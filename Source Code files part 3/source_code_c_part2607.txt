jorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MinorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalog_INTERFACE_DEFINED__ */


#ifndef __IComponentUtil_INTERFACE_DEFINED__
#define __IComponentUtil_INTERFACE_DEFINED__

/* interface IComponentUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22873-8a19-11d0-81b6-00a0c9231c29")
    IComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallComponent( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponent( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponentByName( 
            /* [in] */ BSTR bstrProgID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCLSIDs( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponentByName )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDs )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);
        
        END_INTERFACE
    } IComponentUtilVtbl;

    interface IComponentUtil
    {
        CONST_VTBL struct IComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComponentUtil_InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)	\
    (This)->lpVtbl -> InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)

#define IComponentUtil_ImportComponent(This,bstrCLSID)	\
    (This)->lpVtbl -> ImportComponent(This,bstrCLSID)

#define IComponentUtil_ImportComponentByName(This,bstrProgID)	\
    (This)->lpVtbl -> ImportComponentByName(This,bstrProgID)

#define IComponentUtil_GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)	\
    (This)->lpVtbl -> GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_InstallComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [in] */ BSTR bstrProxyStubDLLFile);


void __RPC_STUB IComponentUtil_InstallComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IComponentUtil_ImportComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponentByName_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IComponentUtil_ImportComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_GetCLSIDs_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);


void __RPC_STUB IComponentUtil_GetCLSIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IPackageUtil_INTERFACE_DEFINED__
#define __IPackageUtil_INTERFACE_DEFINED__

/* interface IPackageUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPackageUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22874-8a19-11d0-81b6-00a0c9231c29")
    IPackageUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportPackage( 
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownPackage( 
            /* [in] */ BSTR bstrPackageID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPackageUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPackageUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPackageUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPackageUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID);
        
        END_INTERFACE
    } IPackageUtilVtbl;

    interface IPackageUtil
    {
        CONST_VTBL struct IPackageUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPackageUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPackageUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPackageUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPackageUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPackageUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPackageUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPackageUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPackageUtil_InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)	\
    (This)->lpVtbl -> InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)

#define IPackageUtil_ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)	\
    (This)->lpVtbl -> ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)

#define IPackageUtil_ShutdownPackage(This,bstrPackageID)	\
    (This)->lpVtbl -> ShutdownPackage(This,bstrPackageID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_InstallPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ BSTR bstrInstallPath,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ExportPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_ExportPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ShutdownPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID);


void __RPC_STUB IPackageUtil_ShutdownPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPackageUtil_INTERFACE_DEFINED__ */


#ifndef __IRemoteComponentUtil_INTERFACE_DEFINED__
#define __IRemoteComponentUtil_INTERFACE_DEFINED__

/* interface IRemoteComponentUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRemoteComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22875-8a19-11d0-81b6-00a0c9231c29")
    IRemoteComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponent( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponentByName( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponent )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponentByName )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID);
        
        END_INTERFACE
    } IRemoteComponentUtilVtbl;

    interface IRemoteComponentUtil
    {
        CONST_VTBL struct IRemoteComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteComponentUtil_InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)	\
    (This)->lpVtbl -> InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)

#define IRemoteComponentUtil_InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)	\
    (This)->lpVtbl -> InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponent_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponentByName_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageName,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IRoleAssociationUtil_INTERFACE_DEFINED__
#define __IRoleAssociationUtil_INTERFACE_DEFINED__

/* interface IRoleAssociationUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRoleAssociationUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22876-8a19-11d0-81b6-00a0c9231c29")
    IRoleAssociationUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRole( 
            /* [in] */ BSTR bstrRoleID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRoleByName( 
            /* [in] */ BSTR bstrRoleName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRoleAssociationUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRole )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRoleByName )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleName);
        
        END_INTERFACE
    } IRoleAssociationUtilVtbl;

    interface IRoleAssociationUtil
    {
        CONST_VTBL struct IRoleAssociationUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRoleAssociationUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRoleAssociationUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRoleAssociationUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRoleAssociationUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRoleAssociationUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRoleAssociationUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRoleAssociationUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRoleAssociationUtil_AssociateRole(This,bstrRoleID)	\
    (This)->lpVtbl -> AssociateRole(This,bstrRoleID)

#define IRoleAssociationUtil_AssociateRoleByName(This,bstrRoleName)	\
    (This)->lpVtbl -> AssociateRoleByName(This,bstrRoleName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRole_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleID);


void __RPC_STUB IRoleAssociationUtil_AssociateRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRoleByName_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleName);


void __RPC_STUB IRoleAssociationUtil_AssociateRoleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRoleAssociationUtil_INTERFACE_DEFINED__ */



#ifndef __MTSAdmin_LIBRARY_DEFINED__
#define __MTSAdmin_LIBRARY_DEFINED__

/* library MTSAdmin */
/* [helpstring][version][uuid] */ 

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtsadmin_0123_0001
    {	mtsInstallUsers	= 1
    }	MTSPackageInstallOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtsadmin_0123_0002
    {	mtsExportUsers	= 1
    }	MTSPackageExportOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtsadmin_0123_0003
    {	mtsErrObjectErrors	= ( HRESULT  )0x80110401L,
	mtsErrObjectInvalid	= ( HRESULT  )0x80110402L,
	mtsErrKeyMissing	= ( HRESULT  )0x80110403L,
	mtsErrAlreadyInstalled	= ( HRESULT  )0x80110404L,
	mtsErrDownloadFailed	= 0x80110405,
	mtsErrPDFWriteFail	= ( HRESULT  )0x80110407L,
	mtsErrPDFReadFail	= ( HRESULT  )0x80110408L,
	mtsErrPDFVersion	= ( HRESULT  )0x80110409L,
	mtsErrBadPath	= ( HRESULT  )0x8011040aL,
	mtsErrPackageExists	= ( HRESULT  )0x8011040bL,
	mtsErrRoleExists	= ( HRESULT  )0x8011040cL,
	mtsErrCantCopyFile	= ( HRESULT  )0x8011040dL,
	mtsErrNoTypeLib	= 0x8011040e,
	mtsErrNoUser	= ( HRESULT  )0x8011040fL,
	mtsErrInvalidUserids	= ( HRESULT  )0x80110410L,
	mtsErrNoRegistryCLSID	= ( HRESULT  )0x80110411L,
	mtsErrBadRegistryProgID	= ( HRESULT  )0x80110412L,
	mtsErrAuthenticationLevel	= ( HRESULT  )0x80110413L,
	mtsErrUserPasswdNotValid	= ( HRESULT  )0x80110414L,
	mtsErrNoRegistryRead	= 0x80110415,
	mtsErrNoRegistryWrite	= 0x80110416,
	mtsErrNoRegistryRepair	= 0x80110417,
	mtsErrCLSIDOrIIDMismatch	= ( HRESULT  )0x80110418L,
	mtsErrRemoteInterface	= ( HRESULT  )0x80110419L,
	mtsErrDllRegisterServer	= ( HRESULT  )0x8011041aL,
	mtsErrNoServerShare	= ( HRESULT  )0x8011041bL,
	mtsErrNoAccessToUNC	= 0x8011041c,
	mtsErrDllLoadFailed	= ( HRESULT  )0x8011041dL,
	mtsErrBadRegistryLibID	= ( HRESULT  )0x8011041eL,
	mtsErrPackDirNotFound	= ( HRESULT  )0x8011041fL,
	mtsErrTreatAs	= 0x80110420,
	mtsErrBadForward	= 0x80110421,
	mtsErrBadIID	= 0x80110422,
	mtsErrRegistrarFailed	= ( HRESULT  )0x80110423L,
	mtsErrCompFileDoesNotExist	= ( HRESULT  )0x80110424L,
	mtsErrCompFileLoadDLLFail	= ( HRESULT  )0x80110425L,
	mtsErrCompFileGetClassObj	= ( HRESULT  )0x80110426L,
	mtsErrCompFileClassNotAvail	= ( HRESULT  )0x80110427L,
	mtsErrCompFileBadTLB	= ( HRESULT  )0x80110428L,
	mtsErrCompFileNotInstallable	= ( HRESULT  )0x80110429L,
	mtsErrNotChangeable	= ( HRESULT  )0x8011042aL,
	mtsErrNotDeletable	= ( HRESULT  )0x8011042bL,
	mtsErrSession	= ( HRESULT  )0x8011042cL,
	mtsErrCompMoveLocked	= ( HRESULT  )0x8011042dL,
	mtsErrCompMoveBadDest	= ( HRESULT  )0x8011042eL,
	mtsErrRegisterTLB	= ( HRESULT  )0x80110430L,
	mtsErrSystemPack	= ( HRESULT  )0x80110433L,
	mtsErrCompFileNoRegistrar	= ( HRESULT  )0x80110434L,
	mtsErrCoReqCompInstalled	= ( HRESULT  )0x80110435L,
	mtsErrPropSaveFailed	= ( HRESULT  )0x80110437L,
	mtsErrObjectExists	= ( HRESULT  )0x80110438L,
	mtsErrRegFileCorrupt	= ( HRESULT  )0x8011043bL,
	mtsErrPropertyOverflow	= ( HRESULT  )0x8011043cL,
	mtsErrNotInRegistry	= ( HRESULT  )0x8011043eL,
	mtsErrApplidMatchesClsid	= ( HRESULT  )0x80110446L,
	mtsErrRoleDoesNotExist	= ( HRESULT  )0x80110447L,
	mtsErrObjectParentMissing	= ( HRESULT  )0x80110808L,
	mtsErrObjectDoesNotExist	= ( HRESULT  )0x80110809L,
	mtsErrCanNotExportAppProxy	= 0x8011044a,
	mtsErrCanNotExportSystemPack	= 0x8011044c
    }	;

#define E_MTS_OBJECTERRORS		 mtsErrObjectErrors 
#define E_MTS_OBJECTINVALID		 mtsErrObjectInvalid 
#define E_MTS_KEYMISSING		 mtsErrKeyMissing 
#define E_MTS_ALREADYINSTALLED		 mtsErrAlreadyInstalled 
#define E_MTS_DOWNLOADFAILED		 mtsErrDownloadFailed 
#define E_MTS_PDFWRITEFAIL		 mtsErrPDFWriteFail 
#define E_MTS_PDFREADFAIL		 mtsErrPDFReadFail 
#define E_MTS_PDFVERSION		 mtsErrPDFVersion 
#define E_MTS_BADPATH		 mtsErrBadPath 
#define E_MTS_PACKAGEEXISTS		 mtsErrPackageExists 
#define E_MTS_ROLEEXISTS		 mtsErrRoleExists 
#define E_MTS_CANTCOPYFILE		 mtsErrCantCopyFile 
#define E_MTS_NOTYPELIB		 mtsErrNoTypeLib 
#define E_MTS_NOUSER		 mtsErrNoUser 
#define E_MTS_INVALIDUSERIDS		 mtsErrInvalidUserids 
#define E_MTS_NOREGISTRYCLSID		 mtsErrNoRegistryCLSID 
#define E_MTS_BADREGISTRYPROGID		 mtsErrBadRegistryProgID 
#define E_MTS_AUTHENTICATIONLEVEL		 mtsErrAuthenticationLevel 
#define E_MTS_USERPASSWDNOTVALID		 mtsErrUserPasswdNotValid 
#define E_MTS_NOREGISTRYREAD		 mtsErrNoRegistryRead 
#define E_MTS_NOREGISTRYWRITE		 mtsErrNoRegistryWrite 
#define E_MTS_NOREGISTRYREPAIR		 mtsErrNoRegistryRepair 
#define E_MTS_CLSIDORIIDMISMATCH		 mtsErrCLSIDOrIIDMismatch 
#define E_MTS_REMOTEINTERFACE		 mtsErrRemoteInterface 
#define E_MTS_DLLREGISTERSERVER		 mtsErrDllRegisterServer 
#define E_MTS_NOSERVERSHARE		 mtsErrNoServerShare 
#define E_MTS_NOACCESSTOUNC		 mtsErrNoAccessToUNC 
#define E_MTS_DLLLOADFAILED		 mtsErrDllLoadFailed 
#define E_MTS_BADREGISTRYLIBID		 mtsErrBadRegistryLibID 
#define E_MTS_PACKDIRNOTFOUND		 mtsErrPackDirNotFound 
#define E_MTS_TREATAS		 mtsErrTreatAs 
#define E_MTS_BADFORWARD		 mtsErrBadForward 
#define E_MTS_BADIID		 mtsErrBadIID 
#define E_MTS_REGISTRARFAILED		 mtsErrRegistrarFailed 
#define E_MTS_COMPFILE_DOESNOTEXIST		 mtsErrCompFileDoesNotExist 
#define E_MTS_COMPFILE_LOADDLLFAIL		 mtsErrCompFileLoadDLLFail 
#define E_MTS_COMPFILE_GETCLASSOBJ		 mtsErrCompFileGetClassObj 
#define E_MTS_COMPFILE_CLASSNOTAVAIL		 mtsErrCompFileClassNotAvail 
#define E_MTS_COMPFILE_BADTLB		 mtsErrCompFileBadTLB 
#define E_MTS_COMPFILE_NOTINSTALLABLE		 mtsErrCompFileNotInstallable 
#define E_MTS_NOTCHANGEABLE		 mtsErrNotChangeable 
#define E_MTS_NOTDELETEABLE		 mtsErrNotDeletable 
#define E_MTS_SESSION		 mtsErrSession 
#define E_MTS_COMP_MOVE_LOCKED		 mtsErrCompMoveLocked 
#define E_MTS_COMP_MOVE_BAD_DEST		 mtsErrCompMoveBadDest 
#define E_MTS_REGISTERTLB		 mtsErrRegisterTLB 
#define E_MTS_SYSTEMPACK		 mtsErrSystemPack 
#define E_MTS_COMPFILE_NOREGISTRAR		 mtsErrCompFileNoRegistrar 
#define E_MTS_COREQCOMPINSTALLED		 mtsErrCoReqCompInstalled 
#define E_MTS_PROPERTYSAVEFAILED		 mtsErrPropSaveFailed 
#define E_MTS_OBJECTEXISTS		 mtsErrObjectExists 
#define E_MTS_REGFILE_CORRUPT		 mtsErrRegFileCorrupt 
#define E_MTS_PROPERTY_OVERFLOW		 mtsErrPropertyOverflow 
#define E_MTS_NOTINREGISTRY		 mtsErrNotInRegistry 
#define E_MTS_APPLID_MATCHES_CLSID		 mtsErrApplidMatchesClsid 
#define E_MTS_ROLE_DOES_NOT_EXIST		 mtsErrRoleDoesNotExist 
#define E_MTS_OBJECT_PARENT_MISSING		 mtsErrObjectParentMissing 
#define E_MTS_OBJECT_DOES_NOT_EXIST		 mtsErrObjectDoesNotExist 
#define E_MTS_CAN_NOT_EXPORT_APP_PROXY   mtsErrCanNotExportAppProxy	
#define E_MTS_CAN_NOT_EXPORT_SYSTEM_PACK   mtsErrCanNotExportSystemPack

EXTERN_C const IID LIBID_MTSAdmin;

EXTERN_C const CLSID CLSID_Catalog;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22881-8a19-11d0-81b6-00a0c9231c29")
Catalog;
#endif

EXTERN_C const CLSID CLSID_CatalogObject;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22882-8a19-11d0-81b6-00a0c9231c29")
CatalogObject;
#endif

EXTERN_C const CLSID CLSID_CatalogCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22883-8a19-11d0-81b6-00a0c9231c29")
CatalogCollection;
#endif

EXTERN_C const CLSID CLSID_ComponentUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22884-8a19-11d0-81b6-00a0c9231c29")
ComponentUtil;
#endif

EXTERN_C const CLSID CLSID_PackageUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22885-8a19-11d0-81b6-00a0c9231c29")
PackageUtil;
#endif

EXTERN_C const CLSID CLSID_RemoteComponentUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22886-8a19-11d0-81b6-00a0c9231c29")
RemoteComponentUtil;
#endif

EXTERN_C const CLSID CLSID_RoleAssociationUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22887-8a19-11d0-81b6-00a0c9231c29")
RoleAssociationUtil;
#endif
#endif /* __MTSAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\msxml.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Sep 24 19:26:13 1999
 */
/* Compiler settings for msxml.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __msxml_h__
#define __msxml_h__

/* Forward Declarations */ 

#ifndef __IXMLDOMImplementation_FWD_DEFINED__
#define __IXMLDOMImplementation_FWD_DEFINED__
typedef interface IXMLDOMImplementation IXMLDOMImplementation;
#endif 	/* __IXMLDOMImplementation_FWD_DEFINED__ */


#ifndef __IXMLDOMNode_FWD_DEFINED__
#define __IXMLDOMNode_FWD_DEFINED__
typedef interface IXMLDOMNode IXMLDOMNode;
#endif 	/* __IXMLDOMNode_FWD_DEFINED__ */


#ifndef __IXMLDOMDocumentFragment_FWD_DEFINED__
#define __IXMLDOMDocumentFragment_FWD_DEFINED__
typedef interface IXMLDOMDocumentFragment IXMLDOMDocumentFragment;
#endif 	/* __IXMLDOMDocumentFragment_FWD_DEFINED__ */


#ifndef __IXMLDOMDocument_FWD_DEFINED__
#define __IXMLDOMDocument_FWD_DEFINED__
typedef interface IXMLDOMDocument IXMLDOMDocument;
#endif 	/* __IXMLDOMDocument_FWD_DEFINED__ */


#ifndef __IXMLDOMNodeList_FWD_DEFINED__
#define __IXMLDOMNodeList_FWD_DEFINED__
typedef interface IXMLDOMNodeList IXMLDOMNodeList;
#endif 	/* __IXMLDOMNodeList_FWD_DEFINED__ */


#ifndef __IXMLDOMNamedNodeMap_FWD_DEFINED__
#define __IXMLDOMNamedNodeMap_FWD_DEFINED__
typedef interface IXMLDOMNamedNodeMap IXMLDOMNamedNodeMap;
#endif 	/* __IXMLDOMNamedNodeMap_FWD_DEFINED__ */


#ifndef __IXMLDOMCharacterData_FWD_DEFINED__
#define __IXMLDOMCharacterData_FWD_DEFINED__
typedef interface IXMLDOMCharacterData IXMLDOMCharacterData;
#endif 	/* __IXMLDOMCharacterData_FWD_DEFINED__ */


#ifndef __IXMLDOMAttribute_FWD_DEFINED__
#define __IXMLDOMAttribute_FWD_DEFINED__
typedef interface IXMLDOMAttribute IXMLDOMAttribute;
#endif 	/* __IXMLDOMAttribute_FWD_DEFINED__ */


#ifndef __IXMLDOMElement_FWD_DEFINED__
#define __IXMLDOMElement_FWD_DEFINED__
typedef interface IXMLDOMElement IXMLDOMElement;
#endif 	/* __IXMLDOMElement_FWD_DEFINED__ */


#ifndef __IXMLDOMText_FWD_DEFINED__
#define __IXMLDOMText_FWD_DEFINED__
typedef interface IXMLDOMText IXMLDOMText;
#endif 	/* __IXMLDOMText_FWD_DEFINED__ */


#ifndef __IXMLDOMComment_FWD_DEFINED__
#define __IXMLDOMComment_FWD_DEFINED__
typedef interface IXMLDOMComment IXMLDOMComment;
#endif 	/* __IXMLDOMComment_FWD_DEFINED__ */


#ifndef __IXMLDOMProcessingInstruction_FWD_DEFINED__
#define __IXMLDOMProcessingInstruction_FWD_DEFINED__
typedef interface IXMLDOMProcessingInstruction IXMLDOMProcessingInstruction;
#endif 	/* __IXMLDOMProcessingInstruction_FWD_DEFINED__ */


#ifndef __IXMLDOMCDATASection_FWD_DEFINED__
#define __IXMLDOMCDATASection_FWD_DEFINED__
typedef interface IXMLDOMCDATASection IXMLDOMCDATASection;
#endif 	/* __IXMLDOMCDATASection_FWD_DEFINED__ */


#ifndef __IXMLDOMDocumentType_FWD_DEFINED__
#define __IXMLDOMDocumentType_FWD_DEFINED__
typedef interface IXMLDOMDocumentType IXMLDOMDocumentType;
#endif 	/* __IXMLDOMDocumentType_FWD_DEFINED__ */


#ifndef __IXMLDOMNotation_FWD_DEFINED__
#define __IXMLDOMNotation_FWD_DEFINED__
typedef interface IXMLDOMNotation IXMLDOMNotation;
#endif 	/* __IXMLDOMNotation_FWD_DEFINED__ */


#ifndef __IXMLDOMEntity_FWD_DEFINED__
#define __IXMLDOMEntity_FWD_DEFINED__
typedef interface IXMLDOMEntity IXMLDOMEntity;
#endif 	/* __IXMLDOMEntity_FWD_DEFINED__ */


#ifndef __IXMLDOMEntityReference_FWD_DEFINED__
#define __IXMLDOMEntityReference_FWD_DEFINED__
typedef interface IXMLDOMEntityReference IXMLDOMEntityReference;
#endif 	/* __IXMLDOMEntityReference_FWD_DEFINED__ */


#ifndef __IXMLDOMParseError_FWD_DEFINED__
#define __IXMLDOMParseError_FWD_DEFINED__
typedef interface IXMLDOMParseError IXMLDOMParseError;
#endif 	/* __IXMLDOMParseError_FWD_DEFINED__ */


#ifndef __IXTLRuntime_FWD_DEFINED__
#define __IXTLRuntime_FWD_DEFINED__
typedef interface IXTLRuntime IXTLRuntime;
#endif 	/* __IXTLRuntime_FWD_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_FWD_DEFINED__
#define __XMLDOMDocumentEvents_FWD_DEFINED__
typedef interface XMLDOMDocumentEvents XMLDOMDocumentEvents;
#endif 	/* __XMLDOMDocumentEvents_FWD_DEFINED__ */


#ifndef __DOMDocument_FWD_DEFINED__
#define __DOMDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMDocument DOMDocument;
#else
typedef struct DOMDocument DOMDocument;
#endif /* __cplusplus */

#endif 	/* __DOMDocument_FWD_DEFINED__ */


#ifndef __DOMFreeThreadedDocument_FWD_DEFINED__
#define __DOMFreeThreadedDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMFreeThreadedDocument DOMFreeThreadedDocument;
#else
typedef struct DOMFreeThreadedDocument DOMFreeThreadedDocument;
#endif /* __cplusplus */

#endif 	/* __DOMFreeThreadedDocument_FWD_DEFINED__ */


#ifndef __IXMLHttpRequest_FWD_DEFINED__
#define __IXMLHttpRequest_FWD_DEFINED__
typedef interface IXMLHttpRequest IXMLHttpRequest;
#endif 	/* __IXMLHttpRequest_FWD_DEFINED__ */


#ifndef __XMLHTTPRequest_FWD_DEFINED__
#define __XMLHTTPRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLHTTPRequest XMLHTTPRequest;
#else
typedef struct XMLHTTPRequest XMLHTTPRequest;
#endif /* __cplusplus */

#endif 	/* __XMLHTTPRequest_FWD_DEFINED__ */


#ifndef __IXMLDSOControl_FWD_DEFINED__
#define __IXMLDSOControl_FWD_DEFINED__
typedef interface IXMLDSOControl IXMLDSOControl;
#endif 	/* __IXMLDSOControl_FWD_DEFINED__ */


#ifndef __XMLDSOControl_FWD_DEFINED__
#define __XMLDSOControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLDSOControl XMLDSOControl;
#else
typedef struct XMLDSOControl XMLDSOControl;
#endif /* __cplusplus */

#endif 	/* __XMLDSOControl_FWD_DEFINED__ */


#ifndef __IXMLElementCollection_FWD_DEFINED__
#define __IXMLElementCollection_FWD_DEFINED__
typedef interface IXMLElementCollection IXMLElementCollection;
#endif 	/* __IXMLElementCollection_FWD_DEFINED__ */


#ifndef __IXMLDocument_FWD_DEFINED__
#define __IXMLDocument_FWD_DEFINED__
typedef interface IXMLDocument IXMLDocument;
#endif 	/* __IXMLDocument_FWD_DEFINED__ */


#ifndef __IXMLDocument2_FWD_DEFINED__
#define __IXMLDocument2_FWD_DEFINED__
typedef interface IXMLDocument2 IXMLDocument2;
#endif 	/* __IXMLDocument2_FWD_DEFINED__ */


#ifndef __IXMLElement_FWD_DEFINED__
#define __IXMLElement_FWD_DEFINED__
typedef interface IXMLElement IXMLElement;
#endif 	/* __IXMLElement_FWD_DEFINED__ */


#ifndef __IXMLElement2_FWD_DEFINED__
#define __IXMLElement2_FWD_DEFINED__
typedef interface IXMLElement2 IXMLElement2;
#endif 	/* __IXMLElement2_FWD_DEFINED__ */


#ifndef __IXMLAttribute_FWD_DEFINED__
#define __IXMLAttribute_FWD_DEFINED__
typedef interface IXMLAttribute IXMLAttribute;
#endif 	/* __IXMLAttribute_FWD_DEFINED__ */


#ifndef __IXMLError_FWD_DEFINED__
#define __IXMLError_FWD_DEFINED__
typedef interface IXMLError IXMLError;
#endif 	/* __IXMLError_FWD_DEFINED__ */


#ifndef __XMLDocument_FWD_DEFINED__
#define __XMLDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLDocument XMLDocument;
#else
typedef struct XMLDocument XMLDocument;
#endif /* __cplusplus */

#endif 	/* __XMLDocument_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_msxml_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//--------------------------------------------------------------------------
typedef struct _xml_error
    {
    unsigned int _nLine;
    BSTR _pchBuf;
    unsigned int _cchBuf;
    unsigned int _ich;
    BSTR _pszFound;
    BSTR _pszExpected;
    DWORD _reserved1;
    DWORD _reserved2;
    }	XML_ERROR;



extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_v0_0_s_ifspec;


#ifndef __MSXML_LIBRARY_DEFINED__
#define __MSXML_LIBRARY_DEFINED__

/* library MSXML */
/* [version][lcid][helpstring][uuid] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999.
//
//--------------------------------------------------------------------------



















typedef /* [helpstring] */ 
enum tagDOMNodeType
    {	NODE_INVALID	= 0,
	NODE_ELEMENT	= NODE_INVALID + 1,
	NODE_ATTRIBUTE	= NODE_ELEMENT + 1,
	NODE_TEXT	= NODE_ATTRIBUTE + 1,
	NODE_CDATA_SECTION	= NODE_TEXT + 1,
	NODE_ENTITY_REFERENCE	= NODE_CDATA_SECTION + 1,
	NODE_ENTITY	= NODE_ENTITY_REFERENCE + 1,
	NODE_PROCESSING_INSTRUCTION	= NODE_ENTITY + 1,
	NODE_COMMENT	= NODE_PROCESSING_INSTRUCTION + 1,
	NODE_DOCUMENT	= NODE_COMMENT + 1,
	NODE_DOCUMENT_TYPE	= NODE_DOCUMENT + 1,
	NODE_DOCUMENT_FRAGMENT	= NODE_DOCUMENT_TYPE + 1,
	NODE_NOTATION	= NODE_DOCUMENT_FRAGMENT + 1
    }	DOMNodeType;

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999.
//
//--------------------------------------------------------------------------









typedef /* [helpstring] */ 
enum tagXMLEMEM_TYPE
    {	XMLELEMTYPE_ELEMENT	= 0,
	XMLELEMTYPE_TEXT	= XMLELEMTYPE_ELEMENT + 1,
	XMLELEMTYPE_COMMENT	= XMLELEMTYPE_TEXT + 1,
	XMLELEMTYPE_DOCUMENT	= XMLELEMTYPE_COMMENT + 1,
	XMLELEMTYPE_DTD	= XMLELEMTYPE_DOCUMENT + 1,
	XMLELEMTYPE_PI	= XMLELEMTYPE_DTD + 1,
	XMLELEMTYPE_OTHER	= XMLELEMTYPE_PI + 1
    }	XMLELEM_TYPE;


EXTERN_C const IID LIBID_MSXML;

#ifndef __IXMLDOMImplementation_INTERFACE_DEFINED__
#define __IXMLDOMImplementation_INTERFACE_DEFINED__

/* interface IXMLDOMImplementation */
/* [uuid][dual][oleautomation][unique][nonextensible][object][local] */ 


EXTERN_C const IID IID_IXMLDOMImplementation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8F-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMImplementation : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE hasFeature( 
            /* [in] */ BSTR feature,
            /* [in] */ BSTR version,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasFeature) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMImplementationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMImplementation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMImplementation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMImplementation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMImplementation __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMImplementation __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMImplementation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMImplementation __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasFeature )( 
            IXMLDOMImplementation __RPC_FAR * This,
            /* [in] */ BSTR feature,
            /* [in] */ BSTR version,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasFeature);
        
        END_INTERFACE
    } IXMLDOMImplementationVtbl;

    interface IXMLDOMImplementation
    {
        CONST_VTBL struct IXMLDOMImplementationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMImplementation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMImplementation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMImplementation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMImplementation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMImplementation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMImplementation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMImplementation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMImplementation_hasFeature(This,feature,version,hasFeature)	\
    (This)->lpVtbl -> hasFeature(This,feature,version,hasFeature)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMImplementation_hasFeature_Proxy( 
    IXMLDOMImplementation __RPC_FAR * This,
    /* [in] */ BSTR feature,
    /* [in] */ BSTR version,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasFeature);


void __RPC_STUB IXMLDOMImplementation_hasFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMImplementation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNode_INTERFACE_DEFINED__
#define __IXMLDOMNode_INTERFACE_DEFINED__

/* interface IXMLDOMNode */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF80-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNode : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeValue( 
            /* [retval][out] */ VARIANT __RPC_FAR *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_nodeValue( 
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeType( 
            /* [retval][out] */ DOMNodeType __RPC_FAR *type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parentNode( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_childNodes( 
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_firstChild( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lastChild( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_previousSibling( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nextSibling( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE insertBefore( 
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE replaceChild( 
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE appendChild( 
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE hasChildNodes( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ownerDocument( 
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE cloneNode( 
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeTypeString( 
            /* [out][retval] */ BSTR __RPC_FAR *nodeType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *text) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR text) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_specified( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_definition( 
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeTypedValue( 
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_nodeTypedValue( 
            /* [in] */ VARIANT typedValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_dataType( 
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_dataType( 
            /* [in] */ BSTR dataTypeName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_xml( 
            /* [out][retval] */ BSTR __RPC_FAR *xmlString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transformNode( 
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE selectNodes( 
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE selectSingleNode( 
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parsed( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_namespaceURI( 
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_prefix( 
            /* [out][retval] */ BSTR __RPC_FAR *prefixString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_baseName( 
            /* [out][retval] */ BSTR __RPC_FAR *nameString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transformNodeToObject( 
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMNode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMNode __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMNodeVtbl;

    interface IXMLDOMNode
    {
        CONST_VTBL struct IXMLDOMNodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNode_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMNode_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMNode_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMNode_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMNode_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMNode_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMNode_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMNode_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMNode_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMNode_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMNode_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMNode_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMNode_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMNode_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMNode_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMNode_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMNode_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMNode_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMNode_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMNode_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMNode_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMNode_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMNode_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMNode_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMNode_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMNode_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMNode_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMNode_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMNode_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMNode_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMNode_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMNode_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMNode_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMNode_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMNode_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMNode_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeName_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *name);


void __RPC_STUB IXMLDOMNode_get_nodeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeValue_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *value);


void __RPC_STUB IXMLDOMNode_get_nodeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_nodeValue_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMNode_put_nodeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeType_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ DOMNodeType __RPC_FAR *type);


void __RPC_STUB IXMLDOMNode_get_nodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_parentNode_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);


void __RPC_STUB IXMLDOMNode_get_parentNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_childNodes_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);


void __RPC_STUB IXMLDOMNode_get_childNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_firstChild_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);


void __RPC_STUB IXMLDOMNode_get_firstChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_lastChild_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);


void __RPC_STUB IXMLDOMNode_get_lastChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_previousSibling_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);


void __RPC_STUB IXMLDOMNode_get_previousSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nextSibling_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);


void __RPC_STUB IXMLDOMNode_get_nextSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_attributes_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);


void __RPC_STUB IXMLDOMNode_get_attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_insertBefore_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
    /* [in] */ VARIANT refChild,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);


void __RPC_STUB IXMLDOMNode_insertBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_replaceChild_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
    /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);


void __RPC_STUB IXMLDOMNode_replaceChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_removeChild_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);


void __RPC_STUB IXMLDOMNode_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_appendChild_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);


void __RPC_STUB IXMLDOMNode_appendChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_hasChildNodes_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);


void __RPC_STUB IXMLDOMNode_hasChildNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_ownerDocument_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);


void __RPC_STUB IXMLDOMNode_get_ownerDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_cloneNode_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL deep,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);


void __RPC_STUB IXMLDOMNode_cloneNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeTypeString_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *nodeType);


void __RPC_STUB IXMLDOMNode_get_nodeTypeString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_text_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *text);


void __RPC_STUB IXMLDOMNode_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_text_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ BSTR text);


void __RPC_STUB IXMLDOMNode_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_specified_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);


void __RPC_STUB IXMLDOMNode_get_specified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_definition_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);


void __RPC_STUB IXMLDOMNode_get_definition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeTypedValue_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *typedValue);


void __RPC_STUB IXMLDOMNode_get_nodeTypedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_nodeTypedValue_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ VARIANT typedValue);


void __RPC_STUB IXMLDOMNode_put_nodeTypedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_dataType_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);


void __RPC_STUB IXMLDOMNode_get_dataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_dataType_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ BSTR dataTypeName);


void __RPC_STUB IXMLDOMNode_put_dataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_xml_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *xmlString);


void __RPC_STUB IXMLDOMNode_get_xml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_transformNode_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
    /* [out][retval] */ BSTR __RPC_FAR *xmlString);


void __RPC_STUB IXMLDOMNode_transformNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_selectNodes_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ BSTR queryString,
    /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);


void __RPC_STUB IXMLDOMNode_selectNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_selectSingleNode_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ BSTR queryString,
    /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);


void __RPC_STUB IXMLDOMNode_selectSingleNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_parsed_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);


void __RPC_STUB IXMLDOMNode_get_parsed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_namespaceURI_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);


void __RPC_STUB IXMLDOMNode_get_namespaceURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_prefix_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *prefixString);


void __RPC_STUB IXMLDOMNode_get_prefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_baseName_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *nameString);


void __RPC_STUB IXMLDOMNode_get_baseName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_transformNodeToObject_Proxy( 
    IXMLDOMNode __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
    /* [in] */ VARIANT outputObject);


void __RPC_STUB IXMLDOMNode_transformNodeToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNode_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocumentFragment_INTERFACE_DEFINED__
#define __IXMLDOMDocumentFragment_INTERFACE_DEFINED__

/* interface IXMLDOMDocumentFragment */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocumentFragment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa413-272f-11d2-836f-0000f87a7782")
    IXMLDOMDocumentFragment : public IXMLDOMNode
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentFragmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMDocumentFragment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMDocumentFragment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMDocumentFragment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMDocumentFragmentVtbl;

    interface IXMLDOMDocumentFragment
    {
        CONST_VTBL struct IXMLDOMDocumentFragmentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocumentFragment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocumentFragment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocumentFragment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocumentFragment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocumentFragment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocumentFragment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocumentFragment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocumentFragment_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocumentFragment_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocumentFragment_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocumentFragment_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocumentFragment_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocumentFragment_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocumentFragment_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocumentFragment_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocumentFragment_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocumentFragment_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocumentFragment_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocumentFragment_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocumentFragment_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocumentFragment_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocumentFragment_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocumentFragment_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocumentFragment_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocumentFragment_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocumentFragment_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocumentFragment_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocumentFragment_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocumentFragment_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocumentFragment_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocumentFragment_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentFragment_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentFragment_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocumentFragment_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocumentFragment_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocumentFragment_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocumentFragment_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocumentFragment_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocumentFragment_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocumentFragment_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocumentFragment_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocumentFragment_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocumentFragment_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMDocumentFragment_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocument_INTERFACE_DEFINED__
#define __IXMLDOMDocument_INTERFACE_DEFINED__

/* interface IXMLDOMDocument */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF81-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocument : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [retval][out] */ IXMLDOMDocumentType __RPC_FAR *__RPC_FAR *documentType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_implementation( 
            /* [retval][out] */ IXMLDOMImplementation __RPC_FAR *__RPC_FAR *impl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_documentElement( 
            /* [retval][out] */ IXMLDOMElement __RPC_FAR *__RPC_FAR *DOMElement) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_documentElement( 
            /* [in] */ IXMLDOMElement __RPC_FAR *DOMElement) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement __RPC_FAR *__RPC_FAR *element) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createDocumentFragment( 
            /* [retval][out] */ IXMLDOMDocumentFragment __RPC_FAR *__RPC_FAR *docFrag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createTextNode( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *text) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createComment( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment __RPC_FAR *__RPC_FAR *comment) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createCDATASection( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection __RPC_FAR *__RPC_FAR *cdata) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createProcessingInstruction( 
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction __RPC_FAR *__RPC_FAR *pi) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createAttribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attribute) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createEntityReference( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference __RPC_FAR *__RPC_FAR *entityRef) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getElementsByTagName( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createNode( 
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *node) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nodeFromID( 
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *node) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long __RPC_FAR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parseError( 
            /* [out][retval] */ IXMLDOMParseError __RPC_FAR *__RPC_FAR *errorObj) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR __RPC_FAR *urlString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_async( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isAsync) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_async( 
            /* [in] */ VARIANT_BOOL isAsync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE loadXML( 
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ VARIANT desination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_validateOnParse( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isValidating) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_validateOnParse( 
            /* [in] */ VARIANT_BOOL isValidating) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_resolveExternals( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isResolving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_resolveExternals( 
            /* [in] */ VARIANT_BOOL isResolving) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_preserveWhiteSpace( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isPreserving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_preserveWhiteSpace( 
            /* [in] */ VARIANT_BOOL isPreserving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ VARIANT readystatechangeSink) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ondataavailable( 
            /* [in] */ VARIANT ondataavailableSink) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ontransformnode( 
            /* [in] */ VARIANT ontransformnodeSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_doctype )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocumentType __RPC_FAR *__RPC_FAR *documentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_implementation )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMImplementation __RPC_FAR *__RPC_FAR *impl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_documentElement )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMElement __RPC_FAR *__RPC_FAR *DOMElement);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_documentElement )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ IXMLDOMElement __RPC_FAR *DOMElement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createElement )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement __RPC_FAR *__RPC_FAR *element);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createDocumentFragment )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocumentFragment __RPC_FAR *__RPC_FAR *docFrag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createTextNode )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *text);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createComment )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment __RPC_FAR *__RPC_FAR *comment);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createCDATASection )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection __RPC_FAR *__RPC_FAR *cdata);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createProcessingInstruction )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction __RPC_FAR *__RPC_FAR *pi);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createAttribute )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createEntityReference )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference __RPC_FAR *__RPC_FAR *entityRef);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getElementsByTagName )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createNode )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *nodeFromID )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *load )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parseError )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMParseError __RPC_FAR *__RPC_FAR *errorObj);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_url )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_async )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isAsync);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_async )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL isAsync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *abort )( 
            IXMLDOMDocument __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *loadXML )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *save )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT desination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_validateOnParse )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isValidating);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_validateOnParse )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL isValidating);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_resolveExternals )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isResolving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_resolveExternals )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL isResolving);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_preserveWhiteSpace )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_preserveWhiteSpace )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onreadystatechange )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT readystatechangeSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ondataavailable )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT ondataavailableSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ontransformnode )( 
            IXMLDOMDocument __RPC_FAR * This,
            /* [in] */ VARIANT ontransformnodeSink);
        
        END_INTERFACE
    } IXMLDOMDocumentVtbl;

    interface IXMLDOMDocument
    {
        CONST_VTBL struct IXMLDOMDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocument_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocument_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocument_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocument_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocument_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocument_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocument_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocument_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocument_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocument_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocument_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocument_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocument_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocument_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocument_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocument_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocument_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocument_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocument_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocument_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocument_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocument_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocument_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocument_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocument_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocument_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocument_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocument_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocument_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocument_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocument_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocument_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocument_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocument_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocument_get_doctype(This,documentType)	\
    (This)->lpVtbl -> get_doctype(This,documentType)

#define IXMLDOMDocument_get_implementation(This,impl)	\
    (This)->lpVtbl -> get_implementation(This,impl)

#define IXMLDOMDocument_get_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> get_documentElement(This,DOMElement)

#define IXMLDOMDocument_putref_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> putref_documentElement(This,DOMElement)

#define IXMLDOMDocument_createElement(This,tagName,element)	\
    (This)->lpVtbl -> createElement(This,tagName,element)

#define IXMLDOMDocument_createDocumentFragment(This,docFrag)	\
    (This)->lpVtbl -> createDocumentFragment(This,docFrag)

#define IXMLDOMDocument_createTextNode(This,data,text)	\
    (This)->lpVtbl -> createTextNode(This,data,text)

#define IXMLDOMDocument_createComment(This,data,comment)	\
    (This)->lpVtbl -> createComment(This,data,comment)

#define IXMLDOMDocument_createCDATASection(This,data,cdata)	\
    (This)->lpVtbl -> createCDATASection(This,data,cdata)

#define IXMLDOMDocument_createProcessingInstruction(This,target,data,pi)	\
    (This)->lpVtbl -> createProcessingInstruction(This,target,data,pi)

#define IXMLDOMDocument_createAttribute(This,name,attribute)	\
    (This)->lpVtbl -> createAttribute(This,name,attribute)

#define IXMLDOMDocument_createEntityReference(This,name,entityRef)	\
    (This)->lpVtbl -> createEntityReference(This,name,entityRef)

#define IXMLDOMDocument_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMDocument_createNode(This,Type,name,namespaceURI,node)	\
    (This)->lpVtbl -> createNode(This,Type,name,namespaceURI,node)

#define IXMLDOMDocument_nodeFromID(This,idString,node)	\
    (This)->lpVtbl -> nodeFromID(This,idString,node)

#define IXMLDOMDocument_load(This,xmlSource,isSuccessful)	\
    (This)->lpVtbl -> load(This,xmlSource,isSuccessful)

#define IXMLDOMDocument_get_readyState(This,value)	\
    (This)->lpVtbl -> get_readyState(This,value)

#define IXMLDOMDocument_get_parseError(This,errorObj)	\
    (This)->lpVtbl -> get_parseError(This,errorObj)

#define IXMLDOMDocument_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMDocument_get_async(This,isAsync)	\
    (This)->lpVtbl -> get_async(This,isAsync)

#define IXMLDOMDocument_put_async(This,isAsync)	\
    (This)->lpVtbl -> put_async(This,isAsync)

#define IXMLDOMDocument_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLDOMDocument_loadXML(This,bstrXML,isSuccessful)	\
    (This)->lpVtbl -> loadXML(This,bstrXML,isSuccessful)

#define IXMLDOMDocument_save(This,desination)	\
    (This)->lpVtbl -> save(This,desination)

#define IXMLDOMDocument_get_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> get_validateOnParse(This,isValidating)

#define IXMLDOMDocument_put_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> put_validateOnParse(This,isValidating)

#define IXMLDOMDocument_get_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> get_resolveExternals(This,isResolving)

#define IXMLDOMDocument_put_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> put_resolveExternals(This,isResolving)

#define IXMLDOMDocument_get_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> get_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument_put_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> put_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument_put_onreadystatechange(This,readystatechangeSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,readystatechangeSink)

#define IXMLDOMDocument_put_ondataavailable(This,ondataavailableSink)	\
    (This)->lpVtbl -> put_ondataavailable(This,ondataavailableSink)

#define IXMLDOMDocument_put_ontransformnode(This,ontransformnodeSink)	\
    (This)->lpVtbl -> put_ontransformnode(This,ontransformnodeSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_doctype_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMDocumentType __RPC_FAR *__RPC_FAR *documentType);


void __RPC_STUB IXMLDOMDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_implementation_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMImplementation __RPC_FAR *__RPC_FAR *impl);


void __RPC_STUB IXMLDOMDocument_get_implementation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_documentElement_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMElement __RPC_FAR *__RPC_FAR *DOMElement);


void __RPC_STUB IXMLDOMDocument_get_documentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_putref_documentElement_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ IXMLDOMElement __RPC_FAR *DOMElement);


void __RPC_STUB IXMLDOMDocument_putref_documentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createElement_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMElement __RPC_FAR *__RPC_FAR *element);


void __RPC_STUB IXMLDOMDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createDocumentFragment_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMDocumentFragment __RPC_FAR *__RPC_FAR *docFrag);


void __RPC_STUB IXMLDOMDocument_createDocumentFragment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createTextNode_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *text);


void __RPC_STUB IXMLDOMDocument_createTextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createComment_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMComment __RPC_FAR *__RPC_FAR *comment);


void __RPC_STUB IXMLDOMDocument_createComment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createCDATASection_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMCDATASection __RPC_FAR *__RPC_FAR *cdata);


void __RPC_STUB IXMLDOMDocument_createCDATASection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createProcessingInstruction_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR target,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMProcessingInstruction __RPC_FAR *__RPC_FAR *pi);


void __RPC_STUB IXMLDOMDocument_createProcessingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createAttribute_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attribute);


void __RPC_STUB IXMLDOMDocument_createAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createEntityReference_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMEntityReference __RPC_FAR *__RPC_FAR *entityRef);


void __RPC_STUB IXMLDOMDocument_createEntityReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_getElementsByTagName_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);


void __RPC_STUB IXMLDOMDocument_getElementsByTagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createNode_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT Type,
    /* [in] */ BSTR name,
    /* [in] */ BSTR namespaceURI,
    /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *node);


void __RPC_STUB IXMLDOMDocument_createNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_nodeFromID_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR idString,
    /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *node);


void __RPC_STUB IXMLDOMDocument_nodeFromID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_load_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT xmlSource,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful);


void __RPC_STUB IXMLDOMDocument_load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_readyState_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *value);


void __RPC_STUB IXMLDOMDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_parseError_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [out][retval] */ IXMLDOMParseError __RPC_FAR *__RPC_FAR *errorObj);


void __RPC_STUB IXMLDOMDocument_get_parseError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_url_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *urlString);


void __RPC_STUB IXMLDOMDocument_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_async_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isAsync);


void __RPC_STUB IXMLDOMDocument_get_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_async_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL isAsync);


void __RPC_STUB IXMLDOMDocument_put_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_abort_Proxy( 
    IXMLDOMDocument __RPC_FAR * This);


void __RPC_STUB IXMLDOMDocument_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_loadXML_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ BSTR bstrXML,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful);


void __RPC_STUB IXMLDOMDocument_loadXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_save_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT desination);


void __RPC_STUB IXMLDOMDocument_save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_validateOnParse_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isValidating);


void __RPC_STUB IXMLDOMDocument_get_validateOnParse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_validateOnParse_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL isValidating);


void __RPC_STUB IXMLDOMDocument_put_validateOnParse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_resolveExternals_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isResolving);


void __RPC_STUB IXMLDOMDocument_get_resolveExternals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_resolveExternals_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL isResolving);


void __RPC_STUB IXMLDOMDocument_put_resolveExternals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_preserveWhiteSpace_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isPreserving);


void __RPC_STUB IXMLDOMDocument_get_preserveWhiteSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_preserveWhiteSpace_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL isPreserving);


void __RPC_STUB IXMLDOMDocument_put_preserveWhiteSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_onreadystatechange_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT readystatechangeSink);


void __RPC_STUB IXMLDOMDocument_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_ondataavailable_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT ondataavailableSink);


void __RPC_STUB IXMLDOMDocument_put_ondataavailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_ontransformnode_Proxy( 
    IXMLDOMDocument __RPC_FAR * This,
    /* [in] */ VARIANT ontransformnodeSink);


void __RPC_STUB IXMLDOMDocument_put_ontransformnode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNodeList_INTERFACE_DEFINED__
#define __IXMLDOMNodeList_INTERFACE_DEFINED__

/* interface IXMLDOMNodeList */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNodeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF82-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNodeList : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *listItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long __RPC_FAR *listLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nextNode( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNodeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMNodeList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMNodeList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_item )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *nextNode )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *reset )( 
            IXMLDOMNodeList __RPC_FAR * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IXMLDOMNodeList __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        END_INTERFACE
    } IXMLDOMNodeListVtbl;

    interface IXMLDOMNodeList
    {
        CONST_VTBL struct IXMLDOMNodeListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNodeList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNodeList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNodeList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNodeList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNodeList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNodeList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNodeList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNodeList_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMNodeList_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMNodeList_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMNodeList_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMNodeList_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get_item_Proxy( 
    IXMLDOMNodeList __RPC_FAR * This,
    /* [in] */ long index,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *listItem);


void __RPC_STUB IXMLDOMNodeList_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get_length_Proxy( 
    IXMLDOMNodeList __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *listLength);


void __RPC_STUB IXMLDOMNodeList_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_nextNode_Proxy( 
    IXMLDOMNodeList __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextItem);


void __RPC_STUB IXMLDOMNodeList_nextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_reset_Proxy( 
    IXMLDOMNodeList __RPC_FAR * This);


void __RPC_STUB IXMLDOMNodeList_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get__newEnum_Proxy( 
    IXMLDOMNodeList __RPC_FAR * This,
    /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IXMLDOMNodeList_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNodeList_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__
#define __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__

/* interface IXMLDOMNamedNodeMap */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNamedNodeMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF83-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNamedNodeMap : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getNamedItem( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *namedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setNamedItem( 
            /* [in] */ IXMLDOMNode __RPC_FAR *newItem,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nameItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeNamedItem( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *namedItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *listItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long __RPC_FAR *listLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getQualifiedItem( 
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *qualifiedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeQualifiedItem( 
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *qualifiedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nextNode( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNamedNodeMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getNamedItem )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *namedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setNamedItem )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newItem,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nameItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeNamedItem )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *namedItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_item )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getQualifiedItem )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *qualifiedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeQualifiedItem )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *qualifiedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *nextNode )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *reset )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IXMLDOMNamedNodeMap __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        END_INTERFACE
    } IXMLDOMNamedNodeMapVtbl;

    interface IXMLDOMNamedNodeMap
    {
        CONST_VTBL struct IXMLDOMNamedNodeMapVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNamedNodeMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNamedNodeMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNamedNodeMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNamedNodeMap_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNamedNodeMap_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNamedNodeMap_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNamedNodeMap_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNamedNodeMap_getNamedItem(This,name,namedItem)	\
    (This)->lpVtbl -> getNamedItem(This,name,namedItem)

#define IXMLDOMNamedNodeMap_setNamedItem(This,newItem,nameItem)	\
    (This)->lpVtbl -> setNamedItem(This,newItem,nameItem)

#define IXMLDOMNamedNodeMap_removeNamedItem(This,name,namedItem)	\
    (This)->lpVtbl -> removeNamedItem(This,name,namedItem)

#define IXMLDOMNamedNodeMap_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMNamedNodeMap_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMNamedNodeMap_getQualifiedItem(This,baseName,namespaceURI,qualifiedItem)	\
    (This)->lpVtbl -> getQualifiedItem(This,baseName,namespaceURI,qualifiedItem)

#define IXMLDOMNamedNodeMap_removeQualifiedItem(This,baseName,namespaceURI,qualifiedItem)	\
    (This)->lpVtbl -> removeQualifiedItem(This,baseName,namespaceURI,qualifiedItem)

#define IXMLDOMNamedNodeMap_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMNamedNodeMap_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMNamedNodeMap_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_getNamedItem_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *namedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_getNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_setNamedItem_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *newItem,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nameItem);


void __RPC_STUB IXMLDOMNamedNodeMap_setNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_removeNamedItem_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *namedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_removeNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get_item_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [in] */ long index,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *listItem);


void __RPC_STUB IXMLDOMNamedNodeMap_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get_length_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *listLength);


void __RPC_STUB IXMLDOMNamedNodeMap_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_getQualifiedItem_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [in] */ BSTR baseName,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *qualifiedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_getQualifiedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_removeQualifiedItem_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [in] */ BSTR baseName,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *qualifiedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_removeQualifiedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_nextNode_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextItem);


void __RPC_STUB IXMLDOMNamedNodeMap_nextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_reset_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This);


void __RPC_STUB IXMLDOMNamedNodeMap_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get__newEnum_Proxy( 
    IXMLDOMNamedNodeMap __RPC_FAR * This,
    /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IXMLDOMNamedNodeMap_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMCharacterData_INTERFACE_DEFINED__
#define __IXMLDOMCharacterData_INTERFACE_DEFINED__

/* interface IXMLDOMCharacterData */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMCharacterData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF84-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMCharacterData : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_data( 
            /* [retval][out] */ BSTR __RPC_FAR *data) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_data( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long __RPC_FAR *dataLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE substringData( 
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE appendData( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE insertData( 
            /* [in] */ long offset,
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteData( 
            /* [in] */ long offset,
            /* [in] */ long count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE replaceData( 
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCharacterDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMCharacterData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMCharacterData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *substringData )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendData )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertData )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteData )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceData )( 
            IXMLDOMCharacterData __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        END_INTERFACE
    } IXMLDOMCharacterDataVtbl;

    interface IXMLDOMCharacterData
    {
        CONST_VTBL struct IXMLDOMCharacterDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMCharacterData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMCharacterData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMCharacterData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMCharacterData_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMCharacterData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMCharacterData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMCharacterData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMCharacterData_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMCharacterData_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMCharacterData_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMCharacterData_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMCharacterData_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMCharacterData_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMCharacterData_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMCharacterData_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMCharacterData_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMCharacterData_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMCharacterData_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMCharacterData_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMCharacterData_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMCharacterData_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMCharacterData_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMCharacterData_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMCharacterData_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMCharacterData_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMCharacterData_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMCharacterData_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMCharacterData_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMCharacterData_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMCharacterData_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMCharacterData_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMCharacterData_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMCharacterData_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMCharacterData_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMCharacterData_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMCharacterData_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMCharacterData_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMCharacterData_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMCharacterData_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMCharacterData_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMCharacterData_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMCharacterData_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMCharacterData_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMCharacterData_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMCharacterData_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMCharacterData_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMCharacterData_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMCharacterData_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMCharacterData_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMCharacterData_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMCharacterData_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_get_data_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *data);


void __RPC_STUB IXMLDOMCharacterData_get_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_put_data_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_put_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_get_length_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *dataLength);


void __RPC_STUB IXMLDOMCharacterData_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_substringData_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [in] */ long offset,
    /* [in] */ long count,
    /* [retval][out] */ BSTR __RPC_FAR *data);


void __RPC_STUB IXMLDOMCharacterData_substringData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_appendData_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_appendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_insertData_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [in] */ long offset,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_insertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_deleteData_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [in] */ long offset,
    /* [in] */ long count);


void __RPC_STUB IXMLDOMCharacterData_deleteData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_replaceData_Proxy( 
    IXMLDOMCharacterData __RPC_FAR * This,
    /* [in] */ long offset,
    /* [in] */ long count,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_replaceData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMCharacterData_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMAttribute_INTERFACE_DEFINED__
#define __IXMLDOMAttribute_INTERFACE_DEFINED__

/* interface IXMLDOMAttribute */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF85-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMAttribute : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR __RPC_FAR *attributeName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [retval][out] */ VARIANT __RPC_FAR *attributeValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ VARIANT attributeValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMAttribute __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMAttribute __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *attributeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *attributeValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IXMLDOMAttribute __RPC_FAR * This,
            /* [in] */ VARIANT attributeValue);
        
        END_INTERFACE
    } IXMLDOMAttributeVtbl;

    interface IXMLDOMAttribute
    {
        CONST_VTBL struct IXMLDOMAttributeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMAttribute_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMAttribute_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMAttribute_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMAttribute_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMAttribute_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMAttribute_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMAttribute_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMAttribute_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMAttribute_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMAttribute_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMAttribute_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMAttribute_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMAttribute_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMAttribute_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMAttribute_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMAttribute_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMAttribute_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMAttribute_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMAttribute_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMAttribute_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMAttribute_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMAttribute_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMAttribute_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMAttribute_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMAttribute_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMAttribute_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMAttribute_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMAttribute_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMAttribute_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMAttribute_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMAttribute_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMAttribute_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMAttribute_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMAttribute_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMAttribute_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMAttribute_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMAttribute_get_name(This,attributeName)	\
    (This)->lpVtbl -> get_name(This,attributeName)

#define IXMLDOMAttribute_get_value(This,attributeValue)	\
    (This)->lpVtbl -> get_value(This,attributeValue)

#define IXMLDOMAttribute_put_value(This,attributeValue)	\
    (This)->lpVtbl -> put_value(This,attributeValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_get_name_Proxy( 
    IXMLDOMAttribute __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *attributeName);


void __RPC_STUB IXMLDOMAttribute_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_get_value_Proxy( 
    IXMLDOMAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *attributeValue);


void __RPC_STUB IXMLDOMAttribute_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_put_value_Proxy( 
    IXMLDOMAttribute __RPC_FAR * This,
    /* [in] */ VARIANT attributeValue);


void __RPC_STUB IXMLDOMAttribute_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMAttribute_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMElement_INTERFACE_DEFINED__
#define __IXMLDOMElement_INTERFACE_DEFINED__

/* interface IXMLDOMElement */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF86-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMElement : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [retval][out] */ BSTR __RPC_FAR *tagName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttributeNode( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttributeNode( 
            /* [in] */ IXMLDOMAttribute __RPC_FAR *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttributeNode( 
            /* [in] */ IXMLDOMAttribute __RPC_FAR *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getElementsByTagName( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE normalize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *tagName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttributeNode )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttributeNode )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMAttribute __RPC_FAR *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttributeNode )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ IXMLDOMAttribute __RPC_FAR *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getElementsByTagName )( 
            IXMLDOMElement __RPC_FAR * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *normalize )( 
            IXMLDOMElement __RPC_FAR * This);
        
        END_INTERFACE
    } IXMLDOMElementVtbl;

    interface IXMLDOMElement
    {
        CONST_VTBL struct IXMLDOMElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMElement_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMElement_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMElement_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMElement_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMElement_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMElement_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMElement_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMElement_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMElement_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMElement_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMElement_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMElement_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMElement_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMElement_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMElement_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMElement_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMElement_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMElement_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMElement_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMElement_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMElement_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMElement_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMElement_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMElement_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMElement_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMElement_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMElement_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMElement_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMElement_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMElement_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMElement_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMElement_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMElement_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMElement_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMElement_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMElement_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMElement_get_tagName(This,tagName)	\
    (This)->lpVtbl -> get_tagName(This,tagName)

#define IXMLDOMElement_getAttribute(This,name,value)	\
    (This)->lpVtbl -> getAttribute(This,name,value)

#define IXMLDOMElement_setAttribute(This,name,value)	\
    (This)->lpVtbl -> setAttribute(This,name,value)

#define IXMLDOMElement_removeAttribute(This,name)	\
    (This)->lpVtbl -> removeAttribute(This,name)

#define IXMLDOMElement_getAttributeNode(This,name,attributeNode)	\
    (This)->lpVtbl -> getAttributeNode(This,name,attributeNode)

#define IXMLDOMElement_setAttributeNode(This,DOMAttribute,attributeNode)	\
    (This)->lpVtbl -> setAttributeNode(This,DOMAttribute,attributeNode)

#define IXMLDOMElement_removeAttributeNode(This,DOMAttribute,attributeNode)	\
    (This)->lpVtbl -> removeAttributeNode(This,DOMAttribute,attributeNode)

#define IXMLDOMElement_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMElement_normalize(This)	\
    (This)->lpVtbl -> normalize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_get_tagName_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *tagName);


void __RPC_STUB IXMLDOMElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getAttribute_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *value);


void __RPC_STUB IXMLDOMElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_setAttribute_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_removeAttribute_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IXMLDOMElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getAttributeNode_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode);


void __RPC_STUB IXMLDOMElement_getAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_setAttributeNode_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [in] */ IXMLDOMAttribute __RPC_FAR *DOMAttribute,
    /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode);


void __RPC_STUB IXMLDOMElement_setAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_removeAttributeNode_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [in] */ IXMLDOMAttribute __RPC_FAR *DOMAttribute,
    /* [retval][out] */ IXMLDOMAttribute __RPC_FAR *__RPC_FAR *attributeNode);


void __RPC_STUB IXMLDOMElement_removeAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getElementsByTagName_Proxy( 
    IXMLDOMElement __RPC_FAR * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);


void __RPC_STUB IXMLDOMElement_getElementsByTagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_normalize_Proxy( 
    IXMLDOMElement __RPC_FAR * This);


void __RPC_STUB IXMLDOMElement_normalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMElement_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMText_INTERFACE_DEFINED__
#define __IXMLDOMText_INTERFACE_DEFINED__

/* interface IXMLDOMText */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF87-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMText : public IXMLDOMCharacterData
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE splitText( 
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *rightHandTextNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *substringData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *splitText )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMTextVtbl;

    interface IXMLDOMText
    {
        CONST_VTBL struct IXMLDOMTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMText_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMText_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMText_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMText_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMText_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMText_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMText_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMText_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMText_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMText_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMText_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMText_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMText_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMText_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMText_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMText_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMText_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMText_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMText_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMText_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMText_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMText_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMText_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMText_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMText_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMText_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMText_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMText_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMText_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMText_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMText_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMText_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMText_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMText_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMText_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMText_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMText_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMText_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMText_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMText_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMText_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMText_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMText_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMText_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMText_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMText_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMText_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMText_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMText_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMText_splitText_Proxy( 
    IXMLDOMText __RPC_FAR * This,
    /* [in] */ long offset,
    /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *rightHandTextNode);


void __RPC_STUB IXMLDOMText_splitText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMText_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMComment_INTERFACE_DEFINED__
#define __IXMLDOMComment_INTERFACE_DEFINED__

/* interface IXMLDOMComment */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMComment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF88-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMComment : public IXMLDOMCharacterData
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCommentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMComment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMComment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *substringData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        END_INTERFACE
    } IXMLDOMCommentVtbl;

    interface IXMLDOMComment
    {
        CONST_VTBL struct IXMLDOMCommentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMComment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMComment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMComment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMComment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMComment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMComment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMComment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMComment_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMComment_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMComment_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMComment_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMComment_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMComment_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMComment_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMComment_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMComment_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMComment_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMComment_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMComment_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMComment_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMComment_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMComment_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMComment_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMComment_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMComment_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMComment_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMComment_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMComment_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMComment_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMComment_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMComment_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMComment_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMComment_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMComment_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMComment_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMComment_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMComment_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMComment_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMComment_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMComment_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMComment_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMComment_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMComment_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMComment_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMComment_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMComment_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMComment_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMComment_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMComment_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMComment_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__
#define __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__

/* interface IXMLDOMProcessingInstruction */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMProcessingInstruction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF89-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMProcessingInstruction : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_target( 
            /* [retval][out] */ BSTR __RPC_FAR *name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_data( 
            /* [retval][out] */ BSTR __RPC_FAR *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_data( 
            /* [in] */ BSTR value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMProcessingInstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_target )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR value);
        
        END_INTERFACE
    } IXMLDOMProcessingInstructionVtbl;

    interface IXMLDOMProcessingInstruction
    {
        CONST_VTBL struct IXMLDOMProcessingInstructionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMProcessingInstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMProcessingInstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMProcessingInstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMProcessingInstruction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMProcessingInstruction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMProcessingInstruction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMProcessingInstruction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMProcessingInstruction_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMProcessingInstruction_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMProcessingInstruction_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMProcessingInstruction_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMProcessingInstruction_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMProcessingInstruction_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMProcessingInstruction_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMProcessingInstruction_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMProcessingInstruction_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMProcessingInstruction_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMProcessingInstruction_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMProcessingInstruction_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMProcessingInstruction_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMProcessingInstruction_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMProcessingInstruction_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMProcessingInstruction_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMProcessingInstruction_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMProcessingInstruction_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMProcessingInstruction_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMProcessingInstruction_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMProcessingInstruction_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMProcessingInstruction_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMProcessingInstruction_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMProcessingInstruction_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMProcessingInstruction_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMProcessingInstruction_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMProcessingInstruction_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMProcessingInstruction_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMProcessingInstruction_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMProcessingInstruction_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMProcessingInstruction_get_target(This,name)	\
    (This)->lpVtbl -> get_target(This,name)

#define IXMLDOMProcessingInstruction_get_data(This,value)	\
    (This)->lpVtbl -> get_data(This,value)

#define IXMLDOMProcessingInstruction_put_data(This,value)	\
    (This)->lpVtbl -> put_data(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_target_Proxy( 
    IXMLDOMProcessingInstruction __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *name);


void __RPC_STUB IXMLDOMProcessingInstruction_get_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_data_Proxy( 
    IXMLDOMProcessingInstruction __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *value);


void __RPC_STUB IXMLDOMProcessingInstruction_get_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_put_data_Proxy( 
    IXMLDOMProcessingInstruction __RPC_FAR * This,
    /* [in] */ BSTR value);


void __RPC_STUB IXMLDOMProcessingInstruction_put_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMCDATASection_INTERFACE_DEFINED__
#define __IXMLDOMCDATASection_INTERFACE_DEFINED__

/* interface IXMLDOMCDATASection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMCDATASection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8A-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMCDATASection : public IXMLDOMText
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCDATASectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMCDATASection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMCDATASection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *substringData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *splitText )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMCDATASectionVtbl;

    interface IXMLDOMCDATASection
    {
        CONST_VTBL struct IXMLDOMCDATASectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMCDATASection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMCDATASection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMCDATASection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMCDATASection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMCDATASection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMCDATASection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMCDATASection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMCDATASection_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMCDATASection_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMCDATASection_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMCDATASection_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMCDATASection_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMCDATASection_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMCDATASection_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMCDATASection_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMCDATASection_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMCDATASection_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMCDATASection_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMCDATASection_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMCDATASection_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMCDATASection_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMCDATASection_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMCDATASection_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMCDATASection_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMCDATASection_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMCDATASection_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMCDATASection_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMCDATASection_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMCDATASection_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMCDATASection_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMCDATASection_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMCDATASection_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMCDATASection_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMCDATASection_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMCDATASection_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMCDATASection_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMCDATASection_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMCDATASection_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMCDATASection_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMCDATASection_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMCDATASection_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMCDATASection_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMCDATASection_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMCDATASection_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMCDATASection_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMCDATASection_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMCDATASection_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMCDATASection_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMCDATASection_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocumentType_INTERFACE_DEFINED__
#define __IXMLDOMDocumentType_INTERFACE_DEFINED__

/* interface IXMLDOMDocumentType */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocumentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8B-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocumentType : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR __RPC_FAR *rootName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_entities( 
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *entityMap) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_notations( 
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *notationMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMDocumentType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMDocumentType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *rootName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_entities )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *entityMap);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_notations )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *notationMap);
        
        END_INTERFACE
    } IXMLDOMDocumentTypeVtbl;

    interface IXMLDOMDocumentType
    {
        CONST_VTBL struct IXMLDOMDocumentTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocumentType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocumentType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocumentType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocumentType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocumentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocumentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocumentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocumentType_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocumentType_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocumentType_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocumentType_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocumentType_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocumentType_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocumentType_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocumentType_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocumentType_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocumentType_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocumentType_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocumentType_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocumentType_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocumentType_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocumentType_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocumentType_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocumentType_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocumentType_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocumentType_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocumentType_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocumentType_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocumentType_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocumentType_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocumentType_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocumentType_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocumentType_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocumentType_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocumentType_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocumentType_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocumentType_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocumentType_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocumentType_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocumentType_get_name(This,rootName)	\
    (This)->lpVtbl -> get_name(This,rootName)

#define IXMLDOMDocumentType_get_entities(This,entityMap)	\
    (This)->lpVtbl -> get_entities(This,entityMap)

#define IXMLDOMDocumentType_get_notations(This,notationMap)	\
    (This)->lpVtbl -> get_notations(This,notationMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_name_Proxy( 
    IXMLDOMDocumentType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *rootName);


void __RPC_STUB IXMLDOMDocumentType_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_entities_Proxy( 
    IXMLDOMDocumentType __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *entityMap);


void __RPC_STUB IXMLDOMDocumentType_get_entities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_notations_Proxy( 
    IXMLDOMDocumentType __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *notationMap);


void __RPC_STUB IXMLDOMDocumentType_get_notations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocumentType_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNotation_INTERFACE_DEFINED__
#define __IXMLDOMNotation_INTERFACE_DEFINED__

/* interface IXMLDOMNotation */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNotation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8C-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNotation : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT __RPC_FAR *publicID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT __RPC_FAR *systemID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNotationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMNotation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMNotation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_publicId )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *publicID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_systemId )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *systemID);
        
        END_INTERFACE
    } IXMLDOMNotationVtbl;

    interface IXMLDOMNotation
    {
        CONST_VTBL struct IXMLDOMNotationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNotation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNotation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNotation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNotation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNotation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNotation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNotation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNotation_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMNotation_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMNotation_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMNotation_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMNotation_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMNotation_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMNotation_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMNotation_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMNotation_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMNotation_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMNotation_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMNotation_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMNotation_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMNotation_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMNotation_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMNotation_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMNotation_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMNotation_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMNotation_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMNotation_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMNotation_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMNotation_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMNotation_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMNotation_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMNotation_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMNotation_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMNotation_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMNotation_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMNotation_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMNotation_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMNotation_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMNotation_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMNotation_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMNotation_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMNotation_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMNotation_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_publicId_Proxy( 
    IXMLDOMNotation __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *publicID);


void __RPC_STUB IXMLDOMNotation_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_systemId_Proxy( 
    IXMLDOMNotation __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *systemID);


void __RPC_STUB IXMLDOMNotation_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNotation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntity_INTERFACE_DEFINED__
#define __IXMLDOMEntity_INTERFACE_DEFINED__

/* interface IXMLDOMEntity */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8D-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntity : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT __RPC_FAR *publicID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT __RPC_FAR *systemID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_notationName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMEntity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMEntity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_publicId )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *publicID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_systemId )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *systemID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_notationName )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        END_INTERFACE
    } IXMLDOMEntityVtbl;

    interface IXMLDOMEntity
    {
        CONST_VTBL struct IXMLDOMEntityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntity_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntity_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntity_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntity_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntity_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntity_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntity_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntity_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntity_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntity_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntity_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntity_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntity_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntity_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntity_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntity_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntity_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntity_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntity_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntity_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntity_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntity_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntity_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntity_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntity_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntity_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntity_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntity_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntity_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntity_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntity_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntity_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntity_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntity_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMEntity_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMEntity_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#define IXMLDOMEntity_get_notationName(This,name)	\
    (This)->lpVtbl -> get_notationName(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_publicId_Proxy( 
    IXMLDOMEntity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *publicID);


void __RPC_STUB IXMLDOMEntity_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_systemId_Proxy( 
    IXMLDOMEntity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *systemID);


void __RPC_STUB IXMLDOMEntity_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_notationName_Proxy( 
    IXMLDOMEntity __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *name);


void __RPC_STUB IXMLDOMEntity_get_notationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMEntity_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntityReference_INTERFACE_DEFINED__
#define __IXMLDOMEntityReference_INTERFACE_DEFINED__

/* interface IXMLDOMEntityReference */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntityReference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8E-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntityReference : public IXMLDOMNode
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityReferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMEntityReference __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMEntityReference __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMEntityReferenceVtbl;

    interface IXMLDOMEntityReference
    {
        CONST_VTBL struct IXMLDOMEntityReferenceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntityReference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntityReference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntityReference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntityReference_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntityReference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntityReference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntityReference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntityReference_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntityReference_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntityReference_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntityReference_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntityReference_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntityReference_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntityReference_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntityReference_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntityReference_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntityReference_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntityReference_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntityReference_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntityReference_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntityReference_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntityReference_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntityReference_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntityReference_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntityReference_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntityReference_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntityReference_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntityReference_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntityReference_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntityReference_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntityReference_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntityReference_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntityReference_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntityReference_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntityReference_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntityReference_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntityReference_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntityReference_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntityReference_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMEntityReference_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMParseError_INTERFACE_DEFINED__
#define __IXMLDOMParseError_INTERFACE_DEFINED__

/* interface IXMLDOMParseError */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMParseError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa426-272f-11d2-836f-0000f87a7782")
    IXMLDOMParseError : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_errorCode( 
            /* [out][retval] */ long __RPC_FAR *errorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR __RPC_FAR *urlString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_reason( 
            /* [out][retval] */ BSTR __RPC_FAR *reasonString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_srcText( 
            /* [out][retval] */ BSTR __RPC_FAR *sourceString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_line( 
            /* [out][retval] */ long __RPC_FAR *lineNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_linepos( 
            /* [out][retval] */ long __RPC_FAR *linePosition) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_filepos( 
            /* [out][retval] */ long __RPC_FAR *filePosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMParseErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMParseError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMParseError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_errorCode )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *errorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_url )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_reason )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *reasonString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_srcText )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *sourceString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_line )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *lineNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_linepos )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *linePosition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_filepos )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *filePosition);
        
        END_INTERFACE
    } IXMLDOMParseErrorVtbl;

    interface IXMLDOMParseError
    {
        CONST_VTBL struct IXMLDOMParseErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMParseError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMParseError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMParseError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMParseError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMParseError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMParseError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMParseError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMParseError_get_errorCode(This,errorCode)	\
    (This)->lpVtbl -> get_errorCode(This,errorCode)

#define IXMLDOMParseError_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMParseError_get_reason(This,reasonString)	\
    (This)->lpVtbl -> get_reason(This,reasonString)

#define IXMLDOMParseError_get_srcText(This,sourceString)	\
    (This)->lpVtbl -> get_srcText(This,sourceString)

#define IXMLDOMParseError_get_line(This,lineNumber)	\
    (This)->lpVtbl -> get_line(This,lineNumber)

#define IXMLDOMParseError_get_linepos(This,linePosition)	\
    (This)->lpVtbl -> get_linepos(This,linePosition)

#define IXMLDOMParseError_get_filepos(This,filePosition)	\
    (This)->lpVtbl -> get_filepos(This,filePosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_errorCode_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *errorCode);


void __RPC_STUB IXMLDOMParseError_get_errorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_url_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *urlString);


void __RPC_STUB IXMLDOMParseError_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_reason_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *reasonString);


void __RPC_STUB IXMLDOMParseError_get_reason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_srcText_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *sourceString);


void __RPC_STUB IXMLDOMParseError_get_srcText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_line_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *lineNumber);


void __RPC_STUB IXMLDOMParseError_get_line_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_linepos_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *linePosition);


void __RPC_STUB IXMLDOMParseError_get_linepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_filepos_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *filePosition);


void __RPC_STUB IXMLDOMParseError_get_filepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMParseError_INTERFACE_DEFINED__ */


#ifndef __IXTLRuntime_INTERFACE_DEFINED__
#define __IXTLRuntime_INTERFACE_DEFINED__

/* interface IXTLRuntime */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXTLRuntime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa425-272f-11d2-836f-0000f87a7782")
    IXTLRuntime : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE uniqueID( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE depth( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pDepth) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE childNumber( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ancestorChildNumber( 
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE absoluteChildNumber( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatIndex( 
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatNumber( 
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatDate( 
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatTime( 
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXTLRuntimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXTLRuntime __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXTLRuntime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *uniqueID )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *depth )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pDepth);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *childNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ancestorChildNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *absoluteChildNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatIndex )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatDate )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatTime )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        END_INTERFACE
    } IXTLRuntimeVtbl;

    interface IXTLRuntime
    {
        CONST_VTBL struct IXTLRuntimeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXTLRuntime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXTLRuntime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXTLRuntime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXTLRuntime_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXTLRuntime_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXTLRuntime_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXTLRuntime_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXTLRuntime_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXTLRuntime_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXTLRuntime_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXTLRuntime_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXTLRuntime_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXTLRuntime_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXTLRuntime_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXTLRuntime_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXTLRuntime_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXTLRuntime_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXTLRuntime_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXTLRuntime_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXTLRuntime_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXTLRuntime_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXTLRuntime_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXTLRuntime_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXTLRuntime_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXTLRuntime_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXTLRuntime_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXTLRuntime_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXTLRuntime_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXTLRuntime_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXTLRuntime_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXTLRuntime_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXTLRuntime_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXTLRuntime_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXTLRuntime_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXTLRuntime_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXTLRuntime_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXTLRuntime_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXTLRuntime_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXTLRuntime_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXTLRuntime_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXTLRuntime_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXTLRuntime_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXTLRuntime_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXTLRuntime_uniqueID(This,pNode,pID)	\
    (This)->lpVtbl -> uniqueID(This,pNode,pID)

#define IXTLRuntime_depth(This,pNode,pDepth)	\
    (This)->lpVtbl -> depth(This,pNode,pDepth)

#define IXTLRuntime_childNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> childNumber(This,pNode,pNumber)

#define IXTLRuntime_ancestorChildNumber(This,bstrNodeName,pNode,pNumber)	\
    (This)->lpVtbl -> ancestorChildNumber(This,bstrNodeName,pNode,pNumber)

#define IXTLRuntime_absoluteChildNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> absoluteChildNumber(This,pNode,pNumber)

#define IXTLRuntime_formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)

#define IXTLRuntime_formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_uniqueID_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pID);


void __RPC_STUB IXTLRuntime_uniqueID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_depth_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pDepth);


void __RPC_STUB IXTLRuntime_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_childNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pNumber);


void __RPC_STUB IXTLRuntime_childNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_ancestorChildNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ BSTR bstrNodeName,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pNumber);


void __RPC_STUB IXTLRuntime_ancestorChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_absoluteChildNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pNumber);


void __RPC_STUB IXTLRuntime_absoluteChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatIndex_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ double dblNumber,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatDate_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ VARIANT varDate,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatTime_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ VARIANT varTime,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXTLRuntime_INTERFACE_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__
#define __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__

/* dispinterface XMLDOMDocumentEvents */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_XMLDOMDocumentEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3efaa427-272f-11d2-836f-0000f87a7782")
    XMLDOMDocumentEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct XMLDOMDocumentEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            XMLDOMDocumentEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            XMLDOMDocumentEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } XMLDOMDocumentEventsVtbl;

    interface XMLDOMDocumentEvents
    {
        CONST_VTBL struct XMLDOMDocumentEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define XMLDOMDocumentEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define XMLDOMDocumentEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define XMLDOMDocumentEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define XMLDOMDocumentEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define XMLDOMDocumentEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define XMLDOMDocumentEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define XMLDOMDocumentEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("2933BF90-7B36-11d2-B20E-00C04F983E60")
DOMDocument;
#endif

EXTERN_C const CLSID CLSID_DOMFreeThreadedDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("2933BF91-7B36-11d2-B20E-00C04F983E60")
DOMFreeThreadedDocument;
#endif

#ifndef __IXMLHttpRequest_INTERFACE_DEFINED__
#define __IXMLHttpRequest_INTERFACE_DEFINED__

/* interface IXMLHttpRequest */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IXMLHttpRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED8C108D-4349-11D2-91A4-00C04F7969E8")
    IXMLHttpRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE open( 
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setRequestHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getResponseHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAllResponseHeaders( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrHeaders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE send( 
            /* [optional][in] */ VARIANT varBody) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [retval][out] */ long __RPC_FAR *plStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_statusText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseXML( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseBody( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseStream( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long __RPC_FAR *plState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ IDispatch __RPC_FAR *pReadyStateSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLHttpRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLHttpRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLHttpRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *open )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setRequestHeader )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getResponseHeader )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAllResponseHeaders )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *send )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *abort )( 
            IXMLHttpRequest __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_statusText )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseXML )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseText )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseBody )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseStream )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onreadystatechange )( 
            IXMLHttpRequest __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pReadyStateSink);
        
        END_INTERFACE
    } IXMLHttpRequestVtbl;

    interface IXMLHttpRequest
    {
        CONST_VTBL struct IXMLHttpRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLHttpRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLHttpRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLHttpRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLHttpRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLHttpRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLHttpRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLHttpRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLHttpRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)

#define IXMLHttpRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue)

#define IXMLHttpRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue)

#define IXMLHttpRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders)

#define IXMLHttpRequest_send(This,varBody)	\
    (This)->lpVtbl -> send(This,varBody)

#define IXMLHttpRequest_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLHttpRequest_get_status(This,plStatus)	\
    (This)->lpVtbl -> get_status(This,plStatus)

#define IXMLHttpRequest_get_statusText(This,pbstrStatus)	\
    (This)->lpVtbl -> get_statusText(This,pbstrStatus)

#define IXMLHttpRequest_get_responseXML(This,ppBody)	\
    (This)->lpVtbl -> get_responseXML(This,ppBody)

#define IXMLHttpRequest_get_responseText(This,pbstrBody)	\
    (This)->lpVtbl -> get_responseText(This,pbstrBody)

#define IXMLHttpRequest_get_responseBody(This,pvarBody)	\
    (This)->lpVtbl -> get_responseBody(This,pvarBody)

#define IXMLHttpRequest_get_responseStream(This,pvarBody)	\
    (This)->lpVtbl -> get_responseStream(This,pvarBody)

#define IXMLHttpRequest_get_readyState(This,plState)	\
    (This)->lpVtbl -> get_readyState(This,plState)

#define IXMLHttpRequest_put_onreadystatechange(This,pReadyStateSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_open_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrMethod,
    /* [in] */ BSTR bstrUrl,
    /* [optional][in] */ VARIANT varAsync,
    /* [optional][in] */ VARIANT bstrUser,
    /* [optional][in] */ VARIANT bstrPassword);


void __RPC_STUB IXMLHttpRequest_open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_setRequestHeader_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrHeader,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IXMLHttpRequest_setRequestHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_getResponseHeader_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrHeader,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);


void __RPC_STUB IXMLHttpRequest_getResponseHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_getAllResponseHeaders_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrHeaders);


void __RPC_STUB IXMLHttpRequest_getAllResponseHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_send_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [optional][in] */ VARIANT varBody);


void __RPC_STUB IXMLHttpRequest_send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_abort_Proxy( 
    IXMLHttpRequest __RPC_FAR * This);


void __RPC_STUB IXMLHttpRequest_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_get_status_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plStatus);


void __RPC_STUB IXMLHttpRequest_get_status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_get_statusText_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);


void __RPC_STUB IXMLHttpRequest_get_statusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_get_responseXML_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppBody);


void __RPC_STUB IXMLHttpRequest_get_responseXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_get_responseText_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrBody);


void __RPC_STUB IXMLHttpRequest_get_responseText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_get_responseBody_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);


void __RPC_STUB IXMLHttpRequest_get_responseBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_get_responseStream_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);


void __RPC_STUB IXMLHttpRequest_get_responseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_get_readyState_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plState);


void __RPC_STUB IXMLHttpRequest_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLHttpRequest_put_onreadystatechange_Proxy( 
    IXMLHttpRequest __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pReadyStateSink);


void __RPC_STUB IXMLHttpRequest_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLHttpRequest_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLHTTPRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("ED8C108E-4349-11D2-91A4-00C04F7969E8")
XMLHTTPRequest;
#endif

#ifndef __IXMLDSOControl_INTERFACE_DEFINED__
#define __IXMLDSOControl_INTERFACE_DEFINED__

/* interface IXMLDSOControl */
/* [unique][helpstring][hidden][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDSOControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310afa62-0575-11d2-9ca9-0060b0ec3d39")
    IXMLDSOControl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLDocument( 
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppDoc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLDocument( 
            /* [in] */ IXMLDOMDocument __RPC_FAR *ppDoc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_JavaDSOCompatible( 
            /* [retval][out] */ BOOL __RPC_FAR *fJavaDSOCompatible) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_JavaDSOCompatible( 
            /* [in] */ BOOL fJavaDSOCompatible) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long __RPC_FAR *state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDSOControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDSOControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDSOControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMLDocument )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppDoc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMLDocument )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [in] */ IXMLDOMDocument __RPC_FAR *ppDoc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_JavaDSOCompatible )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *fJavaDSOCompatible);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_JavaDSOCompatible )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [in] */ BOOL fJavaDSOCompatible);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLDSOControl __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *state);
        
        END_INTERFACE
    } IXMLDSOControlVtbl;

    interface IXMLDSOControl
    {
        CONST_VTBL struct IXMLDSOControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDSOControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDSOControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDSOControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDSOControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDSOControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDSOControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDSOControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDSOControl_get_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> get_XMLDocument(This,ppDoc)

#define IXMLDSOControl_put_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> put_XMLDocument(This,ppDoc)

#define IXMLDSOControl_get_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> get_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IXMLDSOControl_put_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> put_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IXMLDSOControl_get_readyState(This,state)	\
    (This)->lpVtbl -> get_readyState(This,state)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDSOControl_get_XMLDocument_Proxy( 
    IXMLDSOControl __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppDoc);


void __RPC_STUB IXMLDSOControl_get_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDSOControl_put_XMLDocument_Proxy( 
    IXMLDSOControl __RPC_FAR * This,
    /* [in] */ IXMLDOMDocument __RPC_FAR *ppDoc);


void __RPC_STUB IXMLDSOControl_put_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDSOControl_get_JavaDSOCompatible_Proxy( 
    IXMLDSOControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *fJavaDSOCompatible);


void __RPC_STUB IXMLDSOControl_get_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDSOControl_put_JavaDSOCompatible_Proxy( 
    IXMLDSOControl __RPC_FAR * This,
    /* [in] */ BOOL fJavaDSOCompatible);


void __RPC_STUB IXMLDSOControl_put_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDSOControl_get_readyState_Proxy( 
    IXMLDSOControl __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *state);


void __RPC_STUB IXMLDSOControl_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDSOControl_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLDSOControl;

#ifdef __cplusplus

class DECLSPEC_UUID("550dda30-0541-11d2-9ca9-0060b0ec3d39")
XMLDSOControl;
#endif

#ifndef __IXMLElementCollection_INTERFACE_DEFINED__
#define __IXMLElementCollection_INTERFACE_DEFINED__

/* interface IXMLElementCollection */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElementCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65725580-9B5D-11d0-9BFE-00C04FC99C8E")
    IXMLElementCollection : public IDispatch
    {
    public:
        virtual /* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE put_length( 
            /* [in] */ long v) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElementCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElementCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][hidden][restricted][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_length )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        END_INTERFACE
    } IXMLElementCollectionVtbl;

    interface IXMLElementCollection
    {
        CONST_VTBL struct IXMLElementCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElementCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElementCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElementCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElementCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElementCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElementCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElementCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElementCollection_put_length(This,v)	\
    (This)->lpVtbl -> put_length(This,v)

#define IXMLElementCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IXMLElementCollection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#define IXMLElementCollection_item(This,var1,var2,ppDisp)	\
    (This)->lpVtbl -> item(This,var1,var2,ppDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_put_length_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IXMLElementCollection_put_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get_length_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IXMLElementCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get__newEnum_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IXMLElementCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_item_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [in][optional] */ VARIANT var1,
    /* [in][optional] */ VARIANT var2,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IXMLElementCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElementCollection_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument_INTERFACE_DEFINED__
#define __IXMLDocument_INTERFACE_DEFINED__

/* interface IXMLDocument */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F52E2B61-18A1-11d1-B105-00805F49916B")
    IXMLDocument : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_root )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileSize )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileModifiedDate )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileUpdatedDate )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mimeType )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_charset )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_charset )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_version )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_doctype )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dtdURL )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createElement )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem);
        
        END_INTERFACE
    } IXMLDocumentVtbl;

    interface IXMLDocument
    {
        CONST_VTBL struct IXMLDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_root_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileSize_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileModifiedDate_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileUpdatedDate_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_URL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_URL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_mimeType_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_readyState_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *pl);


void __RPC_STUB IXMLDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_charset_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_charset_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_version_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_doctype_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_dtdURL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDocument_createElement_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem);


void __RPC_STUB IXMLDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument2_INTERFACE_DEFINED__
#define __IXMLDocument2_INTERFACE_DEFINED__

/* interface IXMLDocument2 */
/* [hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FE-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLDocument2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppElem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_async( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pf) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_async( 
            /* [in] */ VARIANT_BOOL f) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDocument2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDocument2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_root )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileSize )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileModifiedDate )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileUpdatedDate )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mimeType )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_charset )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_charset )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_version )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_doctype )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dtdURL )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createElement )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppElem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_async )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pf);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_async )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL f);
        
        END_INTERFACE
    } IXMLDocument2Vtbl;

    interface IXMLDocument2
    {
        CONST_VTBL struct IXMLDocument2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument2_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument2_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument2_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument2_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument2_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument2_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument2_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument2_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument2_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument2_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument2_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument2_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument2_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument2_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#define IXMLDocument2_get_async(This,pf)	\
    (This)->lpVtbl -> get_async(This,pf)

#define IXMLDocument2_put_async(This,f)	\
    (This)->lpVtbl -> put_async(This,f)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_root_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileSize_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileModifiedDate_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileUpdatedDate_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_URL_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_URL_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_mimeType_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_readyState_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *pl);


void __RPC_STUB IXMLDocument2_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_charset_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_charset_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_version_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_doctype_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_dtdURL_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_createElement_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppElem);


void __RPC_STUB IXMLDocument2_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_async_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pf);


void __RPC_STUB IXMLDocument2_get_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_async_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL f);


void __RPC_STUB IXMLDocument2_put_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument2_INTERFACE_DEFINED__ */


#ifndef __IXMLElement_INTERFACE_DEFINED__
#define __IXMLElement_INTERFACE_DEFINED__

/* interface IXMLElement */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F7F31AC-E15F-11d0-9C25-00C04FC99C8E")
    IXMLElement : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long __RPC_FAR *plType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement __RPC_FAR *pChildElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tagName )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parent )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_children )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *plType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addChild )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ IXMLElement __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ IXMLElement __RPC_FAR *pChildElem);
        
        END_INTERFACE
    } IXMLElementVtbl;

    interface IXMLElement
    {
        CONST_VTBL struct IXMLElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_tagName_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_tagName_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_parent_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IXMLElement_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_setAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_getAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);


void __RPC_STUB IXMLElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_children_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);


void __RPC_STUB IXMLElement_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_type_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *plType);


void __RPC_STUB IXMLElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_text_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_text_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_addChild_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ IXMLElement __RPC_FAR *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeChild_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ IXMLElement __RPC_FAR *pChildElem);


void __RPC_STUB IXMLElement_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement_INTERFACE_DEFINED__ */


#ifndef __IXMLElement2_INTERFACE_DEFINED__
#define __IXMLElement2_INTERFACE_DEFINED__

/* interface IXMLElement2 */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FF-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLElement2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long __RPC_FAR *plType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElement2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElement2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElement2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tagName )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parent )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_children )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *plType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addChild )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);
        
        END_INTERFACE
    } IXMLElement2Vtbl;

    interface IXMLElement2
    {
        CONST_VTBL struct IXMLElement2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement2_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement2_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement2_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement2_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement2_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement2_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement2_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement2_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement2_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement2_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#define IXMLElement2_get_attributes(This,pp)	\
    (This)->lpVtbl -> get_attributes(This,pp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_tagName_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement2_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_tagName_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_parent_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IXMLElement2_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_setAttribute_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement2_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_getAttribute_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);


void __RPC_STUB IXMLElement2_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeAttribute_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement2_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_children_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);


void __RPC_STUB IXMLElement2_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_type_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *plType);


void __RPC_STUB IXMLElement2_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_text_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement2_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_text_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_addChild_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ IXMLElement2 __RPC_FAR *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement2_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeChild_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ IXMLElement2 __RPC_FAR *pChildElem);


void __RPC_STUB IXMLElement2_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_attributes_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);


void __RPC_STUB IXMLElement2_get_attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement2_INTERFACE_DEFINED__ */


#ifndef __IXMLAttribute_INTERFACE_DEFINED__
#define __IXMLAttribute_INTERFACE_DEFINED__

/* interface IXMLAttribute */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4D4A0FC-3B73-11d1-B2B4-00C04FB92596")
    IXMLAttribute : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *n) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR __RPC_FAR *v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLAttribute __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLAttribute __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLAttribute __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IXMLAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *n);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IXMLAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *v);
        
        END_INTERFACE
    } IXMLAttributeVtbl;

    interface IXMLAttribute
    {
        CONST_VTBL struct IXMLAttributeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLAttribute_get_name(This,n)	\
    (This)->lpVtbl -> get_name(This,n)

#define IXMLAttribute_get_value(This,v)	\
    (This)->lpVtbl -> get_value(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_name_Proxy( 
    IXMLAttribute __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *n);


void __RPC_STUB IXMLAttribute_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_value_Proxy( 
    IXMLAttribute __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *v);


void __RPC_STUB IXMLAttribute_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLAttribute_INTERFACE_DEFINED__ */


#ifndef __IXMLError_INTERFACE_DEFINED__
#define __IXMLError_INTERFACE_DEFINED__

/* interface IXMLError */
/* [helpstring][hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("948C5AD3-C58D-11d0-9C0B-00C04FC99C8E")
    IXMLError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            XML_ERROR __RPC_FAR *pErrorReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLError __RPC_FAR * This,
            XML_ERROR __RPC_FAR *pErrorReturn);
        
        END_INTERFACE
    } IXMLErrorVtbl;

    interface IXMLError
    {
        CONST_VTBL struct IXMLErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLError_GetErrorInfo(This,pErrorReturn)	\
    (This)->lpVtbl -> GetErrorInfo(This,pErrorReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLError_GetErrorInfo_Proxy( 
    IXMLError __RPC_FAR * This,
    XML_ERROR __RPC_FAR *pErrorReturn);


void __RPC_STUB IXMLError_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLError_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("CFC399AF-D876-11d0-9C10-00C04FC99C8E")
XMLDocument;
#endif
#endif /* __MSXML_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtsevents.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:07 1997
 */
/* Compiler settings for mtsevents.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtsevents_h__
#define __mtsevents_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMtsEvents_FWD_DEFINED__
#define __IMtsEvents_FWD_DEFINED__
typedef interface IMtsEvents IMtsEvents;
#endif 	/* __IMtsEvents_FWD_DEFINED__ */


#ifndef __IMtsEventInfo_FWD_DEFINED__
#define __IMtsEventInfo_FWD_DEFINED__
typedef interface IMtsEventInfo IMtsEventInfo;
#endif 	/* __IMtsEventInfo_FWD_DEFINED__ */


#ifndef __IEventMoniker_FWD_DEFINED__
#define __IEventMoniker_FWD_DEFINED__
typedef interface IEventMoniker IEventMoniker;
#endif 	/* __IEventMoniker_FWD_DEFINED__ */


#ifndef __IMTSLocater_FWD_DEFINED__
#define __IMTSLocater_FWD_DEFINED__
typedef interface IMTSLocater IMTSLocater;
#endif 	/* __IMTSLocater_FWD_DEFINED__ */


#ifndef __CoMTSEvents_FWD_DEFINED__
#define __CoMTSEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoMTSEvents CoMTSEvents;
#else
typedef struct CoMTSEvents CoMTSEvents;
#endif /* __cplusplus */

#endif 	/* __CoMTSEvents_FWD_DEFINED__ */


#ifndef __EventMoniker_FWD_DEFINED__
#define __EventMoniker_FWD_DEFINED__

#ifdef __cplusplus
typedef class EventMoniker EventMoniker;
#else
typedef struct EventMoniker EventMoniker;
#endif /* __cplusplus */

#endif 	/* __EventMoniker_FWD_DEFINED__ */


#ifndef __CoMTSLocater_FWD_DEFINED__
#define __CoMTSLocater_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoMTSLocater CoMTSLocater;
#else
typedef struct CoMTSLocater CoMTSLocater;
#endif /* __cplusplus */

#endif 	/* __CoMTSLocater_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "eventcpts.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IMtsEvents_INTERFACE_DEFINED__
#define __IMtsEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsEvents
 * at Thu Sep 11 16:03:07 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IMtsEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF4D-74AB-11D0-B162-00AA00BA3258")
    IMtsEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PackageName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PackageGuid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PostEvent( 
            /* [in] */ VARIANT __RPC_FAR *vEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FireEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProcessID( 
            /* [retval][out] */ long __RPC_FAR *id) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMtsEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMtsEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMtsEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMtsEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PackageName )( 
            IMtsEvents __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PackageGuid )( 
            IMtsEvents __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PostEvent )( 
            IMtsEvents __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *vEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FireEvents )( 
            IMtsEvents __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProcessID )( 
            IMtsEvents __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *id);
        
        END_INTERFACE
    } IMtsEventsVtbl;

    interface IMtsEvents
    {
        CONST_VTBL struct IMtsEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMtsEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMtsEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMtsEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMtsEvents_get_PackageName(This,pVal)	\
    (This)->lpVtbl -> get_PackageName(This,pVal)

#define IMtsEvents_get_PackageGuid(This,pVal)	\
    (This)->lpVtbl -> get_PackageGuid(This,pVal)

#define IMtsEvents_PostEvent(This,vEvent)	\
    (This)->lpVtbl -> PostEvent(This,vEvent)

#define IMtsEvents_get_FireEvents(This,pVal)	\
    (This)->lpVtbl -> get_FireEvents(This,pVal)

#define IMtsEvents_GetProcessID(This,id)	\
    (This)->lpVtbl -> GetProcessID(This,id)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMtsEvents_get_PackageName_Proxy( 
    IMtsEvents __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMtsEvents_get_PackageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMtsEvents_get_PackageGuid_Proxy( 
    IMtsEvents __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMtsEvents_get_PackageGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMtsEvents_PostEvent_Proxy( 
    IMtsEvents __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *vEvent);


void __RPC_STUB IMtsEvents_PostEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMtsEvents_get_FireEvents_Proxy( 
    IMtsEvents __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMtsEvents_get_FireEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMtsEvents_GetProcessID_Proxy( 
    IMtsEvents __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *id);


void __RPC_STUB IMtsEvents_GetProcessID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsEventInfo_INTERFACE_DEFINED__
#define __IMtsEventInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsEventInfo
 * at Thu Sep 11 16:03:07 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IMtsEventInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("D56C3DC1-8482-11d0-B170-00AA00BA3258")
    IMtsEventInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Names( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pUnk) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *sDisplayName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EventID( 
            /* [retval][out] */ BSTR __RPC_FAR *sGuidEventID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *lCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR sKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsEventInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsEventInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsEventInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Names )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pUnk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *sDisplayName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventID )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *sGuidEventID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *lCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IMtsEventInfo __RPC_FAR * This,
            /* [in] */ BSTR sKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IMtsEventInfoVtbl;

    interface IMtsEventInfo
    {
        CONST_VTBL struct IMtsEventInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsEventInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsEventInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsEventInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsEventInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMtsEventInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMtsEventInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMtsEventInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMtsEventInfo_get_Names(This,pUnk)	\
    (This)->lpVtbl -> get_Names(This,pUnk)

#define IMtsEventInfo_get_DisplayName(This,sDisplayName)	\
    (This)->lpVtbl -> get_DisplayName(This,sDisplayName)

#define IMtsEventInfo_get_EventID(This,sGuidEventID)	\
    (This)->lpVtbl -> get_EventID(This,sGuidEventID)

#define IMtsEventInfo_get_Count(This,lCount)	\
    (This)->lpVtbl -> get_Count(This,lCount)

#define IMtsEventInfo_get_Value(This,sKey,pVal)	\
    (This)->lpVtbl -> get_Value(This,sKey,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMtsEventInfo_get_Names_Proxy( 
    IMtsEventInfo __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pUnk);


void __RPC_STUB IMtsEventInfo_get_Names_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMtsEventInfo_get_DisplayName_Proxy( 
    IMtsEventInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *sDisplayName);


void __RPC_STUB IMtsEventInfo_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMtsEventInfo_get_EventID_Proxy( 
    IMtsEventInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *sGuidEventID);


void __RPC_STUB IMtsEventInfo_get_EventID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMtsEventInfo_get_Count_Proxy( 
    IMtsEventInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *lCount);


void __RPC_STUB IMtsEventInfo_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMtsEventInfo_get_Value_Proxy( 
    IMtsEventInfo __RPC_FAR * This,
    /* [in] */ BSTR sKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IMtsEventInfo_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsEventInfo_INTERFACE_DEFINED__ */


#ifndef __IEventMoniker_INTERFACE_DEFINED__
#define __IEventMoniker_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEventMoniker
 * at Thu Sep 11 16:03:07 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpstring][hidden][uuid] */ 



EXTERN_C const IID IID_IEventMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C8CF32B3-7885-11D0-B169-00AA00BA3258")
    IEventMoniker : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ID( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EventObj( 
            /* [in] */ IUnknown __RPC_FAR *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventMonikerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventMoniker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventMoniker __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventMoniker __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IEventMoniker __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IEventMoniker __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ID )( 
            IEventMoniker __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ID )( 
            IEventMoniker __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventObj )( 
            IEventMoniker __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *newVal);
        
        END_INTERFACE
    } IEventMonikerVtbl;

    interface IEventMoniker
    {
        CONST_VTBL struct IEventMonikerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventMoniker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventMoniker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventMoniker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventMoniker_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IEventMoniker_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IEventMoniker_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IEventMoniker_put_ID(This,newVal)	\
    (This)->lpVtbl -> put_ID(This,newVal)

#define IEventMoniker_put_EventObj(This,newVal)	\
    (This)->lpVtbl -> put_EventObj(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IEventMoniker_get_Name_Proxy( 
    IEventMoniker __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IEventMoniker_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IEventMoniker_put_Name_Proxy( 
    IEventMoniker __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IEventMoniker_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IEventMoniker_get_ID_Proxy( 
    IEventMoniker __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IEventMoniker_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IEventMoniker_put_ID_Proxy( 
    IEventMoniker __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IEventMoniker_put_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IEventMoniker_put_EventObj_Proxy( 
    IEventMoniker __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *newVal);


void __RPC_STUB IEventMoniker_put_EventObj_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventMoniker_INTERFACE_DEFINED__ */


#ifndef __IMTSLocater_INTERFACE_DEFINED__
#define __IMTSLocater_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSLocater
 * at Thu Sep 11 16:03:07 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IMTSLocater;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("D19B8BFD-7F88-11D0-B16E-00AA00BA3258")
    IMTSLocater : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEventDispatcher( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSLocaterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSLocater __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSLocater __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSLocater __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMTSLocater __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMTSLocater __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMTSLocater __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMTSLocater __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventDispatcher )( 
            IMTSLocater __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pUnk);
        
        END_INTERFACE
    } IMTSLocaterVtbl;

    interface IMTSLocater
    {
        CONST_VTBL struct IMTSLocaterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSLocater_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSLocater_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSLocater_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSLocater_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMTSLocater_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMTSLocater_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMTSLocater_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMTSLocater_GetEventDispatcher(This,pUnk)	\
    (This)->lpVtbl -> GetEventDispatcher(This,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMTSLocater_GetEventDispatcher_Proxy( 
    IMTSLocater __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pUnk);


void __RPC_STUB IMTSLocater_GetEventDispatcher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSLocater_INTERFACE_DEFINED__ */



#ifndef __MTSEVENTSLib_LIBRARY_DEFINED__
#define __MTSEVENTSLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSEVENTSLib
 * at Thu Sep 11 16:03:07 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MTSEVENTSLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CoMTSEvents;

class DECLSPEC_UUID("BACEDF4E-74AB-11D0-B162-00AA00BA3258")
CoMTSEvents;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_EventMoniker;

class DECLSPEC_UUID("C8CF32B4-7885-11D0-B169-00AA00BA3258")
EventMoniker;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CoMTSLocater;

class DECLSPEC_UUID("D19B8BFE-7F88-11D0-B16E-00AA00BA3258")
CoMTSLocater;
#endif
#endif /* __MTSEVENTSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\msxmldid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1999               **
//*********************************************************************

#ifndef __MSXMLDID_H__
#define __MSXMLDID_H__

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN


#define DISPID_XMLELEMENTCOLLECTION             DISPID_XOBJ_BASE

#define DISPID_XMLELEMENTCOLLECTION_LENGTH     DISPID_XMLELEMENTCOLLECTION + 1
#define DISPID_XMLELEMENTCOLLECTION_NEWENUM     DISPID_NEWENUM
#define DISPID_XMLELEMENTCOLLECTION_ITEM        DISPID_XMLELEMENTCOLLECTION + 3


#define DISPID_XMLDOCUMENT                      DISPID_XMLELEMENTCOLLECTION + 100

#define DISPID_XMLDOCUMENT_ROOT                 DISPID_XMLDOCUMENT + 1
#define DISPID_XMLDOCUMENT_FILESIZE             DISPID_XMLDOCUMENT + 2
#define DISPID_XMLDOCUMENT_FILEMODIFIEDDATE     DISPID_XMLDOCUMENT + 3
#define DISPID_XMLDOCUMENT_FILEUPDATEDDATE      DISPID_XMLDOCUMENT + 4
#define DISPID_XMLDOCUMENT_URL                  DISPID_XMLDOCUMENT + 5
#define DISPID_XMLDOCUMENT_MIMETYPE             DISPID_XMLDOCUMENT + 6
#define DISPID_XMLDOCUMENT_READYSTATE           DISPID_XMLDOCUMENT + 7
#define DISPID_XMLDOCUMENT_CREATEELEMENT        DISPID_XMLDOCUMENT + 8
#define DISPID_XMLDOCUMENT_CHARSET              DISPID_XMLDOCUMENT + 9
#define DISPID_XMLDOCUMENT_VERSION              DISPID_XMLDOCUMENT + 10
#define DISPID_XMLDOCUMENT_DOCTYPE              DISPID_XMLDOCUMENT + 11
#define DISPID_XMLDOCUMENT_DTDURL               DISPID_XMLDOCUMENT + 12
#define DISPID_XMLDOCUMENT_ASYNC                DISPID_XMLDOCUMENT + 13
#define DISPID_XMLDOCUMENT_CASEINSENSITIVE      DISPID_XMLDOCUMENT + 14

#define DISPID_XMLELEMENT                       DISPID_XMLDOCUMENT + 100

#define DISPID_XMLELEMENT_TAGNAME               DISPID_XMLELEMENT + 1
#define DISPID_XMLELEMENT_PARENT                DISPID_XMLELEMENT + 2
#define DISPID_XMLELEMENT_SETATTRIBUTE          DISPID_XMLELEMENT + 3
#define DISPID_XMLELEMENT_GETATTRIBUTE          DISPID_XMLELEMENT + 4
#define DISPID_XMLELEMENT_REMOVEATTRIBUTE       DISPID_XMLELEMENT + 5
#define DISPID_XMLELEMENT_CHILDREN              DISPID_XMLELEMENT + 6
#define DISPID_XMLELEMENT_TYPE                  DISPID_XMLELEMENT + 7
#define DISPID_XMLELEMENT_TEXT                  DISPID_XMLELEMENT + 8
#define DISPID_XMLELEMENT_ADDCHILD              DISPID_XMLELEMENT + 9
#define DISPID_XMLELEMENT_REMOVECHILD           DISPID_XMLELEMENT + 10
#define DISPID_XMLELEMENT_ATTRIBUTES            DISPID_XMLELEMENT + 11

#define DISPID_XMLNOTIFSINK                     DISPID_XMLELEMENT + 100

#define DISPID_XMLNOTIFSINK_CHILDADDED          DISPID_XMLNOTIFSINK + 1

#define DISPID_XMLATTRIBUTE                     DISPID_XMLNOTIFSINK + 100

#define DISPID_XMLATTRIBUTE_NAME                DISPID_XMLATTRIBUTE + 1
#define DISPID_XMLATTRIBUTE_VALUE               DISPID_XMLATTRIBUTE + 2


#endif // __MSXMLDID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtsgrp_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:07 1997
 */
/* Compiler settings for mtsgrp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMtsGrp = {0x4B2E958C,0x0393,0x11D1,{0xB1,0xAB,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID LIBID_MTSGRPLib = {0x4B2E957D,0x0393,0x11D1,{0xB1,0xAB,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const CLSID CLSID_MtsGrp = {0x4B2E958D,0x0393,0x11D1,{0xB1,0xAB,0x00,0xAA,0x00,0xBA,0x32,0x58}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtsevents_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:07 1997
 */
/* Compiler settings for mtsevents.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMtsEvents = {0xBACEDF4D,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsEventInfo = {0xD56C3DC1,0x8482,0x11d0,{0xB1,0x70,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IEventMoniker = {0xC8CF32B3,0x7885,0x11D0,{0xB1,0x69,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMTSLocater = {0xD19B8BFD,0x7F88,0x11D0,{0xB1,0x6E,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID LIBID_MTSEVENTSLib = {0xBACEDF3E,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const CLSID CLSID_CoMTSEvents = {0xBACEDF4E,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const CLSID CLSID_EventMoniker = {0xC8CF32B4,0x7885,0x11D0,{0xB1,0x69,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const CLSID CLSID_CoMTSLocater = {0xD19B8BFE,0x7F88,0x11D0,{0xB1,0x6E,0x00,0xAA,0x00,0xBA,0x32,0x58}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtsgrp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:07 1997
 */
/* Compiler settings for mtsgrp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtsgrp_h__
#define __mtsgrp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMtsGrp_FWD_DEFINED__
#define __IMtsGrp_FWD_DEFINED__
typedef interface IMtsGrp IMtsGrp;
#endif 	/* __IMtsGrp_FWD_DEFINED__ */


#ifndef __MtsGrp_FWD_DEFINED__
#define __MtsGrp_FWD_DEFINED__

#ifdef __cplusplus
typedef class MtsGrp MtsGrp;
#else
typedef struct MtsGrp MtsGrp;
#endif /* __cplusplus */

#endif 	/* __MtsGrp_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IMtsGrp_INTERFACE_DEFINED__
#define __IMtsGrp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsGrp
 * at Thu Sep 11 16:03:07 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IMtsGrp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("4B2E958C-0393-11D1-B1AB-00AA00BA3258")
    IMtsGrp : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long lIndex,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkDispatcher) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsGrpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsGrp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsGrp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsGrp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMtsGrp __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMtsGrp __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMtsGrp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMtsGrp __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMtsGrp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IMtsGrp __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkDispatcher);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IMtsGrp __RPC_FAR * This);
        
        END_INTERFACE
    } IMtsGrpVtbl;

    interface IMtsGrp
    {
        CONST_VTBL struct IMtsGrpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsGrp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsGrp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsGrp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsGrp_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMtsGrp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMtsGrp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMtsGrp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMtsGrp_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IMtsGrp_Item(This,lIndex,ppUnkDispatcher)	\
    (This)->lpVtbl -> Item(This,lIndex,ppUnkDispatcher)

#define IMtsGrp_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMtsGrp_get_Count_Proxy( 
    IMtsGrp __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMtsGrp_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMtsGrp_Item_Proxy( 
    IMtsGrp __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkDispatcher);


void __RPC_STUB IMtsGrp_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMtsGrp_Refresh_Proxy( 
    IMtsGrp __RPC_FAR * This);


void __RPC_STUB IMtsGrp_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsGrp_INTERFACE_DEFINED__ */



#ifndef __MTSGRPLib_LIBRARY_DEFINED__
#define __MTSGRPLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSGRPLib
 * at Thu Sep 11 16:03:07 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MTSGRPLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_MtsGrp;

class DECLSPEC_UUID("4B2E958D-0393-11D1-B1AB-00AA00BA3258")
MtsGrp;
#endif
#endif /* __MTSGRPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtxadmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:04 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxadmin_h__
#define __mtxadmin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICatalog_FWD_DEFINED__
#define __ICatalog_FWD_DEFINED__
typedef interface ICatalog ICatalog;
#endif 	/* __ICatalog_FWD_DEFINED__ */


#ifndef __ICatalogObject_FWD_DEFINED__
#define __ICatalogObject_FWD_DEFINED__
typedef interface ICatalogObject ICatalogObject;
#endif 	/* __ICatalogObject_FWD_DEFINED__ */


#ifndef __ICatalogCollection_FWD_DEFINED__
#define __ICatalogCollection_FWD_DEFINED__
typedef interface ICatalogCollection ICatalogCollection;
#endif 	/* __ICatalogCollection_FWD_DEFINED__ */


#ifndef __IComponentUtil_FWD_DEFINED__
#define __IComponentUtil_FWD_DEFINED__
typedef interface IComponentUtil IComponentUtil;
#endif 	/* __IComponentUtil_FWD_DEFINED__ */


#ifndef __IPackageUtil_FWD_DEFINED__
#define __IPackageUtil_FWD_DEFINED__
typedef interface IPackageUtil IPackageUtil;
#endif 	/* __IPackageUtil_FWD_DEFINED__ */


#ifndef __IRemoteComponentUtil_FWD_DEFINED__
#define __IRemoteComponentUtil_FWD_DEFINED__
typedef interface IRemoteComponentUtil IRemoteComponentUtil;
#endif 	/* __IRemoteComponentUtil_FWD_DEFINED__ */


#ifndef __IRoleAssociationUtil_FWD_DEFINED__
#define __IRoleAssociationUtil_FWD_DEFINED__
typedef interface IRoleAssociationUtil IRoleAssociationUtil;
#endif 	/* __IRoleAssociationUtil_FWD_DEFINED__ */


#ifndef __Catalog_FWD_DEFINED__
#define __Catalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class Catalog Catalog;
#else
typedef struct Catalog Catalog;
#endif /* __cplusplus */

#endif 	/* __Catalog_FWD_DEFINED__ */


#ifndef __CatalogObject_FWD_DEFINED__
#define __CatalogObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogObject CatalogObject;
#else
typedef struct CatalogObject CatalogObject;
#endif /* __cplusplus */

#endif 	/* __CatalogObject_FWD_DEFINED__ */


#ifndef __CatalogCollection_FWD_DEFINED__
#define __CatalogCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogCollection CatalogCollection;
#else
typedef struct CatalogCollection CatalogCollection;
#endif /* __cplusplus */

#endif 	/* __CatalogCollection_FWD_DEFINED__ */


#ifndef __ComponentUtil_FWD_DEFINED__
#define __ComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComponentUtil ComponentUtil;
#else
typedef struct ComponentUtil ComponentUtil;
#endif /* __cplusplus */

#endif 	/* __ComponentUtil_FWD_DEFINED__ */


#ifndef __PackageUtil_FWD_DEFINED__
#define __PackageUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class PackageUtil PackageUtil;
#else
typedef struct PackageUtil PackageUtil;
#endif /* __cplusplus */

#endif 	/* __PackageUtil_FWD_DEFINED__ */


#ifndef __RemoteComponentUtil_FWD_DEFINED__
#define __RemoteComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteComponentUtil RemoteComponentUtil;
#else
typedef struct RemoteComponentUtil RemoteComponentUtil;
#endif /* __cplusplus */

#endif 	/* __RemoteComponentUtil_FWD_DEFINED__ */


#ifndef __RoleAssociationUtil_FWD_DEFINED__
#define __RoleAssociationUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RoleAssociationUtil RoleAssociationUtil;
#else
typedef struct RoleAssociationUtil RoleAssociationUtil;
#endif /* __cplusplus */

#endif 	/* __RoleAssociationUtil_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxadmin_0000
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtxadmin.h  -- Microsoft Transaction Server Programming Interfaces				
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server applications.													
//																			
// Microsoft Transaction Server SDK												
// Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	
#include <objbase.h>
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_s_ifspec;

#ifndef __ICatalog_INTERFACE_DEFINED__
#define __ICatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalog
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22870-8a19-11d0-81b6-00a0c9231c29")
    ICatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MajorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogVtbl;

    interface ICatalog
    {
        CONST_VTBL struct ICatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalog_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection)

#define ICatalog_Connect(This,bstrConnectString,ppCatalogCollection)	\
    (This)->lpVtbl -> Connect(This,bstrConnectString,ppCatalogCollection)

#define ICatalog_get_MajorVersion(This,retval)	\
    (This)->lpVtbl -> get_MajorVersion(This,retval)

#define ICatalog_get_MinorVersion(This,retval)	\
    (This)->lpVtbl -> get_MinorVersion(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_GetCollection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_Connect_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrConnectString,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MajorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MinorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalog_INTERFACE_DEFINED__ */


#ifndef __ICatalogObject_INTERFACE_DEFINED__
#define __ICatalogObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogObject
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22871-8a19-11d0-81b6-00a0c9231c29")
    ICatalogObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyReadOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Valid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyWriteOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyReadOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Valid )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyWriteOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogObjectVtbl;

    interface ICatalogObject
    {
        CONST_VTBL struct ICatalogObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogObject_get_Value(This,bstrPropName,retval)	\
    (This)->lpVtbl -> get_Value(This,bstrPropName,retval)

#define ICatalogObject_put_Value(This,bstrPropName,val)	\
    (This)->lpVtbl -> put_Value(This,bstrPropName,val)

#define ICatalogObject_get_Key(This,retval)	\
    (This)->lpVtbl -> get_Key(This,retval)

#define ICatalogObject_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogObject_IsPropertyReadOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyReadOnly(This,bstrPropName,retval)

#define ICatalogObject_get_Valid(This,retval)	\
    (This)->lpVtbl -> get_Valid(This,retval)

#define ICatalogObject_IsPropertyWriteOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyWriteOnly(This,bstrPropName,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICatalogObject_put_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [in] */ VARIANT val);


void __RPC_STUB ICatalogObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Key_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Name_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyReadOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Valid_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Valid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyWriteOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyWriteOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogCollection_INTERFACE_DEFINED__
#define __ICatalogCollection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogCollection
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22872-8a19-11d0-81b6-00a0c9231c29")
    ICatalogCollection : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Populate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoveEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUtilInterface( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByKey( 
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByQuery( 
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Populate )( 
            ICatalogCollection __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RemoveEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUtilInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMajorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMinorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByKey )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByQuery )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType);
        
        END_INTERFACE
    } ICatalogCollectionVtbl;

    interface ICatalogCollection
    {
        CONST_VTBL struct ICatalogCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogCollection_get__NewEnum(This,ppEnumVariant)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumVariant)

#define ICatalogCollection_get_Item(This,lIndex,ppCatalogObject)	\
    (This)->lpVtbl -> get_Item(This,lIndex,ppCatalogObject)

#define ICatalogCollection_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define ICatalogCollection_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define ICatalogCollection_Add(This,ppCatalogObject)	\
    (This)->lpVtbl -> Add(This,ppCatalogObject)

#define ICatalogCollection_Populate(This)	\
    (This)->lpVtbl -> Populate(This)

#define ICatalogCollection_SaveChanges(This,retval)	\
    (This)->lpVtbl -> SaveChanges(This,retval)

#define ICatalogCollection_GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)

#define ICatalogCollection_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogCollection_get_AddEnabled(This,retval)	\
    (This)->lpVtbl -> get_AddEnabled(This,retval)

#define ICatalogCollection_get_RemoveEnabled(This,retval)	\
    (This)->lpVtbl -> get_RemoveEnabled(This,retval)

#define ICatalogCollection_GetUtilInterface(This,ppUtil)	\
    (This)->lpVtbl -> GetUtilInterface(This,ppUtil)

#define ICatalogCollection_get_DataStoreMajorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMajorVersion(This,retval)

#define ICatalogCollection_get_DataStoreMinorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMinorVersion(This,retval)

#define ICatalogCollection_PopulateByKey(This,aKeys)	\
    (This)->lpVtbl -> PopulateByKey(This,aKeys)

#define ICatalogCollection_PopulateByQuery(This,bstrQueryString,lQueryType)	\
    (This)->lpVtbl -> PopulateByQuery(This,bstrQueryString,lQueryType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get__NewEnum_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);


void __RPC_STUB ICatalogCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Item_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Count_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Remove_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex);


void __RPC_STUB ICatalogCollection_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Add_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Populate_Proxy( 
    ICatalogCollection __RPC_FAR * This);


void __RPC_STUB ICatalogCollection_Populate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_SaveChanges_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetCollection_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [in] */ VARIANT varObjectKey,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalogCollection_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Name_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_AddEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_AddEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_RemoveEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_RemoveEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetUtilInterface_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);


void __RPC_STUB ICatalogCollection_GetUtilInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMajorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMinorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByKey_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * aKeys);


void __RPC_STUB ICatalogCollection_PopulateByKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByQuery_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrQueryString,
    /* [in] */ long lQueryType);


void __RPC_STUB ICatalogCollection_PopulateByQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogCollection_INTERFACE_DEFINED__ */


#ifndef __IComponentUtil_INTERFACE_DEFINED__
#define __IComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponentUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22873-8a19-11d0-81b6-00a0c9231c29")
    IComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallComponent( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponent( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponentByName( 
            /* [in] */ BSTR bstrProgID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCLSIDs( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponentByName )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDs )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);
        
        END_INTERFACE
    } IComponentUtilVtbl;

    interface IComponentUtil
    {
        CONST_VTBL struct IComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComponentUtil_InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)	\
    (This)->lpVtbl -> InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)

#define IComponentUtil_ImportComponent(This,bstrCLSID)	\
    (This)->lpVtbl -> ImportComponent(This,bstrCLSID)

#define IComponentUtil_ImportComponentByName(This,bstrProgID)	\
    (This)->lpVtbl -> ImportComponentByName(This,bstrProgID)

#define IComponentUtil_GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)	\
    (This)->lpVtbl -> GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_InstallComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [in] */ BSTR bstrProxyStubDLLFile);


void __RPC_STUB IComponentUtil_InstallComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IComponentUtil_ImportComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponentByName_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IComponentUtil_ImportComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_GetCLSIDs_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);


void __RPC_STUB IComponentUtil_GetCLSIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IPackageUtil_INTERFACE_DEFINED__
#define __IPackageUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPackageUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IPackageUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22874-8a19-11d0-81b6-00a0c9231c29")
    IPackageUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportPackage( 
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownPackage( 
            /* [in] */ BSTR bstrPackageID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPackageUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPackageUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPackageUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPackageUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID);
        
        END_INTERFACE
    } IPackageUtilVtbl;

    interface IPackageUtil
    {
        CONST_VTBL struct IPackageUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPackageUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPackageUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPackageUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPackageUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPackageUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPackageUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPackageUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPackageUtil_InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)	\
    (This)->lpVtbl -> InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)

#define IPackageUtil_ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)	\
    (This)->lpVtbl -> ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)

#define IPackageUtil_ShutdownPackage(This,bstrPackageID)	\
    (This)->lpVtbl -> ShutdownPackage(This,bstrPackageID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_InstallPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ BSTR bstrInstallPath,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ExportPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_ExportPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ShutdownPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID);


void __RPC_STUB IPackageUtil_ShutdownPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPackageUtil_INTERFACE_DEFINED__ */


#ifndef __IRemoteComponentUtil_INTERFACE_DEFINED__
#define __IRemoteComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteComponentUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRemoteComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22875-8a19-11d0-81b6-00a0c9231c29")
    IRemoteComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponent( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponentByName( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponent )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponentByName )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID);
        
        END_INTERFACE
    } IRemoteComponentUtilVtbl;

    interface IRemoteComponentUtil
    {
        CONST_VTBL struct IRemoteComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteComponentUtil_InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)	\
    (This)->lpVtbl -> InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)

#define IRemoteComponentUtil_InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)	\
    (This)->lpVtbl -> InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponent_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponentByName_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageName,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IRoleAssociationUtil_INTERFACE_DEFINED__
#define __IRoleAssociationUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRoleAssociationUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRoleAssociationUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22876-8a19-11d0-81b6-00a0c9231c29")
    IRoleAssociationUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRole( 
            /* [in] */ BSTR bstrRoleID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRoleByName( 
            /* [in] */ BSTR bstrRoleName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRoleAssociationUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRole )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRoleByName )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleName);
        
        END_INTERFACE
    } IRoleAssociationUtilVtbl;

    interface IRoleAssociationUtil
    {
        CONST_VTBL struct IRoleAssociationUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRoleAssociationUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRoleAssociationUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRoleAssociationUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRoleAssociationUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRoleAssociationUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRoleAssociationUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRoleAssociationUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRoleAssociationUtil_AssociateRole(This,bstrRoleID)	\
    (This)->lpVtbl -> AssociateRole(This,bstrRoleID)

#define IRoleAssociationUtil_AssociateRoleByName(This,bstrRoleName)	\
    (This)->lpVtbl -> AssociateRoleByName(This,bstrRoleName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRole_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleID);


void __RPC_STUB IRoleAssociationUtil_AssociateRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRoleByName_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleName);


void __RPC_STUB IRoleAssociationUtil_AssociateRoleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRoleAssociationUtil_INTERFACE_DEFINED__ */



#ifndef __MTSAdmin_LIBRARY_DEFINED__
#define __MTSAdmin_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSAdmin
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0001
    {	mtsInstallUsers	= 1
    }	MTSPackageInstallOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0002
    {	mtsExportUsers	= 1
    }	MTSPackageExportOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0003
    {	mtsErrObjectErrors	= 0x80110401,
	mtsErrObjectInvalid	= 0x80110402,
	mtsErrKeyMissing	= 0x80110403,
	mtsErrAlreadyInstalled	= 0x80110404,
	mtsErrDownloadFailed	= 0x80110405,
	mtsErrPDFWriteFail	= 0x80110407,
	mtsErrPDFReadFail	= 0x80110408,
	mtsErrPDFVersion	= 0x80110409,
	mtsErrCoReqCompInstalled	= 0x80110410,
	mtsErrBadPath	= 0x8011040a,
	mtsErrPackageExists	= 0x8011040b,
	mtsErrRoleExists	= 0x8011040c,
	mtsErrCantCopyFile	= 0x8011040d,
	mtsErrNoTypeLib	= 0x8011040e,
	mtsErrNoUser	= 0x8011040f,
	mtsErrInvalidUserids	= 0x80110410,
	mtsErrNoRegistryCLSID	= 0x80110411,
	mtsErrBadRegistryProgID	= 0x80110412,
	mtsErrAuthenticationLevel	= 0x80110413,
	mtsErrUserPasswdNotValid	= 0x80110414,
	mtsErrNoRegistryRead	= 0x80110415,
	mtsErrNoRegistryWrite	= 0x80110416,
	mtsErrNoRegistryRepair	= 0x80110417,
	mtsErrCLSIDOrIIDMismatch	= 0x80110418,
	mtsErrRemoteInterface	= 0x80110419,
	mtsErrDllRegisterServer	= 0x8011041a,
	mtsErrNoServerShare	= 0x8011041b,
	mtsErrNoAccessToUNC	= 0x8011041c,
	mtsErrDllLoadFailed	= 0x8011041d,
	mtsErrBadRegistryLibID	= 0x8011041e,
	mtsErrPackDirNotFound	= 0x8011041f,
	mtsErrTreatAs	= 0x80110420,
	mtsErrBadForward	= 0x80110421,
	mtsErrBadIID	= 0x80110422,
	mtsErrRegistrarFailed	= 0x80110423,
	mtsErrCompFileDoesNotExist	= 0x80110424,
	mtsErrCompFileLoadDLLFail	= 0x80110425,
	mtsErrCompFileGetClassObj	= 0x80110426,
	mtsErrCompFileClassNotAvail	= 0x80110427,
	mtsErrCompFileBadTLB	= 0x80110428,
	mtsErrCompFileNotInstallable	= 0x80110429,
	mtsErrNotChangeable	= 0x8011042a,
	mtsErrNotDeletable	= 0x8011042b,
	mtsErrSession	= 0x8011042c,
	mtsErrCompFileNoRegistrar	= 0x80110434
    }	MTSAdminErrorCodes;

#define E_MTS_OBJECTERRORS			 	mtsErrObjectErrors				
#define E_MTS_OBJECTINVALID				mtsErrObjectInvalid				
#define E_MTS_KEYMISSING				mtsErrKeyMissing				
#define E_MTS_ALREADYINSTALLED			mtsErrAlreadyInstalled			
#define E_MTS_DOWNLOADFAILED			mtsErrDownloadFailed			
#define E_MTS_PDFWRITEFAIL				mtsErrPDFWriteFail				
#define E_MTS_PDFREADFAIL				mtsErrPDFReadFail				
#define E_MTS_PDFVERSION				mtsErrPDFVersion				
#define E_MTS_COREQCOMPINSTALLED		mtsErrCoReqCompInstalled		
#define E_MTS_BADPATH					mtsErrBadPath					
#define E_MTS_PACKAGEEXISTS				mtsErrPackageExists				
#define E_MTS_ROLEEXISTS				mtsErrRoleExists				
#define E_MTS_CANTCOPYFILE				mtsErrCantCopyFile				
#define E_MTS_NOTYPELIB					mtsErrNoTypeLib					
#define E_MTS_NOUSER					mtsErrNoUser					
#define E_MTS_INVALIDUSERIDS			mtsErrInvalidUserids			
#define E_MTS_NOREGISTRYCLSID			mtsErrNoRegistryCLSID			
#define E_MTS_BADREGISTRYPROGID			mtsErrBadRegistryProgID			
#define E_MTS_AUTHENTICATIONLEVEL		mtsErrAuthenticationLevel		
#define E_MTS_USERPASSWDNOTVALID		mtsErrUserPasswdNotValid		
#define E_MTS_NOREGISTRYREAD			mtsErrNoRegistryRead			
#define E_MTS_NOREGISTRYWRITE			mtsErrNoRegistryWrite			
#define E_MTS_NOREGISTRYREPAIR			mtsErrNoRegistryRepair			
#define E_MTS_CLSIDORIIDMISMATCH		mtsErrCLSIDOrIIDMismatch		
#define E_MTS_REMOTEINTERFACE			mtsErrRemoteInterface			
#define E_MTS_DLLREGISTERSERVER			mtsErrDllRegisterServer			
#define E_MTS_NOSERVERSHARE				mtsErrNoServerShare				
#define E_MTS_NOACCESSTOUNC				mtsErrNoAccessToUNC				
#define E_MTS_DLLLOADFAILED				mtsErrDllLoadFailed				
#define E_MTS_BADREGISTRYLIBID			mtsErrBadRegistryLibID			
#define E_MTS_PACKDIRNOTFOUND			mtsErrPackDirNotFound			
#define E_MTS_TREATAS					mtsErrTreatAs					
#define E_MTS_BADFORWARD				mtsErrBadForward				
#define E_MTS_BADIID					mtsErrBadIID					
#define E_MTS_REGISTRARFAILED			mtsErrRegistrarFailed			
#define E_MTS_COMPFILE_DOESNOTEXIST		mtsErrCompFileDoesNotExist		
#define E_MTS_COMPFILE_LOADDLLFAIL		mtsErrCompFileLoadDLLFail		
#define E_MTS_COMPFILE_GETCLASSOBJ		mtsErrCompFileGetClassObj		
#define E_MTS_COMPFILE_CLASSNOTAVAIL	mtsErrCompFileClassNotAvail		
#define E_MTS_COMPFILE_BADTLB			mtsErrCompFileBadTLB			
#define E_MTS_COMPFILE_NOTINSTALLABLE	mtsErrCompFileNotInstallable	
#define E_MTS_NOTCHANGEABLE				mtsErrNotChangeable				
#define E_MTS_NOTDELETEABLE				mtsErrNotDeleteable				
#define E_MTS_SESSION					mtsErrSession					
#define E_MTS_COMPFILE_NOREGISTRAR		mtsErrCompFileNoRegistrar		

EXTERN_C const IID LIBID_MTSAdmin;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Catalog;

class DECLSPEC_UUID("6eb22881-8a19-11d0-81b6-00a0c9231c29")
Catalog;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogObject;

class DECLSPEC_UUID("6eb22882-8a19-11d0-81b6-00a0c9231c29")
CatalogObject;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogCollection;

class DECLSPEC_UUID("6eb22883-8a19-11d0-81b6-00a0c9231c29")
CatalogCollection;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ComponentUtil;

class DECLSPEC_UUID("6eb22884-8a19-11d0-81b6-00a0c9231c29")
ComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PackageUtil;

class DECLSPEC_UUID("6eb22885-8a19-11d0-81b6-00a0c9231c29")
PackageUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RemoteComponentUtil;

class DECLSPEC_UUID("6eb22886-8a19-11d0-81b6-00a0c9231c29")
RemoteComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RoleAssociationUtil;

class DECLSPEC_UUID("6eb22887-8a19-11d0-81b6-00a0c9231c29")
RoleAssociationUtil;
#endif
#endif /* __MTSAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sat Nov 08 05:10:47 1997
 */
/* Compiler settings for mtx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtx_h__
#define __mtx_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IObjectContext_FWD_DEFINED__
#define __IObjectContext_FWD_DEFINED__
typedef interface IObjectContext IObjectContext;
#endif 	/* __IObjectContext_FWD_DEFINED__ */


#ifndef __IGetContextProperties_FWD_DEFINED__
#define __IGetContextProperties_FWD_DEFINED__
typedef interface IGetContextProperties IGetContextProperties;
#endif 	/* __IGetContextProperties_FWD_DEFINED__ */


#ifndef __IEnumNames_FWD_DEFINED__
#define __IEnumNames_FWD_DEFINED__
typedef interface IEnumNames IEnumNames;
#endif 	/* __IEnumNames_FWD_DEFINED__ */


#ifndef __ISecurityProperty_FWD_DEFINED__
#define __ISecurityProperty_FWD_DEFINED__
typedef interface ISecurityProperty ISecurityProperty;
#endif 	/* __ISecurityProperty_FWD_DEFINED__ */


#ifndef __IObjectControl_FWD_DEFINED__
#define __IObjectControl_FWD_DEFINED__
typedef interface IObjectControl IObjectControl;
#endif 	/* __IObjectControl_FWD_DEFINED__ */


#ifndef __IObjectContextActivity_FWD_DEFINED__
#define __IObjectContextActivity_FWD_DEFINED__
typedef interface IObjectContextActivity IObjectContextActivity;
#endif 	/* __IObjectContextActivity_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtx_0000
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtx.h  -- Microsoft Transaction Server Programming Interfaces				
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server applications.													
//																			
// Microsoft Transaction Server 2.0											
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	
#include <objbase.h>
#ifndef _MTX_NOFORCE_LIBS
#pragma comment(lib, "mtx.lib")
#endif
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#define CONTEXT_E_ABORTED				0x8004E002
#define CONTEXT_E_ABORTING				0x8004E003
#define CONTEXT_E_NOCONTEXT				0x8004E004
#define CONTEXT_E_NOTREGISTERED			0x8004E005
#define CONTEXT_E_OLDREF					0x8004E007
#define CONTEXT_E_ROLENOTFOUND			0x8004E00C
#define CONTEXT_E_NOSECURITY				0x8004E00D
#define CONTEXT_E_WRONGTHREAD			0x8004E00E
#define CONTEXT_E_TMNOTAVAILABLE			0x8004E00F
#define CONTEXT_E_INSUFFICIENTLICENSES	0x8004E020



extern RPC_IF_HANDLE __MIDL_itf_mtx_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtx_0000_v0_0_s_ifspec;

#ifndef __IObjectContext_INTERFACE_DEFINED__
#define __IObjectContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectContext
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IObjectContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372ae0-cae7-11cf-be81-00aa00a2fa25")
    IObjectContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID __RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableCommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableCommit( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsInTransaction( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsSecurityEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCallerInRole( 
            /* [in] */ BSTR __MIDL_0000,
            /* [retval][out] */ BOOL __RPC_FAR *__MIDL_0001) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            IObjectContext __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID __RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComplete )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAbort )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableCommit )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableCommit )( 
            IObjectContext __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsInTransaction )( 
            IObjectContext __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsSecurityEnabled )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsCallerInRole )( 
            IObjectContext __RPC_FAR * This,
            /* [in] */ BSTR __MIDL_0000,
            /* [retval][out] */ BOOL __RPC_FAR *__MIDL_0001);
        
        END_INTERFACE
    } IObjectContextVtbl;

    interface IObjectContext
    {
        CONST_VTBL struct IObjectContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectContext_CreateInstance(This,rclsid,riid,ppv)	\
    (This)->lpVtbl -> CreateInstance(This,rclsid,riid,ppv)

#define IObjectContext_SetComplete(This)	\
    (This)->lpVtbl -> SetComplete(This)

#define IObjectContext_SetAbort(This)	\
    (This)->lpVtbl -> SetAbort(This)

#define IObjectContext_EnableCommit(This)	\
    (This)->lpVtbl -> EnableCommit(This)

#define IObjectContext_DisableCommit(This)	\
    (This)->lpVtbl -> DisableCommit(This)

#define IObjectContext_IsInTransaction(This)	\
    (This)->lpVtbl -> IsInTransaction(This)

#define IObjectContext_IsSecurityEnabled(This)	\
    (This)->lpVtbl -> IsSecurityEnabled(This)

#define IObjectContext_IsCallerInRole(This,__MIDL_0000,__MIDL_0001)	\
    (This)->lpVtbl -> IsCallerInRole(This,__MIDL_0000,__MIDL_0001)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectContext_CreateInstance_Proxy( 
    IObjectContext __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFIID riid,
    /* [retval][iid_is][out] */ LPVOID __RPC_FAR *ppv);


void __RPC_STUB IObjectContext_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_SetComplete_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_SetComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_SetAbort_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_SetAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_EnableCommit_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_EnableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_DisableCommit_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_DisableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IObjectContext_IsInTransaction_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_IsInTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IObjectContext_IsSecurityEnabled_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_IsSecurityEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_IsCallerInRole_Proxy( 
    IObjectContext __RPC_FAR * This,
    /* [in] */ BSTR __MIDL_0000,
    /* [retval][out] */ BOOL __RPC_FAR *__MIDL_0001);


void __RPC_STUB IObjectContext_IsCallerInRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectContext_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtx_0006
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_mtx_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtx_0006_v0_0_s_ifspec;

#ifndef __IGetContextProperties_INTERFACE_DEFINED__
#define __IGetContextProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetContextProperties
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IGetContextProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372af4-cae7-11cf-be81-00aa00a2fa25")
    IGetContextProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNames( 
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetContextPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetContextProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetContextProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetContextProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IGetContextProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IGetContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNames )( 
            IGetContextProperties __RPC_FAR * This,
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IGetContextPropertiesVtbl;

    interface IGetContextProperties
    {
        CONST_VTBL struct IGetContextPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetContextProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetContextProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetContextProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetContextProperties_Count(This,plCount)	\
    (This)->lpVtbl -> Count(This,plCount)

#define IGetContextProperties_GetProperty(This,name,pProperty)	\
    (This)->lpVtbl -> GetProperty(This,name,pProperty)

#define IGetContextProperties_EnumNames(This,ppenum)	\
    (This)->lpVtbl -> EnumNames(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetContextProperties_Count_Proxy( 
    IGetContextProperties __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IGetContextProperties_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGetContextProperties_GetProperty_Proxy( 
    IGetContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pProperty);


void __RPC_STUB IGetContextProperties_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGetContextProperties_EnumNames_Proxy( 
    IGetContextProperties __RPC_FAR * This,
    /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IGetContextProperties_EnumNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetContextProperties_INTERFACE_DEFINED__ */


#ifndef __IEnumNames_INTERFACE_DEFINED__
#define __IEnumNames_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumNames
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IEnumNames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372af2-cae7-11cf-be81-00aa00a2fa25")
    IEnumNames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long celt,
            /* [size_is][out] */ BSTR __RPC_FAR *rgname,
            /* [retval][out] */ unsigned long __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNamesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNames __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNames __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNames __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNames __RPC_FAR * This,
            /* [in] */ unsigned long celt,
            /* [size_is][out] */ BSTR __RPC_FAR *rgname,
            /* [retval][out] */ unsigned long __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNames __RPC_FAR * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNames __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNames __RPC_FAR * This,
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumNamesVtbl;

    interface IEnumNames
    {
        CONST_VTBL struct IEnumNamesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNames_Next(This,celt,rgname,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgname,pceltFetched)

#define IEnumNames_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNames_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNames_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNames_Next_Proxy( 
    IEnumNames __RPC_FAR * This,
    /* [in] */ unsigned long celt,
    /* [size_is][out] */ BSTR __RPC_FAR *rgname,
    /* [retval][out] */ unsigned long __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumNames_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNames_Skip_Proxy( 
    IEnumNames __RPC_FAR * This,
    /* [in] */ unsigned long celt);


void __RPC_STUB IEnumNames_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNames_Reset_Proxy( 
    IEnumNames __RPC_FAR * This);


void __RPC_STUB IEnumNames_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNames_Clone_Proxy( 
    IEnumNames __RPC_FAR * This,
    /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumNames_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNames_INTERFACE_DEFINED__ */


#ifndef __ISecurityProperty_INTERFACE_DEFINED__
#define __ISecurityProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISecurityProperty
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_ISecurityProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372aea-cae7-11cf-be81-00aa00a2fa25")
    ISecurityProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDirectCreatorSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalCreatorSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectCallerSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalCallerSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSID( 
            PSID pSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecurityPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISecurityProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISecurityProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISecurityProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectCreatorSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOriginalCreatorSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectCallerSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOriginalCallerSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID pSID);
        
        END_INTERFACE
    } ISecurityPropertyVtbl;

    interface ISecurityProperty
    {
        CONST_VTBL struct ISecurityPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecurityProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISecurityProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISecurityProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISecurityProperty_GetDirectCreatorSID(This,pSID)	\
    (This)->lpVtbl -> GetDirectCreatorSID(This,pSID)

#define ISecurityProperty_GetOriginalCreatorSID(This,pSID)	\
    (This)->lpVtbl -> GetOriginalCreatorSID(This,pSID)

#define ISecurityProperty_GetDirectCallerSID(This,pSID)	\
    (This)->lpVtbl -> GetDirectCallerSID(This,pSID)

#define ISecurityProperty_GetOriginalCallerSID(This,pSID)	\
    (This)->lpVtbl -> GetOriginalCallerSID(This,pSID)

#define ISecurityProperty_ReleaseSID(This,pSID)	\
    (This)->lpVtbl -> ReleaseSID(This,pSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISecurityProperty_GetDirectCreatorSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetDirectCreatorSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_GetOriginalCreatorSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetOriginalCreatorSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_GetDirectCallerSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetDirectCallerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_GetOriginalCallerSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetOriginalCallerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_ReleaseSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID pSID);


void __RPC_STUB ISecurityProperty_ReleaseSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISecurityProperty_INTERFACE_DEFINED__ */


#ifndef __IObjectControl_INTERFACE_DEFINED__
#define __IObjectControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectControl
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IObjectControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372aec-cae7-11cf-be81-00aa00a2fa25")
    IObjectControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual void STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE CanBePooled( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IObjectControl __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IObjectControl __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *CanBePooled )( 
            IObjectControl __RPC_FAR * This);
        
        END_INTERFACE
    } IObjectControlVtbl;

    interface IObjectControl
    {
        CONST_VTBL struct IObjectControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectControl_Activate(This)	\
    (This)->lpVtbl -> Activate(This)

#define IObjectControl_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IObjectControl_CanBePooled(This)	\
    (This)->lpVtbl -> CanBePooled(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectControl_Activate_Proxy( 
    IObjectControl __RPC_FAR * This);


void __RPC_STUB IObjectControl_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IObjectControl_Deactivate_Proxy( 
    IObjectControl __RPC_FAR * This);


void __RPC_STUB IObjectControl_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IObjectControl_CanBePooled_Proxy( 
    IObjectControl __RPC_FAR * This);


void __RPC_STUB IObjectControl_CanBePooled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectControl_INTERFACE_DEFINED__ */


#ifndef __IObjectContextActivity_INTERFACE_DEFINED__
#define __IObjectContextActivity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectContextActivity
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IObjectContextActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372afc-cae7-11cf-be81-00aa00a2fa25")
    IObjectContextActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActivityId( 
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectContextActivity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectContextActivity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectContextActivity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActivityId )( 
            IObjectContextActivity __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        END_INTERFACE
    } IObjectContextActivityVtbl;

    interface IObjectContextActivity
    {
        CONST_VTBL struct IObjectContextActivityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContextActivity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectContextActivity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectContextActivity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectContextActivity_GetActivityId(This,pGUID)	\
    (This)->lpVtbl -> GetActivityId(This,pGUID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectContextActivity_GetActivityId_Proxy( 
    IObjectContextActivity __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB IObjectContextActivity_GetActivityId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectContextActivity_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtx_0100
 * at Sat Nov 08 05:10:47 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


extern HRESULT __cdecl GetObjectContext (IObjectContext** ppInstanceContext);
extern void* __cdecl SafeRef(REFIID rid, IUnknown* pUnk);


extern RPC_IF_HANDLE __MIDL_itf_mtx_0100_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtx_0100_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtxdm_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:06 1997
 */
/* Compiler settings for mtxdm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IDispenserManager = {0x5cb31e10,0x2b5f,0x11cf,{0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25}};


const IID IID_IHolder = {0xbf6a1850,0x2b45,0x11cf,{0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25}};


const IID IID_IDispenserDriver = {0x208b3651,0x2b48,0x11cf,{0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\multimon.h ===
//=============================================================================
//
// multimon.h -- Stub module that fakes multiple monitor apis on Win32 OSes
//               without them.
//
// By using this header your code will get back default values from
// GetSystemMetrics() for new metrics, and the new multimonitor APIs
// will act like only one display is present on a Win32 OS without
// multimonitor APIs.
//
// Exactly one source must include this with COMPILE_MULTIMON_STUBS defined.
//
// Copyright (c) 1985-1998, Microsoft Corporation
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

//
// If we are building with Win95/NT4 headers, we need to declare
// the multimonitor-related metrics and APIs ourselves.
//
#ifndef SM_CMONITORS

#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81

// HMONITOR is already declared if WINVER >= 0x0500 in windef.h
// This is for components built with an older version number.
//
#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
DECLARE_HANDLE(HMONITOR);
#define HMONITOR_DECLARED
#endif

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002

#define MONITORINFOF_PRIMARY        0x00000001

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

#ifndef CCHDEVICENAME
#define CCHDEVICENAME 32
#endif

#ifdef __cplusplus
typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR        szDevice[CCHDEVICENAME];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEXW, *LPMONITORINFOEXW;
#ifdef UNICODE
typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;
#else
typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#endif // UNICODE
#else // ndef __cplusplus
typedef struct tagMONITORINFOEXA
{
    MONITORINFO;
    CHAR        szDevice[CCHDEVICENAME];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW
{
    MONITORINFO;
    WCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEXW, *LPMONITORINFOEXW;
#ifdef UNICODE
typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;
#else
typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#endif // UNICODE
#endif

typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOP
typedef struct _DISPLAY_DEVICEA {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
    CHAR   DeviceID[128];
    CHAR   DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD  cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
    WCHAR  DeviceID[128];
    WCHAR  DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;
#ifdef UNICODE
typedef DISPLAY_DEVICEW DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEW PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEW LPDISPLAY_DEVICE;
#else
typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
#endif // UNICODE

#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA_COMPATIBLE      0x00000010
#endif

#endif  // SM_CMONITORS

#undef GetMonitorInfo
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef EnumDisplayMonitors
#undef EnumDisplayDevices

//
// Define COMPILE_MULTIMON_STUBS to compile the stubs;
// otherwise, you get the declarations.
//
#ifdef COMPILE_MULTIMON_STUBS

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

#ifndef MULTIMON_FNS_DEFINED

int      (WINAPI* g_pfnGetSystemMetrics)(int) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, DWORD) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, DWORD) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, DWORD) = NULL;
BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO) = NULL;
BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM) = NULL;
BOOL     (WINAPI* g_pfnEnumDisplayDevices)(PVOID, DWORD, PDISPLAY_DEVICE,DWORD) = NULL;
BOOL     g_fMultiMonInitDone = FALSE;
BOOL     g_fMultimonPlatformNT = FALSE;

#endif

BOOL IsPlatformNT()
{ 
    OSVERSIONINFOA osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA((OSVERSIONINFOA*)&osvi);
    return (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);    
}

BOOL InitMultipleMonitorStubs(void)
{
    HMODULE hUser32;
    if (g_fMultiMonInitDone)
    {
        return g_pfnGetMonitorInfo != NULL;
    }

    g_fMultimonPlatformNT = IsPlatformNT();
    hUser32 = GetModuleHandle(TEXT("USER32"));
    if (hUser32 &&
        (*(FARPROC*)&g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) != NULL &&
        (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) != NULL &&
        (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) != NULL &&
        (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) != NULL &&
        (*(FARPROC*)&g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) != NULL &&
#ifdef UNICODE
        (*(FARPROC*)&g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesW")) != NULL &&
        (*(FARPROC*)&g_pfnGetMonitorInfo      = g_fMultimonPlatformNT ? GetProcAddress(hUser32,"GetMonitorInfoW") : 
                                                GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL
#else
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL &&
        (*(FARPROC*)&g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesA")) != NULL
#endif
    ) {
        g_fMultiMonInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnGetSystemMetrics    = NULL;
        g_pfnMonitorFromWindow   = NULL;
        g_pfnMonitorFromRect     = NULL;
        g_pfnMonitorFromPoint    = NULL;
        g_pfnGetMonitorInfo      = NULL;
        g_pfnEnumDisplayMonitors = NULL;
        g_pfnEnumDisplayDevices  = NULL;

        g_fMultiMonInitDone = TRUE;
        return FALSE;
    }
}

//-----------------------------------------------------------------------------
//
// fake implementations of Monitor APIs that work with the primary display
// no special parameter validation is made since these run in client code
//
//-----------------------------------------------------------------------------

int WINAPI
xGetSystemMetrics(int nIndex)
{
    if (InitMultipleMonitorStubs())
        return g_pfnGetSystemMetrics(nIndex);

    switch (nIndex)
    {
    case SM_CMONITORS:
    case SM_SAMEDISPLAYFORMAT:
        return 1;

    case SM_XVIRTUALSCREEN:
    case SM_YVIRTUALSCREEN:
        return 0;

    case SM_CXVIRTUALSCREEN:
        nIndex = SM_CXSCREEN;
        break;

    case SM_CYVIRTUALSCREEN:
        nIndex = SM_CYSCREEN;
        break;
    }

    return GetSystemMetrics(nIndex);
}

#define xPRIMARY_MONITOR ((HMONITOR)0x12340042)

HMONITOR WINAPI
xMonitorFromPoint(POINT ptScreenCoords, DWORD dwFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromPoint(ptScreenCoords, dwFlags);

    if ((dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((ptScreenCoords.x >= 0) &&
        (ptScreenCoords.x < GetSystemMetrics(SM_CXSCREEN)) &&
        (ptScreenCoords.y >= 0) &&
        (ptScreenCoords.y < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromRect(LPCRECT lprcScreenCoords, DWORD dwFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromRect(lprcScreenCoords, dwFlags);

    if ((dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((lprcScreenCoords->right > 0) &&
        (lprcScreenCoords->bottom > 0) &&
        (lprcScreenCoords->left < GetSystemMetrics(SM_CXSCREEN)) &&
        (lprcScreenCoords->top < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromWindow(HWND hWnd, DWORD dwFlags)
{
    WINDOWPLACEMENT wp;

    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromWindow(hWnd, dwFlags);

    if (dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST))
        return xPRIMARY_MONITOR;

    if (IsIconic(hWnd) ?
            GetWindowPlacement(hWnd, &wp) :
            GetWindowRect(hWnd, &wp.rcNormalPosition)) {

        return xMonitorFromRect(&wp.rcNormalPosition, dwFlags);
    }

    return NULL;
}

BOOL WINAPI
xGetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpMonitorInfo)
{
    RECT rcWork;

    if (InitMultipleMonitorStubs())
    {
        BOOL f = g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);
#ifdef UNICODE
        if (f && !g_fMultimonPlatformNT && (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX)))
        { 
            MultiByteToWideChar(CP_ACP, 0,
                (LPSTR)((MONITORINFOEX*)lpMonitorInfo)->szDevice, -1,
                ((MONITORINFOEX*)lpMonitorInfo)->szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)));
        }
#endif
        return f;
    }

    if ((hMonitor == xPRIMARY_MONITOR) &&
        lpMonitorInfo &&
        (lpMonitorInfo->cbSize >= sizeof(MONITORINFO)) &&
        SystemParametersInfoA(SPI_GETWORKAREA, 0, &rcWork, 0))
    {
        lpMonitorInfo->rcMonitor.left = 0;
        lpMonitorInfo->rcMonitor.top  = 0;
        lpMonitorInfo->rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN);
        lpMonitorInfo->rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN);
        lpMonitorInfo->rcWork = rcWork;
        lpMonitorInfo->dwFlags = MONITORINFOF_PRIMARY;

        if (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX))
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, ((MONITORINFOEX*)lpMonitorInfo)->szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)));
#else // UNICODE
            lstrcpy(((MONITORINFOEX*)lpMonitorInfo)->szDevice, TEXT("DISPLAY"));
#endif // UNICODE
        }

        return TRUE;
    }

    return FALSE;
}

BOOL WINAPI
xEnumDisplayMonitors(
        HDC             hdcOptionalForPainting,
        LPCRECT         lprcEnumMonitorsThatIntersect,
        MONITORENUMPROC lpfnEnumProc,
        LPARAM          dwData)
{
    RECT rcLimit;

    if (InitMultipleMonitorStubs()) {
        return g_pfnEnumDisplayMonitors(
                hdcOptionalForPainting,
                lprcEnumMonitorsThatIntersect,
                lpfnEnumProc,
                dwData);
    }

    if (!lpfnEnumProc)
        return FALSE;

    rcLimit.left   = 0;
    rcLimit.top    = 0;
    rcLimit.right  = GetSystemMetrics(SM_CXSCREEN);
    rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN);

    if (hdcOptionalForPainting)
    {
        RECT    rcClip;
        POINT   ptOrg;

        switch (GetClipBox(hdcOptionalForPainting, &rcClip))
        {
        default:
            if (!GetDCOrgEx(hdcOptionalForPainting, &ptOrg))
                return FALSE;

            OffsetRect(&rcLimit, -ptOrg.x, -ptOrg.y);
            if (IntersectRect(&rcLimit, &rcLimit, &rcClip) &&
                (!lprcEnumMonitorsThatIntersect ||
                     IntersectRect(&rcLimit, &rcLimit, lprcEnumMonitorsThatIntersect))) {

                break;
            }
            //fall thru
        case NULLREGION:
             return TRUE;
        case ERROR:
             return FALSE;
        }
    } else {
        if (    lprcEnumMonitorsThatIntersect &&
                !IntersectRect(&rcLimit, &rcLimit, lprcEnumMonitorsThatIntersect)) {

            return TRUE;
        }
    }

    return lpfnEnumProc(
            xPRIMARY_MONITOR,
            hdcOptionalForPainting,
            &rcLimit,
            dwData);
}

BOOL WINAPI
xEnumDisplayDevices(
    PVOID Unused,
    DWORD iDevNum,
    PDISPLAY_DEVICE lpDisplayDevice,
    DWORD dwFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnEnumDisplayDevices(Unused, iDevNum, lpDisplayDevice, dwFlags);

    if (Unused != NULL)
        return FALSE;

    if (iDevNum != 0)
        return FALSE;

    if (lpDisplayDevice == NULL || lpDisplayDevice->cb < sizeof(DISPLAY_DEVICE))
        return FALSE;

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice->DeviceName, (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)));
    MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice->DeviceString, (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)));
#else // UNICODE
    lstrcpy((LPTSTR)lpDisplayDevice->DeviceName,   TEXT("DISPLAY"));
    lstrcpy((LPTSTR)lpDisplayDevice->DeviceString, TEXT("DISPLAY"));
#endif // UNICODE

    lpDisplayDevice->StateFlags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP | DISPLAY_DEVICE_PRIMARY_DEVICE;

    return TRUE;
}

#undef xPRIMARY_MONITOR
#undef COMPILE_MULTIMON_STUBS

#else   // COMPILE_MULTIMON_STUBS

extern int  WINAPI xGetSystemMetrics(int);
extern HMONITOR WINAPI xMonitorFromWindow(HWND, DWORD);
extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, DWORD);
extern HMONITOR WINAPI xMonitorFromPoint(POINT, DWORD);
extern BOOL WINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO);
extern BOOL WINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM);
extern BOOL WINAPI xEnumDisplayDevices(PVOID, DWORD, PDISPLAY_DEVICE, DWORD);

#endif  // COMPILE_MULTIMON_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define GetSystemMetrics    xGetSystemMetrics
#define MonitorFromWindow   xMonitorFromWindow
#define MonitorFromRect     xMonitorFromRect
#define MonitorFromPoint    xMonitorFromPoint
#define GetMonitorInfo      xGetMonitorInfo
#define EnumDisplayMonitors xEnumDisplayMonitors
#define EnumDisplayDevices  xEnumDisplayDevices

#ifdef __cplusplus
}
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtxspm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sat Nov 08 05:10:46 1997
 */
/* Compiler settings for mtxspm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxspm_h__
#define __mtxspm_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISharedProperty_FWD_DEFINED__
#define __ISharedProperty_FWD_DEFINED__
typedef interface ISharedProperty ISharedProperty;
#endif 	/* __ISharedProperty_FWD_DEFINED__ */


#ifndef __ISharedPropertyGroup_FWD_DEFINED__
#define __ISharedPropertyGroup_FWD_DEFINED__
typedef interface ISharedPropertyGroup ISharedPropertyGroup;
#endif 	/* __ISharedPropertyGroup_FWD_DEFINED__ */


#ifndef __ISharedPropertyGroupManager_FWD_DEFINED__
#define __ISharedPropertyGroupManager_FWD_DEFINED__
typedef interface ISharedPropertyGroupManager ISharedPropertyGroupManager;
#endif 	/* __ISharedPropertyGroupManager_FWD_DEFINED__ */


#ifndef __SharedProperty_FWD_DEFINED__
#define __SharedProperty_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharedProperty SharedProperty;
#else
typedef struct SharedProperty SharedProperty;
#endif /* __cplusplus */

#endif 	/* __SharedProperty_FWD_DEFINED__ */


#ifndef __SharedPropertyGroup_FWD_DEFINED__
#define __SharedPropertyGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharedPropertyGroup SharedPropertyGroup;
#else
typedef struct SharedPropertyGroup SharedPropertyGroup;
#endif /* __cplusplus */

#endif 	/* __SharedPropertyGroup_FWD_DEFINED__ */


#ifndef __SharedPropertyGroupManager_FWD_DEFINED__
#define __SharedPropertyGroupManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharedPropertyGroupManager SharedPropertyGroupManager;
#else
typedef struct SharedPropertyGroupManager SharedPropertyGroupManager;
#endif /* __cplusplus */

#endif 	/* __SharedPropertyGroupManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxspm_0000
 * at Sat Nov 08 05:10:46 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtxspm.h  -- Microsoft Transaction Server SPM Interfaces					
//																			
// This file provides the COM interfaces for the Microsoft Transaction		
// Server Shared Property Manager.											
//																			
// Microsoft Transaction Server 2.0											
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	


extern RPC_IF_HANDLE __MIDL_itf_mtxspm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxspm_0000_v0_0_s_ifspec;

#ifndef __ISharedProperty_INTERFACE_DEFINED__
#define __ISharedProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISharedProperty
 * at Sat Nov 08 05:10:46 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpcontext][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_ISharedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2A005C01-A5DE-11CF-9E66-00AA00A3F464")
    ISharedProperty : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISharedProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISharedProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISharedProperty __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISharedProperty __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][helpcontext][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ VARIANT val);
        
        END_INTERFACE
    } ISharedPropertyVtbl;

    interface ISharedProperty
    {
        CONST_VTBL struct ISharedPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedProperty_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISharedProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISharedProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISharedProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISharedProperty_get_Value(This,pVal)	\
    (This)->lpVtbl -> get_Value(This,pVal)

#define ISharedProperty_put_Value(This,val)	\
    (This)->lpVtbl -> put_Value(This,val)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE ISharedProperty_get_Value_Proxy( 
    ISharedProperty __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB ISharedProperty_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE ISharedProperty_put_Value_Proxy( 
    ISharedProperty __RPC_FAR * This,
    /* [in] */ VARIANT val);


void __RPC_STUB ISharedProperty_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedProperty_INTERFACE_DEFINED__ */


#ifndef __ISharedPropertyGroup_INTERFACE_DEFINED__
#define __ISharedPropertyGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISharedPropertyGroup
 * at Sat Nov 08 05:10:46 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpcontext][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_ISharedPropertyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2A005C07-A5DE-11CF-9E66-00AA00A3F464")
    ISharedPropertyGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreatePropertyByPosition( 
            /* [in] */ int Index,
            /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_PropertyByPosition( 
            /* [in] */ int Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreateProperty( 
            /* [in] */ BSTR Name,
            /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Property( 
            /* [in] */ BSTR Name,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISharedPropertyGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISharedPropertyGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyByPosition )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ int Index,
            /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropertyByPosition )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ int Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProperty )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Property )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);
        
        END_INTERFACE
    } ISharedPropertyGroupVtbl;

    interface ISharedPropertyGroup
    {
        CONST_VTBL struct ISharedPropertyGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedPropertyGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedPropertyGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedPropertyGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedPropertyGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISharedPropertyGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISharedPropertyGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISharedPropertyGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISharedPropertyGroup_CreatePropertyByPosition(This,Index,fExists,ppProp)	\
    (This)->lpVtbl -> CreatePropertyByPosition(This,Index,fExists,ppProp)

#define ISharedPropertyGroup_get_PropertyByPosition(This,Index,ppProperty)	\
    (This)->lpVtbl -> get_PropertyByPosition(This,Index,ppProperty)

#define ISharedPropertyGroup_CreateProperty(This,Name,fExists,ppProp)	\
    (This)->lpVtbl -> CreateProperty(This,Name,fExists,ppProp)

#define ISharedPropertyGroup_get_Property(This,Name,ppProperty)	\
    (This)->lpVtbl -> get_Property(This,Name,ppProperty)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_CreatePropertyByPosition_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ int Index,
    /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);


void __RPC_STUB ISharedPropertyGroup_CreatePropertyByPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_get_PropertyByPosition_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ int Index,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);


void __RPC_STUB ISharedPropertyGroup_get_PropertyByPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_CreateProperty_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);


void __RPC_STUB ISharedPropertyGroup_CreateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_get_Property_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);


void __RPC_STUB ISharedPropertyGroup_get_Property_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedPropertyGroup_INTERFACE_DEFINED__ */


#ifndef __ISharedPropertyGroupManager_INTERFACE_DEFINED__
#define __ISharedPropertyGroupManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISharedPropertyGroupManager
 * at Sat Nov 08 05:10:46 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpcontext][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_ISharedPropertyGroupManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2A005C0D-A5DE-11CF-9E66-00AA00A3F464")
    ISharedPropertyGroupManager : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreatePropertyGroup( 
            /* [in] */ BSTR Name,
            /* [out][in] */ LONG __RPC_FAR *dwIsoMode,
            /* [out][in] */ LONG __RPC_FAR *dwRelMode,
            /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [in] */ BSTR Name,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup) = 0;
        
        virtual /* [helpstring][helpcontext][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyGroupManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISharedPropertyGroupManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISharedPropertyGroupManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyGroup )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [out][in] */ LONG __RPC_FAR *dwIsoMode,
            /* [out][in] */ LONG __RPC_FAR *dwRelMode,
            /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Group )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);
        
        /* [helpstring][helpcontext][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        END_INTERFACE
    } ISharedPropertyGroupManagerVtbl;

    interface ISharedPropertyGroupManager
    {
        CONST_VTBL struct ISharedPropertyGroupManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedPropertyGroupManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedPropertyGroupManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedPropertyGroupManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedPropertyGroupManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISharedPropertyGroupManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISharedPropertyGroupManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISharedPropertyGroupManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISharedPropertyGroupManager_CreatePropertyGroup(This,Name,dwIsoMode,dwRelMode,fExists,ppGroup)	\
    (This)->lpVtbl -> CreatePropertyGroup(This,Name,dwIsoMode,dwRelMode,fExists,ppGroup)

#define ISharedPropertyGroupManager_get_Group(This,Name,ppGroup)	\
    (This)->lpVtbl -> get_Group(This,Name,ppGroup)

#define ISharedPropertyGroupManager_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroupManager_CreatePropertyGroup_Proxy( 
    ISharedPropertyGroupManager __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [out][in] */ LONG __RPC_FAR *dwIsoMode,
    /* [out][in] */ LONG __RPC_FAR *dwRelMode,
    /* [out] */ VARIANT_BOOL __RPC_FAR *fExists,
    /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);


void __RPC_STUB ISharedPropertyGroupManager_CreatePropertyGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroupManager_get_Group_Proxy( 
    ISharedPropertyGroupManager __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);


void __RPC_STUB ISharedPropertyGroupManager_get_Group_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][helpcontext][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroupManager_get__NewEnum_Proxy( 
    ISharedPropertyGroupManager __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB ISharedPropertyGroupManager_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedPropertyGroupManager_INTERFACE_DEFINED__ */



#ifndef __MTxSpm_LIBRARY_DEFINED__
#define __MTxSpm_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTxSpm
 * at Sat Nov 08 05:10:46 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][helpfile][version][uuid] */ 


typedef /* [public] */ 
enum __MIDL___MIDL_itf_mtxspm_0098_0001
    {	LockSetGet	= 0,
	LockMethod	= LockSetGet + 1
    }	LockModes;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mtxspm_0098_0002
    {	Standard	= 0,
	Process	= Standard + 1
    }	ReleaseModes;


EXTERN_C const IID LIBID_MTxSpm;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SharedProperty;

class DECLSPEC_UUID("2A005C05-A5DE-11CF-9E66-00AA00A3F464")
SharedProperty;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SharedPropertyGroup;

class DECLSPEC_UUID("2A005C0B-A5DE-11CF-9E66-00AA00A3F464")
SharedPropertyGroup;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SharedPropertyGroupManager;

class DECLSPEC_UUID("2A005C11-A5DE-11CF-9E66-00AA00A3F464")
SharedPropertyGroupManager;
#endif
#endif /* __MTxSpm_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtxattr.h ===
#ifndef _MTXATTR_H_
#define _MTXATTR_H_

// -----------------------------------------------------------------------
// mtxattr.h  -- Microsoft Transaction Server Custom Properties			
//																		
// This file is the IDL include for Microsoft Transaction Server		
// custom typelib properties.											
//																		
// Microsoft Transaction Server 2.0										
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.	
// -----------------------------------------------------------------------  

//======================================================================================
// Component attributes
//======================================================================================
#define		TLBATTR_TRANS_REQUIRED	17093CC5-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_TRANS_NOTSUPP	17093CC6-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_TRANS_REQNEW	17093CC7-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_TRANS_SUPPORTED	17093CC8-9BD2-11cf-AA4F-304BF89C0001

//======================================================================================
// Component attribute MACROS
//======================================================================================

#define TRANSACTION_REQUIRED		custom(TLBATTR_TRANS_REQUIRED,0)
#define TRANSACTION_SUPPORTED		custom(TLBATTR_TRANS_SUPPORTED,0)
#define TRANSACTION_NOT_SUPPORTED	custom(TLBATTR_TRANS_NOTSUPP,0)
#define TRANSACTION_REQUIRES_NEW	custom(TLBATTR_TRANS_REQNEW,0)


#endif _MTXATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtxdm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:06 1997
 */
/* Compiler settings for mtxdm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxdm_h__
#define __mtxdm_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDispenserManager_FWD_DEFINED__
#define __IDispenserManager_FWD_DEFINED__
typedef interface IDispenserManager IDispenserManager;
#endif 	/* __IDispenserManager_FWD_DEFINED__ */


#ifndef __IHolder_FWD_DEFINED__
#define __IHolder_FWD_DEFINED__
typedef interface IHolder IHolder;
#endif 	/* __IHolder_FWD_DEFINED__ */


#ifndef __IDispenserDriver_FWD_DEFINED__
#define __IDispenserDriver_FWD_DEFINED__
typedef interface IDispenserDriver IDispenserDriver;
#endif 	/* __IDispenserDriver_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxdm_0000
 * at Thu Sep 11 16:03:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtxdm.h  -- Microsoft Transaction Server Resource Dispenser Interfaces				
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server Resource Dispensers.													
//																			
// Microsoft Transaction Server 2.0												
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	
 
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
typedef DWORD RESTYPID;

typedef DWORD RESID;

typedef LPOLESTR SRESID;

typedef LPCOLESTR constSRESID;

typedef DWORD RESOURCERATING;

typedef long TIMEINSECS;

typedef DWORD INSTID;

typedef DWORD TRANSID;



//
// Error Codes
//
#define MTXDM_E_ENLISTRESOURCEFAILED 0x8004E100 // return from EnlistResource, is then returned by AllocResource
 
//
// GetDispenserManager
// A Dispenser calls this API to get a reference to DispenserManager.
//
__declspec(dllimport) HRESULT __cdecl GetDispenserManager(IDispenserManager**);
 
//
// IDispenserManager
// Implemented by Dispenser Manager, called by all Dispensers.
//


extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0000_v0_0_s_ifspec;

#ifndef __IDispenserManager_INTERFACE_DEFINED__
#define __IDispenserManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDispenserManager
 * at Thu Sep 11 16:03:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IDispenserManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("5cb31e10-2b5f-11cf-be10-00aa00a2fa25")
    IDispenserManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterDispenser( 
            /* [in] */ IDispenserDriver __RPC_FAR *__MIDL_0015,
            /* [in] */ LPCOLESTR szDispenserName,
            /* [out] */ IHolder __RPC_FAR *__RPC_FAR *__MIDL_0016) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ INSTID __RPC_FAR *__MIDL_0017,
            /* [out] */ TRANSID __RPC_FAR *__MIDL_0018) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispenserManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispenserManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispenserManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispenserManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterDispenser )( 
            IDispenserManager __RPC_FAR * This,
            /* [in] */ IDispenserDriver __RPC_FAR *__MIDL_0015,
            /* [in] */ LPCOLESTR szDispenserName,
            /* [out] */ IHolder __RPC_FAR *__RPC_FAR *__MIDL_0016);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IDispenserManager __RPC_FAR * This,
            /* [out] */ INSTID __RPC_FAR *__MIDL_0017,
            /* [out] */ TRANSID __RPC_FAR *__MIDL_0018);
        
        END_INTERFACE
    } IDispenserManagerVtbl;

    interface IDispenserManager
    {
        CONST_VTBL struct IDispenserManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispenserManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispenserManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispenserManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispenserManager_RegisterDispenser(This,__MIDL_0015,szDispenserName,__MIDL_0016)	\
    (This)->lpVtbl -> RegisterDispenser(This,__MIDL_0015,szDispenserName,__MIDL_0016)

#define IDispenserManager_GetContext(This,__MIDL_0017,__MIDL_0018)	\
    (This)->lpVtbl -> GetContext(This,__MIDL_0017,__MIDL_0018)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDispenserManager_RegisterDispenser_Proxy( 
    IDispenserManager __RPC_FAR * This,
    /* [in] */ IDispenserDriver __RPC_FAR *__MIDL_0015,
    /* [in] */ LPCOLESTR szDispenserName,
    /* [out] */ IHolder __RPC_FAR *__RPC_FAR *__MIDL_0016);


void __RPC_STUB IDispenserManager_RegisterDispenser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispenserManager_GetContext_Proxy( 
    IDispenserManager __RPC_FAR * This,
    /* [out] */ INSTID __RPC_FAR *__MIDL_0017,
    /* [out] */ TRANSID __RPC_FAR *__MIDL_0018);


void __RPC_STUB IDispenserManager_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispenserManager_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtxdm_0094
 * at Thu Sep 11 16:03:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//
// IHolder
// Implemented by Dispenser Manager, called by one Dispenser.
//


extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0094_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0094_v0_0_s_ifspec;

#ifndef __IHolder_INTERFACE_DEFINED__
#define __IHolder_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHolder
 * at Thu Sep 11 16:03:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("bf6a1850-2b45-11cf-be10-00aa00a2fa25")
    IHolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocResource( 
            /* [in] */ const RESTYPID __MIDL_0019,
            /* [out] */ RESID __RPC_FAR *__MIDL_0020) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeResource( 
            /* [in] */ const RESID __MIDL_0021) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackResource( 
            /* [in] */ const RESID __MIDL_0022) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackResourceS( 
            /* [in] */ constSRESID __MIDL_0023) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UntrackResource( 
            /* [in] */ const RESID __MIDL_0024,
            /* [in] */ const BOOL __MIDL_0025) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UntrackResourceS( 
            /* [in] */ constSRESID __MIDL_0026,
            /* [in] */ const BOOL __MIDL_0027) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestDestroyResource( 
            /* [in] */ const RESID __MIDL_0028) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHolder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHolder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocResource )( 
            IHolder __RPC_FAR * This,
            /* [in] */ const RESTYPID __MIDL_0019,
            /* [out] */ RESID __RPC_FAR *__MIDL_0020);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeResource )( 
            IHolder __RPC_FAR * This,
            /* [in] */ const RESID __MIDL_0021);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TrackResource )( 
            IHolder __RPC_FAR * This,
            /* [in] */ const RESID __MIDL_0022);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TrackResourceS )( 
            IHolder __RPC_FAR * This,
            /* [in] */ constSRESID __MIDL_0023);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UntrackResource )( 
            IHolder __RPC_FAR * This,
            /* [in] */ const RESID __MIDL_0024,
            /* [in] */ const BOOL __MIDL_0025);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UntrackResourceS )( 
            IHolder __RPC_FAR * This,
            /* [in] */ constSRESID __MIDL_0026,
            /* [in] */ const BOOL __MIDL_0027);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IHolder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestDestroyResource )( 
            IHolder __RPC_FAR * This,
            /* [in] */ const RESID __MIDL_0028);
        
        END_INTERFACE
    } IHolderVtbl;

    interface IHolder
    {
        CONST_VTBL struct IHolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHolder_AllocResource(This,__MIDL_0019,__MIDL_0020)	\
    (This)->lpVtbl -> AllocResource(This,__MIDL_0019,__MIDL_0020)

#define IHolder_FreeResource(This,__MIDL_0021)	\
    (This)->lpVtbl -> FreeResource(This,__MIDL_0021)

#define IHolder_TrackResource(This,__MIDL_0022)	\
    (This)->lpVtbl -> TrackResource(This,__MIDL_0022)

#define IHolder_TrackResourceS(This,__MIDL_0023)	\
    (This)->lpVtbl -> TrackResourceS(This,__MIDL_0023)

#define IHolder_UntrackResource(This,__MIDL_0024,__MIDL_0025)	\
    (This)->lpVtbl -> UntrackResource(This,__MIDL_0024,__MIDL_0025)

#define IHolder_UntrackResourceS(This,__MIDL_0026,__MIDL_0027)	\
    (This)->lpVtbl -> UntrackResourceS(This,__MIDL_0026,__MIDL_0027)

#define IHolder_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IHolder_RequestDestroyResource(This,__MIDL_0028)	\
    (This)->lpVtbl -> RequestDestroyResource(This,__MIDL_0028)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHolder_AllocResource_Proxy( 
    IHolder __RPC_FAR * This,
    /* [in] */ const RESTYPID __MIDL_0019,
    /* [out] */ RESID __RPC_FAR *__MIDL_0020);


void __RPC_STUB IHolder_AllocResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHolder_FreeResource_Proxy( 
    IHolder __RPC_FAR * This,
    /* [in] */ const RESID __MIDL_0021);


void __RPC_STUB IHolder_FreeResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHolder_TrackResource_Proxy( 
    IHolder __RPC_FAR * This,
    /* [in] */ const RESID __MIDL_0022);


void __RPC_STUB IHolder_TrackResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHolder_TrackResourceS_Proxy( 
    IHolder __RPC_FAR * This,
    /* [in] */ constSRESID __MIDL_0023);


void __RPC_STUB IHolder_TrackResourceS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHolder_UntrackResource_Proxy( 
    IHolder __RPC_FAR * This,
    /* [in] */ const RESID __MIDL_0024,
    /* [in] */ const BOOL __MIDL_0025);


void __RPC_STUB IHolder_UntrackResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHolder_UntrackResourceS_Proxy( 
    IHolder __RPC_FAR * This,
    /* [in] */ constSRESID __MIDL_0026,
    /* [in] */ const BOOL __MIDL_0027);


void __RPC_STUB IHolder_UntrackResourceS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHolder_Close_Proxy( 
    IHolder __RPC_FAR * This);


void __RPC_STUB IHolder_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHolder_RequestDestroyResource_Proxy( 
    IHolder __RPC_FAR * This,
    /* [in] */ const RESID __MIDL_0028);


void __RPC_STUB IHolder_RequestDestroyResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHolder_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtxdm_0095
 * at Thu Sep 11 16:03:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//
// IDispenserDriver
// Implemented by a Dispenser, called by Dispenser Manager.
//


extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0095_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0095_v0_0_s_ifspec;

#ifndef __IDispenserDriver_INTERFACE_DEFINED__
#define __IDispenserDriver_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDispenserDriver
 * at Thu Sep 11 16:03:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IDispenserDriver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("208b3651-2b48-11cf-be10-00aa00a2fa25")
    IDispenserDriver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateResource( 
            /* [in] */ const RESTYPID ResTypId,
            /* [out] */ RESID __RPC_FAR *pResId,
            /* [out] */ TIMEINSECS __RPC_FAR *pSecsFreeBeforeDestroy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RateResource( 
            /* [in] */ const RESTYPID ResTypId,
            /* [in] */ const RESID ResId,
            /* [in] */ const BOOL fRequiresTransactionEnlistment,
            /* [out] */ RESOURCERATING __RPC_FAR *pRating) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnlistResource( 
            /* [in] */ const RESID ResId,
            /* [in] */ const TRANSID TransId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetResource( 
            /* [in] */ const RESID ResId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyResource( 
            /* [in] */ const RESID ResId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyResourceS( 
            /* [in] */ constSRESID ResId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispenserDriverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispenserDriver __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispenserDriver __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispenserDriver __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateResource )( 
            IDispenserDriver __RPC_FAR * This,
            /* [in] */ const RESTYPID ResTypId,
            /* [out] */ RESID __RPC_FAR *pResId,
            /* [out] */ TIMEINSECS __RPC_FAR *pSecsFreeBeforeDestroy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RateResource )( 
            IDispenserDriver __RPC_FAR * This,
            /* [in] */ const RESTYPID ResTypId,
            /* [in] */ const RESID ResId,
            /* [in] */ const BOOL fRequiresTransactionEnlistment,
            /* [out] */ RESOURCERATING __RPC_FAR *pRating);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnlistResource )( 
            IDispenserDriver __RPC_FAR * This,
            /* [in] */ const RESID ResId,
            /* [in] */ const TRANSID TransId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetResource )( 
            IDispenserDriver __RPC_FAR * This,
            /* [in] */ const RESID ResId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyResource )( 
            IDispenserDriver __RPC_FAR * This,
            /* [in] */ const RESID ResId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyResourceS )( 
            IDispenserDriver __RPC_FAR * This,
            /* [in] */ constSRESID ResId);
        
        END_INTERFACE
    } IDispenserDriverVtbl;

    interface IDispenserDriver
    {
        CONST_VTBL struct IDispenserDriverVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispenserDriver_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispenserDriver_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispenserDriver_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispenserDriver_CreateResource(This,ResTypId,pResId,pSecsFreeBeforeDestroy)	\
    (This)->lpVtbl -> CreateResource(This,ResTypId,pResId,pSecsFreeBeforeDestroy)

#define IDispenserDriver_RateResource(This,ResTypId,ResId,fRequiresTransactionEnlistment,pRating)	\
    (This)->lpVtbl -> RateResource(This,ResTypId,ResId,fRequiresTransactionEnlistment,pRating)

#define IDispenserDriver_EnlistResource(This,ResId,TransId)	\
    (This)->lpVtbl -> EnlistResource(This,ResId,TransId)

#define IDispenserDriver_ResetResource(This,ResId)	\
    (This)->lpVtbl -> ResetResource(This,ResId)

#define IDispenserDriver_DestroyResource(This,ResId)	\
    (This)->lpVtbl -> DestroyResource(This,ResId)

#define IDispenserDriver_DestroyResourceS(This,ResId)	\
    (This)->lpVtbl -> DestroyResourceS(This,ResId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDispenserDriver_CreateResource_Proxy( 
    IDispenserDriver __RPC_FAR * This,
    /* [in] */ const RESTYPID ResTypId,
    /* [out] */ RESID __RPC_FAR *pResId,
    /* [out] */ TIMEINSECS __RPC_FAR *pSecsFreeBeforeDestroy);


void __RPC_STUB IDispenserDriver_CreateResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispenserDriver_RateResource_Proxy( 
    IDispenserDriver __RPC_FAR * This,
    /* [in] */ const RESTYPID ResTypId,
    /* [in] */ const RESID ResId,
    /* [in] */ const BOOL fRequiresTransactionEnlistment,
    /* [out] */ RESOURCERATING __RPC_FAR *pRating);


void __RPC_STUB IDispenserDriver_RateResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispenserDriver_EnlistResource_Proxy( 
    IDispenserDriver __RPC_FAR * This,
    /* [in] */ const RESID ResId,
    /* [in] */ const TRANSID TransId);


void __RPC_STUB IDispenserDriver_EnlistResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispenserDriver_ResetResource_Proxy( 
    IDispenserDriver __RPC_FAR * This,
    /* [in] */ const RESID ResId);


void __RPC_STUB IDispenserDriver_ResetResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispenserDriver_DestroyResource_Proxy( 
    IDispenserDriver __RPC_FAR * This,
    /* [in] */ const RESID ResId);


void __RPC_STUB IDispenserDriver_DestroyResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispenserDriver_DestroyResourceS_Proxy( 
    IDispenserDriver __RPC_FAR * This,
    /* [in] */ constSRESID ResId);


void __RPC_STUB IDispenserDriver_DestroyResourceS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispenserDriver_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtxdm_0096
 * at Thu Sep 11 16:03:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#ifdef USE_UUIDOF_FOR_IID_
#define  IID_IHolder             __uuidof(IIHolder)
#define  IID_IDispenserManager   __uuidof(IDispenserManager)
#define  IID_IDispenserDriver    __uuidof(IDispenserDriver)
#endif


extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0096_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxdm_0096_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\mtxadmin_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:04 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICatalog = {0x6eb22870,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_ICatalogObject = {0x6eb22871,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_ICatalogCollection = {0x6eb22872,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IComponentUtil = {0x6eb22873,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IPackageUtil = {0x6eb22874,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRemoteComponentUtil = {0x6eb22875,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRoleAssociationUtil = {0x6eb22876,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_MTSAdmin = {0x6eb22880,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_Catalog = {0x6eb22881,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogObject = {0x6eb22882,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogCollection = {0x6eb22883,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_ComponentUtil = {0x6eb22884,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_PackageUtil = {0x6eb22885,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RemoteComponentUtil = {0x6eb22886,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RoleAssociationUtil = {0x6eb22887,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\multinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 29 16:59:57 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __multinfo_h__
#define __multinfo_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideClassInfo_FWD_DEFINED__
#define __IProvideClassInfo_FWD_DEFINED__
typedef interface IProvideClassInfo IProvideClassInfo;
#endif 	/* __IProvideClassInfo_FWD_DEFINED__ */


#ifndef __IProvideClassInfo2_FWD_DEFINED__
#define __IProvideClassInfo2_FWD_DEFINED__
typedef interface IProvideClassInfo2 IProvideClassInfo2;
#endif 	/* __IProvideClassInfo2_FWD_DEFINED__ */


#ifndef __IProvideMultipleClassInfo_FWD_DEFINED__
#define __IProvideMultipleClassInfo_FWD_DEFINED__
typedef interface IProvideMultipleClassInfo IProvideMultipleClassInfo;
#endif 	/* __IProvideMultipleClassInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif

// {A7ABA9C1-8983-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IProvideMultipleClassInfo,
0xa7aba9c1, 0x8983, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);


extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_s_ifspec;

#ifndef __IProvideMultipleClassInfo_INTERFACE_DEFINED__
#define __IProvideMultipleClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideMultipleClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


#define MULTICLASSINFO_GETTYPEINFO           0x00000001
#define MULTICLASSINFO_GETNUMRESERVEDDISPIDS 0x00000002
#define MULTICLASSINFO_GETIIDPRIMARY         0x00000004
#define MULTICLASSINFO_GETIIDSOURCE          0x00000008
#define TIFLAGS_EXTENDDISPATCHONLY           0x00000001

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideMultipleClassInfo : public IProvideClassInfo2
    {
    public:
        virtual HRESULT __stdcall GetMultiTypeInfoCount( 
            /* [out] */ ULONG __RPC_FAR *pcti) = 0;
        
        virtual HRESULT __stdcall GetInfoOfIndex( 
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideMultipleClassInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( __stdcall __RPC_FAR *GetMultiTypeInfoCount )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcti);
        
        HRESULT ( __stdcall __RPC_FAR *GetInfoOfIndex )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource);
        
    } IProvideMultipleClassInfoVtbl;

    interface IProvideMultipleClassInfo
    {
        CONST_VTBL struct IProvideMultipleClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideMultipleClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideMultipleClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideMultipleClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideMultipleClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideMultipleClassInfo_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideMultipleClassInfo_GetMultiTypeInfoCount(This,pcti)	\
    (This)->lpVtbl -> GetMultiTypeInfoCount(This,pcti)

#define IProvideMultipleClassInfo_GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)	\
    (This)->lpVtbl -> GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideMultipleClassInfo_GetMultiTypeInfoCount_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcti);


void __RPC_STUB IProvideMultipleClassInfo_GetMultiTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideMultipleClassInfo_GetInfoOfIndex_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [in] */ ULONG iti,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
    /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
    /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
    /* [out] */ IID __RPC_FAR *piidPrimary,
    /* [out] */ IID __RPC_FAR *piidSource);


void __RPC_STUB IProvideMultipleClassInfo_GetInfoOfIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideMultipleClassInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nddesec.h ===
//
//  NDDESEC.H
//  Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
//

#ifndef          _INC_NDDESEC
#define          _INC_NDDESEC

#if _MSC_VER > 1000
#pragma once
#endif

#define NDDE_SHAREDB_ADD	   (0x00000001)
#define NDDE_SHAREDB_DELETE	   (0x00000002)
#define NDDE_SHAREDB_LIST	   (0x00000004)

#define NDDE_SHAREDB_ADMIN	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST |			\
				 READ_CONTROL |				\
				 WRITE_DAC |				\
				 WRITE_OWNER)

#define NDDE_SHAREDB_OPER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_POWER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_USER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_EVERYONE	(NDDE_SHAREDB_LIST)

#define NDDE_SHARE_READ		   (0x00000001)
#define NDDE_SHARE_WRITE	   (0x00000002)
#define NDDE_SHARE_INITIATE_STATIC (0x00000004)
#define NDDE_SHARE_INITIATE_LINK   (0x00000008)
#define NDDE_SHARE_REQUEST	   (0x00000010)
#define NDDE_SHARE_ADVISE	   (0x00000020)
#define NDDE_SHARE_POKE		   (0x00000040)
#define NDDE_SHARE_EXECUTE	   (0x00000080)
#define NDDE_SHARE_ADD_ITEMS	   (0x00000100)
#define NDDE_SHARE_LIST_ITEMS	   (0x00000200)

#define NDDE_SHARE_GENERIC_READ	(NDDE_SHARE_READ |			\
			         NDDE_SHARE_INITIATE_STATIC |		\
				 NDDE_SHARE_REQUEST |			\
				 NDDE_SHARE_ADVISE |			\
				 NDDE_SHARE_LIST_ITEMS)

#define NDDE_SHARE_GENERIC_WRITE (NDDE_SHARE_INITIATE_STATIC |		\
			          NDDE_SHARE_INITIATE_LINK |		\
				  NDDE_SHARE_POKE |			\
				  DELETE)

#define NDDE_SHARE_GENERIC_EXECUTE (NDDE_SHARE_INITIATE_STATIC |	\
			            NDDE_SHARE_INITIATE_LINK |		\
				    NDDE_SHARE_EXECUTE)

#define NDDE_SHARE_GENERIC_ALL (NDDE_SHARE_READ |			\
				NDDE_SHARE_WRITE |			\
			        NDDE_SHARE_INITIATE_STATIC |		\
			        NDDE_SHARE_INITIATE_LINK |		\
				NDDE_SHARE_REQUEST |			\
				NDDE_SHARE_ADVISE |			\
				NDDE_SHARE_POKE |			\
				NDDE_SHARE_EXECUTE |			\
				NDDE_SHARE_ADD_ITEMS |			\
				NDDE_SHARE_LIST_ITEMS |			\
				DELETE |				\
				READ_CONTROL |				\
				WRITE_DAC |				\
				WRITE_OWNER)


#define NDDE_ITEM_REQUEST	   (0x00000001)
#define NDDE_ITEM_ADVISE	   (0x00000002)
#define NDDE_ITEM_POKE		   (0x00000004)

#define NDDE_ITEM_GENERIC_READ	  (NDDE_ITEM_REQUEST | NDDE_ITEM_ADVISE)
#define NDDE_ITEM_GENERIC_WRITE   (NDDE_ITEM_POKE)
#define NDDE_ITEM_GENERIC_EXECUTE (0)
#define NDDE_ITEM_GENERIC_ALL     (NDDE_ITEM_REQUEST |			\
				   NDDE_ITEM_ADVISE |			\
				   NDDE_ITEM_POKE |			\
				   DELETE |				\
				   READ_CONTROL |			\
				   WRITE_DAC |				\
				   WRITE_OWNER)

#define NDDE_GUI_NONE	  	(0)

#define NDDE_GUI_READ		(NDDE_SHARE_GENERIC_READ)

#define NDDE_GUI_READ_LINK	(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_INITIATE_LINK)

#define NDDE_GUI_CHANGE		(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_GENERIC_WRITE |		\
				 NDDE_SHARE_GENERIC_EXECUTE)

#define NDDE_GUI_FULL_CONTROL	(NDDE_SHARE_GENERIC_ALL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nal.h ===
//=============================================================================
//  Microsoft (R) Bloodhound. Copyright (C) 1991-1994.
//
//  MODULE: nal.h
//
//  This source file contains defintions for the Network Abstraction Layer (NAL)
//=============================================================================

#if !defined(_NAL_)

#define _NAL_

#pragma pack(1)

//=============================================================================
//  NETWORK API's.
//=============================================================================

extern DWORD                WINAPI CancelTransmit(HNETWORK hNetwork, LPVOID TxCorrelator);

extern DWORD                WINAPI CloseNetwork(HNETWORK hNetwork, DWORD CloseFlags);

extern DWORD                WINAPI ContinueCapturing(HNETWORK hNetwork);

extern DWORD                WINAPI EnumNetworks(VOID);

extern HBUFFER              WINAPI GetNetworkBuffer(HNETWORK hNetwork);

extern NETWORKPROC          WINAPI GetNetworkCallback(HNETWORK hNetwork);

extern LPNETWORKINFO        WINAPI GetNetworkInfo(DWORD NetworkID);

extern DWORD                WINAPI GetNetworkID(HNETWORK hNetwork);

extern LPVOID               WINAPI GetNetworkInstanceData(HNETWORK hNetwork);

extern HNETWORK             WINAPI OpenNetwork(DWORD NetworkID,
                                               HPASSWORD hPassword,
                                               NETWORKPROC NetworkProc,
                                               LPVOID UserContext,
                                               LPSTATISTICSPARAM StatisticsParam);

extern DWORD                WINAPI PauseCapturing(HNETWORK hNetwork);

extern DWORD                WINAPI SetNetworkBuffer(HNETWORK hNetwork, HBUFFER hBuffer);

extern DWORD                WINAPI SetNetworkFilter(HNETWORK hNetwork, LPCAPTUREFILTER lpCaptureFilter, HBUFFER hBuffer);

extern LPVOID               WINAPI SetNetworkInstanceData(HNETWORK hNetwork, LPVOID InstanceData);

extern NETWORKPROC          WINAPI SetNetworkCallback(HNETWORK hNetwork, NETWORKPROC NetworkProc);

extern DWORD                WINAPI StartCapturing(HNETWORK hNetwork, HBUFFER hBuffer);

extern DWORD                WINAPI StopCapturing(HNETWORK hNetwork);

extern LPVOID               WINAPI TransmitQueue(HNETWORK hNetwork, LPPACKETQUEUE PacketQueue);

extern VOID                 WINAPI TransmitSpecialFrame( DWORD FrameType, DWORD Flags, LPBYTE pUserData, DWORD UserDataLength );

extern LPNETWORKSTATUS      WINAPI QueryNetworkStatus(HNETWORK hNetwork, LPNETWORKSTATUS NetworkStatus);

extern DWORD                WINAPI ClearStatistics(HNETWORK hNetwork);

extern DWORD                WINAPI GetReconnectInfo(HNETWORK        hNetwork,
                                                    LPRECONNECTINFO ReconnectInfoBuffer,
                                                    DWORD           ReconnectInfoBufferLength,
                                                    LPDWORD         nBytesAvail);


extern DWORD                WINAPI SetConnectInfo(HNETWORK        hNetwork,
                                                  LPRECONNECTINFO ReconnectInfoBuffer,
                                                  DWORD           ReconnectInfoBufferLength);

extern DWORD                WINAPI SetupNetwork(DWORD NetworkID, LPSETUPNETWORKPARMS lpSetupParms);
extern DWORD                WINAPI DestroyNetworkID(DWORD NetworkID );

//=============================================================================
//  BUFFER API's
//=============================================================================

extern HBUFFER              WINAPI AllocNetworkBuffer(DWORD NetworkID, DWORD BufferSize);

extern HBUFFER              WINAPI FreeNetworkBuffer(HBUFFER hBuffer);

extern VOID                 WINAPI CompactNetworkBuffer(HBUFFER hBuffer);

extern LPFRAME              WINAPI GetNetworkFrame(HBUFFER hBuffer, DWORD FrameNumber);

extern DWORD                WINAPI GetBufferSize(HBUFFER hBuffer);

extern DWORD                WINAPI GetBufferTotalFramesCaptured(HBUFFER hBuffer);

extern DWORD                WINAPI GetBufferTotalBytesCaptured(HBUFFER hBuffer);

extern LPSYSTEMTIME         WINAPI GetBufferTimeStamp(HBUFFER hBuffer, LPSYSTEMTIME SystemTime);

#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nativcom.h ===
// (C) Copyright 1996, Microsoft Corporation and it suppliers.

//----------------------------------------------------------------------------
// Public header for COM-marshaling facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef _NATIVCOM_
#define _NATIVCOM_


#include <windows.h>
#include <native.h>


#ifdef __cplusplus
extern "C" {
#endif


//----------------------------------------------------------------------------
// COM data wrapper helpers...
//----------------------------------------------------------------------------
void* __cdecl jcdwNewData(Hjava_lang_Object * phJCDW, unsigned int numBytes);
void* __cdecl jcdwGetData(Hjava_lang_Object * phJCDW);
unsigned int __cdecl jcdwSizeOf(Hjava_lang_Object * phJCDW);
unsigned int __cdecl jcdwClassSizeOf(Hjava_lang_Object * phJavaClass);
unsigned int __cdecl jcdwOffsetOf(Hjava_lang_Object * phJCDW, const char *pFieldName);
unsigned int __cdecl jcdwClassOffsetOf(Hjava_lang_Object * phJCDWClass, const char *pFieldName);
Hjava_lang_Object * __cdecl convert_IUnknown_to_Java_Object(IUnknown *punk,
                                                            Hjava_lang_Object *phJavaClass,
                                                            int       fAssumeThreadSafe);
Hjava_lang_Object * __cdecl convert_IUnknown_to_Java_Object2(IUnknown    *punk,
                                                             ClassClass  *pClassClass,
                                                             int         fFreeThreaded);

IUnknown * __cdecl convert_Java_Object_to_IUnknown(Hjava_lang_Object *phJavaObject, const IID *pIID);


Hjava_lang_Object * __cdecl convert_ptr_to_jcdw(void              *pExtData,
                                                Hjava_lang_Object *phJavaClass
                                                );

int __cdecl jcdw_memory_freed_on_gc(Hjava_lang_Object *phJCDW);


int   __cdecl jcdwSetData(Hjava_lang_Object * phJCDW, LPVOID pv);
int   __cdecl jcdw_java_owned(Hjava_lang_Object *phJCDW);




//----------------------------------------------------------------------------
// Map HRESULT to ComException.
//----------------------------------------------------------------------------
void    __cdecl SignalErrorHResult(HRESULT theHRESULT);

//----------------------------------------------------------------------------
// Map Java exception to HRESULT.
//----------------------------------------------------------------------------
HRESULT __cdecl HResultFromException(OBJECT* exception_object);



typedef Hjava_lang_Object *JAVAARG;

//----------------------------------------------------------------------------
// Information structure for Java->COM Custom Method hook.
//----------------------------------------------------------------------------
typedef struct {
    DWORD                   cbSize;         // size of structure in bytes
    IUnknown               *punk;           // pointer to interface being invoked
    const volatile JAVAARG *pJavaArgs;      // pointer to Java argument stack
} J2CMethodHookInfo;

//----------------------------------------------------------------------------
// Information structure for COM->Java Custom Method hook.
//----------------------------------------------------------------------------
typedef struct {
    DWORD                      cbSize;         // size of structure in bytes
    struct methodblock        *javaMethod;     // java method to call
    LPVOID                     pComArgs;       // pointer to COM method argument stack
    const volatile JAVAARG    *ppThis;         // pointer to pointer to Java this

    // Store the COM result here.
    union {
        HRESULT                         resHR;
        DWORD                           resDWORD;
        double                          resDouble;
    };
} C2JMethodHookInfo;


    

#ifdef __cplusplus
}
#endif



#endif _NATIVCOM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\native.h ===
// (C) Copyright 1996-1997, Microsoft Corporation and it suppliers.

//----------------------------------------------------------------------------
// Public header for facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef _NATIVE_
#define _NATIVE_

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// Since handles have gone away, this is no op. The unhands() in this file
// a redundant but useful for clarity.
// Note: You can not just unhand an array to get at it's data, you must now 
// use unhand(x)->body.
//----------------------------------------------------------------------------
#define unhand(phobj) (phobj)

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define JAVAPKG	"java/lang/"

//----------------------------------------------------------------------------
// Standard Java declarations for built in types.
//----------------------------------------------------------------------------
typedef long OBJECT;
typedef OBJECT Classjava_lang_Object;
typedef OBJECT Hjava_lang_Object;
typedef OBJECT ClassObject;
typedef Hjava_lang_Object JHandle;
typedef Hjava_lang_Object HObject;

typedef unsigned short unicode;
typedef long int32_t;
typedef __int64 int64_t;
typedef int BOOL;
typedef void *PVOID;    
typedef unsigned long DWORD;
#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
typedef unsigned int size_t;
#endif
#ifndef VOID
#define VOID void
#endif
#ifndef _BOOL_T_DEFINED
#define _BOOL_T_DEFINED
typedef BOOL bool_t;
#endif

//----------------------------------------------------------------------------
// All RNI DLLs should export the following function to let the VM determine
// if the DLL is compatible with it.
//----------------------------------------------------------------------------

DWORD __declspec(dllexport) __cdecl RNIGetCompatibleVersion();

#ifndef RNIVER
#define RNIMAJORVER         2
#define RNIMINORVER         0
#define RNIVER              ((((DWORD) RNIMAJORVER) << 16) + (DWORD) RNIMINORVER)
#endif

//----------------------------------------------------------------------------
// Use to get the length of an array an HObject.
//----------------------------------------------------------------------------
#define obj_length(hobj) (((ArrayOfSomething*)unhand(hobj))->length)

//----------------------------------------------------------------------------
// Thread entry/exit functions.
// These functions should wrap any calls into the virtual machine.
//----------------------------------------------------------------------------
typedef struct {
	DWORD	reserved[6];
} ThreadEntryFrame;

BOOL __cdecl PrepareThreadForJava(PVOID pThreadEntryFrame);
VOID __cdecl UnprepareThreadForJava(PVOID pThreadEntryFrame);

//----------------------------------------------------------------------------
// Garbage Collection.
//----------------------------------------------------------------------------
typedef struct {
	DWORD	reserved[6];
} GCFrame;

void    __cdecl GCFramePush(PVOID pGCFrame, PVOID pObjects, 
                DWORD cbObjectStructSize);
void    __cdecl GCFramePop(PVOID pGCFrame);

// 'Weak' ptrs
HObject** __cdecl GCGetPtr(HObject *phobj);
void    __cdecl GCFreePtr(HObject **pphobj);

#define GCGetWeakPtr    GCGetPtr
#define GCFreeWeakPtr   GCFreePtr

// 'Strong' ptrs
HObject** __cdecl GCNewHandle(HObject *phobj);
void __cdecl GCFreeHandle(HObject **pphobj);

// 'Internal reserved pinned ptrs
HObject** __cdecl GCNewPinnedHandle(HObject *phobj);
void __cdecl GCFreePinnedHandle(HObject **pphobj);

// GC write barrier support

void __cdecl GCSetObjectReferenceForObject (HObject** location, HObject* phobj);
void __cdecl GCSetObjectReferenceForHandle (HObject** handle, HObject* phobj);


int     __cdecl GCEnable();
int     __cdecl GCDisable();
int     __cdecl GCDisableCount();
int     __cdecl GCEnableCompletely();
void    __cdecl GCDisableMultiple(int cDisable);

//----------------------------------------------------------------------------
// "Built-in" object structures...
// These include helper macro's to get at array data.
//----------------------------------------------------------------------------

#pragma pack(push,4)

typedef struct Classjava_lang_String Classjava_lang_String;
#define Hjava_lang_String Classjava_lang_String
typedef Hjava_lang_String HString;

typedef struct ClassArrayOfByte
{
    int32_t MSReserved;
    unsigned long length;
    char body[1];
} ClassArrayOfByte;
#define HArrayOfByte ClassArrayOfByte
#define ArrayOfByte ClassArrayOfByte

typedef struct ClassArrayOfChar
{
    int32_t MSReserved;
    unsigned long length;
    unsigned short body[1];
} ClassArrayOfChar;
#define HArrayOfChar ClassArrayOfChar
#define ArrayOfChar ClassArrayOfChar

typedef struct ClassArrayOfShort
{
    int32_t MSReserved;
    unsigned long length;
    short body[1];
} ClassArrayOfShort;
#define HArrayOfShort ClassArrayOfShort
#define ArrayOfShort ClassArrayOfShort

typedef struct ClassArrayOfInt
{
    int32_t MSReserved;
    unsigned long length;
    long body[1];
} ClassArrayOfInt;
#define HArrayOfInt ClassArrayOfInt
#define ArrayOfInt ClassArrayOfInt

typedef struct ClassArrayOfLong
{
    int32_t MSReserved;
    unsigned long length;
    __int64 body[1];
} ClassArrayOfLong;
#define HArrayOfLong ClassArrayOfLong
#define ArrayOfLong ClassArrayOfLong

typedef struct ClassArrayOfFloat
{
    int32_t MSReserved;
    unsigned long length;
    float body[1];
} ClassArrayOfFloat;
#define HArrayOfFloat ClassArrayOfFloat
#define ArrayOfFloat ClassArrayOfFloat

typedef struct ClassArrayOfDouble
{
    int32_t MSReserved;
    unsigned long length;
    double body[1];
} ClassArrayOfDouble;
#define HArrayOfDouble ClassArrayOfDouble
#define ArrayOfDouble ClassArrayOfDouble

typedef struct ClassArrayOfObject
{
    int32_t MSReserved;
    unsigned long length;
    HObject *body[1];
} ClassArrayOfObject;
#define HArrayOfObject ClassArrayOfObject
#define ArrayOfObject ClassArrayOfObject

typedef struct ClassArrayOfString
{
    int32_t MSReserved;
    unsigned long length;
    HString  *(body[1]);
} ClassArrayOfString;
#define HArrayOfString ClassArrayOfString
#define ArrayOfString ClassArrayOfString

typedef struct ClassArrayOfArray
{
    int32_t MSReserved;
    unsigned long length;
    JHandle *(body[1]);
} ClassArrayOfArray;
#define HArrayOfArray ClassArrayOfArray
#define ArrayOfArray ClassArrayOfArray

typedef struct
{
    int32_t MSReserved;
    unsigned long length;
} ArrayOfSomething;

#pragma pack(pop)

//----------------------------------------------------------------------------
// We automatically track the execution environment so there's no EE() call
// needed anymore, just pass NULL if an API needs one.
//----------------------------------------------------------------------------
#define EE() NULL
typedef void ExecEnv;

//----------------------------------------------------------------------------
// Exception handling stuff...
//----------------------------------------------------------------------------
void __cdecl SignalError(struct execenv *ee, const char *ename, const char *DetailMessage);
void __cdecl SignalErrorPrintf( const char *ename, const char *pszFormat, ...);

bool_t __cdecl exceptionOccurred(ExecEnv *ee);
void __cdecl exceptionDescribe(ExecEnv *ee);
void __cdecl exceptionClear(ExecEnv *ee);
void __cdecl exceptionSet( ExecEnv *ee, HObject *phThrowable );

HObject * __cdecl getPendingException(ExecEnv *ee);

//----------------------------------------------------------------------------
// Standard exec functions...
//----------------------------------------------------------------------------
typedef PVOID ClassClass;

HObject* __cdecl execute_java_constructor(ExecEnv *ee, const char *classname,
        ClassClass *cb, const char *signature, ...);
HObject* __cdecl execute_java_constructorV(ExecEnv *ee, const char *classname,
        ClassClass *cb, const char *signature, va_list args);
        
#ifndef execute_java_dynamic_method
long __cdecl execute_java_dynamic_method(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, ...);
#endif
int64_t __cdecl execute_java_dynamic_method64(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, ...);
int64_t __cdecl execute_java_dynamic_methodV(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, va_list args);

#ifndef execute_java_interface_method
long __cdecl execute_java_interface_method(ExecEnv *ee, HObject *pobj,
        ClassClass j_interface, const char *method_name, const char *signature, ...);
#endif
int64_t __cdecl execute_java_interface_method64(ExecEnv *ee, HObject *pobj,
        ClassClass j_interface, const char *method_name, const char *signature, ...);
int64_t __cdecl execute_java_interface_methodV(ExecEnv *ee, HObject *pobj,
        ClassClass j_interface, const char *method_name, const char *signature, va_list args);

#ifndef execute_java_static_method
long __cdecl execute_java_static_method(ExecEnv *ee, ClassClass *cb, 
        const char *method_name, const char *signature, ...);
#endif
int64_t __cdecl execute_java_static_method64(ExecEnv *ee, ClassClass *cb,
        const char *method_name, const char *signature, ...);
int64_t __cdecl execute_java_static_methodV(ExecEnv *ee, ClassClass *cb,
        const char *method_name, const char *signature, va_list args);

//----------------------------------------------------------------------------
// NB The resolve flag is ignored, classes found with this api will always
// be resolved.
//----------------------------------------------------------------------------
ClassClass* __cdecl FindClass(ExecEnv *ee, char *classname, bool_t resolve);

//----------------------------------------------------------------------------
// FindClassEx
//
// Similar to FindClass, but can take some flags that control how the class
// load operation works.
//
// The valid flags are:
//  
//   FINDCLASSEX_NOINIT
//      If the class is a system class, will prevent the classes static
//      initializer from running.  
//
//   FINDCLASSEX_IGNORECASE
//      Will perform a case-insensitive validation of the class name, as
//      opposed to the case-sensitive validation that normally occurs.
//
//   FINDCLASSEX_SYSTEMONLY
//       Will only look for the named class as a system class.
//
//----------------------------------------------------------------------------

#define FINDCLASSEX_NOINIT      0x0001
#define FINDCLASSEX_IGNORECASE  0x0002
#define FINDCLASSEX_SYSTEMONLY  0x0004

ClassClass* __cdecl FindClassEx(char *pszClassName,DWORD dwFlags);

//----------------------------------------------------------------------------
// Helper function that returns a methodblock.
//----------------------------------------------------------------------------
struct methodblock* __cdecl get_methodblock(HObject *pjobj, const char
        *method_name, char *signature);

//----------------------------------------------------------------------------
// If you pass in a methodblock from get_methodblock the method name and
// sig are ignored and so it's faster than a regular execute.
//----------------------------------------------------------------------------
#ifndef do_execute_java_method
long __cdecl do_execute_java_method(ExecEnv *ee, void *obj, const char
        *method_name, const char *signature, struct methodblock *mb,
        bool_t isStaticCall, ...);
#endif
int64_t __cdecl do_execute_java_method64(ExecEnv *ee, void *obj, const char
        *method_name, const char *signature, struct methodblock *mb,
        bool_t isStaticCall, ...);

//----------------------------------------------------------------------------
// isInstanceOf
//
// Returns true if the specified object can be cast to the named class
// type.
//----------------------------------------------------------------------------

BOOL __cdecl isInstanceOf(JHandle *phobj, const char *classname);

//----------------------------------------------------------------------------
// is_instance_of
//
// Returns true if the specified object can be cast to the specified
// class type.
//----------------------------------------------------------------------------

BOOL __cdecl is_instance_of(JHandle *phobj,ClassClass *dcb,ExecEnv *ee);

//----------------------------------------------------------------------------
// is_subclass_of
//
// Returns true if the class (cb) is a subclass of the specified class(dcb).
//----------------------------------------------------------------------------

BOOL __cdecl is_subclass_of(ClassClass *cb, ClassClass *dcb, ExecEnv *ee);

//----------------------------------------------------------------------------
// ImplementsInterface
//
// Returns true if the class (cb) implements the specified interface (icb).
//----------------------------------------------------------------------------

BOOL __cdecl ImplementsInterface(ClassClass *cb,ClassClass *icb,ExecEnv *ee);

//----------------------------------------------------------------------------
#define T_TMASK	034
#define T_LMASK 003
#define T_MKTYPE( t, l )  ( ( (t)&T_TMASK ) | ( (l)&T_LMASK) )

#define T_CLASS		2
#define T_FLOATING	4	
#define T_CHAR		5
#define T_INTEGER	010
#define T_BOOLEAN	4

#define T_FLOAT     T_MKTYPE(T_FLOATING,2)
#define T_DOUBLE    T_MKTYPE(T_FLOATING,3)
#define T_BYTE	    T_MKTYPE(T_INTEGER,0)
#define T_SHORT	    T_MKTYPE(T_INTEGER,1)
#define T_INT	    T_MKTYPE(T_INTEGER,2)
#define T_LONG	    T_MKTYPE(T_INTEGER,3)

//----------------------------------------------------------------------------
// Create an array of primitive types only (int, long etc).
//----------------------------------------------------------------------------
HObject* __cdecl ArrayAlloc(int type, int cItems);

//----------------------------------------------------------------------------
// Create an array of objects.
//----------------------------------------------------------------------------
HObject* __cdecl ClassArrayAlloc(int type, int cItems, const char *szSig);

//----------------------------------------------------------------------------
// Copy an array ala System.arrayCopy()
//----------------------------------------------------------------------------
void __cdecl ArrayCopy(HObject *srch, long src_pos, HObject *dsth, 
        long dst_pos, long length);

//----------------------------------------------------------------------------
// Create and return a new array of bytes initialized from the C string.
//----------------------------------------------------------------------------
HArrayOfByte* __cdecl MakeByteString(const char *str, long len);

//----------------------------------------------------------------------------
// Create and return a new Java String object, initialized from the C string.
//----------------------------------------------------------------------------
Hjava_lang_String* __cdecl makeJavaString(const char *str, int len);
Hjava_lang_String* __cdecl makeJavaStringW(const unicode *pszwSrc, int cch);

//----------------------------------------------------------------------------
// Create and return a new Java String object, initialized from a null 
// terminated, UTF8 formatted, C string.
//----------------------------------------------------------------------------
Hjava_lang_String* __cdecl makeJavaStringFromUtf8(const char *pszUtf8);

//----------------------------------------------------------------------------
// Get the characters of the String object into a C string buffer.
// No allocation occurs. Assumes that len is the size of the buffer.
// The C string's address is returned.
//----------------------------------------------------------------------------
char* __cdecl javaString2CString(Hjava_lang_String *s, char *buf, int buflen);

//----------------------------------------------------------------------------
// Return the length of the String object.
//----------------------------------------------------------------------------
int __cdecl javaStringLength(Hjava_lang_String *s);

//----------------------------------------------------------------------------
// Return temporary ptr to first char of the String object.
// May change when gc happens.
//----------------------------------------------------------------------------
unicode * __cdecl javaStringStart (HString *string);

//----------------------------------------------------------------------------
// Note: The int passed to these API's must be an object ptr.
//----------------------------------------------------------------------------
#define obj_monitor(handlep) ((int) handlep)
void __cdecl monitorEnter(unsigned int);
void __cdecl monitorExit(unsigned int);
void __cdecl monitorNotify(unsigned int);
void __cdecl monitorNotifyAll(unsigned int);
void __cdecl monitorWait(unsigned int, int64_t millis);

#define ObjectMonitorEnter(obj)         monitorEnter((int)obj)
#define ObjectMonitorExit(obj)          monitorExit((int)obj)
#define ObjectMonitorNotify(obj)        monitorNotify((int)obj)
#define ObjectMonitorNotifyAll(obj)     monitorNotifyAll((int)obj)
#define ObjectMonitorWait(obj,millis)   monitorWait((int)obj,millis)

//----------------------------------------------------------------------------
// String helpers...
//----------------------------------------------------------------------------
int __cdecl jio_snprintf(char *str, size_t count, const char *fmt, ...);
int __cdecl jio_vsnprintf(char *str, size_t count, const char *fmt, va_list 
        args);

//----------------------------------------------------------------------------
// Methods to get information about the caller of a native method.
//----------------------------------------------------------------------------

ClassClass * __cdecl GetNativeMethodCallersClass();
struct methodblock* __cdecl GetNativeMethodCallersMethodInfo();

//----------------------------------------------------------------------------
// Member attributes, as appear in Java class file.
//----------------------------------------------------------------------------

#define ACC_PUBLIC      0x0001       
#define ACC_PRIVATE     0x0002       
#define ACC_PROTECTED   0x0004       
#define ACC_STATIC      0x0008       
#define ACC_FINAL       0x0010       
#define ACC_SYNCH       0x0020       
#define ACC_SUPER       0x0020       
#define ACC_THREADSAFE  0x0040       
#define ACC_VOLATILE    0x0040        
#define ACC_TRANSIENT   0x0080        
#define ACC_NATIVE      0x0100        
#define ACC_INTERFACE   0x0200        
#define ACC_ABSTRACT    0x0400        

//----------------------------------------------------------------------------
// Class information
//----------------------------------------------------------------------------

// Total number of fields in the class, including supers
unsigned __cdecl            Class_GetFieldCount(ClassClass *cls);
struct fieldblock * __cdecl Class_GetField(ClassClass *cls, const char *name);
struct fieldblock * __cdecl Class_GetFieldByIndex(ClassClass *cls, unsigned index);
// Total number of methods, including supers.
unsigned __cdecl            Class_GetMethodCount(ClassClass *cls);
struct methodblock* __cdecl Class_GetMethod(ClassClass *cls, const char *name, const char *signature);
struct methodblock* __cdecl Class_GetMethodByIndex(ClassClass *cls, unsigned index);
ClassClass * __cdecl        Class_GetSuper(ClassClass *cls);
const char * __cdecl        Class_GetName(ClassClass *cls);
unsigned __cdecl            Class_GetInterfaceCount(ClassClass *cls);
ClassClass * __cdecl        Class_GetInterface(ClassClass *cls, unsigned index);
// Returns combination of ACC_* constants.
int __cdecl                 Class_GetAttributes(ClassClass *cls);

//----------------------------------------------------------------------------
// Field/method information
//----------------------------------------------------------------------------

const char * __cdecl        Member_GetName(PVOID member);
const char * __cdecl        Member_GetSignature(PVOID member);
// class of the field/method is implemented in.
ClassClass * __cdecl        Member_GetClass(PVOID member);
// Returns combination of ACC_* constants.
int __cdecl                 Member_GetAttributes(PVOID member);

// For non-static fields, Offset of field in object.  See also Field_Get/SetValue.
unsigned __cdecl            Field_GetOffset(struct fieldblock * field);
// Ptr to static value
PVOID __cdecl               Field_GetStaticPtr(struct fieldblock * field);


//----------------------------------------------------------------------------
// Object accessors
//----------------------------------------------------------------------------
ClassClass * __cdecl        Object_GetClass(HObject *obj);

__int32 __cdecl             Field_GetValue(HObject *obj, struct fieldblock * field);
__int64 __cdecl             Field_GetValue64(HObject *obj, struct fieldblock * field);
float __cdecl               Field_GetFloat(HObject *obj, struct fieldblock * field);
double __cdecl              Field_GetDouble(HObject *obj, struct fieldblock * field);
void __cdecl                Field_SetValue(HObject *obj, struct fieldblock * field, __int32 value);
void __cdecl                Field_SetValue64(HObject *obj, struct fieldblock * field, __int64 value);
void __cdecl                Field_SetFloat(HObject *obj, struct fieldblock * field, float value);
void __cdecl                Field_SetDouble(HObject *obj, struct fieldblock * field, double value);

#define Field_GetBoolean(obj,field)     ((bool_t)       Field_GetValue(obj,field))
#define Field_GetByte(obj,field)        ((signed char)  Field_GetValue(obj,field))
#define Field_GetChar(obj,field)        ((unicode)      Field_GetValue(obj,field))
#define Field_GetShort(obj,field)       ((short)        Field_GetValue(obj,field))
#define Field_GetInt(obj,field)                         Field_GetValue(obj,field)
#define Field_GetLong(obj,field)                        Field_GetValue64(obj,field)
#define Field_GetObject(obj,field)      ((HObject*)     Field_GetValue(obj,field))
#define Field_GetFloat(obj,field)                       Field_GetFloat(obj,field)
#define Field_GetDouble(obj,field)                      Field_GetDouble(obj,field)

#define Field_SetBoolean(obj,field,value)               Field_SetValue(obj,field,(bool_t)(value))
#define Field_SetByte(obj,field,value)                  Field_SetValue(obj,field,(signed char)(value))
#define Field_SetChar(obj,field,value)                  Field_SetValue(obj,field,(unicode)(value))
#define Field_SetShort(obj,field,value)                 Field_SetValue(obj,field,(short)(value))
#define Field_SetInt(obj,field,value)                   Field_SetValue(obj,field,value)
#define Field_SetLong(obj,field,value)                  Field_SetValue64(obj,field,value)
#define Field_SetObject(obj,field,value)                Field_SetValue(obj,field,(__int32)(value))
#define Field_SetFloat(obj,field,value)                 Field_SetFloat(obj,field,value)
#define Field_SetDouble(obj,field,value)                Field_SetDouble(obj,field,value)


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\naltypes.h ===
//=============================================================================
//  Microsoft Bloodhound. Copyright (C) 1991-1998.
//
//  MODULE: naltypes.h
//
//  This source file contains defintions for the Network Abstraction Layer (NAL).
//
//  NOTE: Do not make changes to this file unless you mahe changes to the
//        NDIS 2.0 driver header files. There are masm equivalents to change.
//=============================================================================

#include "buffer.h"                             //... Include buffer definitions.
#include "bherr.h"                              //... Bloodhound error codes.
#include "neterr.h"                             //... Network Topology error codes
#include "queue.h"                              //... Queuing functions.

#if !defined(_NALTYPES_)

#define _NALTYPES_

#pragma pack(1)

//=============================================================================
//  NETWORK_MESSAGE_TRIGGER_COMPLETE:
//
//  param1  =  Trigger structure.
//  param2  =  Nothing.
//=============================================================================

#define NETWORK_MESSAGE_TRIGGER_COMPLETE        0

//=============================================================================
//  NETWORK_MESSAGE_TRANSMIT_COMPLETE:
//
//  param1  =  Transmit statistics.
//  param2  =  Packet queue.
//=============================================================================

#define NETWORK_MESSAGE_TRANSMIT_COMPLETE       1

//=============================================================================
//  NETWORK_MESSAGE_RESET_STATE:
//
//  param1  =  RESET_COMPLETE     reset, current net handle now invalid
//             RESET_OPEN         reset, current net handle still valid
//  param2  =  Packet queue.
//=============================================================================

#define NETWORK_MESSAGE_RESET_STATE             2

#define RESET_COMPLETE                          0
#define RESET_OPEN                              1

//=============================================================================
//  NETWORK_MESSAGE_BH_ERROR
//
//  param1  =  BHERR ERROR CODE 
//  param2  =  LPSTR Description (optional pointer to description of error)
//=============================================================================

#define NETWORK_MESSAGE_BH_ERROR                3

//=============================================================================
//  NETWORK_MESSAGE_NETWORK_ERROR
//
//  param1  =  MacType (EtherNet, TokenRing, FDDI, etc.)
//  param2  =  NETERR_ error code (specific to topology)
//=============================================================================

#define NETWORK_MESSAGE_NETWORK_ERROR           4

//=============================================================================
//  The network handle.
//=============================================================================

#ifndef MAKE_IDENTIFIER
#define MAKE_IDENTIFIER(a, b, c, d)     ((DWORD) MAKELONG(MAKEWORD(a, b), MAKEWORD(c, d)))
#endif

typedef struct _NETWORK         *HNETWORK;

#define HANDLE_TYPE_NETWORK     MAKE_IDENTIFIER('N', 'E', 'T', '$')

//=============================================================================
//  NETWORKSTATE data structure.
//=============================================================================

typedef struct _NETWORKSTATUS
{
    DWORD       State;                                      //... Current state.
    DWORD       Flags;                                      //... Current flags.
    DWORD       TriggerAction;                              //... Trigger action.
    DWORD       TriggerOpcode;                              //... Trigger opcode.
    DWORD       TriggerState;                               //... Trigger state.
    DWORD       BufferSize;                                 //... Capture buffer size.
} NETWORKSTATUS;

typedef NETWORKSTATUS *LPNETWORKSTATUS;

#define NETWORKSTATUS_SIZE   sizeof(NETWORKSTATUS)

#define NETWORKSTATUS_STATE_VOID                0           //... Nothing state.
#define NETWORKSTATUS_STATE_INIT                1           //... Initial state.
#define NETWORKSTATUS_STATE_READY               2           //... Ready state.
#define NETWORKSTATUS_STATE_CAPTURING           3           //... Capturing state.
#define NETWORKSTATUS_STATE_PAUSED              4           //... Paused state.

#define NETWORKSTATUS_FLAGS_TRIGGER_PENDING     0x0001      //... Trigger pending.

//=============================================================================
//  General constants.
//=============================================================================

#define MAC_TYPE_UNKNOWN                        0           //... not supported
#define MAC_TYPE_ETHERNET                       1           //... ethernet and 802.3
#define MAC_TYPE_TOKENRING                      2           //... tokenring (802.5)
#define MAC_TYPE_FDDI                           3           //... fddi.

#define MACHINE_NAME_LENGTH                     16
#define USER_NAME_LENGTH                        32
#define ADAPTER_COMMENT_LENGTH                  32

#define CLOSE_FLAGS_CLOSE                       0x0000
#define CLOSE_FLAGS_SUSPEND                     0x0001

//=============================================================================
//  NAL error codes.
//=============================================================================

#define NAL_SUCCESS                          BHERR_SUCCESS
#define NAL_INVALID_NETWORK_ID               BHERR_INVALID_NETWORK_ID
#define NAL_INVALID_HNETCONTEXT              BHERR_INVALID_HNETWORK
#define NAL_OUT_OF_MEMORY                    BHERR_OUT_OF_MEMORY
#define NAL_NETWORK_BUSY                     BHERR_NETWORK_BUSY
#define NAL_INVALID_HBUFFER                  BHERR_INVALID_HBUFFER
#define NAL_INVALID_PACKET_LENGTH            BHERR_INVALID_PACKET_LENGTH
#define NAL_TRANSMIT_ERROR                   BHERR_TRANSMIT_ERROR
#define NAL_CAPTURE_PAUSED                   BHERR_CAPTURE_PAUSED
#define NAL_CAPTURE_NOT_PAUSED               BHERR_CAPTURE_NOT_PAUSED
#define NAL_CAPTURE_STARTED                  BHERR_CAPTURING
#define NAL_CAPTURE_NOT_STARTED              BHERR_NOT_CAPTURING
#define NAL_MSDOS_DRIVER_NOT_LOADED          BHERR_MSDOS_DRIVER_NOT_LOADED
#define NAL_WINDOWS_DRIVER_NOT_LOADED        BHERR_WINDOWS_DRIVER_NOT_LOADED
#define NAL_MSDOS_DRIVER_INIT_FAILURE        BHERR_MSDOS_DRIVER_INIT_FAILURE
#define NAL_WINDOWS_DRIVER_INIT_FAILURE      BHERR_WINDOWS_DRIVER_INIT_FAILURE
#define NAL_PROMISCUOUS_MODE_NOT_SUPPORTED   BHERR_PROMISCUOUS_MODE_NOT_SUPPORTED
#define NAL_MAC_DRIVER_OPEN_FAILURE          BHERR_MAC_DRIVER_OPEN_FAILURE
#define NAL_PENDING                          BHERR_PENDING
#define NAL_INTERNAL_EXCEPTION               BHERR_INTERNAL_EXCEPTION

//=============================================================================
//  Trigger codes.
//=============================================================================

#define TRIGGER_OFF                                     0
#define TRIGGER_ON_PATTERN_MATCH                        1
#define TRIGGER_ON_BUFFER_CONTENT                       2
#define TRIGGER_ON_PATTERN_MATCH_THEN_BUFFER_CONTENT    3
#define TRIGGER_ON_BUFFER_CONTENT_THEN_PATTERN_MATCH    4

#define TRIGGER_STATE_NOTHING                           0
#define TRIGGER_STATE_STOP_CAPTURE                      1
#define TRIGGER_STATE_PAUSE_CAPTURE                     2

#define TRIGGER_ACTION_NOTIFY                           0
#define TRIGGER_ACTION_EXECUTE_COMMAND                  1

//=============================================================================
//  Handle defintions.
//=============================================================================

typedef LPVOID HNETCONTEXT;

//=============================================================================
//  Transmit statistics structure.
//=============================================================================

typedef struct _TRANSMITSTATS
{
    DWORD       TotalFramesSent;
    DWORD       TotalBytesSent;
    DWORD       TotalTransmitErrors;
} TRANSMITSTATS;

typedef TRANSMITSTATS *LPTRANSMITSTATS;

#define TRANSMITSTATS_SIZE   sizeof(TRANSMITSTATS)

//=============================================================================
//  Statistics structure.
//=============================================================================

typedef struct _STATISTICS
{
    //=========================================================================
    //  Statistics kept by BH driver.
    //=========================================================================

    DWORD           TimeElapsed;

    //...           Buffered statistics

    DWORD           TotalFramesCaptured;
    DWORD           TotalBytesCaptured;

    //...           Filtered statistics

    DWORD           TotalFramesFiltered;
    DWORD           TotalBytesFiltered;

    //...           Overall statistics.

    DWORD           TotalFramesSeen;
    DWORD           TotalBytesSeen;

    DWORD           TotalMulticastsReceived;
    DWORD           TotalBroadcastsReceived;

    DWORD           TotalFramesDropped;
    DWORD           TotalFramesDroppedFromBuffer;

    //=========================================================================
    //  Statistics kept by MAC driver.
    //=========================================================================


    DWORD           MacFramesReceived;
    DWORD           MacCRCErrors;

    union
    {
        DWORD           MacBytesReceived;
        LARGE_INTEGER   MacBytesReceivedEx;
    };

    DWORD           MacFramesDropped_NoBuffers;
    DWORD           MacMulticastsReceived;
    DWORD           MacBroadcastsReceived;
    DWORD           MacFramesDropped_HwError;
} STATISTICS;

typedef STATISTICS *LPSTATISTICS;

#define STATISTICS_SIZE   sizeof(STATISTICS)

//=============================================================================
//  Protocol statistics structure.
//=============================================================================

typedef struct _PROTOCOLSTAT
{
    DWORD       ProtocolID;
    DWORD       ProtocolFramesCaptured;
    DWORD       ProtocolBytesCaptured;
} PROTOCOLSTAT;

typedef PROTOCOLSTAT *LPPROTOCOLSTAT;

#define PROTOCOLSTAT_SIZE   sizeof(PROTOCOLSTAT)

typedef struct _PROTOCOL_STATISTICS_TABLE
{
    DWORD           nProtocols;
    LPPROTOCOLSTAT  ProtocolStatistic;
} PROTOCOL_STATISTICS_TABLE;

typedef PROTOCOL_STATISTICS_TABLE *LPPROTOCOL_STATISTICS_TABLE;

#define PROTOCOL_STATISTIC_TABLE_SIZE   sizeof(PROTOCOL_STATISTICS_TABLE)

//=============================================================================
//  Packet data structure.
//=============================================================================

typedef struct _PACKET *LPPACKET;

typedef struct _PACKET
{
    LPBYTE      Frame;                      //... Pointer to entire MAC frame.
    LPVOID      FrameMdl;                   //... Driver-level frame pointer.
    WORD	FrameSize;		    //... Length of frame.
    WORD	ReferenceCount; 	    //... Number of frame references (lock count).
    DWORD       TimeStamp;                  //... Timestamp of frame.
} PACKET;

#define PACKET_SIZE  sizeof(PACKET)

//=============================================================================
//  StatFrame type.
//=============================================================================

typedef struct _FRAMEHDR
{
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    WORD    Length;
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} FRAMEHDR;

typedef struct _TRFRAMEHDR
{
    BYTE    AC;
    BYTE    FC;
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} TRFRAMEHDR;

#define DEFAULT_AC          0x00
#define DEFAULT_FC          0x40
#define DEFAULT_SAP         0xAA
#define DEFAULT_CONTROL     0x03
#define DEFAULT_ETHERTYPE   0x8419

typedef struct _FDDIFRAMEHDR
{
    BYTE    FC;
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} FDDIFRAMEHDR;
#define DEFAULT_FDDIFC      0x10

typedef struct _FDDISTATFRAME
{
    DWORD       TimeStamp;          //... Relative time in milliseconds.
    WORD        FrameLength;        //... MAC frame length.
    WORD        nBytesAvail;        //... Actual frame length copied.
    FDDIFRAMEHDR  FrameHeader;
    BYTE        FrameID[4];         //... "$MST"
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} FDDISTATFRAME;

typedef FDDISTATFRAME *LPFDDISTATFRAME;
typedef FDDISTATFRAME UNALIGNED *ULPFDDISTATFRAME;

#define FDDISTATFRAME_SIZE  sizeof(FDDISTATFRAME)

typedef struct _TRSTATFRAME
{
    DWORD       TimeStamp;          //... Relative time in milliseconds.
    WORD        FrameLength;        //... MAC frame length.
    WORD        nBytesAvail;        //... Actual frame length copied.
    TRFRAMEHDR  FrameHeader;
    BYTE        FrameID[4];         //... "$MST"
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} TRSTATFRAME;

typedef TRSTATFRAME *LPTRSTATFRAME;
typedef TRSTATFRAME UNALIGNED *ULPTRSTATFRAME;

#define TRSTATFRAME_SIZE  sizeof(TRSTATFRAME)

typedef struct _STATFRAME
{
    DWORD       TimeStamp;          //... Relative time in milliseconds.
    WORD        FrameLength;        //... MAC frame length.
    WORD        nBytesAvail;        //... Actual frame length copied.
    FRAMEHDR    FrameHeader;
    BYTE        FrameID[4];         //... "$MST"
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} STATFRAME;


#define STATISTICS_VERSION  0x00000000

typedef STATFRAME *LPSTATFRAME;
typedef STATFRAME UNALIGNED *ULPSTATFRAME;

#define STATFRAME_SIZE  sizeof(STATFRAME)


//=============================================================================
//  The network procedure type.
//
//  Syntax:
//
//  DWORD CALLBACK NetworkProc(handle, message, status, UserContext, param1, param2).
//=============================================================================

typedef DWORD (WINAPI *NETWORKPROC)(HNETWORK, DWORD, DWORD, LPVOID, LPVOID, LPVOID);


//=============================================================================
//  Packet queue data structure.
//=============================================================================

typedef struct _PACKETQUEUE *LPPACKETQUEUE;

typedef struct _PACKETQUEUE
{
    //=========================================================================
    //  The following members are set by the NAL interface and
    //  must be NOT used by the Bloodhound kernel or applications.
    //=========================================================================

    LINK            QueueLinkage;               //... Queue linkage (used by Bloodhound drivers).
    DWORD           State;                      //... Transmit complete flag (used by Bloodhound drivers).
    DWORD           Status;                     //... Final Bloodhound error code (used by Bloodhound drivers).
    LPVOID          TimerHandle;                //... Handle to timer or pending transmits (used by Bloodhound drivers).
    HANDLE          hNetwork;                   //... Network handle (set by NAL).
    LPVOID          InstData;                   //... OpenNetwork instance data.

    //=========================================================================
    //  The following members are set by NAL applications, such as the Bloodhound
    //  kernel.
    //=========================================================================

    DWORD           Size;                       //... The overall size in bytes.
    DWORD           FrameTimeDelta;             //... Time between frames (-1 means use frame timestamp).
    DWORD           QueueTimeDelta;             //... Time between queues.
    DWORD           IterationCount;             //... Number of times to repeat send sequence.
    TRANSMITSTATS   TransmitStats;              //... Transmit statistics structure.
    NETWORKPROC     NetworkProc;                //... Network procedure, used by the kernel to hook transmit completions.

    //=========================================================================
    //  The actual list of packets to transmit.
    //=========================================================================

    DWORD           nPackets;                   //... Packet queue length (i.e. number of frames to send).
    PACKET          Packet[0];                  //... Packet queue.
} PACKETQUEUE;

#define PACKETQUEUE_SIZE  sizeof(PACKETQUEUE)

#define PACKETQUEUE_STATE_VOID          0
#define PACKETQUEUE_STATE_PENDING       1
#define PACKETQUEUE_STATE_COMPLETE      2
#define PACKETQUEUE_STATE_CANCEL        3

//=============================================================================
//  Address structures
//=============================================================================

#define MAX_NAME_SIZE                   32
#define IP_ADDRESS_SIZE                 4
#define MAC_ADDRESS_SIZE                6

//      What is the maximum address size that we could have to copy?
//      IPX == DWORD + 6 bytes == 10
#define MAX_ADDRESS_SIZE                                10

//  VINES IP ADDRESS

typedef struct _VINES_IP_ADDRESS
{
    DWORD   NetID;
    WORD    SubnetID;
} VINES_IP_ADDRESS;

typedef VINES_IP_ADDRESS *LPVINES_IP_ADDRESS;

#define VINES_IP_ADDRESS_SIZE sizeof(VINES_IP_ADDRESS)

// ... IPX address

typedef struct _IPX_ADDRESS
{
    BYTE    Subnet[4];
    BYTE    Address[6];
} IPX_ADDRESS;

typedef IPX_ADDRESS *LPIPX_ADDRESS;

#define IPX_ADDRESS_SIZE sizeof(IPX_ADDRESS)

//... XNS address

typedef IPX_ADDRESS XNS_ADDRESS;

typedef IPX_ADDRESS *LPXNS_ADDRESS;

// ... ETHERNET SOURCE ADDRESS

typedef struct _ETHERNET_SRC_ADDRESS
{
    BYTE    RoutingBit:     1;
    BYTE    LocalBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_SRC_ADDRESS;

typedef ETHERNET_SRC_ADDRESS *LPETHERNET_SRC_ADDRESS;

// ... ETHERNET DESTINATION ADDRESS

typedef struct _ETHERNET_DST_ADDRESS
{
    BYTE    GroupBit:       1;
    BYTE    AdminBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_DST_ADDRESS;

typedef ETHERNET_DST_ADDRESS *LPETHERNET_DST_ADDRESS;

// ... FDDI addresses
typedef ETHERNET_SRC_ADDRESS FDDI_SRC_ADDRESS;
typedef ETHERNET_DST_ADDRESS FDDI_DST_ADDRESS;

typedef FDDI_SRC_ADDRESS *LPFDDI_SRC_ADDRESS;
typedef FDDI_DST_ADDRESS *LPFDDI_DST_ADDRESS;

// .... TOKENRING Source Address

typedef struct _TOKENRING_SRC_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    LocalBit:       1;
    BYTE    RoutingBit:     1;
    BYTE    Byte1;
    BYTE    Byte2:          7;
    BYTE    Functional:     1;
    BYTE    Reserved[3];
} TOKENRING_SRC_ADDRESS;

typedef TOKENRING_SRC_ADDRESS *LPTOKENRING_SRC_ADDRESS;

// .... TOKENRING Destination Address

typedef struct _TOKENRING_DST_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    AdminBit:       1;
    BYTE    GroupBit:       1;
    BYTE    Reserved[5];
} TOKENRING_DST_ADDRESS;

typedef TOKENRING_DST_ADDRESS *LPTOKENRING_DST_ADDRESS;

//... Old type def's

#define MACADDRESS_SIZE     MAC_ADDRESS_SIZE
#define IPADDRESS_SIZE      IP_ADDRESS_SIZE
#define IPXADDRESS_SIZE     IPX_ADDRESS_SIZE
#define VINESIPADDRESS_SIZE VINES_IP_ADDRESS_SIZE

typedef struct _ADDRESS
{
    DWORD                       Type;

    union
    {
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

        BYTE                    IPAddress[IP_ADDRESS_SIZE];

        BYTE                    IPXRawAddress[IPX_ADDRESS_SIZE];
        IPX_ADDRESS             IPXAddress;
        
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];
        VINES_IP_ADDRESS        VinesIPAddress;       

        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

        FDDI_SRC_ADDRESS        FddiSrcAddress;
        FDDI_DST_ADDRESS        FddiDstAddress;
    };

    WORD                        Flags;
} ADDRESS;

typedef ADDRESS *LPADDRESS;

#define ADDRESS_SIZE    sizeof(ADDRESS)

#define ADDRESS_TYPE_ETHERNET   0
#define ADDRESS_TYPE_IP         1
#define ADDRESS_TYPE_IPX        2
#define ADDRESS_TYPE_TOKENRING  3
#define ADDRESS_TYPE_FDDI       4
#define ADDRESS_TYPE_XNS        5
#define ADDRESS_TYPE_ANY        6        // NOTE: Special ANY and ANY_GROUP are placeholders, meaning, ignore this type
#define ADDRESS_TYPE_ANY_GROUP  7     
#define ADDRESS_TYPE_FIND_HIGHEST  8
#define ADDRESS_TYPE_VINES_IP   9
#define ADDRESS_TYPE_LOCAL_ONLY 10

#define ADDRESSTYPE_FLAGS_NORMALIZE     0x0001
#define ADDRESSTYPE_FLAGS_BIT_REVERSE   0x0002

//=============================================================================
//  Address pair.
//=============================================================================

typedef struct _ADDRESSPAIR
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS     DstAddress;
    ADDRESS     SrcAddress;
} ADDRESSPAIR;

typedef ADDRESSPAIR *LPADDRESSPAIR;

#define ADDRESS_FLAGS_MATCH_DST     0x0001  //... Match dest. address.
#define ADDRESS_FLAGS_MATCH_SRC     0x0002  //... Match src. address.
#define ADDRESS_FLAGS_EXCLUDE       0x0004  //... Perform logical XOR vs logical OR.
#define ADDRESS_FLAGS_GROUP_ADDR    0x0008  //... Match group bit only.

#define ADDRESS_FLAGS_MATCH_BOTH    0x0003  //... 0x0001 | 0x0002.

#define ADDRESSPAIR_SIZE sizeof(ADDRESSPAIR)

//=============================================================================
//  Address table.
//=============================================================================

#define MAX_ADDRESS_PAIRS   8

typedef struct _ADDRESSTABLE
{
    DWORD           nAddressPairs;
    ADDRESSPAIR     AddressPair[MAX_ADDRESS_PAIRS];
} ADDRESSTABLE;

typedef ADDRESSTABLE *LPADDRESSTABLE;

#define ADDRESSTABLE_SIZE sizeof(ADDRESSTABLE)

//=============================================================================
//  Network information.
//=============================================================================

typedef struct _NETWORKINFO
{
    BYTE            PermanentAddr[6];       //... Permanent MAC address
    BYTE            CurrentAddr[6];         //... Current  MAC address
    ADDRESS         OtherAddress;           //... Other address supported (IP, IPX, etc...)
    DWORD           LinkSpeed;              //... Link speed in Mbits.
    DWORD           MacType;                //... Media type.
    DWORD           MaxFrameSize;           //... Max frame size allowed.
    DWORD           Flags;                  //... Informational flags.
    DWORD           TimestampScaleFactor;   //... 1 = 1/1 ms, 10 = 1/10 ms, 100 = 1/100 ms, etc.
    BYTE            NodeName[32];           //... Name of remote workstation.
    BYTE            Comment[ADAPTER_COMMENT_LENGTH]; // Adapter comment field.
} NETWORKINFO;

typedef NETWORKINFO *LPNETWORKINFO;

#define NETWORKINFO_SIZE    sizeof(NETWORKINFO)

#define NETWORKINFO_FLAGS_PMODE_NOT_SUPPORTED           0x00000001
#define NETWORKINFO_FLAGS_LOOPBACK_NOT_SUPPORTED        0x00000002
#define NETWORKINFO_FLAGS_REMOTE_NAL                    0x00000004
#define NETWORKINFO_FLAGS_REMOTE_NAL_CONNECTED          0x00000008
#define NETWORKINFO_FLAGS_REMOTE_CARD                   0x00000010

//=============================================================================
//  Pattern structure.
//=============================================================================

#define MAX_PATTERN_LENGTH  16

typedef struct _PATTERNMATCH
{
    DWORD   Flags;
    WORD    Offset;
    WORD    Length;
    BYTE    PatternToMatch[MAX_PATTERN_LENGTH];                 //... Pattern to match.
} PATTERNMATCH;

#define PATTERN_MATCH_FLAGS_NOT                 0x00000001      //... Negate the results.
#define PATTERN_MATCH_FLAGS_DATA_RELATIVE       0x00000002      //... pattern is relative to data, not frame.

typedef PATTERNMATCH *LPPATTERNMATCH;

#define PATTERNMATCH_SIZE    sizeof(PATTERNMATCH)

//=============================================================================
//  Expression structure.
//=============================================================================

#define MAX_PATTERNS    4

typedef struct _ANDEXP
{
    DWORD            nPatternMatches;
    PATTERNMATCH     PatternMatch[MAX_PATTERNS];
} ANDEXP;

typedef ANDEXP *LPANDEXP;

#define ANDEXP_SIZE     sizeof(ANDEXP)

typedef struct _EXPRESSION
{
    DWORD       nAndExps;
    ANDEXP      AndExp[MAX_PATTERNS];
} EXPRESSION;

typedef EXPRESSION *LPEXPRESSION;

#define EXPRESSION_SIZE    sizeof(EXPRESSION)

//=============================================================================
//  Trigger.
//=============================================================================

typedef struct _TRIGGER
{
    DWORD           TriggerFlags;           //... Trigger flags.
    PATTERNMATCH    TriggerPatternMatch;    //... Trigger pattern match.
    BYTE            TriggerOpcode;          //... Trigger opcode.
    BYTE            TriggerAction;          //... Action to take when trigger occurs.
    WORD            TriggerState;           //... State change request.
    WORD            TriggerBufferSize;      //... Percentage of buffer to trigger on.
    LPSTR           TriggerCommand;         //... Command string to pass to WinExec.
} TRIGGER;

typedef TRIGGER *LPTRIGGER;

#define TRIGGER_SIZE    sizeof(TRIGGER)

#define TRIGGER_FLAGS_DATA_RELATIVE         0x00000001

//=============================================================================
//  Capture filter.
//=============================================================================

typedef struct _CAPTUREFILTER
{
    DWORD           FilterFlags;            //... filter flags,
    LPBYTE          SapTable;               //... sap table.
    LPWORD          EtypeTable;             //... etype table.
    WORD            nSaps;                  //... sap table length.
    WORD            nEtypes;                //... Etype table length.
    LPADDRESSTABLE  AddressTable;           //... Address table.
    EXPRESSION      FilterExpression;       //... Filter expression.
    TRIGGER         Trigger;                //... Trigger structure.
    DWORD           nFrameBytesToCopy;      //... Number of byte of each frame to copy.
    DWORD           Reserved;
} CAPTUREFILTER;

typedef CAPTUREFILTER *LPCAPTUREFILTER;

#define CAPTUREFILTER_SIZE sizeof(CAPTUREFILTER)

//=============================================================================
//  Capture filter flags. By default all frames are rejected and
//  NalSetCaptureFilter enables them based on the CAPTUREFILTER flags
//  defined below.
//=============================================================================

#define CAPTUREFILTER_FLAGS_INCLUDE_ALL_SAPS    0x0001      //... include saps.
#define CAPTUREFILTER_FLAGS_INCLUDE_ALL_ETYPES  0x0002      //... include etypes.
#define CAPTUREFILTER_FLAGS_TRIGGER             0x0004      //... process trigger.
#define CAPTUREFILTER_FLAGS_LOCAL_ONLY          0x0008      //... non-promiscuous.
#define CAPTUREFILTER_FLAGS_DISCARD_COMMENTS    0x0010      //... throw away our internal comment frames

//.. The following causes both saps and etypes to be included.

#define CAPTUREFILTER_FLAGS_INCLUDE_ALL         0x0003      //... 0x0001 | 0x0002

#define BUFFER_FULL_25_PERCENT                  0
#define BUFFER_FULL_50_PERCENT                  1
#define BUFFER_FULL_75_PERCENT                  2
#define BUFFER_FULL_100_PERCENT                 3

//=============================================================================
//  Station statistics.
//=============================================================================

typedef struct _STATIONSTATS *LPSTATIONSTATS;
typedef struct _SESSION      *LPSESSION;

typedef struct _SESSION
{
    LPSESSION       NextSession;            //... opaque, used by nal.
    LPSTATIONSTATS  StationOwner;
    LPSTATIONSTATS  StationPartner;
    DWORD           Flags;
    DWORD           TotalPacketsSent;
} SESSION;

#define SESSION_SIZE    sizeof(SESSION)

#define SESSION_FLAGS_INITIALIZED  0x0001           //... Structure has been initialized.
#define SESSION_FLAGS_EVENTPOSTED  0x0002           //... Nal has posted an event for this entry.

typedef struct _STATIONSTATS    *LPSTATIONSTATS;

typedef struct _STATIONSTATS
{
    LPSTATIONSTATS NextStationStats;        //... opaque, used by nal.
    LPSESSION       SessionPartnerList;     //... opaque, used by nal.
    DWORD           Flags;                  //... opaque, used by nal.
    BYTE            StationAddress[6];
    WORD            Pad;                    //... DWORD alignment.
    DWORD           TotalPacketsReceived;
    DWORD           TotalDirectedPacketsSent;
    DWORD           TotalBroadcastPacketsSent;
    DWORD           TotalMulticastPacketsSent;
    DWORD           TotalBytesReceived;
    DWORD           TotalBytesSent;
} STATIONSTATS;

#define STATIONSTATS_SIZE       sizeof(STATIONSTATS)

#define STATIONSTATS_FLAGS_INITIALIZED  0x0001      //... Structure has been initialized.
#define STATIONSTATS_FLAGS_EVENTPOSTED  0x0002      //... Nal has posted an event for this entry.

//=============================================================================
//  Bone packet definition.
//=============================================================================

#define STATIONQUERY_FLAGS_LOADED       0x0001      //... Driver is loaded but the kernel is not.
#define STATIONQUERY_FLAGS_RUNNING      0x0002      //... Driver is loaded but not capturing.
#define STATIONQUERY_FLAGS_CAPTURING    0x0004      //... Driver is actively capturing.
#define STATIONQUERY_FLAGS_TRANSMITTING 0x0008      //... Driver is actively transmitting.

typedef struct _STATIONQUERY
{
    DWORD           Flags;                              //... Current state of bloodhound.
    BYTE            BCDVerMinor;                        //... Binary coded decimal (minor).
    BYTE            BCDVerMajor;                        //... Binary coded decimal (major).
    DWORD           LicenseNumber;                      //... Software license number.
    BYTE            MachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    BYTE            UserName[USER_NAME_LENGTH];         //... Username name, if any.
    BYTE            Reserved[32];                       //... Reserved.
    BYTE            AdapterAddress[6];                  //... NIC address.
} STATIONQUERY;

typedef STATIONQUERY *LPSTATIONQUERY;

#define STATIONQUERY_SIZE sizeof(STATIONQUERY)

//=============================================================================
//  QUERYTABLE structure.
//=============================================================================

typedef struct _QUERYTABLE
{
    DWORD           nStationQueries;
    STATIONQUERY    StationQuery[0];
} QUERYTABLE;

typedef QUERYTABLE *LPQUERYTABLE;

#define QUERYTABLE_SIZE sizeof(QUERYTABLE)

//=============================================================================
//  BONEPACKET structure.
//=============================================================================

typedef struct _BONEPACKET
{
    DWORD       Signature;                  //... 'RTSS'
    BYTE        Command;                    //... packet command field.
    BYTE        Flags;                      //... flags.
    DWORD       Reserved;                   //... reserved.
    WORD        Length;                     //... length of data, if any.
} BONEPACKET;

typedef BONEPACKET *LPBONEPACKET;

#define BONEPACKET_SIZE sizeof(BONEPACKET)

//=============================================================================
//  BONE alert packet.
//=============================================================================

typedef struct _ALERT
{
    DWORD           AlertCode;                          //... Alert code.
    BYTE            MachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    BYTE            UserName[USER_NAME_LENGTH];         //... Username name, if any.

    union
    {
        BYTE            Pad[32];                        //... Alert code-specific data.
        DWORD           nFramesToSend;                  //... Transmit alert data.
    };
} ALERT;

typedef ALERT *LPALERT;

#define ALERT_SIZE sizeof(ALERT)

//... Alert codes.

#define ALERT_CODE_BEGIN_TRANSMIT           0

//=============================================================================
//  BONEPACKET signature.
//=============================================================================

#define MAKE_WORD(l, h)         (((WORD) (l)) | (((WORD) (h)) << 8))
#define MAKE_LONG(l, h)         (((DWORD) (l)) | (((DWORD) (h)) << 16L))

#define MAKE_SIG(a, b, c, d)    MAKE_LONG(MAKE_WORD(a, b), MAKE_WORD(c, d))

#define BONE_PACKET_SIGNATURE   MAKE_SIG('R', 'T', 'S', 'S')

//=============================================================================
//  BONEPACKET commands.
//=============================================================================

#define BONE_COMMAND_STATION_QUERY_REQUEST      0
#define BONE_COMMAND_STATION_QUERY_RESPONSE     1
#define BONE_COMMAND_ALERT                      2

//=============================================================================
//  STATISTICS parameter structure return from OpenNetwork().
//=============================================================================

typedef struct _STATISTICSPARAM
{
    DWORD           StatisticsSize;             //... Number of bytes.
    LPSTATISTICS    Statistics;
    DWORD           StatisticsTableEntries;     //... Number of entries.
    LPSTATIONSTATS  StatisticsTable;
    DWORD           SessionTableEntries;        //... Number of entries.
    LPSESSION       SessionTable;
} STATISTICSPARAM;

typedef STATISTICSPARAM *LPSTATISTICSPARAM;

#define STATISTICSPARAM_SIZE    sizeof(STATISTICSPARAM)

//=============================================================================
//  RECONNECTINFO structure.
//=============================================================================

typedef struct _RECONNECTINFO_HEADER
{
    DWORD       Signature;                      //... Application-defined signature.
    WORD        PrivateDataLength;              //... Private data length (max = 64K - header size).
    BYTE        Reserved[26];                   //... Reserved for future use.
} RECONNECTINFO_HEADER;

typedef RECONNECTINFO_HEADER *LPRECONNECTINFO_HEADER;

#define RECONNECTINFO_HEADER_SIZE   sizeof(RECONNECTINFO_HEADER)    //... 32 byte fixed header.

typedef struct _RECONNECTINFO
{
    RECONNECTINFO_HEADER    ReconnectInfoHeader;
    BYTE                    PrivateData[0];
} RECONNECTINFO;

typedef RECONNECTINFO *LPRECONNECTINFO;

#define RECONNECTINFO_SIZE  sizeof(RECONNECTINFO)

//=============================================================================
//  TEMP SetupNetworkID() data struct
//=============================================================================

typedef struct _SETUPNETWORKPARMS
{
    char    Nodename[32];       //... remote node to connect to
    char    Comment[255];       //... comment regarding what we are using remote network for
    int     NetID;              //... which network id to use
    DWORD   Frequency;          //... frequency of Agent status updates
    DWORD   fSlowLink:1;        //... flag to signify slow link
} SETUPNETWORKPARMS;

typedef SETUPNETWORKPARMS *LPSETUPNETWORKPARMS;

#define SETUPNETWORKPARMS_SIZE    sizeof(SETUPNETWORKPARMS)

//=============================================================================
// Constants for SpecialFrame comment insertions
//=============================================================================

#define SPECIAL_FRAME_FLAG_USE_AS_STATS_ENDPOINT      0x00000001

#define SPECIAL_FRAME_TYPE_COMMENT  101
#define SPECIAL_FRAME_TYPE_BOOKMARK 102
#define SPECIAL_FRAME_TYPE_STATS    103
#define SPECIAL_FRAME_TYPE_ODBC     104
#define SPECIAL_FRAME_TYPE_MESSAGE  105

#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nb30.h ===
//*++
//
// Copyright (c) 1991-1999  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
//--*/

#ifndef NCB_INCLUDED
#define NCB_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */
#ifdef _WIN64
    UCHAR   ncb_reserve[18];        /* reserved, used by BIOS         */
#else
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
#endif
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[NCBNAMSZ];
    UCHAR   remote_name[NCBNAMSZ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state

#define LISTEN_OUTSTANDING      0x01
#define CALL_PENDING            0x02
#define SESSION_ESTABLISHED     0x03
#define HANGUP_PENDING          0x04
#define HANGUP_COMPLETE         0x05
#define SESSION_ABORTED         0x06

/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[]
    UCHAR   lana[MAX_LANA+1];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id

#define ALL_TRANSPORTS  "M\0\0\0"
#define MS_NBF          "MNBF"


/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

#define NCBCALL         0x10            /* NCB CALL                           */
#define NCBLISTEN       0x11            /* NCB LISTEN                         */
#define NCBHANGUP       0x12            /* NCB HANG UP                        */
#define NCBSEND         0x14            /* NCB SEND                           */
#define NCBRECV         0x15            /* NCB RECEIVE                        */
#define NCBRECVANY      0x16            /* NCB RECEIVE ANY                    */
#define NCBCHAINSEND    0x17            /* NCB CHAIN SEND                     */
#define NCBDGSEND       0x20            /* NCB SEND DATAGRAM                  */
#define NCBDGRECV       0x21            /* NCB RECEIVE DATAGRAM               */
#define NCBDGSENDBC     0x22            /* NCB SEND BROADCAST DATAGRAM        */
#define NCBDGRECVBC     0x23            /* NCB RECEIVE BROADCAST DATAGRAM     */
#define NCBADDNAME      0x30            /* NCB ADD NAME                       */
#define NCBDELNAME      0x31            /* NCB DELETE NAME                    */
#define NCBRESET        0x32            /* NCB RESET                          */
#define NCBASTAT        0x33            /* NCB ADAPTER STATUS                 */
#define NCBSSTAT        0x34            /* NCB SESSION STATUS                 */
#define NCBCANCEL       0x35            /* NCB CANCEL                         */
#define NCBADDGRNAME    0x36            /* NCB ADD GROUP NAME                 */
#define NCBENUM         0x37            /* NCB ENUMERATE LANA NUMBERS         */
#define NCBUNLINK       0x70            /* NCB UNLINK                         */
#define NCBSENDNA       0x71            /* NCB SEND NO ACK                    */
#define NCBCHAINSENDNA  0x72            /* NCB CHAIN SEND NO ACK              */
#define NCBLANSTALERT   0x73            /* NCB LAN STATUS ALERT               */
#define NCBACTION       0x77            /* NCB ACTION                         */
#define NCBFINDNAME     0x78            /* NCB FIND NAME                      */
#define NCBTRACE        0x79            /* NCB TRACE                          */


#define ASYNCH          0x80            /* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

#define NRC_GOODRET     0x00    /* good return                                */
                                /* also returned when ASYNCH request accepted */
#define NRC_BUFLEN      0x01    /* illegal buffer length                      */
#define NRC_ILLCMD      0x03    /* illegal command                            */
#define NRC_CMDTMO      0x05    /* command timed out                          */
#define NRC_INCOMP      0x06    /* message incomplete, issue another command  */
#define NRC_BADDR       0x07    /* illegal buffer address                     */
#define NRC_SNUMOUT     0x08    /* session number out of range                */
#define NRC_NORES       0x09    /* no resource available                      */
#define NRC_SCLOSED     0x0a    /* session closed                             */
#define NRC_CMDCAN      0x0b    /* command cancelled                          */
#define NRC_DUPNAME     0x0d    /* duplicate name                             */
#define NRC_NAMTFUL     0x0e    /* name table full                            */
#define NRC_ACTSES      0x0f    /* no deletions, name has active sessions     */
#define NRC_LOCTFUL     0x11    /* local session table full                   */
#define NRC_REMTFUL     0x12    /* remote session table full                  */
#define NRC_ILLNN       0x13    /* illegal name number                        */
#define NRC_NOCALL      0x14    /* no callname                                */
#define NRC_NOWILD      0x15    /* cannot put * in NCB_NAME                   */
#define NRC_INUSE       0x16    /* name in use on remote adapter              */
#define NRC_NAMERR      0x17    /* name deleted                               */
#define NRC_SABORT      0x18    /* session ended abnormally                   */
#define NRC_NAMCONF     0x19    /* name conflict detected                     */
#define NRC_IFBUSY      0x21    /* interface busy, IRET before retrying       */
#define NRC_TOOMANY     0x22    /* too many commands outstanding, retry later */
#define NRC_BRIDGE      0x23    /* ncb_lana_num field invalid                 */
#define NRC_CANOCCR     0x24    /* command completed while cancel occurring   */
#define NRC_CANCEL      0x26    /* command not valid to cancel                */
#define NRC_DUPENV      0x30    /* name defined by anther local process       */
#define NRC_ENVNOTDEF   0x34    /* environment undefined. RESET required      */
#define NRC_OSRESNOTAV  0x35    /* required OS resources exhausted            */
#define NRC_MAXAPPS     0x36    /* max number of applications exceeded        */
#define NRC_NOSAPS      0x37    /* no saps available for netbios              */
#define NRC_NORESOURCES 0x38    /* requested resources are not available      */
#define NRC_INVADDRESS  0x39    /* invalid ncb address or length > segment    */
#define NRC_INVDDID     0x3B    /* invalid NCB DDID                           */
#define NRC_LOCKFAIL    0x3C    /* lock of user area failed                   */
#define NRC_OPENERR     0x3f    /* NETBIOS not loaded                         */
#define NRC_SYSTEM      0x40    /* system error                               */

#define NRC_PENDING     0xff    /* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
APIENTRY
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/

#define NCB_POST void CALLBACK

#ifdef __cplusplus
}
#endif

#endif /* NCB_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\neterr.h ===
//=============================================================================
//  Microsoft (R) Bloodhound (tm). Copyright (C) 1991-1992.
//
//  MODULE: neterr.h
//
//  This is the top-level include file for all NETWORK topology error codes
//  Bloodhound driver network error codes -- DO NOT CHANGE!
//=============================================================================

#if !defined(_NETERR_)

#define _NETERR_

//=============================================================================
//  TOKENRING errors
//=============================================================================

#define NETERR_RING_STATUS_SIGNAL_LOST           0x00008000

#define NETERR_RING_STATUS_HARD_ERROR            0x00004000

#define NETERR_RING_STATUS_SOFT_ERROR            0x00002000

#define NETERR_RING_STATUS_TRANSMIT_BEACON       0x00001000

#define NETERR_RING_STATUS_LOBE_WIRE_FAULT       0x00000800

#define NETERR_RING_STATUS_AUTO_REMOVAL_ERROR    0x00000400

#define NETERR_RING_STATUS_REMOTE_RECEIVED       0x00000200

#define NETERR_RING_STATUS_COUNTER_OVERFLOW      0x00000100

#define NETERR_RING_STATUS_SIGNAL_STATION        0x00000080

#define NETERR_RING_STATUS_RECOVERY              0x00000040


//
// The following defines a bit mask to be compared with to see if
// the state of the ring should cause us to stop the current network
// capture.
//
// LobeWireFault, Signal Loss, Remove Received, and Auto Removal are
// currently the ones that fall into this category.
//
#define NETERR_RING_STOP_CAPTURE                 0x00008E00


//=============================================================================
//  ETHERNET errors
//=============================================================================

//=============================================================================
//  FDDI errors
//=============================================================================

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nddeapi.h ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
* Copyright (c) Microsoft Inc. 1995-1999                                *
*               All Rights Reserved.                                    *
************************************************************************/

#ifndef          _INC_NDDEAPI
#define          _INC_NDDEAPI

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif    /* __cplusplus */

#ifndef CNLEN           /* If not included with netapi header */
#define CNLEN           15                  /* Computer name length     */
#define UNCLEN          (CNLEN+2)           /* UNC computer name length */
#endif /* CNLEN */

// the choice of this char affects legal share,topic, etc. names
#define SEP_CHAR    ','
#define BAR_CHAR    "|"
#define SEP_WCHAR   L','
#define BAR_WCHAR   L"|"

/* API error codes  */
#define NDDE_NO_ERROR                   0
#define NDDE_ACCESS_DENIED              1
#define NDDE_BUF_TOO_SMALL              2
#define NDDE_ERROR_MORE_DATA            3
#define NDDE_INVALID_SERVER             4
#define NDDE_INVALID_SHARE              5
#define NDDE_INVALID_PARAMETER          6
#define NDDE_INVALID_LEVEL              7
#define NDDE_INVALID_PASSWORD           8
#define NDDE_INVALID_ITEMNAME           9
#define NDDE_INVALID_TOPIC             10
#define NDDE_INTERNAL_ERROR            11
#define NDDE_OUT_OF_MEMORY             12
#define NDDE_INVALID_APPNAME           13
#define NDDE_NOT_IMPLEMENTED           14
#define NDDE_SHARE_ALREADY_EXIST       15
#define NDDE_SHARE_NOT_EXIST           16
#define NDDE_INVALID_FILENAME          17
#define NDDE_NOT_RUNNING               18
#define NDDE_INVALID_WINDOW            19
#define NDDE_INVALID_SESSION           20
#define NDDE_INVALID_ITEM_LIST         21
#define NDDE_SHARE_DATA_CORRUPTED      22
#define NDDE_REGISTRY_ERROR            23
#define NDDE_CANT_ACCESS_SERVER        24
#define NDDE_INVALID_SPECIAL_COMMAND   25
#define NDDE_INVALID_SECURITY_DESC     26
#define NDDE_TRUST_SHARE_FAIL          27

/* string size constants */
#define MAX_NDDESHARENAME       256
#define MAX_DOMAINNAME          15
#define MAX_USERNAME            15
#define MAX_APPNAME             255
#define MAX_TOPICNAME           255
#define MAX_ITEMNAME            255

/* connectFlags bits for ndde service affix */
#define NDDEF_NOPASSWORDPROMPT  0x0001
#define NDDEF_NOCACHELOOKUP     0x0002
#define NDDEF_STRIP_NDDE        0x0004


/* NDDESHAREINFO - contains information about a NDDE share */

struct NDdeShareInfo_tag {
    LONG                    lRevision;
    LPTSTR                  lpszShareName;
    LONG                    lShareType;
    LPTSTR                  lpszAppTopicList;
    LONG                    fSharedFlag;
    LONG                    fService;
    LONG                    fStartAppFlag;
    LONG                    nCmdShow;
    LONG                    qModifyId[2];
    LONG                    cNumItems;
    LPTSTR                  lpszItemList;
};
typedef struct NDdeShareInfo_tag   NDDESHAREINFO;
typedef struct NDdeShareInfo_tag * PNDDESHAREINFO;

/*  Share Types */
#define SHARE_TYPE_OLD      0x01                // Excel|sheet1.xls
#define SHARE_TYPE_NEW      0x02                // ExcelWorksheet|sheet1.xls
#define SHARE_TYPE_STATIC   0x04                // ClipSrv|SalesData

/*
    Add new share
*/
UINT WINAPI
NDdeShareAddA (
    LPSTR                   lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);

UINT WINAPI
NDdeShareAddW (
    LPWSTR                  lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);

/*
    Delete a share
*/
UINT WINAPI
NDdeShareDelA (
    LPSTR   lpszServer,     // server to execute on ( must be NULL )
    LPSTR   lpszShareName,  // name of share to delete
    UINT    wReserved       // reserved for force level (?) 0 for now
);

UINT WINAPI
NDdeShareDelW (
    LPWSTR  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,  // name of share to delete
    UINT    wReserved       // reserved for force level (?) 0 for now
);

/*
    Get Share Security Descriptor
*/

UINT WINAPI
NDdeGetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on ( must be NULL )
    LPSTR                   lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);

UINT WINAPI
NDdeGetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR                  lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);

/*
    Set Share Security Descriptor
*/

UINT WINAPI
NDdeSetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on ( must be NULL )
    LPSTR                   lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);

UINT WINAPI
NDdeSetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR                  lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);

/*
    Enumerate shares
*/
UINT WINAPI
NDdeShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

UINT WINAPI
NDdeShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

/*
    Get information on a share
*/
UINT WINAPI
NDdeShareGetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);

UINT WINAPI
NDdeShareGetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);

/*
    Modify DDE share data
*/
UINT WINAPI
NDdeShareSetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);

UINT WINAPI
NDdeShareSetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);

/*
    Set/Create a trusted share
*/

UINT WINAPI
NDdeSetTrustedShareA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);

UINT WINAPI
NDdeSetTrustedShareW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);

                                            /*  Trusted share options       */
#define NDDE_TRUST_SHARE_START  0x80000000L     // Start App Allowed
#define NDDE_TRUST_SHARE_INIT   0x40000000L     // Init Conv Allowed
#define NDDE_TRUST_SHARE_DEL    0x20000000L     // Delete Trusted Share (on set)
#define NDDE_TRUST_CMD_SHOW     0x10000000L     // Use supplied cmd show
#define NDDE_CMD_SHOW_MASK      0x0000FFFFL     // Command Show mask

/*
    Get a trusted share options
*/

UINT WINAPI
NDdeGetTrustedShareA (
    LPSTR       lpszServer,         // server to execute on ( must be NULL )
    LPSTR       lpszShareName,      // name of share to query
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);

UINT WINAPI
NDdeGetTrustedShareW (
    LPWSTR      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR      lpszShareName,      // name of share to query
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);


/*
    Enumerate trusted shares
*/
UINT WINAPI
NDdeTrustedShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

UINT WINAPI
NDdeTrustedShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

/*
    Convert error code to string value
*/
UINT WINAPI
NDdeGetErrorStringA (
    UINT    uErrorCode,         // Error code to get string for
    LPSTR   lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);

UINT WINAPI
NDdeGetErrorStringW (
    UINT    uErrorCode,         // Error code to get string for
    LPWSTR  lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);

/*
    Validate share name format
*/
BOOL WINAPI
NDdeIsValidShareNameA (
    LPSTR shareName
);

BOOL WINAPI
NDdeIsValidShareNameW (
    LPWSTR shareName
);

/*
    Validate application/topic list format
*/
BOOL WINAPI
NDdeIsValidAppTopicListA (
    LPSTR targetTopic
);

BOOL WINAPI
NDdeIsValidAppTopicListW (
    LPWSTR targetTopic
);

#ifdef UNICODE
#define NDdeShareAdd            NDdeShareAddW
#define NDdeShareDel            NDdeShareDelW
#define NDdeSetShareSecurity    NDdeSetShareSecurityW
#define NDdeGetShareSecurity    NDdeGetShareSecurityW
#define NDdeShareEnum           NDdeShareEnumW
#define NDdeShareGetInfo        NDdeShareGetInfoW
#define NDdeShareSetInfo        NDdeShareSetInfoW
#define NDdeGetErrorString      NDdeGetErrorStringW
#define NDdeIsValidShareName    NDdeIsValidShareNameW
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListW
#define NDdeSetTrustedShare     NDdeSetTrustedShareW
#define NDdeGetTrustedShare     NDdeGetTrustedShareW
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumW
#else
#define NDdeShareAdd            NDdeShareAddA
#define NDdeShareDel            NDdeShareDelA
#define NDdeSetShareSecurity    NDdeSetShareSecurityA
#define NDdeGetShareSecurity    NDdeGetShareSecurityA
#define NDdeShareEnum           NDdeShareEnumA
#define NDdeShareGetInfo        NDdeShareGetInfoA
#define NDdeShareSetInfo        NDdeShareSetInfoA
#define NDdeGetErrorString      NDdeGetErrorStringA
#define NDdeIsValidShareName    NDdeIsValidShareNameA
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListA
#define NDdeSetTrustedShare     NDdeSetTrustedShareA
#define NDdeGetTrustedShare     NDdeGetTrustedShareA
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumA
#endif

#ifdef __cplusplus
}
#endif    /* __cplusplus */

#include <poppack.h>

#endif  /* _INC_NDDEAPI */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\network.h ===
/***********************************************************************
**      N E T W O R K . H         		                               *
**                                                                     *
************************************************************************
** Copyright (C) 1996 by Microsoft Corporation                         *
**                 All Rights Reserved                                 *
************************************************************************/
/*
        NETWORK.H

        Network record object class definitions for Microsoft Guide
*/


#ifndef _NETWORK_H_
#define _NETWORK_H_


/*

Network objects are constructed from database records of the Network table.

The CNetworkRecordset class is used to select and create Network objects
from the Network table via functions in the CDatabaseRecordset parent class.

*/


#include "dbsets.h"


class COMMMSTVEXPORT CNetworkRecordset : public CDatabaseRecordset
{
// This class provides Channel recordset manipulation via parent functions

virtual CString GetTableName( VOID);

virtual BOOL    SetRecordsetObject( VOID* cRecordsetObject);

public:
virtual VOID*   GetRecordsetObject( VOID);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, CObject &coo);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, LONG lNetworkID);
};


class COMMMSTVEXPORT CNetwork : public CObject
{
    friend class CNetworkRecordset; // generates the CNetwork record object

protected:

	long m_lNetworkID;
	CString m_cszName;
	CString m_cszLogoMoniker;
		
public:

	CNetwork(long lNetworkID = AFX_RFX_LONG_PSEUDO_NULL,
				CString cszName = "",
				CString cszLogoMoniker = "") :
				m_lNetworkID(lNetworkID),
				m_cszName(cszName),
				m_cszLogoMoniker(cszLogoMoniker) { }
	~CNetwork() { }

    void SetName( LPCTSTR szName ) { m_cszName = szName; }
    void SetLogoMoniker( LPCTSTR szLogoMoniker ) { m_cszLogoMoniker = szLogoMoniker; }
    
	long NetworkID() { return m_lNetworkID; }
	CString Name() { return m_cszName; }
	CString LogoMoniker() { return m_cszLogoMoniker; }
};


// Table: Network

#define  TBL_Network  _T("Network")

#define FLD_Network_NetworkID		_T("N Network ID")
#define FLD_Network_Name			_T("N Name")
#define FLD_Network_LogoMoniker		_T("N LogoMoniker")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\NetSh.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    netsh.h

Abstract:
    This file contains definitions which are needed by all NetSh helper DLLs.

--*/

#ifndef _NETSH_H_
#define _NETSH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Error codes
//

#define NETSH_ERROR_BASE                        15000
#define ERROR_NO_ENTRIES                        (NETSH_ERROR_BASE + 0)
#define ERROR_INVALID_SYNTAX                    (NETSH_ERROR_BASE + 1)
#define ERROR_PROTOCOL_NOT_IN_TRANSPORT         (NETSH_ERROR_BASE + 2)
#define ERROR_NO_CHANGE                         (NETSH_ERROR_BASE + 3)
#define ERROR_CMD_NOT_FOUND                     (NETSH_ERROR_BASE + 4)
#define ERROR_ENTRY_PT_NOT_FOUND                (NETSH_ERROR_BASE + 5)
#define ERROR_DLL_LOAD_FAILED                   (NETSH_ERROR_BASE + 6)
#define ERROR_INIT_DISPLAY                      (NETSH_ERROR_BASE + 7)
#define ERROR_TAG_ALREADY_PRESENT               (NETSH_ERROR_BASE + 8)
#define ERROR_INVALID_OPTION_TAG                (NETSH_ERROR_BASE + 9)
#define ERROR_NO_TAG                            (NETSH_ERROR_BASE + 10)
#define ERROR_MISSING_OPTION                    (NETSH_ERROR_BASE + 11)
#define ERROR_TRANSPORT_NOT_PRESENT             (NETSH_ERROR_BASE + 12)
#define ERROR_SHOW_USAGE                        (NETSH_ERROR_BASE + 13)
#define ERROR_INVALID_OPTION_VALUE              (NETSH_ERROR_BASE + 14)
#define ERROR_OKAY                              (NETSH_ERROR_BASE + 15)
#define ERROR_CONTINUE_IN_PARENT_CONTEXT        (NETSH_ERROR_BASE + 16)
#define ERROR_SUPPRESS_OUTPUT                   (NETSH_ERROR_BASE + 17)

#define NETSH_ERROR_END                ERROR_SUPPRESS_OUTPUT

// Mode change values

#define NETSH_COMMIT                    0
#define NETSH_UNCOMMIT                  1
#define NETSH_FLUSH                     2
#define NETSH_COMMIT_STATE              3
#define NETSH_SAVE                      4

#define ERROR_CONTEXT_SWITCH            0x55aa
#define ERROR_CONNECT_REMOTE_CONFIG     (ERROR_CONTEXT_SWITCH + 1)

#define MAX_NAME_LEN                    MAX_DLL_NAME

#define NETSH_VERSION_50                0x0005000

#define NETSH_ARG_DELIMITER             L"="
#define NETSH_CMD_DELIMITER             L" "

#define NETSH_MAX_TOKEN_LENGTH          64
#define NETSH_MAX_CMD_TOKEN_LENGTH      128

#define NETSH_ROOT_GUID { 0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } }


typedef
DWORD
(WINAPI NS_CONTEXT_COMMIT_FN)(
    IN  DWORD       dwAction
    );

typedef NS_CONTEXT_COMMIT_FN *PNS_CONTEXT_COMMIT_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_ENTRY_FN)(
    IN  PWCHAR      pwszMachine,
    IN  WCHAR       **ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  DWORD       dwFlags,
    IN  PVOID       pvData,
    OUT PWCHAR      pwcNewContext
    );

typedef NS_CONTEXT_ENTRY_FN *PNS_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_CONNECT_FN)(
    IN  PWCHAR      pwszMachine
    );

typedef NS_CONTEXT_CONNECT_FN *PNS_CONTEXT_CONNECT_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_SUBENTRY_FN)(
    IN  PVOID                     pSubContext,
    IN  PWCHAR                    pwszMachine,
    IN  WCHAR                     **ppwcArguments,
    IN  DWORD                     dwArgCount,
    IN  DWORD                     dwFlags,
    IN  PVOID                     pvData,
    OUT PWCHAR                    pwcNewContext
    );

typedef NS_CONTEXT_SUBENTRY_FN *PNS_CONTEXT_SUBENTRY_FN;

typedef
DWORD
(WINAPI *PNS_CONTEXT_UNINIT_FN)(
    IN  DWORD   dwReserved
    );

typedef
DWORD
(WINAPI NS_CONTEXT_DUMP_FN)(
    IN  PWCHAR      pwszRouter,
    IN  WCHAR       **ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  PVOID       pvData
    );

typedef NS_CONTEXT_DUMP_FN *PNS_CONTEXT_DUMP_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_HELP_FN)(
    IN  PWCHAR      pwszGroup,
    IN  DWORD       dwCmdFlags
    );

typedef NS_CONTEXT_HELP_FN *PNS_CONTEXT_HELP_FN;

typedef
DWORD
(WINAPI NS_DLL_STOP_FN)(
    IN  DWORD       dwReserved
    );

typedef NS_DLL_STOP_FN *PNS_DLL_STOP_FN;

typedef
DWORD
(WINAPI NS_HELPER_START_FN)(
    IN  CONST GUID *pguidParent,
    IN  PVOID       pfnRegisterContext,
    IN  DWORD       dwVersion
    );

typedef NS_HELPER_START_FN *PNS_HELPER_START_FN;

typedef
DWORD
(WINAPI NS_HELPER_STOP_FN)(
    IN  DWORD       dwReserved
    );

typedef NS_HELPER_STOP_FN *PNS_HELPER_STOP_FN;

typedef
DWORD
(WINAPI NS_DEREG_ALL_CONTEXTS_FN)(
    IN  CONST GUID *pguidChild
    );

typedef NS_DEREG_ALL_CONTEXTS_FN *PNS_DEREG_ALL_CONTEXTS_FN;

typedef
DWORD
(WINAPI NS_DISPLAY_PARENT_HELP)(
    IN  PWCHAR  pwszGroup,
    IN  DWORD   dwCmdFlags
    );

typedef NS_DISPLAY_PARENT_HELP *PNS_DISPLAY_PARENT_HELP;

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

typedef struct _NS_DLL_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };

        ULONGLONG       _ullAlign;
    };

    PNS_DLL_STOP_FN     pfnStopFn;

}NS_DLL_ATTRIBUTES, *PNS_DLL_ATTRIBUTES;

typedef struct _NS_HELPER_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };

        ULONGLONG       _ullAlign;
    };

    //
    // GUID associated with the helper
    //

    GUID                      guidHelper;

    //
    // Function to start this helper
    //

    PNS_HELPER_START_FN       pfnStart;

    //
    // Function to stop this helper
    //

    PNS_HELPER_STOP_FN        pfnStop;

    //
    // Function (if any) to use to register sub-contexts
    //

    PVOID                     pfnRegisterContext;


    PNS_DEREG_ALL_CONTEXTS_FN pfnDeregisterAllContexts;

}NS_HELPER_ATTRIBUTES, *PNS_HELPER_ATTRIBUTES;

typedef struct _NS_BASE_CONTEXT_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };

        ULONGLONG       _ullAlign;
    };

    //
    // Name of the context
    //

    PWCHAR                   pwszContext;

    // GUID of the helper servicing this context

    GUID                     guidHelper;

    //
    // Flags limiting when context is available.
    // See CMD_FLAG_xxx in netsh.h.
    //

    DWORD                    dwFlags;

    // Priority field is only relevant if CMD_FLAG_PRIORITY is set in dwFlags

    ULONG                    ulPriority;

    // Number of top-level commands

    ULONG                    ulNumTopCmds; 

    // Array of top-level commands

    struct _CMD_ENTRY        (*pTopCmds)[];

    // Number of command groups

    ULONG                    ulNumGroups;

    // Array of command groups

    struct _CMD_GROUP_ENTRY  (*pCmdGroups)[];

    // Function to display parent help

    PNS_DISPLAY_PARENT_HELP  pfnDisplayParentHelp;

}NS_BASE_CONTEXT_ATTRIBUTES, *PNS_BASE_CONTEXT_ATTRIBUTES;

//
// This structure is a generic version of the attributes
// structure for a context.  Typically, a helper which
// supports subcontexts will define its own context attributes
// structure which is the same form as this structure except
// that the types of the functions may vary.  See the
// attributes structures in ipmontr.h and ipxmontr.h as examples.
//

typedef struct _NS_CONTEXT_ATTRIBUTES
{
#ifdef __cplusplus
    NS_BASE_CONTEXT_ATTRIBUTES bca;
#else
    NS_BASE_CONTEXT_ATTRIBUTES;
#endif

    PNS_CONTEXT_ENTRY_FN     pfnEntryFn;
    PNS_CONTEXT_COMMIT_FN    pfnCommitFn;
    PNS_CONTEXT_DUMP_FN      pfnDumpFn;
    PNS_CONTEXT_CONNECT_FN   pfnConnectFn;
    PNS_CONTEXT_SUBENTRY_FN  pfnSubEntryFn;
    PNS_CONTEXT_HELP_FN      pfnHelpFn;

}NS_CONTEXT_ATTRIBUTES, *PNS_CONTEXT_ATTRIBUTES;

#define DEFAULT_CONTEXT_PRIORITY 100

typedef
DWORD
(WINAPI *PNS_IF_NAME_MAPPER)(
    IN  HANDLE hMprConfig,
    IN  PWCHAR pwszName,
    OUT PWCHAR pwszBuffer,
    IN  PDWORD pdwBufSize
    );

typedef
BOOL
(WINAPI *PNS_MATCH_CMD_LINE)(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  LPCWSTR pwszCmdToken,
    OUT PDWORD  pdwNumMatched
    );

typedef
BOOL
(WINAPI *PNS_MATCH_TOKEN)(
    IN  PWCHAR  pwszUserToken,
    IN  LPCWSTR pwszCmdToken
    );



typedef struct _TOKEN_VALUE
{
    PWCHAR  pwszToken; // literal token string
    DWORD   dwValue;   // ID of info string

}TOKEN_VALUE, *PTOKEN_VALUE;

#define NUM_TOKENS_IN_TABLE(TokenArray) \
    sizeof(TokenArray)/sizeof(TOKEN_VALUE)

typedef struct _VALUE_TOKEN
{
    DWORD   dwValue;
    PWCHAR  pwszToken;

}VALUE_TOKEN, *PVALUE_TOKEN;

typedef struct _VALUE_STRING
{
    DWORD   dwValue;
    DWORD   dwStringId;

}VALUE_STRING, *PVALUE_STRING;
#define NUM_VALUES_IN_TABLE(TokenArray) \
    sizeof(TokenArray)/sizeof(VALUE_STRING)


typedef
DWORD
(WINAPI *PNS_MATCH_ENUM_TAG)(
    IN  HANDLE      hModule,
    IN  PWCHAR      pwcArg,
    IN  DWORD       dwNumArg,
    IN  PTOKEN_VALUE pEnumTable,
    OUT PDWORD      pdwValue
    );

typedef
DWORD
(WINAPI *PNS_GET_DISPLAY_STRING)(
    IN  HANDLE      hModule,
    IN  DWORD       dwValue,
    IN  PTOKEN_VALUE pEnumTable,
    IN  DWORD       dwNumArgs,
    OUT PWCHAR      ptszString
    );


#define NS_REQ_PRESENT        0x01
#define NS_REQ_ALLOW_MULTIPLE 0x02
#define NS_REQ_ZERO         0
#define NS_REQ_ONE          1
#define NS_REQ_ZERO_OR_MORE 2
#define NS_REQ_ONE_OR_MORE  3

typedef struct _TAG_TYPE
{
    PWCHAR   pwszTag;       // tag string
    DWORD    dwRequired;    // required or not
    BOOL     bPresent;      // present or not
}TAG_TYPE, *PTAG_TYPE;

typedef
DWORD
(WINAPI *PNS_MATCH_TAGS_IN_CMD_LINE)(
    IN  HANDLE      hModule,
    IN  PWCHAR      *ppwcArguments,
    IN  DWORD       dwCurrentIndex,
    IN  DWORD       dwArgCount,
    IN  PTAG_TYPE   pEnumTable,
    IN  DWORD       dwNumTags,
    OUT PDWORD      pdwOut
    );

#define NUM_TAGS_IN_TABLE(TagsArray) \
    sizeof(TagsArray)/sizeof(TAG_TYPE)

typedef
DWORD
(WINAPI *PNS_PREPROCESS_COMMAND)(
    IN  HANDLE    hModule,
    IN  PWCHAR   *ppwcArguments,
    IN  DWORD     dwCurrentIndex,
    IN  DWORD     dwArgCount,

    IN  TAG_TYPE *pttTags,
    IN  DWORD     dwTagCount,
    IN  DWORD     dwMinArgs,
    IN  DWORD     dwMaxArgs,
    OUT DWORD    *pdwTagType
    );


typedef
PWCHAR
(WINAPI *PNS_GET_ENUM_STRING)(
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  DWORD           dwNumVal,
    IN  PTOKEN_VALUE    pEnumTable
    );

typedef
PWCHAR
(WINAPI *PNS_MAKE_STRING)(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId
    );

typedef
VOID
(WINAPI *PNS_FREE_STRING)(
    IN  PWCHAR  pwszMadeString
    );

typedef
PWCHAR
(WINAPI *PNS_MAKE_QUOTED_STRING)(
    IN  PWCHAR  pwszString
    );

typedef
VOID
(WINAPI *PNS_FREE_QUOTED_STRING)(
    IN  PWCHAR  pwszMadeString
    );

typedef
VOID
(*PNS_DISPLAY_ERR)(
    IN  HANDLE  hModule, OPTIONAL
    IN  DWORD   dwErrId,
    ...
    );

typedef
DWORD
(*PNS_DISPLAY_MSG)(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

typedef PNS_DISPLAY_MSG PNS_DISPLAY_MSG_M;

typedef
DWORD
(*PNS_DISPLAY_MSG_T)(
    IN  PWCHAR  pwszFormat,
    ...
    );

typedef
BOOL
(WINAPI *PNS_INIT_CONSOLE)(
    IN    OUT    PDWORD    pdwRR,
    OUT          HANDLE    *phMib,
    OUT          HANDLE    *phConsole
    );

typedef
DWORD
(*PNS_DISPLAY_MSG_CONSOLE)(
    IN  HANDLE  hModule,
    IN  HANDLE  hConsole,
    IN  DWORD   dwMsgId,
    ...
    );

typedef
DWORD
(WINAPI *PNS_REFRESH_CONSOLE)(
    IN    HANDLE    hMib,
    IN    HANDLE    hConsole,
    IN    DWORD     dwRR
    );

typedef
DWORD
(WINAPI *PNS_REGISTER_HELPER)(
    IN    CONST GUID           *pguidParentContext,
    IN    PVOID                 pfnRegisterSubContext
    );

typedef
DWORD
(WINAPI *PNS_GET_HELPER_ENTRY)(
    IN    CONST GUID                     *pGuid,
    OUT   struct _NS_HELPER_TABLE_ENTRY **ppHelper
    );

typedef
VOID
(WINAPI *PNS_CONVERT_GUID_TO_STRING)(
    IN    CONST GUID *pGuid,
    OUT   PWCHAR      pwszBuffer
    );

typedef
DWORD
(WINAPI *PNS_CONVERT_STRING_TO_GUID)(
    IN  PWCHAR  pwszGuid,
    IN  USHORT  usStringLen,
    OUT GUID    *pGuid
    );

typedef
DWORD
(WINAPI NS_PROCESS_HELPER_CMD)(
    IN     DWORD     dwArgCount,
    IN     PWCHAR   *argv,
    IN     DWORD     dwFlags,
//  IN OUT PWCHAR   *ppwszNewContext,
    OUT    BOOL     *pbDone
    );

typedef NS_PROCESS_HELPER_CMD *PNS_PROCESS_HELPER_CMD;

typedef
BOOL
(WINAPI *PNS_EVENT_FILTER)(
    IN  EVENTLOGRECORD  *pRecord,
    IN  PWCHAR          pwszLogName,
    IN  PWCHAR          pwszComponent,
    IN  PWCHAR          pwszSubComponent,
    IN  PVOID           pvFilterContext
    );
    
typedef
DWORD
(WINAPI *PNS_PRINT_EVENTLOG)(
    IN  PWCHAR              pwszLogName,
    IN  PWCHAR              pwszComponent,
    IN  PWCHAR              pwszSubComponent, OPTIONAL
    IN  DWORD               fFlags,
    IN  PVOID               pvHistoryInfo,
    IN  PNS_EVENT_FILTER    pfnEventFilter, OPTIONAL
    IN  PVOID               pvFilterContext
    );

#define NS_GET_EVENT_IDS_FN_NAME    "GetEventIds"

#define NS_EVENT_LOOP       0x00010000
#define NS_EVENT_LAST_N     0x00000001
#define NS_EVENT_LAST_SECS  0x00000002
#define NS_EVENT_FROM_N     0x00000004
#define NS_EVENT_FROM_START 0x00000008

typedef
DWORD
(WINAPI *PNS_GET_EVENT_IDS_FN)(
    IN  PWCHAR  pwszComponent,
    IN  PWCHAR  pwszSubComponent,
    OUT PDWORD  pdwEventIds,
    OUT PULONG  pulEventCount
    );


#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

typedef DWORD (FN_HANDLE_CMD)(
    PWCHAR    pwszMachine,
    PWCHAR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL     *pbDone
    );

typedef FN_HANDLE_CMD *PFN_HANDLE_CMD;

#define CMD_FLAG_PRIVATE     0x01 // not valid in sub-contexts
#define CMD_FLAG_INTERACTIVE 0x02 // not valid from outside netsh
#define CMD_FLAG_IMMEDIATE   0x04 // not valid from ancestor contexts
#define CMD_FLAG_LOCAL       0x08 // not valid from a remote machine
#define CMD_FLAG_ONLINE      0x10 // not valid in offline/non-commit mode

#define CMD_FLAG_LIMIT_MASK 0xffff

#define CMD_FLAG_PRIORITY   0x80000000 // ulPriority field is used

typedef struct _CMD_ENTRY
{
    //
    // The token for the command
    //

    LPCWSTR             pwszCmdToken;

    //
    // The function which handles this command
    //

    PFN_HANDLE_CMD      pfnCmdHandler;

    //
    // The short help message
    //

    DWORD               dwShortCmdHelpToken;

    //
    // The message to display if the only thing after the command is a
    // help token (HELP, /?, -?, ?)
    //

    DWORD               dwCmdHlpToken;

    // Flags (see CMD_FLAGS_xxx above)

    DWORD               dwFlags;

}CMD_ENTRY, *PCMD_ENTRY;

#define CREATE_CMD_ENTRY(t,f)   {CMD_##t, f, HLP_##t, HLP_##t##_EX, CMD_FLAG_PRIVATE}
#define CREATE_CMD_ENTRY_EX(t,f,i) {CMD_##t, f, HLP_##t, HLP_##t##_EX, i}

typedef struct _CMD_GROUP_ENTRY
{
    //
    // The token for the command verb
    //

    const PWCHAR    pwszCmdGroupToken;

    //
    // The message to display in a command listing.
    //

    DWORD           dwShortCmdHelpToken;

    //
    // The number of entries in the cmd table
    //

    ULONG           ulCmdGroupSize;

    // Flags (see CMD_FLAG_xxx)

    DWORD           dwFlags;

    //
    // The command table
    //

    PCMD_ENTRY      pCmdGroup;

}CMD_GROUP_ENTRY, *PCMD_GROUP_ENTRY;

#define CREATE_CMD_GROUP_ENTRY(t,s)     {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), 0, s }
#define CREATE_CMD_GROUP_ENTRY_EX(t,s,i)     {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), i, s }

typedef
DWORD
(WINAPI *PNS_EXECUTE_HANDLER)(
    IN  HANDLE     hModule,
    IN  PCMD_ENTRY pCmdEntry,
    IN  PWCHAR    *argv,
    IN  DWORD      dwNumMatched,
    IN  DWORD      dwArgCount,
    IN  DWORD      dwFlags,
    IN  PVOID      pvData,
    OUT BOOL      *pbDone
    );

typedef
CONST PWCHAR
(WINAPI *PNS_GET_CURRENT_CONTEXT)(VOID);

typedef
DWORD
(WINAPI NS_DISPLAY_HELP)(
    IN  CONST GUID                *pguidHelper,
    IN  PWCHAR                     pwszContext,
    IN  DWORD                      dwDisplayFlags,
    IN  DWORD                      dwCmdFlags,
    IN  DWORD                      dwArgsRemaining,
    IN  PWCHAR                     pwszGroup
    );

typedef NS_DISPLAY_HELP *PNS_DISPLAY_HELP;

typedef
DWORD
(WINAPI NS_UPDATE_NEW_CONTEXT)(
    IN PWCHAR  ppwszBuffer,
    IN PWCHAR  pwszNewToken,
    IN DWORD   dwArgs
    );

typedef NS_UPDATE_NEW_CONTEXT *PNS_UPDATE_NEW_CONTEXT;

typedef
DWORD
(WINAPI NS_GENERIC_ENTRY_FN)(
    IN    PNS_CONTEXT_ATTRIBUTES         pContext,
    IN    PWCHAR                         pwszMachine,
    IN    PWCHAR                         *ppwcArguments,
    IN    DWORD                          dwArgCount,
    IN    DWORD                          dwFlags,
    IN    PVOID                          pvData,
    OUT   PWCHAR                         pwcNewContext
    );

typedef NS_GENERIC_ENTRY_FN   *PNS_GENERIC_ENTRY_FN;

typedef struct _NETSH_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };

        ULONGLONG       _ulAlign;
    };

    PNS_IF_NAME_MAPPER      pfnGetFriendlyNameFromIfName;
    PNS_IF_NAME_MAPPER      pfnGetIfNameFromFriendlyName;
    PNS_MATCH_CMD_LINE      pfnMatchCmdLine;
    PNS_MATCH_TOKEN         pfnMatchToken;
    PNS_MATCH_ENUM_TAG      pfnMatchEnumTag;
    PNS_MATCH_TAGS_IN_CMD_LINE     pfnMatchTagsInCmdLine;
    PNS_GET_ENUM_STRING     pfnGetEnumString;
    PNS_MAKE_STRING         pfnMakeString;
    PNS_FREE_STRING         pfnFreeString;

    PNS_MAKE_QUOTED_STRING  pfnMakeQuotedString;
    PNS_FREE_QUOTED_STRING  pfnFreeQuotedString;
    PNS_DISPLAY_ERR         pfnDisplayError;
    PNS_DISPLAY_MSG         pfnDisplayMessage;
    PNS_INIT_CONSOLE        pfnInitializeConsole;
    PNS_DISPLAY_MSG_CONSOLE pfnDisplayMessageToConsole;
    PNS_REFRESH_CONSOLE     pfnRefreshConsole;
    PNS_PROCESS_HELPER_CMD  pfnProcessHelperCommand;
    PNS_REGISTER_HELPER     pfnRegisterHelper;
    PNS_GET_HELPER_ENTRY    pfnGetHelperEntry;
    PNS_DISPLAY_MSG_M       pfnDisplayMessageM;
    PNS_CONVERT_GUID_TO_STRING  pfnConvertGuidToString;
    PNS_CONVERT_STRING_TO_GUID  pfnConvertStringToGuid;
    PNS_DISPLAY_MSG_T       pfnDisplayMessageT;
    PNS_EXECUTE_HANDLER     pfnExecuteHandler;
    PNS_DISPLAY_HELP        pfnDisplayHelp;
    PNS_UPDATE_NEW_CONTEXT  pfnUpdateNewContext;
    PNS_PREPROCESS_COMMAND  pfnPreprocessCommand;
    PNS_PRINT_EVENTLOG      pfnPrintEventLog;
    PNS_DISPLAY_PARENT_HELP pfnDisplayRootHelp;
    PNS_GENERIC_ENTRY_FN    pfnGenericEntry;

}NETSH_ATTRIBUTES, *PNETSH_ATTRIBUTES;

typedef
DWORD
(NS_DLL_INIT_FN)(
    IN  PNETSH_ATTRIBUTES           pUtilityTable,
    OUT PNS_DLL_ATTRIBUTES          pDllTable
    );

typedef NS_DLL_INIT_FN *PNS_DLL_INIT_FN;

typedef
DWORD
(WINAPI *PNS_HELPER_INIT_FN)(
    IN  PWCHAR                      pwszRouter,
    IN  PNETSH_ATTRIBUTES           pUtilityTable,
    OUT PNS_HELPER_ATTRIBUTES       pHelperTable
    );

typedef
DWORD
(WINAPI *PNS_REGISTER_CONTEXT)(
    IN    PNS_CONTEXT_ATTRIBUTES  pAttributes
    );

#ifdef __cplusplus
}
#endif

#endif // _NETSH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\netmon.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for netmon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netmon_h__
#define __netmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDelaydC_FWD_DEFINED__
#define __IDelaydC_FWD_DEFINED__
typedef interface IDelaydC IDelaydC;
#endif 	/* __IDelaydC_FWD_DEFINED__ */


#ifndef __IESP_FWD_DEFINED__
#define __IESP_FWD_DEFINED__
typedef interface IESP IESP;
#endif 	/* __IESP_FWD_DEFINED__ */


#ifndef __IRTC_FWD_DEFINED__
#define __IRTC_FWD_DEFINED__
typedef interface IRTC IRTC;
#endif 	/* __IRTC_FWD_DEFINED__ */


#ifndef __IStats_FWD_DEFINED__
#define __IStats_FWD_DEFINED__
typedef interface IStats IStats;
#endif 	/* __IStats_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_netmon_0000 */
/* [local] */ 

//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-2000. All rights reserved.
//
//  MODULE: netmon.h
//
//  This is the consolidated include file for all Network Monitor components.
//
//  It contains the contents of these files from previous SDKs:
//
//      NPPTypes.h
//      NMEvent.h       (previously Event.h)
//      NMmcs.h         (previously mcs.h)
//      NMmonitor.h     (previously monitor.h)
//      Finder.h
//      NMSupp.h
//      BHTypes.h
//      NMErr.h
//      BHFilter.h
//      Frame.h
//      Parser.h
//      IniLib.h
//      NMExpert.h      (previously Expert.h)
//      Netmon.h        (previously bh.h)
//      NMBlob.h        (previously blob.h)
//      NMRegHelp.h     (previously reghelp.h)
//      NMIpStructs.h   (previously IpStructs.h)
//      NMIcmpStructs.h (previously IcmpStructs.h)
//      NMIpxStructs.h  (previously IpxStructs.h)
//      NMTcpStructs.h  (previously TcpStructs.h)
//
//      IDelaydC.idl
//      IESP.idl
//      IRTC.idl
//      IStats.idl
//
//=============================================================================
#include <winerror.h>

#pragma pack(1)
// For backward compatability with old SDK versions, all structures within this header
// file will be byte packed on x86 platforms. All other platforms will only have those
// structures that will be used to decode network data packed.
#ifdef _X86_
#pragma pack(1)
#else
#pragma pack()
#endif

// yes we know that many of our structures have:
// warning C4200: nonstandard extension used : zero-sized array in struct/union
// this is OK and intended
#pragma warning(disable:4200)
//=============================================================================
//=============================================================================
//  (NPPTypes.h)
//=============================================================================
//=============================================================================
typedef BYTE *LPBYTE;

typedef const void *HBLOB;

//=============================================================================
// General constants.
//=============================================================================
#define	MAC_TYPE_UNKNOWN	( 0 )

#define	MAC_TYPE_ETHERNET	( 1 )

#define	MAC_TYPE_TOKENRING	( 2 )

#define	MAC_TYPE_FDDI	( 3 )

#define	MAC_TYPE_ATM	( 4 )

#define	MAC_TYPE_1394	( 5 )

#define	MACHINE_NAME_LENGTH	( 16 )

#define	USER_NAME_LENGTH	( 32 )

#define	ADAPTER_COMMENT_LENGTH	( 32 )

#define	CONNECTION_FLAGS_WANT_CONVERSATION_STATS	( 0x1 )

//=============================================================================
//  Handle to a network
//=============================================================================
typedef DWORD HNETWORK;

//=============================================================================
//  Transmit statistics structure.
//=============================================================================
typedef struct _TRANSMITSTATS
    {
    DWORD TotalFramesSent;
    DWORD TotalBytesSent;
    DWORD TotalTransmitErrors;
    } 	TRANSMITSTATS;

typedef TRANSMITSTATS *LPTRANSMITSTATS;

#define	TRANSMITSTATS_SIZE	( sizeof( TRANSMITSTATS  ) )

//=============================================================================
//  Statistics structure.
//=============================================================================
typedef struct _STATISTICS
    {
    __int64 TimeElapsed;
    DWORD TotalFramesCaptured;
    DWORD TotalBytesCaptured;
    DWORD TotalFramesFiltered;
    DWORD TotalBytesFiltered;
    DWORD TotalMulticastsFiltered;
    DWORD TotalBroadcastsFiltered;
    DWORD TotalFramesSeen;
    DWORD TotalBytesSeen;
    DWORD TotalMulticastsReceived;
    DWORD TotalBroadcastsReceived;
    DWORD TotalFramesDropped;
    DWORD TotalFramesDroppedFromBuffer;
    DWORD MacFramesReceived;
    DWORD MacCRCErrors;
    __int64 MacBytesReceivedEx;
    DWORD MacFramesDropped_NoBuffers;
    DWORD MacMulticastsReceived;
    DWORD MacBroadcastsReceived;
    DWORD MacFramesDropped_HwError;
    } 	STATISTICS;

typedef STATISTICS *LPSTATISTICS;

#define	STATISTICS_SIZE	( sizeof( STATISTICS  ) )

//=============================================================================
//  Address structures
//=============================================================================

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)
#define	MAX_NAME_SIZE	( 32 )

#define	IP_ADDRESS_SIZE	( 4 )

#define	MAC_ADDRESS_SIZE	( 6 )

// Q: What is the maximum address size that we could have to copy?
// A: IPX == DWORD + 6 bytes == 10
#define	MAX_ADDRESS_SIZE	( 10 )

#define	ADDRESS_TYPE_ETHERNET	( 0 )

#define	ADDRESS_TYPE_IP	( 1 )

#define	ADDRESS_TYPE_IPX	( 2 )

#define	ADDRESS_TYPE_TOKENRING	( 3 )

#define	ADDRESS_TYPE_FDDI	( 4 )

#define	ADDRESS_TYPE_XNS	( 5 )

#define	ADDRESS_TYPE_ANY	( 6 )

#define	ADDRESS_TYPE_ANY_GROUP	( 7 )

#define	ADDRESS_TYPE_FIND_HIGHEST	( 8 )

#define	ADDRESS_TYPE_VINES_IP	( 9 )

#define	ADDRESS_TYPE_LOCAL_ONLY	( 10 )

#define	ADDRESS_TYPE_ATM	( 11 )

#define	ADDRESS_TYPE_1394	( 12 )

#define	ADDRESSTYPE_FLAGS_NORMALIZE	( 0x1 )

#define	ADDRESSTYPE_FLAGS_BIT_REVERSE	( 0x2 )

// Vines IP Address Structure
typedef struct _VINES_IP_ADDRESS
    {
    DWORD NetID;
    WORD SubnetID;
    } 	VINES_IP_ADDRESS;

typedef VINES_IP_ADDRESS *LPVINES_IP_ADDRESS;

#define	VINES_IP_ADDRESS_SIZE	( sizeof( VINES_IP_ADDRESS  ) )

// IPX Address Structure
typedef struct _IPX_ADDR
    {
    BYTE Subnet[ 4 ];
    BYTE Address[ 6 ];
    } 	IPX_ADDR;

typedef IPX_ADDR *LPIPX_ADDR;

#define	IPX_ADDR_SIZE	( sizeof( IPX_ADDR  ) )

// XNS Address Structure
typedef IPX_ADDR XNS_ADDRESS;

typedef IPX_ADDR *LPXNS_ADDRESS;

// ETHERNET SOURCE ADDRESS
typedef struct _ETHERNET_SRC_ADDRESS
{
    BYTE    RoutingBit:     1;
    BYTE    LocalBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];

} ETHERNET_SRC_ADDRESS;
typedef ETHERNET_SRC_ADDRESS *LPETHERNET_SRC_ADDRESS;
// ETHERNET DESTINATION ADDRESS
typedef struct _ETHERNET_DST_ADDRESS
{
    BYTE    GroupBit:       1;
    BYTE    AdminBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_DST_ADDRESS;
typedef ETHERNET_DST_ADDRESS *LPETHERNET_DST_ADDRESS;

// FDDI addresses
typedef ETHERNET_SRC_ADDRESS FDDI_SRC_ADDRESS;
typedef ETHERNET_DST_ADDRESS FDDI_DST_ADDRESS;

typedef FDDI_SRC_ADDRESS *LPFDDI_SRC_ADDRESS;
typedef FDDI_DST_ADDRESS *LPFDDI_DST_ADDRESS;

// TOKENRING Source Address
typedef struct _TOKENRING_SRC_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    LocalBit:       1;
    BYTE    RoutingBit:     1;
    BYTE    Byte1;
    BYTE    Byte2:          7;
    BYTE    Functional:     1;
    BYTE    Reserved[3];
} TOKENRING_SRC_ADDRESS;
typedef TOKENRING_SRC_ADDRESS *LPTOKENRING_SRC_ADDRESS;

// TOKENRING Destination Address
typedef struct _TOKENRING_DST_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    AdminBit:       1;
    BYTE    GroupBit:       1;
    BYTE    Reserved[5];
} TOKENRING_DST_ADDRESS;
typedef TOKENRING_DST_ADDRESS *LPTOKENRING_DST_ADDRESS;
// Address Structure
typedef struct _ADDRESS
{
    DWORD                       Type;

    union
    {
        // ADDRESS_TYPE_ETHERNET
        // ADDRESS_TYPE_TOKENRING
        // ADDRESS_TYPE_FDDI
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

        // IP
        BYTE                    IPAddress[IP_ADDRESS_SIZE];

        // raw IPX
        BYTE                    IPXRawAddress[IPX_ADDR_SIZE];

        // real IPX
        IPX_ADDR                IPXAddress;

        // raw Vines IP
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];

        // real Vines IP
        VINES_IP_ADDRESS        VinesIPAddress;

        // ethernet with bits defined
        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;

        // ethernet with bits defined
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

        // tokenring with bits defined
        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;

        // tokenring with bits defined
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

        // fddi with bits defined
        FDDI_SRC_ADDRESS        FddiSrcAddress;

        // fddi with bits defined
        FDDI_DST_ADDRESS        FddiDstAddress;
    };
    
    WORD                        Flags;
} ADDRESS;
typedef ADDRESS *LPADDRESS;
#define ADDRESS_SIZE   sizeof(ADDRESS)


#pragma pack(pop)
//=============================================================================
//  Address Pair Structure
//=============================================================================
#define	ADDRESS_FLAGS_MATCH_DST	( 0x1 )

#define	ADDRESS_FLAGS_MATCH_SRC	( 0x2 )

#define	ADDRESS_FLAGS_EXCLUDE	( 0x4 )

#define	ADDRESS_FLAGS_DST_GROUP_ADDR	( 0x8 )

#define	ADDRESS_FLAGS_MATCH_BOTH	( 0x3 )

typedef struct _ADDRESSPAIR
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS     DstAddress;
    ADDRESS     SrcAddress;

} ADDRESSPAIR;
typedef ADDRESSPAIR *LPADDRESSPAIR;
#define ADDRESSPAIR_SIZE  sizeof(ADDRESSPAIR)
//=============================================================================
//  Address table.
//=============================================================================
#define	MAX_ADDRESS_PAIRS	( 8 )

typedef struct _ADDRESSTABLE
{
    DWORD           nAddressPairs;
    DWORD           nNonMacAddressPairs;
    ADDRESSPAIR     AddressPair[MAX_ADDRESS_PAIRS];

} ADDRESSTABLE;

typedef ADDRESSTABLE *LPADDRESSTABLE;
#define ADDRESSTABLE_SIZE sizeof(ADDRESSTABLE)
//=============================================================================
//  Network information.
//=============================================================================
#define	NETWORKINFO_FLAGS_PMODE_NOT_SUPPORTED	( 0x1 )

#define	NETWORKINFO_FLAGS_REMOTE_NAL	( 0x4 )

#define	NETWORKINFO_FLAGS_REMOTE_NAL_CONNECTED	( 0x8 )

#define	NETWORKINFO_FLAGS_REMOTE_CARD	( 0x10 )

#define	NETWORKINFO_FLAGS_RAS	( 0x20 )

typedef struct _NETWORKINFO
{
    BYTE            PermanentAddr[6];       //... Permanent MAC address
    BYTE            CurrentAddr[6];         //... Current  MAC address
    ADDRESS         OtherAddress;           //... Other address supported (IP, IPX, etc...)
    DWORD           LinkSpeed;              //... Link speed in Mbits.
    DWORD           MacType;                //... Media type.
    DWORD           MaxFrameSize;           //... Max frame size allowed.
    DWORD           Flags;                  //... Informational flags.
    DWORD           TimestampScaleFactor;   //... 1 = 1/1 ms, 10 = 1/10 ms, 100 = 1/100 ms, etc.
    BYTE            NodeName[32];           //... Name of remote workstation.
    BOOL            PModeSupported;         //... Card claims to support P-Mode
    BYTE            Comment[ADAPTER_COMMENT_LENGTH]; // Adapter comment field.

} NETWORKINFO;
typedef NETWORKINFO *LPNETWORKINFO;
#define NETWORKINFO_SIZE    sizeof(NETWORKINFO)
#define	MINIMUM_FRAME_SIZE	( 32 )

//=============================================================================
//  Pattern structure.
//=============================================================================
#define	MAX_PATTERN_LENGTH	( 16 )

// When set this flag will cause those frames which do NOT have the specified pattern
// in the proper stop to be kept.
#define	PATTERN_MATCH_FLAGS_NOT	( 0x1 )

#define	PATTERN_MATCH_FLAGS_RESERVED_1	( 0x2 )

// When set this flag indicates that the user is not interested in a pattern match within 
// IP or IPX, but in the protocol that follows.  The driver will ensure that the protocol
// given in OffsetBasis is there and then that the port in the fram matches the port given.
// It will then calculate the offset from the beginning of the protocol that follows IP or IPX.
// NOTE: This flag is ignored if it is used with any OffsetBasis other than 
// OFFSET_BASIS_RELATIVE_TO_IPX or OFFSET_BASIS_RELATIVE_TO_IP
#define	PATTERN_MATCH_FLAGS_PORT_SPECIFIED	( 0x8 )

// The offset given is relative to the beginning of the frame. The 
// PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define	OFFSET_BASIS_RELATIVE_TO_FRAME	( 0 )

// The offset given is relative to the beginning of the Effective Protocol.
// The Effective Protocol is defined as the protocol that follows
// the last protocol that determines Etype/SAP. In normal terms this means 
// that the Effective Protocol will be IP, IPX, XNS, or any of their ilk.
// The PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define	OFFSET_BASIS_RELATIVE_TO_EFFECTIVE_PROTOCOL	( 1 )

// The offset given is relative to the beginning of IPX. If IPX is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IPX.
#define	OFFSET_BASIS_RELATIVE_TO_IPX	( 2 )

// The offset given is relative to the beginning of IP. If IP is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IP.
#define	OFFSET_BASIS_RELATIVE_TO_IP	( 3 )

typedef /* [public][public][public][public][public][public][public][public][public] */ union __MIDL___MIDL_itf_netmon_0000_0001
    {
    BYTE IPPort;
    WORD ByteSwappedIPXPort;
    } 	GENERIC_PORT;

typedef struct _PATTERNMATCH
    {
    DWORD Flags;
    BYTE OffsetBasis;
    GENERIC_PORT Port;
    WORD Offset;
    WORD Length;
    BYTE PatternToMatch[ 16 ];
    } 	PATTERNMATCH;

typedef PATTERNMATCH *LPPATTERNMATCH;

#define	PATTERNMATCH_SIZE	( sizeof( PATTERNMATCH  ) )

//=============================================================================
//  Expression structure.
//=============================================================================
#define	MAX_PATTERNS	( 4 )

typedef struct _ANDEXP
    {
    DWORD nPatternMatches;
    PATTERNMATCH PatternMatch[ 4 ];
    } 	ANDEXP;

typedef ANDEXP *LPANDEXP;

#define	ANDEXP_SIZE	( sizeof( ANDEXP  ) )

typedef struct _EXPRESSION
    {
    DWORD nAndExps;
    ANDEXP AndExp[ 4 ];
    } 	EXPRESSION;

typedef EXPRESSION *LPEXPRESSION;

#define	EXPRESSION_SIZE	( sizeof( EXPRESSION  ) )

//=============================================================================
//  Trigger.
//=============================================================================
#define	TRIGGER_TYPE_PATTERN_MATCH	( 1 )

#define	TRIGGER_TYPE_BUFFER_CONTENT	( 2 )

#define	TRIGGER_TYPE_PATTERN_MATCH_THEN_BUFFER_CONTENT	( 3 )

#define	TRIGGER_TYPE_BUFFER_CONTENT_THEN_PATTERN_MATCH	( 4 )

#define	TRIGGER_FLAGS_FRAME_RELATIVE	( 0 )

#define	TRIGGER_FLAGS_DATA_RELATIVE	( 0x1 )

#define	TRIGGER_ACTION_NOTIFY	( 0 )

#define	TRIGGER_ACTION_STOP	( 0x2 )

#define	TRIGGER_ACTION_PAUSE	( 0x3 )

#define	TRIGGER_BUFFER_FULL_25_PERCENT	( 0 )

#define	TRIGGER_BUFFER_FULL_50_PERCENT	( 1 )

#define	TRIGGER_BUFFER_FULL_75_PERCENT	( 2 )

#define	TRIGGER_BUFFER_FULL_100_PERCENT	( 3 )

typedef struct _TRIGGER
    {
    BOOL TriggerActive;
    BYTE TriggerType;
    BYTE TriggerAction;
    DWORD TriggerFlags;
    PATTERNMATCH TriggerPatternMatch;
    DWORD TriggerBufferSize;
    DWORD TriggerReserved;
    char TriggerCommandLine[ 260 ];
    } 	TRIGGER;

typedef TRIGGER *LPTRIGGER;

#define	TRIGGER_SIZE	( sizeof( TRIGGER  ) )

//=============================================================================
//  Capture filter.
//=============================================================================
//  Capture filter flags. By default all frames are rejected and
//  Network Monitor enables them based on the CAPTUREFILTER flags
//  defined below.
#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL_SAPS	( 0x1 )

#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL_ETYPES	( 0x2 )

#define	CAPTUREFILTER_FLAGS_TRIGGER	( 0x4 )

#define	CAPTUREFILTER_FLAGS_LOCAL_ONLY	( 0x8 )

// throw away our internal comment frames
#define	CAPTUREFILTER_FLAGS_DISCARD_COMMENTS	( 0x10 )

// Keep SMT and Token Ring MAC frames
#define	CAPTUREFILTER_FLAGS_KEEP_RAW	( 0x20 )

#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL	( 0x3 )

#define	BUFFER_FULL_25_PERCENT	( 0 )

#define	BUFFER_FULL_50_PERCENT	( 1 )

#define	BUFFER_FULL_75_PERCENT	( 2 )

#define	BUFFER_FULL_100_PERCENT	( 3 )

typedef struct _CAPTUREFILTER
{
    DWORD           FilterFlags;      
    LPBYTE          lpSapTable;       
    LPWORD          lpEtypeTable;     
    WORD            nSaps;            
    WORD            nEtypes;          
    LPADDRESSTABLE  AddressTable;     
    EXPRESSION      FilterExpression; 
    TRIGGER         Trigger;          
    DWORD           nFrameBytesToCopy;
    DWORD           Reserved;

} CAPTUREFILTER;
typedef CAPTUREFILTER *LPCAPTUREFILTER;
#define CAPTUREFILTER_SIZE    sizeof(CAPTUREFILTER)
//=============================================================================
//  Frame type.
//=============================================================================
//  TimeStamp is in 1/1,000,000th seconds.
typedef struct _FRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    /* [size_is] */ BYTE MacFrame[ 1 ];
    } 	FRAME;

typedef FRAME *LPFRAME;

typedef FRAME UNALIGNED *ULPFRAME;
#define	FRAME_SIZE	( sizeof( FRAME  ) )

//=============================================================================
//  Frame descriptor type.
//=============================================================================
#define	LOW_PROTOCOL_IPX	( OFFSET_BASIS_RELATIVE_TO_IPX )

#define	LOW_PROTOCOL_IP	( OFFSET_BASIS_RELATIVE_TO_IP )

#define	LOW_PROTOCOL_UNKNOWN	( ( BYTE  )-1 )

typedef struct _FRAME_DESCRIPTOR
    {
    /* [size_is] */ LPBYTE FramePointer;
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    WORD Etype;
    BYTE Sap;
    BYTE LowProtocol;
    WORD LowProtocolOffset;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [default] */ WORD Reserved;
        /* [case()] */ BYTE IPPort;
        /* [case()] */ WORD ByteSwappedIPXPort;
        } 	HighPort;
    WORD HighProtocolOffset;
    } 	FRAME_DESCRIPTOR;

typedef FRAME_DESCRIPTOR *LPFRAME_DESCRIPTOR;

#define	FRAME_DESCRIPTOR_SIZE	( sizeof( FRAME_DESCRIPTOR  ) )

//=============================================================================
//  Frame descriptor table.
//=============================================================================
typedef struct _FRAMETABLE
    {
    DWORD FrameTableLength;
    DWORD StartIndex;
    DWORD EndIndex;
    DWORD FrameCount;
    /* [size_is] */ FRAME_DESCRIPTOR Frames[ 1 ];
    } 	FRAMETABLE;

typedef FRAMETABLE *LPFRAMETABLE;

//=============================================================================
//  Station statistics.
//=============================================================================
#define	STATIONSTATS_FLAGS_INITIALIZED	( 0x1 )

#define	STATIONSTATS_FLAGS_EVENTPOSTED	( 0x2 )

#define	STATIONSTATS_POOL_SIZE	( 100 )

typedef struct _STATIONSTATS
    {
    DWORD NextStationStats;
    DWORD SessionPartnerList;
    DWORD Flags;
    BYTE StationAddress[ 6 ];
    WORD Pad;
    DWORD TotalPacketsReceived;
    DWORD TotalDirectedPacketsSent;
    DWORD TotalBroadcastPacketsSent;
    DWORD TotalMulticastPacketsSent;
    DWORD TotalBytesReceived;
    DWORD TotalBytesSent;
    } 	STATIONSTATS;

typedef STATIONSTATS *LPSTATIONSTATS;

#define	STATIONSTATS_SIZE	( sizeof( STATIONSTATS  ) )

//=============================================================================
//  Session statistics.
//=============================================================================
#define	SESSION_FLAGS_INITIALIZED	( 0x1 )

#define	SESSION_FLAGS_EVENTPOSTED	( 0x2 )

#define	SESSION_POOL_SIZE	( 100 )

typedef struct _SESSIONSTATS
    {
    DWORD NextSession;
    DWORD StationOwner;
    DWORD StationPartner;
    DWORD Flags;
    DWORD TotalPacketsSent;
    } 	SESSIONSTATS;

typedef SESSIONSTATS *LPSESSIONSTATS;

#define	SESSIONSTATS_SIZE	( sizeof( SESSIONSTATS  ) )

//=============================================================================
//  Station Query
//=============================================================================

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)
#define	STATIONQUERY_FLAGS_LOADED	( 0x1 )

#define	STATIONQUERY_FLAGS_RUNNING	( 0x2 )

#define	STATIONQUERY_FLAGS_CAPTURING	( 0x4 )

#define	STATIONQUERY_FLAGS_TRANSMITTING	( 0x8 )

#define	STATIONQUERY_VERSION_MINOR	( 0x1 )

#define	STATIONQUERY_VERSION_MAJOR	( 0x2 )

typedef struct _OLDSTATIONQUERY
    {
    DWORD Flags;
    BYTE BCDVerMinor;
    BYTE BCDVerMajor;
    DWORD LicenseNumber;
    BYTE MachineName[ 16 ];
    BYTE UserName[ 32 ];
    BYTE Reserved[ 32 ];
    BYTE AdapterAddress[ 6 ];
    } 	OLDSTATIONQUERY;

typedef OLDSTATIONQUERY *LPOLDSTATIONQUERY;

#define	OLDSTATIONQUERY_SIZE	( sizeof( OLDSTATIONQUERY  ) )

typedef struct _STATIONQUERY
    {
    DWORD Flags;
    BYTE BCDVerMinor;
    BYTE BCDVerMajor;
    DWORD LicenseNumber;
    BYTE MachineName[ 16 ];
    BYTE UserName[ 32 ];
    BYTE Reserved[ 32 ];
    BYTE AdapterAddress[ 6 ];
    WCHAR WMachineName[ 16 ];
    WCHAR WUserName[ 32 ];
    } 	STATIONQUERY;

typedef STATIONQUERY *LPSTATIONQUERY;

#define	STATIONQUERY_SIZE	( sizeof( STATIONQUERY  ) )


#pragma pack(pop)
//=============================================================================
//   structure.
//=============================================================================
typedef struct _QUERYTABLE
    {
    DWORD nStationQueries;
    /* [size_is] */ STATIONQUERY StationQuery[ 1 ];
    } 	QUERYTABLE;

typedef QUERYTABLE *LPQUERYTABLE;

#define	QUERYTABLE_SIZE	( sizeof( QUERYTABLE  ) )

//=============================================================================
//  The LINK structure is used to chain structures together into a list.
//=============================================================================
typedef struct _LINK *LPLINK;

typedef struct _LINK
    {
    LPLINK PrevLink;
    LPLINK NextLink;
    } 	LINK;

//=============================================================================
//  Security Request packet
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _SECURITY_PERMISSION_CHECK
    {
    UINT Version;
    DWORD RandomNumber;
    BYTE MachineName[ 16 ];
    BYTE UserName[ 32 ];
    UINT MacType;
    BYTE PermanentAdapterAddress[ 6 ];
    BYTE CurrentAdapterAddress[ 6 ];
    WCHAR WMachineName[ 16 ];
    WCHAR WUserName[ 32 ];
    } 	SECURITY_PERMISSION_CHECK;

typedef SECURITY_PERMISSION_CHECK *LPSECURITY_PERMISSION_CHECK;

typedef SECURITY_PERMISSION_CHECK UNALIGNED * ULPSECURITY_PERMISSION_CHECK;
#define	SECURITY_PERMISSION_CHECK_SIZE	( sizeof( SECURITY_PERMISSION_CHECK  ) )


#pragma pack(pop)
//=============================================================================
//  Security Response packet
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
#define	MAX_SECURITY_BREACH_REASON_SIZE	( 100 )

#define	MAX_SIGNATURE_LENGTH	( 128 )

#define	MAX_USER_NAME_LENGTH	( 256 )

typedef struct _SECURITY_PERMISSION_RESPONSE
    {
    UINT Version;
    DWORD RandomNumber;
    BYTE MachineName[ 16 ];
    BYTE Address[ 6 ];
    BYTE UserName[ 256 ];
    BYTE Reason[ 100 ];
    DWORD SignatureLength;
    BYTE Signature[ 128 ];
    } 	SECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE *LPSECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE UNALIGNED * ULPSECURITY_PERMISSION_RESPONSE;
#define	SECURITY_PERMISSION_RESPONSE_SIZE	( sizeof( SECURITY_PERMISSION_RESPONSE  ) )


#pragma pack(pop)
//=============================================================================
//  Callback type
//=============================================================================
// generic events
#define	UPDATE_EVENT_TERMINATE_THREAD	( 0 )

#define	UPDATE_EVENT_NETWORK_STATUS	( 0x1 )

// rtc events
#define	UPDATE_EVENT_RTC_INTERVAL_ELAPSED	( 0x2 )

#define	UPDATE_EVENT_RTC_FRAME_TABLE_FULL	( 0x3 )

#define	UPDATE_EVENT_RTC_BUFFER_FULL	( 0x4 )

// delayed events
#define	UPDATE_EVENT_TRIGGER_BUFFER_CONTENT	( 0x5 )

#define	UPDATE_EVENT_TRIGGER_PATTERN_MATCH	( 0x6 )

#define	UPDATE_EVENT_TRIGGER_BUFFER_PATTERN	( 0x7 )

#define	UPDATE_EVENT_TRIGGER_PATTERN_BUFFER	( 0x8 )

// transmit events
#define	UPDATE_EVENT_TRANSMIT_STATUS	( 0x9 )

// Security events
#define	UPDATE_EVENT_SECURITY_BREACH	( 0xa )

// Remote failure event
#define	UPDATE_EVENT_REMOTE_FAILURE	( 0xb )

// actions
#define	UPDATE_ACTION_TERMINATE_THREAD	( 0 )

#define	UPDATE_ACTION_NOTIFY	( 0x1 )

#define	UPDATE_ACTION_STOP_CAPTURE	( 0x2 )

#define	UPDATE_ACTION_PAUSE_CAPTURE	( 0x3 )

#define	UPDATE_ACTION_RTC_BUFFER_SWITCH	( 0x4 )

typedef struct _UPDATE_EVENT
    {
    USHORT Event;
    DWORD Action;
    DWORD Status;
    DWORD Value;
    __int64 TimeStamp;
    DWORD_PTR lpUserContext;
    DWORD_PTR lpReserved;
    UINT FramesDropped;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [default] */ DWORD Reserved;
        /* [case()] */ LPFRAMETABLE lpFrameTable;
        /* [case()] */ DWORD_PTR lpPacketQueue;
        /* [case()] */ SECURITY_PERMISSION_RESPONSE SecurityResponse;
        } 	;
    LPSTATISTICS lpFinalStats;
    } 	UPDATE_EVENT;

typedef UPDATE_EVENT *PUPDATE_EVENT;

// note for c++ users:
// the declaration for this callback should be in the public part of the header file:
// static WINAPI DWORD NetworkCallback( UPDATE_EVENT events);
// and the implementation should be, in the protected section of the cpp file:
// DWORD WINAPI ClassName::NetworkCallback( UPDATE_EVENT events) {};
//typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
//=============================================================================
//  NETWORKSTATUS data structure.
//=============================================================================
typedef struct _NETWORKSTATUS
    {
    DWORD State;
    DWORD Flags;
    } 	NETWORKSTATUS;

typedef NETWORKSTATUS *LPNETWORKSTATUS;

#define	NETWORKSTATUS_SIZE	( sizeof( NETWORKSTATUS  ) )

#define	NETWORKSTATUS_STATE_VOID	( 0 )

#define	NETWORKSTATUS_STATE_INIT	( 1 )

#define	NETWORKSTATUS_STATE_CAPTURING	( 2 )

#define	NETWORKSTATUS_STATE_PAUSED	( 3 )

#define	NETWORKSTATUS_FLAGS_TRIGGER_PENDING	( 0x1 )

//=============================================================================
//  BONEPACKET structure.
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
#define	BONE_COMMAND_STATION_QUERY_REQUEST	( 0 )

#define	BONE_COMMAND_STATION_QUERY_RESPONSE	( 1 )

#define	BONE_COMMAND_ALERT	( 2 )

#define	BONE_COMMAND_PERMISSION_CHECK	( 3 )

#define	BONE_COMMAND_PERMISSION_RESPONSE	( 4 )

#define	BONE_COMMAND_SECURITY_MONITOR_EVENT	( 5 )

typedef struct _BONEPACKET
    {
    DWORD Signature;
    BYTE Command;
    BYTE Flags;
    DWORD Reserved;
    WORD Length;
    } 	BONEPACKET;

typedef BONEPACKET *LPBONEPACKET;

typedef BONEPACKET UNALIGNED* ULPBONEPACKET;
#define	BONEPACKET_SIZE	( sizeof( BONEPACKET  ) )


#pragma pack(pop)
//=============================================================================
//  BONE alert packet.
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
#define	ALERT_CODE_BEGIN_TRANSMIT	( 0 )

typedef struct _ALERT
    {
    DWORD AlertCode;
    WCHAR WMachineName[ 16 ];
    WCHAR WUserName[ 32 ];
    union 
        {
        BYTE Pad[ 32 ];
        DWORD nFramesToSend;
        } 	;
    } 	ALERT;

typedef ALERT *LPALERT;

#define	ALERT_SIZE	( sizeof( ALERT  ) )


#pragma pack(pop)
//=============================================================================
//  BONEPACKET signature.
//=============================================================================
#define MAKE_WORD(l, h)         (((WORD) (l)) | (((WORD) (h)) << 8))
#define MAKE_LONG(l, h)         (((DWORD) (l)) | (((DWORD) (h)) << 16L))
#define MAKE_SIG(a, b, c, d)    MAKE_LONG(MAKE_WORD(a, b), MAKE_WORD(c, d))
#define BONE_PACKET_SIGNATURE   MAKE_SIG('R', 'T', 'S', 'S')
//=============================================================================
//  STATISTICS parameter structure.
//=============================================================================
#define	MAX_SESSIONS	( 100 )

#define	MAX_STATIONS	( 100 )

typedef struct _STATISTICSPARAM
    {
    DWORD StatisticsSize;
    STATISTICS Statistics;
    DWORD StatisticsTableEntries;
    STATIONSTATS StatisticsTable[ 100 ];
    DWORD SessionTableEntries;
    SESSIONSTATS SessionTable[ 100 ];
    } 	STATISTICSPARAM;

typedef STATISTICSPARAM *LPSTATISTICSPARAM;

#define	STATISTICSPARAM_SIZE	( sizeof( STATISTICSPARAM  ) )

//=============================================================================
//  Capture file header.
//=============================================================================

// This structure is used to decode file data and so needs to be packed

#pragma pack(push, 1)
#define	CAPTUREFILE_VERSION_MAJOR	( 2 )

#define	CAPTUREFILE_VERSION_MINOR	( 0 )

#define MakeVersion(Major, Minor)   ((DWORD) MAKEWORD(Minor, Major))
#define GetCurrentVersion()         MakeVersion(CAPTUREFILE_VERSION_MAJOR, CAPTUREFILE_VERSION_MINOR)
#define NETMON_1_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('R', 'T', 'S', 'S')
#define NETMON_2_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('G', 'M', 'B', 'U')
typedef struct _CAPTUREFILE_HEADER_VALUES
    {
    DWORD Signature;
    BYTE BCDVerMinor;
    BYTE BCDVerMajor;
    WORD MacType;
    SYSTEMTIME TimeStamp;
    DWORD FrameTableOffset;
    DWORD FrameTableLength;
    DWORD UserDataOffset;
    DWORD UserDataLength;
    DWORD CommentDataOffset;
    DWORD CommentDataLength;
    DWORD StatisticsOffset;
    DWORD StatisticsLength;
    DWORD NetworkInfoOffset;
    DWORD NetworkInfoLength;
    DWORD ConversationStatsOffset;
    DWORD ConversationStatsLength;
    } 	CAPTUREFILE_HEADER_VALUES;

typedef CAPTUREFILE_HEADER_VALUES *LPCAPTUREFILE_HEADER_VALUES;

#define	CAPTUREFILE_HEADER_VALUES_SIZE	( sizeof( CAPTUREFILE_HEADER_VALUES  ) )


#pragma pack(pop)
//=============================================================================
//  Capture file.
//=============================================================================

// This structure is used to decode file data and so needs to be packed

#pragma pack(push, 1)
typedef struct _CAPTUREFILE_HEADER
    {
    union 
        {
        CAPTUREFILE_HEADER_VALUES ActualHeader;
        BYTE Buffer[ 72 ];
        } 	;
    BYTE Reserved[ 56 ];
    } 	CAPTUREFILE_HEADER;

typedef CAPTUREFILE_HEADER *LPCAPTUREFILE_HEADER;

#define	CAPTUREFILE_HEADER_SIZE	( sizeof( CAPTUREFILE_HEADER  ) )


#pragma pack(pop)
//=============================================================================
//  Stats Frame definitions.
//=============================================================================

// These structures are used to create network data and so need to be packed

#pragma pack(push, 1)
typedef struct _EFRAMEHDR
    {
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    WORD Length;
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	EFRAMEHDR;

typedef struct _TRFRAMEHDR
    {
    BYTE AC;
    BYTE FC;
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	TRFRAMEHDR;

#define	DEFAULT_TR_AC	( 0 )

#define	DEFAULT_TR_FC	( 0x40 )

#define	DEFAULT_SAP	( 0xaa )

#define	DEFAULT_CONTROL	( 0x3 )

#define	DEFAULT_ETHERTYPE	( 0x8419 )

typedef struct _FDDIFRAMEHDR
    {
    BYTE FC;
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	FDDIFRAMEHDR;

#define	DEFAULT_FDDI_FC	( 0x10 )

typedef struct _FDDISTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    FDDIFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	FDDISTATFRAME;

typedef FDDISTATFRAME *LPFDDISTATFRAME;

typedef FDDISTATFRAME UNALIGNED *ULPFDDISTATFRAME;
#define	FDDISTATFRAME_SIZE	( sizeof( FDDISTATFRAME  ) )

typedef struct _ATMFRAMEHDR
    {
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    WORD Vpi;
    WORD Vci;
    } 	ATMFRAMEHDR;

typedef struct _ATMSTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    ATMFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	ATMSTATFRAME;

typedef ATMSTATFRAME *LPATMSTATFRAME;

typedef ATMSTATFRAME UNALIGNED *ULPATMSTATFRAME;
#define	ATMSTATFRAME_SIZE	( sizeof( ATMSTATFRAME  ) )

typedef struct _TRSTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    TRFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	TRSTATFRAME;

typedef TRSTATFRAME *LPTRSTATFRAME;

typedef TRSTATFRAME UNALIGNED *ULPTRSTATFRAME;
#define	TRSTATFRAME_SIZE	( sizeof( TRSTATFRAME  ) )

typedef struct _ESTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    EFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	ESTATFRAME;

typedef ESTATFRAME *LPESTATFRAME;

typedef ESTATFRAME UNALIGNED *ULPESTATFRAME;
#define	ESTATFRAME_SIZE	( sizeof( ESTATFRAME  ) )

#define	STATISTICS_VERSION_1_0	( 0 )

#define	STATISTICS_VERSION_2_0	( 0x20 )

#define	MAX_STATSFRAME_SIZE	( sizeof( TRSTATFRAME  ) )

#define	STATS_FRAME_TYPE	( 103 )


#pragma pack(pop)
//=============================================================================
//=============================================================================
//  (NMEvent.h)
//=============================================================================
//=============================================================================
// NMCOLUMNTYPE
typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0006
    {	NMCOLUMNTYPE_UINT8	= 0,
	NMCOLUMNTYPE_SINT8	= NMCOLUMNTYPE_UINT8 + 1,
	NMCOLUMNTYPE_UINT16	= NMCOLUMNTYPE_SINT8 + 1,
	NMCOLUMNTYPE_SINT16	= NMCOLUMNTYPE_UINT16 + 1,
	NMCOLUMNTYPE_UINT32	= NMCOLUMNTYPE_SINT16 + 1,
	NMCOLUMNTYPE_SINT32	= NMCOLUMNTYPE_UINT32 + 1,
	NMCOLUMNTYPE_FLOAT64	= NMCOLUMNTYPE_SINT32 + 1,
	NMCOLUMNTYPE_FRAME	= NMCOLUMNTYPE_FLOAT64 + 1,
	NMCOLUMNTYPE_YESNO	= NMCOLUMNTYPE_FRAME + 1,
	NMCOLUMNTYPE_ONOFF	= NMCOLUMNTYPE_YESNO + 1,
	NMCOLUMNTYPE_TRUEFALSE	= NMCOLUMNTYPE_ONOFF + 1,
	NMCOLUMNTYPE_MACADDR	= NMCOLUMNTYPE_TRUEFALSE + 1,
	NMCOLUMNTYPE_IPXADDR	= NMCOLUMNTYPE_MACADDR + 1,
	NMCOLUMNTYPE_IPADDR	= NMCOLUMNTYPE_IPXADDR + 1,
	NMCOLUMNTYPE_VARTIME	= NMCOLUMNTYPE_IPADDR + 1,
	NMCOLUMNTYPE_STRING	= NMCOLUMNTYPE_VARTIME + 1
    } 	NMCOLUMNTYPE;

// NMCOLUMNVARIANT
typedef struct _NMCOLUMNVARIANT
    {
    NMCOLUMNTYPE Type;
    union 
        {
        BYTE Uint8Val;
        char Sint8Val;
        WORD Uint16Val;
        short Sint16Val;
        DWORD Uint32Val;
        long Sint32Val;
        DOUBLE Float64Val;
        DWORD FrameVal;
        BOOL YesNoVal;
        BOOL OnOffVal;
        BOOL TrueFalseVal;
        BYTE MACAddrVal[ 6 ];
        IPX_ADDR IPXAddrVal;
        DWORD IPAddrVal;
        DOUBLE VarTimeVal;
        LPCSTR pStringVal;
        } 	Value;
    } 	NMCOLUMNVARIANT;

// COLUMNINFO
typedef struct _NMCOLUMNINFO
    {
    LPSTR szColumnName;
    NMCOLUMNVARIANT VariantData;
    } 	NMCOLUMNINFO;

typedef NMCOLUMNINFO *PNMCOLUMNINFO;

// JTYPE
typedef LPSTR JTYPE;

// EVENTDATA
typedef struct _NMEVENTDATA
    {
    LPSTR pszReserved;
    BYTE Version;
    DWORD EventIdent;
    DWORD Flags;
    DWORD Severity;
    BYTE NumColumns;
    LPSTR szSourceName;
    LPSTR szEventName;
    LPSTR szDescription;
    LPSTR szMachine;
    JTYPE Justification;
    LPSTR szUrl;
    SYSTEMTIME SysTime;
    /* [size_is] */ NMCOLUMNINFO Column[ 1 ];
    } 	NMEVENTDATA;

typedef NMEVENTDATA *PNMEVENTDATA;

// EVENT FLAGS
#define	NMEVENTFLAG_MONITOR	( 0 )

#define	NMEVENTFLAG_EXPERT	( 0x1 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY	( 0x80000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE	( 0x40000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME	( 0x20000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION	( 0x10000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE	( 0x8000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_TIME	( 0x4000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_DATE	( 0x2000000 )

//#define NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS (NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY   | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE     | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION| \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE    | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_TIME       | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DATE )
#define	NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS	( 0xfe000000 )


enum _NMEVENT_SEVERITIES
    {	NMEVENT_SEVERITY_INFORMATIONAL	= 0,
	NMEVENT_SEVERITY_WARNING	= NMEVENT_SEVERITY_INFORMATIONAL + 1,
	NMEVENT_SEVERITY_STRONG_WARNING	= NMEVENT_SEVERITY_WARNING + 1,
	NMEVENT_SEVERITY_ERROR	= NMEVENT_SEVERITY_STRONG_WARNING + 1,
	NMEVENT_SEVERITY_SEVERE_ERROR	= NMEVENT_SEVERITY_ERROR + 1,
	NMEVENT_SEVERITY_CRITICAL_ERROR	= NMEVENT_SEVERITY_SEVERE_ERROR + 1
    } ;
//=============================================================================
//=============================================================================
//  (NMmcs.h)
//=============================================================================
//=============================================================================
//=============================================================================
// Monitor status values returned from call to GetMonitorStatus
//=============================================================================
#define	MONITOR_STATUS_ERROR	( -1 )

#define	MONITOR_STATUS_ENABLED	( 4 )

#define	MONITOR_STATUS_CONFIGURED	( 5 )

#define	MONITOR_STATUS_RUNNING	( 6 )

#define	MONITOR_STATUS_RUNNING_FAULTED	( 9 )

#define	MONITOR_STATUS_DELETED	( 10 )

#define	MCS_COMMAND_ENABLE	( 13 )

#define	MCS_COMMAND_DISABLE	( 14 )

#define	MCS_COMMAND_SET_CONFIG	( 15 )

#define	MCS_COMMAND_GET_CONFIG	( 16 )

#define	MCS_COMMAND_START	( 17 )

#define	MCS_COMMAND_STOP	( 18 )

#define	MCS_COMMAND_CONNECT	( 19 )

#define	MCS_COMMAND_RENAME	( 20 )

#define	MCS_COMMAND_REFRESH_STATUS	( 21 )

//=============================================================================
// Monitor Creation Flags
//=============================================================================
#define	MCS_CREATE_ONE_PER_NETCARD	( 0x1 )

#define	MCS_CREATE_CONFIGS_BY_DEFAULT	( 0x10 )

#define	MCS_CREATE_PMODE_NOT_REQUIRED	( 0x100 )

typedef __int64 HNMMONITOR;

//=============================================================================
// NPP_INFO
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0008
    {
    DWORD ListIndex;
    /* [string] */ char *ShortName;
    /* [string] */ char *LongName;
    } 	NPP_INFO;

typedef NPP_INFO *PNPP_INFO;

//=============================================================================
// MONITOR_INFO
//=============================================================================
typedef struct _MONITOR_INFO
    {
    HNMMONITOR MonitorInstance;
    HNMMONITOR MonitorClass;
    DWORD CreateFlags;
    DWORD Status;
    DWORD ListIndex;
    /* [string] */ char *pDescription;
    /* [string] */ char *pScript;
    /* [string] */ char *pConfiguration;
    /* [string] */ char *pName;
    } 	MONITOR_INFO;

typedef MONITOR_INFO *PMONITOR_INFO;

//=============================================================================
// MONITOR_MESSAGE
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0009
    {
    HNMMONITOR Monitor;
    DWORD ListIndex;
    /* [string] */ char *pszMessage;
    } 	MONITOR_MESSAGE;

typedef MONITOR_MESSAGE *PMONITOR_MESSAGE;

//=============================================================================
// COMMAND_FAILED_EVENT
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0010
    {
    HNMMONITOR Monitor;
    DWORD Command;
    DWORD FailureCode;
    DWORD ListIndex;
    DWORD Status;
    } 	COMMAND_FAILED_EVENT;

typedef COMMAND_FAILED_EVENT *PCOMMAND_FAILED_EVENT;

//=============================================================================
// MONITOR_STATUS_EVENT
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0011
    {
    HNMMONITOR Monitor;
    DWORD LastCommand;
    DWORD ListIndex;
    DWORD Status;
    DWORD FramesProcessed;
    } 	MONITOR_STATUS_EVENT;

typedef MONITOR_STATUS_EVENT *PMONITOR_STATUS_EVENT;

//=============================================================================
// MCS_CLIENT
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0012
    {
    /* [string] */ OLECHAR *pwszName;
    FILETIME FileTime;
    DWORD pXMCS;
    BOOL bCurrent;
    } 	MCS_CLIENT;

typedef MCS_CLIENT *PMCS_CLIENT;

//=============================================================================
//=============================================================================
// (Finder.h)
//=============================================================================
//=============================================================================
//=============================================================================
// Structures use by NPPs, the Finder, and monitors
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0013
    {
    DWORD dwNumBlobs;
    /* [size_is] */ HBLOB hBlobs[ 1 ];
    } 	BLOB_TABLE;

typedef BLOB_TABLE *PBLOB_TABLE;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0014
    {
    DWORD size;
    /* [size_is] */ BYTE *pBytes;
    } 	MBLOB;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0015
    {
    DWORD dwNumBlobs;
    /* [size_is] */ MBLOB mBlobs[ 1 ];
    } 	MBLOB_TABLE;

typedef MBLOB_TABLE *PMBLOB_TABLE;

//=============================================================================
// Functions called by monitors, tools, netmon
//=============================================================================
DWORD _cdecl GetNPPBlobTable(HBLOB          hFilterBlob,  
                      PBLOB_TABLE*   ppBlobTable);

DWORD _cdecl GetNPPBlobFromUI(HWND          hwnd,
                       HBLOB         hFilterBlob,
                       HBLOB*        phBlob);          

DWORD _cdecl GetNPPBlobFromUIExU(HWND          hwnd,
                          HBLOB         hFilterBlob,
                          HBLOB*        phBlob,
                          char*         szHelpFileName);          

DWORD _cdecl SelectNPPBlobFromTable( HWND   hwnd,
                              PBLOB_TABLE    pBlobTable,
                              HBLOB*         hBlob);

DWORD _cdecl SelectNPPBlobFromTableExU( HWND   hwnd,
                                 PBLOB_TABLE    pBlobTable,
                                 HBLOB*         hBlob,
                                 char*          szHelpFileName);

//=============================================================================
// Helper functions provided by the Finder
//=============================================================================

__inline DWORD BLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(BLOB_TABLE)+dwNumBlobs*sizeof(HBLOB));
}

__inline PBLOB_TABLE  AllocBlobTable(DWORD dwNumBlobs)
{
    DWORD size = BLOB_TABLE_SIZE(dwNumBlobs);

    return (PBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

__inline DWORD MBLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(MBLOB_TABLE)+dwNumBlobs*sizeof(MBLOB));
}

__inline PMBLOB_TABLE  AllocMBlobTable(DWORD dwNumBlobs)
{
    DWORD size = MBLOB_TABLE_SIZE(dwNumBlobs);

    return (PMBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

//=============================================================================
// Functions provided by NPPs, called by the Finder
//=============================================================================

// For NPP's that can return a Blob table without additional configuration.
DWORD _cdecl GetNPPBlobs(PBLOB_TABLE*       ppBlobTable);
typedef DWORD (_cdecl FAR* BLOBSPROC) (PBLOB_TABLE*       ppBlobTable);

// For NPP's that need additional information to return a Blob table.
DWORD _cdecl GetConfigBlob(HBLOB*      phBlob);
typedef DWORD (_cdecl FAR* GETCFGBLOB) (HBLOB, HBLOB*);
typedef DWORD (_cdecl FAR* CFGPROC) (HWND               hwnd,
                              HBLOB              SpecialBlob,
                              PBLOB_TABLE*       ppBlobTable);

//=============================================================================
// Handy functions
//=============================================================================
BOOL  _cdecl FilterNPPBlob(HBLOB hBlob, HBLOB FilterBlob);

BOOL  _cdecl RaiseNMEvent(HINSTANCE    hInstance,
                   WORD         EventType, 
                   DWORD        EventID,
                   WORD         nStrings, 
                   const char** aInsertStrs,
                   LPVOID       lpvData,
                   DWORD        dwDataSize);

//=============================================================================
//=============================================================================
//  (NMmonitor.h)
//=============================================================================
//=============================================================================
#ifdef __cplusplus
struct MONITOR;
typedef MONITOR* PMONITOR;

typedef void (WINAPI* MCSALERTPROC) (PMONITOR pMonitor, TCHAR* alert);

//****************************************************************************
// Our exported Monitor functions, that must be supported by ALL monitors 
//****************************************************************************
// Create the Monitor, function called "CreateMonitor". The
// argument is a potential configuration structure
typedef DWORD (WINAPI* CREATEMONITOR)(PMONITOR*     ppMonitor, 
                                      HBLOB         hInputNPPBlob,
                                      char*         pConfiguration,
                                      MCSALERTPROC  McsAlertProc);

// Destroy the Monitor, function called "DestroyMonitor"
typedef DWORD (WINAPI* DESTROYMONITOR)(PMONITOR);

// We need the monitor's NPP filter blob: "GetMonitorFilter"
typedef DWORD (WINAPI* GETMONITORFILTER) (HBLOB* pFilterBlob);

// Get the monitor configuration "GetMonitorConfig"
// The pMonitor argument can not be null
typedef DWORD (WINAPI* GETMONITORCONFIG) (PMONITOR pMonitor,
                                          char**   ppScript,
                                          char**   ppConfiguration);

// Set the monitor configuration "SetMonitorConfig"
// The pMonitor argument can not be null
typedef DWORD (WINAPI* SETMONITORCONFIG) (PMONITOR pMonitor, 
                                          char* pConfiguration);

// The monitor's connect function: "ConnectMonitor"
typedef DWORD (WINAPI* CONNECTMONITOR) (PMONITOR pMonitor);

// The monitor's start function: "StartMonitor"
typedef DWORD (WINAPI* STARTMONITOR) (PMONITOR pMonitor, char** ppResponse);

// The monitor's stop function: "StopMonitor"
typedef DWORD (WINAPI* STOPMONITOR) (PMONITOR pMonitor);

// Get the monitor status: "GetMonitorStatus"
typedef DWORD (WINAPI* GETMONITORSTATUS) (PMONITOR pMonitor, DWORD* pStatus);

//****************************************************************************
// Optional function that allows the monitor dll to do specific functions
// prior to the creation of any monitors. "OneTimeSetup"
typedef DWORD (WINAPI* ONETIMESETUP) (void);
//****************************************************************************

//****************************************************************************
// Optional function that provides a description of the monitor
//****************************************************************************
// For current display porpoises, we could use this: "DescribeSelf"
typedef DWORD (WINAPI* DESCRIBESELF) (const char** ppName,
                                      const char** ppDescription);

//=============================================================================
//  Useful class which writes out frame to a cap file Netmon can read.
//=============================================================================
struct CSCAPF;

class __declspec (dllexport) CCaptureFile
{
public:
    CCaptureFile(const char* FileName,
                 HWND hwndParent,
                 DWORD FileSize,
                 int EstimatedAvgFrameSize);
    CCaptureFile(const char* FileName,
                 DWORD FileSize,
                 int EstimatedAvgFrameSize);

    ~CCaptureFile();
    
    DWORD SaveFrame(LPFRAME_DESCRIPTOR lpFrameDesc);
    DWORD Save(void);
    DWORD Resize(DWORD NewFileSize);
    DWORD SetNetworkInfo(LPNETWORKINFO lpNetworkInfo);

private:
    CSCAPF* m_cscapf;
};

#endif // __cplusplus
//=============================================================================
//=============================================================================
//  (NMSupp.h)
//=============================================================================
//=============================================================================

#ifndef __cplusplus
#ifndef try
#define try                         __try
#endif // try

#ifndef except
#define except                      __except
#endif // except
#endif // __cplusplus
//=============================================================================
//  Windows version constants.
//=============================================================================
#define	WINDOWS_VERSION_UNKNOWN	( 0 )

#define	WINDOWS_VERSION_WIN32S	( 1 )

#define	WINDOWS_VERSION_WIN32C	( 2 )

#define	WINDOWS_VERSION_WIN32	( 3 )

//=============================================================================
//  Frame masks.
//=============================================================================
#define	FRAME_MASK_ETHERNET	( ( BYTE  )~0x1 )

#define	FRAME_MASK_TOKENRING	( ( BYTE  )~0x80 )

#define	FRAME_MASK_FDDI	( ( BYTE  )~0x1 )

//=============================================================================
//  ACCESSRIGHTS
//=============================================================================
typedef 
enum _ACCESSRIGHTS
    {	AccessRightsNoAccess	= 0,
	AccessRightsMonitoring	= AccessRightsNoAccess + 1,
	AccessRightsUserAccess	= AccessRightsMonitoring + 1,
	AccessRightsAllAccess	= AccessRightsUserAccess + 1
    } 	ACCESSRIGHTS;

typedef ACCESSRIGHTS *PACCESSRIGHTS;

typedef LPVOID HPASSWORD;

#define HANDLE_TYPE_PASSWORD            MAKE_IDENTIFIER('P', 'W', 'D', '$')
//=============================================================================
//  Object heap type.
//=============================================================================
typedef LPVOID HOBJECTHEAP;

//=============================================================================
//  Object cleanup procedure.
//=============================================================================

typedef VOID (WINAPI *OBJECTPROC)(HOBJECTHEAP, LPVOID);

//=============================================================================
//  Network Monitor timers.
//=============================================================================
typedef struct _TIMER *HTIMER;

typedef VOID (WINAPI *BHTIMERPROC)(LPVOID);

HTIMER WINAPI BhSetTimer(BHTIMERPROC TimerProc, LPVOID InstData, DWORD TimeOut);

VOID   WINAPI BhKillTimer(HTIMER hTimer);

//=============================================================================
//  Network Monitor global error API.
//=============================================================================

DWORD  WINAPI BhGetLastError(VOID);

DWORD  WINAPI BhSetLastError(DWORD Error);

//=============================================================================
//  Object manager function prototypes.
//=============================================================================

HOBJECTHEAP WINAPI CreateObjectHeap(DWORD ObjectSize, OBJECTPROC ObjectProc);

HOBJECTHEAP WINAPI DestroyObjectHeap(HOBJECTHEAP hObjectHeap);

LPVOID      WINAPI AllocObject(HOBJECTHEAP hObjectHeap);

LPVOID      WINAPI FreeObject(HOBJECTHEAP hObjectHeap, LPVOID ObjectMemory);

DWORD       WINAPI GrowObjectHeap(HOBJECTHEAP hObjectHeap, DWORD nObjects);

DWORD       WINAPI GetObjectHeapSize(HOBJECTHEAP hObjectHeap);

VOID        WINAPI PurgeObjectHeap(HOBJECTHEAP hObjectHeap);

//=============================================================================
//  Memory functions.
//=============================================================================

LPVOID     WINAPI AllocMemory(SIZE_T size);

LPVOID     WINAPI ReallocMemory(LPVOID ptr, SIZE_T NewSize);

VOID       WINAPI FreeMemory(LPVOID ptr);

VOID       WINAPI TestMemory(LPVOID ptr);

SIZE_T     WINAPI MemorySize(LPVOID ptr);

HANDLE     WINAPI MemoryHandle(LPBYTE ptr);

//=============================================================================
//  Password API's.
//=============================================================================

HPASSWORD    WINAPI CreatePassword(LPSTR password);

VOID         WINAPI DestroyPassword(HPASSWORD hPassword);

ACCESSRIGHTS WINAPI ValidatePassword(HPASSWORD hPassword);

//=============================================================================
//  EXPRESSION API's
//=============================================================================

LPEXPRESSION         WINAPI InitializeExpression(LPEXPRESSION Expression);

LPPATTERNMATCH       WINAPI InitializePattern(LPPATTERNMATCH Pattern, LPVOID ptr, DWORD offset, DWORD length);

LPEXPRESSION         WINAPI AndExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

LPEXPRESSION         WINAPI OrExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

LPPATTERNMATCH       WINAPI NegatePattern(LPPATTERNMATCH Pattern);

LPADDRESSTABLE       WINAPI AdjustOperatorPrecedence(LPADDRESSTABLE AddressTable);

LPADDRESS            WINAPI NormalizeAddress(LPADDRESS Address);

LPADDRESSTABLE       WINAPI NormalizeAddressTable(LPADDRESSTABLE AddressTable);

//=============================================================================
//  MISC. API's
//=============================================================================

DWORD                WINAPI BhGetWindowsVersion(VOID);

BOOL                 WINAPI IsDaytona(VOID);

VOID                 _cdecl dprintf(LPSTR format, ...);

//=============================================================================
//=============================================================================
//  (BHTypes.h)
//=============================================================================
//=============================================================================
//=============================================================================
//  Unaligned base type definitions.
//=============================================================================
typedef VOID        UNALIGNED   *ULPVOID;
typedef BYTE        UNALIGNED   *ULPBYTE;
typedef WORD        UNALIGNED   *ULPWORD;
typedef DWORD       UNALIGNED   *ULPDWORD;
typedef CHAR        UNALIGNED   *ULPSTR;
typedef SYSTEMTIME  UNALIGNED   *ULPSYSTEMTIME;
//=============================================================================
//  Handle definitions.
//=============================================================================
typedef struct _PARSER *HPARSER;

typedef struct _CAPFRAMEDESC *HFRAME;

typedef struct _CAPTURE *HCAPTURE;

typedef struct _FILTER *HFILTER;

typedef struct _ADDRESSDB *HADDRESSDB;

typedef struct _PROTOCOL *HPROTOCOL;

typedef DWORD_PTR HPROPERTY;

typedef HPROTOCOL *LPHPROTOCOL;

//=============================================================================
//  GetTableSize() -- The following macro is used to calculate the actual
//                    length of Network Monitor variable-length table structures.
//
//  EXAMPLE:
//
//  GetTableSize(PROTOCOLTABLESIZE, 
//               ProtocolTable->nProtocols, 
//               sizeof(HPROTOCOL))
//=============================================================================
#define GetTableSize(TableBaseSize, nElements, ElementSize) ((TableBaseSize) + ((nElements) * (ElementSize)))
//=============================================================================
//  Object type identifiers.
//=============================================================================
typedef DWORD OBJECTTYPE;

#ifndef MAKE_IDENTIFIER
#define MAKE_IDENTIFIER(a, b, c, d)     ((DWORD) MAKELONG(MAKEWORD(a, b), MAKEWORD(c, d)))
#endif // MAKE_IDENTIFIER
#define HANDLE_TYPE_INVALID             MAKE_IDENTIFIER(-1, -1, -1, -1)
#define HANDLE_TYPE_CAPTURE             MAKE_IDENTIFIER('C', 'A', 'P', '$')
#define HANDLE_TYPE_PARSER              MAKE_IDENTIFIER('P', 'S', 'R', '$')
#define HANDLE_TYPE_ADDRESSDB           MAKE_IDENTIFIER('A', 'D', 'R', '$')
#define HANDLE_TYPE_PROTOCOL            MAKE_IDENTIFIER('P', 'R', 'T', '$')
#define HANDLE_TYPE_BUFFER              MAKE_IDENTIFIER('B', 'U', 'F', '$')
//=============================================================================
//  Network Monitor constant definitions.
//=============================================================================
#define INLINE  __inline
#define BHAPI   WINAPI
#define	MAX_NAME_LENGTH	( 16 )

#define	MAX_ADDR_LENGTH	( 6 )

//=============================================================================
//  Ethernet type (ETYPE) constant definitions.
//=============================================================================
#define	ETYPE_LOOP	( 0x9000 )

#define	ETYPE_3COM_NETMAP1	( 0x9001 )

#define	ETYPE_3COM_NETMAP2	( 0x9002 )

#define	ETYPE_IBM_RT	( 0x80d5 )

#define	ETYPE_NETWARE	( 0x8137 )

#define	ETYPE_XNS1	( 0x600 )

#define	ETYPE_XNS2	( 0x807 )

#define	ETYPE_3COM_NBP0	( 0x3c00 )

#define	ETYPE_3COM_NBP1	( 0x3c01 )

#define	ETYPE_3COM_NBP2	( 0x3c02 )

#define	ETYPE_3COM_NBP3	( 0x3c03 )

#define	ETYPE_3COM_NBP4	( 0x3c04 )

#define	ETYPE_3COM_NBP5	( 0x3c05 )

#define	ETYPE_3COM_NBP6	( 0x3c06 )

#define	ETYPE_3COM_NBP7	( 0x3c07 )

#define	ETYPE_3COM_NBP8	( 0x3c08 )

#define	ETYPE_3COM_NBP9	( 0x3c09 )

#define	ETYPE_3COM_NBP10	( 0x3c0a )

#define	ETYPE_IP	( 0x800 )

#define	ETYPE_ARP1	( 0x806 )

#define	ETYPE_ARP2	( 0x807 )

#define	ETYPE_RARP	( 0x8035 )

#define	ETYPE_TRLR0	( 0x1000 )

#define	ETYPE_TRLR1	( 0x1001 )

#define	ETYPE_TRLR2	( 0x1002 )

#define	ETYPE_TRLR3	( 0x1003 )

#define	ETYPE_TRLR4	( 0x1004 )

#define	ETYPE_TRLR5	( 0x1005 )

#define	ETYPE_PUP	( 0x200 )

#define	ETYPE_PUP_ARP	( 0x201 )

#define	ETYPE_APPLETALK_ARP	( 0x80f3 )

#define	ETYPE_APPLETALK_LAP	( 0x809b )

#define	ETYPE_SNMP	( 0x814c )

//=============================================================================
//  LLC (802.2) SAP constant definitions.
//=============================================================================
#define	SAP_SNAP	( 0xaa )

#define	SAP_BPDU	( 0x42 )

#define	SAP_IBM_NM	( 0xf4 )

#define	SAP_IBM_NETBIOS	( 0xf0 )

#define	SAP_SNA1	( 0x4 )

#define	SAP_SNA2	( 0x5 )

#define	SAP_SNA3	( 0x8 )

#define	SAP_SNA4	( 0xc )

#define	SAP_NETWARE1	( 0x10 )

#define	SAP_NETWARE2	( 0xe0 )

#define	SAP_NETWARE3	( 0xfe )

#define	SAP_IP	( 0x6 )

#define	SAP_X25	( 0x7e )

#define	SAP_RPL1	( 0xf8 )

#define	SAP_RPL2	( 0xfc )

#define	SAP_UB	( 0xfa )

#define	SAP_XNS	( 0x80 )

//=============================================================================
//  Property constants
//=============================================================================
// data types
#define	PROP_TYPE_VOID	( 0 )

#define	PROP_TYPE_SUMMARY	( 0x1 )

#define	PROP_TYPE_BYTE	( 0x2 )

#define	PROP_TYPE_WORD	( 0x3 )

#define	PROP_TYPE_DWORD	( 0x4 )

#define	PROP_TYPE_LARGEINT	( 0x5 )

#define	PROP_TYPE_ADDR	( 0x6 )

#define	PROP_TYPE_TIME	( 0x7 )

#define	PROP_TYPE_STRING	( 0x8 )

#define	PROP_TYPE_IP_ADDRESS	( 0x9 )

#define	PROP_TYPE_IPX_ADDRESS	( 0xa )

#define	PROP_TYPE_BYTESWAPPED_WORD	( 0xb )

#define	PROP_TYPE_BYTESWAPPED_DWORD	( 0xc )

#define	PROP_TYPE_TYPED_STRING	( 0xd )

#define	PROP_TYPE_RAW_DATA	( 0xe )

#define	PROP_TYPE_COMMENT	( 0xf )

#define	PROP_TYPE_SRCFRIENDLYNAME	( 0x10 )

#define	PROP_TYPE_DSTFRIENDLYNAME	( 0x11 )

#define	PROP_TYPE_TOKENRING_ADDRESS	( 0x12 )

#define	PROP_TYPE_FDDI_ADDRESS	( 0x13 )

#define	PROP_TYPE_ETHERNET_ADDRESS	( 0x14 )

#define	PROP_TYPE_OBJECT_IDENTIFIER	( 0x15 )

#define	PROP_TYPE_VINES_IP_ADDRESS	( 0x16 )

#define	PROP_TYPE_VAR_LEN_SMALL_INT	( 0x17 )

#define	PROP_TYPE_ATM_ADDRESS	( 0x18 )

#define	PROP_TYPE_1394_ADDRESS	( 0x19 )

// data qualifiers
#define	PROP_QUAL_NONE	( 0 )

#define	PROP_QUAL_RANGE	( 0x1 )

#define	PROP_QUAL_SET	( 0x2 )

#define	PROP_QUAL_BITFIELD	( 0x3 )

#define	PROP_QUAL_LABELED_SET	( 0x4 )

#define	PROP_QUAL_LABELED_BITFIELD	( 0x8 )

#define	PROP_QUAL_CONST	( 0x9 )

#define	PROP_QUAL_FLAGS	( 0xa )

#define	PROP_QUAL_ARRAY	( 0xb )

//=============================================================================
//  LARGEINT structure defined in winnt.h
//=============================================================================
typedef LARGE_INTEGER *LPLARGEINT;

typedef LARGE_INTEGER UNALIGNED *ULPLARGEINT;
//=============================================================================
//  Range structure.
//=============================================================================
typedef struct _RANGE
    {
    DWORD MinValue;
    DWORD MaxValue;
    } 	RANGE;

typedef RANGE *LPRANGE;

//=============================================================================
//  LABELED_BYTE structure
//=============================================================================
typedef struct _LABELED_BYTE
    {
    BYTE Value;
    LPSTR Label;
    } 	LABELED_BYTE;

typedef LABELED_BYTE *LPLABELED_BYTE;

//=============================================================================
//  LABELED_WORD structure
//=============================================================================
typedef struct _LABELED_WORD
    {
    WORD Value;
    LPSTR Label;
    } 	LABELED_WORD;

typedef LABELED_WORD *LPLABELED_WORD;

//=============================================================================
//  LABELED_DWORD structure
//=============================================================================
typedef struct _LABELED_DWORD
    {
    DWORD Value;
    LPSTR Label;
    } 	LABELED_DWORD;

typedef LABELED_DWORD *LPLABELED_DWORD;

//=============================================================================
//  LABELED_LARGEINT structure
//=============================================================================
typedef struct _LABELED_LARGEINT
    {
    LARGE_INTEGER Value;
    LPSTR Label;
    } 	LABELED_LARGEINT;

typedef LABELED_LARGEINT *LPLABELED_LARGEINT;

//=============================================================================
//  LABELED_SYSTEMTIME structure
//=============================================================================
typedef struct _LABELED_SYSTEMTIME
    {
    SYSTEMTIME Value;
    LPSTR Label;
    } 	LABELED_SYSTEMTIME;

typedef LABELED_SYSTEMTIME *LPLABELED_SYSTEMTIME;

//=============================================================================
//  LABELED_BIT structure
//=============================================================================
// BitNumber starts at 0, up to 256 bits.
typedef struct _LABELED_BIT
    {
    BYTE BitNumber;
    LPSTR LabelOff;
    LPSTR LabelOn;
    } 	LABELED_BIT;

typedef LABELED_BIT *LPLABELED_BIT;

//=============================================================================
//  TYPED_STRING structure
//=============================================================================
#define	TYPED_STRING_NORMAL	( 1 )

#define	TYPED_STRING_UNICODE	( 2 )

#define	TYPED_STRING_EXFLAG	( 1 )

// Typed Strings are always Ex, so to actually Ex we set fStringEx and put the Ex data in Byte
typedef struct _TYPED_STRING
{
    BYTE    StringType:7;
    BYTE    fStringEx:1;
    LPSTR   lpString;
    BYTE    Byte[0];
} TYPED_STRING;

typedef TYPED_STRING *LPTYPED_STRING;
//=============================================================================
//  OBJECT_IDENTIFIER structure
//=============================================================================
typedef struct _OBJECT_IDENTIFIER
    {
    DWORD Length;
    LPDWORD lpIdentifier;
    } 	OBJECT_IDENTIFIER;

typedef OBJECT_IDENTIFIER *LPOBJECT_IDENTIFIER;

//=============================================================================
//  Set structure.
//=============================================================================
typedef struct _SET
    {
    DWORD nEntries;
    union 
        {
        LPVOID lpVoidTable;
        LPBYTE lpByteTable;
        LPWORD lpWordTable;
        LPDWORD lpDwordTable;
        LPLARGEINT lpLargeIntTable;
        LPSYSTEMTIME lpSystemTimeTable;
        LPLABELED_BYTE lpLabeledByteTable;
        LPLABELED_WORD lpLabeledWordTable;
        LPLABELED_DWORD lpLabeledDwordTable;
        LPLABELED_LARGEINT lpLabeledLargeIntTable;
        LPLABELED_SYSTEMTIME lpLabeledSystemTimeTable;
        LPLABELED_BIT lpLabeledBit;
        } 	;
    } 	SET;

typedef SET *LPSET;

//=============================================================================
//  String table.
//=============================================================================
typedef struct _STRINGTABLE
{
    DWORD           nStrings;
    LPSTR           String[0];

} STRINGTABLE;

typedef STRINGTABLE *LPSTRINGTABLE;
#define STRINGTABLE_SIZE    sizeof(STRINGTABLE)

//=============================================================================
//  RECOGNIZEDATA structure.
//
//  This structure to keep track of the start of each recognized protocol.
//=============================================================================
typedef struct _RECOGNIZEDATA
    {
    WORD ProtocolID;
    WORD nProtocolOffset;
    LPVOID InstData;
    } 	RECOGNIZEDATA;

typedef RECOGNIZEDATA *LPRECOGNIZEDATA;

//=============================================================================
//  RECOGNIZEDATATABLE structure.
//
//  This structure to keep track of the start of each RECOGNIZEDATA structure
//=============================================================================
typedef struct _RECOGNIZEDATATABLE
{
    WORD            nRecognizeDatas;    //... number of RECOGNIZEDATA structures
    RECOGNIZEDATA   RecognizeData[0];   //... array of RECOGNIZEDATA structures follows

} RECOGNIZEDATATABLE;

typedef RECOGNIZEDATATABLE * LPRECOGNIZEDATATABLE;

//=============================================================================
//  Property information structure.
//=============================================================================
typedef struct _PROPERTYINFO
    {
    HPROPERTY hProperty;
    DWORD Version;
    LPSTR Label;
    LPSTR Comment;
    BYTE DataType;
    BYTE DataQualifier;
    union 
        {
        LPVOID lpExtendedInfo;
        LPRANGE lpRange;
        LPSET lpSet;
        DWORD Bitmask;
        DWORD Value;
        } 	;
    WORD FormatStringSize;
    LPVOID InstanceData;
    } 	PROPERTYINFO;

typedef PROPERTYINFO *LPPROPERTYINFO;

#define	PROPERTYINFO_SIZE	( sizeof( PROPERTYINFO  ) )

//=============================================================================
//  Property instance Extended structure.
//=============================================================================
typedef struct _PROPERTYINSTEX
{
    WORD        Length;         //... length of raw data in frame
    WORD        LengthEx;       //... number of bytes following
    ULPVOID     lpData;         //... pointer to raw data in frame

    union
    {
        BYTE            Byte[];     //... table of bytes follows
        WORD            Word[];     //... table of words follows
        DWORD           Dword[];    //... table of Dwords follows
        LARGE_INTEGER   LargeInt[]; //... table of LARGEINT structures to follow
        SYSTEMTIME      SysTime[];  //... table of SYSTEMTIME structures follows
        TYPED_STRING    TypedString;//... a typed_string that may have extended data
    };
} PROPERTYINSTEX;
typedef PROPERTYINSTEX *LPPROPERTYINSTEX;
typedef PROPERTYINSTEX UNALIGNED *ULPPROPERTYINSTEX;
#define PROPERTYINSTEX_SIZE     sizeof(PROPERTYINSTEX)
//=============================================================================
//  Property instance structure.
//=============================================================================
typedef struct _PROPERTYINST
{
    LPPROPERTYINFO          lpPropertyInfo;     // pointer to property info
    LPSTR                   szPropertyText;     // pointer to string description

    union
    {
        LPVOID              lpData;             // pointer to data
        ULPBYTE             lpByte;             // bytes
        ULPWORD             lpWord;             // words
        ULPDWORD            lpDword;            // dwords

        ULPLARGEINT         lpLargeInt;         // LargeInt
        ULPSYSTEMTIME       lpSysTime;          // pointer to SYSTEMTIME structures
        LPPROPERTYINSTEX    lpPropertyInstEx;   // pointer to propertyinstex (if DataLength = -1)
    };

    WORD                    DataLength;         // length of data, or flag for propertyinstex struct
    WORD                    Level   : 4  ;      // level information        ............1111
    WORD                    HelpID  : 12 ;      // context ID for helpfile  111111111111....
                     //    ---------------
                     // total of 16 bits == 1 WORD == DWORD ALIGNED structure
                            // Interpretation Flags:  Flags that define attach time information to the
                            // interpretation of the property.  For example, in RPC, the client can be
                            // Intel format and the server can be non-Intel format... thus the property
                            // database cannot describe the property at database creation time.
    DWORD                   IFlags;

} PROPERTYINST;
typedef PROPERTYINST *LPPROPERTYINST;
#define PROPERTYINST_SIZE   sizeof(PROPERTYINST)

// Flags passed at AttachPropertyInstance and AttachPropertyInstanceEx time in the IFlags field:
// flag for error condition ...............1
#define	IFLAG_ERROR	( 0x1 )

// is the WORD or DWORD byte non-Intel format at attach time?
#define	IFLAG_SWAPPED	( 0x2 )

// is the STRING UNICODE at attach time?
#define	IFLAG_UNICODE	( 0x4 )

//=============================================================================
//  Property instance table structure.
//=============================================================================
typedef struct _PROPERTYINSTTABLE
    {
    WORD nPropertyInsts;
    WORD nPropertyInstIndex;
    } 	PROPERTYINSTTABLE;

typedef PROPERTYINSTTABLE *LPPROPERTYINSTTABLE;

#define	PROPERTYINSTTABLE_SIZE	( sizeof( PROPERTYINSTTABLE  ) )

//=============================================================================
//  Property table structure.
//=============================================================================
typedef struct _PROPERTYTABLE
{
    LPVOID                  lpFormatBuffer;             //... Opaque.                       (PRIVATE)
    DWORD                   FormatBufferLength;         //... Opaque.                       (PRIVATE)
    DWORD                   nTotalPropertyInsts;        //... total number of propertyinstances in array
    LPPROPERTYINST          lpFirstPropertyInst;        //... array of property instances
    BYTE                    nPropertyInstTables;        //... total PropertyIndexTables following
    PROPERTYINSTTABLE       PropertyInstTable[0];       //... array of propertyinstance index table structures

} PROPERTYTABLE;

typedef PROPERTYTABLE *LPPROPERTYTABLE;

#define PROPERTYTABLE_SIZE sizeof(PROPERTYTABLE)
//=============================================================================
//  Protocol entry points.
//=============================================================================

typedef VOID    (WINAPI *REGISTER)(HPROTOCOL);

typedef VOID    (WINAPI *DEREGISTER)(HPROTOCOL);

typedef LPBYTE  (WINAPI *RECOGNIZEFRAME)(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);

typedef LPBYTE  (WINAPI *ATTACHPROPERTIES)(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);

typedef DWORD   (WINAPI *FORMATPROPERTIES)(HFRAME, ULPBYTE, ULPBYTE, DWORD, LPPROPERTYINST);

//=============================================================================
//  Protocol entry point structure.
//=============================================================================

typedef struct _ENTRYPOINTS
{
    REGISTER            Register;               //... Protocol Register() entry point.
    DEREGISTER          Deregister;             //... Protocol Deregister() entry point.
    RECOGNIZEFRAME      RecognizeFrame;         //... Protocol RecognizeFrame() entry point.
    ATTACHPROPERTIES    AttachProperties;       //... Protocol AttachProperties() entry point.
    FORMATPROPERTIES    FormatProperties;       //... Protocol FormatProperties() entry point.

} ENTRYPOINTS;

typedef ENTRYPOINTS *LPENTRYPOINTS;

#define ENTRYPOINTS_SIZE sizeof(ENTRYPOINTS)

//=============================================================================
//  Property database structure.
//=============================================================================
typedef struct _PROPERTYDATABASE
{
    DWORD           nProperties;                 //... Number of properties in database.
    LPPROPERTYINFO  PropertyInfo[0];             //... Array of property info pointers.

} PROPERTYDATABASE;
#define PROPERTYDATABASE_SIZE   sizeof(PROPERTYDATABASE)
typedef PROPERTYDATABASE *LPPROPERTYDATABASE;

//=============================================================================
//  Protocol info structure (PUBLIC portion of HPROTOCOL).
//=============================================================================
typedef struct _PROTOCOLINFO
{
    DWORD               ProtocolID;             //... Prootocol ID of owning protocol.
    LPPROPERTYDATABASE  PropertyDatabase;       //... Property database.
    BYTE                ProtocolName[16];       //... Protocol name.
    BYTE                HelpFile[16];           //... Optional helpfile name.
    BYTE                Comment[128];           //... Comment describing protocol.
} PROTOCOLINFO;
typedef PROTOCOLINFO *LPPROTOCOLINFO;
#define PROTOCOLINFO_SIZE   sizeof(PROTOCOLINFO)

//=============================================================================
//  Protocol Table.
//=============================================================================
typedef struct _PROTOCOLTABLE
    {
    DWORD nProtocols;
    HPROTOCOL hProtocol[ 1 ];
    } 	PROTOCOLTABLE;

typedef PROTOCOLTABLE *LPPROTOCOLTABLE;

#define	PROTOCOLTABLE_SIZE	( sizeof( PROTOCOLTABLE  ) - sizeof( HPROTOCOL  ) )

#define PROTOCOLTABLE_ACTUAL_SIZE(p) GetTableSize(PROTOCOLTABLE_SIZE, (p)->nProtocols, sizeof(HPROTOCOL))
//=============================================================================
//  AddressInfo structure
//=============================================================================
#define	SORT_BYADDRESS	( 0 )

#define	SORT_BYNAME	( 1 )

#define	PERMANENT_NAME	( 0x100 )

typedef struct _ADDRESSINFO
{
    ADDRESS        Address;
    WCHAR          Name[MAX_NAME_SIZE];
    DWORD          Flags;
    LPVOID         lpAddressInstData;

} ADDRESSINFO;
typedef struct _ADDRESSINFO *LPADDRESSINFO;
#define ADDRESSINFO_SIZE    sizeof(ADDRESSINFO)
//=============================================================================
//  AddressInfoTable
//=============================================================================
typedef struct _ADDRESSINFOTABLE
{
    DWORD         nAddressInfos;
    LPADDRESSINFO lpAddressInfo[0];

} ADDRESSINFOTABLE;
typedef ADDRESSINFOTABLE *LPADDRESSINFOTABLE;
#define ADDRESSINFOTABLE_SIZE   sizeof(ADDRESSINFOTABLE)
//=============================================================================
//  callback procedures.
//=============================================================================

typedef DWORD (WINAPI *FILTERPROC)(HCAPTURE, HFRAME, LPVOID);

//=============================================================================
//=============================================================================
//  (NMErr.h)
//=============================================================================
//=============================================================================
//  The operation succeeded.
#define	NMERR_SUCCESS	( 0 )

//  An error occured creating a memory-mapped file.
#define	NMERR_MEMORY_MAPPED_FILE_ERROR	( 1 )

//  The handle to a filter is invalid.
#define	NMERR_INVALID_HFILTER	( 2 )

//  Capturing has already been started.
#define	NMERR_CAPTURING	( 3 )

//  Capturing has not been started.
#define	NMERR_NOT_CAPTURING	( 4 )

//  The are no frames available.
#define	NMERR_NO_MORE_FRAMES	( 5 )

//  The buffer is too small to complete the operation.
#define	NMERR_BUFFER_TOO_SMALL	( 6 )

//  No protocol was able to recognize the frame.
#define	NMERR_FRAME_NOT_RECOGNIZED	( 7 )

//  The file already exists.
#define	NMERR_FILE_ALREADY_EXISTS	( 8 )

//  A needed device driver was not found or is not loaded.
#define	NMERR_DRIVER_NOT_FOUND	( 9 )

//  This address aready exists in the database.
#define	NMERR_ADDRESS_ALREADY_EXISTS	( 10 )

//  The frame handle is invalid.
#define	NMERR_INVALID_HFRAME	( 11 )

//  The protocol handle is invalid.
#define	NMERR_INVALID_HPROTOCOL	( 12 )

//  The property handle is invalid.
#define	NMERR_INVALID_HPROPERTY	( 13 )

//  The the object has been locked.  
#define	NMERR_LOCKED	( 14 )

//  A pop operation was attempted on an empty stack.
#define	NMERR_STACK_EMPTY	( 15 )

//  A push operation was attempted on an full stack.
#define	NMERR_STACK_OVERFLOW	( 16 )

//  There are too many protocols active.
#define	NMERR_TOO_MANY_PROTOCOLS	( 17 )

//  The file was not found.
#define	NMERR_FILE_NOT_FOUND	( 18 )

//  No memory was available.  Shut down windows to free up resources.
#define	NMERR_OUT_OF_MEMORY	( 19 )

//  The capture is already in the paused state.
#define	NMERR_CAPTURE_PAUSED	( 20 )

//  There are no buffers available or present.
#define	NMERR_NO_BUFFERS	( 21 )

//  There are already buffers present.
#define	NMERR_BUFFERS_ALREADY_EXIST	( 22 )

//  The object is not locked.
#define	NMERR_NOT_LOCKED	( 23 )

//  A integer type was out of range.
#define	NMERR_OUT_OF_RANGE	( 24 )

//  An object was locked too many times.
#define	NMERR_LOCK_NESTING_TOO_DEEP	( 25 )

//  A parser failed to load.
#define	NMERR_LOAD_PARSER_FAILED	( 26 )

//  A parser failed to unload.
#define	NMERR_UNLOAD_PARSER_FAILED	( 27 )

//  The address database handle is invalid.
#define	NMERR_INVALID_HADDRESSDB	( 28 )

//  The MAC address was not found in the database.
#define	NMERR_ADDRESS_NOT_FOUND	( 29 )

//  The network software was not found in the system.
#define	NMERR_NETWORK_NOT_PRESENT	( 30 )

//  There is no property database for a protocol.
#define	NMERR_NO_PROPERTY_DATABASE	( 31 )

//  A property was not found in the database.
#define	NMERR_PROPERTY_NOT_FOUND	( 32 )

//  The property database handle is in valid.
#define	NMERR_INVALID_HPROPERTYDB	( 33 )

//  The protocol has not been enabled.
#define	NMERR_PROTOCOL_NOT_ENABLED	( 34 )

//  The protocol DLL could not be found.
#define	NMERR_PROTOCOL_NOT_FOUND	( 35 )

//  The parser DLL is not valid.
#define	NMERR_INVALID_PARSER_DLL	( 36 )

//  There are no properties attached.
#define	NMERR_NO_ATTACHED_PROPERTIES	( 37 )

//  There are no frames in the buffer.
#define	NMERR_NO_FRAMES	( 38 )

//  The capture file format is not valid.
#define	NMERR_INVALID_FILE_FORMAT	( 39 )

//  The OS could not create a temporary file.
#define	NMERR_COULD_NOT_CREATE_TEMPFILE	( 40 )

//  There is not enough MS-DOS memory available.
#define	NMERR_OUT_OF_DOS_MEMORY	( 41 )

//  There are no protocols enabled.
#define	NMERR_NO_PROTOCOLS_ENABLED	( 42 )

//  The MAC type is invalid or unsupported.
#define	NMERR_UNKNOWN_MACTYPE	( 46 )

//  There is no routing information present in the MAC frame.
#define	NMERR_ROUTING_INFO_NOT_PRESENT	( 47 )

//  The network handle is invalid.
#define	NMERR_INVALID_HNETWORK	( 48 )

//  The network is already open.
#define	NMERR_NETWORK_ALREADY_OPENED	( 49 )

//  The network is not open.
#define	NMERR_NETWORK_NOT_OPENED	( 50 )

//  The frame was not found in the buffer.
#define	NMERR_FRAME_NOT_FOUND	( 51 )

//  There are no handles available.
#define	NMERR_NO_HANDLES	( 53 )

//  The network ID is invalid.
#define	NMERR_INVALID_NETWORK_ID	( 54 )

//  The capture handle is invalid.
#define	NMERR_INVALID_HCAPTURE	( 55 )

//  The protocol has already been enabled.
#define	NMERR_PROTOCOL_ALREADY_ENABLED	( 56 )

//  The filter expression is invalid.
#define	NMERR_FILTER_INVALID_EXPRESSION	( 57 )

//  A transmit error occured.
#define	NMERR_TRANSMIT_ERROR	( 58 )

//  The buffer handle is invalid.
#define	NMERR_INVALID_HBUFFER	( 59 )

//  The specified data is unknown or invalid.
#define	NMERR_INVALID_DATA	( 60 )

//  The MS-DOS/NDIS 2.0 network driver is not loaded.
#define	NMERR_MSDOS_DRIVER_NOT_LOADED	( 61 )

//  The Windows VxD/NDIS 3.0 network driver is not loaded.
#define	NMERR_WINDOWS_DRIVER_NOT_LOADED	( 62 )

//  The MS-DOS/NDIS 2.0 driver had an init-time failure.
#define	NMERR_MSDOS_DRIVER_INIT_FAILURE	( 63 )

//  The Windows/NDIS 3.0 driver had an init-time failure.
#define	NMERR_WINDOWS_DRIVER_INIT_FAILURE	( 64 )

//  The network driver is busy and cannot handle requests.
#define	NMERR_NETWORK_BUSY	( 65 )

//  The capture is not paused.
#define	NMERR_CAPTURE_NOT_PAUSED	( 66 )

//  The frame/packet length is not valid.
#define	NMERR_INVALID_PACKET_LENGTH	( 67 )

//  An internal exception occured.
#define	NMERR_INTERNAL_EXCEPTION	( 69 )

//  The MAC driver does not support promiscious mode.
#define	NMERR_PROMISCUOUS_MODE_NOT_SUPPORTED	( 70 )

//  The MAC driver failed to open.
#define	NMERR_MAC_DRIVER_OPEN_FAILURE	( 71 )

//  The protocol went off the end of the frame.
#define	NMERR_RUNAWAY_PROTOCOL	( 72 )

//  An asynchronous operation is still pending.
#define	NMERR_PENDING	( 73 )

//  Access is denied.
#define	NMERR_ACCESS_DENIED	( 74 )

//  The password handle is invalid.
#define	NMERR_INVALID_HPASSWORD	( 75 )

//  A bad parameter was detected.
#define	NMERR_INVALID_PARAMETER	( 76 )

//  An error occured reading the file.
#define	NMERR_FILE_READ_ERROR	( 77 )

//  An error occured writing to the file.
#define	NMERR_FILE_WRITE_ERROR	( 78 )

//  The protocol has not been registered
#define	NMERR_PROTOCOL_NOT_REGISTERED	( 79 )

//  The frame does not contain an IP address.
#define	NMERR_IP_ADDRESS_NOT_FOUND	( 80 )

//  The transmit request was cancelled.
#define	NMERR_TRANSMIT_CANCELLED	( 81 )

//  The operation cannot be performed on a capture with 1 or more locked frames.
#define	NMERR_LOCKED_FRAMES	( 82 )

//  A cancel transmit request was submitted but there were no transmits pending.
#define	NMERR_NO_TRANSMITS_PENDING	( 83 )

//  Path not found.
#define	NMERR_PATH_NOT_FOUND	( 84 )

//  A windows error has occured.
#define	NMERR_WINDOWS_ERROR	( 85 )

//  The handle to the frame has no frame number.
#define	NMERR_NO_FRAME_NUMBER	( 86 )

//  The frame is not associated with any capture.
#define	NMERR_FRAME_HAS_NO_CAPTURE	( 87 )

//  The frame is already associated with a capture.
#define	NMERR_FRAME_ALREADY_HAS_CAPTURE	( 88 )

//  The NAL is not remotable.
#define	NMERR_NAL_IS_NOT_REMOTE	( 89 )

//  The API is not supported
#define	NMERR_NOT_SUPPORTED	( 90 )

//  Network Monitor should discard the current frame. 
//  This error code is only used during a filtered SaveCapture() API call.
#define	NMERR_DISCARD_FRAME	( 91 )

//  Network Monitor should cancel the current save. 
//  This error code is only used during a filtered SaveCapture() API call.
#define	NMERR_CANCEL_SAVE_CAPTURE	( 92 )

//  The connection to the remote machine has been lost
#define	NMERR_LOST_CONNECTION	( 93 )

//  The media/mac type is not valid.
#define	NMERR_INVALID_MEDIA_TYPE	( 94 )

//  The Remote Agent is currently in use
#define	NMERR_AGENT_IN_USE	( 95 )

//  The request has timed out
#define	NMERR_TIMEOUT	( 96 )

//  The remote agent has been disconnected
#define	NMERR_DISCONNECTED	( 97 )

//  A timer required for operation failed creation
#define	NMERR_SETTIMER_FAILED	( 98 )

//  A network error occured.
#define	NMERR_NETWORK_ERROR	( 99 )

//  Frame callback procedure is not valid
#define	NMERR_INVALID_FRAMESPROC	( 100 )

//  Capture type specified is unknown
#define	NMERR_UNKNOWN_CAPTURETYPE	( 101 )

// The NPP is not connected to a network.
#define	NMERR_NOT_CONNECTED	( 102 )

// The NPP is already connected to a network.
#define	NMERR_ALREADY_CONNECTED	( 103 )

// The registry tag does not indicate a known configuration.
#define	NMERR_INVALID_REGISTRY_CONFIGURATION	( 104 )

// The NPP is currently configured for delayed capturing.
#define	NMERR_DELAYED	( 105 )

// The NPP is not currently configured for delayed capturing.
#define	NMERR_NOT_DELAYED	( 106 )

// The NPP is currently configured for real time capturing.
#define	NMERR_REALTIME	( 107 )

// The NPP is not currently configured for real time capturing.
#define	NMERR_NOT_REALTIME	( 108 )

// The NPP is currently configured for stats only capturing.
#define	NMERR_STATS_ONLY	( 109 )

// The NPP is not currently configured for stats only capturing.
#define	NMERR_NOT_STATS_ONLY	( 110 )

// The NPP is currently configured for transmitting.
#define	NMERR_TRANSMIT	( 111 )

// The NPP is not currently configured for transmitting.
#define	NMERR_NOT_TRANSMIT	( 112 )

// The NPP is currently transmitting
#define	NMERR_TRANSMITTING	( 113 )

// The specified capture file hard disk is not local
#define	NMERR_DISK_NOT_LOCAL_FIXED	( 114 )

// Could not create the default capture directory on the given disk
#define	NMERR_COULD_NOT_CREATE_DIRECTORY	( 115 )

// The default capture directory was not set in the registry:
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nm\Parameters\CapturePath
#define	NMERR_NO_DEFAULT_CAPTURE_DIRECTORY	( 116 )

//  The capture file is an uplevel version that this netmon does not understand
#define	NMERR_UPLEVEL_CAPTURE_FILE	( 117 )

//  An expert failed to load.
#define	NMERR_LOAD_EXPERT_FAILED	( 118 )

//  An expert failed to report its EXPERT_INFO structs.
#define	NMERR_EXPERT_REPORT_FAILED	( 119 )

//  Registry API call failed.
#define	NMERR_REG_OPERATION_FAILED	( 120 )

//  Registry API call failed.
#define	NMERR_NO_DLLS_FOUND	( 121 )

//  There are no conversation stats, they were not asked for.
#define	NMERR_NO_CONVERSATION_STATS	( 122 )

//  We have received a security response packet from a security monitor.
#define	NMERR_SECURITY_BREACH_CAPTURE_DELETED	( 123 )

//  The given frame failed the display filter.
#define	NMERR_FRAME_FAILED_FILTER	( 124 )

//  Netmon wants the Expert to stop running.
#define	NMERR_EXPERT_TERMINATE	( 125 )

//  Netmon needs the remote machine to be a server.
#define	NMERR_REMOTE_NOT_A_SERVER	( 126 )

//  Netmon needs the remote machine to be a server.
#define	NMERR_REMOTE_VERSION_OUTOFSYNC	( 127 )

//  The supplied group is an invalid handle
#define	NMERR_INVALID_EXPERT_GROUP	( 128 )

//  The supplied expert name cannot be found
#define	NMERR_INVALID_EXPERT_NAME	( 129 )

//  The supplied expert name cannot be found
#define	NMERR_INVALID_EXPERT_HANDLE	( 130 )

//  The supplied group name already exists
#define	NMERR_GROUP_NAME_ALREADY_EXISTS	( 131 )

//  The supplied group name is invalid
#define	NMERR_INVALID_GROUP_NAME	( 132 )

//  The supplied Expert is already in the group.  
#define	NMERR_EXPERT_ALREADY_IN_GROUP	( 133 )

//  The Expert cannot be deleted from the group because it is not in the group
#define	NMERR_EXPERT_NOT_IN_GROUP	( 134 )

//  The COM object has not been initialized
#define	NMERR_NOT_INITIALIZED	( 135 )

//  Cannot perform function to Root group
#define	NMERR_INVALID_GROUP_ROOT	( 136 )

//  Potential data structure mismatch between NdisNpp and Driver.
#define	NMERR_BAD_VERSION	( 137 )

// The NPP is currently configured for ESP capturing.
#define	NMERR_ESP	( 138 )

// The NPP is not currently configured for ESP capturing.
#define	NMERR_NOT_ESP	( 139 )

//=============================================================================
// Blob Errors
//=============================================================================
#define	NMERR_BLOB_NOT_INITIALIZED	( 1000 )

#define	NMERR_INVALID_BLOB	( 1001 )

#define	NMERR_UPLEVEL_BLOB	( 1002 )

#define	NMERR_BLOB_ENTRY_ALREADY_EXISTS	( 1003 )

#define	NMERR_BLOB_ENTRY_DOES_NOT_EXIST	( 1004 )

#define	NMERR_AMBIGUOUS_SPECIFIER	( 1005 )

#define	NMERR_BLOB_OWNER_NOT_FOUND	( 1006 )

#define	NMERR_BLOB_CATEGORY_NOT_FOUND	( 1007 )

#define	NMERR_UNKNOWN_CATEGORY	( 1008 )

#define	NMERR_UNKNOWN_TAG	( 1009 )

#define	NMERR_BLOB_CONVERSION_ERROR	( 1010 )

#define	NMERR_ILLEGAL_TRIGGER	( 1011 )

#define	NMERR_BLOB_STRING_INVALID	( 1012 )

//=============================================================================
// FINDER errors
//=============================================================================
#define	NMERR_UNABLE_TO_LOAD_LIBRARY	( 1013 )

#define	NMERR_UNABLE_TO_GET_PROCADDR	( 1014 )

#define	NMERR_CLASS_NOT_REGISTERED	( 1015 )

#define	NMERR_INVALID_REMOTE_COMPUTERNAME	( 1016 )

#define	NMERR_RPC_REMOTE_FAILURE	( 1017 )

#define	NMERR_NO_NPPS	( 3016 )

#define	NMERR_NO_MATCHING_NPPS	( 3017 )

#define	NMERR_NO_NPP_SELECTED	( 3018 )

#define	NMERR_NO_INPUT_BLOBS	( 3019 )

#define	NMERR_NO_NPP_DLLS	( 3020 )

#define	NMERR_NO_VALID_NPP_DLLS	( 3021 )

//=============================================================================
// Monitor errors
//=============================================================================
#define	NMERR_INVALID_LIST_INDEX	( 2000 )

#define	NMERR_INVALID_MONITOR	( 2001 )

#define	NMERR_INVALID_MONITOR_DLL	( 2002 )

#define	NMERR_UNABLE_TO_CREATE_MONITOR	( 2003 )

#define	NMERR_INVALID_MONITOR_CONFIG	( 2005 )

#define	NMERR_INVALID_INDEX	( 2006 )

#define	NMERR_MONITOR_ENABLED	( 2007 )

#define	NMERR_MONITOR_NOT_RUNNING	( 2008 )

#define	NMERR_MONITOR_IS_BUSY	( 2009 )

#define	NMERR_MCS_IS_BUSY	( 2010 )

#define	NMERR_NO_MONITORS	( 2011 )

#define	NMERR_ONE_MONITOR_PER_NETCARD	( 2012 )

#define	NMERR_CONFIGURATION_REQUIRED	( 2013 )

#define	NMERR_MONITOR_NOT_CONNECTED	( 2014 )

#define	NMERR_MONITOR_NOT_CONFIGURED	( 2015 )

#define	NMERR_MONITOR_CONFIG_FAILED	( 2016 )

#define	NMERR_MONITOR_INIT_FAILED	( 2017 )

#define	NMERR_MONITOR_FAULTED	( 2018 )

#define	NMERR_SAVE_ALL_FAILED	( 2019 )

#define	NMERR_SAVE_MONITOR_FAILED	( 2029 )

#define	NMERR_MONITOR_CONNECT_FAILED	( 2021 )

#define	NMERR_MONITOR_START_FAILED	( 2022 )

#define	NMERR_MONITOR_STOP_FAILED	( 2023 )

//=============================================================================
// Error Macros
//=============================================================================
#ifndef INLINE
#define INLINE __inline
#endif // INLINE
typedef LONG HRESULT;

// normal Network Monitor errors will be put into the code portion of an hresult
// for return from OLE objects:
// these two macros will help to create and crack the scode
INLINE HRESULT NMERR_TO_HRESULT( DWORD nmerror )
{
    HRESULT hResult;
    if (nmerror == NMERR_SUCCESS)
        hResult = NOERROR;
    else
        hResult = MAKE_HRESULT( SEVERITY_ERROR,FACILITY_ITF, (WORD)nmerror) ;

    return hResult;
}
//We use to decide whether the first bit was set to 1 or 0, not regarding 
//whether the result passed with a warning set in the low word.  Now we 
//disregard the first bit and pass back the warning.
INLINE DWORD HRESULT_TO_NMERR( HRESULT hResult )
{
    return HRESULT_CODE(hResult);
}
//=============================================================================
//=============================================================================
//  (BHFilter.h)
//=============================================================================
//=============================================================================
//============================================================================
//  types
//============================================================================
typedef HFILTER *LPHFILTER;

typedef DWORD FILTERACTIONTYPE;

typedef DWORD VALUETYPE;

// check for protocols existing in the frame.

// ProtocolPart
// this is the raw data for a Protocol based expression
//
// WHAT             FIELD          DESCRIPTION                  EXAMPLE
// ----             -----          -----------                  -------
// Count of Protocol(nPropertyDBs) Number of protocols to pass  5
// PropertyDB Table (PropertyDB)    Table of HPROTOCOL        SMB, LLC, MAC
//
// NOTE: the nPropertyDBs field may also be the following, which implies that
// all are selected but that none have actually been put into the structure
#define	PROTOCOL_NUM_ANY	( -1 )

typedef PROTOCOLTABLE PROTOCOLTABLETYPE;

typedef PROTOCOLTABLETYPE *LPPROTOCOLTABLETYPE;

// filter bits stores who passed what filter per frame to speed up
//  the filter process...  This is actually an array.
typedef DWORD FILTERBITS;

typedef FILTERBITS *LPFILTERBITS;

typedef SYSTEMTIME *LPTIME;

typedef SYSTEMTIME UNALIGNED * ULPTIME;
// The Filter Object is the basic unit of the postfix stack.
// I need to restart the convert property to value if the comparison does not match.
// To do this, I need the original pointer to the property.  Pull the hProperty out of
// the union so that the pointer to the property is saved.
typedef struct _FILTEROBJECT
{
    FILTERACTIONTYPE    Action;     // Object action, see codes below
    HPROPERTY           hProperty;  // property key
    union
    {
        VALUETYPE           Value;           // value of the object.
        HPROTOCOL           hProtocol;       // protocol key.
        LPVOID              lpArray;         // if array, length is ItemCount below.
        LPPROTOCOLTABLETYPE lpProtocolTable; // list of protocols to see if exist in frame.
        LPADDRESS           lpAddress;       // kernel type address, mac or ip
        ULPLARGEINT         lpLargeInt;      // Double DWORD used by NT
        ULPTIME             lpTime;          // pointer to SYSTEMTIME
        LPOBJECT_IDENTIFIER lpOID;           // pointer to OBJECT_IDENTIFIER

    };
    union
    {
        WORD            ByteCount;      // Number of BYTES!
        WORD            ByteOffset;     // offset for array compare
    };

    struct _FILTEROBJECT * pNext;   // reserved

} FILTEROBJECT;

typedef FILTEROBJECT * LPFILTEROBJECT;

#define FILTERINFO_SIZE (sizeof(FILTEROBJECT) )



typedef struct _FILTERDESC
{
    WORD            NumEntries;
    WORD            Flags;          // private
    LPFILTEROBJECT  lpStack;
    LPFILTEROBJECT  lpKeepLast;
    LPVOID          UIInstanceData; // UI specific information.
    LPFILTERBITS    lpFilterBits;   // cache who passed
    LPFILTERBITS    lpCheckBits;    // have we looked at it yet?
    
} FILTERDESC;

typedef FILTERDESC * LPFILTERDESC;

#define FILTERDESC_SIZE sizeof(FILTERDESC)
//============================================================================
//  Macros.
//============================================================================
#define FilterGetUIInstanceData(hfilt)         (((LPFILTERDESC)hfilt)->UIInstanceData)
#define FilterSetUIInstanceData(hfilt,inst)    (((LPFILTERDESC)hfilt)->UIInstanceData = (LPVOID)inst)
//============================================================================
//  defines
//============================================================================
#define	FILTERFREEPOOLSTART	( 20 )

#define	INVALIDELEMENT	( -1 )

#define	INVALIDVALUE	( ( VALUETYPE  )-9999 )

// use filter failed to check the return code on FilterFrame.
#define	FILTER_FAIL_WITH_ERROR	( -1 )

#define	FILTER_PASSED	( TRUE )

#define	FILTER_FAILED	( FALSE )

#define	FILTERACTION_INVALID	( 0 )

#define	FILTERACTION_PROPERTY	( 1 )

#define	FILTERACTION_VALUE	( 2 )

#define	FILTERACTION_STRING	( 3 )

#define	FILTERACTION_ARRAY	( 4 )

#define	FILTERACTION_AND	( 5 )

#define	FILTERACTION_OR	( 6 )

#define	FILTERACTION_XOR	( 7 )

#define	FILTERACTION_PROPERTYEXIST	( 8 )

#define	FILTERACTION_CONTAINSNC	( 9 )

#define	FILTERACTION_CONTAINS	( 10 )

#define	FILTERACTION_NOT	( 11 )

#define	FILTERACTION_EQUALNC	( 12 )

#define	FILTERACTION_EQUAL	( 13 )

#define	FILTERACTION_NOTEQUALNC	( 14 )

#define	FILTERACTION_NOTEQUAL	( 15 )

#define	FILTERACTION_GREATERNC	( 16 )

#define	FILTERACTION_GREATER	( 17 )

#define	FILTERACTION_LESSNC	( 18 )

#define	FILTERACTION_LESS	( 19 )

#define	FILTERACTION_GREATEREQUALNC	( 20 )

#define	FILTERACTION_GREATEREQUAL	( 21 )

#define	FILTERACTION_LESSEQUALNC	( 22 )

#define	FILTERACTION_LESSEQUAL	( 23 )

#define	FILTERACTION_PLUS	( 24 )

#define	FILTERACTION_MINUS	( 25 )

#define	FILTERACTION_ADDRESS	( 26 )

#define	FILTERACTION_ADDRESSANY	( 27 )

#define	FILTERACTION_FROM	( 28 )

#define	FILTERACTION_TO	( 29 )

#define	FILTERACTION_FROMTO	( 30 )

#define	FILTERACTION_AREBITSON	( 31 )

#define	FILTERACTION_AREBITSOFF	( 32 )

#define	FILTERACTION_PROTOCOLSEXIST	( 33 )

#define	FILTERACTION_PROTOCOLEXIST	( 34 )

#define	FILTERACTION_ARRAYEQUAL	( 35 )

#define	FILTERACTION_DEREFPROPERTY	( 36 )

#define	FILTERACTION_LARGEINT	( 37 )

#define	FILTERACTION_TIME	( 38 )

#define	FILTERACTION_ADDR_ETHER	( 39 )

#define	FILTERACTION_ADDR_TOKEN	( 40 )

#define	FILTERACTION_ADDR_FDDI	( 41 )

#define	FILTERACTION_ADDR_IPX	( 42 )

#define	FILTERACTION_ADDR_IP	( 43 )

#define	FILTERACTION_OID	( 44 )

#define	FILTERACTION_OID_CONTAINS	( 45 )

#define	FILTERACTION_OID_BEGINS_WITH	( 46 )

#define	FILTERACTION_OID_ENDS_WITH	( 47 )

#define	FILTERACTION_ADDR_VINES	( 48 )

#define	FILTERACTION_EXPRESSION	( 97 )

#define	FILTERACTION_BOOL	( 98 )

#define	FILTERACTION_NOEVAL	( 99 )

#define	FILTER_NO_MORE_FRAMES	( 0xffffffff )

#define	FILTER_CANCELED	( 0xfffffffe )

#define	FILTER_DIRECTION_NEXT	( TRUE )

#define	FILTER_DIRECTION_PREV	( FALSE )

//============================================================================
//  Helper functions.
//============================================================================
typedef BOOL (WINAPI *STATUSPROC)(DWORD, HCAPTURE, HFILTER, LPVOID);
//=============================================================================
//  FILTER API's.
//=============================================================================

HFILTER  WINAPI CreateFilter(VOID);

DWORD    WINAPI DestroyFilter(HFILTER hFilter);

HFILTER  WINAPI FilterDuplicate(HFILTER hFilter);

DWORD    WINAPI DisableParserFilter(HFILTER hFilter, HPARSER hParser);

DWORD    WINAPI EnableParserFilter(HFILTER hFilter, HPARSER hParser);

DWORD    WINAPI FilterAddObject(HFILTER hFilter, LPFILTEROBJECT lpFilterObject );

VOID     WINAPI FilterFlushBits(HFILTER hFilter);

DWORD    WINAPI FilterFrame(HFRAME hFrame, HFILTER hFilter, HCAPTURE hCapture);
    // returns -1 == check BH set last error
    //          0 == FALSE
    //          1 == TRUE

BOOL     WINAPI FilterAttachesProperties(HFILTER hFilter);

DWORD WINAPI FilterFindFrame (  HFILTER     hFilter,
                                HCAPTURE    hCapture,
                                DWORD       nFrame,
                                STATUSPROC  StatusProc,
                                LPVOID      UIInstance,
                                DWORD       TimeDelta,
                                BOOL        FilterDirection );

HFRAME FilterFindPropertyInstance ( HFRAME          hFrame, 
                                    HFILTER         hMasterFilter, 
                                    HCAPTURE        hCapture,
                                    HFILTER         hInstanceFilter,
                                    LPPROPERTYINST  *lpPropRestartKey,
                                    STATUSPROC      StatusProc,
                                    LPVOID          UIInstance,
                                    DWORD           TimeDelta,
                                    BOOL            FilterForward );


VOID WINAPI SetCurrentFilter(HFILTER);
HFILTER WINAPI GetCurrentFilter(VOID);

//=============================================================================
//=============================================================================
//  (Frame.h)
//=============================================================================
//=============================================================================
//=============================================================================
//  802.3 and ETHERNET MAC structure.
//=============================================================================
typedef struct _ETHERNET
{
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    union
    {
        WORD    Length;                 //... 802.3 length field.
        WORD    Type;                   //... Ethernet type field.
    };
    BYTE    Info[0];                    //... information field.

} ETHERNET;
typedef ETHERNET *LPETHERNET;
typedef ETHERNET UNALIGNED *ULPETHERNET;
#define ETHERNET_SIZE   sizeof(ETHERNET)
#define	ETHERNET_HEADER_LENGTH	( 14 )

#define	ETHERNET_DATA_LENGTH	( 0x5dc )

#define	ETHERNET_FRAME_LENGTH	( 0x5ea )

#define	ETHERNET_FRAME_TYPE	( 0x600 )

//=============================================================================
//  Header for NM_ATM Packets.
//=============================================================================

typedef struct _NM_ATM
    {
    UCHAR DstAddr[ 6 ];
    UCHAR SrcAddr[ 6 ];
    ULONG Vpi;
    ULONG Vci;
    } 	NM_ATM;

typedef NM_ATM *PNM_ATM;

typedef NM_ATM *UPNM_ATM;

#define NM_ATM_HEADER_LENGTH sizeof(NM_ATM)
typedef struct _NM_1394
    {
    UCHAR DstAddr[ 6 ];
    UCHAR SrcAddr[ 6 ];
    ULONGLONG VcId;
    } 	NM_1394;

typedef NM_1394 *PNM_1394;

typedef NM_1394 *UPNM_1394;

#define NM_1394_HEADER_LENGTH sizeof(NM_1394)
//=============================================================================
//  802.5 (TOKENRING) MAC structure.
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _TOKENRING
{
    BYTE    AccessCtrl;                 //... access control field.
    BYTE    FrameCtrl;                  //... frame control field.
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    union
    {
        BYTE    Info[0];                //... information field.
        WORD    RoutingInfo[0];         //... routing information field.
    };
} TOKENRING;

typedef TOKENRING *LPTOKENRING;
typedef TOKENRING UNALIGNED *ULPTOKENRING;
#define TOKENRING_SIZE  sizeof(TOKENRING)
#define	TOKENRING_HEADER_LENGTH	( 14 )

#define	TOKENRING_SA_ROUTING_INFO	( 0x80 )

#define	TOKENRING_SA_LOCAL	( 0x40 )

#define	TOKENRING_DA_LOCAL	( 0x40 )

#define	TOKENRING_DA_GROUP	( 0x80 )

#define	TOKENRING_RC_LENGTHMASK	( 0x1f )

#define	TOKENRING_BC_MASK	( 0xe0 )

#define	TOKENRING_TYPE_MAC	( 0 )

#define	TOKENRING_TYPE_LLC	( 0x40 )


#pragma pack(pop)
//=============================================================================
//  FDDI MAC structure.
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _FDDI
{
    BYTE    FrameCtrl;                  //... frame control field.
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    BYTE    Info[0];                    //... information field.

} FDDI;
#define FDDI_SIZE       sizeof(FDDI)
typedef FDDI *LPFDDI;
typedef FDDI UNALIGNED *ULPFDDI;
#define	FDDI_HEADER_LENGTH	( 13 )

#define	FDDI_TYPE_MAC	( 0 )

#define	FDDI_TYPE_LLC	( 0x10 )

#define	FDDI_TYPE_LONG_ADDRESS	( 0x40 )


#pragma pack(pop)
//=============================================================================
//  LLC (802.2)
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _LLC
    {
    BYTE dsap;
    BYTE ssap;
    struct 
        {
        union 
            {
            BYTE Command;
            BYTE NextSend;
            } 	;
        union 
            {
            BYTE NextRecv;
            BYTE Data[ 1 ];
            } 	;
        } 	ControlField;
    } 	LLC;

typedef LLC *LPLLC;

typedef LLC UNALIGNED *ULPLLC;
#define	LLC_SIZE	( sizeof( LLC  ) )


#pragma pack(pop)
//=============================================================================
//  Helper macros.
//=============================================================================

#define IsRoutingInfoPresent(f) ((((ULPTOKENRING) (f))->SrcAddr[0] & TOKENRING_SA_ROUTING_INFO) ? TRUE : FALSE)

#define GetRoutingInfoLength(f) (IsRoutingInfoPresent(f) \
                                 ? (((ULPTOKENRING) (f))->RoutingInfo[0] & TOKENRING_RC_LENGTHMASK) : 0)

//=============================================================================
//=============================================================================
//  (Parser.h)
//=============================================================================
//=============================================================================

//=============================================================================
//  Format Procedure Type.
//
//  NOTE: All format functions *must* be declared as WINAPIV not WINAPI!
//=============================================================================

typedef VOID (WINAPIV *FORMAT)(LPPROPERTYINST, ...);

//  The protocol recognized the frame and moved the pointer to end of its
//  protocol header. Network Monitor uses the protocols follow set to continue
//  parsing.
#define	PROTOCOL_STATUS_RECOGNIZED	( 0 )

//  The protocol did not recognized the frame and did not move the pointer
//  (i.e. the start data pointer which was passed in). Network Monitor uses the
//  protocols follow set to continue parsing.
#define	PROTOCOL_STATUS_NOT_RECOGNIZED	( 1 )

//  The protocol recognized the frame and claimed it all for itself,
//  and parsing terminates.
#define	PROTOCOL_STATUS_CLAIMED	( 2 )

//  The protocol recognized the frame and moved the pointer to end of its
//  protocol header. The current protocol requests that Network Monitor 
//  continue parsing at a known next protocol by returning the next protocols
//  handle back to Network Monitor. In this case, the follow of the current 
//  protocol, if any, is not used.
#define	PROTOCOL_STATUS_NEXT_PROTOCOL	( 3 )

//=============================================================================
//  Macros.
//=============================================================================

extern  BYTE HexTable[];

#define XCHG(x)         MAKEWORD( HIBYTE(x), LOBYTE(x) )

#define DXCHG(x)        MAKELONG( XCHG(HIWORD(x)), XCHG(LOWORD(x)) )

#define LONIBBLE(b) ((BYTE) ((b) & 0x0F))

#define HINIBBLE(b)     ((BYTE) ((b) >> 4))

#define HEX(b)          (HexTable[LONIBBLE(b)])

#define SWAPBYTES(w)    ((w) = XCHG(w))

#define SWAPWORDS(d)    ((d) = DXCHG(d))

//=============================================================================
//  All the MAC frame types combined.
//=============================================================================
typedef union _MACFRAME
{
    LPBYTE      MacHeader;              //... generic pointer.
    LPETHERNET  Ethernet;               //... ethernet pointer.
    LPTOKENRING Tokenring;              //... tokenring pointer.
    LPFDDI      Fddi;                   //... FDDI pointer.

} MACFRAME;
typedef MACFRAME *LPMACFRAME;

#define HOT_SIGNATURE       MAKE_IDENTIFIER('H', 'O', 'T', '$')
#define HOE_SIGNATURE       MAKE_IDENTIFIER('H', 'O', 'E', '$')
typedef struct _HANDOFFENTRY
    {
    DWORD hoe_sig;
    DWORD hoe_ProtIdentNumber;
    HPROTOCOL hoe_ProtocolHandle;
    DWORD hoe_ProtocolData;
    } 	HANDOFFENTRY;

typedef HANDOFFENTRY *LPHANDOFFENTRY;

typedef struct _HANDOFFTABLE
    {
    DWORD hot_sig;
    DWORD hot_NumEntries;
    LPHANDOFFENTRY hot_Entries;
    } 	HANDOFFTABLE;

typedef struct _HANDOFFTABLE *LPHANDOFFTABLE;

//=============================================================================
//  Parser helper macros.
//=============================================================================

INLINE LPVOID GetPropertyInstanceData(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength != (WORD) -1 )
    {
        return PropertyInst->lpData;
    }

    return (LPVOID) PropertyInst->lpPropertyInstEx->Byte;
}

#define GetPropertyInstanceDataValue(p, type)  ((type *) GetPropertyInstanceData(p))[0]

INLINE DWORD GetPropertyInstanceFrameDataLength(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength != (WORD) -1 )
    {
        return PropertyInst->DataLength;
    }

    return PropertyInst->lpPropertyInstEx->Length;
}

INLINE DWORD GetPropertyInstanceExDataLength(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength == (WORD) -1 )
    {
        PropertyInst->lpPropertyInstEx->Length;
    }

    return (WORD) -1;
}

//=============================================================================
//  Parser helper functions.
//=============================================================================

LPLABELED_WORD  WINAPI GetProtocolDescriptionTable(LPDWORD TableSize);

LPLABELED_WORD  WINAPI GetProtocolDescription(DWORD ProtocolID);

DWORD        WINAPI GetMacHeaderLength(LPVOID MacHeader, DWORD MacType);

DWORD        WINAPI GetLLCHeaderLength(LPLLC Frame);

DWORD        WINAPI GetEtype(LPVOID MacHeader, DWORD MacType);

DWORD        WINAPI GetSaps(LPVOID MacHeader, DWORD MacType);

BOOL         WINAPI IsLLCPresent(LPVOID MacHeader, DWORD MacType);

VOID         WINAPI CanonicalizeHexString(LPSTR hex, LPSTR dest, DWORD len);

void         WINAPI CanonHex(UCHAR * pDest, UCHAR * pSource, int iLen, BOOL fOx );

DWORD        WINAPI ByteToBinary(LPSTR string, DWORD ByteValue);

DWORD        WINAPI WordToBinary(LPSTR string, DWORD WordValue);

DWORD        WINAPI DwordToBinary(LPSTR string, DWORD DwordValue);

LPSTR        WINAPI AddressToString(LPSTR string, BYTE *lpAddress);

LPBYTE       WINAPI StringToAddress(BYTE *lpAddress, LPSTR string);

LPDWORD      WINAPI VarLenSmallIntToDword( LPBYTE  pValue, 
                                                  WORD    ValueLen, 
                                                  BOOL    fIsByteswapped,
                                                  LPDWORD lpDword );

LPBYTE       WINAPI LookupByteSetString (LPSET lpSet, BYTE Value);

LPBYTE       WINAPI LookupWordSetString (LPSET lpSet, WORD Value);

LPBYTE       WINAPI LookupDwordSetString (LPSET lpSet, DWORD Value);

DWORD        WINAPIV FormatByteFlags(LPSTR string, DWORD ByteValue, DWORD BitMask);

DWORD        WINAPIV FormatWordFlags(LPSTR string, DWORD WordValue, DWORD BitMask);

DWORD        WINAPIV FormatDwordFlags(LPSTR string, DWORD DwordValue, DWORD BitMask);

LPSTR        WINAPIV FormatTimeAsString(SYSTEMTIME *time, LPSTR string);

VOID         WINAPIV FormatLabeledByteSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledWordSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledDwordSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsByte(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsWord(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsDword(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatLabeledByteSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledWordSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledDwordSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsInt64(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsTime(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsString(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsHexString(LPPROPERTYINST lpPropertyInst);

// Parsers should NOT call LockFrame().  If a parser takes a lock and then gets
// faulted or returns without unlocking, it leaves the system in a state where
// it cannot change protocols or cut/copy frames.  Parsers should use ParserTemporaryLockFrame
// which grants a lock ONLY during the context of the api entry into the parser.  The 
// lock is released on exit from the parser for that frame.
ULPBYTE       WINAPI ParserTemporaryLockFrame(HFRAME hFrame);

LPVOID       WINAPI GetCCInstPtr(VOID);
VOID         WINAPI SetCCInstPtr(LPVOID lpCurCaptureInst);
LPVOID       WINAPI CCHeapAlloc(DWORD dwBytes, BOOL bZeroInit);
LPVOID       WINAPI CCHeapReAlloc(LPVOID lpMem, DWORD dwBytes, BOOL bZeroInit);
BOOL         WINAPI CCHeapFree(LPVOID lpMem);
SIZE_T       WINAPI CCHeapSize(LPVOID lpMem);

BOOL _cdecl BERGetInteger( ULPBYTE  pCurrentPointer,
                           ULPBYTE *ppValuePointer,
                           LPDWORD pHeaderLength,
                           LPDWORD pDataLength,
                           ULPBYTE *ppNext);
BOOL _cdecl BERGetString( ULPBYTE  pCurrentPointer,
                          ULPBYTE *ppValuePointer,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext);
BOOL _cdecl BERGetHeader( ULPBYTE  pCurrentPointer,
                          ULPBYTE  pTag,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext);

//=============================================================================
//  Parser Finder Structures.
//=============================================================================
#define	MAX_PROTOCOL_NAME_LEN	( 16 )

#define	MAX_PROTOCOL_COMMENT_LEN	( 256 )

// Handoff Value Format Base
typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0021
    {	HANDOFF_VALUE_FORMAT_BASE_UNKNOWN	= 0,
	HANDOFF_VALUE_FORMAT_BASE_DECIMAL	= 10,
	HANDOFF_VALUE_FORMAT_BASE_HEX	= 16
    } 	PF_HANDOFFVALUEFORMATBASE;

// PF_HANDOFFENTRY
typedef struct _PF_HANDOFFENTRY
    {
    char szIniFile[ 260 ];
    char szIniSection[ 260 ];
    char szProtocol[ 16 ];
    DWORD dwHandOffValue;
    PF_HANDOFFVALUEFORMATBASE ValueFormatBase;
    } 	PF_HANDOFFENTRY;

typedef PF_HANDOFFENTRY *PPF_HANDOFFENTRY;

// PF_HANDOFFSET
typedef struct _PF_HANDOFFSET
{
    DWORD           nEntries;
    PF_HANDOFFENTRY Entry[0];

} PF_HANDOFFSET;
typedef PF_HANDOFFSET* PPF_HANDOFFSET;
// FOLLOWENTRY
typedef struct _PF_FOLLOWENTRY
    {
    char szProtocol[ 16 ];
    } 	PF_FOLLOWENTRY;

typedef PF_FOLLOWENTRY *PPF_FOLLOWENTRY;

// PF_FOLLOWSET
typedef struct _PF_FOLLOWSET
{
    DWORD           nEntries;
    PF_FOLLOWENTRY  Entry[0];

} PF_FOLLOWSET;
typedef PF_FOLLOWSET* PPF_FOLLOWSET;

// PARSERINFO - contains information about a single parser
typedef struct _PF_PARSERINFO
{
    char szProtocolName[MAX_PROTOCOL_NAME_LEN];
    char szComment[MAX_PROTOCOL_COMMENT_LEN];
    char szHelpFile[MAX_PATH];

    PPF_FOLLOWSET pWhoCanPrecedeMe;
    PPF_FOLLOWSET pWhoCanFollowMe;

    PPF_HANDOFFSET pWhoHandsOffToMe;
    PPF_HANDOFFSET pWhoDoIHandOffTo;

} PF_PARSERINFO;
typedef PF_PARSERINFO* PPF_PARSERINFO;

// PF_PARSERDLLINFO - contains information about a single parser DLL
typedef struct _PF_PARSERDLLINFO
{             
//    char          szDLLName[MAX_PATH];
    DWORD         nParsers;
    PF_PARSERINFO ParserInfo[0];

} PF_PARSERDLLINFO;
typedef PF_PARSERDLLINFO* PPF_PARSERDLLINFO;
//=============================================================================
//=============================================================================
//  (IniLib.h)
//=============================================================================
//=============================================================================
#define	INI_PATH_LENGTH	( 256 )

#define	MAX_HANDOFF_ENTRY_LENGTH	( 80 )

#define	MAX_PROTOCOL_NAME	( 40 )

#define	NUMALLOCENTRIES	( 10 )

#define	RAW_INI_STR_LEN	( 200 )

#define PARSERS_SUBDIR              "PARSERS"
#define INI_EXTENSION               "INI"
#define BASE10_FORMAT_STR           "%ld=%s %ld"
#define BASE16_FORMAT_STR           "%lx=%s %lx"
// Given "XNS" or "TCP" or whatever BuildINIPath will return fully qual. path to "XNS.INI" or "TCP.INI"
LPSTR _cdecl BuildINIPath( char     *FullPath,
                           char     *IniFileName );

// Builds Handoff Set
DWORD     WINAPI CreateHandoffTable(LPSTR               secName,
                                    LPSTR               iniFile,
                                    LPHANDOFFTABLE *    hTable,
                                    DWORD               nMaxProtocolEntries,
                                    DWORD               base);

HPROTOCOL WINAPI GetProtocolFromTable(LPHANDOFFTABLE  hTable, // lp to Handoff Table...
                                      DWORD           ItemToFind,       // port number etc...
                                      PDWORD_PTR      lpInstData );   // inst data to give to next protocol

VOID      WINAPI DestroyHandoffTable( LPHANDOFFTABLE hTable );

BOOLEAN WINAPI IsRawIPXEnabled(LPSTR               secName,
                               LPSTR               iniFile,
                               LPSTR               CurProtocol );

//=============================================================================
//=============================================================================
//  (NMExpert.h)
//=============================================================================
//=============================================================================
#define	EXPERTSTRINGLENGTH	( 260 )

#define	EXPERTGROUPNAMELENGTH	( 25 )

// HEXPERTKEY tracks running experts. It is only used by experts for 
// self reference. It refers to a RUNNINGEXPERT (an internal only structure)..
typedef LPVOID HEXPERTKEY;

typedef HEXPERTKEY *PHEXPERTKEY;

// HEXPERT tracks loaded experts. It refers to an EXPERTENUMINFO.
typedef LPVOID HEXPERT;

typedef HEXPERT *PHEXPERT;

// HRUNNINGEXPERT tracks a currently running expert.
// It refers to a RUNNINGEXPERT (an internal only structure).
typedef LPVOID HRUNNINGEXPERT;

typedef HRUNNINGEXPERT *PHRUNNINGEXPERT;

// HGROUP tracks a group. It refers to a GROUPLIST (an internal only structure).
typedef LPVOID HGROUP;

typedef HGROUP *PHGROUP;

typedef struct _EXPERTENUMINFO * PEXPERTENUMINFO;
typedef struct _EXPERTCONFIG   * PEXPERTCONFIG;
typedef struct _EXPERTSTARTUPINFO * PEXPERTSTARTUPINFO;
// Definitions needed to call experts
#define EXPERTENTRY_REGISTER      "Register"
#define EXPERTENTRY_CONFIGURE     "Configure"
#define EXPERTENTRY_RUN           "Run"
typedef BOOL (WINAPI * PEXPERTREGISTERPROC)( PEXPERTENUMINFO );
typedef BOOL (WINAPI * PEXPERTCONFIGPROC)  ( HEXPERTKEY, PEXPERTCONFIG*, PEXPERTSTARTUPINFO, DWORD, HWND );
typedef BOOL (WINAPI * PEXPERTRUNPROC)     ( HEXPERTKEY, PEXPERTCONFIG, PEXPERTSTARTUPINFO, DWORD, HWND);
// EXPERTENUMINFO describes an expert that NetMon has loaded from disk. 
// It does not include any configuration or runtime information.
typedef struct _EXPERTENUMINFO
{
    char      szName[EXPERTSTRINGLENGTH];
    char      szVendor[EXPERTSTRINGLENGTH];
    char      szDescription[EXPERTSTRINGLENGTH];
    DWORD     Version;    
    DWORD     Flags;
    char      szDllName[MAX_PATH];      // private, dont' touch
    HEXPERT   hExpert;                  // private, don't touch
    HINSTANCE hModule;                  // private, don't touch
    PEXPERTREGISTERPROC pRegisterProc;  // private, don't touch
    PEXPERTCONFIGPROC   pConfigProc;    // private, don't touch
    PEXPERTRUNPROC      pRunProc;       // private, don't touch

} EXPERTENUMINFO;
typedef EXPERTENUMINFO * PEXPERTENUMINFO;
#define	EXPERT_ENUM_FLAG_CONFIGURABLE	( 0x1 )

#define	EXPERT_ENUM_FLAG_VIEWER_PRIVATE	( 0x2 )

#define	EXPERT_ENUM_FLAG_NO_VIEWER	( 0x4 )

#define	EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_SUMMARY	( 0x10 )

#define	EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_DETAIL	( 0x20 )

// GROUPINFO
// This is an accociation between a group name and its handle.
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0022
    {
    char szGroupName[ 26 ];
    HGROUP hGroup;
    } 	GROUPINFO;

typedef GROUPINFO *PGROUPINFO;

// EXPERTSTARTUPINFO
// This gives the Expert an indication of where he came from.
// Note: if the lpPropertyInst->PropertyInfo->DataQualifier == PROP_QUAL_FLAGS
// then the sBitField structure is filled in
typedef struct _EXPERTSTARTUPINFO
{
    DWORD           Flags;
    HCAPTURE        hCapture;
    char            szCaptureFile[MAX_PATH];
    DWORD           dwFrameNumber;
    HPROTOCOL       hProtocol;

    LPPROPERTYINST  lpPropertyInst;

    struct
    {
        BYTE    BitNumber;
        BOOL    bOn;
    } sBitfield;

} EXPERTSTARTUPINFO;
// EXPERTCONFIG
// This is a generic holder for an Expert's config data.
typedef struct  _EXPERTCONFIG
{
    DWORD   RawConfigLength;
    BYTE    RawConfigData[0];

} EXPERTCONFIG;
typedef EXPERTCONFIG * PEXPERTCONFIG;
// CONFIGUREDEXPERT
// This structure associates a loaded expert with its configuration data.
typedef struct
{
    HEXPERT         hExpert;
    DWORD           StartupFlags;
    PEXPERTCONFIG   pConfig;
} CONFIGUREDEXPERT;
typedef CONFIGUREDEXPERT * PCONFIGUREDEXPERT;
// EXPERTFRAMEDESCRIPTOR - passed back to the expert to fulfil the request for a frame
typedef struct
{
    DWORD                FrameNumber;         // Frame Number.
    HFRAME               hFrame;              // Handle to the frame.
    ULPFRAME             pFrame;              // pointer to frame.
    LPRECOGNIZEDATATABLE lpRecognizeDataTable;// pointer to table of RECOGNIZEDATA structures.
    LPPROPERTYTABLE      lpPropertyTable;     // pointer to property table.

} EXPERTFRAMEDESCRIPTOR;
typedef EXPERTFRAMEDESCRIPTOR * LPEXPERTFRAMEDESCRIPTOR;
#define	GET_SPECIFIED_FRAME	( 0 )

#define	GET_FRAME_NEXT_FORWARD	( 1 )

#define	GET_FRAME_NEXT_BACKWARD	( 2 )

#define	FLAGS_DEFER_TO_UI_FILTER	( 0x1 )

#define	FLAGS_ATTACH_PROPERTIES	( 0x2 )

// EXPERTSTATUSENUM
// gives the possible values for the status field in the EXPERTSTATUS structure
typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0023
    {	EXPERTSTATUS_INACTIVE	= 0,
	EXPERTSTATUS_STARTING	= EXPERTSTATUS_INACTIVE + 1,
	EXPERTSTATUS_RUNNING	= EXPERTSTATUS_STARTING + 1,
	EXPERTSTATUS_PROBLEM	= EXPERTSTATUS_RUNNING + 1,
	EXPERTSTATUS_ABORTED	= EXPERTSTATUS_PROBLEM + 1,
	EXPERTSTATUS_DONE	= EXPERTSTATUS_ABORTED + 1
    } 	EXPERTSTATUSENUMERATION;

// EXPERTSUBSTATUS bitfield 
// gives the possible values for the substatus field in the EXPERTSTATUS structure
#define	EXPERTSUBSTATUS_ABORTED_USER	( 0x1 )

#define	EXPERTSUBSTATUS_ABORTED_LOAD_FAIL	( 0x2 )

#define	EXPERTSUBSTATUS_ABORTED_THREAD_FAIL	( 0x4 )

#define	EXPERTSUBSTATUS_ABORTED_BAD_ENTRY	( 0x8 )

// EXPERTSTATUS
// Indicates the current status of a running expert.
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0024
    {
    EXPERTSTATUSENUMERATION Status;
    DWORD SubStatus;
    DWORD PercentDone;
    DWORD Frame;
    char szStatusText[ 260 ];
    } 	EXPERTSTATUS;

typedef EXPERTSTATUS *PEXPERTSTATUS;

// EXPERT STARTUP FLAGS
#define	EXPERT_STARTUP_FLAG_USE_STARTUP_DATA_OVER_CONFIG_DATA	( 0x1 )

//=============================================================================
//=============================================================================
//  (NetMon.h)
//=============================================================================
//=============================================================================
//  A frame with no number contains this value as its frame number.
#define	INVALID_FRAME_NUMBER	( ( DWORD  )-1 )

//=============================================================================
//  Capture file flags.
//=============================================================================
#define CAPTUREFILE_OPEN                OPEN_EXISTING
#define CAPTUREFILE_CREATE              CREATE_NEW
//=============================================================================
//  CAPTURE CONTEXT API's.
//=============================================================================

LPSYSTEMTIME         WINAPI GetCaptureTimeStamp(HCAPTURE hCapture);

DWORD                WINAPI GetCaptureMacType(HCAPTURE hCapture);

DWORD                WINAPI GetCaptureTotalFrames(HCAPTURE hCapture);

LPSTR                WINAPI GetCaptureComment(HCAPTURE hCapture);

//=============================================================================
//  FRAME HELP API's.
//=============================================================================

DWORD                WINAPI MacTypeToAddressType(DWORD MacType);

DWORD                WINAPI AddressTypeToMacType(DWORD AddressType);

DWORD                WINAPI GetFrameDstAddressOffset(HFRAME hFrame, DWORD AddressType, LPDWORD AddressLength);

DWORD                WINAPI GetFrameSrcAddressOffset(HFRAME hFrame, DWORD AddressType, LPDWORD AddressLength);

HCAPTURE             WINAPI GetFrameCaptureHandle(HFRAME hFrame);


DWORD                WINAPI GetFrameDestAddress(HFRAME       hFrame,
                                                       LPADDRESS    lpAddress,
                                                       DWORD        AddressType,
                                                       DWORD        Flags);

DWORD                WINAPI GetFrameSourceAddress(HFRAME     hFrame,
                                                         LPADDRESS  lpAddress,
                                                         DWORD      AddressType,
                                                         DWORD      Flags);

DWORD                WINAPI GetFrameMacHeaderLength(HFRAME hFrame);

BOOL                 WINAPI CompareFrameDestAddress(HFRAME hFrame, LPADDRESS lpAddress);

BOOL                 WINAPI CompareFrameSourceAddress(HFRAME hFrame, LPADDRESS lpAddress);

DWORD                WINAPI GetFrameLength(HFRAME hFrame);

DWORD                WINAPI GetFrameStoredLength(HFRAME hFrame);

DWORD                WINAPI GetFrameMacType(HFRAME hFrame);

DWORD                WINAPI GetFrameMacHeaderLength(HFRAME hFrame);

DWORD                WINAPI GetFrameNumber(HFRAME hFrame);

__int64              WINAPI GetFrameTimeStamp(HFRAME hFrame);

ULPFRAME             WINAPI GetFrameFromFrameHandle(HFRAME hFrame);

//=============================================================================
//  FRAME API's.
//=============================================================================

HFRAME               WINAPI ModifyFrame(HCAPTURE hCapture,
                                               DWORD    FrameNumber,
                                               LPBYTE   FrameData,
                                               DWORD    FrameLength,
                                               __int64  TimeStamp);

HFRAME               WINAPI FindNextFrame(HFRAME hCurrentFrame,
                                                LPSTR ProtocolName,
                                                LPADDRESS lpDesstAddress,
                                                LPADDRESS lpSrcAddress,
                                                LPWORD ProtocolOffset,
                                                DWORD  OriginalFrameNumber,
                                                DWORD  nHighestFrame);

HFRAME               WINAPI FindPreviousFrame(HFRAME hCurrentFrame,
                                                    LPSTR ProtocolName,
                                                    LPADDRESS lpDstAddress,
                                                    LPADDRESS lpSrcAddress,
                                                    LPWORD ProtocolOffset,
                                                    DWORD  OriginalFrameNumber,
                                                    DWORD  nLowestFrame );

HCAPTURE             WINAPI GetFrameCaptureHandle(HFRAME);

HFRAME               WINAPI GetFrame(HCAPTURE hCapture, DWORD FrameNumber);

LPRECOGNIZEDATATABLE WINAPI GetFrameRecognizeData(HFRAME hFrame);

//=============================================================================
//  Protocol API's.
//=============================================================================

HPROTOCOL            WINAPI CreateProtocol(LPSTR ProtocolName,
                                                  LPENTRYPOINTS lpEntryPoints,
                                                  DWORD cbEntryPoints);

VOID                 WINAPI DestroyProtocol(HPROTOCOL hProtocol);

LPPROTOCOLINFO       WINAPI GetProtocolInfo(HPROTOCOL hProtocol);

HPROPERTY            WINAPI GetProperty(HPROTOCOL hProtocol, LPSTR PropertyName);

HPROTOCOL            WINAPI GetProtocolFromName(LPSTR ProtocolName);

DWORD                WINAPI GetProtocolStartOffset(HFRAME hFrame, LPSTR ProtocolName);

DWORD                WINAPI GetProtocolStartOffsetHandle(HFRAME hFrame, HPROTOCOL hProtocol);

DWORD                WINAPI GetPreviousProtocolOffsetByName(HFRAME hFrame,
                                                                   DWORD  dwStartOffset,
                                                                   LPSTR  szProtocolName,
                                                                   DWORD* pdwPreviousOffset);

LPPROTOCOLTABLE      WINAPI GetEnabledProtocols(HCAPTURE hCapture);

//=============================================================================
//  Property API's.
//=============================================================================

DWORD                WINAPI CreatePropertyDatabase(HPROTOCOL hProtocol, DWORD nProperties);

DWORD                WINAPI DestroyPropertyDatabase(HPROTOCOL hProtocol);

HPROPERTY            WINAPI AddProperty(HPROTOCOL hProtocol, LPPROPERTYINFO PropertyInfo);

BOOL                 WINAPI AttachPropertyInstance(HFRAME    hFrame,
                                                          HPROPERTY hProperty,
                                                          DWORD     Length,
                                                          ULPVOID   lpData,
                                                          DWORD     HelpID,
                                                          DWORD     Level,
                                                          DWORD     IFlags);

BOOL                 WINAPI AttachPropertyInstanceEx(HFRAME      hFrame,
                                                            HPROPERTY   hProperty,
                                                            DWORD       Length,
                                                            ULPVOID     lpData,
                                                            DWORD       ExLength,
                                                            ULPVOID     lpExData,
                                                            DWORD       HelpID,
                                                            DWORD       Level,
                                                            DWORD       IFlags);

LPPROPERTYINST       WINAPI FindPropertyInstance(HFRAME hFrame, HPROPERTY hProperty);

LPPROPERTYINST       WINAPI FindPropertyInstanceRestart (HFRAME      hFrame, 
                                                                HPROPERTY   hProperty, 
                                                                LPPROPERTYINST *lpRestartKey, 
                                                                BOOL        DirForward );

LPPROPERTYINFO       WINAPI GetPropertyInfo(HPROPERTY hProperty);

LPSTR                WINAPI GetPropertyText(HFRAME hFrame, LPPROPERTYINST lpPI, LPSTR szBuffer, DWORD BufferSize);

DWORD                WINAPI ResetPropertyInstanceLength( LPPROPERTYINST lpProp, 
                                                                WORD nOrgLen, 
                                                                WORD nNewLen );
//=============================================================================
//  MISC. API's.
//=============================================================================

DWORD                WINAPI GetCaptureCommentFromFilename(LPSTR lpFilename, LPSTR lpComment, DWORD BufferSize);

int                  WINAPI CompareAddresses(LPADDRESS lpAddress1, LPADDRESS lpAddress2);

DWORD                WINAPIV FormatPropertyInstance(LPPROPERTYINST lpPropertyInst, ...);

SYSTEMTIME *         WINAPI AdjustSystemTime(SYSTEMTIME *SystemTime, __int64 TimeDelta);

//=============================================================================
//  EXPERT API's for use by Experts
//=============================================================================

DWORD WINAPI ExpertGetFrame( IN HEXPERTKEY hExpertKey,
                                    IN DWORD Direction,
                                    IN DWORD RequestFlags,
                                    IN DWORD RequestedFrameNumber,
                                    IN HFILTER hFilter,
                                    OUT LPEXPERTFRAMEDESCRIPTOR pEFrameDescriptor);

LPVOID WINAPI ExpertAllocMemory( IN  HEXPERTKEY hExpertKey,
                                        IN  SIZE_T nBytes,
                                        OUT DWORD* pError);

LPVOID WINAPI ExpertReallocMemory( IN  HEXPERTKEY hExpertKey,
                                          IN  LPVOID pOriginalMemory,
                                          IN  SIZE_T nBytes,
                                          OUT DWORD* pError);

DWORD WINAPI ExpertFreeMemory( IN HEXPERTKEY hExpertKey,
                                      IN LPVOID pOriginalMemory);

SIZE_T WINAPI ExpertMemorySize( IN HEXPERTKEY hExpertKey,
                                       IN LPVOID pOriginalMemory);

DWORD WINAPI ExpertIndicateStatus( IN HEXPERTKEY              hExpertKey, 
                                          IN EXPERTSTATUSENUMERATION Status,
                                          IN DWORD                   SubStatus,
                                          IN const char *            szText,
                                          IN LONG                    PercentDone);

DWORD WINAPI ExpertSubmitEvent( IN HEXPERTKEY   hExpertKey,
                                       IN PNMEVENTDATA pExpertEvent);

DWORD WINAPI ExpertGetStartupInfo( IN  HEXPERTKEY hExpertKey,
                                          OUT PEXPERTSTARTUPINFO pExpertStartupInfo);

//=============================================================================
//  DEBUG API's.
//=============================================================================
#ifdef DEBUG

//=============================================================================
//  BreakPoint() macro.
//=============================================================================
// We do not want breakpoints in our code any more...
// so we are defining DebugBreak(), usually a system call, to be
// just a dprintf. BreakPoint() is still defined as DebugBreak().

#ifdef DebugBreak
#undef DebugBreak
#endif // DebugBreak

#define DebugBreak()    dprintf("DebugBreak Called at %s:%s", __FILE__, __LINE__);
#define BreakPoint()    DebugBreak()

#endif // DEBUG
//=============================================================================
//=============================================================================
//  (NMBlob.h)
//=============================================================================
//=============================================================================
//=============================================================================
// Blob Constants
//=============================================================================
#define	INITIAL_RESTART_KEY	( 0xffffffff )

//=============================================================================
// Blob Core Helper Routines 
//=============================================================================
DWORD _cdecl CreateBlob(HBLOB * phBlob);

DWORD _cdecl DestroyBlob(HBLOB hBlob);

DWORD _cdecl SetStringInBlob(HBLOB  hBlob,         
                      const char * pOwnerName,    
                      const char * pCategoryName, 
                      const char * pTagName,      
                      const char * pString);      

DWORD _cdecl GetStringFromBlob(HBLOB   hBlob,
                        const char *  pOwnerName,
                        const char *  pCategoryName,
                        const char *  pTagName,
                        const char ** ppString);

DWORD _cdecl GetStringsFromBlob(HBLOB   hBlob,
                         const char * pRequestedOwnerName,
                         const char * pRequestedCategoryName,
                         const char * pRequestedTagName,
                         const char ** ppReturnedOwnerName,
                         const char ** ppReturnedCategoryName,
                         const char ** ppReturnedTagName,
                         const char ** ppReturnedString,
                         DWORD *       pRestartKey);

DWORD _cdecl RemoveFromBlob(HBLOB   hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName);

DWORD _cdecl LockBlob(HBLOB hBlob);

DWORD _cdecl UnlockBlob(HBLOB hBlob);

DWORD _cdecl FindUnknownBlobCategories( HBLOB hBlob,
                                 const char *  pOwnerName,
                                 const char *  pKnownCategoriesTable[],
                                 HBLOB hUnknownCategoriesBlob);

//=============================================================================
// Blob Helper Routines 
//=============================================================================
DWORD _cdecl MergeBlob(HBLOB hDstBlob,
                HBLOB hSrcBlob); 

DWORD _cdecl DuplicateBlob (HBLOB hSrcBlob,
                     HBLOB *hBlobThatWillBeCreated ); 

DWORD _cdecl WriteBlobToFile(HBLOB  hBlob,
                      const char * pFileName);

DWORD _cdecl ReadBlobFromFile(HBLOB* phBlob,
                       const char * pFileName);

DWORD _cdecl RegCreateBlobKey(HKEY hkey, const char* szBlobName, HBLOB hBlob);

DWORD _cdecl RegOpenBlobKey(HKEY hkey, const char* szBlobName, HBLOB* phBlob);

DWORD _cdecl MarshalBlob(HBLOB hBlob, DWORD* pSize, BYTE** ppBytes);

DWORD _cdecl UnMarshalBlob(HBLOB* phBlob, DWORD Size, BYTE* pBytes);

DWORD _cdecl SetDwordInBlob(HBLOB hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName,
                     DWORD         Dword);

DWORD _cdecl GetDwordFromBlob(HBLOB   hBlob,
                       const char *  pOwnerName,
                       const char *  pCategoryName,
                       const char *  pTagName,
                       DWORD      *  pDword);

DWORD _cdecl SetBoolInBlob(HBLOB   hBlob,
                    const char *  pOwnerName,
                    const char *  pCategoryName,
                    const char *  pTagName,
                    BOOL          Bool);

DWORD _cdecl GetBoolFromBlob(HBLOB   hBlob,
                      const char *  pOwnerName,
                      const char *  pCategoryName,
                      const char *  pTagName,
                      BOOL       *  pBool);

DWORD _cdecl GetMacAddressFromBlob(HBLOB   hBlob,
                            const char *  pOwnerName,
                            const char *  pCategoryName,
                            const char *  pTagName,
                            BYTE *  pMacAddress);

DWORD _cdecl SetMacAddressInBlob(HBLOB   hBlob,
                          const char *  pOwnerName,
                          const char *  pCategoryName,
                          const char *  pTagName,
                          const BYTE *  pMacAddress);

DWORD _cdecl FindUnknownBlobTags( HBLOB hBlob,
                           const char *  pOwnerName,
                           const char *  pCategoryName,
                           const char *  pKnownTagsTable[],
                           HBLOB hUnknownTagsBlob);

//=============================================================================
// Blob NPP Helper Routines
//=============================================================================
DWORD _cdecl SetNetworkInfoInBlob(HBLOB hBlob, 
                           LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl GetNetworkInfoFromBlob(HBLOB hBlob, 
                             LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl CreateNPPInterface ( HBLOB hBlob,
                           REFIID iid,
                           void ** ppvObject);

DWORD _cdecl SetClassIDInBlob(HBLOB hBlob,
                       const char* pOwnerName,
                       const char* pCategoryName,
                       const char* pTagName,
                       const CLSID*  pClsID);

DWORD _cdecl GetClassIDFromBlob(HBLOB hBlob,
                         const char* pOwnerName,
                         const char* pCategoryName,
                         const char* pTagName,
                         CLSID * pClsID);

DWORD _cdecl SetNPPPatternFilterInBlob( HBLOB hBlob,
                                 LPEXPRESSION pExpression,
                                 HBLOB hErrorBlob);

DWORD _cdecl GetNPPPatternFilterFromBlob( HBLOB hBlob,
                                   LPEXPRESSION pExpression,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPAddressFilterInBlob( HBLOB hBlob,
                                 LPADDRESSTABLE pAddressTable);

DWORD _cdecl GetNPPAddressFilterFromBlob( HBLOB hBlob,
                                   LPADDRESSTABLE pAddressTable,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPTriggerInBlob( HBLOB hBlob,
                           LPTRIGGER   pTrigger,
                           HBLOB hErrorBlob);

DWORD _cdecl GetNPPTriggerFromBlob( HBLOB hBlob,
                             LPTRIGGER   pTrigger,
                             HBLOB hErrorBlob);

DWORD _cdecl SetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   nSaps,
                           WORD   nEtypes,
                           LPBYTE lpSapTable,
                           LPWORD lpEtypeTable,
                           DWORD  FilterFlags,
                           HBLOB  hErrorBlob);

DWORD _cdecl GetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   *pnSaps,
                           WORD   *pnEtypes,
                           LPBYTE *ppSapTable,
                           LPWORD *ppEtypeTable,
                           DWORD  *pFilterFlags,
                           HBLOB  hErrorBlob);

// GetNPPMacTypeAsNumber maps the tag NPP:NetworkInfo:MacType to the MAC_TYPE_*
// defined in the NPPTYPES.h.  If the tag is unavailable, the API returns MAC_TYPE_UNKNOWN.
DWORD _cdecl GetNPPMacTypeAsNumber(HBLOB hBlob, 
                            LPDWORD lpMacType);

// See if a remote catagory exists... and make sure that the remote computername
// isn't the same as the local computername.
BOOL  _cdecl IsRemoteNPP ( HBLOB hBLOB);

//=============================================================================
// npp tag definitions
//=============================================================================
#define OWNER_NPP               "NPP"

#define CATEGORY_NETWORKINFO        "NetworkInfo"
#define TAG_RAS                         "Dial-up Connection"
#define TAG_MACTYPE                     "MacType"
#define TAG_CURRENTADDRESS              "CurrentAddress"
#define TAG_LINKSPEED                   "LinkSpeed"
#define TAG_MAXFRAMESIZE                "MaxFrameSize"
#define TAG_FLAGS                       "Flags"
#define TAG_TIMESTAMPSCALEFACTOR        "TimeStampScaleFactor"
#define TAG_COMMENT                     "Comment"
#define TAG_NODENAME                    "NodeName"
#define TAG_NAME                        "Name"
#define TAG_FAKENPP                     "Fake"
#define TAG_PROMISCUOUS_MODE            "PMode"

#define CATEGORY_LOCATION           "Location"
#define TAG_MACADDRESS                  "MacAddress"
#define TAG_CLASSID                     "ClassID"
#define TAG_NAME                        "Name"

#define CATEGORY_CONFIG             "Config"
#define TAG_FRAME_SIZE                  "FrameSize"
#define TAG_UPDATE_FREQUENCY            "UpdateFreq"
#define TAG_BUFFER_SIZE                 "BufferSize"
#define TAG_DRIVE_LETTER                "DriveLetter"
#define TAG_PATTERN_DESIGNATOR          "PatternMatch"
#define TAG_PATTERN                     "Pattern"
#define TAG_ADDRESS_PAIR                "AddressPair"
#define TAG_CONNECTIONFLAGS             "ConnectionFlags"
#define TAG_ETYPES                      "Etypes"
#define TAG_SAPS                        "Saps"
#define TAG_NO_CONVERSATION_STATS       "NoConversationStats"
#define TAG_NO_STATS_FRAME              "NoStatsFrame"
#define TAG_DONT_DELETE_EMPTY_CAPTURE   "DontDeleteEmptyCapture"
#define TAG_WANT_PROTOCOL_INFO          "WantProtocolInfo"
#define TAG_INTERFACE_DELAYED_CAPTURE   "IDdC"
#define TAG_INTERFACE_REALTIME_CAPTURE  "IRTC"
#define TAG_INTERFACE_STATS             "ISts"
#define TAG_INTERFACE_TRANSMIT          "IXmt"
#define TAG_INTERFACE_EXPERT_STATS      "IESP"
#define TAG_LOCAL_ONLY                  "LocalOnly"
// Is_Remote is set to TRUE by NPPs that go remote.  Note that when you
//  are looking for a remote NPP, you probably also need to ask for
//  blobs that have the TAG_GET_SPECIAL_BLOBS bool set
#define TAG_IS_REMOTE                   "IsRemote"


#define CATEGORY_TRIGGER            "Trigger"
#define TAG_TRIGGER                     "Trigger"

#define CATEGORY_FINDER             "Finder"
#define TAG_ROOT                        "Root"
#define TAG_PROCNAME                    "ProcName"
#define TAG_DISP_STRING                 "Display"
#define TAG_DLL_FILENAME                "DLLName"
#define TAG_GET_SPECIAL_BLOBS           "Specials"

#define CATEGORY_REMOTE              "Remote"
#define TAG_REMOTECOMPUTER              "RemoteComputer"
#define TAG_REMOTECLASSID               "ClassID"

#define CATEGORY_ESP                "ESP"
#define TAG_ESP_GENERAL_ACTIVE          "ESPGeneralActive"
#define TAG_ESP_PROTOCOL_ACTIVE         "ESPProtocolActive"
#define TAG_ESP_MAC_ACTIVE              "ESPMacActive"
#define TAG_ESP_MAC2MAC_ACTIVE          "ESPMac2MacActive"
#define TAG_ESP_IP_ACTIVE               "ESPIpActive"
#define TAG_ESP_IP2IP_ACTIVE            "ESPIp2IpActive"
#define TAG_ESP_IP_APP_ACTIVE           "ESPIpAppActive"
#define TAG_ESP_IPX_ACTIVE              "ESPIpxActive"
#define TAG_ESP_IPX2IPX_ACTIVE          "ESPIpx2IpxActive"
#define TAG_ESP_IPX_APP_ACTIVE          "ESPIpxAppActive"
#define TAG_ESP_DEC_ACTIVE              "ESPDecActive"
#define TAG_ESP_DEC2DEC_ACTIVE          "ESPDec2DecActive"
#define TAG_ESP_DEC_APP_ACTIVE          "ESPDecAppActive"
#define TAG_ESP_APPLE_ACTIVE            "ESPAppleActive"
#define TAG_ESP_APPLE2APPLE_ACTIVE      "ESPApple2AppleActive"
#define TAG_ESP_APPLE_APP_ACTIVE        "ESPAppleAppActive"

#define TAG_ESP_UTIL_SIZE               "ESPUtilSize"
#define TAG_ESP_TIME_SIZE               "ESPTimeSize"
#define TAG_ESP_BPS_SIZE                "ESPBpsSize"
#define TAG_ESP_BPS_THRESH              "ESPBpsThresh"
#define TAG_ESP_FPS_THRESH              "ESPFpsThresh"

#define TAG_ESP_MAC                     "ESPMac"
#define TAG_ESP_IPX                     "ESPIpx"
#define TAG_ESP_IPXSPX                  "ESPIpxSpx"
#define TAG_ESP_NCP                     "ESPNcp"
#define TAG_ESP_IP                      "ESPIp"
#define TAG_ESP_UDP                     "ESPUdp"
#define TAG_ESP_TCP                     "ESPTcp"
#define TAG_ESP_ICMP                    "ESPIcmp"
#define TAG_ESP_ARP                     "ESPArp"
#define TAG_ESP_RARP                    "ESPRarp"
#define TAG_ESP_APPLE                   "ESPApple"
#define TAG_ESP_AARP                    "ESPAarp"
#define TAG_ESP_DEC                     "ESPDec"
#define TAG_ESP_NETBIOS                 "ESPNetbios"
#define TAG_ESP_SNA                     "ESPSna"
#define TAG_ESP_BPDU                    "ESPBpdu"
#define TAG_ESP_LLC                     "ESPLlc"
#define TAG_ESP_RPL                     "ESPRpl"
#define TAG_ESP_BANYAN                  "ESPBanyan"
#define TAG_ESP_LANMAN                  "ESPLanMan"
#define TAG_ESP_SNMP                    "ESPSnmp"
#define TAG_ESP_X25                     "ESPX25"
#define TAG_ESP_XNS                     "ESPXns"
#define TAG_ESP_ISO                     "ESPIso"
#define TAG_ESP_UNKNOWN                 "ESPUnknown"
#define TAG_ESP_ATP                     "ESPAtp"
#define TAG_ESP_ADSP                    "ESPAdsp"

//=============================================================================
// npp value definitions
//=============================================================================
// Mac types
#define PROTOCOL_STRING_ETHERNET_TXT   "ETHERNET"
#define PROTOCOL_STRING_TOKENRING_TXT  "TOKENRING"
#define PROTOCOL_STRING_FDDI_TXT       "FDDI"
#define PROTOCOL_STRING_ATM_TXT        "ATM"
#define PROTOCOL_STRING_1394_TXT       "IP/1394"

// lower protocols
#define PROTOCOL_STRING_IP_TXT         "IP"
#define PROTOCOL_STRING_IPX_TXT        "IPX"
#define PROTOCOL_STRING_XNS_TXT        "XNS"
#define PROTOCOL_STRING_VINES_IP_TXT   "VINES IP"

// upper protocols
#define PROTOCOL_STRING_ICMP_TXT       "ICMP"
#define PROTOCOL_STRING_TCP_TXT        "TCP"
#define PROTOCOL_STRING_UDP_TXT        "UDP"
#define PROTOCOL_STRING_SPX_TXT        "SPX"
#define PROTOCOL_STRING_NCP_TXT        "NCP"

// pseudo protocols
#define PROTOCOL_STRING_ANY_TXT        "ANY"
#define PROTOCOL_STRING_ANY_GROUP_TXT  "ANY GROUP"
#define PROTOCOL_STRING_HIGHEST_TXT    "HIGHEST"
#define PROTOCOL_STRING_LOCAL_ONLY_TXT "LOCAL ONLY"
#define PROTOCOL_STRING_UNKNOWN_TXT    "UNKNOWN"
#define PROTOCOL_STRING_DATA_TXT       "DATA"
#define PROTOCOL_STRING_FRAME_TXT      "FRAME"
#define PROTOCOL_STRING_NONE_TXT       "NONE"
#define PROTOCOL_STRING_EFFECTIVE_TXT  "EFFECTIVE"

#define ADDRESS_PAIR_INCLUDE_TXT    "INCLUDE"
#define ADDRESS_PAIR_EXCLUDE_TXT    "EXCLUDE"

#define INCLUDE_ALL_EXCEPT_TXT      "INCLUDE ALL EXCEPT"
#define EXCLUDE_ALL_EXCEPT_TXT      "EXCLUDE ALL EXCEPT"

#define PATTERN_MATCH_OR_TXT        "OR("
#define PATTERN_MATCH_AND_TXT       "AND("

#define TRIGGER_PATTERN_TXT               "PATTERN MATCH"
#define TRIGGER_BUFFER_TXT                "BUFFER CONTENT"

#define TRIGGER_NOTIFY_TXT      "NOTIFY"
#define TRIGGER_STOP_TXT        "STOP"
#define TRIGGER_PAUSE_TXT       "PAUSE"

#define TRIGGER_25_PERCENT_TXT  "25 PERCENT"
#define TRIGGER_50_PERCENT_TXT  "50 PERCENT"
#define TRIGGER_75_PERCENT_TXT  "75 PERCENT"
#define TRIGGER_100_PERCENT_TXT "100 PERCENT"

#define PATTERN_MATCH_NOT_TXT   "NOT"

//=============================================================================
//=============================================================================
// (NMRegHelp.h)
//=============================================================================
//=============================================================================

// Registry helpers
LPCSTR _cdecl FindOneOf(LPCSTR p1, LPCSTR p2);

LONG _cdecl recursiveDeleteKey(HKEY hKeyParent,            // Parent of key to delete.
                        const char* lpszKeyChild);  // Key to delete.

BOOL _cdecl SubkeyExists(const char* pszPath,              // Path of key to check
                  const char* szSubkey);            // Key to check

BOOL _cdecl setKeyAndValue(const char* szKey, 
                    const char* szSubkey, 
                    const char* szValue,
                    const char* szName) ;

//=============================================================================
//=============================================================================
// (NMIpStructs.h)
//=============================================================================
//=============================================================================

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)
//
// IP Packet Structure
//
typedef struct _IP 
{
    union 
    {
        BYTE   Version;
        BYTE   HdrLen;
    };
    BYTE ServiceType;
    WORD TotalLen;
    WORD ID;
    union 
    {
        WORD   Flags;
        WORD   FragOff;
    };
    BYTE TimeToLive;
    BYTE Protocol;
    WORD HdrChksum;
    DWORD   SrcAddr;
    DWORD   DstAddr;
    BYTE Options[0];
} IP;

typedef IP * LPIP;
typedef IP UNALIGNED * ULPIP;
// Psuedo Header used for CheckSum Calculations
typedef struct _PSUHDR
    {
    DWORD ph_SrcIP;
    DWORD ph_DstIP;
    UCHAR ph_Zero;
    UCHAR ph_Proto;
    WORD ph_ProtLen;
    } 	PSUHDR;

typedef PSUHDR UNALIGNED * LPPSUHDR;
//
// IP Bitmasks that are useful
// (and the appropriate bit shifts, as well)
//

#define IP_VERSION_MASK ((BYTE) 0xf0)
#define IP_VERSION_SHIFT (4)
#define IP_HDRLEN_MASK  ((BYTE) 0x0f)
#define IP_HDRLEN_SHIFT (0)
#define IP_PRECEDENCE_MASK ((BYTE) 0xE0)
#define IP_PRECEDENCE_SHIFT   (5)
#define IP_TOS_MASK ((BYTE) 0x1E)
#define IP_TOS_SHIFT   (1)
#define IP_DELAY_MASK   ((BYTE) 0x10)
#define IP_THROUGHPUT_MASK ((BYTE) 0x08)
#define IP_RELIABILITY_MASK   ((BYTE) 0x04)
#define IP_FLAGS_MASK   ((BYTE) 0xE0)
#define IP_FLAGS_SHIFT  (13)
#define IP_DF_MASK   ((BYTE) 0x40)
#define IP_MF_MASK   ((BYTE) 0x20)
#define IP_MF_SHIFT     (5)
#define IP_FRAGOFF_MASK ((WORD) 0x1FFF)
#define IP_FRAGOFF_SHIFT   (3)
#define IP_TCC_MASK  ((DWORD) 0xFFFFFF00)
#define IP_TIME_OPTS_MASK  ((BYTE) 0x0F)
#define IP_MISS_STNS_MASK  ((BYTE) 0xF0)

#define IP_TIME_OPTS_SHIFT (0)
#define IP_MISS_STNS_SHIFT  (4)

//
// Offset to checksum field in ip header
//
#define IP_CHKSUM_OFF   10

INLINE BYTE IP_Version(ULPIP pIP)
{
    return (pIP->Version & IP_VERSION_MASK) >> IP_VERSION_SHIFT;
}

INLINE DWORD IP_HdrLen(ULPIP pIP)
{
    return ((pIP->HdrLen & IP_HDRLEN_MASK) >> IP_HDRLEN_SHIFT) << 2;
}

INLINE WORD IP_FragOff(ULPIP pIP)
{
    return (XCHG(pIP->FragOff) & IP_FRAGOFF_MASK) << IP_FRAGOFF_SHIFT;
}

INLINE DWORD IP_TotalLen(ULPIP pIP)
{
    return XCHG(pIP->TotalLen);
}

INLINE DWORD IP_MoreFragments(ULPIP pIP)
{
    return (pIP->Flags & IP_MF_MASK) >> IP_MF_SHIFT;
}
//
// Well known ports in the TCP/IP protocol (See RFC 1060)
//
#define PORT_TCPMUX              1  // TCP Port Service Multiplexer
#define PORT_RJE                 5  // Remote Job Entry
#define PORT_ECHO                7  // Echo
#define PORT_DISCARD             9  // Discard
#define PORT_USERS              11  // Active users
#define PORT_DAYTIME            13  // Daytime
#define PORT_NETSTAT            15  // Netstat
#define PORT_QUOTE              17  // Quote of the day
#define PORT_CHARGEN            19  // Character Generator
#define PORT_FTPDATA            20  // File transfer [default data]
#define PORT_FTP                21  // File transfer [Control]
#define PORT_TELNET             23  // Telnet
#define PORT_SMTP               25  // Simple Mail Transfer
#define PORT_NSWFE              27  // NSW User System FE
#define PORT_MSGICP             29  // MSG ICP
#define PORT_MSGAUTH            31  // MSG Authentication
#define PORT_DSP                33  // Display Support
#define PORT_PRTSERVER          35  // any private printer server
#define PORT_TIME               37  // Time
#define PORT_RLP                39  // Resource Location Protocol
#define PORT_GRAPHICS           41  // Graphics
#define PORT_NAMESERVER         42  // Host Name Server
#define PORT_NICNAME            43  // Who is
#define PORT_MPMFLAGS           44  // MPM Flags 
#define PORT_MPM                45  // Message Processing Module [recv]
#define PORT_MPMSND             46  // MPM [default send]
#define PORT_NIFTP              47  // NI FTP
#define PORT_LOGIN              49  // Login Host Protocol
#define PORT_LAMAINT            51  // IMP Logical Address Maintenance
#define PORT_DOMAIN             53  // Domain Name Server
#define PORT_ISIGL              55  // ISI Graphics Language
#define PORT_ANYTERMACC         57  // any private terminal access
#define PORT_ANYFILESYS         59  // any private file service
#define PORT_NIMAIL             61  // NI Mail
#define PORT_VIAFTP             63  // VIA Systems - FTP
#define PORT_TACACSDS           65  // TACACS - Database Service
#define PORT_BOOTPS             67  // Bootstrap Protocol server
#define PORT_BOOTPC             68  // Bootstrap Protocol client
#define PORT_TFTP               69  // Trivial File Transfer
#define PORT_NETRJS1            71  // Remote Job service
#define PORT_NETRJS2            72  // Remote Job service
#define PORT_NETRJS3            73  // Remote Job service
#define PORT_NETRJS4            74  // Remote Job service
#define PORT_ANYDIALOUT         75  // any private dial out service
#define PORT_ANYRJE             77  // any private RJE service
#define PORT_FINGER             79  // Finger
#define PORT_HTTP               80  // HTTP (www)
#define PORT_HOSTS2NS           81  // Hosts2 Name Server
#define PORT_MITMLDEV1          83  // MIT ML Device
#define PORT_MITMLDEV2          85  // MIT ML Device
#define PORT_ANYTERMLINK        87  // any private terminal link
#define PORT_SUMITTG            89  // SU/MIT Telnet Gateway
#define PORT_MITDOV             91  // MIT Dover Spooler
#define PORT_DCP                93  // Device Control Protocol
#define PORT_SUPDUP             95  // SUPDUP
#define PORT_SWIFTRVF           97  // Swift Remote Vitural File Protocol
#define PORT_TACNEWS            98  // TAC News
#define PORT_METAGRAM           99  // Metagram Relay
#define PORT_NEWACCT           100  // [Unauthorized use]
#define PORT_HOSTNAME          101  // NIC Host Name Server
#define PORT_ISOTSAP           102  // ISO-TSAP
#define PORT_X400              103  // X400
#define PORT_X400SND           104  // X400 - SND
#define PORT_CSNETNS           105  // Mailbox Name Nameserver
#define PORT_RTELNET           107  // Remote Telnet Service
#define PORT_POP2              109  // Post Office Protocol - version 2
#define PORT_POP3              110  // Post Office Protocol - version 3
#define PORT_SUNRPC            111  // SUN Remote Procedure Call
#define PORT_AUTH              113  // Authentication
#define PORT_SFTP              115  // Simple File Transfer Protocol
#define PORT_UUCPPATH          117  // UUCP Path Service
#define PORT_NNTP              119  // Network News Transfer Protocol
#define PORT_ERPC              121  // Encore Expedited Remote Proc. Call
#define PORT_NTP               123  // Network Time Protocol
#define PORT_LOCUSMAP          125  // Locus PC-Interface Net Map Sesrver
#define PORT_LOCUSCON          127  // Locus PC-Interface Conn Server
#define PORT_PWDGEN            129  // Password Generator Protocol
#define PORT_CISCOFNA          130  // CISCO FNATIVE
#define PORT_CISCOTNA          131  // CISCO TNATIVE
#define PORT_CISCOSYS          132  // CISCO SYSMAINT
#define PORT_STATSRV           133  // Statistics Service
#define PORT_INGRESNET         134  // Ingres net service
#define PORT_LOCSRV            135  // Location Service
#define PORT_PROFILE           136  // PROFILE Naming System
#define PORT_NETBIOSNS         137  // NETBIOS Name Service
#define PORT_NETBIOSDGM        138  // NETBIOS Datagram Service
#define PORT_NETBIOSSSN        139  // NETBIOS Session Service
#define PORT_EMFISDATA         140  // EMFIS Data Service
#define PORT_EMFISCNTL         141  // EMFIS Control Service
#define PORT_BLIDM             142  // Britton-Lee IDM
#define PORT_IMAP2             143  // Interim Mail Access Protocol v2
#define PORT_NEWS              144  // NewS
#define PORT_UAAC              145  // UAAC protocol
#define PORT_ISOTP0            146  // ISO-IP0
#define PORT_ISOIP             147  // ISO-IP
#define PORT_CRONUS            148  // CRONUS-Support
#define PORT_AED512            149  // AED 512 Emulation Service
#define PORT_SQLNET            150  // SQL-NET
#define PORT_HEMS              151  // HEMS
#define PORT_BFTP              152  // Background File Transfer Protocol
#define PORT_SGMP              153  // SGMP
#define PORT_NETSCPROD         154  // NETSC
#define PORT_NETSCDEV          155  // NETSC
#define PORT_SQLSRV            156  // SQL service
#define PORT_KNETCMP           157  // KNET/VM Command/Message Protocol
#define PORT_PCMAILSRV         158  // PCMail server
#define PORT_NSSROUTING        159  // NSS routing
#define PORT_SGMPTRAPS         160  // SGMP-TRAPS
#define PORT_SNMP              161  // SNMP
#define PORT_SNMPTRAP          162  // SNMPTRAP
#define PORT_CMIPMANAGE        163  // CMIP/TCP Manager
#define PORT_CMIPAGENT         164  // CMIP/TCP Agent
#define PORT_XNSCOURIER        165  // Xerox
#define PORT_SNET              166  // Sirius Systems
#define PORT_NAMP              167  // NAMP
#define PORT_RSVD              168  // RSVC
#define PORT_SEND              169  // SEND
#define PORT_PRINTSRV          170  // Network Postscript
#define PORT_MULTIPLEX         171  // Network Innovations Multiples
#define PORT_CL1               172  // Network Innovations CL/1
#define PORT_XYPLEXMUX         173  // Xyplex
#define PORT_MAILQ             174  // MAILQ
#define PORT_VMNET             175  // VMNET
#define PORT_GENRADMUX         176  // GENRAD-MUX
#define PORT_XDMCP             177  // X Display Manager Control Protocol
#define PORT_NEXTSTEP          178  // NextStep Window Server
#define PORT_BGP               179  // Border Gateway Protocol
#define PORT_RIS               180  // Intergraph
#define PORT_UNIFY             181  // Unify
#define PORT_UNISYSCAM         182  // Unisys-Cam
#define PORT_OCBINDER          183  // OCBinder
#define PORT_OCSERVER          184  // OCServer
#define PORT_REMOTEKIS         185  // Remote-KIS
#define PORT_KIS               186  // KIS protocol
#define PORT_ACI               187  // Application Communication Interface
#define PORT_MUMPS             188  // MUMPS
#define PORT_QFT               189  // Queued File Transport
#define PORT_GACP              190  // Gateway Access Control Protocol
#define PORT_PROSPERO          191  // Prospero
#define PORT_OSUNMS            192  // OSU Network Monitoring System
#define PORT_SRMP              193  // Spider Remote Monitoring Protocol
#define PORT_IRC               194  // Internet Relay Chat Protocol
#define PORT_DN6NLMAUD         195  // DNSIX Network Level Module Audit
#define PORT_DN6SMMRED         196  // DSNIX Session Mgt Module Audit Redirector
#define PORT_DLS               197  // Directory Location Service
#define PORT_DLSMON            198  // Directory Location Service Monitor
#define PORT_ATRMTP            201  // AppleTalk Routing Maintenance
#define PORT_ATNBP             202  // AppleTalk Name Binding
#define PORT_AT3               203  // AppleTalk Unused
#define PORT_ATECHO            204  // AppleTalk Echo
#define PORT_AT5               205  // AppleTalk Unused
#define PORT_ATZIS             206  // AppleTalk Zone Information
#define PORT_AT7               207  // AppleTalk Unused
#define PORT_AT8               208  // AppleTalk Unused
#define PORT_SURMEAS           243  // Survey Measurement
#define PORT_LINK              245  // LINK
#define PORT_DSP3270           246  // Display Systems Protocol
#define PORT_LDAP1             389  // LDAP
#define PORT_ISAKMP            500  // ISAKMP
#define PORT_REXEC             512  // Remote Process Execution
#define PORT_RLOGIN            513  // Remote login a la telnet
#define PORT_RSH               514  // Remote command
#define PORT_LPD               515  // Line printer spooler - LPD
#define PORT_RIP               520  // TCP=? / UDP=RIP
#define PORT_TEMPO             526  // Newdate
#define PORT_COURIER           530  // rpc
#define PORT_NETNEWS           532  // READNEWS
#define PORT_UUCPD             540  // UUCPD
#define PORT_KLOGIN            543  //
#define PORT_KSHELL            544  // krcmd
#define PORT_DSF               555  //
#define PORT_REMOTEEFS         556  // RFS server
#define PORT_CHSHELL           562  // chmod
#define PORT_METER             570  // METER
#define PORT_PCSERVER          600  // SUN IPC Server
#define PORT_NQS               607  // NQS
#define PORT_HMMP_INDICATION   612  //     
#define PORT_HMMP_OPERATION    613  //     
#define PORT_MDQS              666  // MDQS
#define PORT_LPD721            721  // LPD Client (lpd client ports 721 - 731)
#define PORT_LPD722            722  // LPD Client (see RFC 1179)
#define PORT_LPD723            723  // LPD Client
#define PORT_LPD724            724  // LPD Client
#define PORT_LPD725            725  // LPD Client
#define PORT_LPD726            726  // LPD Client
#define PORT_LPD727            727  // LPD Client
#define PORT_LPD728            728  // LPD Client
#define PORT_LPD729            729  // LPD Client
#define PORT_LPD730            730  // LPD Client
#define PORT_LPD731            731  // LPD Client
#define PORT_RFILE             750  // RFILE
#define PORT_PUMP              751  // PUMP
#define PORT_QRH               752  // QRH
#define PORT_RRH               753  // RRH
#define PORT_TELL              754  // TELL
#define PORT_NLOGIN            758  // NLOGIN
#define PORT_CON               759  // CON
#define PORT_NS                760  // NS
#define PORT_RXE               761  // RXE
#define PORT_QUOTAD            762  // QUOTAD
#define PORT_CYCLESERV         763  // CYCLESERV
#define PORT_OMSERV            764  // OMSERV
#define PORT_WEBSTER           765  // WEBSTER
#define PORT_PHONEBOOK         767  // PHONE
#define PORT_VID               769  // VID
#define PORT_RTIP              771  // RTIP
#define PORT_CYCLESERV2        772  // CYCLESERV-2
#define PORT_SUBMIT            773  // submit
#define PORT_RPASSWD           774  // RPASSWD
#define PORT_ENTOMB            775  // ENTOMB
#define PORT_WPAGES            776  // WPAGES
#define PORT_WPGS              780  // wpgs
#define PORT_MDBSDAEMON        800  // MDBS DAEMON
#define PORT_DEVICE            801  // DEVICE
#define PORT_MAITRD            997  // MAITRD
#define PORT_BUSBOY            998  // BUSBOY
#define PORT_GARCON            999  // GARCON
#define PORT_NFS              2049  // NFS
#define PORT_LDAP2            3268  // LDAP
#define PORT_PPTP             5678  // PPTP

//=============================================================================
//=============================================================================
// (NMIcmpStructs.h)
//=============================================================================
//=============================================================================

//
// ICMP Frame Structure
//
typedef struct _RequestReplyFields
    {
    WORD ID;
    WORD SeqNo;
    } 	ReqReply;

typedef struct _ParameterProblemFields
    {
    BYTE Pointer;
    BYTE junk[ 3 ];
    } 	ParmProb;

typedef struct _TimestampFields
    {
    DWORD tsOrig;
    DWORD tsRecv;
    DWORD tsXmit;
    } 	TS;

typedef struct _RouterAnnounceHeaderFields
    {
    BYTE NumAddrs;
    BYTE AddrEntrySize;
    WORD Lifetime;
    } 	RouterAH;

typedef struct _RouterAnnounceEntry
    {
    DWORD Address;
    DWORD PreferenceLevel;
    } 	RouterAE;

typedef struct _ICMP 
{
   BYTE Type;
   BYTE Code;
   WORD Checksum;
   union
   {
      DWORD    Unused;
      DWORD    Address;
      ReqReply RR;
      ParmProb PP;
      RouterAH RAH;     
   };

   union
   {
      TS       Time;
      IP       IP;
      RouterAE RAE[0];
   };
} ICMP;

typedef ICMP * LPICMP;
typedef ICMP UNALIGNED * ULPICMP;
#define	ICMP_HEADER_LENGTH	( 8 )

// # of *BYTES* of IP data to attach to
// datagram in addition to IP header
#define	ICMP_IP_DATA_LENGTH	( 8 )

//
// ICMP Packet Types
//
#define	ECHO_REPLY	( 0 )

#define	DESTINATION_UNREACHABLE	( 3 )

#define	SOURCE_QUENCH	( 4 )

#define	REDIRECT	( 5 )

#define	ECHO	( 8 )

#define	ROUTER_ADVERTISEMENT	( 9 )

#define	ROUTER_SOLICITATION	( 10 )

#define	TIME_EXCEEDED	( 11 )

#define	PARAMETER_PROBLEM	( 12 )

#define	TIMESTAMP	( 13 )

#define	TIMESTAMP_REPLY	( 14 )

#define	INFORMATION_REQUEST	( 15 )

#define	INFORMATION_REPLY	( 16 )

#define	ADDRESS_MASK_REQUEST	( 17 )

#define	ADDRESS_MASK_REPLY	( 18 )

//=============================================================================
//=============================================================================
// (NMIpxStructs.h)
//=============================================================================
//=============================================================================
//  IPX
typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0025
    {
    UCHAR ha_address[ 6 ];
    } 	HOST_ADDRESS;

typedef struct _IPXADDRESS
    {
    ULONG ipx_NetNumber;
    HOST_ADDRESS ipx_HostAddr;
    } 	IPXADDRESS;

typedef IPXADDRESS UNALIGNED * PIPXADDRESS;
typedef struct _NET_ADDRESS
    {
    IPXADDRESS na_IPXAddr;
    USHORT na_socket;
    } 	NET_ADDRESS;

typedef NET_ADDRESS UNALIGNED * UPNET_ADDRESS;
// IPX Internetwork Packet eXchange Protocol Header.
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0026
    {
    USHORT ipx_checksum;
    USHORT ipx_length;
    UCHAR ipx_xport_control;
    UCHAR ipx_packet_type;
    NET_ADDRESS ipx_dest;
    NET_ADDRESS ipx_source;
    } 	IPX_HDR;

typedef IPX_HDR UNALIGNED * ULPIPX_HDR;
//  SPX - Sequenced Packet Protocol
typedef struct _SPX_HDR
    {
    IPX_HDR spx_idp_hdr;
    UCHAR spx_conn_ctrl;
    UCHAR spx_data_type;
    USHORT spx_src_conn_id;
    USHORT spx_dest_conn_id;
    USHORT spx_sequence_num;
    USHORT spx_ack_num;
    USHORT spx_alloc_num;
    } 	SPX_HDR;

typedef SPX_HDR UNALIGNED *PSPX_HDR;
//=============================================================================
//=============================================================================
// (NMTcpStructs.h)
//=============================================================================
//=============================================================================
//
// TCP Packet Structure
//
typedef struct _TCP
    {
    WORD SrcPort;
    WORD DstPort;
    DWORD SeqNum;
    DWORD AckNum;
    BYTE DataOff;
    BYTE Flags;
    WORD Window;
    WORD Chksum;
    WORD UrgPtr;
    } 	TCP;

typedef TCP *LPTCP;

typedef TCP UNALIGNED * ULPTCP;
INLINE DWORD TCP_HdrLen(ULPTCP pTCP)
{
    return (pTCP->DataOff & 0xf0) >> 2;
}

INLINE DWORD TCP_SrcPort(ULPTCP pTCP)
{
    return XCHG(pTCP->SrcPort);
}

INLINE DWORD TCP_DstPort(ULPTCP pTCP)
{
    return XCHG(pTCP->DstPort);
}
//
// TCP Option Opcodes
//
#define	TCP_OPTION_ENDOFOPTIONS	( 0 )

#define	TCP_OPTION_NOP	( 1 )

#define	TCP_OPTION_MAXSEGSIZE	( 2 )

#define	TCP_OPTION_WSCALE	( 3 )

#define	TCP_OPTION_SACK_PERMITTED	( 4 )

#define	TCP_OPTION_SACK	( 5 )

#define	TCP_OPTION_TIMESTAMPS	( 8 )

//
// TCP Flags
//
#define	TCP_FLAG_URGENT	( 0x20 )

#define	TCP_FLAG_ACK	( 0x10 )

#define	TCP_FLAG_PUSH	( 0x8 )

#define	TCP_FLAG_RESET	( 0x4 )

#define	TCP_FLAG_SYN	( 0x2 )

#define	TCP_FLAG_FIN	( 0x1 )

//
// TCP Field Masks
//
#define	TCP_RESERVED_MASK	( 0xfc0 )


#pragma pack(pop)
//****************************************************************************
//****************************************************************************
// IDelaydC - used by a consumer to get frames after a capture has completed.
//****************************************************************************
//****************************************************************************
#define	DEFAULT_DELAYED_BUFFER_SIZE	( 1 )

#define	USE_DEFAULT_DRIVE_LETTER	( 0 )

#define	RTC_FRAME_SIZE_FULL	( 0 )



extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_v0_0_s_ifspec;

#ifndef __IDelaydC_INTERFACE_DEFINED__
#define __IDelaydC_INTERFACE_DEFINED__

/* interface IDelaydC */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDelaydC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BFF9C030-B58F-11ce-B5B0-00AA006CB37D")
    IDelaydC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [out] */ char *pFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [out] */ LPSTATISTICS lpStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelaydCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDelaydC * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDelaydC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IDelaydC * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IDelaydC * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IDelaydC * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDelaydC * This,
            /* [out] */ char *pFileName);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDelaydC * This,
            /* [out] */ LPSTATISTICS lpStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IDelaydC * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IDelaydC * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IDelaydC * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IDelaydC * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IDelaydC * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IDelaydCVtbl;

    interface IDelaydC
    {
        CONST_VTBL struct IDelaydCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelaydC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDelaydC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDelaydC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDelaydC_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)

#define IDelaydC_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IDelaydC_QueryStatus(This,pNetworkStatus)	\
    (This)->lpVtbl -> QueryStatus(This,pNetworkStatus)

#define IDelaydC_Configure(This,hConfigurationBlob,hErrorBlob)	\
    (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob)

#define IDelaydC_Start(This,pFileName)	\
    (This)->lpVtbl -> Start(This,pFileName)

#define IDelaydC_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IDelaydC_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IDelaydC_Stop(This,lpStats)	\
    (This)->lpVtbl -> Stop(This,lpStats)

#define IDelaydC_GetControlState(This,IsRunnning,IsPaused)	\
    (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused)

#define IDelaydC_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading)

#define IDelaydC_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)

#define IDelaydC_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)

#define IDelaydC_QueryStations(This,lpQueryTable)	\
    (This)->lpVtbl -> QueryStations(This,lpQueryTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDelaydC_Connect_Proxy( 
    IDelaydC * This,
    /* [in] */ HBLOB hInputBlob,
    /* [in] */ LPVOID StatusCallbackProc,
    /* [in] */ LPVOID UserContext,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IDelaydC_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_Disconnect_Proxy( 
    IDelaydC * This);


void __RPC_STUB IDelaydC_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_QueryStatus_Proxy( 
    IDelaydC * This,
    /* [out] */ NETWORKSTATUS *pNetworkStatus);


void __RPC_STUB IDelaydC_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_Configure_Proxy( 
    IDelaydC * This,
    /* [in] */ HBLOB hConfigurationBlob,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IDelaydC_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_Start_Proxy( 
    IDelaydC * This,
    /* [out] */ char *pFileName);


void __RPC_STUB IDelaydC_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_Pause_Proxy( 
    IDelaydC * This);


void __RPC_STUB IDelaydC_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_Resume_Proxy( 
    IDelaydC * This);


void __RPC_STUB IDelaydC_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_Stop_Proxy( 
    IDelaydC * This,
    /* [out] */ LPSTATISTICS lpStats);


void __RPC_STUB IDelaydC_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_GetControlState_Proxy( 
    IDelaydC * This,
    /* [out] */ BOOL *IsRunnning,
    /* [out] */ BOOL *IsPaused);


void __RPC_STUB IDelaydC_GetControlState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_GetTotalStatistics_Proxy( 
    IDelaydC * This,
    /* [out] */ LPSTATISTICS lpStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IDelaydC_GetTotalStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_GetConversationStatistics_Proxy( 
    IDelaydC * This,
    /* [out] */ DWORD *nSessions,
    /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
    /* [out] */ DWORD *nStations,
    /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IDelaydC_GetConversationStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_InsertSpecialFrame_Proxy( 
    IDelaydC * This,
    /* [in] */ DWORD FrameType,
    /* [in] */ DWORD Flags,
    /* [in] */ BYTE *pUserData,
    /* [in] */ DWORD UserDataLength);


void __RPC_STUB IDelaydC_InsertSpecialFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDelaydC_QueryStations_Proxy( 
    IDelaydC * This,
    /* [out][in] */ QUERYTABLE *lpQueryTable);


void __RPC_STUB IDelaydC_QueryStations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDelaydC_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0010 */
/* [local] */ 

//****************************************************************************
//****************************************************************************
// IESP - used by a consumer to get extended statistics, no frames.
//****************************************************************************
//****************************************************************************


extern RPC_IF_HANDLE __MIDL_itf_netmon_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0010_v0_0_s_ifspec;

#ifndef __IESP_INTERFACE_DEFINED__
#define __IESP_INTERFACE_DEFINED__

/* interface IESP */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IESP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E99A04AA-AB95-11d0-BE96-00A0C94989DE")
    IESP : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [out][string] */ char *pFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ LPSTATISTICS lpStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [out] */ LPSTATISTICS lpStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IESPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IESP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IESP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IESP * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IESP * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IESP * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IESP * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IESP * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IESP * This,
            /* [out][string] */ char *pFileName);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IESP * This,
            /* [out] */ LPSTATISTICS lpStats);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IESP * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IESP * This,
            /* [out] */ LPSTATISTICS lpStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IESP * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IESP * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IESPVtbl;

    interface IESP
    {
        CONST_VTBL struct IESPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IESP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IESP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IESP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IESP_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)

#define IESP_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IESP_QueryStatus(This,pNetworkStatus)	\
    (This)->lpVtbl -> QueryStatus(This,pNetworkStatus)

#define IESP_Configure(This,hConfigurationBlob,hErrorBlob)	\
    (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob)

#define IESP_Start(This,pFileName)	\
    (This)->lpVtbl -> Start(This,pFileName)

#define IESP_Pause(This,lpStats)	\
    (This)->lpVtbl -> Pause(This,lpStats)

#define IESP_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IESP_Stop(This,lpStats)	\
    (This)->lpVtbl -> Stop(This,lpStats)

#define IESP_GetControlState(This,IsRunnning,IsPaused)	\
    (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused)

#define IESP_QueryStations(This,lpQueryTable)	\
    (This)->lpVtbl -> QueryStations(This,lpQueryTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IESP_Connect_Proxy( 
    IESP * This,
    /* [in] */ HBLOB hInputBlob,
    /* [in] */ LPVOID StatusCallbackProc,
    /* [in] */ LPVOID UserContext,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IESP_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Disconnect_Proxy( 
    IESP * This);


void __RPC_STUB IESP_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_QueryStatus_Proxy( 
    IESP * This,
    /* [out] */ NETWORKSTATUS *pNetworkStatus);


void __RPC_STUB IESP_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Configure_Proxy( 
    IESP * This,
    /* [in] */ HBLOB hConfigurationBlob,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IESP_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Start_Proxy( 
    IESP * This,
    /* [out][string] */ char *pFileName);


void __RPC_STUB IESP_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Pause_Proxy( 
    IESP * This,
    /* [out] */ LPSTATISTICS lpStats);


void __RPC_STUB IESP_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Resume_Proxy( 
    IESP * This);


void __RPC_STUB IESP_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Stop_Proxy( 
    IESP * This,
    /* [out] */ LPSTATISTICS lpStats);


void __RPC_STUB IESP_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_GetControlState_Proxy( 
    IESP * This,
    /* [out] */ BOOL *IsRunnning,
    /* [out] */ BOOL *IsPaused);


void __RPC_STUB IESP_GetControlState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_QueryStations_Proxy( 
    IESP * This,
    /* [out][in] */ QUERYTABLE *lpQueryTable);


void __RPC_STUB IESP_QueryStations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IESP_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0012 */
/* [local] */ 

//****************************************************************************
//****************************************************************************
// IRTC - used by a consumer to get an interface to local entry points
// necessary to do real time capture processing.  It includes a method
// for handing a callback to the NPP.
//****************************************************************************
//****************************************************************************
#define	DEFAULT_RTC_BUFFER_SIZE	( 0x100000 )



extern RPC_IF_HANDLE __MIDL_itf_netmon_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0012_v0_0_s_ifspec;

#ifndef __IRTC_INTERFACE_DEFINED__
#define __IRTC_INTERFACE_DEFINED__

/* interface IRTC */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRTC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4811EA40-B582-11ce-B5AF-00AA006CB37D")
    IRTC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRTC * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRTC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IRTC * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IRTC * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IRTC * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IRTC * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IRTC * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IRTC * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IRTC * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IRTC * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IRTCVtbl;

    interface IRTC
    {
        CONST_VTBL struct IRTCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRTC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRTC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRTC_Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob)	\
    (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob)

#define IRTC_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IRTC_QueryStatus(This,pNetworkStatus)	\
    (This)->lpVtbl -> QueryStatus(This,pNetworkStatus)

#define IRTC_Configure(This,hConfigurationBlob,hErrorBlob)	\
    (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob)

#define IRTC_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IRTC_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IRTC_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IRTC_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IRTC_GetControlState(This,IsRunnning,IsPaused)	\
    (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused)

#define IRTC_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading)

#define IRTC_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)

#define IRTC_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)

#define IRTC_QueryStations(This,lpQueryTable)	\
    (This)->lpVtbl -> QueryStations(This,lpQueryTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRTC_Connect_Proxy( 
    IRTC * This,
    /* [in] */ HBLOB hInputBlob,
    /* [in] */ LPVOID StatusCallbackProc,
    /* [in] */ LPVOID FramesCallbackProc,
    /* [in] */ LPVOID UserContext,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IRTC_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Disconnect_Proxy( 
    IRTC * This);


void __RPC_STUB IRTC_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_QueryStatus_Proxy( 
    IRTC * This,
    /* [out] */ NETWORKSTATUS *pNetworkStatus);


void __RPC_STUB IRTC_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Configure_Proxy( 
    IRTC * This,
    /* [in] */ HBLOB hConfigurationBlob,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IRTC_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Start_Proxy( 
    IRTC * This);


void __RPC_STUB IRTC_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Pause_Proxy( 
    IRTC * This);


void __RPC_STUB IRTC_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Resume_Proxy( 
    IRTC * This);


void __RPC_STUB IRTC_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Stop_Proxy( 
    IRTC * This);


void __RPC_STUB IRTC_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_GetControlState_Proxy( 
    IRTC * This,
    /* [out] */ BOOL *IsRunnning,
    /* [out] */ BOOL *IsPaused);


void __RPC_STUB IRTC_GetControlState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_GetTotalStatistics_Proxy( 
    IRTC * This,
    /* [out] */ LPSTATISTICS lpStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IRTC_GetTotalStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_GetConversationStatistics_Proxy( 
    IRTC * This,
    /* [out] */ DWORD *nSessions,
    /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
    /* [out] */ DWORD *nStations,
    /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IRTC_GetConversationStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_InsertSpecialFrame_Proxy( 
    IRTC * This,
    /* [in] */ DWORD FrameType,
    /* [in] */ DWORD Flags,
    /* [in] */ BYTE *pUserData,
    /* [in] */ DWORD UserDataLength);


void __RPC_STUB IRTC_InsertSpecialFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_QueryStations_Proxy( 
    IRTC * This,
    /* [out][in] */ QUERYTABLE *lpQueryTable);


void __RPC_STUB IRTC_QueryStations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRTC_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0014 */
/* [local] */ 

//****************************************************************************
//****************************************************************************
// IStats - used by a consumer to get just statistics, no frames.
//****************************************************************************
//****************************************************************************


extern RPC_IF_HANDLE __MIDL_itf_netmon_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0014_v0_0_s_ifspec;

#ifndef __IStats_INTERFACE_DEFINED__
#define __IStats_INTERFACE_DEFINED__

/* interface IStats */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("944AD530-B09D-11ce-B59C-00AA006CB37D")
    IStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IStats * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IStats * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IStats * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IStats * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IStats * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IStats * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IStats * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IStats * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IStatsVtbl;

    interface IStats
    {
        CONST_VTBL struct IStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStats_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)

#define IStats_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IStats_QueryStatus(This,pNetworkStatus)	\
    (This)->lpVtbl -> QueryStatus(This,pNetworkStatus)

#define IStats_Configure(This,hConfigurationBlob,hErrorBlob)	\
    (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob)

#define IStats_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IStats_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IStats_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IStats_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IStats_GetControlState(This,IsRunnning,IsPaused)	\
    (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused)

#define IStats_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading)

#define IStats_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)

#define IStats_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)

#define IStats_QueryStations(This,lpQueryTable)	\
    (This)->lpVtbl -> QueryStations(This,lpQueryTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStats_Connect_Proxy( 
    IStats * This,
    /* [in] */ HBLOB hInputBlob,
    /* [in] */ LPVOID StatusCallbackProc,
    /* [in] */ LPVOID UserContext,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IStats_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Disconnect_Proxy( 
    IStats * This);


void __RPC_STUB IStats_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_QueryStatus_Proxy( 
    IStats * This,
    /* [out] */ NETWORKSTATUS *pNetworkStatus);


void __RPC_STUB IStats_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Configure_Proxy( 
    IStats * This,
    /* [in] */ HBLOB hConfigurationBlob,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IStats_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Start_Proxy( 
    IStats * This);


void __RPC_STUB IStats_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Pause_Proxy( 
    IStats * This);


void __RPC_STUB IStats_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Resume_Proxy( 
    IStats * This);


void __RPC_STUB IStats_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Stop_Proxy( 
    IStats * This);


void __RPC_STUB IStats_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_GetControlState_Proxy( 
    IStats * This,
    /* [out] */ BOOL *IsRunnning,
    /* [out] */ BOOL *IsPaused);


void __RPC_STUB IStats_GetControlState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_GetTotalStatistics_Proxy( 
    IStats * This,
    /* [out] */ LPSTATISTICS lpStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IStats_GetTotalStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_GetConversationStatistics_Proxy( 
    IStats * This,
    /* [out] */ DWORD *nSessions,
    /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
    /* [out] */ DWORD *nStations,
    /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IStats_GetConversationStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_InsertSpecialFrame_Proxy( 
    IStats * This,
    /* [in] */ DWORD FrameType,
    /* [in] */ DWORD Flags,
    /* [in] */ BYTE *pUserData,
    /* [in] */ DWORD UserDataLength);


void __RPC_STUB IStats_InsertSpecialFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_QueryStations_Proxy( 
    IStats * This,
    /* [out][in] */ QUERYTABLE *lpQueryTable);


void __RPC_STUB IStats_QueryStations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStats_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0016 */
/* [local] */ 

#pragma warning(default:4200)

#pragma pack()


extern RPC_IF_HANDLE __MIDL_itf_netmon_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0016_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmdprintf.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1993-1999. All rights reserved.
//
//  MODULE: nmdprintf.h
//=============================================================================

#ifndef NMDPRINTF_H
#define NMDPRINTF_H

#ifndef _NMSUPP_H
#ifdef __cplusplus
extern "C"
{
#endif

extern VOID _cdecl dprintf(LPSTR format, ...);


#ifdef __cplusplus
}
#endif

#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
typedef void (__cdecl * new_handler) ();
_CRTIMP new_handler __cdecl set_new_handler(new_handler);
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
	{return; }
#endif
#endif


/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#endif /* __cplusplus */

#endif /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\NlAdmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Apr 22 20:03:10 1998
 */
/* Compiler settings for nladmin.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __nladmin_h__
#define __nladmin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISearchAdmin_FWD_DEFINED__
#define __ISearchAdmin_FWD_DEFINED__
typedef interface ISearchAdmin ISearchAdmin;
#endif 	/* __ISearchAdmin_FWD_DEFINED__ */


#ifndef __IBuildServer_FWD_DEFINED__
#define __IBuildServer_FWD_DEFINED__
typedef interface IBuildServer IBuildServer;
#endif 	/* __IBuildServer_FWD_DEFINED__ */


#ifndef __IBuildCatalogs_FWD_DEFINED__
#define __IBuildCatalogs_FWD_DEFINED__
typedef interface IBuildCatalogs IBuildCatalogs;
#endif 	/* __IBuildCatalogs_FWD_DEFINED__ */


#ifndef __IBuildCatalog_FWD_DEFINED__
#define __IBuildCatalog_FWD_DEFINED__
typedef interface IBuildCatalog IBuildCatalog;
#endif 	/* __IBuildCatalog_FWD_DEFINED__ */


#ifndef __ISearchServer_FWD_DEFINED__
#define __ISearchServer_FWD_DEFINED__
typedef interface ISearchServer ISearchServer;
#endif 	/* __ISearchServer_FWD_DEFINED__ */


#ifndef __ISearchCatalogs_FWD_DEFINED__
#define __ISearchCatalogs_FWD_DEFINED__
typedef interface ISearchCatalogs ISearchCatalogs;
#endif 	/* __ISearchCatalogs_FWD_DEFINED__ */


#ifndef __ISearchCatalog_FWD_DEFINED__
#define __ISearchCatalog_FWD_DEFINED__
typedef interface ISearchCatalog ISearchCatalog;
#endif 	/* __ISearchCatalog_FWD_DEFINED__ */


#ifndef __IBuildServer_FWD_DEFINED__
#define __IBuildServer_FWD_DEFINED__
typedef interface IBuildServer IBuildServer;
#endif 	/* __IBuildServer_FWD_DEFINED__ */


#ifndef __IBuildCatalogs_FWD_DEFINED__
#define __IBuildCatalogs_FWD_DEFINED__
typedef interface IBuildCatalogs IBuildCatalogs;
#endif 	/* __IBuildCatalogs_FWD_DEFINED__ */


#ifndef __IBuildCatalog_FWD_DEFINED__
#define __IBuildCatalog_FWD_DEFINED__
typedef interface IBuildCatalog IBuildCatalog;
#endif 	/* __IBuildCatalog_FWD_DEFINED__ */


#ifndef __ISearchServer_FWD_DEFINED__
#define __ISearchServer_FWD_DEFINED__
typedef interface ISearchServer ISearchServer;
#endif 	/* __ISearchServer_FWD_DEFINED__ */


#ifndef __ISearchCatalogs_FWD_DEFINED__
#define __ISearchCatalogs_FWD_DEFINED__
typedef interface ISearchCatalogs ISearchCatalogs;
#endif 	/* __ISearchCatalogs_FWD_DEFINED__ */


#ifndef __ISearchCatalog_FWD_DEFINED__
#define __ISearchCatalog_FWD_DEFINED__
typedef interface ISearchCatalog ISearchCatalog;
#endif 	/* __ISearchCatalog_FWD_DEFINED__ */


#ifndef __SearchAdmin_FWD_DEFINED__
#define __SearchAdmin_FWD_DEFINED__

#ifdef __cplusplus
typedef class SearchAdmin SearchAdmin;
#else
typedef struct SearchAdmin SearchAdmin;
#endif /* __cplusplus */

#endif 	/* __SearchAdmin_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "gthradminsdk.h"
#include "schemaedit.h"
#include "idxadminsdk.h"
#include "catprops.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISearchAdmin_INTERFACE_DEFINED__
#define __ISearchAdmin_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISearchAdmin
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISearchAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0b63e355-9ccc-11d0-bcdb-00805fccce04")
    ISearchAdmin : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_HostName( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BuildServer( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchServer( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchAdmin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchAdmin __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchAdmin __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchAdmin __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchAdmin __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchAdmin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchAdmin __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HostName )( 
            ISearchAdmin __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HostName )( 
            ISearchAdmin __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BuildServer )( 
            ISearchAdmin __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchServer )( 
            ISearchAdmin __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer);
        
        END_INTERFACE
    } ISearchAdminVtbl;

    interface ISearchAdmin
    {
        CONST_VTBL struct ISearchAdminVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchAdmin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchAdmin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchAdmin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchAdmin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchAdmin_get_HostName(This,pbstrName)	\
    (This)->lpVtbl -> get_HostName(This,pbstrName)

#define ISearchAdmin_put_HostName(This,bstrName)	\
    (This)->lpVtbl -> put_HostName(This,bstrName)

#define ISearchAdmin_get_BuildServer(This,pvarBuildServer)	\
    (This)->lpVtbl -> get_BuildServer(This,pvarBuildServer)

#define ISearchAdmin_get_SearchServer(This,pvarSearchServer)	\
    (This)->lpVtbl -> get_SearchServer(This,pvarSearchServer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchAdmin_get_HostName_Proxy( 
    ISearchAdmin __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB ISearchAdmin_get_HostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ISearchAdmin_put_HostName_Proxy( 
    ISearchAdmin __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB ISearchAdmin_put_HostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchAdmin_get_BuildServer_Proxy( 
    ISearchAdmin __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer);


void __RPC_STUB ISearchAdmin_get_BuildServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchAdmin_get_SearchServer_Proxy( 
    ISearchAdmin __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer);


void __RPC_STUB ISearchAdmin_get_SearchServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchAdmin_INTERFACE_DEFINED__ */


#ifndef __IBuildServer_INTERFACE_DEFINED__
#define __IBuildServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBuildServer
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IBuildServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0b63e356-9ccc-11d0-bcdb-00805fccce04")
    IBuildServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserAgent( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UserAgent( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TempPath( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_TempPath( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PerformanceLevel( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PerformanceLevel( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCatalogsLocation( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultCatalogsLocation( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectTimeout( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DataTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DataTimeout( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultAccountName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultPluginAccountName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchAdmin( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchAdmin) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BuildCatalogs( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildCatalogs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Sites( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarServers) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProxyUsageSetting( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProxyAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAddress) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProxyPortNumber( 
            /* [retval][out] */ LONG __RPC_FAR *pnPort) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProxyBypassForLocalAddresses( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProxyBypassAddressesList( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultLogsLocation( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultLogsLocation( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultAccount( 
            /* [in] */ BSTR bstrAccountName,
            /* [in] */ BSTR bstrPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultPluginAccount( 
            /* [in] */ BSTR bstrAccountName,
            /* [in] */ BSTR bstrPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExportCatalog( 
            /* [in] */ BSTR bstrCatalogName,
            /* [in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImportCatalog( 
            /* [in] */ BSTR bstrCatalogName,
            /* [in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetProxySettings( 
            /* [in] */ LONG nUsageSetting,
            /* [in] */ BSTR bstrAddress,
            /* [in] */ LONG nPort,
            /* [in] */ LONG nBypassForLocalAddresses,
            /* [in] */ BSTR bstrBypassAddressesList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadConfiguration( 
            /* [in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SaveConfiguration( 
            /* [in] */ BSTR bstrFilePath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBuildServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBuildServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBuildServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBuildServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserAgent )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserAgent )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddress )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EmailAddress )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TempPath )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TempPath )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PerformanceLevel )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PerformanceLevel )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultCatalogsLocation )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultCatalogsLocation )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectTimeout )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectTimeout )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataTimeout )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DataTimeout )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultAccountName )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultPluginAccountName )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchAdmin )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchAdmin);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BuildCatalogs )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildCatalogs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sites )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarServers);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProxyUsageSetting )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProxyAddress )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAddress);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProxyPortNumber )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pnPort);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProxyBypassForLocalAddresses )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProxyBypassAddressesList )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultLogsLocation )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultLogsLocation )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IBuildServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultAccount )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR bstrAccountName,
            /* [in] */ BSTR bstrPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultPluginAccount )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR bstrAccountName,
            /* [in] */ BSTR bstrPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportCatalog )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR bstrCatalogName,
            /* [in] */ BSTR bstrFilePath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportCatalog )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR bstrCatalogName,
            /* [in] */ BSTR bstrFilePath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxySettings )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ LONG nUsageSetting,
            /* [in] */ BSTR bstrAddress,
            /* [in] */ LONG nPort,
            /* [in] */ LONG nBypassForLocalAddresses,
            /* [in] */ BSTR bstrBypassAddressesList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadConfiguration )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR bstrFilePath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveConfiguration )( 
            IBuildServer __RPC_FAR * This,
            /* [in] */ BSTR bstrFilePath);
        
        END_INTERFACE
    } IBuildServerVtbl;

    interface IBuildServer
    {
        CONST_VTBL struct IBuildServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBuildServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBuildServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBuildServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBuildServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBuildServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBuildServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBuildServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBuildServer_get_UserAgent(This,pVal)	\
    (This)->lpVtbl -> get_UserAgent(This,pVal)

#define IBuildServer_put_UserAgent(This,newVal)	\
    (This)->lpVtbl -> put_UserAgent(This,newVal)

#define IBuildServer_get_EmailAddress(This,pVal)	\
    (This)->lpVtbl -> get_EmailAddress(This,pVal)

#define IBuildServer_put_EmailAddress(This,newVal)	\
    (This)->lpVtbl -> put_EmailAddress(This,newVal)

#define IBuildServer_get_TempPath(This,pVal)	\
    (This)->lpVtbl -> get_TempPath(This,pVal)

#define IBuildServer_put_TempPath(This,newVal)	\
    (This)->lpVtbl -> put_TempPath(This,newVal)

#define IBuildServer_get_PerformanceLevel(This,pVal)	\
    (This)->lpVtbl -> get_PerformanceLevel(This,pVal)

#define IBuildServer_put_PerformanceLevel(This,newVal)	\
    (This)->lpVtbl -> put_PerformanceLevel(This,newVal)

#define IBuildServer_get_DefaultCatalogsLocation(This,pVal)	\
    (This)->lpVtbl -> get_DefaultCatalogsLocation(This,pVal)

#define IBuildServer_put_DefaultCatalogsLocation(This,newVal)	\
    (This)->lpVtbl -> put_DefaultCatalogsLocation(This,newVal)

#define IBuildServer_get_ConnectTimeout(This,pVal)	\
    (This)->lpVtbl -> get_ConnectTimeout(This,pVal)

#define IBuildServer_put_ConnectTimeout(This,newVal)	\
    (This)->lpVtbl -> put_ConnectTimeout(This,newVal)

#define IBuildServer_get_DataTimeout(This,pVal)	\
    (This)->lpVtbl -> get_DataTimeout(This,pVal)

#define IBuildServer_put_DataTimeout(This,newVal)	\
    (This)->lpVtbl -> put_DataTimeout(This,newVal)

#define IBuildServer_get_DefaultAccountName(This,pVal)	\
    (This)->lpVtbl -> get_DefaultAccountName(This,pVal)

#define IBuildServer_get_DefaultPluginAccountName(This,pVal)	\
    (This)->lpVtbl -> get_DefaultPluginAccountName(This,pVal)

#define IBuildServer_get_SearchAdmin(This,pvarSearchAdmin)	\
    (This)->lpVtbl -> get_SearchAdmin(This,pvarSearchAdmin)

#define IBuildServer_get_BuildCatalogs(This,pvarBuildCatalogs)	\
    (This)->lpVtbl -> get_BuildCatalogs(This,pvarBuildCatalogs)

#define IBuildServer_get_Sites(This,pvarServers)	\
    (This)->lpVtbl -> get_Sites(This,pvarServers)

#define IBuildServer_get_ProxyUsageSetting(This,pVal)	\
    (This)->lpVtbl -> get_ProxyUsageSetting(This,pVal)

#define IBuildServer_get_ProxyAddress(This,pbstrAddress)	\
    (This)->lpVtbl -> get_ProxyAddress(This,pbstrAddress)

#define IBuildServer_get_ProxyPortNumber(This,pnPort)	\
    (This)->lpVtbl -> get_ProxyPortNumber(This,pnPort)

#define IBuildServer_get_ProxyBypassForLocalAddresses(This,pVal)	\
    (This)->lpVtbl -> get_ProxyBypassForLocalAddresses(This,pVal)

#define IBuildServer_get_ProxyBypassAddressesList(This,pVal)	\
    (This)->lpVtbl -> get_ProxyBypassAddressesList(This,pVal)

#define IBuildServer_get_DefaultLogsLocation(This,pVal)	\
    (This)->lpVtbl -> get_DefaultLogsLocation(This,pVal)

#define IBuildServer_put_DefaultLogsLocation(This,newVal)	\
    (This)->lpVtbl -> put_DefaultLogsLocation(This,newVal)

#define IBuildServer_Clone(This,pvarBuildServer)	\
    (This)->lpVtbl -> Clone(This,pvarBuildServer)

#define IBuildServer_SetDefaultAccount(This,bstrAccountName,bstrPassword)	\
    (This)->lpVtbl -> SetDefaultAccount(This,bstrAccountName,bstrPassword)

#define IBuildServer_SetDefaultPluginAccount(This,bstrAccountName,bstrPassword)	\
    (This)->lpVtbl -> SetDefaultPluginAccount(This,bstrAccountName,bstrPassword)

#define IBuildServer_ExportCatalog(This,bstrCatalogName,bstrFilePath)	\
    (This)->lpVtbl -> ExportCatalog(This,bstrCatalogName,bstrFilePath)

#define IBuildServer_ImportCatalog(This,bstrCatalogName,bstrFilePath)	\
    (This)->lpVtbl -> ImportCatalog(This,bstrCatalogName,bstrFilePath)

#define IBuildServer_SetProxySettings(This,nUsageSetting,bstrAddress,nPort,nBypassForLocalAddresses,bstrBypassAddressesList)	\
    (This)->lpVtbl -> SetProxySettings(This,nUsageSetting,bstrAddress,nPort,nBypassForLocalAddresses,bstrBypassAddressesList)

#define IBuildServer_LoadConfiguration(This,bstrFilePath)	\
    (This)->lpVtbl -> LoadConfiguration(This,bstrFilePath)

#define IBuildServer_SaveConfiguration(This,bstrFilePath)	\
    (This)->lpVtbl -> SaveConfiguration(This,bstrFilePath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_UserAgent_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_UserAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_UserAgent_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IBuildServer_put_UserAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_EmailAddress_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_EmailAddress_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IBuildServer_put_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_TempPath_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_TempPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_TempPath_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IBuildServer_put_TempPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_PerformanceLevel_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_PerformanceLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_PerformanceLevel_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IBuildServer_put_PerformanceLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_DefaultCatalogsLocation_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_DefaultCatalogsLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_DefaultCatalogsLocation_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IBuildServer_put_DefaultCatalogsLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_ConnectTimeout_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_ConnectTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_ConnectTimeout_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IBuildServer_put_ConnectTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_DataTimeout_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_DataTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_DataTimeout_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IBuildServer_put_DataTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_DefaultAccountName_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_DefaultAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_DefaultPluginAccountName_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_DefaultPluginAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_SearchAdmin_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchAdmin);


void __RPC_STUB IBuildServer_get_SearchAdmin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_BuildCatalogs_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildCatalogs);


void __RPC_STUB IBuildServer_get_BuildCatalogs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_Sites_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarServers);


void __RPC_STUB IBuildServer_get_Sites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_ProxyUsageSetting_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_ProxyUsageSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_ProxyAddress_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrAddress);


void __RPC_STUB IBuildServer_get_ProxyAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_ProxyPortNumber_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pnPort);


void __RPC_STUB IBuildServer_get_ProxyPortNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_ProxyBypassForLocalAddresses_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_ProxyBypassForLocalAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_ProxyBypassAddressesList_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_ProxyBypassAddressesList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildServer_get_DefaultLogsLocation_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildServer_get_DefaultLogsLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildServer_put_DefaultLogsLocation_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IBuildServer_put_DefaultLogsLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_Clone_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer);


void __RPC_STUB IBuildServer_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_SetDefaultAccount_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR bstrAccountName,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB IBuildServer_SetDefaultAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_SetDefaultPluginAccount_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR bstrAccountName,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB IBuildServer_SetDefaultPluginAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_ExportCatalog_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR bstrCatalogName,
    /* [in] */ BSTR bstrFilePath);


void __RPC_STUB IBuildServer_ExportCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_ImportCatalog_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR bstrCatalogName,
    /* [in] */ BSTR bstrFilePath);


void __RPC_STUB IBuildServer_ImportCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_SetProxySettings_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ LONG nUsageSetting,
    /* [in] */ BSTR bstrAddress,
    /* [in] */ LONG nPort,
    /* [in] */ LONG nBypassForLocalAddresses,
    /* [in] */ BSTR bstrBypassAddressesList);


void __RPC_STUB IBuildServer_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_LoadConfiguration_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR bstrFilePath);


void __RPC_STUB IBuildServer_LoadConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildServer_SaveConfiguration_Proxy( 
    IBuildServer __RPC_FAR * This,
    /* [in] */ BSTR bstrFilePath);


void __RPC_STUB IBuildServer_SaveConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBuildServer_INTERFACE_DEFINED__ */


#ifndef __IBuildCatalogs_INTERFACE_DEFINED__
#define __IBuildCatalogs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBuildCatalogs
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IBuildCatalogs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0b63e360-9ccc-11d0-bcdb-00805fccce04")
    IBuildCatalogs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalog) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR bstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBuildCatalogsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBuildCatalogs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBuildCatalogs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalog);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IBuildCatalogs __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        END_INTERFACE
    } IBuildCatalogsVtbl;

    interface IBuildCatalogs
    {
        CONST_VTBL struct IBuildCatalogsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBuildCatalogs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBuildCatalogs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBuildCatalogs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBuildCatalogs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBuildCatalogs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBuildCatalogs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBuildCatalogs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBuildCatalogs_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IBuildCatalogs_get_Item(This,bstrName,pvarCatalog)	\
    (This)->lpVtbl -> get_Item(This,bstrName,pvarCatalog)

#define IBuildCatalogs_get__NewEnum(This,pNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,pNewEnum)

#define IBuildCatalogs_Add(This,bstrName,bstrPath,pvarCatalog)	\
    (This)->lpVtbl -> Add(This,bstrName,bstrPath,pvarCatalog)

#define IBuildCatalogs_Remove(This,bstrName)	\
    (This)->lpVtbl -> Remove(This,bstrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalogs_get_Count_Proxy( 
    IBuildCatalogs __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB IBuildCatalogs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalogs_get_Item_Proxy( 
    IBuildCatalogs __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalog);


void __RPC_STUB IBuildCatalogs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalogs_get__NewEnum_Proxy( 
    IBuildCatalogs __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum);


void __RPC_STUB IBuildCatalogs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalogs_Add_Proxy( 
    IBuildCatalogs __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPath,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalog);


void __RPC_STUB IBuildCatalogs_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalogs_Remove_Proxy( 
    IBuildCatalogs __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IBuildCatalogs_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBuildCatalogs_INTERFACE_DEFINED__ */


#ifndef __IBuildCatalog_INTERFACE_DEFINED__
#define __IBuildCatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBuildCatalog
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IBuildCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0b63e354-9ccc-11d0-bcdb-00805fccce04")
    IBuildCatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LogSuccess( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LogSuccess( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LogExcluded( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LogExcluded( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BuildServer( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StartPages( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarStartPages) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Sites( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSites) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Extensions( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExtensions) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Mappings( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarMappings) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Protocols( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProtocols) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPages( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsBuilding( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchServers( 
            /* [retval][out] */ VARIANT __RPC_FAR *pSearchServers) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FollowComplexUrls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FollowComplexUrls( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProjectType( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ProjectType( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NotificationSource( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_NotificationSource( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentBuildProperties( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreviousBuildProperties( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Logs( 
            /* [retval][out] */ VARIANT __RPC_FAR *pGatherLogs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AutoPropLimitEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AutoPropLimitEnabled( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AutoPropLimit( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AutoPropLimit( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsLocalFileSchema( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_IsLocalFileSchema( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Schema( 
            /* [retval][out] */ VARIANT __RPC_FAR *pSearchSchema) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildCatalog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartIncrementalBuild( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartBuild( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopBuild( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PauseBuild( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResumeBuild( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ForceProp( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AbortProp( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBuildCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBuildCatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBuildCatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBuildCatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogSuccess )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LogSuccess )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogExcluded )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LogExcluded )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BuildServer )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartPages )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarStartPages);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sites )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSites);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Extensions )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExtensions);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mappings )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarMappings);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Protocols )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProtocols);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusCode )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentPages )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBuilding )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchServers )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pSearchServers);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FollowComplexUrls )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FollowComplexUrls )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProjectType )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProjectType )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NotificationSource )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NotificationSource )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentBuildProperties )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreviousBuildProperties )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Logs )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pGatherLogs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoPropLimitEnabled )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoPropLimitEnabled )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoPropLimit )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoPropLimit )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsLocalFileSchema )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsLocalFileSchema )( 
            IBuildCatalog __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schema )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pSearchSchema);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IBuildCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildCatalog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartIncrementalBuild )( 
            IBuildCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartBuild )( 
            IBuildCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuild )( 
            IBuildCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseBuild )( 
            IBuildCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeBuild )( 
            IBuildCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ForceProp )( 
            IBuildCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AbortProp )( 
            IBuildCatalog __RPC_FAR * This);
        
        END_INTERFACE
    } IBuildCatalogVtbl;

    interface IBuildCatalog
    {
        CONST_VTBL struct IBuildCatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBuildCatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBuildCatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBuildCatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBuildCatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBuildCatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBuildCatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBuildCatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBuildCatalog_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IBuildCatalog_get_LogSuccess(This,pVal)	\
    (This)->lpVtbl -> get_LogSuccess(This,pVal)

#define IBuildCatalog_put_LogSuccess(This,newVal)	\
    (This)->lpVtbl -> put_LogSuccess(This,newVal)

#define IBuildCatalog_get_LogExcluded(This,pVal)	\
    (This)->lpVtbl -> get_LogExcluded(This,pVal)

#define IBuildCatalog_put_LogExcluded(This,newVal)	\
    (This)->lpVtbl -> put_LogExcluded(This,newVal)

#define IBuildCatalog_get_BuildServer(This,pvarBuildServer)	\
    (This)->lpVtbl -> get_BuildServer(This,pvarBuildServer)

#define IBuildCatalog_get_StartPages(This,pvarStartPages)	\
    (This)->lpVtbl -> get_StartPages(This,pvarStartPages)

#define IBuildCatalog_get_Sites(This,pvarSites)	\
    (This)->lpVtbl -> get_Sites(This,pvarSites)

#define IBuildCatalog_get_Extensions(This,pvarExtensions)	\
    (This)->lpVtbl -> get_Extensions(This,pvarExtensions)

#define IBuildCatalog_get_Mappings(This,pvarMappings)	\
    (This)->lpVtbl -> get_Mappings(This,pvarMappings)

#define IBuildCatalog_get_Protocols(This,pvarProtocols)	\
    (This)->lpVtbl -> get_Protocols(This,pvarProtocols)

#define IBuildCatalog_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IBuildCatalog_get_StatusCode(This,pVal)	\
    (This)->lpVtbl -> get_StatusCode(This,pVal)

#define IBuildCatalog_get_CurrentPages(This,pVal)	\
    (This)->lpVtbl -> get_CurrentPages(This,pVal)

#define IBuildCatalog_get_IsBuilding(This,pVal)	\
    (This)->lpVtbl -> get_IsBuilding(This,pVal)

#define IBuildCatalog_get_SearchServers(This,pSearchServers)	\
    (This)->lpVtbl -> get_SearchServers(This,pSearchServers)

#define IBuildCatalog_get_FollowComplexUrls(This,pVal)	\
    (This)->lpVtbl -> get_FollowComplexUrls(This,pVal)

#define IBuildCatalog_put_FollowComplexUrls(This,newVal)	\
    (This)->lpVtbl -> put_FollowComplexUrls(This,newVal)

#define IBuildCatalog_get_ProjectType(This,pVal)	\
    (This)->lpVtbl -> get_ProjectType(This,pVal)

#define IBuildCatalog_put_ProjectType(This,newVal)	\
    (This)->lpVtbl -> put_ProjectType(This,newVal)

#define IBuildCatalog_get_NotificationSource(This,pVal)	\
    (This)->lpVtbl -> get_NotificationSource(This,pVal)

#define IBuildCatalog_put_NotificationSource(This,newVal)	\
    (This)->lpVtbl -> put_NotificationSource(This,newVal)

#define IBuildCatalog_get_CurrentBuildProperties(This,pvarCatalogProperties)	\
    (This)->lpVtbl -> get_CurrentBuildProperties(This,pvarCatalogProperties)

#define IBuildCatalog_get_PreviousBuildProperties(This,pvarCatalogProperties)	\
    (This)->lpVtbl -> get_PreviousBuildProperties(This,pvarCatalogProperties)

#define IBuildCatalog_get_Logs(This,pGatherLogs)	\
    (This)->lpVtbl -> get_Logs(This,pGatherLogs)

#define IBuildCatalog_get_AutoPropLimitEnabled(This,pVal)	\
    (This)->lpVtbl -> get_AutoPropLimitEnabled(This,pVal)

#define IBuildCatalog_put_AutoPropLimitEnabled(This,newVal)	\
    (This)->lpVtbl -> put_AutoPropLimitEnabled(This,newVal)

#define IBuildCatalog_get_AutoPropLimit(This,pVal)	\
    (This)->lpVtbl -> get_AutoPropLimit(This,pVal)

#define IBuildCatalog_put_AutoPropLimit(This,newVal)	\
    (This)->lpVtbl -> put_AutoPropLimit(This,newVal)

#define IBuildCatalog_get_IsLocalFileSchema(This,pVal)	\
    (This)->lpVtbl -> get_IsLocalFileSchema(This,pVal)

#define IBuildCatalog_put_IsLocalFileSchema(This,newVal)	\
    (This)->lpVtbl -> put_IsLocalFileSchema(This,newVal)

#define IBuildCatalog_get_Schema(This,pSearchSchema)	\
    (This)->lpVtbl -> get_Schema(This,pSearchSchema)

#define IBuildCatalog_Clone(This,pvarBuildCatalog)	\
    (This)->lpVtbl -> Clone(This,pvarBuildCatalog)

#define IBuildCatalog_StartIncrementalBuild(This)	\
    (This)->lpVtbl -> StartIncrementalBuild(This)

#define IBuildCatalog_StartBuild(This)	\
    (This)->lpVtbl -> StartBuild(This)

#define IBuildCatalog_StopBuild(This)	\
    (This)->lpVtbl -> StopBuild(This)

#define IBuildCatalog_PauseBuild(This)	\
    (This)->lpVtbl -> PauseBuild(This)

#define IBuildCatalog_ResumeBuild(This)	\
    (This)->lpVtbl -> ResumeBuild(This)

#define IBuildCatalog_ForceProp(This)	\
    (This)->lpVtbl -> ForceProp(This)

#define IBuildCatalog_AbortProp(This)	\
    (This)->lpVtbl -> AbortProp(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Name_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_LogSuccess_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_LogSuccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_LogSuccess_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IBuildCatalog_put_LogSuccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_LogExcluded_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_LogExcluded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_LogExcluded_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IBuildCatalog_put_LogExcluded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_BuildServer_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildServer);


void __RPC_STUB IBuildCatalog_get_BuildServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_StartPages_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarStartPages);


void __RPC_STUB IBuildCatalog_get_StartPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Sites_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSites);


void __RPC_STUB IBuildCatalog_get_Sites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Extensions_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExtensions);


void __RPC_STUB IBuildCatalog_get_Extensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Mappings_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarMappings);


void __RPC_STUB IBuildCatalog_get_Mappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Protocols_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProtocols);


void __RPC_STUB IBuildCatalog_get_Protocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Status_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_StatusCode_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_StatusCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_CurrentPages_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_CurrentPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_IsBuilding_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_IsBuilding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_SearchServers_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pSearchServers);


void __RPC_STUB IBuildCatalog_get_SearchServers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_FollowComplexUrls_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_FollowComplexUrls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_FollowComplexUrls_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IBuildCatalog_put_FollowComplexUrls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_ProjectType_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_ProjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_ProjectType_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IBuildCatalog_put_ProjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_NotificationSource_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_NotificationSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_NotificationSource_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IBuildCatalog_put_NotificationSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_CurrentBuildProperties_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties);


void __RPC_STUB IBuildCatalog_get_CurrentBuildProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_PreviousBuildProperties_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties);


void __RPC_STUB IBuildCatalog_get_PreviousBuildProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Logs_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pGatherLogs);


void __RPC_STUB IBuildCatalog_get_Logs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_AutoPropLimitEnabled_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_AutoPropLimitEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_AutoPropLimitEnabled_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IBuildCatalog_put_AutoPropLimitEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_AutoPropLimit_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_AutoPropLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_AutoPropLimit_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IBuildCatalog_put_AutoPropLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_IsLocalFileSchema_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IBuildCatalog_get_IsLocalFileSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_put_IsLocalFileSchema_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IBuildCatalog_put_IsLocalFileSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_get_Schema_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pSearchSchema);


void __RPC_STUB IBuildCatalog_get_Schema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_Clone_Proxy( 
    IBuildCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBuildCatalog);


void __RPC_STUB IBuildCatalog_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_StartIncrementalBuild_Proxy( 
    IBuildCatalog __RPC_FAR * This);


void __RPC_STUB IBuildCatalog_StartIncrementalBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_StartBuild_Proxy( 
    IBuildCatalog __RPC_FAR * This);


void __RPC_STUB IBuildCatalog_StartBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_StopBuild_Proxy( 
    IBuildCatalog __RPC_FAR * This);


void __RPC_STUB IBuildCatalog_StopBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_PauseBuild_Proxy( 
    IBuildCatalog __RPC_FAR * This);


void __RPC_STUB IBuildCatalog_PauseBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_ResumeBuild_Proxy( 
    IBuildCatalog __RPC_FAR * This);


void __RPC_STUB IBuildCatalog_ResumeBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_ForceProp_Proxy( 
    IBuildCatalog __RPC_FAR * This);


void __RPC_STUB IBuildCatalog_ForceProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBuildCatalog_AbortProp_Proxy( 
    IBuildCatalog __RPC_FAR * This);


void __RPC_STUB IBuildCatalog_AbortProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBuildCatalog_INTERFACE_DEFINED__ */


#ifndef __ISearchServer_INTERFACE_DEFINED__
#define __ISearchServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISearchServer
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISearchServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0b63e357-9ccc-11d0-bcdb-00805fccce04")
    ISearchServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchAdmin( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchAdmin) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchCatalogs( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalogs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PerformanceLevel( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PerformanceLevel( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CatalogsLocation( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_CatalogsLocation( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCatalog( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchCatalogName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultCatalog( 
            /* [in] */ BSTR bstrSearchCatalogName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchAdmin )( 
            ISearchServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchAdmin);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchCatalogs )( 
            ISearchServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalogs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PerformanceLevel )( 
            ISearchServer __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PerformanceLevel )( 
            ISearchServer __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CatalogsLocation )( 
            ISearchServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CatalogsLocation )( 
            ISearchServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultCatalog )( 
            ISearchServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchCatalogName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultCatalog )( 
            ISearchServer __RPC_FAR * This,
            /* [in] */ BSTR bstrSearchCatalogName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            ISearchServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer);
        
        END_INTERFACE
    } ISearchServerVtbl;

    interface ISearchServer
    {
        CONST_VTBL struct ISearchServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchServer_get_SearchAdmin(This,pvarSearchAdmin)	\
    (This)->lpVtbl -> get_SearchAdmin(This,pvarSearchAdmin)

#define ISearchServer_get_SearchCatalogs(This,pvarSearchCatalogs)	\
    (This)->lpVtbl -> get_SearchCatalogs(This,pvarSearchCatalogs)

#define ISearchServer_get_PerformanceLevel(This,pVal)	\
    (This)->lpVtbl -> get_PerformanceLevel(This,pVal)

#define ISearchServer_put_PerformanceLevel(This,newVal)	\
    (This)->lpVtbl -> put_PerformanceLevel(This,newVal)

#define ISearchServer_get_CatalogsLocation(This,pVal)	\
    (This)->lpVtbl -> get_CatalogsLocation(This,pVal)

#define ISearchServer_put_CatalogsLocation(This,newVal)	\
    (This)->lpVtbl -> put_CatalogsLocation(This,newVal)

#define ISearchServer_get_DefaultCatalog(This,pbstrSearchCatalogName)	\
    (This)->lpVtbl -> get_DefaultCatalog(This,pbstrSearchCatalogName)

#define ISearchServer_put_DefaultCatalog(This,bstrSearchCatalogName)	\
    (This)->lpVtbl -> put_DefaultCatalog(This,bstrSearchCatalogName)

#define ISearchServer_Clone(This,pvarSearchServer)	\
    (This)->lpVtbl -> Clone(This,pvarSearchServer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchServer_get_SearchAdmin_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchAdmin);


void __RPC_STUB ISearchServer_get_SearchAdmin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchServer_get_SearchCatalogs_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalogs);


void __RPC_STUB ISearchServer_get_SearchCatalogs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchServer_get_PerformanceLevel_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB ISearchServer_get_PerformanceLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ISearchServer_put_PerformanceLevel_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB ISearchServer_put_PerformanceLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchServer_get_CatalogsLocation_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISearchServer_get_CatalogsLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ISearchServer_put_CatalogsLocation_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISearchServer_put_CatalogsLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchServer_get_DefaultCatalog_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchCatalogName);


void __RPC_STUB ISearchServer_get_DefaultCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ISearchServer_put_DefaultCatalog_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [in] */ BSTR bstrSearchCatalogName);


void __RPC_STUB ISearchServer_put_DefaultCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearchServer_Clone_Proxy( 
    ISearchServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer);


void __RPC_STUB ISearchServer_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchServer_INTERFACE_DEFINED__ */


#ifndef __ISearchCatalogs_INTERFACE_DEFINED__
#define __ISearchCatalogs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISearchCatalogs
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISearchCatalogs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0b63e361-9ccc-11d0-bcdb-00805fccce04")
    ISearchCatalogs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR bstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchCatalogsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchCatalogs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchCatalogs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            ISearchCatalogs __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        END_INTERFACE
    } ISearchCatalogsVtbl;

    interface ISearchCatalogs
    {
        CONST_VTBL struct ISearchCatalogsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchCatalogs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchCatalogs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchCatalogs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchCatalogs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchCatalogs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchCatalogs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchCatalogs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchCatalogs_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define ISearchCatalogs_get_Item(This,bstrName,pvarSearchCatalog)	\
    (This)->lpVtbl -> get_Item(This,bstrName,pvarSearchCatalog)

#define ISearchCatalogs_get__NewEnum(This,pNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,pNewEnum)

#define ISearchCatalogs_Add(This,bstrName,pvarSearchCatalog)	\
    (This)->lpVtbl -> Add(This,bstrName,pvarSearchCatalog)

#define ISearchCatalogs_Remove(This,bstrName)	\
    (This)->lpVtbl -> Remove(This,bstrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalogs_get_Count_Proxy( 
    ISearchCatalogs __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ISearchCatalogs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalogs_get_Item_Proxy( 
    ISearchCatalogs __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog);


void __RPC_STUB ISearchCatalogs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalogs_get__NewEnum_Proxy( 
    ISearchCatalogs __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum);


void __RPC_STUB ISearchCatalogs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearchCatalogs_Add_Proxy( 
    ISearchCatalogs __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog);


void __RPC_STUB ISearchCatalogs_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearchCatalogs_Remove_Proxy( 
    ISearchCatalogs __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB ISearchCatalogs_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchCatalogs_INTERFACE_DEFINED__ */


#ifndef __ISearchCatalog_INTERFACE_DEFINED__
#define __ISearchCatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISearchCatalog
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISearchCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0b63e35e-9ccc-11d0-bcdb-00805fccce04")
    ISearchCatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BuildServerName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchServer( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryTimeout( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_QueryTimeout( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxResultRows( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MaxResultRows( 
            /* [in] */ DWORD newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Enable( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Disable( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Update( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchCatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchCatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchCatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchCatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchCatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BuildServerName )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchServer )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryTimeout )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_QueryTimeout )( 
            ISearchCatalog __RPC_FAR * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxResultRows )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxResultRows )( 
            ISearchCatalog __RPC_FAR * This,
            /* [in] */ DWORD newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            ISearchCatalog __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enable )( 
            ISearchCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disable )( 
            ISearchCatalog __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            ISearchCatalog __RPC_FAR * This);
        
        END_INTERFACE
    } ISearchCatalogVtbl;

    interface ISearchCatalog
    {
        CONST_VTBL struct ISearchCatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchCatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchCatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchCatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchCatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchCatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchCatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchCatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchCatalog_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define ISearchCatalog_get_BuildServerName(This,pVal)	\
    (This)->lpVtbl -> get_BuildServerName(This,pVal)

#define ISearchCatalog_get_SearchServer(This,pvarSearchServer)	\
    (This)->lpVtbl -> get_SearchServer(This,pvarSearchServer)

#define ISearchCatalog_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define ISearchCatalog_get_QueryTimeout(This,pVal)	\
    (This)->lpVtbl -> get_QueryTimeout(This,pVal)

#define ISearchCatalog_put_QueryTimeout(This,newVal)	\
    (This)->lpVtbl -> put_QueryTimeout(This,newVal)

#define ISearchCatalog_get_MaxResultRows(This,pVal)	\
    (This)->lpVtbl -> get_MaxResultRows(This,pVal)

#define ISearchCatalog_put_MaxResultRows(This,newVal)	\
    (This)->lpVtbl -> put_MaxResultRows(This,newVal)

#define ISearchCatalog_get_Properties(This,pvarCatalogProperties)	\
    (This)->lpVtbl -> get_Properties(This,pvarCatalogProperties)

#define ISearchCatalog_Clone(This,pvarSearchCatalog)	\
    (This)->lpVtbl -> Clone(This,pvarSearchCatalog)

#define ISearchCatalog_Enable(This)	\
    (This)->lpVtbl -> Enable(This)

#define ISearchCatalog_Disable(This)	\
    (This)->lpVtbl -> Disable(This)

#define ISearchCatalog_Update(This)	\
    (This)->lpVtbl -> Update(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_get_Name_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISearchCatalog_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_get_BuildServerName_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISearchCatalog_get_BuildServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_get_SearchServer_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchServer);


void __RPC_STUB ISearchCatalog_get_SearchServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_get_Status_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISearchCatalog_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_get_QueryTimeout_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB ISearchCatalog_get_QueryTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_put_QueryTimeout_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB ISearchCatalog_put_QueryTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_get_MaxResultRows_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB ISearchCatalog_get_MaxResultRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_put_MaxResultRows_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [in] */ DWORD newVal);


void __RPC_STUB ISearchCatalog_put_MaxResultRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_get_Properties_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarCatalogProperties);


void __RPC_STUB ISearchCatalog_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_Clone_Proxy( 
    ISearchCatalog __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarSearchCatalog);


void __RPC_STUB ISearchCatalog_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_Enable_Proxy( 
    ISearchCatalog __RPC_FAR * This);


void __RPC_STUB ISearchCatalog_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_Disable_Proxy( 
    ISearchCatalog __RPC_FAR * This);


void __RPC_STUB ISearchCatalog_Disable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearchCatalog_Update_Proxy( 
    ISearchCatalog __RPC_FAR * This);


void __RPC_STUB ISearchCatalog_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchCatalog_INTERFACE_DEFINED__ */



#ifndef __NLADMINLib_LIBRARY_DEFINED__
#define __NLADMINLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: NLADMINLib
 * at Wed Apr 22 20:03:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 









EXTERN_C const IID LIBID_NLADMINLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SearchAdmin;

class DECLSPEC_UUID("0b63e35b-9ccc-11d0-bcdb-00805fccce04")
SearchAdmin;
#endif
#endif /* __NLADMINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\newpst.h ===
// --newpst.h-----------------------------------------------------------------
//
// Header file for the newpst library.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All rights reserved.
//
//-----------------------------------------------------------------------------

#ifndef	_NEWPST_H
#define _NEWPST_H

#ifdef  __cplusplus
extern "C" {
#endif

// $--HrCreatePersonalStore----------------------------------------------------------
//
// DESCRIPTION: Create a New PST with properties determined by the input
//				parameters in a temporary profile.  The name and password
//				of the temporary PST are returned to the user.
//
// INPUT:
//
//	[lpszPSTPath]			-- Value for PR_PST_PATH (new PST path).
//	[dwEncryption]			-- Value for PR_PST_ENCRYPTION (TBS).
//	[lpszPSTDisplayName]	-- Value for PR_DISPLAY_NAME (new PST display name).
//	[lpszPSTPassword]		-- Value for PR_PST_PW_SZ_NEW (new PST password,
//							   NULL not accepted).
//
// OUTPUT:
//
//	[lppszProfileName]		-- Ptr that will be set to point at temporary
//							   profile name on return; this may be used to
//							   establish a MAPI session.
//	[lppszProfilePassword]	-- Ptr that will be set to point at temporary
//							   profile password on return; this may be used to
//							   establish a MAPI session.
//
// RETURNS:     NOERROR on success,
//              E_INVALIDARG if bad input,
//              E_ACCESSDENIED if can't access profile,
//              E_FAIL if general failure
//
// Notes:		Successive calls to CreateNewPST() should not be made without
//				intervening calls to NewPSTCleanup().  Due to use of internal
//				static storage for objects and profile strings, only one new
//				PST may be created and used at a time.
//
//---------------------------------------------------------------------------

HRESULT HrCreatePersonalStore(                         // RETURNS: HRESULT
	IN	LPSTR	lpszPSTPath,            // PST fully-pathed file name
	IN	DWORD	dwEncryption,           // encryption method
	IN	LPSTR	lpszPSTDisplayName,     // PR_DISPLAY_NAME value
	IN	LPSTR	lpszPSTPassword,        // PST password
	OUT	LPSTR *	lppszProfileName,       // Temporary profile name
	OUT	LPSTR *	lppszProfilePassword    // Temporary profile password
	);

// $--HrCleanupPSTGlobals---------------------------------------------------------
//
// DESCRIPTION: Release objects involved in creation of a new PST.
//
// INPUT:       temporary profile name
//
// RETURNS:     NOERROR on success
//              E_FAIL on failure
//
// Notes:		This should be called after Logoff() and Release() are called
//				for the LPSESSION and before MAPIUninitialize() is called.
//---------------------------------------------------------------------------

HRESULT HrCleanupPSTGlobals(         // RETURNS: HRESULT
        IN LPSTR lpszProfileName);  // temporary profile name

#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif	// _NEWPST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\newapis.h ===
/*
 *  Copyright (c) 1997-1999, Microsoft Corporation
 *
 *  Wrapper module that "stubs" APIs that were not implemented
 *  on Windows 95 or Windows NT versions less than 4.0 SP 3.
 *
 *  By using this header, your code will run on older platforms.
 *
 *  To enable a particular wrapper, define the corresponding symbol.
 *
 *  Function                Symbol
 *
 *  GetDiskFreeSpaceEx      WANT_GETDISKFREESPACEEX_WRAPPER
 *  GetLongPathName         WANT_GETLONGPATHNAME_WRAPPER
 *  GetFileAttributesEx     WANT_GETFILEATTRIBUTESEX_WRAPPER
 *  IsDebuggerPresent       WANT_ISDEBUGGERPRESENT_WRAPPER
 *
 *  Exactly one source file must include the line
 *
 *  #define COMPILE_NEWAPIS_STUBS
 *
 *  before including this file.
 *
 */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*****************************************************************************
 *
 * GetDiskFreeSpaceEx
 *
 *****************************************************************************/

#ifdef WANT_GETDISKFREESPACEEX_WRAPPER

#undef GetDiskFreeSpaceEx
#define GetDiskFreeSpaceEx _GetDiskFreeSpaceEx

extern BOOL (CALLBACK *GetDiskFreeSpaceEx)
             (LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

/*
 * Exactly one file should define this symbol.
 */
#ifdef COMPILE_NEWAPIS_STUBS

/*
 * The version to use if we are forced to emulate.
 */
static BOOL WINAPI
Emulate_GetDiskFreeSpaceEx(LPCTSTR ptszRoot, PULARGE_INTEGER pliQuota,
                         PULARGE_INTEGER pliTotal, PULARGE_INTEGER pliFree)
{
    DWORD dwSecPerClus, dwBytesPerSec, dwFreeClus, dwTotalClus;
    BOOL fRc;

    fRc = GetDiskFreeSpace(ptszRoot, &dwSecPerClus, &dwBytesPerSec,
                           &dwFreeClus, &dwTotalClus);
    if (fRc) {
        DWORD dwBytesPerClus = dwSecPerClus * dwBytesPerSec;

        /*
         *  Curiously, of all the output parameters, only pliFree is
         *  allowed to be NULL.
         */

        *(__int64 *)pliQuota = Int32x32To64(dwBytesPerClus, dwFreeClus);
        if (pliFree) {
            *pliFree = *pliQuota;
        }

        *(__int64 *)pliTotal = Int32x32To64(dwBytesPerClus, dwTotalClus);
    }

    return fRc;
}

/*
 * The stub that probes to decide which version to use.
 */
static BOOL WINAPI
Probe_GetDiskFreeSpaceEx(LPCTSTR ptszRoot, PULARGE_INTEGER pliQuota,
                         PULARGE_INTEGER pliTotal, PULARGE_INTEGER pliFree)
{
    HINSTANCE hinst;
    FARPROC fp;
    BOOL fRc;
    BOOL (CALLBACK *RealGetDiskFreeSpaceEx)
             (LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

    hinst = GetModuleHandle(TEXT("KERNEL32"));
#ifdef UNICODE
    fp = GetProcAddress(hinst, "GetDiskFreeSpaceExW");
#else
    fp = GetProcAddress(hinst, "GetDiskFreeSpaceExA");
#endif

    if (fp) {
        *(FARPROC *)&RealGetDiskFreeSpaceEx = fp;
        fRc = RealGetDiskFreeSpaceEx(ptszRoot, pliQuota, pliTotal, pliFree);
        if (fRc || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED) {
            GetDiskFreeSpaceEx = RealGetDiskFreeSpaceEx;
        } else {
            GetDiskFreeSpaceEx = Emulate_GetDiskFreeSpaceEx;
            fRc = GetDiskFreeSpaceEx(ptszRoot, pliQuota, pliTotal, pliFree);
        }
    } else {
        GetDiskFreeSpaceEx = Emulate_GetDiskFreeSpaceEx;
        fRc = GetDiskFreeSpaceEx(ptszRoot, pliQuota, pliTotal, pliFree);
    }

    return fRc;

}

BOOL (CALLBACK *GetDiskFreeSpaceEx)
             (LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER) =
                Probe_GetDiskFreeSpaceEx;

#endif /* COMPILE_NEWAPIS_STUBS */
#endif /* WANT_GETDISKFREESPACEEX_WRAPPER */

/*****************************************************************************
 *
 * GetLongPathName
 *
 *****************************************************************************/

#ifdef WANT_GETLONGPATHNAME_WRAPPER

#include <shlobj.h>

#undef GetLongPathName
#define GetLongPathName _GetLongPathName

extern DWORD (CALLBACK *GetLongPathName)(LPCTSTR, LPTSTR, DWORD);

/*
 * Exactly one file should define this symbol.
 */
#ifdef COMPILE_NEWAPIS_STUBS

/*
 * The version to use if we are forced to emulate.
 */
static DWORD WINAPI
Emulate_GetLongPathName(LPCTSTR ptszShort, LPTSTR ptszLong, DWORD ctchBuf)
{
    LPSHELLFOLDER psfDesk;
    HRESULT hr;
    LPITEMIDLIST pidl;
    TCHAR tsz[MAX_PATH];            /* Scratch TCHAR buffer */
    DWORD dwRc;
    LPMALLOC pMalloc;

    /*
     *  The file had better exist.  GetFileAttributes() will
     *  not only tell us, but it'll even call SetLastError()
     *  for us.
     */
    if (GetFileAttributes(ptszShort) == 0xFFFFFFFF) {
        return 0;
    }

    /*
     *  First convert from relative path to absolute path.
     *  This uses the scratch TCHAR buffer.
     */
    dwRc = GetFullPathName(ptszShort, MAX_PATH, tsz, NULL);
    if (dwRc == 0) {
        /*
         *  Failed; GFPN already did SetLastError().
         */
    } else if (dwRc >= MAX_PATH) {
        /*
         *  Resulting path would be too long.
         */
        SetLastError(ERROR_BUFFER_OVERFLOW);
        dwRc = 0;
    } else {
        /*
         *  Just right.
         */
        hr = SHGetDesktopFolder(&psfDesk);
        if (SUCCEEDED(hr)) {
            ULONG cwchEaten;

#ifdef UNICODE
#ifdef __cplusplus
            hr = psfDesk->ParseDisplayName(NULL, NULL, tsz,
                                       &cwchEaten, &pidl, NULL);
#else
            hr = psfDesk->lpVtbl->ParseDisplayName(psfDesk, NULL, NULL, tsz,
                                       &cwchEaten, &pidl, NULL);
#endif
#else
            WCHAR wsz[MAX_PATH];        /* Scratch WCHAR buffer */

            /*
             *  ParseDisplayName requires UNICODE, so we use
             *  the scratch WCHAR buffer during the conversion.
             */
            dwRc = MultiByteToWideChar(
                        AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                        0, tsz, -1, wsz, MAX_PATH);
            if (dwRc == 0) {
                /*
                 *  Couldn't convert to UNICODE.  MB2WC uses
                 *  ERROR_INSUFFICIENT_BUFFER, which we convert
                 *  to ERROR_BUFFER_OVERFLOW.  Any other error
                 *  we leave alone.
                 */
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    SetLastError(ERROR_BUFFER_OVERFLOW);
                }
                dwRc = 0;
            } else {
#ifdef __cplusplus
                hr = psfDesk->ParseDisplayName(NULL, NULL, wsz,
                                           &cwchEaten, &pidl, NULL);
#else
                hr = psfDesk->lpVtbl->ParseDisplayName(psfDesk, NULL, NULL,
                                           wsz, &cwchEaten, &pidl, NULL);
#endif
#endif

                if (FAILED(hr)) {
                    /*
                     *  Weird.  Convert the result back to a Win32
                     *  error code if we can.  Otherwise, use the
                     *  generic "duh" error code ERROR_INVALID_DATA.
                     */
                    if (HRESULT_FACILITY(hr) == FACILITY_WIN32) {
                        SetLastError(HRESULT_CODE(hr));
                    } else {
                        SetLastError(ERROR_INVALID_DATA);
                    }
                    dwRc = 0;
                } else {
                    /*
                     *  Convert the pidl back to a filename in the
                     *  TCHAR scratch buffer.
                     */
                    dwRc = SHGetPathFromIDList(pidl, tsz);
                    if (dwRc == 0 && tsz[0]) {
                        /*
                         *  Bizarre failure.
                         */
                        SetLastError(ERROR_INVALID_DATA);
                    } else {
                        /*
                         *  Copy the result back to the user's buffer.
                         */
                        dwRc = lstrlen(tsz);
                        if (dwRc + 1 > ctchBuf) {
                            /*
                             *  On buffer overflow, return necessary
                             *  size including terminating null (+1).
                             */
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            dwRc = dwRc + 1;
                        } else {
                            /*
                             *  On buffer okay, return actual size not
                             *  including terminating null.
                             */
                            lstrcpyn(ptszLong, tsz, ctchBuf);
                        }
                    }

                    /*
                     *  Free the pidl.
                     */
                    if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
#ifdef __cplusplus
                        pMalloc->Free(pidl);
                        pMalloc->Release();
#else
                        pMalloc->lpVtbl->Free(pMalloc, pidl);
                        pMalloc->lpVtbl->Release(pMalloc);
#endif
                    }
                }
#ifndef UNICODE
            }
#endif
            /*
             *  Release the desktop folder now that we no longer
             *  need it.
             */
#ifdef __cplusplus
            psfDesk->Release();
#else
            psfDesk->lpVtbl->Release(psfDesk);
#endif
        }
    }
    return dwRc;
}

/*
 * The stub that probes to decide which version to use.
 */
static DWORD WINAPI
Probe_GetLongPathName(LPCTSTR ptszShort, LPTSTR ptszLong, DWORD ctchBuf)
{
    HINSTANCE hinst;
    FARPROC fp;
    DWORD dwRc;
    BOOL (CALLBACK *RealGetLongPathName)(LPCTSTR, LPTSTR, DWORD);

    hinst = GetModuleHandle(TEXT("KERNEL32"));
#ifdef UNICODE
    fp = GetProcAddress(hinst, "GetLongPathNameW");
#else
    fp = GetProcAddress(hinst, "GetLongPathNameA");
#endif

    if (fp) {
        *(FARPROC *)&RealGetLongPathName = fp;
        dwRc = RealGetLongPathName(ptszShort, ptszLong, ctchBuf);
        if (dwRc || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED) {
            GetLongPathName = RealGetLongPathName;
        } else {
            GetLongPathName = Emulate_GetLongPathName;
            dwRc = GetLongPathName(ptszShort, ptszLong, ctchBuf);
        }
    } else {
        GetLongPathName = Emulate_GetLongPathName;
        dwRc = GetLongPathName(ptszShort, ptszLong, ctchBuf);
    }

    return dwRc;

}

DWORD (CALLBACK *GetLongPathName)(LPCTSTR, LPTSTR, DWORD) =
                Probe_GetLongPathName;

#endif /* COMPILE_NEWAPIS_STUBS */
#endif /* WANT_GETLONGPATHNAME_WRAPPER */

/*****************************************************************************
 *
 * GetFileAttributesEx
 *
 *****************************************************************************/

#ifdef WANT_GETFILEATTRIBUTESEX_WRAPPER

#undef GetFileAttributesEx
#define GetFileAttributesEx _GetFileAttributesEx

/*
 *  Really old header files don't even have definitions for these constants
 *  and structures.
 */
#if WINVER < 0x040A

typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;

typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

#endif

extern BOOL (CALLBACK *GetFileAttributesEx)
                (LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

/*
 * Exactly one file should define this symbol.
 */
#ifdef COMPILE_NEWAPIS_STUBS

/*
 * The version to use if we are forced to emulate.
 */
static BOOL WINAPI
Emulate_GetFileAttributesEx(LPCTSTR ptszFile, GET_FILEEX_INFO_LEVELS level,
                            LPVOID pv)
{
    BOOL fRc;

    if (level == GetFileExInfoStandard) {

        /*
         *  Must call GetFileAttributes first to avoid returning random
         *  values if the so-called filename contains wildcards.
         */
        if (GetFileAttributes(ptszFile) != 0xFFFFFFFF) {
            HANDLE hfind;
            WIN32_FIND_DATA wfd;
            hfind = FindFirstFile(ptszFile, &wfd);
            if (hfind != INVALID_HANDLE_VALUE) {
                LPWIN32_FILE_ATTRIBUTE_DATA pfad = pv;
                FindClose(hfind);

                pfad->dwFileAttributes = wfd.dwFileAttributes;
                pfad->ftCreationTime   = wfd.ftCreationTime;
                pfad->ftLastAccessTime = wfd.ftLastAccessTime;
                pfad->ftLastWriteTime  = wfd.ftLastWriteTime;
                pfad->nFileSizeHigh    = wfd.nFileSizeHigh;
                pfad->nFileSizeLow     = wfd.nFileSizeLow;

                fRc = TRUE;

            } else {
                /*
                 *  FindFirstFile already called SetLastError() for us.
                 */
                fRc = FALSE;
            }
        } else {
            /*
             *  GetFileAttributes already called SetLastError() for us.
             */
            fRc = FALSE;
        }
    } else {
        /*
         *  Unknown info level.
         */
        SetLastError(ERROR_INVALID_PARAMETER);
        fRc = FALSE;
    }

    return fRc;
}

/*
 * The stub that probes to decide which version to use.
 */
static BOOL WINAPI
Probe_GetFileAttributesEx(LPCTSTR ptszFile, GET_FILEEX_INFO_LEVELS level,
                          LPVOID pv)
{
    HINSTANCE hinst;
    FARPROC fp;
    BOOL fRc;
    BOOL (CALLBACK *RealGetFileAttributesEx)
             (LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

    hinst = GetModuleHandle(TEXT("KERNEL32"));
#ifdef UNICODE
    fp = GetProcAddress(hinst, "GetFileAttributesExW");
#else
    fp = GetProcAddress(hinst, "GetFileAttributesExA");
#endif

    if (fp) {
        *(FARPROC *)&RealGetFileAttributesEx = fp;
        fRc = RealGetFileAttributesEx(ptszFile, level, pv);
        if (fRc || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED) {
            GetFileAttributesEx = RealGetFileAttributesEx;
        } else {
            GetFileAttributesEx = Emulate_GetFileAttributesEx;
            fRc = GetFileAttributesEx(ptszFile, level, pv);
        }
    } else {
        GetFileAttributesEx = Emulate_GetFileAttributesEx;
        fRc = GetFileAttributesEx(ptszFile, level, pv);
    }

    return fRc;

}

BOOL (CALLBACK *GetFileAttributesEx)
                (LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID) =
        Probe_GetFileAttributesEx;

#endif /* COMPILE_NEWAPIS_STUBS */
#endif /* WANT_GETFILEATTRIBUTESEX_WRAPPER */

/*****************************************************************************
 *
 * IsDebuggerPresent
 *
 *****************************************************************************/

#ifdef WANT_ISDEBUGGERPRESENT_WRAPPER

#define IsDebuggerPresent _IsDebuggerPresent

extern BOOL (CALLBACK *IsDebuggerPresent)(VOID);

/*
 * Exactly one file should define this symbol.
 */
#ifdef COMPILE_NEWAPIS_STUBS

/*
 * The version to use if we are forced to emulate.
 */
static BOOL WINAPI
Emulate_IsDebuggerPresent(VOID)
{
    /* No way to tell, so just say "no". */
    return FALSE;
}

/*
 * The stub that probes to decide which version to use.
 */
static BOOL WINAPI
Probe_IsDebuggerPresent(VOID)
{
    HINSTANCE hinst;
    FARPROC fp;
    BOOL (CALLBACK *RealIsDebuggerPresent)(VOID);

    hinst = GetModuleHandle(TEXT("KERNEL32"));
    fp = GetProcAddress(hinst, "IsDebuggerPresent");

    if (fp) {
        *(FARPROC *)&IsDebuggerPresent = fp;
    } else {
        IsDebuggerPresent = Emulate_IsDebuggerPresent;
    }

    return IsDebuggerPresent();
}

BOOL (CALLBACK *IsDebuggerPresent)(VOID) =
        Probe_IsDebuggerPresent;

#endif /* COMPILE_NEWAPIS_STUBS */
#endif /* WANT_ISDEBUGGERPRESENT_WRAPPER */

#ifdef __cplusplus
}
#endif    /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmfinder.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1996-1999. All rights reserved.
//
//  MODULE: NMFinder.h
//
//  External Header for the NPP finder
//=============================================================================

#ifndef NMFINDER_H
#define NMFINDER_H

#include <NPPTypes.h>

#ifdef __cplusplus
extern "C"
{
#endif

// FINDER errors -- see also nmerr.h, blob.h
#define NMERR_NO_NPPS                       3016

#define NMERR_NO_MATCHING_NPPS              3017

#define NMERR_NO_NPP_SELECTED               3018

#define NMERR_NO_INPUT_BLOBS                3019

#define NMERR_NO_NPP_DLLS                   3020

#define NMERR_NO_VALID_NPP_DLLS             3021
//****************************************************************************
// Structures use by NPPs, the Finder, and monitors
//****************************************************************************

#pragma warning(disable:4200)
typedef struct
{
    DWORD         dwNumBlobs;
    HBLOB         hBlobs[0];
} BLOB_TABLE;
typedef BLOB_TABLE* PBLOB_TABLE;

typedef struct 
{
	DWORD size;
	BYTE* pBytes;
} MBLOB;

typedef struct
{
    DWORD         dwNumBlobs;
    MBLOB         mBlobs[0];
} MBLOB_TABLE;
typedef MBLOB_TABLE* PMBLOB_TABLE;

#pragma warning(default:4200)

//****************************************************************************
// Functions called by monitors, tools, netmon
//****************************************************************************
DWORD _cdecl GetNPPBlobTable(HBLOB          hFilterBlob,  
                      PBLOB_TABLE*   ppBlobTable);

DWORD _cdecl GetNPPBlobFromUI(HWND          hwnd,
                       HBLOB         hFilterBlob,
                       HBLOB*        phBlob);          

DWORD _cdecl GetNPPBlobFromUIExU(HWND          hwnd,
                          HBLOB         hFilterBlob,
                          HBLOB*        phBlob,
                          char*         szHelpFileName);          

DWORD _cdecl SelectNPPBlobFromTable( HWND   hwnd,
                              PBLOB_TABLE    pBlobTable,
                              HBLOB*         hBlob);

DWORD _cdecl SelectNPPBlobFromTableExU( HWND   hwnd,
                                 PBLOB_TABLE    pBlobTable,
                                 HBLOB*         hBlob,
                                 char*          szHelpFileName);


//****************************************************************************
// Helper functions provided by the Finder
//****************************************************************************
__inline DWORD BLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(BLOB_TABLE)+dwNumBlobs*sizeof(HBLOB));
}

__inline PBLOB_TABLE  AllocBlobTable(DWORD dwNumBlobs)
{
    DWORD size = BLOB_TABLE_SIZE(dwNumBlobs);

    return (PBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

__inline DWORD MBLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(MBLOB_TABLE)+dwNumBlobs*sizeof(MBLOB));
}

__inline PMBLOB_TABLE  AllocMBlobTable(DWORD dwNumBlobs)
{
    DWORD size = MBLOB_TABLE_SIZE(dwNumBlobs);

    return (PMBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

//****************************************************************************
// Functions provided by NPPs, called by the Finder
//****************************************************************************

// For NPP's that can return a Blob table without additional configuration.
DWORD _cdecl GetNPPBlobs(PBLOB_TABLE*       ppBlobTable);

typedef DWORD (_cdecl FAR* BLOBSPROC) (PBLOB_TABLE*       ppBlobTable);

// For NPP's that need additional information to return a Blob table.
DWORD _cdecl GetConfigBlob(HBLOB*      phBlob);

typedef DWORD (_cdecl FAR* GETCFGBLOB) (HBLOB, HBLOB*);
typedef DWORD (_cdecl FAR* CFGPROC) (HWND               hwnd,
                              HBLOB              SpecialBlob,
                              PBLOB_TABLE*       ppBlobTable);

//****************************************************************************
// Handy functions
BOOL  _cdecl FilterNPPBlob(HBLOB hBlob, HBLOB FilterBlob);

BOOL  _cdecl RaiseNMEvent(HINSTANCE    hInstance,
                   WORD         EventType, 
                   DWORD        EventID,
                   WORD         nStrings, 
                   const char** aInsertStrs,
                   LPVOID       lpvData,
                   DWORD        dwDataSize);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmapptyp.h ===
//****************************************************************************
//  Module:     SDK
//  File:       NMAPPTYP.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1999
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#if ! defined(_NM_APPLET_TYPE_H_) && ! defined(__iapplet_h__)
#define _NM_APPLET_TYPE_H_

//
// GCC/MCS Base Types
//

typedef USHORT          AppletSessionID;
typedef USHORT          AppletChannelID;
typedef AppletChannelID AppletUserID;
typedef AppletUserID    AppletNodeID;
typedef USHORT          AppletTokenID;
typedef USHORT          AppletEntityID;

typedef ULONG           AppletConfID;

typedef UINT            AppletRequestTag;


//
// GCC Registry
//

typedef enum tagAppletRegistryCommand
{
    APPLET_REGISTER_CHANNEL  = 0,
    APPLET_ASSIGN_TOKEN      = 1,
    APPLET_SET_PARAMETER     = 2,
    APPLET_RETRIEVE_ENTRY    = 3,
    APPLET_DELETE_ENTRY      = 4,
    APPLET_ALLOCATE_HANDLE   = 5,
    APPLET_MONITOR           = 6, // nyi in SDK
}
    AppletRegistryCommand;


typedef enum tagAppletRegistryItemType
{
    APPLET_REGISTRY_CHANNEL_ID  = 1,
    APPLET_REGISTRY_TOKEN_ID    = 2,
    APPLET_REGISTRY_PARAMETER   = 3,
    APPLET_REGISTRY_NONE        = 4,
}
    AppletRegistryItemType;


typedef enum tagAppletModificationRights
{
    APPLET_OWNER_RIGHTS                     = 0,
    APPLET_SESSION_RIGHTS                   = 1,
    APPLET_PUBLIC_RIGHTS                    = 2,
    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED = 3,
}
    AppletModificationRights;


//
// MCS Channel
//

typedef enum tagAppletChannelCommand
{
    APPLET_JOIN_CHANNEL         = 0,
    APPLET_LEAVE_CHANNEL        = 1,
    APPLET_CONVENE_CHANNEL      = 2,
    APPLET_DISBAND_CHANNEL      = 3,
    APPLET_ADMIT_CHANNEL        = 4,
    APPLET_EXPEL_CHANNEL        = 5,	// indication only
}
    AppletChannelCommand;


typedef enum tagAppletChannelType
{
    APPLET_STATIC_CHANNEL               = 0,
    APPLET_DYNAMIC_MULTICAST_CHANNEL    = 1,
    APPLET_DYNAMIC_PRIVATE_CHANNEL      = 2,
    APPLET_DYNAMIC_USER_ID_CHANNEL      = 3,
    APPLET_NO_CHANNEL_TYPE_SPECIFIED    = 4
}
    AppletChannelType;


//
// MCS Token
//

typedef enum tagAppletTokenCommand
{
    APPLET_GRAB_TOKEN          = 0,
    APPLET_INHIBIT_TOKEN       = 1,
    APPLET_GIVE_TOKEN          = 2,
    APPLET_PLEASE_TOKEN        = 3,
    APPLET_RELEASE_TOKEN       = 4,
    APPLET_TEST_TOKEN          = 5,
    APPLET_GIVE_TOKEN_RESPONSE = 6,
}
    AppletTokenCommand;


typedef enum tagAppletTokenStatus
{
    APPLET_TOKEN_NOT_IN_USE         = 0,
    APPLET_TOKEN_SELF_GRABBED       = 1,
    APPLET_TOKEN_OTHER_GRABBED      = 2,
    APPLET_TOKEN_SELF_INHIBITED     = 3,
    APPLET_TOKEN_OTHER_INHIBITED    = 4,
    APPLET_TOKEN_SELF_RECIPIENT     = 5,
    APPLET_TOKEN_SELF_GIVING        = 6,
    APPLET_TOKEN_OTHER_GIVING       = 7,
}
    AppletTokenStatus;


//
// GCC Capability
//

typedef enum tagAppletCapabilityType
{
    APPLET_UNKNOWN_CAP_TYPE             = 0, // for non-collapsing caps
    APPLET_LOGICAL_CAPABILITY           = 1,
    APPLET_UNSIGNED_MINIMUM_CAPABILITY  = 2,
    APPLET_UNSIGNED_MAXIMUM_CAPABILITY  = 3,
}
    AppletCapabilityType;


typedef struct tagAppletCapabilityClass
{
    AppletCapabilityType    eType;
    ULONG                   nMinOrMax;
}
    AppletCapabilityClass;


typedef enum tagAppletCapIDType
{
	APPLET_STANDARD_CAPABILITY  = 0,
	APPLET_NONSTD_CAPABILITY	= 1,
}
    AppletCapIDType;


//
// GCC/MCS Resource Allocation Command
//

typedef enum tagAppletResourceAllocCommand
{
    APPLET_JOIN_DYNAMIC_CHANNEL     = 0, // compete among all members
    APPLET_GRAB_TOKEN_REQUEST		= 1, // nyi in SDK
}
    AppletResourceAllocCommand;

//
// Send Data
//

typedef enum tagAppletPriority
{
    APPLET_TOP_PRIORITY     = 0,
    APPLET_HIGH_PRIORITY    = 1,
    APPLET_MEDIUM_PRIORITY  = 2,
    APPLET_LOW_PRIORITY     = 3,
}
    AppletPriority;


//
// Key Type
//

typedef enum tagAppletKeyType
{
	APPLET_OBJECT_KEY		= 1,
	APPLET_H221_NONSTD_KEY	= 2,
}
	AppletKeyType;


//
// Error Code
//

enum tagAppletErrorCode
{
    APPLET_E_NO_SERVICE       		= 0x82000001,
    APPLET_E_SERVICE_FAIL      		= 0x82000002,
    APPLET_E_ALREADY_REGISTERED  	= 0x82000003,
    APPLET_E_NOT_REGISTERED      	= 0x82000004,
    APPLET_E_INVALID_CONFERENCE  	= 0x82000005,
    APPLET_E_INVALID_COOKIE      	= 0x82000006,
    APPLET_E_ALREADY_JOIN        	= 0x82000007,
    APPLET_E_NOT_JOINED          	= 0x82000008,
    APPLET_E_INVALID_JOIN_REQUEST	= 0x82000009,
    APPLET_E_ENTRY_ALREADY_EXISTS   = 0x8200000a,
    APPLET_E_ENTRY_DOES_NOT_EXIST   = 0x8200000b,
    APPLET_E_NOT_OWNER              = 0x8200000c,
    APPLET_E_NOT_ADVISED            = 0x8200000d,
    APPLET_E_ALREADY_ADVISED        = 0x8200000e,
};


//
// Reason Code
//

typedef enum tagAppletReason
{
    APPLET_R_UNSPECIFIED            = 0,
    APPLET_R_CONFERENCE_GONE        = 1,
    APPLET_R_USER_REJECTED          = 2,
    APPLET_R_RESOURCE_PURGED        = 3,
}
    AppletReason;


#endif // _NM_APPLET_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmappstr.h ===
//****************************************************************************
//  Module:     SDK
//  File:       NMAPPSTR.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1999
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _NM_APPLET_STRINGS_H_
#define _NM_APPLET_STRINGS_H_

//
// This is used to register applets such that the NetMeeting process knows
// how to launch the applet process.
//

//
// Registry folder for applets.
//

#define NM_APPLET_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\T.120 Applets")

//
// Registry sub-folders for applets with standard keys.
//

#define NM_STD_KEY_TYPE     TEXT("Object Key")

//
// Registry sub-folders for applets with non-standard keys.
//

#define NM_NONSTD_KEY_TYPE  TEXT("NonStd Key")

//
// Registry keys for applets
//

#define NM_REGVAL_APP_PATH      TEXT("Path")            // required
#define NM_REGVAL_CMD_LINE      TEXT("CmdLine")         // optional
#define NM_REGVAL_CURR_DIR      TEXT("Directory")       // optional
#define NM_REGVAL_MANUFACTURER  TEXT("Manufacturer")    // optional
#define NM_REGVAL_PRODUCT_NAME  TEXT("ProductName")     // optional
#define NM_REGVAL_DESCRIPTION   TEXT("Description")     // optional

//
// Environment variables for invoke information
//

#define NM_ENV_NODE_ID          TEXT("_node_id")    // conference ID
#define NM_ENV_CONF_ID          TEXT("_conf_id")    // initiator's node ID


#endif // _NM_APPLET_STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmblob.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1996-1999. All rights reserved.
//
//  MODULE: nmblob.h
//
//  External Header for the blob helpers
//=============================================================================

#ifndef _NMBLOB_H_
#define _NMBLOB_H_

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif


/////////////////////////////////////////////////////////////////////////////
// Blob Definitions - (they are all in npptypes.idl)
/////////////////////////////////////////////////////////////////////////////
#include "npptypes.h"

#ifdef __cplusplus
extern "C"
{
#endif

/////////////////////////////////////////////////////////////////////////////
// Blob Constants
/////////////////////////////////////////////////////////////////////////////
#define INITIAL_RESTART_KEY 0xFFFFFFFF

/////////////////////////////////////////////////////////////////////////////
// Blob Core Helper Routines - these mess with internals (BlobCore.c)
/////////////////////////////////////////////////////////////////////////////
DWORD _cdecl CreateBlob(HBLOB * phBlob);

DWORD _cdecl DestroyBlob(HBLOB hBlob);

DWORD _cdecl SetStringInBlob(HBLOB  hBlob,         
                      const char * pOwnerName,    
                      const char * pCategoryName, 
                      const char * pTagName,      
                      const char * pString);      

DWORD _cdecl GetStringFromBlob(HBLOB   hBlob,
                        const char *  pOwnerName,
                        const char *  pCategoryName,
                        const char *  pTagName,
                        const char ** ppString);

DWORD _cdecl GetStringsFromBlob(HBLOB   hBlob,
                         const char * pRequestedOwnerName,
                         const char * pRequestedCategoryName,
                         const char * pRequestedTagName,
                         const char ** ppReturnedOwnerName,
                         const char ** ppReturnedCategoryName,
                         const char ** ppReturnedTagName,
                         const char ** ppReturnedString,
                         DWORD *       pRestartKey);

DWORD _cdecl RemoveFromBlob(HBLOB   hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName);

DWORD _cdecl LockBlob(HBLOB hBlob);

DWORD _cdecl UnlockBlob(HBLOB hBlob);

DWORD _cdecl FindUnknownBlobCategories( HBLOB hBlob,
                                 const char *  pOwnerName,
                                 const char *  pKnownCategoriesTable[],
                                 HBLOB hUnknownCategoriesBlob);

/////////////////////////////////////////////////////////////////////////////
// Blob Helper Routines - these just call core helpers (BlobHelp.c)
/////////////////////////////////////////////////////////////////////////////
DWORD _cdecl MergeBlob(HBLOB hDstBlob,
                HBLOB hSrcBlob); 

DWORD _cdecl DuplicateBlob (HBLOB hSrcBlob,
					 HBLOB *hBlobThatWillBeCreated ); 

DWORD _cdecl WriteBlobToFile(HBLOB  hBlob,
                      const char * pFileName);

DWORD _cdecl ReadBlobFromFile(HBLOB* phBlob,
                       const char * pFileName);

DWORD _cdecl RegCreateBlobKey(HKEY hkey, const char* szBlobName, HBLOB hBlob);

DWORD _cdecl RegOpenBlobKey(HKEY hkey, const char* szBlobName, HBLOB* phBlob);

DWORD _cdecl MarshalBlob(HBLOB hBlob, DWORD* pSize, BYTE** ppBytes);

DWORD _cdecl UnMarshalBlob(HBLOB* phBlob, DWORD Size, BYTE* pBytes);

DWORD _cdecl SetDwordInBlob(HBLOB hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName,
                     DWORD         Dword);

DWORD _cdecl GetDwordFromBlob(HBLOB   hBlob,
                       const char *  pOwnerName,
                       const char *  pCategoryName,
                       const char *  pTagName,
                       DWORD      *  pDword);

DWORD _cdecl SetBoolInBlob(HBLOB   hBlob,
                    const char *  pOwnerName,
                    const char *  pCategoryName,
                    const char *  pTagName,
                    BOOL          Bool);

DWORD _cdecl GetBoolFromBlob(HBLOB   hBlob,
                      const char *  pOwnerName,
                      const char *  pCategoryName,
                      const char *  pTagName,
                      BOOL       *  pBool);

DWORD _cdecl GetMacAddressFromBlob(HBLOB   hBlob,
                            const char *  pOwnerName,
                            const char *  pCategoryName,
                            const char *  pTagName,
                            BYTE *  pMacAddress);

DWORD _cdecl SetMacAddressInBlob(HBLOB   hBlob,
                          const char *  pOwnerName,
                          const char *  pCategoryName,
                          const char *  pTagName,
                          const BYTE *  pMacAddress);

DWORD _cdecl FindUnknownBlobTags( HBLOB hBlob,
                           const char *  pOwnerName,
                           const char *  pCategoryName,
                           const char *  pKnownTagsTable[],
                           HBLOB hUnknownTagsBlob);

/////////////////////////////////////////////////////////////////////////////
// Blob NPP Helper Routines - these are specific to the NPP interfaces (BlobNPP.c)
/////////////////////////////////////////////////////////////////////////////
DWORD _cdecl SetNetworkInfoInBlob(HBLOB hBlob, 
                           LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl GetNetworkInfoFromBlob(HBLOB hBlob, 
                             LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl CreateNPPInterface ( HBLOB hBlob,
                           REFIID iid,
                           void ** ppvObject);

DWORD _cdecl SetClassIDInBlob(HBLOB hBlob,
                       const char* pOwnerName,
                       const char* pCategoryName,
                       const char* pTagName,
                       const CLSID*  pClsID);

DWORD _cdecl GetClassIDFromBlob(HBLOB hBlob,
                         const char* pOwnerName,
                         const char* pCategoryName,
                         const char* pTagName,
                         CLSID * pClsID);

DWORD _cdecl SetNPPPatternFilterInBlob( HBLOB hBlob,
                                 LPEXPRESSION pExpression,
                                 HBLOB hErrorBlob);

DWORD _cdecl GetNPPPatternFilterFromBlob( HBLOB hBlob,
                                   LPEXPRESSION pExpression,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPAddressFilterInBlob( HBLOB hBlob,
                                 LPADDRESSTABLE pAddressTable);

DWORD _cdecl GetNPPAddressFilterFromBlob( HBLOB hBlob,
                                   LPADDRESSTABLE pAddressTable,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPTriggerInBlob( HBLOB hBlob,
                           LPTRIGGER   pTrigger,
                           HBLOB hErrorBlob);

DWORD _cdecl GetNPPTriggerFromBlob( HBLOB hBlob,
                             LPTRIGGER   pTrigger,
                             HBLOB hErrorBlob);

DWORD _cdecl SetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   nSaps,
                           WORD   nEtypes,
                           LPBYTE lpSapTable,
                           LPWORD lpEtypeTable,
                           DWORD  FilterFlags,
                           HBLOB  hErrorBlob);

DWORD _cdecl GetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   *pnSaps,
                           WORD   *pnEtypes,
                           LPBYTE *ppSapTable,
                           LPWORD *ppEtypeTable,
                           DWORD  *pFilterFlags,
                           HBLOB  hErrorBlob);

// GetNPPMacTypeAsNumber maps the tag NPP:NetworkInfo:MacType to the MAC_TYPE_*
// defined in the NPPTYPES.h.  If the tag is unavailable, the API returns MAC_TYPE_UNKNOWN.
DWORD _cdecl GetNPPMacTypeAsNumber(HBLOB hBlob, 
                            LPDWORD lpMacType);

// See if a remote catagory exists... and make sure that the remote computername
// isn't the same as the local computername.
BOOL  _cdecl IsRemoteNPP ( HBLOB hBLOB);

/////////////////////////////////////////////////////////////////////////////
// Blob Errors
/////////////////////////////////////////////////////////////////////////////

// basic blob errors
#define NMERR_BLOB_NOT_INITIALIZED          1000

#define NMERR_INVALID_BLOB                  1001

#define NMERR_UPLEVEL_BLOB                  1002

#define NMERR_BLOB_ENTRY_ALREADY_EXISTS     1003

#define NMERR_BLOB_ENTRY_DOES_NOT_EXIST     1004

#define NMERR_AMBIGUOUS_SPECIFIER           1005

#define NMERR_BLOB_OWNER_NOT_FOUND          1006

#define NMERR_BLOB_CATEGORY_NOT_FOUND       1007

#define NMERR_UNKNOWN_CATEGORY              1008

#define NMERR_UNKNOWN_TAG                   1009

#define NMERR_BLOB_CONVERSION_ERROR         1010

#define NMERR_ILLEGAL_TRIGGER               1011

#define NMERR_BLOB_STRING_INVALID           1012

// FINDER errors -- see also nmerr.h, finder.h
#define NMERR_UNABLE_TO_LOAD_LIBRARY        1013

#define NMERR_UNABLE_TO_GET_PROCADDR        1014

#define NMERR_CLASS_NOT_REGISTERED          1015

#define NMERR_INVALID_REMOTE_COMPUTERNAME   1016

#define NMERR_RPC_REMOTE_FAILURE            1017

//////////////////////////////////////////////////////////////////////////////
// npp tag definitions
//////////////////////////////////////////////////////////////////////////////
#define OWNER_NPP               "NPP"

#define CATEGORY_NETWORKINFO        "NetworkInfo"
#define TAG_RAS                         "Dial-up Connection"
#define TAG_MACTYPE						"MacType"
#define TAG_CURRENTADDRESS              "CurrentAddress"
#define TAG_LINKSPEED                   "LinkSpeed"
#define TAG_MAXFRAMESIZE                "MaxFrameSize"
#define TAG_FLAGS                       "Flags"
#define TAG_TIMESTAMPSCALEFACTOR        "TimeStampScaleFactor"
#define TAG_COMMENT                     "Comment"
#define TAG_NODENAME                    "NodeName"
#define TAG_NAME                        "Name"
#define TAG_FAKENPP                     "Fake"
#define TAG_PROMISCUOUS_MODE            "PMode"

#define CATEGORY_LOCATION           "Location"
#define TAG_MACADDRESS                  "MacAddress"
#define TAG_CLASSID                     "ClassID"
#define TAG_NAME                        "Name"

#define CATEGORY_CONFIG             "Config"
#define TAG_FRAME_SIZE                  "FrameSize"
#define TAG_UPDATE_FREQUENCY            "UpdateFreq"
#define TAG_BUFFER_SIZE                 "BufferSize"
#define TAG_DRIVE_LETTER                "DriveLetter"
#define TAG_PATTERN_DESIGNATOR          "PatternMatch"
#define TAG_PATTERN                     "Pattern"
#define TAG_ADDRESS_PAIR                "AddressPair"
#define TAG_CONNECTIONFLAGS             "ConnectionFlags"
#define TAG_ETYPES                      "Etypes"
#define TAG_SAPS                        "Saps"
#define TAG_NO_CONVERSATION_STATS       "NoConversationStats"
#define TAG_NO_STATS_FRAME              "NoStatsFrame"
#define TAG_DONT_DELETE_EMPTY_CAPTURE   "DontDeleteEmptyCapture"
#define TAG_WANT_PROTOCOL_INFO          "WantProtocolInfo"
#define TAG_INTERFACE_DELAYED_CAPTURE   "IDdC"
#define TAG_INTERFACE_REALTIME_CAPTURE  "IRTC"
#define TAG_INTERFACE_STATS             "ISts"
#define TAG_INTERFACE_EXPERT_STATS      "IESP"
#define TAG_LOCAL_ONLY                  "LocalOnly"
// Is_Remote is set to TRUE by NPPs that go remote.  Note that when you
//  are looking for a remote NPP, you probably also need to ask for 
//  blobs that have the TAG_GET_SPECIAL_BLOBS bool set
#define TAG_IS_REMOTE                   "IsRemote"


#define CATEGORY_TRIGGER            "Trigger"
#define TAG_TRIGGER                     "Trigger"

#define CATEGORY_FINDER             "Finder"
#define TAG_ROOT                        "Root"
#define TAG_PROCNAME                    "ProcName"
#define TAG_DISP_STRING                 "Display"
#define TAG_DLL_FILENAME                "DLLName"
#define TAG_GET_SPECIAL_BLOBS           "Specials"

#define CATEGORY_REMOTE              "Remote"
#define TAG_REMOTECOMPUTER              "RemoteComputer"
#define TAG_REMOTECLASSID               "ClassID"

#define CATEGORY_ESP                "ESP"
#define TAG_ESP_GENERAL_ACTIVE          "ESPGeneralActive"
#define TAG_ESP_PROTOCOL_ACTIVE         "ESPProtocolActive"
#define TAG_ESP_MAC_ACTIVE              "ESPMacActive"
#define TAG_ESP_MAC2MAC_ACTIVE          "ESPMac2MacActive"
#define TAG_ESP_IP_ACTIVE               "ESPIpActive"
#define TAG_ESP_IP2IP_ACTIVE            "ESPIp2IpActive"
#define TAG_ESP_IP_APP_ACTIVE           "ESPIpAppActive"
#define TAG_ESP_IPX_ACTIVE              "ESPIpxActive"
#define TAG_ESP_IPX2IPX_ACTIVE          "ESPIpx2IpxActive"
#define TAG_ESP_IPX_APP_ACTIVE          "ESPIpxAppActive"
#define TAG_ESP_DEC_ACTIVE              "ESPDecActive"
#define TAG_ESP_DEC2DEC_ACTIVE          "ESPDec2DecActive"
#define TAG_ESP_DEC_APP_ACTIVE          "ESPDecAppActive"
#define TAG_ESP_APPLE_ACTIVE            "ESPAppleActive"
#define TAG_ESP_APPLE2APPLE_ACTIVE      "ESPApple2AppleActive"
#define TAG_ESP_APPLE_APP_ACTIVE        "ESPAppleAppActive"

#define TAG_ESP_UTIL_SIZE               "ESPUtilSize"
#define TAG_ESP_TIME_SIZE               "ESPTimeSize"
#define TAG_ESP_BPS_SIZE				"ESPBpsSize"
#define TAG_ESP_BPS_THRESH				"ESPBpsThresh"
#define TAG_ESP_FPS_THRESH				"ESPFpsThresh"

#define TAG_ESP_MAC                     "ESPMac"
#define TAG_ESP_IPX                     "ESPIpx"
#define TAG_ESP_IPXSPX                  "ESPIpxSpx"
#define TAG_ESP_NCP                     "ESPNcp"
#define TAG_ESP_IP                      "ESPIp"
#define TAG_ESP_UDP                     "ESPUdp"
#define TAG_ESP_TCP                     "ESPTcp"
#define TAG_ESP_ICMP                    "ESPIcmp"
#define TAG_ESP_ARP                     "ESPArp"
#define TAG_ESP_RARP                    "ESPRarp"
#define TAG_ESP_APPLE                   "ESPApple"
#define TAG_ESP_AARP                    "ESPAarp"
#define TAG_ESP_DEC                     "ESPDec"
#define TAG_ESP_NETBIOS                 "ESPNetbios"
#define TAG_ESP_SNA                     "ESPSna"
#define TAG_ESP_BPDU                    "ESPBpdu"
#define TAG_ESP_LLC                     "ESPLlc"
#define TAG_ESP_RPL                     "ESPRpl"
#define TAG_ESP_BANYAN                  "ESPBanyan"
#define TAG_ESP_LANMAN                  "ESPLanMan"
#define TAG_ESP_SNMP                    "ESPSnmp"
#define TAG_ESP_X25                     "ESPX25"
#define TAG_ESP_XNS                     "ESPXns"
#define TAG_ESP_ISO                     "ESPIso"
#define TAG_ESP_UNKNOWN                 "ESPUnknown"
#define TAG_ESP_ATP                     "ESPAtp"
#define TAG_ESP_ADSP                    "ESPAdsp"

//////////////////////////////////////////////////////////////////////////////
// npp value definitions
//////////////////////////////////////////////////////////////////////////////
// Mac types
#define PROTOCOL_STRING_ETHERNET_TXT   "ETHERNET"
#define PROTOCOL_STRING_TOKENRING_TXT  "TOKENRING"
#define PROTOCOL_STRING_FDDI_TXT       "FDDI"
#define PROTOCOL_STRING_ATM_TXT        "ATM"

// lower protocols
#define PROTOCOL_STRING_IP_TXT         "IP"
#define PROTOCOL_STRING_IPX_TXT        "IPX"
#define PROTOCOL_STRING_XNS_TXT        "XNS"
#define PROTOCOL_STRING_VINES_IP_TXT   "VINES IP"

// upper protocols
#define PROTOCOL_STRING_ICMP_TXT       "ICMP"
#define PROTOCOL_STRING_TCP_TXT        "TCP"
#define PROTOCOL_STRING_UDP_TXT        "UDP"
#define PROTOCOL_STRING_SPX_TXT        "SPX"
#define PROTOCOL_STRING_NCP_TXT        "NCP"

// pseudo protocols
#define PROTOCOL_STRING_ANY_TXT        "ANY"
#define PROTOCOL_STRING_ANY_GROUP_TXT  "ANY GROUP"
#define PROTOCOL_STRING_HIGHEST_TXT    "HIGHEST"
#define PROTOCOL_STRING_LOCAL_ONLY_TXT "LOCAL ONLY"
#define PROTOCOL_STRING_UNKNOWN_TXT    "UNKNOWN"
#define PROTOCOL_STRING_DATA_TXT       "DATA"
#define PROTOCOL_STRING_FRAME_TXT      "FRAME"
#define PROTOCOL_STRING_NONE_TXT       "NONE"
#define PROTOCOL_STRING_EFFECTIVE_TXT  "EFFECTIVE"


#define ADDRESS_PAIR_INCLUDE_TXT    "INCLUDE"
#define ADDRESS_PAIR_EXCLUDE_TXT    "EXCLUDE"

#define INCLUDE_ALL_EXCEPT_TXT      "INCLUDE ALL EXCEPT"
#define EXCLUDE_ALL_EXCEPT_TXT      "EXCLUDE ALL EXCEPT"

#define PATTERN_MATCH_OR_TXT        "OR("
#define PATTERN_MATCH_AND_TXT       "AND("

#define TRIGGER_PATTERN_TXT               "PATTERN MATCH"
#define TRIGGER_BUFFER_TXT                "BUFFER CONTENT"

#define TRIGGER_NOTIFY_TXT      "NOTIFY"
#define TRIGGER_STOP_TXT        "STOP"
#define TRIGGER_PAUSE_TXT       "PAUSE"

#define TRIGGER_25_PERCENT_TXT  "25 PERCENT"
#define TRIGGER_50_PERCENT_TXT  "50 PERCENT"
#define TRIGGER_75_PERCENT_TXT  "75 PERCENT"
#define TRIGGER_100_PERCENT_TXT "100 PERCENT"

#define PATTERN_MATCH_NOT_TXT   "NOT"


#ifdef __cplusplus
}
#endif

#endif // _BLOBHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmipxstructs.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1992-1999. All rights reserved.
//
//  MODULE: nmipxstructs.h
//
//  IPX structures & #defines
//=============================================================================

#ifndef NMIPXSTRUCTS_H
#define NMIPXSTRUCTS_H

#ifdef __cplusplus
extern "C"
{
#endif

//  IPX
typedef struct {
   UCHAR ha_address[6];
} HOST_ADDRESS;

typedef struct {
   ULONG  netnumber;
   HOST_ADDRESS hostaddr;
   USHORT socket;
} NET_ADDRESS;
typedef NET_ADDRESS UNALIGNED * ULPNETADDRESS;

typedef struct {
   USHORT ipx_checksum;
   USHORT ipx_length;
   UCHAR  ipx_xport_control;
   UCHAR  ipx_packet_type;
   NET_ADDRESS idp_dest;
   NET_ADDRESS idp_source;
} IPX_HDR;
typedef IPX_HDR UNALIGNED * ULPIPX_HDR;

//  SPX
typedef struct _SPX_HDR {       // Sequenced Packet Protocol
    IPX_HDR spx_idp_hdr;
    UCHAR   spx_conn_ctrl;      // bits 0-3 defined (SPX_CTRL_xxx)
    UCHAR   spx_data_type;      // 0 (defined to be used by higher layers)
    USHORT  spx_src_conn_id;    // b.e.
    USHORT  spx_dest_conn_id;   // b.e.
    USHORT  spx_sequence_num;   // sequence number (b.e.).
    USHORT  spx_ack_num;        // acknowledge number (b.e.)
    USHORT  spx_alloc_num;      // allocation (b.e.)
} SPX_HDR;
typedef SPX_HDR UNALIGNED *PSPX_HDR;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmerr.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-1999. All rights reserved.
//
//  MODULE: NMErr.h
//
//  This is the top-level include file for all NETWORK MONITOR error codes
//=============================================================================

#ifndef _NMERR_
#define _NMERR_

#ifndef HRESULT
typedef LONG HRESULT;       // From wtypes.h
#endif

#ifndef INLINE
#define INLINE __inline
#endif

#include <winerror.h>       // For HRESULT macros

//=============================================================================
//  The operation succeeded.
//=============================================================================

#define NMERR_SUCCESS                        0

//=============================================================================
//  An error occured creating a memory-mapped file.
//=============================================================================

#define NMERR_MEMORY_MAPPED_FILE_ERROR       1

//=============================================================================
//  The handle to a filter is invalid.
//=============================================================================

#define NMERR_INVALID_HFILTER                2

//=============================================================================
//  Capturing has already been started.
//=============================================================================

#define NMERR_CAPTURING                      3

//=============================================================================
//  Capturing has not been started.
//=============================================================================

#define NMERR_NOT_CAPTURING                  4

//=============================================================================
//  The are no frames available.
//=============================================================================

#define NMERR_NO_MORE_FRAMES                 5

//=============================================================================
//  The buffer is too small to complete the operation.
//=============================================================================

#define NMERR_BUFFER_TOO_SMALL               6

//=============================================================================
//  No protocol was able to recognize the frame.
//=============================================================================

#define NMERR_FRAME_NOT_RECOGNIZED           7

//=============================================================================
//  The file already exists.
//=============================================================================

#define NMERR_FILE_ALREADY_EXISTS            8

//=============================================================================
//  A needed device driver was not found or is not loaded.
//=============================================================================

#define NMERR_DRIVER_NOT_FOUND               9

//=============================================================================
//  This address aready exists in the database.
//=============================================================================

#define NMERR_ADDRESS_ALREADY_EXISTS         10

//=============================================================================
//  The frame handle is invalid.
//=============================================================================

#define NMERR_INVALID_HFRAME                 11

//=============================================================================
//  The protocol handle is invalid.
//=============================================================================

#define NMERR_INVALID_HPROTOCOL              12

//=============================================================================
//  The property handle is invalid.
//=============================================================================

#define NMERR_INVALID_HPROPERTY              13

//=============================================================================
//  The the object has been locked.  
//=============================================================================

#define NMERR_LOCKED                         14

//=============================================================================
//  A pop operation was attempted on an empty stack.
//=============================================================================

#define NMERR_STACK_EMPTY                    15

//=============================================================================
//  A push operation was attempted on an full stack.
//=============================================================================

#define NMERR_STACK_OVERFLOW                 16

//=============================================================================
//  There are too many protocols active.
//=============================================================================

#define NMERR_TOO_MANY_PROTOCOLS             17

//=============================================================================
//  The file was not found.
//=============================================================================

#define NMERR_FILE_NOT_FOUND                 18

//=============================================================================
//  No memory was available.  Shut down windows to free up resources.
//=============================================================================

#define NMERR_OUT_OF_MEMORY                  19

//=============================================================================
//  The capture is already in the paused state.
//=============================================================================

#define NMERR_CAPTURE_PAUSED                 20

//=============================================================================
//  There are no buffers available or present.
//=============================================================================

#define NMERR_NO_BUFFERS                     21

//=============================================================================
//  There are already buffers present.
//=============================================================================

#define NMERR_BUFFERS_ALREADY_EXIST          22

//=============================================================================
//  The object is not locked.
//=============================================================================

#define NMERR_NOT_LOCKED                     23

//=============================================================================
//  A integer type was out of range.
//=============================================================================

#define NMERR_OUT_OF_RANGE                   24

//=============================================================================
//  An object was locked too many times.
//=============================================================================

#define NMERR_LOCK_NESTING_TOO_DEEP          25

//=============================================================================
//  A parser failed to load.
//=============================================================================

#define NMERR_LOAD_PARSER_FAILED             26

//=============================================================================
//  A parser failed to unload.
//=============================================================================

#define NMERR_UNLOAD_PARSER_FAILED          27

//=============================================================================
//  The address database handle is invalid.
//=============================================================================

#define NMERR_INVALID_HADDRESSDB             28

//=============================================================================
//  The MAC address was not found in the database.
//=============================================================================

#define NMERR_ADDRESS_NOT_FOUND              29

//=============================================================================
//  The network software was not found in the system.
//=============================================================================

#define NMERR_NETWORK_NOT_PRESENT            30

//=============================================================================
//  There is no property database for a protocol.
//=============================================================================

#define NMERR_NO_PROPERTY_DATABASE           31

//=============================================================================
//  A property was not found in the database.
//=============================================================================

#define NMERR_PROPERTY_NOT_FOUND             32

//=============================================================================
//  The property database handle is in valid.
//=============================================================================

#define NMERR_INVALID_HPROPERTYDB            33

//=============================================================================
//  The protocol has not been enabled.
//=============================================================================

#define NMERR_PROTOCOL_NOT_ENABLED          34

//=============================================================================
//  The protocol DLL could not be found.
//=============================================================================

#define NMERR_PROTOCOL_NOT_FOUND            35

//=============================================================================
//  The parser DLL is not valid.
//=============================================================================

#define NMERR_INVALID_PARSER_DLL            36

//=============================================================================
//  There are no properties attached.
//=============================================================================

#define NMERR_NO_ATTACHED_PROPERTIES         37

//=============================================================================
//  There are no frames in the buffer.
//=============================================================================

#define NMERR_NO_FRAMES                      38

//=============================================================================
//  The capture file format is not valid.
//=============================================================================

#define NMERR_INVALID_FILE_FORMAT            39

//=============================================================================
//  The OS could not create a temporary file.
//=============================================================================

#define NMERR_COULD_NOT_CREATE_TEMPFILE      40

//=============================================================================
//  There is not enough MS-DOS memory available.
//=============================================================================

#define NMERR_OUT_OF_DOS_MEMORY              41

//=============================================================================
//  There are no protocols enabled.
//=============================================================================

#define NMERR_NO_PROTOCOLS_ENABLED           42

//=============================================================================
//  The MAC type is invalid or unsupported.
//=============================================================================

#define NMERR_UNKNOWN_MACTYPE                46

//=============================================================================
//  There is no routing information present in the MAC frame.
//=============================================================================

#define NMERR_ROUTING_INFO_NOT_PRESENT       47

//=============================================================================
//  The network handle is invalid.
//=============================================================================

#define NMERR_INVALID_HNETWORK               48

//=============================================================================
//  The network is already open.
//=============================================================================

#define NMERR_NETWORK_ALREADY_OPENED         49

//=============================================================================
//  The network is not open.
//=============================================================================

#define NMERR_NETWORK_NOT_OPENED             50

//=============================================================================
//  The frame was not found in the buffer.
//=============================================================================

#define NMERR_FRAME_NOT_FOUND                51

//=============================================================================
//  There are no handles available.
//=============================================================================

#define NMERR_NO_HANDLES                     53

//=============================================================================
//  The network ID is invalid.
//=============================================================================

#define NMERR_INVALID_NETWORK_ID             54

//=============================================================================
//  The capture handle is invalid.
//=============================================================================

#define NMERR_INVALID_HCAPTURE               55

//=============================================================================
//  The protocol has already been enabled.
//=============================================================================

#define NMERR_PROTOCOL_ALREADY_ENABLED       56

//=============================================================================
//  The filter expression is invalid.
//=============================================================================

#define NMERR_FILTER_INVALID_EXPRESSION      57

//=============================================================================
//  A transmit error occured.
//=============================================================================

#define NMERR_TRANSMIT_ERROR                 58

//=============================================================================
//  The buffer handle is invalid.
//=============================================================================

#define NMERR_INVALID_HBUFFER                59

//=============================================================================
//  The specified data is unknown or invalid.
//=============================================================================

#define NMERR_INVALID_DATA                   60

//=============================================================================
//  The MS-DOS/NDIS 2.0 network driver is not loaded.
//=============================================================================

#define NMERR_MSDOS_DRIVER_NOT_LOADED        61

//=============================================================================
//  The Windows VxD/NDIS 3.0 network driver is not loaded.
//=============================================================================

#define NMERR_WINDOWS_DRIVER_NOT_LOADED      62

//=============================================================================
//  The MS-DOS/NDIS 2.0 driver had an init-time failure.
//=============================================================================

#define NMERR_MSDOS_DRIVER_INIT_FAILURE      63

//=============================================================================
//  The Windows/NDIS 3.0 driver had an init-time failure.
//=============================================================================

#define NMERR_WINDOWS_DRIVER_INIT_FAILURE    64

//=============================================================================
//  The network driver is busy and cannot handle requests.
//=============================================================================

#define NMERR_NETWORK_BUSY                   65

//=============================================================================
//  The capture is not paused.
//=============================================================================

#define NMERR_CAPTURE_NOT_PAUSED             66

//=============================================================================
//  The frame/packet length is not valid.
//=============================================================================

#define NMERR_INVALID_PACKET_LENGTH          67

//=============================================================================
//  An internal exception occured.
//=============================================================================

#define NMERR_INTERNAL_EXCEPTION             69

//=============================================================================
//  The MAC driver does not support promiscious mode.
//=============================================================================

#define NMERR_PROMISCUOUS_MODE_NOT_SUPPORTED 70

//=============================================================================
//  The MAC driver failed to open.
//=============================================================================

#define NMERR_MAC_DRIVER_OPEN_FAILURE        71

//=============================================================================
//  The protocol went off the end of the frame.
//=============================================================================

#define NMERR_RUNAWAY_PROTOCOL               72

//=============================================================================
//  An asynchronous operation is still pending.
//=============================================================================

#define NMERR_PENDING                        73

//=============================================================================
//  Access is denied.
//=============================================================================

#define NMERR_ACCESS_DENIED                  74

//=============================================================================
//  The password handle is invalid.
//=============================================================================

#define NMERR_INVALID_HPASSWORD              75

//=============================================================================
//  A bad parameter was detected.
//=============================================================================

#define NMERR_INVALID_PARAMETER              76

//=============================================================================
//  An error occured reading the file.
//=============================================================================

#define NMERR_FILE_READ_ERROR                77

//=============================================================================
//  An error occured writing to the file.
//=============================================================================

#define NMERR_FILE_WRITE_ERROR               78

//=============================================================================
//  The protocol has not been registered
//=============================================================================

#define NMERR_PROTOCOL_NOT_REGISTERED        79

//=============================================================================
//  The frame does not contain an IP address.
//=============================================================================

#define NMERR_IP_ADDRESS_NOT_FOUND           80

//=============================================================================
//  The transmit request was cancelled.
//=============================================================================

#define NMERR_TRANSMIT_CANCELLED             81

//=============================================================================
//  The operation cannot be performed on a capture with 1 or more locked frames.
//=============================================================================

#define NMERR_LOCKED_FRAMES                  82

//=============================================================================
//  A cancel transmit request was submitted but there were no transmits pending.
//=============================================================================

#define NMERR_NO_TRANSMITS_PENDING           83

//=============================================================================
//  Path not found.
//=============================================================================

#define NMERR_PATH_NOT_FOUND                 84

//=============================================================================
//  A windows error has occured.
//=============================================================================

#define NMERR_WINDOWS_ERROR                  85

//=============================================================================
//  The handle to the frame has no frame number.
//=============================================================================

#define NMERR_NO_FRAME_NUMBER                86

//=============================================================================
//  The frame is not associated with any capture.
//=============================================================================

#define NMERR_FRAME_HAS_NO_CAPTURE           87

//=============================================================================
//  The frame is already associated with a capture.
//=============================================================================

#define NMERR_FRAME_ALREADY_HAS_CAPTURE      88

//=============================================================================
//  The NAL is not remotable.
//=============================================================================

#define NMERR_NAL_IS_NOT_REMOTE              89

//=============================================================================
//  The API is not supported
//=============================================================================

#define NMERR_NOT_SUPPORTED                  90

//=============================================================================
//  Network Monitor should discard the current frame. 
//  This error code is only used during a filtered SaveCapture() API call.
//=============================================================================

#define NMERR_DISCARD_FRAME                  91

//=============================================================================
//  Network Monitor should cancel the current save. 
//  This error code is only used during a filtered SaveCapture() API call.
//=============================================================================

#define NMERR_CANCEL_SAVE_CAPTURE            92

//=============================================================================
//  The connection to the remote machine has been lost
//=============================================================================

#define NMERR_LOST_CONNECTION                93

//=============================================================================
//  The media/mac type is not valid.
//=============================================================================

#define NMERR_INVALID_MEDIA_TYPE             94

//=============================================================================
//  The Remote Agent is currently in use
//=============================================================================

#define NMERR_AGENT_IN_USE                   95

//=============================================================================
//  The request has timed out
//=============================================================================

#define NMERR_TIMEOUT                        96

//=============================================================================
//  The remote agent has been disconnected
//=============================================================================

#define NMERR_DISCONNECTED                   97

//=============================================================================
//  A timer required for operation failed creation
//=============================================================================

#define NMERR_SETTIMER_FAILED                98

//=============================================================================
//  A network error occured.
//=============================================================================

#define NMERR_NETWORK_ERROR                  99

//=============================================================================
//  Frame callback procedure is not valid
//=============================================================================
#define NMERR_INVALID_FRAMESPROC            100

//=============================================================================
//  Capture type specified is unknown
//=============================================================================
#define NMERR_UNKNOWN_CAPTURETYPE           101

//=============================================================================
// The NPP is not connected to a network.
//=============================================================================
#define NMERR_NOT_CONNECTED                 102

//=============================================================================
// The NPP is already connected to a network.
//=============================================================================
#define NMERR_ALREADY_CONNECTED             103

//=============================================================================
// The registry tag does not indicate a known configuration.
//=============================================================================
#define NMERR_INVALID_REGISTRY_CONFIGURATION 104

//=============================================================================
// The NPP is currently configured for delayed capturing.
//=============================================================================
#define NMERR_DELAYED                       105

//=============================================================================
// The NPP is not currently configured for delayed capturing.
//=============================================================================
#define NMERR_NOT_DELAYED                   106

//=============================================================================
// The NPP is currently configured for real time capturing.
//=============================================================================
#define NMERR_REALTIME                      107

//=============================================================================
// The NPP is not currently configured for real time capturing.
//=============================================================================
#define NMERR_NOT_REALTIME                  108

//=============================================================================
// The NPP is currently configured for stats only capturing.
//=============================================================================
#define NMERR_STATS_ONLY                    109

//=============================================================================
// The NPP is not currently configured for stats only capturing.
//=============================================================================
#define NMERR_NOT_STATS_ONLY                110

//=============================================================================
// The NPP is currently configured for transmitting.
//=============================================================================
#define NMERR_TRANSMIT                      111

//=============================================================================
// The NPP is not currently configured for transmitting.
//=============================================================================
#define NMERR_NOT_TRANSMIT                  112

//=============================================================================
// The NPP is currently transmitting
//=============================================================================
#define NMERR_TRANSMITTING                  113

//=============================================================================
// The specified capture file hard disk is not local
//=============================================================================
#define NMERR_DISK_NOT_LOCAL_FIXED          114

//=============================================================================
// Could not create the default capture directory on the given disk
//=============================================================================
#define NMERR_COULD_NOT_CREATE_DIRECTORY    115

//=============================================================================
// The default capture directory was not set in the registry:
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nm\Parameters\CapturePath
//=============================================================================
#define NMERR_NO_DEFAULT_CAPTURE_DIRECTORY  116

//=============================================================================
//  The capture file is an uplevel version that this netmon does not understand
//=============================================================================

#define NMERR_UPLEVEL_CAPTURE_FILE           117


//=============================================================================
//  An expert failed to load.
//=============================================================================

#define NMERR_LOAD_EXPERT_FAILED             118

//=============================================================================
//  An expert failed to report its EXPERT_INFO structs.
//=============================================================================

#define	NMERR_EXPERT_REPORT_FAILED          119

//=============================================================================
//  Registry API call failed.
//=============================================================================

#define	NMERR_REG_OPERATION_FAILED          120


//=============================================================================
//  Registry API call failed.
//=============================================================================

#define	NMERR_NO_DLLS_FOUND                 121

//=============================================================================
//  There are no conversation stats, they were not asked for.
//=============================================================================

#define	NMERR_NO_CONVERSATION_STATS         122

//=============================================================================
//  We have received a security response packet from a security monitor.
//=============================================================================

#define	NMERR_SECURITY_BREACH_CAPTURE_DELETED  123

//=============================================================================
//  The given frame failed the display filter.
//=============================================================================

#define NMERR_FRAME_FAILED_FILTER           124


//=============================================================================
//  Netmon wants the Expert to stop running.
//=============================================================================

#define NMERR_EXPERT_TERMINATE              125

//=============================================================================
//  Netmon needs the remote machine to be a server.
//=============================================================================

#define NMERR_REMOTE_NOT_A_SERVER           126

//=============================================================================
//  Netmon needs the remote machine to be a server.
//=============================================================================

#define NMERR_REMOTE_VERSION_OUTOFSYNC      127

//=============================================================================
//  The supplied group is an invalid handle
//=============================================================================

#define NMERR_INVALID_EXPERT_GROUP      128

//=============================================================================
//  The supplied expert name cannot be found
//=============================================================================

#define NMERR_INVALID_EXPERT_NAME       129

//=============================================================================
//  The supplied expert name cannot be found
//=============================================================================

#define NMERR_INVALID_EXPERT_HANDLE 130

//=============================================================================
//  The supplied group name already exists
//=============================================================================

#define NMERR_GROUP_NAME_ALREADY_EXISTS  131

//=============================================================================
//  The supplied group name is invalid
//=============================================================================

#define NMERR_INVALID_GROUP_NAME    132

//=============================================================================
//  The supplied Expert is already in the group.  
//=============================================================================

#define NMERR_EXPERT_ALREADY_IN_GROUP    133

//=============================================================================
//  The Expert cannot be deleted from the group because it is not in the group
//=============================================================================

#define NMERR_EXPERT_NOT_IN_GROUP        134

//=============================================================================
//  The COM object has not been initialized
//=============================================================================

#define NMERR_NOT_INITIALIZED   135

//=============================================================================
//  Cannot perform function to Root group
//=============================================================================

#define NMERR_INVALID_GROUP_ROOT   136

//=============================================================================
//  Potential data structure mismatch between NdisNpp and Driver.
//=============================================================================

#define NMERR_BAD_VERSION   137

//=============================================================================
// The NPP is currently configured for ESP capturing.
//=============================================================================
#define NMERR_ESP                         138

//=============================================================================
// The NPP is not currently configured for ESP capturing.
//=============================================================================
#define NMERR_NOT_ESP                     139



///////////////////////////////////////////////////////////////////////////////
// MACROS
///////////////////////////////////////////////////////////////////////////////
// normal Network Monitor errors will be put into the code portion of an hresult
// for return from OLE objects:
// these two macros will help to create and crack the scode
INLINE HRESULT NMERR_TO_HRESULT( DWORD nmerror )
{
    HRESULT hResult;
    if (nmerror == NMERR_SUCCESS)
        hResult = NOERROR;
    else
        hResult = MAKE_HRESULT( SEVERITY_ERROR,FACILITY_ITF, (WORD)nmerror) ;

    return hResult;
}

//We use to decide whether the first bit was set to 1 or 0, not regarding 
//whether the result passed with a warning set in the low word.  Now we 
//disregard the first bit and pass back the warning.
INLINE DWORD HRESULT_TO_NMERR( HRESULT hResult )
{
    return HRESULT_CODE(hResult);
}

#endif // NMErr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmicmpstructs.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1993-1999. All rights reserved.
//
//  MODULE: nmicmpstructs.h
//
//  Definitions/#defines for parsing ICMP frames.
//=============================================================================

#ifndef NMICMPSTRUCTS_H
#define NMICMPSTRUCTS_H

#include <nmipstructs.h>

#ifdef __cplusplus
extern "C"
{
#endif

//
// ICMP Frame Structure
//

typedef struct _RequestReplyFields 
{
   WORD ID;
   WORD SeqNo;
} ReqReply;

typedef struct _ParameterProblemFields 
{
   BYTE Pointer;
   BYTE junk[3];
} ParmProb;

typedef struct _TimestampFields 
{
   DWORD tsOrig;
   DWORD tsRecv;
   DWORD tsXmit;
} TS;

typedef struct _RouterAnnounceHeaderFields
{
    BYTE NumAddrs;
    BYTE AddrEntrySize;
    WORD Lifetime;
} RouterAH;

typedef struct _RouterAnnounceEntry
{
    DWORD Address;
    DWORD PreferenceLevel;
} RouterAE;

typedef struct _ICMP 
{
   BYTE Type;
   BYTE Code;
   WORD Checksum;
   union
   {
      DWORD    Unused;
      DWORD    Address;
      ReqReply RR;
      ParmProb PP;
      RouterAH RAH;     
   };

   union
   {
      TS       Time;
      IP       IP;
#pragma warning(disable:4200)
      RouterAE RAE[0];
#pragma warning(default:4200)
   };
} ICMP;

typedef ICMP * LPICMP;
typedef ICMP UNALIGNED * ULPICMP;

#define ICMP_HEADER_LENGTH (8)
#define ICMP_IP_DATA_LENGTH   (8)   // # of *BYTES* of IP data to attach to
                                    // datagram in addition to IP header
//
// ICMP Packet Types
//

#define ECHO_REPLY                     0
#define DESTINATION_UNREACHABLE        3
#define SOURCE_QUENCH                  4
#define REDIRECT                       5
#define ECHO                           8
#define ROUTER_ADVERTISEMENT           9
#define ROUTER_SOLICITATION           10
#define TIME_EXCEEDED                 11
#define PARAMETER_PROBLEM             12
#define TIMESTAMP                     13
#define TIMESTAMP_REPLY               14
#define INFORMATION_REQUEST           15
#define INFORMATION_REPLY             16
#define ADDRESS_MASK_REQUEST          17
#define ADDRESS_MASK_REPLY            18

#ifdef __cplusplus
}
#endif

#endif NMICMPSTRUCTS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmexpert.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1997-1999. All rights reserved.
//
//  MODULE: NMExpert.h
//
//  Structures and definitions needed in Experts
//=============================================================================

#ifndef _NMEXPERT_H_
#define _NMEXPERT_H_

// we say zero length arrays are just fine...
#pragma warning(disable:4200)

// all of the stuff that follows is not C++ specific
#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#define EXPERTSTRINGLENGTH  MAX_PATH
#define EXPERTGROUPNAMELENGTH 25

// HEXPERTKEY tracks running experts. It is only used by experts for 
// self reference. It refers to a RUNNINGEXPERT (an internal only structure)..
typedef LPVOID HEXPERTKEY;
typedef HEXPERTKEY * PHEXPERTKEY;

// HEXPERT tracks loaded experts. It refers to an EXPERTENUMINFO.
typedef LPVOID HEXPERT;
typedef HEXPERT * PHEXPERT;

// HRUNNINGEXPERT tracks a currently running expert.
// It refers to a RUNNINGEXPERT (an internal only structure).
typedef LPVOID HRUNNINGEXPERT;
typedef HRUNNINGEXPERT * PHRUNNINGEXPERT;

// HGROUP tracks a group. It refers to a GROUPLIST (an internal only structure).
typedef LPVOID HGROUP;
typedef HGROUP * PHGROUP;

// forward ref
typedef struct _EXPERTENUMINFO * PEXPERTENUMINFO;
typedef struct _EXPERTCONFIG   * PEXPERTCONFIG;
typedef struct _EXPERTSTARTUPINFO * PEXPERTSTARTUPINFO;

// Definitions needed to call experts
#define EXPERTENTRY_REGISTER      "Register"
#define EXPERTENTRY_CONFIGURE     "Configure"
#define EXPERTENTRY_RUN           "Run"
typedef BOOL (WINAPI * PEXPERTREGISTERPROC)( PEXPERTENUMINFO );
typedef BOOL (WINAPI * PEXPERTCONFIGPROC)  ( HEXPERTKEY, PEXPERTCONFIG*, PEXPERTSTARTUPINFO, DWORD, HWND );
typedef BOOL (WINAPI * PEXPERTRUNPROC)     ( HEXPERTKEY, PEXPERTCONFIG, PEXPERTSTARTUPINFO, DWORD, HWND);


// EXPERTENUMINFO describes an expert that NetMon has loaded from disk. 
// It does not include any configuration or runtime information.
typedef struct _EXPERTENUMINFO
{
    char      szName[EXPERTSTRINGLENGTH];
    char      szVendor[EXPERTSTRINGLENGTH];
    char      szDescription[EXPERTSTRINGLENGTH];
    DWORD     Version;    
    DWORD     Flags;
    char      szDllName[MAX_PATH];      // private, dont' touch
    HEXPERT   hExpert;                  // private, don't touch
    HINSTANCE hModule;                  // private, don't touch
    PEXPERTREGISTERPROC pRegisterProc;  // private, don't touch
    PEXPERTCONFIGPROC   pConfigProc;    // private, don't touch
    PEXPERTRUNPROC      pRunProc;       // private, don't touch
} EXPERTENUMINFO;
typedef EXPERTENUMINFO * PEXPERTENUMINFO;

#define EXPERT_ENUM_FLAG_CONFIGURABLE                0x0001   // Expert dll contains configure export function 
#define EXPERT_ENUM_FLAG_VIEWER_PRIVATE              0x0002   // Expert dll wants private viewer (default is shared)
#define EXPERT_ENUM_FLAG_NO_VIEWER                   0x0004   // Expert dll does not want an associated viewer
#define EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_SUMMARY    0x0010   // Expert dll wants to be on the RMC menu in the summary pane
#define EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_DETAIL     0x0020   // Expert dll wants to be on the RMC menu in the detail pane

// GROUPINFO
// This is an accociation between a group name and its handle.
typedef struct
{
    char        szGroupName[EXPERTGROUPNAMELENGTH+1];
    HGROUP  hGroup;
} GROUPINFO;
typedef GROUPINFO * PGROUPINFO;

// EXPERTSTARTUPINFO
// This gives the Expert an indication of where he came from.
typedef struct _EXPERTSTARTUPINFO
{
    DWORD           Flags;
    HCAPTURE        hCapture;
    char            szCaptureFile[MAX_PATH];
    DWORD           dwFrameNumber;
    HPROTOCOL       hProtocol;

    // note: the expert launch code has locked the starting frame
    // so this data will not go out of scope.
    LPPROPERTYINST  lpPropertyInst;

    // if the lpPropertyInst->PropertyInfo->DataQualifier == PROP_QUAL_FLAGS
    // the the following structure is filled in
    struct
    {
        BYTE    BitNumber;
        BOOL    bOn;
    } sBitfield;

} EXPERTSTARTUPINFO;

// EXPERTCONFIG
// This is a generic holder for an Expert's config data.
typedef struct  _EXPERTCONFIG
{
    DWORD   RawConfigLength;
    BYTE    RawConfigData[0];

} EXPERTCONFIG;
typedef EXPERTCONFIG * PEXPERTCONFIG;

// CONFIGUREDEXPERT
// This structure associates a loaded expert with its configuration data.
typedef struct
{
    HEXPERT         hExpert;
    DWORD           StartupFlags;
    PEXPERTCONFIG   pConfig;
} CONFIGUREDEXPERT;
typedef CONFIGUREDEXPERT * PCONFIGUREDEXPERT;

// EXPERTFRAMEDESCRIPTOR - passed back to the expert to fulfil the request for a frame
typedef struct
{
    DWORD                FrameNumber;         // Frame Number.
    HFRAME               hFrame;              // Handle to the frame.
    ULPFRAME             pFrame;              // pointer to frame.
    LPRECOGNIZEDATATABLE lpRecognizeDataTable;// pointer to table of RECOGNIZEDATA structures.
    LPPROPERTYTABLE      lpPropertyTable;     // pointer to property table.
} EXPERTFRAMEDESCRIPTOR;
typedef EXPERTFRAMEDESCRIPTOR * LPEXPERTFRAMEDESCRIPTOR;

// other definitions
#define GET_SPECIFIED_FRAME              0
#define GET_FRAME_NEXT_FORWARD           1
#define GET_FRAME_NEXT_BACKWARD          2

#define FLAGS_DEFER_TO_UI_FILTER       0x1
#define FLAGS_ATTACH_PROPERTIES        0x2

// EXPERTSTATUSENUM
// gives the possible values for the status field in the EXPERTSTATUS structure
typedef enum
{
    EXPERTSTATUS_INACTIVE = 0,
    EXPERTSTATUS_STARTING,
    EXPERTSTATUS_RUNNING,
    EXPERTSTATUS_PROBLEM,
    EXPERTSTATUS_ABORTED,  
    EXPERTSTATUS_DONE,  
} EXPERTSTATUSENUMERATION;

// EXPERTSUBSTATUS bitfield 
// gives the possible values for the substatus field in the EXPERTSTATUS structure
#define  EXPERTSUBSTATUS_ABORTED_USER          0x0001   // User aborted expert dll
#define  EXPERTSUBSTATUS_ABORTED_LOAD_FAIL     0x0002   // Netmon could not load expert dll
#define  EXPERTSUBSTATUS_ABORTED_THREAD_FAIL   0x0004   // Netmon could not start dll thread
#define  EXPERTSUBSTATUS_ABORTED_BAD_ENTRY     0x0008   // Netmon could not find expert dll entry point 

// EXPERTSTATUS
// Indicates the current status of a running expert.
typedef struct
{                                                          
    EXPERTSTATUSENUMERATION   Status;
    DWORD                     SubStatus;
    DWORD                     PercentDone;
    DWORD                     Frame; 
    char                      szStatusText[EXPERTSTRINGLENGTH];
} EXPERTSTATUS;
typedef EXPERTSTATUS * PEXPERTSTATUS;               


// EXPERT STARTUP FLAGS
#define EXPERT_STARTUP_FLAG_USE_STARTUP_DATA_OVER_CONFIG_DATA   0x00000001

#ifdef __cplusplus
}
#endif // __cplusplus

// turn this warning back on
#pragma warning(default:4200)

#endif // _NMEXPERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmevent.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1997-1999. All rights reserved.
//
//  MODULE: NMEvent.h
//
//  The basis of all Network Monitor Events
//=============================================================================

#ifndef _NMEVENT_H_
#define _NMEVENT_H_

// we only need this include to get MAC_ADDRESS_SIZE and IPX_ADDRESS
#include <npptypes.h>

// we say zero length arrays are just fine...
#pragma warning(disable:4200)

// NMCOLUMNTYPE
typedef enum 
{

    NMCOLUMNTYPE_UINT8 = 0,
    NMCOLUMNTYPE_SINT8,
    NMCOLUMNTYPE_UINT16,
    NMCOLUMNTYPE_SINT16,
    NMCOLUMNTYPE_UINT32,
    NMCOLUMNTYPE_SINT32,
    NMCOLUMNTYPE_FLOAT64,
    NMCOLUMNTYPE_FRAME,
    NMCOLUMNTYPE_YESNO,
    NMCOLUMNTYPE_ONOFF,
    NMCOLUMNTYPE_TRUEFALSE,
    NMCOLUMNTYPE_MACADDR,
    NMCOLUMNTYPE_IPXADDR,
    NMCOLUMNTYPE_IPADDR,
    NMCOLUMNTYPE_VARTIME,
    NMCOLUMNTYPE_STRING

} NMCOLUMNTYPE;

// NMCOLUMNVARIANT
typedef struct _NMCOLUMNVARIANT
{
    NMCOLUMNTYPE Type;
    union
    {
       BYTE     Uint8Val;    // 8 bit unsigned value
       char     Sint8Val;    // 8 bit signed value
       WORD     Uint16Val;   // 16 bit unsigned value
       short    Sint16Val;   // 16 bit signed value
       DWORD    Uint32Val;   // 32 bit unsigned value
       long     Sint32Val;   // 32 bit signed value
       DOUBLE   Float64Val;  // 64 bit floating point value
       DWORD    FrameVal;    // 32 bit unsigned frame value
       BOOL     YesNoVal;    // 32 bit boolean: zero maps to 'NO', nonzero maps to 'YES'
       BOOL     OnOffVal;    // 32 bit boolean: zero maps to 'OFF', nonzero maps to 'ON'
       BOOL     TrueFalseVal;// 32 bit boolean: zero maps to 'False', nonzero maps to 'True'
       BYTE     MACAddrVal[MAC_ADDRESS_SIZE];// 48 bit MAC address (6 bytes)
       IPX_ADDRESS IPXAddrVal;// 10 byte ipx address (4 byte subnet. 6 byte address)
       DWORD    IPAddrVal;   // 32 bit IP Address: ddd.ddd.ddd.ddd
       DOUBLE   VarTimeVal;  // Double representation of time value (use VariantTimeToSystemTime to convert)
       LPCSTR  pStringVal;   // pointer to a string value
    } Value;
} NMCOLUMNVARIANT;

// COLUMNINFO
typedef struct _NMCOLUMNINFO
{
    LPSTR           szColumnName;// Name of column
    NMCOLUMNVARIANT VariantData; // Value for column
} NMCOLUMNINFO;                                                  
typedef NMCOLUMNINFO* PNMCOLUMNINFO;                                         
             
// JTYPE
typedef LPSTR JTYPE; // (structure placeholder)

// EVENTDATA
typedef struct _NMEVENTDATA
{                                                                   
    LPSTR      pszReserved;  // Reserved
    BYTE       Version;      // Version for this structure (must be 0)
    DWORD      EventIdent;   // ID for this event
    DWORD      Flags;        // Flags for Expert generated or Monitor generated and others
    DWORD      Severity;     // Severity level
    BYTE       NumColumns;   // Number of optional columns for this event
    LPSTR      szSourceName; // Name of Monitor or Expert
    LPSTR      szEventName;  // Name of event
    LPSTR      szDescription;// Description of event
    LPSTR      szMachine;    // Name (or IPADDRESS?) of the machine supplying the event (NULL for Experts usually)
    JTYPE      Justification;// Justification pane info (currently a string, but possible structure)
    LPSTR      szUrl;        // URL to Book of Knowledge  (NULL for default for ID?)
    SYSTEMTIME SysTime;      // Systemtime of the event
    NMCOLUMNINFO Column[0];    // Array of optional columns with their names and data
} NMEVENTDATA;
typedef NMEVENTDATA* PNMEVENTDATA;

// EVENT FLAGS
#define NMEVENTFLAG_MONITOR                      0x00000000   // Event was generated by a monitor
#define NMEVENTFLAG_EXPERT                       0x00000001   // Event was generated by an expert

#define NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY      0x80000000
#define NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE        0x40000000
#define NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME    0x20000000
#define NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION   0x10000000
#define NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE       0x08000000
#define NMEVENTFLAG_DO_NOT_DISPLAY_TIME          0x04000000
#define NMEVENTFLAG_DO_NOT_DISPLAY_DATE          0x02000000

//#define NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS (NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY   | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE     | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION| \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE    | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_TIME       | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DATE )
#define NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS 0xFE000000


enum  _NMEVENT_SEVERITIES
{
    NMEVENT_SEVERITY_INFORMATIONAL = 0,
    NMEVENT_SEVERITY_WARNING,
    NMEVENT_SEVERITY_STRONG_WARNING,
    NMEVENT_SEVERITY_ERROR,
    NMEVENT_SEVERITY_SEVERE_ERROR,
    NMEVENT_SEVERITY_CRITICAL_ERROR 
};


// turn this warning back on
#pragma warning(default:4200)

#endif // _EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmreghelp.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-1999. All rights reserved.
//
//  MODULE: NMRegHelp.h
//
//  Prototypes of Registry helper functions
//=============================================================================

#ifndef NMREGHELP_H
#define NMREGHELP_H


#ifdef __cplusplus
extern "C" {
#endif

// Registry helpers
LPCSTR _cdecl FindOneOf(LPCSTR p1, LPCSTR p2);

LONG _cdecl recursiveDeleteKey(HKEY hKeyParent,            // Parent of key to delete.
                        const char* lpszKeyChild);  // Key to delete.

BOOL _cdecl SubkeyExists(const char* pszPath,              // Path of key to check
                  const char* szSubkey);            // Key to check

BOOL _cdecl setKeyAndValue(const char* szKey, 
                    const char* szSubkey, 
                    const char* szValue,
                    const char* szName) ;

#ifdef __cplusplus
}
#endif

#endif // NMREGHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmmonitor.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1997-1999. All rights reserved.
//
//  MODULE: NMMonitor.h
//
//  External Header for all NPP monitors
//=============================================================================

#ifndef NMMONITOR_H
#define NMMONITOR_H

#ifdef __cplusplus
extern "C"
{
#endif

#include <netmon.h>
#include <nmMCS.h>
#include <nmblob.h>
#include <tchar.h>

// Forward reference
struct MONITOR;
typedef MONITOR* PMONITOR;

typedef void (WINAPI* MCSALERTPROC) (PMONITOR pMonitor, char* alert);

//****************************************************************************
// Our exported Monitor functions, that must be supported by ALL monitors 
//****************************************************************************
// Create the Monitor, function called "CreateMonitor". The
// argument is a potential configuration structure
typedef DWORD (WINAPI* CREATEMONITOR)(PMONITOR*     ppMonitor, 
                                      HBLOB         hInputNPPBlob,
                                      char*         pConfiguration,
                                      MCSALERTPROC  McsAlertProc);

// Destroy the Monitor, function called "DestroyMonitor"
typedef DWORD (WINAPI* DESTROYMONITOR)(PMONITOR);

// We need the monitor's NPP filter blob: "GetMonitorFilter"
typedef DWORD (WINAPI* GETMONITORFILTER) (HBLOB* pFilterBlob);

// Get the monitor configuration "GetMonitorConfig"
// The pMonitor argument can not be null
typedef DWORD (WINAPI* GETMONITORCONFIG) (PMONITOR pMonitor,
                                          char**   ppScript,
                                          char**   ppConfiguration);

// Set the monitor configuration "SetMonitorConfig"
// The pMonitor argument can not be null
typedef DWORD (WINAPI* SETMONITORCONFIG) (PMONITOR pMonitor, 
                                          char* pConfiguration);

// The monitor's connect function: "ConnectMonitor"
typedef DWORD (WINAPI* CONNECTMONITOR) (PMONITOR pMonitor);

// The monitor's start function: "StartMonitor"
typedef DWORD (WINAPI* STARTMONITOR) (PMONITOR pMonitor, char** ppResponse);

// The monitor's stop function: "StopMonitor"
typedef DWORD (WINAPI* STOPMONITOR) (PMONITOR pMonitor);

// Get the monitor status: "GetMonitorStatus"
typedef DWORD (WINAPI* GETMONITORSTATUS) (PMONITOR pMonitor, DWORD* pStatus);

//****************************************************************************
// Optional function that allows the monitor dll to do specific functions
// prior to the creation of any monitors. "OneTimeSetup"
typedef DWORD (WINAPI* ONETIMESETUP) (void);
//****************************************************************************

//****************************************************************************
// Optional function that provides a description of the monitor
//****************************************************************************
// For current display porpoises, we could use this: "DescribeSelf"
typedef DWORD (WINAPI* DESCRIBESELF) (const char** ppName,
                                      const char** ppDescription);

#ifdef __cplusplus
}
#endif

//=============================================================================
//  Semi-useful class which writes out frame to a cap file Netmon can read.
//=============================================================================
struct CSCAPF;

class __declspec (dllexport) CCaptureFile
{
public:
    CCaptureFile(const char* FileName,
                 HWND hwndParent,
                 DWORD FileSize,
                 int EstimatedAvgFrameSize);
    CCaptureFile(const char* FileName,
                 DWORD FileSize,
                 int EstimatedAvgFrameSize);

    ~CCaptureFile();
    
    DWORD SaveFrame(LPFRAME_DESCRIPTOR lpFrameDesc);
    DWORD Save(void);
    DWORD Resize(DWORD NewFileSize);
    DWORD SetNetworkInfo(LPNETWORKINFO lpNetworkInfo);

private:
    CSCAPF* m_cscapf;
};

//=============================================================================
//  Class definition for the resource string loader
//=============================================================================
#define INITIAL_TABLE_SIZE          (100 * sizeof(LPSTR))
#define INITIAL_TEMP_BUFFER_SIZE    512

// IDS Class
class __declspec (dllexport) IDS
{
    public:
        IDS( DWORD StringBase, HINSTANCE hInstance );
        ~IDS();

        LPSTR GetString( DWORD StringID );

    private:
        // configuration parameters
        DWORD m_dwStringBase;
        HINSTANCE m_hInstance;

        // the array of pointers to strings
        // (this holds strings already loaded)
        LPSTR *m_pMasterList;

        // this counts the number of Entries (not bytes)
        DWORD m_dwMasterListLength;

        // a temporary buffer to hold fresh strings
        LPSTR m_szTempBuffer;
        DWORD m_dwTempBufferLength;

        // this holds the default string ""
        char m_szBlank[1];
};

//=============================================================================
//  Various helpers for monitors, IP monitors, in particular.
//=============================================================================
#ifdef __cplusplus
extern "C"
{
#endif

typedef struct
{
    DWORD Mask;
    DWORD Addr;
} SAddrMaskPair;

// Convert HTML CP_UTF8 version to Unicode
__declspec (dllexport) WCHAR* HTMLValueToUnicode(const TCHAR* pValue);

// Replace HTML funkiness with special characters (like ;:&, etc)
__declspec (dllexport) void CleanHTMLString(TCHAR* string);

// Load TCHAR string from html config string
__declspec (dllexport) BOOL LoadTCHAR(const char*  pConfig, 
                                      const char*  pVarName, 
                                      TCHAR**      ppszString);

// Load DWORD from html config string
__declspec (dllexport) BOOL LoadDWORD(const char*  pConfig, 
                                      const char*  pVarName, 
                                      DWORD* pValue);

// Load IP address list from HTML TEXTAREA config string
__declspec (dllexport) BOOL LoadHTMAddrMaskPairs(const char*     pConfig,
                                                 const char*     pVarName,
                                                 SAddrMaskPair** ppAddrMask, 
                                                 DWORD*          pNumAddresses);

// Load IP address list from HTML TEXTAREA config string
__declspec (dllexport) BOOL LoadIPAddresses(const char* pConfig, 
                                            const char* pVarName,
                                            DWORD**     ppAddresses,
                                            DWORD*      pNumAddresses);

// Load IPX address list from HTML TEXTAREA config string
__declspec (dllexport) BOOL LoadIPXAddresses(const char*   pConfig, 
                                             const char*   pVarName,
                                             IPX_ADDRESS** ppAddresses,
                                             DWORD*        pNumAddresses);

// Load MAC address list from HTML TEXTAREA config string
__declspec (dllexport) BOOL LoadMACAddresses(const char*   pConfig, 
                                             const char*   pVarName,
                                             LPBYTE*       ppAddresses,
                                             DWORD*        pNumAddresses);

// SpecialFormatIPAddresses
// Uses the address mask to stick in '*'s, as necessary. Bonus, dude.
__declspec (dllexport) int SpecialFormatIPAddresses(char* str, 
                                                    int index, 
                                                    DWORD dwaddr);

// LoadStringAddrMaskPair
// Takes a string like "157.54.*.*" and creates DWORD address and mask pair
__declspec (dllexport) BOOL LoadStringAddrMaskPair(SAddrMaskPair* pAddrMask, 
                                                   const char* str);

// LoadStringAddr
// Takes a string like "157.54.32.45" and creates DWORD address
__declspec (dllexport) BOOL LoadStringAddr( DWORD* pAddress, const char* str);

// LoadHTMLScript 
// allocates and loads a string with the contents of the file pointed
// to by argument szPath.
__declspec (dllexport) char* LoadHTMLScript(char* szPath);
/*
// BOOL LoadProfileAddressSection 
// Takes an ini file section that looks like this:
sip0=157.54.*.*
sip1=157.55.*.*
sip2=157.56.*.*
sip3=157.57.*.*
sip4=157.58.*.*
sip5=157.59.*.*
sip6=157.60.*.*
sip7=157.61.*.*
sip8=157.62.*.*
sip9=192.168.*.*
and allocates and fills an array of SAddrMaskPairs.
*/
__declspec (dllexport) BOOL LoadProfileAddressSection(const char* Section, 
                               SAddrMaskPair** ppAddrMaskPairs, 
                               DWORD* pNumAddrMaskPairs);

// LoadProfileAddresses
/* Takes an ini file section that looks like this:
sip0=157.54.32.45
sip1=157.55.25.35
and allocates and fills an array of DWORDs.
*/
__declspec (dllexport) BOOL LoadProfileAddresses(const char* Section,
                               DWORD**  ppAddresses,
                               DWORD*   pNumAddresses);
//
// Some MAC helper functions for cracking, These belong in cracker.
__declspec (dllexport) BOOL GetMACAddresses_Ethernet( LPFRAME_DESCRIPTOR lpFrameDesc,
                               LPBYTE*            ppSrcMacAddress,
                               LPBYTE*            ppDstMacAddress);

__declspec (dllexport) BOOL GetMACAddresses_FDDI(     LPFRAME_DESCRIPTOR lpFrameDesc,
                               LPBYTE*            ppSrcMacAddress,
                               LPBYTE*            ppDstMacAddress);

__declspec (dllexport) BOOL GetMACAddresses_TokenRing(LPFRAME_DESCRIPTOR lpFrameDesc,
                               LPBYTE*            ppSrcMacAddress,
                               LPBYTE*            ppDstMacAddress);

__declspec (dllexport) BOOL LoadTextAreaAsMultiSZ( IN  const char*  pConfig,
                            IN  const char*  pVarName,
                            IN        BOOL   fNullDivider,
                            OUT       char * szBuffer,
                            OUT       DWORD* Length );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmipstructs.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1992-1999. All rights reserved.
//
//  MODULE: nmipstructs.h
//
//  IP structures & #defines
//=============================================================================

#ifndef NMIPSTRUCTS_H
#define NMIPSTRUCTS_H

#ifdef __cplusplus
extern "C"
{
#endif

//
// IP Packet Structure
//

#pragma warning(disable:4200)

typedef struct _IP 
{
    union 
    {
        BYTE   Version;
        BYTE   HdrLen;
    };
    BYTE ServiceType;
    WORD TotalLen;
    WORD ID;
    union 
    {
        WORD   Flags;
        WORD   FragOff;
    };
    BYTE TimeToLive;
    BYTE Protocol;
    WORD HdrChksum;
    DWORD   SrcAddr;
    DWORD   DstAddr;
    BYTE Options[0];
} IP;

typedef IP * LPIP;
typedef IP UNALIGNED * ULPIP;

#pragma warning(default:4200)

// Psuedo Header used for CheckSum Calculations
typedef struct _PSUHDR 
{
    DWORD   ph_SrcIP;
    DWORD   ph_DstIP;
    UCHAR   ph_Zero;
    UCHAR   ph_Proto;
    WORD    ph_ProtLen;
} PSUHDR;
typedef PSUHDR UNALIGNED * LPPSUHDR;

//
// IP Bitmasks that are useful
// (and the appropriate bit shifts, as well)
//

#define IP_VERSION_MASK ((BYTE) 0xf0)
#define IP_VERSION_SHIFT (4)
#define IP_HDRLEN_MASK  ((BYTE) 0x0f)
#define IP_HDRLEN_SHIFT (0)
#define IP_PRECEDENCE_MASK ((BYTE) 0xE0)
#define IP_PRECEDENCE_SHIFT   (5)
#define IP_TOS_MASK ((BYTE) 0x1E)
#define IP_TOS_SHIFT   (1)
#define IP_DELAY_MASK   ((BYTE) 0x10)
#define IP_THROUGHPUT_MASK ((BYTE) 0x08)
#define IP_RELIABILITY_MASK   ((BYTE) 0x04)
#define IP_FLAGS_MASK   ((BYTE) 0xE0)
#define IP_FLAGS_SHIFT  (13)
#define IP_DF_MASK   ((BYTE) 0x40)
#define IP_MF_MASK   ((BYTE) 0x20)
#define IP_MF_SHIFT     (5)
#define IP_FRAGOFF_MASK ((WORD) 0x1FFF)
#define IP_FRAGOFF_SHIFT   (3)
#define IP_TCC_MASK  ((DWORD) 0xFFFFFF00)
#define IP_TIME_OPTS_MASK  ((BYTE) 0x0F)
#define IP_MISS_STNS_MASK  ((BYTE) 0xF0)

#define IP_TIME_OPTS_SHIFT (0)
#define IP_MISS_STNS_SHIFT  (4)

#ifndef XCHG
#define XCHG(x)         MAKEWORD( HIBYTE(x), LOBYTE(x) )
#endif

#ifndef DXCHG
#define DXCHG(x)        MAKELONG( XCHG(HIWORD(x)), XCHG(LOWORD(x)) )
#endif

//
// Offset to checksum field in ip header
//
#define IP_CHKSUM_OFF   10

INLINE BYTE IP_Version(ULPIP pIP)
{
    return (pIP->Version & IP_VERSION_MASK) >> IP_VERSION_SHIFT;
}

INLINE DWORD IP_HdrLen(ULPIP pIP)
{
    return ((pIP->HdrLen & IP_HDRLEN_MASK) >> IP_HDRLEN_SHIFT) << 2;
}

INLINE WORD IP_FragOff(ULPIP pIP)
{
    return (XCHG(pIP->FragOff) & IP_FRAGOFF_MASK) << IP_FRAGOFF_SHIFT;
}

INLINE DWORD IP_TotalLen(ULPIP pIP)
{
    return XCHG(pIP->TotalLen);
}

INLINE DWORD IP_MoreFragments(ULPIP pIP)
{
    return (pIP->Flags & IP_MF_MASK) >> IP_MF_SHIFT;
}


//
// Well known ports in the TCP/IP protocol (See RFC 1060)
//
#define PORT_TCPMUX              1  // TCP Port Service Multiplexer
#define PORT_RJE                 5  // Remote Job Entry
#define PORT_ECHO                7  // Echo
#define PORT_DISCARD             9  // Discard
#define PORT_USERS              11  // Active users
#define PORT_DAYTIME            13  // Daytime
#define PORT_NETSTAT            15  // Netstat
#define PORT_QUOTE              17  // Quote of the day
#define PORT_CHARGEN            19  // Character Generator
#define PORT_FTPDATA            20  // File transfer [default data]
#define PORT_FTP                21  // File transfer [Control]
#define PORT_TELNET             23  // Telnet
#define PORT_SMTP               25  // Simple Mail Transfer
#define PORT_NSWFE              27  // NSW User System FE
#define PORT_MSGICP             29  // MSG ICP
#define PORT_MSGAUTH            31  // MSG Authentication
#define PORT_DSP                33  // Display Support
#define PORT_PRTSERVER          35  // any private printer server
#define PORT_TIME               37  // Time
#define PORT_RLP                39  // Resource Location Protocol
#define PORT_GRAPHICS           41  // Graphics
#define PORT_NAMESERVER         42  // Host Name Server
#define PORT_NICNAME            43  // Who is
#define PORT_MPMFLAGS           44  // MPM Flags 
#define PORT_MPM                45  // Message Processing Module [recv]
#define PORT_MPMSND             46  // MPM [default send]
#define PORT_NIFTP              47  // NI FTP
#define PORT_LOGIN              49  // Login Host Protocol
#define PORT_LAMAINT            51  // IMP Logical Address Maintenance
#define PORT_DOMAIN             53  // Domain Name Server
#define PORT_ISIGL              55  // ISI Graphics Language
#define PORT_ANYTERMACC         57  // any private terminal access
#define PORT_ANYFILESYS         59  // any private file service
#define PORT_NIMAIL             61  // NI Mail
#define PORT_VIAFTP             63  // VIA Systems - FTP
#define PORT_TACACSDS           65  // TACACS - Database Service
#define PORT_BOOTPS             67  // Bootstrap Protocol server
#define PORT_BOOTPC             68  // Bootstrap Protocol client
#define PORT_TFTP               69  // Trivial File Transfer
#define PORT_NETRJS1            71  // Remote Job service
#define PORT_NETRJS2            72  // Remote Job service
#define PORT_NETRJS3            73  // Remote Job service
#define PORT_NETRJS4            74  // Remote Job service
#define PORT_ANYDIALOUT         75  // any private dial out service
#define PORT_ANYRJE             77  // any private RJE service
#define PORT_FINGER             79  // Finger
#define PORT_HTTP               80  // HTTP (www)
#define PORT_HOSTS2NS           81  // Hosts2 Name Server
#define PORT_MITMLDEV1          83  // MIT ML Device
#define PORT_MITMLDEV2          85  // MIT ML Device
#define PORT_ANYTERMLINK        87  // any private terminal link
#define PORT_SUMITTG            89  // SU/MIT Telnet Gateway
#define PORT_MITDOV             91  // MIT Dover Spooler
#define PORT_DCP                93  // Device Control Protocol
#define PORT_SUPDUP             95  // SUPDUP
#define PORT_SWIFTRVF           97  // Swift Remote Vitural File Protocol
#define PORT_TACNEWS            98  // TAC News
#define PORT_METAGRAM           99  // Metagram Relay
#define PORT_NEWACCT           100  // [Unauthorized use]
#define PORT_HOSTNAME          101  // NIC Host Name Server
#define PORT_ISOTSAP           102  // ISO-TSAP
#define PORT_X400              103  // X400
#define PORT_X400SND           104  // X400 - SND
#define PORT_CSNETNS           105  // Mailbox Name Nameserver
#define PORT_RTELNET           107  // Remote Telnet Service
#define PORT_POP2              109  // Post Office Protocol - version 2
#define PORT_POP3              110  // Post Office Protocol - version 3
#define PORT_SUNRPC            111  // SUN Remote Procedure Call
#define PORT_AUTH              113  // Authentication
#define PORT_SFTP              115  // Simple File Transfer Protocol
#define PORT_UUCPPATH          117  // UUCP Path Service
#define PORT_NNTP              119  // Network News Transfer Protocol
#define PORT_ERPC              121  // Encore Expedited Remote Proc. Call
#define PORT_NTP               123  // Network Time Protocol
#define PORT_LOCUSMAP          125  // Locus PC-Interface Net Map Sesrver
#define PORT_LOCUSCON          127  // Locus PC-Interface Conn Server
#define PORT_PWDGEN            129  // Password Generator Protocol
#define PORT_CISCOFNA          130  // CISCO FNATIVE
#define PORT_CISCOTNA          131  // CISCO TNATIVE
#define PORT_CISCOSYS          132  // CISCO SYSMAINT
#define PORT_STATSRV           133  // Statistics Service
#define PORT_INGRESNET         134  // Ingres net service
#define PORT_LOCSRV            135  // Location Service
#define PORT_PROFILE           136  // PROFILE Naming System
#define PORT_NETBIOSNS         137  // NETBIOS Name Service
#define PORT_NETBIOSDGM        138  // NETBIOS Datagram Service
#define PORT_NETBIOSSSN        139  // NETBIOS Session Service
#define PORT_EMFISDATA         140  // EMFIS Data Service
#define PORT_EMFISCNTL         141  // EMFIS Control Service
#define PORT_BLIDM             142  // Britton-Lee IDM
#define PORT_IMAP2             143  // Interim Mail Access Protocol v2
#define PORT_NEWS              144  // NewS
#define PORT_UAAC              145  // UAAC protocol
#define PORT_ISOTP0            146  // ISO-IP0
#define PORT_ISOIP             147  // ISO-IP
#define PORT_CRONUS            148  // CRONUS-Support
#define PORT_AED512            149  // AED 512 Emulation Service
#define PORT_SQLNET            150  // SQL-NET
#define PORT_HEMS              151  // HEMS
#define PORT_BFTP              152  // Background File Transfer Protocol
#define PORT_SGMP              153  // SGMP
#define PORT_NETSCPROD         154  // NETSC
#define PORT_NETSCDEV          155  // NETSC
#define PORT_SQLSRV            156  // SQL service
#define PORT_KNETCMP           157  // KNET/VM Command/Message Protocol
#define PORT_PCMAILSRV         158  // PCMail server
#define PORT_NSSROUTING        159  // NSS routing
#define PORT_SGMPTRAPS         160  // SGMP-TRAPS
#define PORT_SNMP              161  // SNMP
#define PORT_SNMPTRAP          162  // SNMPTRAP
#define PORT_CMIPMANAGE        163  // CMIP/TCP Manager
#define PORT_CMIPAGENT         164  // CMIP/TCP Agent
#define PORT_XNSCOURIER        165  // Xerox
#define PORT_SNET              166  // Sirius Systems
#define PORT_NAMP              167  // NAMP
#define PORT_RSVD              168  // RSVC
#define PORT_SEND              169  // SEND
#define PORT_PRINTSRV          170  // Network Postscript
#define PORT_MULTIPLEX         171  // Network Innovations Multiples
#define PORT_CL1               172  // Network Innovations CL/1
#define PORT_XYPLEXMUX         173  // Xyplex
#define PORT_MAILQ             174  // MAILQ
#define PORT_VMNET             175  // VMNET
#define PORT_GENRADMUX         176  // GENRAD-MUX
#define PORT_XDMCP             177  // X Display Manager Control Protocol
#define PORT_NEXTSTEP          178  // NextStep Window Server
#define PORT_BGP               179  // Border Gateway Protocol
#define PORT_RIS               180  // Intergraph
#define PORT_UNIFY             181  // Unify
#define PORT_UNISYSCAM         182  // Unisys-Cam
#define PORT_OCBINDER          183  // OCBinder
#define PORT_OCSERVER          184  // OCServer
#define PORT_REMOTEKIS         185  // Remote-KIS
#define PORT_KIS               186  // KIS protocol
#define PORT_ACI               187  // Application Communication Interface
#define PORT_MUMPS             188  // MUMPS
#define PORT_QFT               189  // Queued File Transport
#define PORT_GACP              190  // Gateway Access Control Protocol
#define PORT_PROSPERO          191  // Prospero
#define PORT_OSUNMS            192  // OSU Network Monitoring System
#define PORT_SRMP              193  // Spider Remote Monitoring Protocol
#define PORT_IRC               194  // Internet Relay Chat Protocol
#define PORT_DN6NLMAUD         195  // DNSIX Network Level Module Audit
#define PORT_DN6SMMRED         196  // DSNIX Session Mgt Module Audit Redirector
#define PORT_DLS               197  // Directory Location Service
#define PORT_DLSMON            198  // Directory Location Service Monitor
#define PORT_ATRMTP            201  // AppleTalk Routing Maintenance
#define PORT_ATNBP             202  // AppleTalk Name Binding
#define PORT_AT3               203  // AppleTalk Unused
#define PORT_ATECHO            204  // AppleTalk Echo
#define PORT_AT5               205  // AppleTalk Unused
#define PORT_ATZIS             206  // AppleTalk Zone Information
#define PORT_AT7               207  // AppleTalk Unused
#define PORT_AT8               208  // AppleTalk Unused
#define PORT_SURMEAS           243  // Survey Measurement
#define PORT_LINK              245  // LINK
#define PORT_DSP3270           246  // Display Systems Protocol
#define PORT_LDAP1             389  // LDAP
#define PORT_ISAKMP            500  // ISAKMP
#define PORT_REXEC             512  // Remote Process Execution
#define PORT_RLOGIN            513  // Remote login a la telnet
#define PORT_RSH               514  // Remote command
#define PORT_LPD               515  // Line printer spooler - LPD
#define PORT_RIP               520  // TCP=? / UDP=RIP
#define PORT_TEMPO             526  // Newdate
#define PORT_COURIER           530  // rpc
#define PORT_NETNEWS           532  // READNEWS
#define PORT_UUCPD             540  // UUCPD
#define PORT_KLOGIN            543  //
#define PORT_KSHELL            544  // krcmd
#define PORT_DSF               555  //
#define PORT_REMOTEEFS         556  // RFS server
#define PORT_CHSHELL           562  // chmod
#define PORT_METER             570  // METER
#define PORT_PCSERVER          600  // SUN IPC Server
#define PORT_NQS               607  // NQS
#define PORT_HMMP_INDICATION   612  //     
#define PORT_HMMP_OPERATION    613  //     
#define PORT_MDQS              666  // MDQS
#define PORT_LPD721            721  // LPD Client (lpd client ports 721 - 731)
#define PORT_LPD722            722  // LPD Client (see RFC 1179)
#define PORT_LPD723            723  // LPD Client
#define PORT_LPD724            724  // LPD Client
#define PORT_LPD725            725  // LPD Client
#define PORT_LPD726            726  // LPD Client
#define PORT_LPD727            727  // LPD Client
#define PORT_LPD728            728  // LPD Client
#define PORT_LPD729            729  // LPD Client
#define PORT_LPD730            730  // LPD Client
#define PORT_LPD731            731  // LPD Client
#define PORT_RFILE             750  // RFILE
#define PORT_PUMP              751  // PUMP
#define PORT_QRH               752  // QRH
#define PORT_RRH               753  // RRH
#define PORT_TELL              754  // TELL
#define PORT_NLOGIN            758  // NLOGIN
#define PORT_CON               759  // CON
#define PORT_NS                760  // NS
#define PORT_RXE               761  // RXE
#define PORT_QUOTAD            762  // QUOTAD
#define PORT_CYCLESERV         763  // CYCLESERV
#define PORT_OMSERV            764  // OMSERV
#define PORT_WEBSTER           765  // WEBSTER
#define PORT_PHONEBOOK         767  // PHONE
#define PORT_VID               769  // VID
#define PORT_RTIP              771  // RTIP
#define PORT_CYCLESERV2        772  // CYCLESERV-2
#define PORT_SUBMIT            773  // submit
#define PORT_RPASSWD           774  // RPASSWD
#define PORT_ENTOMB            775  // ENTOMB
#define PORT_WPAGES            776  // WPAGES
#define PORT_WPGS              780  // wpgs
#define PORT_MDBSDAEMON        800  // MDBS DAEMON
#define PORT_DEVICE            801  // DEVICE
#define PORT_MAITRD            997  // MAITRD
#define PORT_BUSBOY            998  // BUSBOY
#define PORT_GARCON            999  // GARCON
#define PORT_NFS              2049  // NFS
#define PORT_LDAP2            3268  // LDAP
#define PORT_PPTP             5678  // PPTP

#ifdef __cplusplus
}
#endif

#endif // NMIPSTRUCTS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmmcs.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1997-1999. All rights reserved.
//
//  MODULE: NMMCS.h
//
//  Header file to the public MCS structures
//=============================================================================

#ifndef NMMCS_H
#define NMMCS_H

#define NMERR_INVALID_LIST_INDEX        2000
#define NMERR_INVALID_MONITOR           2001
#define NMERR_INVALID_MONITOR_DLL       2002
#define NMERR_UNABLE_TO_CREATE_MONITOR  2003
#define NMERR_INVALID_MONITOR_CONFIG    2005
#define NMERR_INVALID_INDEX             2006
#define NMERR_MONITOR_ENABLED           2007
#define NMERR_MONITOR_NOT_RUNNING       2008
#define NMERR_MONITOR_IS_BUSY           2009
#define NMERR_MCS_IS_BUSY               2010
#define NMERR_NO_MONITORS               2011
#define NMERR_ONE_MONITOR_PER_NETCARD   2012
#define NMERR_CONFIGURATION_REQUIRED    2013
#define NMERR_MONITOR_NOT_CONNECTED     2014
#define NMERR_MONITOR_NOT_CONFIGURED    2015
#define NMERR_MONITOR_CONFIG_FAILED     2016
#define NMERR_MONITOR_INIT_FAILED       2017
#define NMERR_MONITOR_FAULTED           2018
#define NMERR_SAVE_ALL_FAILED           2019
#define NMERR_SAVE_MONITOR_FAILED       2029
#define NMERR_MONITOR_CONNECT_FAILED    2021
#define NMERR_MONITOR_START_FAILED      2022
#define NMERR_MONITOR_STOP_FAILED       2023

// Monitor status values returned from call to GetMonitorStatus
#define MONITOR_STATUS_ERROR            -1
#define MONITOR_STATUS_ENABLED          4
#define MONITOR_STATUS_CONFIGURED       5
#define MONITOR_STATUS_RUNNING          6
#define MONITOR_STATUS_RUNNING_FAULTED  9
#define MONITOR_STATUS_DELETED          10

#define MCS_COMMAND_ENABLE              13
#define MCS_COMMAND_DISABLE             14
#define MCS_COMMAND_SET_CONFIG          15
#define MCS_COMMAND_GET_CONFIG          16
#define MCS_COMMAND_START               17
#define MCS_COMMAND_STOP                18
#define MCS_COMMAND_CONNECT             19
#define MCS_COMMAND_RENAME              20
#define MCS_COMMAND_REFRESH_STATUS      21

// Monitor Creation Flags
#define MCS_CREATE_ONE_PER_NETCARD      0x00000001
#define MCS_CREATE_CONFIGS_BY_DEFAULT   0x00000010
#define MCS_CREATE_PMODE_NOT_REQUIRED   0x00000100

#ifdef __cplusplus
extern "C"
{
#endif


typedef __int64         HMONITOR;

// ****************************************************************************
// NPP_INFO
typedef struct 
{
    DWORD               ListIndex;
    char*               ShortName;
    char*               LongName;    
} NPP_INFO;
typedef NPP_INFO* PNPP_INFO;

// ****************************************************************************
// MONITOR_INFO
typedef struct _MONITOR_INFO
{
    // Our opaque pointer
    HMONITOR            MonitorInstance;

    HMONITOR            MonitorClass;
    DWORD               CreateFlags;
    DWORD               Status;
    DWORD               ListIndex;

    // The description of the monitor DLL
    char*               pDescription;
    char*               pScript;
    char*               pConfiguration;

    // The name of the monitor DLL
    char*               pName;

} MONITOR_INFO;
typedef MONITOR_INFO* PMONITOR_INFO;
// ****************************************************************************
typedef struct
{   
    HMONITOR            Monitor;
    DWORD               ListIndex;
    char*               pszMessage;
} MONITOR_MESSAGE;
typedef MONITOR_MESSAGE* PMONITOR_MESSAGE;
// ****************************************************************************
typedef struct
{
    HMONITOR            Monitor;
    DWORD               Command;
    DWORD               FailureCode;
    DWORD               ListIndex;
    DWORD               Status;
} COMMAND_FAILED_EVENT;
typedef COMMAND_FAILED_EVENT* PCOMMAND_FAILED_EVENT;
// ****************************************************************************

typedef struct
{
    HMONITOR            Monitor;
    DWORD               LastCommand;
    DWORD               ListIndex;
    DWORD               Status;
    DWORD               FramesProcessed;
} MONITOR_STATUS_EVENT;
typedef MONITOR_STATUS_EVENT* PMONITOR_STATUS_EVENT;
// ****************************************************************************

typedef struct
{
    OLECHAR*    pwszName;
    FILETIME    FileTime;
    DWORD       pXMCS;
    BOOL        bCurrent;
} MCS_CLIENT;
typedef MCS_CLIENT* PMCS_CLIENT;
// ****************************************************************************

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmsupp.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-1999. All rights reserved.
//
//  MODULE: bhsupp.h
//=============================================================================

#if !defined(_NMSUPP_H)

#define _NMSUPP_H

#pragma pack(1)

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __cplusplus
#ifndef try
#define try                         __try
#endif

#ifndef except
#define except                      __except
#endif
#endif

//=============================================================================
//  Windows version constants.
//=============================================================================

#define WINDOWS_VERSION_UNKNOWN     0
#define WINDOWS_VERSION_WIN32S      1
#define WINDOWS_VERSION_WIN32C      2
#define WINDOWS_VERSION_WIN32       3

//=============================================================================
//  Frame masks.
//=============================================================================

#define FRAME_MASK_ETHERNET         ((BYTE) ~0x01)
#define FRAME_MASK_TOKENRING        ((BYTE) ~0x80)
#define FRAME_MASK_FDDI             ((BYTE) ~0x01)

//=============================================================================
//  ACCESSRIGHTS
//=============================================================================

typedef enum _ACCESSRIGHTS
{
    AccessRightsNoAccess,               //... Access denied, invalid password.
    AccessRightsMonitoring,             //... Monitoring mode only.
    AccessRightsUserAccess,             //... User-level access rights.
    AccessRightsAllAccess               //... All access.
} ACCESSRIGHTS;

typedef ACCESSRIGHTS *PACCESSRIGHTS;

typedef LPVOID HPASSWORD;

#define HANDLE_TYPE_PASSWORD            MAKE_IDENTIFIER('P', 'W', 'D', '$')

//=============================================================================
//  Object heap type.
//=============================================================================

typedef LPVOID HOBJECTHEAP;                 //... Opaque.

//=============================================================================
//  Object cleanup procedure.
//=============================================================================

typedef VOID (WINAPI *OBJECTPROC)(HOBJECTHEAP, LPVOID);

#pragma pack()

//=============================================================================
//  Network Monitor timers.
//=============================================================================

typedef struct _TIMER *HTIMER;

typedef VOID (WINAPI *BHTIMERPROC)(LPVOID);

extern  HTIMER WINAPI BhSetTimer(BHTIMERPROC TimerProc, LPVOID InstData, DWORD TimeOut);

extern  VOID   WINAPI BhKillTimer(HTIMER hTimer);

//=============================================================================
//  Network Monitor driver support.
//=============================================================================

extern LPVOID WINAPI BhAllocSystemMemory(DWORD nBytes);

extern LPVOID WINAPI BhFreeSystemMemory(LPVOID ptr);

extern LPVOID WINAPI BhGetNetworkRequestAddress(DWORD NalRequestType);

//=============================================================================
//  Network Monitor global error API.
//=============================================================================

extern DWORD  WINAPI BhGetLastError(VOID);

extern DWORD  WINAPI BhSetLastError(DWORD Error);

//=============================================================================
//  Object manager function prototypes.
//=============================================================================

extern HOBJECTHEAP WINAPI CreateObjectHeap(DWORD ObjectSize, OBJECTPROC ObjectProc);

extern HOBJECTHEAP WINAPI DestroyObjectHeap(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI AllocObject(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI FreeObject(HOBJECTHEAP hObjectHeap, LPVOID ObjectMemory);

extern DWORD       WINAPI GrowObjectHeap(HOBJECTHEAP hObjectHeap, DWORD nObjects);

extern DWORD       WINAPI GetObjectHeapSize(HOBJECTHEAP hObjectHeap);

extern VOID        WINAPI PurgeObjectHeap(HOBJECTHEAP hObjectHeap);

//=============================================================================
//  Memory functions.
//=============================================================================

extern LPVOID     WINAPI AllocMemory(SIZE_T size);

extern LPVOID     WINAPI ReallocMemory(LPVOID ptr, SIZE_T NewSize);

extern VOID       WINAPI FreeMemory(LPVOID ptr);

extern VOID       WINAPI TestMemory(LPVOID ptr);

extern SIZE_T     WINAPI MemorySize(LPVOID ptr);

extern HANDLE     WINAPI MemoryHandle(LPBYTE ptr);

//=============================================================================
//  Password API's.
//=============================================================================

extern HPASSWORD    WINAPI CreatePassword(LPSTR password);

extern VOID         WINAPI DestroyPassword(HPASSWORD hPassword);

extern ACCESSRIGHTS WINAPI ValidatePassword(HPASSWORD hPassword);

//=============================================================================
//  EXPRESSION API's
//=============================================================================

extern LPEXPRESSION         WINAPI InitializeExpression(LPEXPRESSION Expression);

extern LPPATTERNMATCH       WINAPI InitializePattern(LPPATTERNMATCH Pattern, LPVOID ptr, DWORD offset, DWORD length);

extern LPEXPRESSION         WINAPI AndExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPEXPRESSION         WINAPI OrExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPPATTERNMATCH       WINAPI NegatePattern(LPPATTERNMATCH Pattern);

extern LPADDRESSTABLE       WINAPI AdjustOperatorPrecedence(LPADDRESSTABLE AddressTable);

extern LPADDRESS            WINAPI NormalizeAddress(LPADDRESS Address);

extern LPADDRESSTABLE       WINAPI NormalizeAddressTable(LPADDRESSTABLE AddressTable);

//=============================================================================
//  SERVICE API's
//=============================================================================

extern HANDLE               WINAPI BhOpenService(LPSTR ServiceName);

extern VOID                 WINAPI BhCloseService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStartService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStopService(HANDLE ServiceHandle);

//=============================================================================
//  MISC. API's
//=============================================================================

extern DWORD                WINAPI BhGetWindowsVersion(VOID);

extern BOOL                 WINAPI IsDaytona(VOID);

extern VOID                 _cdecl dprintf(LPSTR format, ...);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nmtcpstructs.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1993-1999. All rights reserved.
//
//  MODULE: nmtcpstructs.h
//
//  Definitions/declarations for parsing TCP frames.
//=============================================================================

#ifndef NMTCPSTRUCTS_H
#define NMTCPSTRUCTS_H

#ifdef __cplusplus
extern "C"
{
#endif

//
// TCP Packet Structure
//

typedef struct _TCP 
{
    WORD  SrcPort;
    WORD  DstPort;
    DWORD SeqNum;
    DWORD AckNum;
    BYTE  DataOff;
    BYTE  Flags;
    WORD  Window;
    WORD  Chksum;
    WORD  UrgPtr;
} TCP;

typedef TCP * LPTCP;
typedef TCP UNALIGNED * ULPTCP;

INLINE DWORD TCP_HdrLen(ULPTCP pTCP)
{
    return (pTCP->DataOff & 0xf0) >> 2;
}

INLINE DWORD TCP_SrcPort(ULPTCP pTCP)
{
    return XCHG(pTCP->SrcPort);
}

INLINE DWORD TCP_DstPort(ULPTCP pTCP)
{
    return XCHG(pTCP->DstPort);
}

//
// TCP Option Opcodes
//

#define TCP_OPTION_ENDOFOPTIONS   0
#define TCP_OPTION_NOP            1
#define TCP_OPTION_MAXSEGSIZE     2
#define TCP_OPTION_WSCALE         3
#define TCP_OPTION_SACK_PERMITTED 4
#define TCP_OPTION_SACK           5
#define TCP_OPTION_TIMESTAMPS     8

//
// TCP Flags
//

#define TCP_FLAG_URGENT     0x20
#define TCP_FLAG_ACK        0x10
#define TCP_FLAG_PUSH       0x08
#define TCP_FLAG_RESET      0x04
#define TCP_FLAG_SYN        0x02
#define TCP_FLAG_FIN        0x01

//
// TCP Field Masks
//

#define TCP_RESERVED_MASK   0x0FC0

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nspapi.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    nspapi.h

Abstract:

    Name Space Provider API prototypes and manifests. See the
    "Windows NT NameSpace Provider Specification" document for
    details.


Environment:

    User Mode -Win32

Notes:

    You must include "basetyps.h" first. Some types should
    use definitions from base files rather than redefine here.
    Unfortunately, so such base file exists.

--*/

#ifndef _NSPAPI_INCLUDED
#define _NSPAPI_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct _BLOB {
    ULONG cbSize ;
#ifdef MIDL_PASS
    [size_is(cbSize)] BYTE *pBlobData;
#else  // MIDL_PASS
    BYTE *pBlobData ;
#endif // MIDL_PASS
} BLOB, *LPBLOB ;
#endif

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif


//
// Service categories
//
#define SERVICE_RESOURCE            (0x00000001)
#define SERVICE_SERVICE             (0x00000002)
#define SERVICE_LOCAL               (0x00000004)

//
// Operation used when calling SetService()
//
#define SERVICE_REGISTER            (0x00000001)
#define SERVICE_DEREGISTER          (0x00000002)
#define SERVICE_FLUSH               (0x00000003)
#define SERVICE_ADD_TYPE            (0x00000004)
#define SERVICE_DELETE_TYPE         (0x00000005)

//
// Flags that affect the operations above
//
#define SERVICE_FLAG_DEFER          (0x00000001)
#define SERVICE_FLAG_HARD           (0x00000002)

//
// Used as input to GetService() for setting the dwProps parameter
//
#define PROP_COMMENT                (0x00000001)
#define PROP_LOCALE                 (0x00000002)
#define PROP_DISPLAY_HINT           (0x00000004)
#define PROP_VERSION                (0x00000008)
#define PROP_START_TIME             (0x00000010)
#define PROP_MACHINE                (0x00000020)
#define PROP_ADDRESSES              (0x00000100)
#define PROP_SD                     (0x00000200)
#define PROP_ALL                    (0x80000000)

//
// Flags that describe attributes of Service Addresses
//

#define SERVICE_ADDRESS_FLAG_RPC_CN (0x00000001)
#define SERVICE_ADDRESS_FLAG_RPC_DG (0x00000002)
#define SERVICE_ADDRESS_FLAG_RPC_NB (0x00000004)

//
// Name Spaces
//

#define NS_DEFAULT                  (0)

#define NS_SAP                      (1)
#define NS_NDS                      (2)
#define NS_PEER_BROWSE              (3)

#define NS_TCPIP_LOCAL              (10)
#define NS_TCPIP_HOSTS              (11)
#define NS_DNS                      (12)
#define NS_NETBT                    (13)
#define NS_WINS                     (14)

#define NS_NBP                      (20)

#define NS_MS                       (30)
#define NS_STDA                     (31)
#define NS_NTDS                     (32)

#define NS_X500                     (40)
#define NS_NIS                      (41)

#define NS_VNS                      (50)

//
// Name space attributes.
//
#define NSTYPE_HIERARCHICAL         (0x00000001)
#define NSTYPE_DYNAMIC              (0x00000002)
#define NSTYPE_ENUMERABLE           (0x00000004)
#define NSTYPE_WORKGROUP            (0x00000008)

//
// Transport attributes.
//
#define XP_CONNECTIONLESS           (0x00000001)
#define XP_GUARANTEED_DELIVERY      (0x00000002)
#define XP_GUARANTEED_ORDER         (0x00000004)
#define XP_MESSAGE_ORIENTED         (0x00000008)
#define XP_PSEUDO_STREAM            (0x00000010)
#define XP_GRACEFUL_CLOSE           (0x00000020)
#define XP_EXPEDITED_DATA           (0x00000040)
#define XP_CONNECT_DATA             (0x00000080)
#define XP_DISCONNECT_DATA          (0x00000100)
#define XP_SUPPORTS_BROADCAST       (0x00000200)
#define XP_SUPPORTS_MULTICAST       (0x00000400)
#define XP_BANDWIDTH_ALLOCATION     (0x00000800)
#define XP_FRAGMENTATION            (0x00001000)
#define XP_ENCRYPTS                 (0x00002000)

//
// Resolution flags for GetAddressByName().
//
#define RES_SOFT_SEARCH             (0x00000001)
#define RES_FIND_MULTIPLE           (0x00000002)
#define RES_SERVICE                 (0x00000004)

//
// Well known value names for Service Types
//

#define SERVICE_TYPE_VALUE_SAPIDA        "SapId"
#define SERVICE_TYPE_VALUE_SAPIDW       L"SapId"

#define SERVICE_TYPE_VALUE_CONNA         "ConnectionOriented"
#define SERVICE_TYPE_VALUE_CONNW        L"ConnectionOriented"

#define SERVICE_TYPE_VALUE_TCPPORTA      "TcpPort"
#define SERVICE_TYPE_VALUE_TCPPORTW     L"TcpPort"

#define SERVICE_TYPE_VALUE_UDPPORTA      "UdpPort"
#define SERVICE_TYPE_VALUE_UDPPORTW     L"UdpPort"

#ifdef UNICODE

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDW
#define SERVICE_TYPE_VALUE_CONN         SERVICE_TYPE_VALUE_CONNW
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTW
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTW

#else // not UNICODE

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDA
#define SERVICE_TYPE_VALUE_CONN         SERVICE_TYPE_VALUE_CONNA
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTA
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTA

#endif


//
// status flags returned by SetService
//
#define SET_SERVICE_PARTIAL_SUCCESS  (0x00000001)

//
// Name Space Information
//
typedef struct _NS_INFOA {
    DWORD dwNameSpace ;
    DWORD dwNameSpaceFlags ;
    LPSTR   lpNameSpace ;
} NS_INFOA,  * PNS_INFOA, FAR * LPNS_INFOA;
//
// Name Space Information
//
typedef struct _NS_INFOW {
    DWORD dwNameSpace ;
    DWORD dwNameSpaceFlags ;
    LPWSTR  lpNameSpace ;
} NS_INFOW,  * PNS_INFOW, FAR * LPNS_INFOW;
#ifdef UNICODE
typedef NS_INFOW NS_INFO;
typedef PNS_INFOW PNS_INFO;
typedef LPNS_INFOW LPNS_INFO;
#else
typedef NS_INFOA NS_INFO;
typedef PNS_INFOA PNS_INFO;
typedef LPNS_INFOA LPNS_INFO;
#endif // UNICODE

//
// Service Type Values. The structures are used to define named Service
// Type specific values. This structure is self relative and has no pointers.
//
typedef struct _SERVICE_TYPE_VALUE {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    DWORD dwValueNameOffset ;
    DWORD dwValueOffset ;
} SERVICE_TYPE_VALUE, *PSERVICE_TYPE_VALUE, FAR *LPSERVICE_TYPE_VALUE ;

//
// An absolute version of above. This structure does contain pointers.
//
typedef struct _SERVICE_TYPE_VALUE_ABSA  {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    LPSTR   lpValueName ;
    PVOID lpValue ;
} SERVICE_TYPE_VALUE_ABSA,
  *PSERVICE_TYPE_VALUE_ABSA,
  FAR *LPSERVICE_TYPE_VALUE_ABSA;
//
// An absolute version of above. This structure does contain pointers.
//
typedef struct _SERVICE_TYPE_VALUE_ABSW  {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    LPWSTR  lpValueName ;
    PVOID lpValue ;
} SERVICE_TYPE_VALUE_ABSW,
  *PSERVICE_TYPE_VALUE_ABSW,
  FAR *LPSERVICE_TYPE_VALUE_ABSW;
#ifdef UNICODE
typedef SERVICE_TYPE_VALUE_ABSW SERVICE_TYPE_VALUE_ABS;
typedef PSERVICE_TYPE_VALUE_ABSW PSERVICE_TYPE_VALUE_ABS;
typedef LPSERVICE_TYPE_VALUE_ABSW LPSERVICE_TYPE_VALUE_ABS;
#else
typedef SERVICE_TYPE_VALUE_ABSA SERVICE_TYPE_VALUE_ABS;
typedef PSERVICE_TYPE_VALUE_ABSA PSERVICE_TYPE_VALUE_ABS;
typedef LPSERVICE_TYPE_VALUE_ABSA LPSERVICE_TYPE_VALUE_ABS;
#endif // UNICODE

//
// Service Type Information. Contains the name of the Service Type and
// and an array of SERVICE_NS_TYPE_VALUE structures. This structure is self
// relative and has no pointers in it.
//
typedef struct _SERVICE_TYPE_INFO {
    DWORD dwTypeNameOffset ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE Values[1] ;
} SERVICE_TYPE_INFO, *PSERVICE_TYPE_INFO, FAR *LPSERVICE_TYPE_INFO ;

typedef struct _SERVICE_TYPE_INFO_ABSA {
    LPSTR   lpTypeName ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE_ABSA Values[1] ;
} SERVICE_TYPE_INFO_ABSA,
  *PSERVICE_TYPE_INFO_ABSA,
  FAR *LPSERVICE_TYPE_INFO_ABSA ;
typedef struct _SERVICE_TYPE_INFO_ABSW {
    LPWSTR  lpTypeName ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE_ABSW Values[1] ;
} SERVICE_TYPE_INFO_ABSW,
  *PSERVICE_TYPE_INFO_ABSW,
  FAR *LPSERVICE_TYPE_INFO_ABSW ;
#ifdef UNICODE
typedef SERVICE_TYPE_INFO_ABSW SERVICE_TYPE_INFO_ABS;
typedef PSERVICE_TYPE_INFO_ABSW PSERVICE_TYPE_INFO_ABS;
typedef LPSERVICE_TYPE_INFO_ABSW LPSERVICE_TYPE_INFO_ABS;
#else
typedef SERVICE_TYPE_INFO_ABSA SERVICE_TYPE_INFO_ABS;
typedef PSERVICE_TYPE_INFO_ABSA PSERVICE_TYPE_INFO_ABS;
typedef LPSERVICE_TYPE_INFO_ABSA LPSERVICE_TYPE_INFO_ABS;
#endif // UNICODE


//
// A Single Address definition.
//
typedef struct _SERVICE_ADDRESS {
    DWORD   dwAddressType ;
    DWORD   dwAddressFlags ;
    DWORD   dwAddressLength ;
    DWORD   dwPrincipalLength ;
#ifdef MIDL_PASS
    [size_is(dwAddressLength)] BYTE *lpAddress;
#else  // MIDL_PASS
    BYTE   *lpAddress ;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [size_is(dwPrincipalLength)] BYTE *lpPrincipal;
#else  // MIDL_PASS
    BYTE   *lpPrincipal ;
#endif // MIDL_PASS
} SERVICE_ADDRESS, *PSERVICE_ADDRESS, *LPSERVICE_ADDRESS;

//
// Addresses used by the service. Contains array of SERVICE_ADDRESS.
//
typedef struct _SERVICE_ADDRESSES {
    DWORD           dwAddressCount ;
#ifdef MIDL_PASS
    [size_is(dwAddressCount)] SERVICE_ADDRESS Addressses[*];
#else  // MIDL_PASS
    SERVICE_ADDRESS Addresses[1] ;
#endif // MIDL_PASS
} SERVICE_ADDRESSES, *PSERVICE_ADDRESSES, *LPSERVICE_ADDRESSES;


//
// Service Information.
//
typedef struct _SERVICE_INFOA {
    LPGUID lpServiceType ;
    LPSTR   lpServiceName ;
    LPSTR   lpComment ;
    LPSTR   lpLocale ;
    DWORD dwDisplayHint ;
    DWORD dwVersion ;
    DWORD dwTime ;
    LPSTR   lpMachineName ;
    LPSERVICE_ADDRESSES lpServiceAddress ;
    BLOB ServiceSpecificInfo ;
} SERVICE_INFOA, *PSERVICE_INFOA, FAR * LPSERVICE_INFOA ;
//
// Service Information.
//
typedef struct _SERVICE_INFOW {
    LPGUID lpServiceType ;
    LPWSTR  lpServiceName ;
    LPWSTR  lpComment ;
    LPWSTR  lpLocale ;
    DWORD dwDisplayHint ;
    DWORD dwVersion ;
    DWORD dwTime ;
    LPWSTR  lpMachineName ;
    LPSERVICE_ADDRESSES lpServiceAddress ;
    BLOB ServiceSpecificInfo ;
} SERVICE_INFOW, *PSERVICE_INFOW, FAR * LPSERVICE_INFOW ;
#ifdef UNICODE
typedef SERVICE_INFOW SERVICE_INFO;
typedef PSERVICE_INFOW PSERVICE_INFO;
typedef LPSERVICE_INFOW LPSERVICE_INFO;
#else
typedef SERVICE_INFOA SERVICE_INFO;
typedef PSERVICE_INFOA PSERVICE_INFO;
typedef LPSERVICE_INFOA LPSERVICE_INFO;
#endif // UNICODE


//
// Name Space & Service Information
//
typedef struct _NS_SERVICE_INFOA {
    DWORD dwNameSpace ;
    SERVICE_INFOA ServiceInfo ;
} NS_SERVICE_INFOA, *PNS_SERVICE_INFOA, FAR * LPNS_SERVICE_INFOA ;
//
// Name Space & Service Information
//
typedef struct _NS_SERVICE_INFOW {
    DWORD dwNameSpace ;
    SERVICE_INFOW ServiceInfo ;
} NS_SERVICE_INFOW, *PNS_SERVICE_INFOW, FAR * LPNS_SERVICE_INFOW ;
#ifdef UNICODE
typedef NS_SERVICE_INFOW NS_SERVICE_INFO;
typedef PNS_SERVICE_INFOW PNS_SERVICE_INFO;
typedef LPNS_SERVICE_INFOW LPNS_SERVICE_INFO;
#else
typedef NS_SERVICE_INFOA NS_SERVICE_INFO;
typedef PNS_SERVICE_INFOA PNS_SERVICE_INFO;
typedef LPNS_SERVICE_INFOA LPNS_SERVICE_INFO;
#endif // UNICODE

#ifndef __CSADDR_DEFINED__
#define __CSADDR_DEFINED__

//
// SockAddr Information
//
typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr ;
    INT iSockaddrLength ;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, FAR * LPSOCKET_ADDRESS ;

//
// CSAddr Information
//
typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO, FAR * LPCSADDR_INFO ;

#endif

//
// Protocol Information
//
typedef struct _PROTOCOL_INFOA {
    DWORD dwServiceFlags ;
    INT iAddressFamily ;
    INT iMaxSockAddr ;
    INT iMinSockAddr ;
    INT iSocketType ;
    INT iProtocol ;
    DWORD dwMessageSize ;
    LPSTR   lpProtocol ;
} PROTOCOL_INFOA, *PPROTOCOL_INFOA, FAR * LPPROTOCOL_INFOA ;
//
// Protocol Information
//
typedef struct _PROTOCOL_INFOW {
    DWORD dwServiceFlags ;
    INT iAddressFamily ;
    INT iMaxSockAddr ;
    INT iMinSockAddr ;
    INT iSocketType ;
    INT iProtocol ;
    DWORD dwMessageSize ;
    LPWSTR  lpProtocol ;
} PROTOCOL_INFOW, *PPROTOCOL_INFOW, FAR * LPPROTOCOL_INFOW ;
#ifdef UNICODE
typedef PROTOCOL_INFOW PROTOCOL_INFO;
typedef PPROTOCOL_INFOW PPROTOCOL_INFO;
typedef LPPROTOCOL_INFOW LPPROTOCOL_INFO;
#else
typedef PROTOCOL_INFOA PROTOCOL_INFO;
typedef PPROTOCOL_INFOA PPROTOCOL_INFO;
typedef LPPROTOCOL_INFOA LPPROTOCOL_INFO;
#endif // UNICODE

//
// NETRESOURCE2 Structure
//
typedef struct _NETRESOURCE2A {
    DWORD dwScope ;
    DWORD dwType ;
    DWORD dwUsage ;
    DWORD dwDisplayType ;
    LPSTR   lpLocalName ;
    LPSTR   lpRemoteName ;
    LPSTR   lpComment ;
    NS_INFO ns_info ;
    GUID ServiceType ;
    DWORD dwProtocols ;
    LPINT lpiProtocols ;
} NETRESOURCE2A, *PNETRESOURCE2A, FAR * LPNETRESOURCE2A ;
//
// NETRESOURCE2 Structure
//
typedef struct _NETRESOURCE2W {
    DWORD dwScope ;
    DWORD dwType ;
    DWORD dwUsage ;
    DWORD dwDisplayType ;
    LPWSTR  lpLocalName ;
    LPWSTR  lpRemoteName ;
    LPWSTR  lpComment ;
    NS_INFO ns_info ;
    GUID ServiceType ;
    DWORD dwProtocols ;
    LPINT lpiProtocols ;
} NETRESOURCE2W, *PNETRESOURCE2W, FAR * LPNETRESOURCE2W ;
#ifdef UNICODE
typedef NETRESOURCE2W NETRESOURCE2;
typedef PNETRESOURCE2W PNETRESOURCE2;
typedef LPNETRESOURCE2W LPNETRESOURCE2;
#else
typedef NETRESOURCE2A NETRESOURCE2;
typedef PNETRESOURCE2A PNETRESOURCE2;
typedef LPNETRESOURCE2A LPNETRESOURCE2;
#endif // UNICODE

typedef  DWORD (* LPFN_NSPAPI) (VOID ) ;

//
// Structures for using the service routines asynchronously.
//
typedef
VOID
(*LPSERVICE_CALLBACK_PROC) (
    IN LPARAM lParam,
    IN HANDLE hAsyncTaskHandle
    );

typedef struct _SERVICE_ASYNC_INFO {
    LPSERVICE_CALLBACK_PROC lpServiceCallbackProc;
    LPARAM lParam;
    HANDLE hAsyncTaskHandle;
} SERVICE_ASYNC_INFO, *PSERVICE_ASYNC_INFO, FAR * LPSERVICE_ASYNC_INFO;

//
// Public NSP API prototypes.
//
INT
APIENTRY
EnumProtocolsA (
    IN     LPINT           lpiProtocols,
    IN OUT LPVOID          lpProtocolBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );
//
// Public NSP API prototypes.
//
INT
APIENTRY
EnumProtocolsW (
    IN     LPINT           lpiProtocols,
    IN OUT LPVOID          lpProtocolBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );
#ifdef UNICODE
#define EnumProtocols  EnumProtocolsW
#else
#define EnumProtocols  EnumProtocolsA
#endif // !UNICODE

INT
APIENTRY
GetAddressByNameA (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpServiceType,
    IN     LPSTR              lpServiceName OPTIONAL,
    IN     LPINT                lpiProtocols OPTIONAL,
    IN     DWORD                dwResolution,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo OPTIONAL,
    IN OUT LPVOID               lpCsaddrBuffer,
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPSTR              lpAliasBuffer OPTIONAL,
    IN OUT LPDWORD              lpdwAliasBufferLength OPTIONAL
    );
INT
APIENTRY
GetAddressByNameW (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpServiceType,
    IN     LPWSTR              lpServiceName OPTIONAL,
    IN     LPINT                lpiProtocols OPTIONAL,
    IN     DWORD                dwResolution,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo OPTIONAL,
    IN OUT LPVOID               lpCsaddrBuffer,
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPWSTR              lpAliasBuffer OPTIONAL,
    IN OUT LPDWORD              lpdwAliasBufferLength OPTIONAL
    );
#ifdef UNICODE
#define GetAddressByName  GetAddressByNameW
#else
#define GetAddressByName  GetAddressByNameA
#endif // !UNICODE

INT
APIENTRY
GetTypeByNameA (
    IN     LPSTR         lpServiceName,
    IN OUT LPGUID          lpServiceType
    );
INT
APIENTRY
GetTypeByNameW (
    IN     LPWSTR         lpServiceName,
    IN OUT LPGUID          lpServiceType
    );
#ifdef UNICODE
#define GetTypeByName  GetTypeByNameW
#else
#define GetTypeByName  GetTypeByNameA
#endif // !UNICODE

INT
APIENTRY
GetNameByTypeA (
    IN     LPGUID          lpServiceType,
    IN OUT LPSTR         lpServiceName,
    IN     DWORD           dwNameLength
    );
INT
APIENTRY
GetNameByTypeW (
    IN     LPGUID          lpServiceType,
    IN OUT LPWSTR         lpServiceName,
    IN     DWORD           dwNameLength
    );
#ifdef UNICODE
#define GetNameByType  GetNameByTypeW
#else
#define GetNameByType  GetNameByTypeA
#endif // !UNICODE

INT
APIENTRY
SetServiceA (
    IN     DWORD                dwNameSpace,
    IN     DWORD                dwOperation,
    IN     DWORD                dwFlags,
    IN     LPSERVICE_INFOA      lpServiceInfo,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    IN OUT LPDWORD              lpdwStatusFlags
    );
INT
APIENTRY
SetServiceW (
    IN     DWORD                dwNameSpace,
    IN     DWORD                dwOperation,
    IN     DWORD                dwFlags,
    IN     LPSERVICE_INFOW      lpServiceInfo,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    IN OUT LPDWORD              lpdwStatusFlags
    );
#ifdef UNICODE
#define SetService  SetServiceW
#else
#define SetService  SetServiceA
#endif // !UNICODE

INT
APIENTRY
GetServiceA (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpGuid,
    IN     LPSTR              lpServiceName,
    IN     DWORD                dwProperties,
    IN OUT LPVOID               lpBuffer,
    IN OUT LPDWORD              lpdwBufferSize,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo
    );
INT
APIENTRY
GetServiceW (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpGuid,
    IN     LPWSTR              lpServiceName,
    IN     DWORD                dwProperties,
    IN OUT LPVOID               lpBuffer,
    IN OUT LPDWORD              lpdwBufferSize,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo
    );
#ifdef UNICODE
#define GetService  GetServiceW
#else
#define GetService  GetServiceA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  // _NSPAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntalpha.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1992-1999  Digital Equipment Corporation

Module Name:

    ntalpha.h

Abstract:

    User-mode visible Alpha specific structures and constants

Author:

    Joe Notarangelo  27-March-1992  (based on ntmips.h by Dave Cutler)

Revision History:

    Kim Peterson     21-May-1997    Add DNZ bit to FPCR and SoftFPCR

    Miche Baker-Harvey 28-Jan-1993  Add 32-bit API for context structure

    Jeff McLeman     22-Jul-1992    Add SystemTime struct

    Jeff McLeman     10-July-1992   Add Stall entries in the PCR

    Steve Jenness    08-July-1992   Add NtCurrentTeb definition.

    John DeRosa      30-June-1992

            Added volatile qualifier to the address arguments of the I/O
            space function prototypes.

            Put back in sections of the PCR, and a typedef, that were deleted.

    Rod Gamache      15-May-1992    Add EISA access routines prototypes

    Thomas Van Baak (tvb) 9-Jul-1992

        Created proper Alpha CONTEXT structure definitions.

--*/

#ifndef _NTALPHA_
#define _NTALPHA_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// begin_ntddk begin_wdm begin_nthal

#if defined(_ALPHA_)

//
// Define system time structure.
//

typedef ULONGLONG KSYSTEM_TIME;
typedef KSYSTEM_TIME *PKSYSTEM_TIME;

#endif

// end_ntddk end_wdm end_nthal

#ifdef _ALPHA_                  // ntddk wdm nthal

//
// Cfront doesn't support the volatile attribute and complains about
// it loudly.  This disables volatile when compiling C++ code, but it
// isn't clear the semantics are correct.  It all comes down to the fact
// that cfront is bogus.
//

#ifdef _CFRONT
#define VOLATILE
#else
#define VOLATILE volatile
#endif

// begin_windbgkd
#ifdef _ALPHA_

//
// Define Alpha specific kernel debugger information.
//
// The following structure contains machine specific data passed to
// the host system kernel debugger in a wait state change message.
//

#define DBGKD_MAXSTREAM 16

typedef struct _DBGKD_CONTROL_REPORT {
    ULONG InstructionCount;
    UCHAR InstructionStream[DBGKD_MAXSTREAM];
} DBGKD_CONTROL_REPORT, *PDBGKD_CONTROL_REPORT;

//
// The following structure contains information that the host system
// kernel debugger wants to set on every continue operation and avoids
// the need to send extra packets of information.
//

typedef ULONG DBGKD_CONTROL_SET, *PDBGKD_CONTROL_SET;

#endif // _ALPHA_
// end_windbgkd

//
// Define breakpoint codes.
//

#define USER_BREAKPOINT 0                   // user breakpoint
#define KERNEL_BREAKPOINT 1                 // kernel breakpoint

#define DEBUG_PRINT_BREAKPOINT 20           // debug print breakpoint
#define DEBUG_PROMPT_BREAKPOINT 21          // debug prompt breakpoint
#define DEBUG_STOP_BREAKPOINT 22            // debug stop breakpoint
#define DEBUG_LOAD_SYMBOLS_BREAKPOINT 23    // load symbols breakpoint
#define DEBUG_UNLOAD_SYMBOLS_BREAKPOINT 24  // unload symbols breakpoint
#define BREAKIN_BREAKPOINT 25               // breakin breakpoint

//
// Define Alpha specific read control space commands for the
// Kernel Debugger.  These definitions are for values that must be
// accessed via defined interfaces (PAL on MP systems).
//

#define DEBUG_CONTROL_SPACE_PCR       1
#define DEBUG_CONTROL_SPACE_THREAD    2
#define DEBUG_CONTROL_SPACE_PRCB      3
#define DEBUG_CONTROL_SPACE_PSR       4
#define DEBUG_CONTROL_SPACE_DPCACTIVE 5
#define DEBUG_CONTROL_SPACE_TEB       6
#define DEBUG_CONTROL_SPACE_IPRSTATE  7
#define DEBUG_CONTROL_SPACE_COUNTERS  8

//
// Define Alpha GENTRAP codes.
//

#define GENTRAP_INTEGER_OVERFLOW            (-1)
#define GENTRAP_INTEGER_DIVIDE_BY_ZERO      (-2)
#define GENTRAP_FLOATING_OVERFLOW           (-3)
#define GENTRAP_FLOATING_DIVIDE_BY_ZERO     (-4)
#define GENTRAP_FLOATING_UNDERFLOW          (-5)
#define GENTRAP_FLOATING_INVALID_OPERAND    (-6)
#define GENTRAP_FLOATING_INEXACT_RESULT     (-7)

//
// Define special fast path event pair client/server system service codes.
//
// N.B. These codes are VERY special. The high bit signifies a fast path
//      event pair service and the low bit signifies what type.
//

#define SET_LOW_WAIT_HIGH -2                // fast path event pair service
#define SET_HIGH_WAIT_LOW -1                // fast path event pair service

// begin_ntddk begin_nthal
//
// Define size of kernel mode stack.
//

#if defined(_AXP64_)

#define KERNEL_STACK_SIZE 0x6000

#else

#define KERNEL_STACK_SIZE 0x4000

#endif

//
// Define size of large kernel mode stack for callbacks.
//

#define KERNEL_LARGE_STACK_SIZE 65536

//
// Define number of pages to initialize in a large kernel stack.
//

#define KERNEL_LARGE_STACK_COMMIT KERNEL_STACK_SIZE

// end_ntddk end_nthal

//
// Define address of data shared between user and kernel mode.
//

#define MM_SHARED_USER_DATA_VA 0x7FFE0000

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)MM_SHARED_USER_DATA_VA)

#if defined(_AXP64_)
//
// Define address of the wow64 reserved compatibility area.
//
#define WOW64_COMPATIBILITY_AREA_ADDRESS  (MM_SHARED_USER_DATA_VA - 0x1000000)

//
// Define address of the system-wide csrss shared section.
//
#define CSR_SYSTEM_SHARED_ADDRESS (WOW64_COMPATIBILITY_AREA_ADDRESS)
#endif

// begin_winnt
//
// Define function to return the current Thread Environment Block
//

#ifdef _ALPHA_                          // winnt
void *_rdteb(void);                     // winnt
#if defined(_M_ALPHA)                   // winnt
#pragma intrinsic(_rdteb)               // winnt
#endif                                  // winnt
#endif                                  // winnt

#if defined(_M_ALPHA)
#define NtCurrentTeb() ((struct _TEB *)_rdteb())
#else
struct _TEB *
NtCurrentTeb(void);
#endif

//
// Define functions to get the address of the current fiber and the
// current fiber data.
//

#ifdef _ALPHA_

#define GetCurrentFiber() (((PNT_TIB)NtCurrentTeb())->FiberData)
#define GetFiberData() (*(PVOID *)(GetCurrentFiber()))

// begin_ntddk begin_nthal
//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_ALPHA              0x00020000

#define CONTEXT_CONTROL         (CONTEXT_ALPHA | 0x00000001L)
#define CONTEXT_FLOATING_POINT  (CONTEXT_ALPHA | 0x00000002L)
#define CONTEXT_INTEGER         (CONTEXT_ALPHA | 0x00000004L)

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER)

#endif

#ifndef _PORTABLE_32BIT_CONTEXT

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to construct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, 4) it is used in the user level thread creation
//  routines, and 5) it is used to to pass thread state to debuggers.
//
//  N.B. Because this record is used as a call frame, it must be EXACTLY
//  a multiple of 16 bytes in length.
//
//  There are two variations of the context structure. This is the real one.
//

typedef struct _CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG FltF0;
    ULONGLONG FltF1;
    ULONGLONG FltF2;
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;
    ULONGLONG FltF10;
    ULONGLONG FltF11;
    ULONGLONG FltF12;
    ULONGLONG FltF13;
    ULONGLONG FltF14;
    ULONGLONG FltF15;
    ULONGLONG FltF16;
    ULONGLONG FltF17;
    ULONGLONG FltF18;
    ULONGLONG FltF19;
    ULONGLONG FltF20;
    ULONGLONG FltF21;
    ULONGLONG FltF22;
    ULONGLONG FltF23;
    ULONGLONG FltF24;
    ULONGLONG FltF25;
    ULONGLONG FltF26;
    ULONGLONG FltF27;
    ULONGLONG FltF28;
    ULONGLONG FltF29;
    ULONGLONG FltF30;
    ULONGLONG FltF31;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, and ra are defined in this section, but are
    //  considered part of the control context rather than part of the integer
    //  context.
    //

    ULONGLONG IntV0;    //  $0: return value register, v0
    ULONGLONG IntT0;    //  $1: temporary registers, t0 - t7
    ULONGLONG IntT1;    //  $2:
    ULONGLONG IntT2;    //  $3:
    ULONGLONG IntT3;    //  $4:
    ULONGLONG IntT4;    //  $5:
    ULONGLONG IntT5;    //  $6:
    ULONGLONG IntT6;    //  $7:
    ULONGLONG IntT7;    //  $8:
    ULONGLONG IntS0;    //  $9: nonvolatile registers, s0 - s5
    ULONGLONG IntS1;    // $10:
    ULONGLONG IntS2;    // $11:
    ULONGLONG IntS3;    // $12:
    ULONGLONG IntS4;    // $13:
    ULONGLONG IntS5;    // $14:
    ULONGLONG IntFp;    // $15: frame pointer register, fp/s6
    ULONGLONG IntA0;    // $16: argument registers, a0 - a5
    ULONGLONG IntA1;    // $17:
    ULONGLONG IntA2;    // $18:
    ULONGLONG IntA3;    // $19:
    ULONGLONG IntA4;    // $20:
    ULONGLONG IntA5;    // $21:
    ULONGLONG IntT8;    // $22: temporary registers, t8 - t11
    ULONGLONG IntT9;    // $23:
    ULONGLONG IntT10;   // $24:
    ULONGLONG IntT11;   // $25:
    ULONGLONG IntRa;    // $26: return address register, ra
    ULONGLONG IntT12;   // $27: temporary register, t12
    ULONGLONG IntAt;    // $28: assembler temp register, at
    ULONGLONG IntGp;    // $29: global pointer register, gp
    ULONGLONG IntSp;    // $30: stack pointer register, sp
    ULONGLONG IntZero;  // $31: zero register, zero

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG Fpcr;     // floating point control register
    ULONGLONG SoftFpcr; // software extension to FPCR

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //
    // N.B. The registers gp, sp, and ra are defined in the integer section,
    //   but are considered part of the control context rather than part of
    //   the integer context.
    //

    ULONGLONG Fir;      // (fault instruction) continuation address
    ULONG Psr;          // processor status

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill[4];      // padding for 16-byte stack frame alignment

} CONTEXT, *PCONTEXT;

#else

#error _PORTABLE_32BIT_CONTEXT no longer supported on Alpha.

#endif // _PORTABLE_32BIT_CONTEXT

// end_ntddk end_nthal

#endif // _ALPHA_

// end_winnt

#define CONTEXT_TO_PROGRAM_COUNTER(Context) ((Context)->Fir)

#define CONTEXT_LENGTH (sizeof(CONTEXT))
#define CONTEXT_ALIGN (sizeof(ULONG))
#define CONTEXT_ROUND (CONTEXT_ALIGN - 1)

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {

    PULONGLONG FloatingContext[1];
    PULONGLONG FltF1;
    // Nonvolatile floating point registers start here.
    PULONGLONG FltF2;
    PULONGLONG FltF3;
    PULONGLONG FltF4;
    PULONGLONG FltF5;
    PULONGLONG FltF6;
    PULONGLONG FltF7;
    PULONGLONG FltF8;
    PULONGLONG FltF9;
    PULONGLONG FltF10;
    PULONGLONG FltF11;
    PULONGLONG FltF12;
    PULONGLONG FltF13;
    PULONGLONG FltF14;
    PULONGLONG FltF15;
    PULONGLONG FltF16;
    PULONGLONG FltF17;
    PULONGLONG FltF18;
    PULONGLONG FltF19;
    PULONGLONG FltF20;
    PULONGLONG FltF21;
    PULONGLONG FltF22;
    PULONGLONG FltF23;
    PULONGLONG FltF24;
    PULONGLONG FltF25;
    PULONGLONG FltF26;
    PULONGLONG FltF27;
    PULONGLONG FltF28;
    PULONGLONG FltF29;
    PULONGLONG FltF30;
    PULONGLONG FltF31;

    PULONGLONG IntegerContext[1];
    PULONGLONG IntT0;
    PULONGLONG IntT1;
    PULONGLONG IntT2;
    PULONGLONG IntT3;
    PULONGLONG IntT4;
    PULONGLONG IntT5;
    PULONGLONG IntT6;
    PULONGLONG IntT7;
    // Nonvolatile integer registers start here.
    PULONGLONG IntS0;
    PULONGLONG IntS1;
    PULONGLONG IntS2;
    PULONGLONG IntS3;
    PULONGLONG IntS4;
    PULONGLONG IntS5;
    PULONGLONG IntFp;
    PULONGLONG IntA0;
    PULONGLONG IntA1;
    PULONGLONG IntA2;
    PULONGLONG IntA3;
    PULONGLONG IntA4;
    PULONGLONG IntA5;
    PULONGLONG IntT8;
    PULONGLONG IntT9;
    PULONGLONG IntT10;
    PULONGLONG IntT11;
    PULONGLONG IntRa;
    PULONGLONG IntT12;
    PULONGLONG IntAt;
    PULONGLONG IntGp;
    PULONGLONG IntSp;
    PULONGLONG IntZero;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

//
// Define Exception Summary Register for arithmetic exceptions.
//

typedef struct _EXC_SUM {

    ULONG SoftwareCompletion : 1;
    ULONG InvalidOperation : 1;
    ULONG DivisionByZero : 1;
    ULONG Overflow : 1;
    ULONG Underflow : 1;
    ULONG InexactResult : 1;
    ULONG IntegerOverflow : 1;
    ULONG Fill : 25;

} EXC_SUM, *PEXC_SUM;

//
// Define hardware Floating Point Control Register.
//

typedef struct _FPCR {

    ULONG LowPart;
    ULONG Fill : 16;
    ULONG DenormalOperandsToZeroEnable : 1;
    ULONG DisableInvalid : 1;
    ULONG DisableDivisionByZero : 1;
    ULONG DisableOverflow : 1;
    ULONG InvalidOperation : 1;
    ULONG DivisionByZero : 1;
    ULONG Overflow : 1;
    ULONG Underflow : 1;
    ULONG InexactResult : 1;
    ULONG IntegerOverflow : 1;
    ULONG DynamicRoundingMode : 2;
    ULONG UnderflowToZeroEnable : 1;
    ULONG DisableUnderflow : 1;
    ULONG DisableInexact : 1;
    ULONG SummaryBit : 1;

} FPCR, *PFPCR;

//
// Define software Floating Point Control and Status Register.
//
// N.B. The five IEEE trap enable bits are in the same position as the bits
//      in the exception summary register. The five IEEE status bits are in
//      the same order and 16 bits left of the IEEE enable bits.
//
// N.B. The ArithmeticTrapIgnore bit will supress all arithmetic traps (and
//      leave unpredictable results in the destination register of floating
//      point instructions that trap) when the /S qualifier is not used.
//
// The Software FPCR defaults to zero.
//

typedef struct _SW_FPCR {

    ULONG ArithmeticTrapIgnore : 1;

    ULONG EnableInvalid : 1;
    ULONG EnableDivisionByZero : 1;
    ULONG EnableOverflow : 1;
    ULONG EnableUnderflow : 1;
    ULONG EnableInexact : 1;
    ULONG FillA : 5;

    ULONG DenormalOperandsEnable : 1;   // DNZ for EV4/EV5
    ULONG DenormalResultEnable : 1;
    ULONG NoSoftwareEmulation : 1;      // tvb debug
    ULONG UnderflowToZeroEnable : 1;    // bit 14 not used
    ULONG ThreadInheritEnable : 1;      // bit 15 not used

    ULONG EmulationOccurred : 1;

    ULONG StatusInvalid : 1;
    ULONG StatusDivisionByZero : 1;
    ULONG StatusOverflow : 1;
    ULONG StatusUnderflow : 1;
    ULONG StatusInexact : 1;
    ULONG FillB : 10;

} SW_FPCR, *PSW_FPCR;

// begin_nthal
//
// Define address space layout as defined by Alpha 32-bit and 43-bit super-page
// memory management.
//

#define KUSEG_BASE 0x0                  // base of user segment

#if defined(_AXP64_)

#define KSEG0_BASE 0xFFFFFFFF80000000UI64 // base of 32-bit superpage physical
#define KSEG2_BASE 0xFFFFFFFFC0000000UI64 // limit of 32-bit superpage physical
#define KSEG43_BASE 0xFFFFFC0000000000UI64 // base of 43-bit superpage physical
#define KSEG43_LIMIT 0xFFFFFE0000000000UI64 // limit of 43-bit superpage physical

#else

#define KSEG0_BASE 0x80000000           // base of cached kernel physical
#define KSEG2_BASE 0xc0000000           // base of cached kernel virtual

#endif

// end_nthal

//
// Define Alpha exception handling structures and function prototypes.
//

//
// Function table entry structure definition.
//
// Exception Mode is in the low bit of ExceptionHandler and the low two bits
// of PrologEndAddress. Entry Type is in the low two bits of HandlerData
// in secondary function entries. Low two bits of BeginAddress and EndAddress
// are reserved for future use. RF_ macros are defined to provide consistent
// access to the fields of RUNTIME_FUNCTION without the low order bits.

typedef struct _RUNTIME_FUNCTION {
    ULONG_PTR BeginAddress;
    ULONG_PTR EndAddress;
    PEXCEPTION_ROUTINE ExceptionHandler;
    PVOID HandlerData;
    ULONG_PTR PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

#define RF_BEGIN_ADDRESS(RF)      ((RF)->BeginAddress & (~3))
#define RF_END_ADDRESS(RF)        ((RF)->EndAddress & (~3))
#define RF_EXCEPTION_HANDLER(RF)  (PEXCEPTION_ROUTINE)((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define RF_ENTRY_TYPE(RF)         (ULONG)((ULONG_PTR)((RF)->HandlerData) & 3)
#define RF_PROLOG_END_ADDRESS(RF) ((RF)->PrologEndAddress & (~3))
#define RF_IS_FIXED_RETURN(RF)    (BOOLEAN)(((ULONG_PTR)((RF)->ExceptionHandler) & 2) >> 1)
#define RF_NULL_CONTEXT_COUNT(RF) (ULONG)((ULONG_PTR)((RF)->EndAddress) & 3)
#define RF_FIXED_RETURN(RF)       ((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define RF_ALT_PROLOG(RF)         ((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define RF_STACK_ADJUST(RF)       (ULONG)((ULONG_PTR)((RF)->ExceptionHandler) & (~3))

// Values for secondary function entry type

#define RF_NOT_CONTIGUOUS    0
#define RF_ALT_ENT_PROLOG    1
#define RF_NULL_CONTEXT      2

// Dynamic function table link entry. List head for this structure
// is returned by RtlGetFunctionTableListHead.

typedef struct _DYNAMIC_FUNCTION_TABLE {
    LIST_ENTRY          Links;
    PRUNTIME_FUNCTION   FunctionTable;
    ULONG               EntryCount;
    LARGE_INTEGER       TimeStamp;
    ULONG_PTR            MinimumAddress;
    ULONG_PTR            MaximumAddress;
    BOOLEAN             Sorted;
} DYNAMIC_FUNCTION_TABLE, *PDYNAMIC_FUNCTION_TABLE;

//
// Scope table structure definition - for acc.
//
// One table entry is created by the acc C compiler for each try-except or
// try-finally scope. Nested scopes are ordered from inner to outer scope.
// Current scope is passively maintained by PC-mapping (function tables).
//

typedef struct _SCOPE_TABLE {
    ULONG Count;
    struct
    {
        ULONG_PTR BeginAddress;
        ULONG_PTR EndAddress;
        ULONG_PTR HandlerAddress;
        ULONG_PTR JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE, *PSCOPE_TABLE;

//
// Scope structure definition - for GEM.
//
// One descriptor is created by the GEM C compiler for each try-except or
// try-finally scope. Nested scopes are linked from inner to outer scope.
// Current scope is actively maintained by a dynamic scope context structure.
//

typedef struct _SEH_BLOCK {
    ULONG_PTR HandlerAddress;
    ULONG_PTR JumpTarget;
    struct _SEH_BLOCK *ParentSeb;
} SEH_BLOCK, *PSEH_BLOCK;

//
// Dynamic SEH context definition for GEM.
//
// For GEM generated C code, dynamic SEH scope for a procedure is maintained
// with a pointer to the current SEB (or NULL when not in any SEH scope). The
// SEB pointer, as well as except handler linkage variables, is contained in
// a structure located at a known offset within the stack frame.
//

typedef struct _SEH_CONTEXT {
    PSEH_BLOCK CurrentSeb;
    ULONG ExceptionCode;
    ULONG_PTR RealFramePointer;
} SEH_CONTEXT, *PSEH_CONTEXT;

//
// Runtime Library function prototypes.
//

VOID
RtlCaptureContext (
    OUT PCONTEXT ContextRecord
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG_PTR ControlPc
    );

PRUNTIME_FUNCTION
RtlLookupDirectFunctionEntry (
    IN ULONG_PTR ControlPc
    );

BOOLEAN
RtlAddFunctionTable (
    IN PRUNTIME_FUNCTION FunctionTable,
    IN ULONG EntryCount
    );

BOOLEAN
RtlDeleteFunctionTable (
    IN PRUNTIME_FUNCTION FunctionTable
    );

PLIST_ENTRY
RtlGetFunctionTableListHead (
    VOID
    );

typedef struct _FRAME_POINTERS {
    ULONG_PTR VirtualFramePointer;
    ULONG_PTR RealFramePointer;
} FRAME_POINTERS, *PFRAME_POINTERS;

ULONG_PTR
RtlVirtualUnwind (
    IN ULONG_PTR ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
    );

//
// Define C structured exception handing function prototypes.
//

typedef struct _DISPATCHER_CONTEXT {
    ULONG_PTR ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;
    PCONTEXT ContextRecord;
} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;

struct _EXCEPTION_POINTERS;

typedef
LONG
(*EXCEPTION_FILTER) (
    struct _EXCEPTION_POINTERS *ExceptionPointers
    );

typedef
VOID
(*TERMINATION_HANDLER) (
    BOOLEAN is_abnormal
    );

// begin_winnt

#ifdef _ALPHA_

VOID
__jump_unwind (
    PVOID VirtualFramePointer,
    PVOID TargetPc
    );

#endif // _ALPHA_

// end_winnt


#endif // _ALPHA_               // ntddk wdm nthal

#ifdef __cplusplus
}
#endif

#endif // _NTALPHA_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntagp.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ntagp.h

Abstract:

    This file defines the external interface for the AGP bus filter driver

Author:

    John Vert (jvert) 10/26/1997

Revision History:

--*/
#ifndef _NTAGP_
#define _NTAGP_

#if _MSC_VER > 1000
#pragma once
#endif

DEFINE_GUID(GUID_AGP_BUS_INTERFACE_STANDARD, 0x2ef74803, 0xd8d3, 0x11d1, 0x9c, 0xaa, 0x00, 0xc0, 0xf0, 0x16, 0x56, 0x36 );
//
// Define AGP Interface version
//
#define AGP_INTERFACE_VERSION 1

//
// Define AGP Capabilities field
//
#define AGP_CAPABILITIES_MAP_PHYSICAL   0x00000001

typedef
NTSTATUS
(*PAGP_BUS_RESERVE_MEMORY)(
    IN PVOID AgpContext,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

typedef
NTSTATUS
(*PAGP_BUS_RELEASE_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle
    );

typedef
NTSTATUS
(*PAGP_BUS_COMMIT_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

typedef
NTSTATUS
(*PAGP_BUS_FREE_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
NTSTATUS
(*PAGP_GET_MAPPED_PAGES)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mld
    );

typedef struct _AGP_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID AgpContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // AGP bus interfaces
    //

    ULONG Capabilities;
    PAGP_BUS_RESERVE_MEMORY ReserveMemory;
    PAGP_BUS_RELEASE_MEMORY ReleaseMemory;
    PAGP_BUS_COMMIT_MEMORY CommitMemory;
    PAGP_BUS_FREE_MEMORY FreeMemory;
    PAGP_GET_MAPPED_PAGES GetMappedPages;
} AGP_BUS_INTERFACE_STANDARD, *PAGP_BUS_INTERFACE_STANDARD;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\npptypes.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1997-1999. All rights reserved.
//
//  MODULE: NPPTypes.h
//
//  The source of everything outsiders need to know about NPP
//=============================================================================

#ifndef __npptypes_h__
#define __npptypes_h__

#include <unknwn.h>


#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

typedef const void * HBLOB;

#pragma pack(1)

//=============================================================================
// DWORD  General constants.
//=============================================================================

#define MAC_TYPE_UNKNOWN                             0     //... not supported
#define MAC_TYPE_ETHERNET                            1     //... ethernet and 802.3
#define MAC_TYPE_TOKENRING                           2     //... tokenring (802.5)
#define MAC_TYPE_FDDI                                3     //... fddi.
                                                     
#define MACHINE_NAME_LENGTH                         16 
#define USER_NAME_LENGTH                            32 
#define ADAPTER_COMMENT_LENGTH                      32 
                                                
#define CONNECTION_FLAGS_WANT_CONVERSATION_STATS    0x00000001


//=============================================================================
//  Handle to a network
//=============================================================================
typedef DWORD HNETWORK;

//=============================================================================
//  Statistics structure.
//=============================================================================

// -----------
// Structure
// -----------
typedef struct _STATISTICS
{
    __int64          TimeElapsed; // in millionths of a second

    //...Buffer statistics
    DWORD           TotalFramesCaptured;
    DWORD           TotalBytesCaptured;

    //...Filtered statistics
    DWORD           TotalFramesFiltered;
    DWORD           TotalBytesFiltered;
    DWORD           TotalMulticastsFiltered;
    DWORD           TotalBroadcastsFiltered;

    //...Overall statistics.
    DWORD           TotalFramesSeen;
    DWORD           TotalBytesSeen;
    DWORD           TotalMulticastsReceived;
    DWORD           TotalBroadcastsReceived;
    DWORD           TotalFramesDropped;
    DWORD           TotalFramesDroppedFromBuffer;
    
    //... Statistics kept by MAC driver.
    DWORD           MacFramesReceived;
    DWORD           MacCRCErrors;
    __int64         MacBytesReceivedEx;
    DWORD           MacFramesDropped_NoBuffers;
    DWORD           MacMulticastsReceived;
    DWORD           MacBroadcastsReceived;
    DWORD           MacFramesDropped_HwError;
} STATISTICS;

typedef STATISTICS *LPSTATISTICS;

#define STATISTICS_SIZE    sizeof(STATISTICS)

//=============================================================================
//  Address structures
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_NAME_SIZE       32 
#define IP_ADDRESS_SIZE     4  
#define MAC_ADDRESS_SIZE    6  

// Q: What is the maximum address size that we could have to copy?
// A: IPX == DWORD + 6 bytes == 10
#define MAX_ADDRESS_SIZE    10 
                                    
#define ADDRESS_TYPE_ETHERNET       0 
#define ADDRESS_TYPE_IP             1 
#define ADDRESS_TYPE_IPX            2 
#define ADDRESS_TYPE_TOKENRING      3 
#define ADDRESS_TYPE_FDDI           4 

#define ADDRESS_TYPE_XNS            5 
#define ADDRESS_TYPE_ANY            6   // NOTE: Special ANY and ANY_GROUP are placeholders, meaning, ignore this type
#define ADDRESS_TYPE_ANY_GROUP      7   
#define ADDRESS_TYPE_FIND_HIGHEST   8   
#define ADDRESS_TYPE_VINES_IP       9   
#define ADDRESS_TYPE_LOCAL_ONLY     10   


#define ADDRESSTYPE_FLAGS_NORMALIZE     0x0001 
#define ADDRESSTYPE_FLAGS_BIT_REVERSE   0x0002 


// -----------
// Structure
// -----------
// Vines IP Address Structure
typedef struct _VINES_IP_ADDRESS
{
    DWORD   NetID;
    WORD    SubnetID;
} VINES_IP_ADDRESS;
typedef VINES_IP_ADDRESS *LPVINES_IP_ADDRESS;
#define VINES_IP_ADDRESS_SIZE sizeof(VINES_IP_ADDRESS)

// IPX Address Structure
typedef struct _IPX_ADDRESS
{
    BYTE    Subnet[4];
    BYTE    Address[6];
} IPX_ADDRESS;
typedef IPX_ADDRESS *LPIPX_ADDRESS;
#define IPX_ADDRESS_SIZE    sizeof(IPX_ADDRESS)

// XNS Address Structure
typedef IPX_ADDRESS XNS_ADDRESS;
typedef IPX_ADDRESS *LPXNS_ADDRESS;

// ETHERNET SOURCE ADDRESS
typedef struct _ETHERNET_SRC_ADDRESS
{
    BYTE    RoutingBit:     1;
    BYTE    LocalBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_SRC_ADDRESS;
typedef ETHERNET_SRC_ADDRESS *LPETHERNET_SRC_ADDRESS;

// ETHERNET DESTINATION ADDRESS
typedef struct _ETHERNET_DST_ADDRESS
{
    BYTE    GroupBit:       1;
    BYTE    AdminBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_DST_ADDRESS;
typedef ETHERNET_DST_ADDRESS *LPETHERNET_DST_ADDRESS;

// FDDI addresses
typedef ETHERNET_SRC_ADDRESS FDDI_SRC_ADDRESS;
typedef ETHERNET_DST_ADDRESS FDDI_DST_ADDRESS;

typedef FDDI_SRC_ADDRESS *LPFDDI_SRC_ADDRESS;
typedef FDDI_DST_ADDRESS *LPFDDI_DST_ADDRESS;

// TOKENRING Source Address
typedef struct _TOKENRING_SRC_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    LocalBit:       1;
    BYTE    RoutingBit:     1;
    BYTE    Byte1;
    BYTE    Byte2:          7;
    BYTE    Functional:     1;
    BYTE    Reserved[3];
} TOKENRING_SRC_ADDRESS;
typedef TOKENRING_SRC_ADDRESS *LPTOKENRING_SRC_ADDRESS;

// TOKENRING Destination Address
typedef struct _TOKENRING_DST_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    AdminBit:       1;
    BYTE    GroupBit:       1;
    BYTE    Reserved[5];
} TOKENRING_DST_ADDRESS;
typedef TOKENRING_DST_ADDRESS *LPTOKENRING_DST_ADDRESS;



// Address Structure
typedef struct _ADDRESS
{
    DWORD                       Type;

    union
    {
        // ADDRESS_TYPE_ETHERNET
        // ADDRESS_TYPE_TOKENRING
        // ADDRESS_TYPE_FDDI
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

        // IP
        BYTE                    IPAddress[IP_ADDRESS_SIZE];

        // raw IPX
        BYTE                    IPXRawAddress[IPX_ADDRESS_SIZE];

        // real IPX
        IPX_ADDRESS             IPXAddress;

        // raw Vines IP
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];

        // real Vines IP
        VINES_IP_ADDRESS        VinesIPAddress;

        // ethernet with bits defined
        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;

        // ethernet with bits defined
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

        // tokenring with bits defined
        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;

        // tokenring with bits defined
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

        // fddi with bits defined
        FDDI_SRC_ADDRESS        FddiSrcAddress;

        // fddi with bits defined
        FDDI_DST_ADDRESS        FddiDstAddress;
    };
    
    WORD                        Flags;
} ADDRESS;
typedef ADDRESS *LPADDRESS;
#define ADDRESS_SIZE   sizeof(ADDRESS)

//=============================================================================
//  Address Pair Structure
//=============================================================================

// -----------
// Constants
// -----------
#define ADDRESS_FLAGS_MATCH_DST         0x0001 //... Match dest. address.
#define ADDRESS_FLAGS_MATCH_SRC         0x0002 //... Match src. address.
#define ADDRESS_FLAGS_EXCLUDE           0x0004 //... Perform logical XOR vs logical OR.
#define ADDRESS_FLAGS_DST_GROUP_ADDR    0x0008 //... Match group bit only.

#define ADDRESS_FLAGS_MATCH_BOTH        0x0003 //... 0x0001 | 0x0002.

// -----------
// Structure
// -----------
typedef struct _ADDRESSPAIR
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS     DstAddress;
    ADDRESS     SrcAddress;
} ADDRESSPAIR;
typedef ADDRESSPAIR *LPADDRESSPAIR;
#define ADDRESSPAIR_SIZE  sizeof(ADDRESSPAIR)


//=============================================================================
//  Address table.
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_ADDRESS_PAIRS   8

// -----------
// Structure
// -----------
typedef struct _ADDRESSTABLE
{
    DWORD           nAddressPairs;
    DWORD           nNonMacAddressPairs;
    ADDRESSPAIR     AddressPair[MAX_ADDRESS_PAIRS];
} ADDRESSTABLE;

typedef ADDRESSTABLE *LPADDRESSTABLE;

#define ADDRESSTABLE_SIZE sizeof(ADDRESSTABLE)

//=============================================================================
//  Network information.
//=============================================================================

// -----------
// Constants
// -----------
#define NETWORKINFO_FLAGS_PMODE_NOT_SUPPORTED           0x00000001 

#define NETWORKINFO_FLAGS_REMOTE_NAL                    0x00000004 
#define NETWORKINFO_FLAGS_REMOTE_NAL_CONNECTED          0x00000008 
#define NETWORKINFO_FLAGS_REMOTE_CARD                   0x00000010 
#define NETWORKINFO_FLAGS_RAS                           0x00000020 

// -----------
// Structure
// -----------
typedef struct _NETWORKINFO
{
    BYTE            PermanentAddr[6];       //... Permanent MAC address
    BYTE            CurrentAddr[6];         //... Current  MAC address
    ADDRESS         OtherAddress;           //... Other address supported (IP, IPX, etc...)
    DWORD           LinkSpeed;              //... Link speed in Mbits.
    DWORD           MacType;                //... Media type.
    DWORD           MaxFrameSize;           //... Max frame size allowed.
    DWORD           Flags;                  //... Informational flags.
    DWORD           TimestampScaleFactor;   //... 1 = 1/1 ms, 10 = 1/10 ms, 100 = 1/100 ms, etc.
    BYTE            NodeName[32];           //... Name of remote workstation.
    BOOL            PModeSupported;         //... Card claims to support P-Mode
    BYTE            Comment[ADAPTER_COMMENT_LENGTH]; // Adapter comment field.
} NETWORKINFO;
typedef NETWORKINFO *LPNETWORKINFO;
#define NETWORKINFO_SIZE    sizeof(NETWORKINFO)
#define MINIMUM_FRAME_SIZE   32


//=============================================================================
//  Pattern structure.
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_PATTERN_LENGTH  16 

// When set this flag will cause those frames which do NOT have the specified pattern
// in the proper stop to be kept.
#define PATTERN_MATCH_FLAGS_NOT                 0x00000001

// This flag was used in previous versions of Network Monitor and its value is therefore 
// reserved for compatability reasons
#define PATTERN_MATCH_FLAGS_RESERVED_1          0x00000002

// When set this flag indicates that the user is not interested in a pattern match within 
// IP or IPX, but in the protocol that follows.  The driver will ensure that the protocol
// given in OffsetBasis is there and then that the port in the fram matches the port given.
// It will then calculate the offset from the beginning of the protocol that follows IP or IPX.
// NOTE: This flag is ignored if it is used with any OffsetBasis other than 
// OFFSET_BASIS_RELATIVE_TO_IPX or OFFSET_BASIS_RELATIVE_TO_IP
#define PATTERN_MATCH_FLAGS_PORT_SPECIFIED      0x00000008


// The offset given is relative to the beginning of the frame. The 
// PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define OFFSET_BASIS_RELATIVE_TO_FRAME                0

// The offset given is relative to the beginning of the Effective Protocol.
// The Effective Protocol is defined as the protocol that follows
// the last protocol that determines Etype/SAP. In normal terms this means 
// that the Effective Protocol will be IP, IPX, XNS, or any of their ilk.
// The PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define OFFSET_BASIS_RELATIVE_TO_EFFECTIVE_PROTOCOL   1

// The offset given is relative to the beginning of IPX. If IPX is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IPX.
#define OFFSET_BASIS_RELATIVE_TO_IPX                  2

// The offset given is relative to the beginning of IP. If IP is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IP.
#define OFFSET_BASIS_RELATIVE_TO_IP                   3

// -----------
// Structure
// -----------
typedef union
{
    BYTE IPPort;
    WORD ByteSwappedIPXPort;
} GENERIC_PORT;


typedef struct _PATTERNMATCH
{
    DWORD        Flags;
    BYTE         OffsetBasis;
    GENERIC_PORT Port;
    WORD         Offset;
    WORD         Length;
    BYTE         PatternToMatch[MAX_PATTERN_LENGTH];//... Pattern to match.
} PATTERNMATCH;
typedef PATTERNMATCH *LPPATTERNMATCH;
#define PATTERNMATCH_SIZE sizeof(PATTERNMATCH)

//=============================================================================
//  Expression structure.
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_PATTERNS    4

// -----------
// Structures
// -----------
typedef struct _ANDEXP
{
    DWORD            nPatternMatches;
    PATTERNMATCH     PatternMatch[MAX_PATTERNS];
} ANDEXP;
typedef ANDEXP *LPANDEXP;
#define ANDEXP_SIZE     sizeof(ANDEXP)

typedef struct _EXPRESSION
{
    DWORD       nAndExps;
    ANDEXP      AndExp[MAX_PATTERNS];
} EXPRESSION;
typedef EXPRESSION *LPEXPRESSION;
#define EXPRESSION_SIZE    sizeof(EXPRESSION)

//
//  Trigger.
//

// -----------
// Constants
// -----------

#define TRIGGER_TYPE_PATTERN_MATCH                       1  
#define TRIGGER_TYPE_BUFFER_CONTENT                      2  
#define TRIGGER_TYPE_PATTERN_MATCH_THEN_BUFFER_CONTENT   3  
#define TRIGGER_TYPE_BUFFER_CONTENT_THEN_PATTERN_MATCH   4  

#define TRIGGER_FLAGS_FRAME_RELATIVE                   0x00000000  
#define TRIGGER_FLAGS_DATA_RELATIVE                    0x00000001  

#define TRIGGER_ACTION_NOTIFY                          0x00  
#define TRIGGER_ACTION_STOP                            0x02  
#define TRIGGER_ACTION_PAUSE                           0x03  

#define TRIGGER_BUFFER_FULL_25_PERCENT         0  
#define TRIGGER_BUFFER_FULL_50_PERCENT         1  
#define TRIGGER_BUFFER_FULL_75_PERCENT         2  
#define TRIGGER_BUFFER_FULL_100_PERCENT        3  

// -----------
// Structure
// -----------
// this is just needed in the driver
#ifndef MAX_PATH
#define MAX_PATH 260
#endif

typedef struct _TRIGGER
{
    BOOL            TriggerActive;          //... Whether trigger is running
    BYTE            TriggerType;            //... Opcode of trigger
    BYTE            TriggerAction;          //... Action to take when trigger occurs.
    DWORD           TriggerFlags;           //... Trigger flags.
    PATTERNMATCH    TriggerPatternMatch;    //... Trigger pattern match.
    DWORD           TriggerBufferSize;      //... Trigger buffer size.
    DWORD           TriggerReserved;        //... Set to all zeros - do not use
    char            TriggerCommandLine[MAX_PATH];
} TRIGGER;
typedef TRIGGER *LPTRIGGER;
#define TRIGGER_SIZE    sizeof(TRIGGER)

//
//  Capture filter.
//

// -----------
// Constants
// -----------
//  Capture filter flags. By default all frames are rejected and
//  NalSetCaptureFilter enables them based on the CAPTUREFILTER flags
//  defined below.

#define CAPTUREFILTER_FLAGS_INCLUDE_ALL_SAPS    0x0001      //... include saps.
#define CAPTUREFILTER_FLAGS_INCLUDE_ALL_ETYPES  0x0002      //... include etypes.
#define CAPTUREFILTER_FLAGS_TRIGGER             0x0004      //... process trigger.
#define CAPTUREFILTER_FLAGS_LOCAL_ONLY          0x0008      //... non-promiscuous.
#define CAPTUREFILTER_FLAGS_DISCARD_COMMENTS    0x0010      //... throw away our internal comment frames
#define CAPTUREFILTER_FLAGS_KEEP_RAW        0x0020      //... Keep SMT and Token Ring MAC frames

//.. The following causes both saps and etypes to be included.
#define CAPTUREFILTER_FLAGS_INCLUDE_ALL         0x0003      //... 0x0001 | 0x0002

#define BUFFER_FULL_25_PERCENT                  0 
#define BUFFER_FULL_50_PERCENT                  1 
#define BUFFER_FULL_75_PERCENT                  2 
#define BUFFER_FULL_100_PERCENT                 3 

// -----------
// Structure
// -----------
typedef struct _CAPTUREFILTER
{
    DWORD           FilterFlags;            //... filter flags,
    LPBYTE          lpSapTable;             //... sap table.
    LPWORD          lpEtypeTable;           //... etype table.
    WORD            nSaps;                  //... sap table length.
    WORD            nEtypes;                //... Etype table length.
    LPADDRESSTABLE  AddressTable;           //... Address table.
    EXPRESSION      FilterExpression;       //... Filter expression.
    TRIGGER         Trigger;                //... Trigger structure.
    DWORD           nFrameBytesToCopy;      //... Number of byte of each frame to copy.
    DWORD           Reserved;
} CAPTUREFILTER;
typedef CAPTUREFILTER *LPCAPTUREFILTER;
#define CAPTUREFILTER_SIZE    sizeof(CAPTUREFILTER)

//=============================================================================
//  Frame type.
//=============================================================================

// -----------
// Structure
// -----------
#pragma warning(disable:4200)
typedef struct _FRAME
{
    __int64  TimeStamp;      //... Relative time in 1/1,000,000th seconds.
    DWORD     FrameLength;  //... MAC frame length.
    DWORD     nBytesAvail;  //... Actual frame length copied.
    BYTE      MacFrame[0];  //... Frame data.
} FRAME;
#pragma warning(default:4200)
typedef FRAME *LPFRAME;
typedef FRAME UNALIGNED *ULPFRAME;
#define FRAME_SIZE sizeof(FRAME)

//=============================================================================
//  Frame descriptor type.
//=============================================================================

// -----------
// Constants
// -----------
#define LOW_PROTOCOL_IPX     OFFSET_BASIS_RELATIVE_TO_IPX  
#define LOW_PROTOCOL_IP      OFFSET_BASIS_RELATIVE_TO_IP   
#define LOW_PROTOCOL_UNKNOWN ((BYTE)-1)
                                                            
// -----------
// Structure
// -----------
typedef struct _FRAME_DESCRIPTOR
{
    LPBYTE  FramePointer;       //... Pointer to frame data
    __int64 TimeStamp;      //... Relative time in 1/1,000,000th seconds.
    DWORD   FrameLength;    //... MAC frame length.
    DWORD   nBytesAvail;    //... Actual frame length copied.
    WORD    Etype;
    BYTE    Sap;       
    BYTE    LowProtocol;           //... Index of Protocol found
    WORD    LowProtocolOffset;     //... Offset to protocol data
    GENERIC_PORT HighPort;         //... Port of high protocol in low protocol
    WORD    HighProtocolOffset;    //... Offset to protocol data
} FRAME_DESCRIPTOR;
typedef FRAME_DESCRIPTOR *LPFRAME_DESCRIPTOR;
#define FRAME_DESCRIPTOR_SIZE sizeof(FRAME_DESCRIPTOR)



//=============================================================================
//  Frame descriptor table.
//=============================================================================
// -----------
// Structure
// -----------
typedef struct _FRAMETABLE
{
    DWORD   FrameTableLength;
    DWORD   StartIndex;
    DWORD   EndIndex;
    DWORD   FrameCount;
    FRAME_DESCRIPTOR    Frames[1];
} FRAMETABLE;

typedef FRAMETABLE *LPFRAMETABLE;


//=============================================================================
//  Station statistics.
//=============================================================================

// -----------
// Constants
// -----------
#define STATIONSTATS_FLAGS_INITIALIZED  0x0001      //... Structure has been initialized.
#define STATIONSTATS_FLAGS_EVENTPOSTED  0x0002      //... Nal has posted an event for this entry.


#define STATIONSTATS_POOL_SIZE      100

// -----------
// Structure
// -----------
typedef struct _STATIONSTATS
{
    DWORD           NextStationStats;       //... Index of next Station
    DWORD           SessionPartnerList;     //... Index to the session table
    DWORD           Flags;
    BYTE            StationAddress[6];
    WORD            Pad;                    //... DWORD alignment.
    DWORD           TotalPacketsReceived;
    DWORD           TotalDirectedPacketsSent;
    DWORD           TotalBroadcastPacketsSent;
    DWORD           TotalMulticastPacketsSent;
    DWORD           TotalBytesReceived;
    DWORD           TotalBytesSent;
} STATIONSTATS;
typedef STATIONSTATS * LPSTATIONSTATS;
#define STATIONSTATS_SIZE sizeof(STATIONSTATS)

//=============================================================================
//  Session statistics.
//=============================================================================


// -----------
// Constants
// -----------
#define SESSION_FLAGS_INITIALIZED  0x0001           //... Structure has been initialized.
#define SESSION_FLAGS_EVENTPOSTED  0x0002           //... Nal has posted an event for this entry.


#define SESSION_POOL_SIZE           100

// -----------
// Structure
// -----------
typedef struct _SESSIONSTATS
{
    DWORD           NextSession;            // Index of next session
    DWORD           StationOwner;           // Index of one station
    DWORD           StationPartner;         // Index of the other station
    DWORD           Flags;
    DWORD           TotalPacketsSent;
} SESSIONSTATS;
typedef SESSIONSTATS * LPSESSIONSTATS;
#define SESSIONSTATS_SIZE  sizeof(SESSIONSTATS)


//=============================================================================
//  Station Query
//=============================================================================

// -----------
// Constants
// -----------
#define STATIONQUERY_FLAGS_LOADED       0x0001      //... Driver is loaded but the kernel is not.
#define STATIONQUERY_FLAGS_RUNNING      0x0002      //... Driver is loaded but not capturing.
#define STATIONQUERY_FLAGS_CAPTURING    0x0004      //... Driver is actively capturing.
#define STATIONQUERY_FLAGS_TRANSMITTING 0x0008      //... Driver is actively transmitting.

// -----------
// Structure
// -----------
#define STATIONQUERY_VERSION_MINOR      0x01
#define STATIONQUERY_VERSION_MAJOR      0x02

typedef struct _OLDSTATIONQUERY
{
    DWORD           Flags;                              //... Current state of Network Monitor.
    BYTE            BCDVerMinor;                        //... Binary coded decimal (minor).
    BYTE            BCDVerMajor;                        //... Binary coded decimal (major).
    DWORD           LicenseNumber;                      //... Software license number.
    BYTE            MachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    BYTE            UserName[USER_NAME_LENGTH];         //... Username name, if any.
    BYTE            Reserved[32];                       //... Reserved.
    BYTE            AdapterAddress[6];                  //... NIC address.
} OLDSTATIONQUERY;
typedef OLDSTATIONQUERY *LPOLDSTATIONQUERY;
#define OLDSTATIONQUERY_SIZE sizeof(OLDSTATIONQUERY)

typedef struct _STATIONQUERY
{
    DWORD           Flags;                              //... Current state of Network Monitor.
    BYTE            BCDVerMinor;                        //... Binary coded decimal (minor).
    BYTE            BCDVerMajor;                        //... Binary coded decimal (major).
    DWORD           LicenseNumber;                      //... Software license number.
    BYTE            MachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    BYTE            UserName[USER_NAME_LENGTH];         //... Username name, if any.
    BYTE            Reserved[32];                       //... Reserved.
    BYTE            AdapterAddress[6];                  //... NIC address.
    WCHAR           WMachineName[MACHINE_NAME_LENGTH];  //... Wide Machine name, if any.
    WCHAR           WUserName[USER_NAME_LENGTH];        //... Wide Username name, if any.
} STATIONQUERY;
typedef STATIONQUERY *LPSTATIONQUERY;
#define STATIONQUERY_SIZE sizeof(STATIONQUERY)

//=============================================================================
//  QUERYTABLE structure.
//=============================================================================

// -----------
// Structure
// -----------
typedef struct _QUERYTABLE
{
                                DWORD           nStationQueries;
                                STATIONQUERY    StationQuery[1];
} QUERYTABLE;
typedef QUERYTABLE *LPQUERYTABLE;
#define QUERYTABLE_SIZE sizeof(QUERYTABLE)


//=============================================================================
//  The LINK structure is used to chain structures together into a list.
//=============================================================================

#ifndef _LINK_
#define _LINK_

typedef struct _LINK *LPLINK;

typedef struct _LINK
{
    LPLINK     PrevLink;                    //... Previous or back pointer.
    LPLINK     NextLink;                    //... Next or forward pointer.
} LINK;

#endif //_LINK_

//=============================================================================
//  Security Request packet
//=============================================================================

typedef struct _SECURITY_PERMISSION_CHECK
{
    UINT        Version;
    DWORD       RandomNumber;
    BYTE        MachineName[MACHINE_NAME_LENGTH];
    BYTE        UserName[USER_NAME_LENGTH];
    UINT        MacType;                            //... Mac type.
    BYTE        PermanentAdapterAddress[MAC_ADDRESS_SIZE];
    BYTE        CurrentAdapterAddress[MAC_ADDRESS_SIZE];
    WCHAR       WMachineName[MACHINE_NAME_LENGTH];
    WCHAR       WUserName[USER_NAME_LENGTH];
} SECURITY_PERMISSION_CHECK;

typedef SECURITY_PERMISSION_CHECK * LPSECURITY_PERMISSION_CHECK;

typedef SECURITY_PERMISSION_CHECK UNALIGNED * ULPSECURITY_PERMISSION_CHECK;

#define SECURITY_PERMISSION_CHECK_SIZE     sizeof(SECURITY_PERMISSION_CHECK)


//=============================================================================
//  Security Response packet
//=============================================================================

#define MAX_SECURITY_BREACH_REASON_SIZE             100
#define MAX_SIGNATURE_LENGTH                        128
#define MAX_USER_NAME_LENGTH                        256

typedef struct _SECURITY_PERMISSION_RESPONSE
{
    UINT        Version;
    DWORD       RandomNumber;
    BYTE        MachineName[MACHINE_NAME_LENGTH];
    BYTE        Address[MAC_ADDRESS_SIZE];
    BYTE        UserName[MAX_USER_NAME_LENGTH];
    BYTE        Reason[MAX_SECURITY_BREACH_REASON_SIZE];
    DWORD       SignatureLength;
    BYTE        Signature[MAX_SIGNATURE_LENGTH];
} SECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE * LPSECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE UNALIGNED * ULPSECURITY_PERMISSION_RESPONSE;

#define SECURITY_PERMISSION_RESPONSE_SIZE     sizeof(SECURITY_PERMISSION_RESPONSE)


//
//  Callback type
//
//
// An UpdateEvent structure is part of an open context (defined below).
// As events occur, the update thread is released. While the thread
// is processing events, we want to be sure we don't lose any events.
// A queue of UpdateEvent structures is used for that purpose.
//

// -----------
// Constants
// -----------
// generic events
#define UPDATE_EVENT_TERMINATE_THREAD               0x00000000
#define UPDATE_EVENT_NETWORK_STATUS                 0x00000001

// rtc events
#define UPDATE_EVENT_RTC_INTERVAL_ELAPSED           0x00000002
#define UPDATE_EVENT_RTC_FRAME_TABLE_FULL           0x00000003
#define UPDATE_EVENT_RTC_BUFFER_FULL                0x00000004

// delayed events
#define UPDATE_EVENT_TRIGGER_BUFFER_CONTENT         0x00000005
#define UPDATE_EVENT_TRIGGER_PATTERN_MATCH          0x00000006
#define UPDATE_EVENT_TRIGGER_BUFFER_PATTERN         0x00000007
#define UPDATE_EVENT_TRIGGER_PATTERN_BUFFER         0x00000008

// transmit events
#define UPDATE_EVENT_TRANSMIT_STATUS                0x00000009

// Security events
#define UPDATE_EVENT_SECURITY_BREACH                0x0000000A

// Remote failure event
#define UPDATE_EVENT_REMOTE_FAILURE                 0x0000000B

// actions
#define UPDATE_ACTION_TERMINATE_THREAD              0x00000000
#define UPDATE_ACTION_NOTIFY                        0x00000001
#define UPDATE_ACTION_STOP_CAPTURE                  0x00000002
#define UPDATE_ACTION_PAUSE_CAPTURE                 0x00000003
#define UPDATE_ACTION_RTC_BUFFER_SWITCH             0x00000004
                                                        
// -----------
// Structures
// -----------
typedef struct _UPDATE_EVENT 
{
    USHORT          Event;          //... Actual event being recorded
    DWORD           Action;         //... What action was taken
    DWORD           Status;         //... Usually network status
    DWORD           Value;          //... Auxilary counter variable
    __int64         TimeStamp;      //... Mark the events( in millionths of a second)
    LPVOID          lpUserContext;  //... User context given by App
    LPVOID          lpReserved;     //... Driver/NAL use
    UINT            FramesDropped;  //... RTF frames dropped in this buffer
    union
    {
        DWORD           Reserved;       //... No data comes back with this switch option.
        LPFRAMETABLE    lpFrameTable;   //... RTF only
        SECURITY_PERMISSION_RESPONSE SecurityResponse;// remote security monitor response
    };

    // this is only filled in on non-security related stops (ie. triggers)
    LPSTATISTICS lpFinalStats;

} UPDATE_EVENT;
typedef UPDATE_EVENT *PUPDATE_EVENT;

// note for c++ users:
// the declaration for this callback should be in the public part of the header file:
// static WINAPI DWORD NetworkCallback( UPDATE_EVENT events);
// and the implementation should be, in the protected section of the cpp file:
// DWORD WINAPI ClassName::NetworkCallback( UPDATE_EVENT events) {};
//typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
 

//=============================================================================
//  NETWORKSTATUS data structure.
//=============================================================================

typedef struct _NETWORKSTATUS
{
    DWORD       State;                                      //... Current state.
    DWORD       Flags;                                      //... Current flags.
//    DWORD       BufferSize;                                 //... Capture buffer size.
} NETWORKSTATUS;

typedef NETWORKSTATUS *LPNETWORKSTATUS;

#define NETWORKSTATUS_SIZE   sizeof(NETWORKSTATUS)

#define NETWORKSTATUS_STATE_VOID                0           //... Nothing state.
#define NETWORKSTATUS_STATE_INIT                1           //... Initial state.
#define NETWORKSTATUS_STATE_CAPTURING           2           //... Capturing state.
#define NETWORKSTATUS_STATE_PAUSED              3           //... Paused state.

#define NETWORKSTATUS_FLAGS_TRIGGER_PENDING     0x0001      //... Trigger pending.

//
//  BONEPACKET structure.
//=============================================================================

typedef struct _BONEPACKET
{
    DWORD       Signature;                  //... 'RTSS'
    BYTE        Command;                    //... packet command field.
    BYTE        Flags;                      //... flags.
    DWORD       Reserved;                   //... reserved.
    WORD        Length;                     //... length of data, if any.
} BONEPACKET;
typedef BONEPACKET *LPBONEPACKET;
#define BONEPACKET_SIZE     sizeof(BONEPACKET)

//=============================================================================
//  BONE alert packet.
//=============================================================================

typedef struct _ALERT
{
    DWORD           AlertCode;                          //... Alert code.
    WCHAR           WMachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    WCHAR           WUserName[USER_NAME_LENGTH];         //... Username name, if any.

    union
    {
        BYTE            Pad[32];                        //... Alert code-specific data.
        DWORD           nFramesToSend;                  //... Transmit alert data.
    };
} ALERT;

typedef ALERT *LPALERT;

#define ALERT_SIZE sizeof(ALERT)

//... Alert codes.

#define ALERT_CODE_BEGIN_TRANSMIT           0

//
//  BONEPACKET signature.
//

#define MAKE_WORD(l, h)         (((WORD) (l)) | (((WORD) (h)) << 8))
#define MAKE_LONG(l, h)         (((DWORD) (l)) | (((DWORD) (h)) << 16L))
#define MAKE_SIG(a, b, c, d)    MAKE_LONG(MAKE_WORD(a, b), MAKE_WORD(c, d))
#define BONE_PACKET_SIGNATURE   MAKE_SIG('R', 'T', 'S', 'S')

//
//  BONEPACKET commands.
//

#define BONE_COMMAND_STATION_QUERY_REQUEST      0
#define BONE_COMMAND_STATION_QUERY_RESPONSE     1
#define BONE_COMMAND_ALERT                      2
#define BONE_COMMAND_PERMISSION_CHECK           3
#define BONE_COMMAND_PERMISSION_RESPONSE        4
#define BONE_COMMAND_SECURITY_MONITOR_EVENT     5


//
//  STATISTICS parameter structure return from OpenNetwork().
//
#define MAX_SESSIONS    100
#define MAX_STATIONS    100

typedef struct _STATISTICSPARAM
{
    DWORD           StatisticsSize;             //... Number of bytes.
    STATISTICS      Statistics;
    DWORD           StatisticsTableEntries;     //... Number of entries.
    STATIONSTATS    StatisticsTable[MAX_STATIONS];
    DWORD           SessionTableEntries;        //... Number of entries.
    SESSIONSTATS    SessionTable[MAX_SESSIONS];
} STATISTICSPARAM;
typedef STATISTICSPARAM *LPSTATISTICSPARAM;
#define STATISTICSPARAM_SIZE  sizeof(STATISTICSPARAM)

//=============================================================================
//  Capture file header.
//=============================================================================

#define CAPTUREFILE_VERSION_MAJOR   2
#define CAPTUREFILE_VERSION_MINOR   0

#define MakeVersion(Major, Minor)   ((DWORD) MAKEWORD(Minor, Major))

#define GetCurrentVersion()         MakeVersion(CAPTUREFILE_VERSION_MAJOR, CAPTUREFILE_VERSION_MINOR)

#define NETMON_1_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('R', 'T', 'S', 'S')
#define NETMON_2_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('G', 'M', 'B', 'U')

typedef struct _CAPTUREFILE_HEADER_VALUES
{
    DWORD      Signature;                //... Unique identifier: 'RTSS'.
    BYTE       BCDVerMinor;              //... Binary coded decimal (minor).
    BYTE       BCDVerMajor;              //... Binary coded decimal (major).
    WORD       MacType;                  //... Topology type.
    SYSTEMTIME TimeStamp;                //... time of capture.
    DWORD      FrameTableOffset;         //... Frame index table.
    DWORD      FrameTableLength;         //... Frame index table size.
    DWORD      UserDataOffset;           //... User data offset.
    DWORD      UserDataLength;           //... User data length.
    DWORD      CommentDataOffset;        //... Comment Data offset
    DWORD      CommentDataLength;        //... Length of comment data.
    DWORD      StatisticsOffset;         //....offset to STATISTICS STRUCTURE
    DWORD      StatisticsLength;         //....length of stats struct
    DWORD      NetworkInfoOffset;        //....offset to network info structure
    DWORD      NetworkInfoLength;        //....length of network info structure
    DWORD      ConversationStatsOffset;  //....offset of conv stats structure
    DWORD      ConversationStatsLength;  //....length of conv stats structure
} CAPTUREFILE_HEADER_VALUES;

typedef CAPTUREFILE_HEADER_VALUES  *LPCAPTUREFILE_HEADER_VALUES;

#define CAPTUREFILE_HEADER_VALUES_SIZE sizeof(CAPTUREFILE_HEADER_VALUES)


//=============================================================================
//  Capture file.
//=============================================================================


typedef struct _CAPTUREFILE_HEADER
{
    union
    {
        CAPTUREFILE_HEADER_VALUES  ActualHeader;
        BYTE  Buffer[CAPTUREFILE_HEADER_VALUES_SIZE];
    };

    BYTE                    Reserved[128 - CAPTUREFILE_HEADER_VALUES_SIZE];
} CAPTUREFILE_HEADER;

typedef CAPTUREFILE_HEADER         *LPCAPTUREFILE_HEADER;

#define CAPTUREFILE_HEADER_SIZE     sizeof(CAPTUREFILE_HEADER)


//=============================================================================
//  Stats Frame definitions.
//=============================================================================


//=============================================================================
//  Stats Frame definitions.
//=============================================================================
typedef struct _EFRAMEHDR
{
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    WORD    Length;
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} EFRAMEHDR;
 
typedef struct _TRFRAMEHDR
{
    BYTE    AC;
    BYTE    FC;
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} TRFRAMEHDR;
 
#define DEFAULT_TR_AC       0x00
#define DEFAULT_TR_FC       0x40
#define DEFAULT_SAP         0xAA
#define DEFAULT_CONTROL     0x03
#define DEFAULT_ETHERTYPE   0x8419
 
typedef struct _FDDIFRAMEHDR
{
    BYTE    FC;
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} FDDIFRAMEHDR;
#define DEFAULT_FDDI_FC      0x10
 
typedef struct _FDDISTATFRAME
{
    __int64     TimeStamp;          //... Relative time in milliseconds.
    DWORD       FrameLength;        //... MAC frame length.
    DWORD       nBytesAvail;        //... Actual frame length copied.
    FDDIFRAMEHDR  FrameHeader;
    BYTE        FrameID[4];         //... $MST
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} FDDISTATFRAME;
 
typedef FDDISTATFRAME *LPFDDISTATFRAME;
typedef FDDISTATFRAME UNALIGNED *ULPFDDISTATFRAME;
 
#define FDDISTATFRAME_SIZE  sizeof(FDDISTATFRAME)
 
typedef struct _TRSTATFRAME
{
    __int64     TimeStamp;          //... Relative time in milliseconds.
    DWORD       FrameLength;        //... MAC frame length.
    DWORD       nBytesAvail;        //... Actual frame length copied.
    TRFRAMEHDR  FrameHeader;
    BYTE        FrameID[4];         //... $MST
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} TRSTATFRAME;
 
typedef TRSTATFRAME *LPTRSTATFRAME;
typedef TRSTATFRAME UNALIGNED *ULPTRSTATFRAME;
 
#define TRSTATFRAME_SIZE  sizeof(TRSTATFRAME)
 
typedef struct _ESTATFRAME
{
    __int64     TimeStamp;          //... Relative time in milliseconds.
    DWORD       FrameLength;        //... MAC frame length.
    DWORD       nBytesAvail;        //... Actual frame length copied.
    EFRAMEHDR   FrameHeader;
    BYTE        FrameID[4];         //... $MST
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} ESTATFRAME;
 
 
#define STATISTICS_VERSION_1_0  0x00000000
#define STATISTICS_VERSION_2_0  0x00000020
 
typedef ESTATFRAME *LPESTATFRAME;
typedef ESTATFRAME UNALIGNED *ULPESTATFRAME;

#define ESTATFRAME_SIZE  sizeof(ESTATFRAME)
 
// this variable could change if any of the above sizes changed
#define MAX_STATSFRAME_SIZE sizeof(TRSTATFRAME)
 
#define STATS_FRAME_TYPE   103

#pragma pack()
#endif //__npptypes_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\nt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    nt.h

Abstract:

    Top level include file for applications and subsystems written to
    the NT API.  Including this file defines all the public types
    and system calls that an application program can use.

    Initial clients of this include file are the NT Shell, along with
    the Windows, OS2 and POSIX subsystems.


Author:

    Steve Wood   [stevewo]   23-Feb-1989

Revision History:

--*/

#ifndef NT_INCLUDED
#define NT_INCLUDED

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4514)
#ifndef __cplusplus
#pragma warning(disable:4116)       // TYPE_ALIGNMENT generates this - move it
                                    // outside the warning push/pop scope.
#endif
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#endif
#if (_MSC_VER > 1020)
#pragma once
#endif
#endif
//
//  Common definitions
//

#define _CTYPE_DISABLE_MACROS

#include <excpt.h>
#include <stdarg.h>
#include <ntdef.h>

#include <ntstatus.h>
#include <ntkeapi.h>

#ifdef _X86_
#include "nti386.h"
#endif // i386

#ifdef _MIPS_
#include "ntmips.h"
#endif // MIPS

#ifdef _ALPHA_
#include "ntalpha.h"
#endif // _ALPHA_

#ifdef _PPC_
#include "ntppc.h"
#endif // _PPC_

#ifdef _MPPC_
#include "ntmppc.h"
#endif // _MPPC_

#ifdef _IA64_
#include "ntia64.h"
#endif // _IA64_

//
//  Each NT Component that exports system call APIs to user programs
//  should have its own include file included here.
//

#include <ntseapi.h>
#include <ntobapi.h>
#include <ntimage.h>
#include <ntldr.h>
#include <ntpsapi.h>
#include <ntxcapi.h>
#include <ntlpcapi.h>
#include <ntioapi.h>
#include <ntiolog.h>
#include <ntpoapi.h>
#include <ntexapi.h>
#include <ntkxapi.h>
#include <ntmmapi.h>
#include <ntregapi.h>
#include <ntelfapi.h>
#include <ntconfig.h>
#include <ntnls.h>
#include <ntpnpapi.h>

#if defined (_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
#endif
#endif

#endif // NT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntapmsdk.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntapmsdk.h

Abstract:

    This header contain nt apm support constants that need to be
    defined in sdk\inc so it can be used by setup, sdktools, etc,

    None of this should appear in the actual sdk or any other public
    distribution of header data.

Author:

    Bryan M. Willman (bryanwi) 16-Sep-1998

Revision History:

--*/

#ifndef _NTAPMSDK_
#define _NTAPMSDK_

#if _MSC_VER > 1000
#pragma once
#endif

//
// APM Registery information stored by ntdetect
//

typedef struct _APM_REGISTRY_INFO {

    //
    // OLD part of the structure, leave this alone
    // so that we can dual boot with NT4.
    //

    UCHAR       ApmRevMajor;
    UCHAR       ApmRevMinor;

    USHORT      ApmInstallFlags;

    //
    // Defines for 16 bit interface connect
    //

    USHORT      Code16BitSegment;
    USHORT      Code16BitOffset;
    USHORT      Data16BitSegment;

    //
    // NEW part of the structure for NT5.
    //

    UCHAR       Signature[3];
    UCHAR       Valid;

    //
    // Detection Log Space
    //

    UCHAR       DetectLog[16];      // see hwapm in halx86

} APM_REGISTRY_INFO, *PAPM_REGISTRY_INFO;

#endif // _NTAPMSDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntconfig.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntconfig.h

Abstract:

    This module contains the definitions associated with the conventions
    used to access the configuration registry.

Author:

    Andre Vachon (andreva) 17-Apr-1992

Revision History:

    28-Apr-1992 JohnRo
        Made changes to be consistent with win32 service controller APIs.
--*/

#ifndef _NTCONFIG_
#define _NTCONFIG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// begin_ntddk begin_wdm begin_nthal
// begin_winnt
//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD                   ( 11 )  // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN     ( 11 )  // 64-bit number (same as REG_QWORD)

// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal
//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;

// end_winnt
// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal

//
// Resource List definitions
//

// begin_ntminiport begin_ntndis

//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
#define CmResourceTypeAssignedResource    8   // BUGBUG--remove
#define CmResourceTypeSubAllocateFrom     9   // BUGBUG--remove
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED

// end_wdm

//
// Define the bit masks for Flags common for all CM_RESOURCE_TYPE
//
// BUGBUG--remove the following 3 flags...
//
#define CM_RESOURCE_COMMON_COMPUTE_LENGTH_FROM_DEPENDENTS   0x8000
#define CM_RESOURCE_COMMON_NOT_REASSIGNED                   0x4000
#define CM_RESOURCE_COMMON_SUBSTRACTIVE                     0x2000

// begin_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
// end_wdm
#define CM_RESOURCE_PORT_FORWARD_FIRST_256_OF_EACH_1024     0x0002  // BUGBUG--remove
// begin_wdm
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040
// end_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeBusNumber
//

#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001  // BUGBUG--remove

//
// Define the bit masks for Flags when type is CmResourceTypeSubAllocateFrom
//

#define CM_RESOURCE_SUBALLOCATEFROM_FIXED_TRANSLATION   0x0001  // BUGBUG--remove
#define CM_RESOURCE_SUBALLOCATEFROM_WIRED_TRANSLATION   0x0002  // BUGBUG--remove

// end_ntminiport end_ntndis

// begin_wdm

//
// This structure defines one type of resource used by a driver.
//
// There can only be *1* DeviceSpecificData block. It must be located at
// the end of all resource descriptors in a full descriptor block.
//

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//
// begin_ntndis

#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // end_wdm
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        // begin_wdm
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // end_wdm
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        // begin_wdm
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// end_wdm
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// begin_wdm
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

// end_ntndis
//
// Define the structures used to interpret configuration data of
// \\Registry\machine\hardware\description tree.
// Basically, these structures are used to interpret component
// sepcific data.
//

//
// Define DEVICE_FLAGS
//

typedef struct _DEVICE_FLAGS {
    ULONG Failed : 1;
    ULONG ReadOnly : 1;
    ULONG Removable : 1;
    ULONG ConsoleIn : 1;
    ULONG ConsoleOut : 1;
    ULONG Input : 1;
    ULONG Output : 1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

//
// Define Component Information structure
//

typedef struct _CM_COMPONENT_INFORMATION {
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal
//
// The following structures are used to interpret x86
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
// (Most of the structures are defined by BIOS.  They are
// not aligned on word (or dword) boundary.
//

//
// Define the Rom Block structure
//

typedef struct _CM_ROM_BLOCK {
    ULONG Address;
    ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;

// begin_ntminiport begin_ntndis

#include "pshpack1.h"

// end_ntminiport end_ntndis

//
// Define INT13 driver parameter block
//

typedef struct _CM_INT13_DRIVE_PARAMETER {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;

// begin_ntminiport begin_ntndis

//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

// end_ntminiport end_ntndis

//
// The following structures are used to interpret mips
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
//

//
// Device data records for adapters.
//

//
// The device data record for the Emulex SCSI controller.
//

typedef struct _CM_SCSI_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

//
// Device data records for controllers.
//

//
// The device data record for the Video controller.
//

typedef struct _CM_VIDEO_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

//
// The device data record for the SONIC network controller.
//

typedef struct _CM_SONIC_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT DataConfigurationRegister;
    UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

//
// The device data record for the serial controller.
//

typedef struct _CM_SERIAL_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

//
// Device data records for peripherals.
//

//
// The device data record for the Monitor peripheral.
//

typedef struct _CM_MONITOR_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT HorizontalScreenSize;
    USHORT VerticalScreenSize;
    USHORT HorizontalResolution;
    USHORT VerticalResolution;
    USHORT HorizontalDisplayTimeLow;
    USHORT HorizontalDisplayTime;
    USHORT HorizontalDisplayTimeHigh;
    USHORT HorizontalBackPorchLow;
    USHORT HorizontalBackPorch;
    USHORT HorizontalBackPorchHigh;
    USHORT HorizontalFrontPorchLow;
    USHORT HorizontalFrontPorch;
    USHORT HorizontalFrontPorchHigh;
    USHORT HorizontalSyncLow;
    USHORT HorizontalSync;
    USHORT HorizontalSyncHigh;
    USHORT VerticalBackPorchLow;
    USHORT VerticalBackPorch;
    USHORT VerticalBackPorchHigh;
    USHORT VerticalFrontPorchLow;
    USHORT VerticalFrontPorch;
    USHORT VerticalFrontPorchHigh;
    USHORT VerticalSyncLow;
    USHORT VerticalSync;
    USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

//
// The device data record for the Floppy peripheral.
//

typedef struct _CM_FLOPPY_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    CHAR Size[8];
    ULONG MaxDensity;
    ULONG MountDensity;
    //
    // New data fields for version >= 2.0
    //
    UCHAR StepRateHeadUnloadTime;
    UCHAR HeadLoadTime;
    UCHAR MotorOffTime;
    UCHAR SectorLengthCode;
    UCHAR SectorPerTrack;
    UCHAR ReadWriteGapLength;
    UCHAR DataTransferLength;
    UCHAR FormatGapLength;
    UCHAR FormatFillCharacter;
    UCHAR HeadSettleTime;
    UCHAR MotorSettleTime;
    UCHAR MaximumTrackValue;
    UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

//
// Declaration of the structure for disk geometries
//

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    ULONG BytesPerSector;
    ULONG NumberOfCylinders;
    ULONG SectorsPerTrack;
    ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;

// end_wdm
//
// Declaration of the structure for the PcCard ISA IRQ map
//

typedef struct _CM_PCCARD_DEVICE_DATA {
    UCHAR Flags;
    UCHAR ErrorCode;
    USHORT Reserved;
    ULONG BusData;
    ULONG DeviceId;
    ULONG LegacyBaseAddress;
    UCHAR IRQMap[16];
} CM_PCCARD_DEVICE_DATA, *PCM_PCCARD_DEVICE_DATA;

// Definitions for Flags

#define PCCARD_MAP_ERROR        0x01
#define PCCARD_DEVICE_PCI       0x10

#define PCCARD_SCAN_DISABLED    0x01
#define PCCARD_MAP_ZERO         0x02
#define PCCARD_NO_TIMER         0x03
#define PCCARD_NO_PIC           0x04
#define PCCARD_NO_LEGACY_BASE   0x05
#define PCCARD_DUP_LEGACY_BASE  0x06
#define PCCARD_NO_CONTROLLERS   0x07

// begin_wdm
// begin_ntminiport

//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

// end_wdm

        struct {
            PASSIGNED_RESOURCE AssignedResource;
        } AssignedResource;     // will be obsoleted

        struct {
            UCHAR Type;                 // use CM_RESOURCE_TYPE
            UCHAR Reserved[3];
            PASSIGNED_RESOURCE AssignedResource;
            PHYSICAL_ADDRESS Transformation;
        } SubAllocateFrom;      // will be obsoleted

// begin_wdm

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

// end_ntminiport


typedef struct _IO_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;

    ULONG Count;
    IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;


typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
    ULONG ListSize;
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    ULONG SlotNumber;
    ULONG Reserved[3];
    ULONG AlternativeLists;
    IO_RESOURCE_LIST  List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

// end_ntddk end_wdm end_nthal

#ifdef __cplusplus
}
#endif

#endif // _NTCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddapmt.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntddapmt.h

Abstract:

    Public interface definitions for APMTEST.SYS, the
        Advanced Power Management UI test device driver.

--*/

#ifndef _NTDDAPMT_
#define _NTDDAPMT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//  APM_IOCTL_GET_VERSION
//      Gets the version of the installed APM device.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM version.

// Returned by APM_IOCTL_GET_VERSION

#define APM_DRIVER_VERSION 0x0400

#define APM_IOCTL_GET_VERSION               0x80FF0004

//  APM_IOCTL_GET_APM_BIOS_VERSION
//      Gets the version of the APM BIOS that APM has detected.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM BIOS version.
#define APM_IOCTL_GET_APM_BIOS_VERSION      0x80FF0008

//  APM_IOCTL_GET_PM_LEVEL
//      Gets the level of power management interaction between APM and the
//      APM BIOS.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the current power management
//                  level.
#define APM_IOCTL_GET_PM_LEVEL              0x80FF000C

//  APM_IOCTL_SET_PM_LEVEL
//      Sets the level of power management interaction between APM and the
//      APM BIOS.
//
//  lpvInBuffer:    Pointer to APM_SET_PM_LEVEL_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_SET_PM_LEVEL              0x80FF0010

#define PMLEVEL_ADVANCED 0x0001

typedef struct _APM_SET_PM_LEVEL_PARAM {
    DWORD PowerManagementLevel;
}   APM_SET_PM_LEVEL_PARAM;

//  APM_IOCTL_SET_DEVICE_STATE
//      Sets the power state (e.g., OFF) of the specified device ID.  Not valid
//      for the system device (all devices power managed by the APM BIOS).
//
//  lpvInBuffer:    Pointer to APM_SET_DEVICE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_SET_DEVICE_STATE          0x80FF0014

//
//  Power device ID type and standard IDs as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_DEVICE_ID;

#define PDI_APM_BIOS                    0x0000
#define PDI_MANAGED_BY_APM_BIOS         0x0001
#define PDI_MANAGED_BY_APM_BIOS_OLD     0xFFFF

//
//  Power state type and standard power states as defined by the APM 1.1
//  specification.
//

#define PSTATE_APM_ENABLED              0x0000
#define PSTATE_STANDBY                  0x0001
#define PSTATE_SUSPEND                  0x0002
#define PSTATE_OFF                      0x0003

typedef struct _APM_SET_DEVICE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    DWORD PowerState;
}   APM_SET_DEVICE_PARAM;

//  APM_IOCTL_RESTORE_DEFAULTS
//      Reinitializes all APM BIOS power-on defaults.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_RESTORE_DEFAULTS          0x80FF001C

//  APM_IOCTL_GET_STATUS
//      Gets the current power status of the specified device ID.
//
//  lpvInBuffer:    Pointer to APM_GET_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_GET_STATUS                0x80FF0020

typedef struct _POWER_STATUS {
    BYTE PS_AC_Line_Status;
    BYTE PS_Battery_Status;
    BYTE PS_Battery_Flag;
    BYTE PS_Battery_Life_Percentage;
    WORD PS_Battery_Life_Time;
}   POWER_STATUS;

typedef POWER_STATUS *LPPOWER_STATUS;

typedef struct _APM_GET_STATUS_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPPOWER_STATUS lpPowerStatus;
}   APM_GET_STATUS_PARAM;

//  APM_IOCTL_GET_STATE
//      Gets the power state (e.g., OFF) of the specified device ID.
//
//  lpvInBuffer:    Pointer to APM_GET_STATE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_GET_STATE                 0x80FF0024

typedef struct _APM_GET_STATE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPDWORD lpPowerState;
}   GET_STATE_PARAM;

//  APM_IOCTL_OEM_APM_FUNCTION
//      Calls an OEM defined APM BIOS extension.
//
//  lpvInBuffer:    Pointer to APM_OEM_APM_FUNCTION_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_OEM_APM_FUNCTION          0x80FF0028

//
//  OEM APM Register Structure used by _APM_OEM_APM_Function.
//

struct _OEM_APM_BYTE_REGS {
    WORD OEMAPM_Reserved1[6];
    BYTE OEMAPM_BL;
    BYTE OEMAPM_BH;
    WORD OEMAPM_Reserved2;
    BYTE OEMAPM_DL;
    BYTE OEMAPM_DH;
    WORD OEMAPM_Reserved3;
    BYTE OEMAPM_CL;
    BYTE OEMAPM_CH;
    WORD OEMAPM_Reserved4;
    BYTE OEMAPM_AL;
    BYTE OEMAPM_AH;
    WORD OEMAPM_Reserved5;
    BYTE OEMAPM_Flags;
    BYTE OEMAPM_Reserved6[3];
};

struct _OEM_APM_WORD_REGS {
    WORD OEMAPM_DI;
    WORD OEMAPM_Reserved7;
    WORD OEMAPM_SI;
    WORD OEMAPM_Reserved8;
    WORD OEMAPM_BP;
    WORD OEMAPM_Reserved9;
    WORD OEMAPM_BX;
    WORD OEMAPM_Reserved10;
    WORD OEMAPM_DX;
    WORD OEMAPM_Reserved11;
    WORD OEMAPM_CX;
    WORD OEMAPM_Reserved12;
    WORD OEMAPM_AX;
    WORD OEMAPM_Reserved13[3];
};
struct _OEM_APM_DWORD_REGS {
    DWORD OEMAPM_EDI;
    DWORD OEMAPM_ESI;
    DWORD OEMAPM_EBP;
    DWORD OEMAPM_EBX;
    DWORD OEMAPM_EDX;
    DWORD OEMAPM_ECX;
    DWORD OEMAPM_EAX;
    DWORD OEMAPM_Reserved14;
};

typedef union _OEM_APM_REGS {
    struct _OEM_APM_BYTE_REGS ByteRegs;
    struct _OEM_APM_WORD_REGS WordRegs;
    struct _OEM_APM_DWORD_REGS DwordRegs;
}   OEM_APM_REGS, *LPOEM_APM_REGS;

typedef struct _APM_OEM_APM_FUNCTION_PARAM {
    LPOEM_APM_REGS lpOemApmRegs;
}   APM_OEM_APM_FUNCTION_PARAM;

//  APM_IOCTL_W32_GET_SYSTEM_STATUS
//      Gets the current power status of the system.  Follows the Win32
//      GetSystemPowerStatus API convention.
//
//  lpvInBuffer:    Pointer to APM_W32_GET_SYSTEM_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define APM_IOCTL_W32_GET_SYSTEM_STATUS     0x80FF0034

// APM_CAPABILITIES, Capabilities flags:
#define CAPS_SUPPORTS_STANDBY   1
#define CAPS_SUPPORTS_SUSPEND   2
#define CAPS_SUPPORTS_HIBERNATE 4

typedef struct APM_CAPABILITIES_S   {
        WORD Capabilities;
        BYTE BatteryCount;
        BYTE Reserved;
}APM_CAPABILITIES, *PAPM_CAPABILITIES;

typedef struct _WIN32_SYSTEM_POWER_STATUS {
    BYTE W32PS_AC_Line_Status;
    BYTE W32PS_Battery_Flag;
    BYTE W32PS_Battery_Life_Percent;
    BYTE W32PS_Reserved1;
    DWORD W32PS_Battery_Life_Time;
    DWORD W32PS_Battery_Full_Life_Time;
}   WIN32_SYSTEM_POWER_STATUS;

typedef WIN32_SYSTEM_POWER_STATUS *LPWIN32_SYSTEM_POWER_STATUS;

typedef struct _APM_W32_GET_SYSTEM_STATUS_PARAM {
    LPWIN32_SYSTEM_POWER_STATUS lpWin32SystemPowerStatus;
}   APM_W32_GET_SYSTEM_STATUS_PARAM;


//  APM_IOCTL_GET_CAPABILITIES
//      Gets the capabilities bitmask of an APM 1.2 machine.
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to APM_CAPABILITIES structure.
#define APM_IOCTL_GET_CAPABILITIES          0x80FF003C

typedef struct _APM_GET_CAPABILITIES_PARAM {
        PAPM_CAPABILITIES   pApmCaps;
}   APM_GET_CAPABILITIES_PARAM;

//  APM_IOCTL_GET_RING_RESUME_STATUS
//      Gets the ring resume status.
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD which will contain the status.
#define APM_IOCTL_GET_RING_RESUME_STATUS    0x80FF0040


//  APM_IOCTL_ENABLE_RING_RESUME
//      Sets the ring resume status.
//  lpvInBuffer:    Points to new status.
//  lpvOutBuffer:   Pointer to APM_CAPABILITIES structure.
#define APM_IOCTL_ENABLE_RING_RESUME          0x80FF0044

#ifdef __cplusplus
}
#endif

#endif  // _NTDDAPMT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntcsrdll.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntcsrdll.h

Abstract:

    This module defines the public interfaces of the Client portion of
    the Client-Server Runtime (Csr) Subsystem.

Author:

    Steve Wood (stevewo) 09-Oct-1990

Revision History:

--*/

#ifndef _NTCSRDLLAPI_
#define _NTCSRDLLAPI_

#if _MSC_VER > 1000
#pragma once
#endif

#include "ntcsrmsg.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef
ULONG
(*PCSR_CALLBACK_ROUTINE)(
    IN OUT PCSR_API_MSG ReplyMsg
    );

typedef struct _CSR_CALLBACK_INFO {
    ULONG ApiNumberBase;
    ULONG MaxApiNumber;
    PCSR_CALLBACK_ROUTINE *CallbackDispatchTable;
} CSR_CALLBACK_INFO, *PCSR_CALLBACK_INFO;

NTSYSAPI
NTSTATUS
NTAPI
CsrClientConnectToServer(
    IN PWSTR ObjectDirectory,
    IN ULONG ServertDllIndex,
    IN PCSR_CALLBACK_INFO CallbackInformation OPTIONAL,
    IN PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
CsrClientCallServer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer OPTIONAL,
    IN CSR_API_NUMBER ApiNumber,
    IN ULONG ArgLength
    );

NTSYSAPI
PCSR_CAPTURE_HEADER
NTAPI
CsrAllocateCaptureBuffer(
    IN ULONG CountMessagePointers,
    IN ULONG Size
    );

NTSYSAPI
VOID
NTAPI
CsrFreeCaptureBuffer(
    IN PCSR_CAPTURE_HEADER CaptureBuffer
    );

NTSYSAPI
ULONG
NTAPI
CsrAllocateMessagePointer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN ULONG Length,
    OUT PVOID *Pointer
    );

NTSYSAPI
VOID
NTAPI
CsrCaptureMessageBuffer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    OUT PVOID *CapturedBuffer
    );

NTSYSAPI
VOID
NTAPI
CsrCaptureMessageString(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PCSTR String,
    IN ULONG Length,
    IN ULONG MaximumLength,
    OUT PSTRING CapturedString
    );

NTSYSAPI
PLARGE_INTEGER
NTAPI
CsrCaptureTimeout(
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Timeout
    );

NTSYSAPI
VOID
NTAPI
CsrProbeForWrite(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    );

NTSYSAPI
VOID
NTAPI
CsrProbeForRead(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    );


NTSYSAPI
NTSTATUS
NTAPI
CsrNewThread(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
CsrIdentifyAlertableThread(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
CsrSetPriorityClass(
    IN HANDLE ProcessHandle,
    IN OUT PULONG PriorityClass
    );

NTSYSAPI
NTSTATUS
NTAPI
CsrStartProfile(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
CsrStopProfile(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
CsrDumpProfile(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
CsrStopDumpProfile(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif // _NTCSRDLLAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntdd8042.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntdd8042.h

Abstract:

    This is the include file that defines all constants and types for hooking
    i8042 devices.

Author:

    Doron J. Holan (doronh) 17-Dec-1997

Revision History:

--*/

#ifndef _NTDD8042_
#define _NTDD8042_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Internal IOCTLs used to find who is in the chain of notification
//
#define IOCTL_INTERNAL_I8042_HOOK_KEYBOARD  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_I8042_HOOK_MOUSE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0FF0, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Internal IOCTLs used to write data to either device
//
// The IOCTL will be completed when the write has been completed.  If the write
// time out, the Cancel Routine of the Irp will be ignored and the Irp will still
// be completed successfully with a status of STATUS_IO_TIMEOUT instead of
// STATUS_SUCCESS
//
#define IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER   CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER      CTL_CODE(FILE_DEVICE_MOUSE, 0x0FF1, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Can only be sent down the keyboard stack
//
#define IOCTL_INTERNAL_I8042_CONTROLLER_WRITE_BUFFER CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF2, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// The keyboard / mouse will send this down the stack so that the upper device
// filter has a device object to synch against.  
//
#define IOCTL_INTERNAL_I8042_KEYBOARD_START_INFORMATION   CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF3, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_I8042_MOUSE_START_INFORMATION      CTL_CODE(FILE_DEVICE_MOUSE, 0x0FF3, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Valid bits for the PowerCapabilities REG_DWORD that can be put in the devnode
// indicating the presence of their respecitve power keys on the device
//
#define I8042_POWER_SYS_BUTTON           0x0001
#define I8042_SLEEP_SYS_BUTTON           0x0002
#define I8042_WAKE_SYS_BUTTON            0x0004
#define I8042_SYS_BUTTONS  (I8042_POWER_SYS_BUTTON | \
                            I8042_SLEEP_SYS_BUTTON | \
                            I8042_WAKE_SYS_BUTTON) 

//
// Synchronous reads and writes during kb initialization
//
#if 0
typedef enum _I8042_PORT_TYPE {
    PortTypeData = 0,
    PortTypeCommand
} I8042_PORT_TYPE;
#endif

typedef
NTSTATUS
(*PI8042_SYNCH_READ_PORT) (
    IN PVOID    Context,
    PUCHAR      Value,
    BOOLEAN     WaitForACK
    );

/*++
Routine Description:

    This routine sends a command or data byte to the keyboard
    in polling mode.  It waits for acknowledgment and resends
    the command/data if WaitForACK is true.

Arguments:

    Context - Function specific context

    PortType - If PortTypeCommand, send the byte to the command register,
        otherwise send it to the data register.

    WaitForACK - If true, wait for an ACK back from the hardware.

    AckDeviceType - Indicates which device we expect to get the ACK back
        from.

    Value - The byte to send to the hardware.

Return Value:

    STATUS_IO_TIMEOUT - The hardware was not ready for input or did not
    respond.

    STATUS_SUCCESS - The byte was successfully sent to the hardware.
  --*/
typedef
NTSTATUS
(*PI8042_SYNCH_WRITE_PORT) (
    IN PVOID    Context,
    UCHAR       Value,
    BOOLEAN     WaitForACK
    );

//
// These functions (PI8042_ISR_WRITE_PORT, PI8042_QUEUE_PACKET) are only valid
// when called with the context of the ISR hook
//
typedef
VOID
(*PI8042_ISR_WRITE_PORT) (
    IN PVOID        Context,
    IN UCHAR        Value
    );

//
// Call this function when an input packet has been fully formed and is ready to
// be queued to the class driver above of us in the stack
//
typedef
VOID
(*PI8042_QUEUE_PACKET) (
    IN PVOID        Context
    );

//
// Current state of writing to a device
//
typedef enum _TRANSMIT_STATE {
    Idle = 0,
    SendingBytes
} TRANSMIT_STATE;

//
// Current state of writing to the device.  If State != Idle, then a write is in
// progress
//
typedef struct _OUTPUT_PACKET {
    PUCHAR         Bytes;
    ULONG          CurrentByte;
    ULONG          ByteCount;
    TRANSMIT_STATE State;
} OUTPUT_PACKET, *POUTPUT_PACKET;

typedef enum _MOUSE_STATE {
    MouseIdle,              // expecting byte 1
    XMovement,              // expecting byte 2
    YMovement,              // expecting byte 3
    ZMovement,              // expecting byte 4 (if a wheel mouse)
    MouseExpectingACK,      // expecting ACK from Enable Mouse cmd
    MouseResetting          // reset substate
} MOUSE_STATE, *PMOUSE_STATE;

/*--
Normal reset process

Step                                    Transition into
Send Reset to mouse                     ExpectingReset (ie, 0xAA)
Got reset                               ExpectingResetId
Got reset id, send get device id        ExpectingGetDeviceIdACK
Got get dev id ack,                     ExpectingGetDeviceIdValue
Got dev id                              ExpectingSetResolutionACK
Got ACK for set res                     ExpectingSetResolutionValueAck
Got ACK for value                       ExpectingSetScaling1to1ACK
Got ACK for set scaling                 ExpectingSetScaling1to1ACK2
Got ACK for set scaling                 ExpectingSetScaling1to1ACK3

                                        EnableWheelDetection (via registry) ==
                                        0 send set sampling rate,
                                            ExpectingSetSamplingRateDefaultACK
                                        1 StartPnPIdDetection
                                        2 EnableWheel
StartPnPIdDetection, send series        ExpectingPnpIdByte1 after setting complete
 of set sampling rate commands
ExpectingPnpIdByte7                     compare pnp id to list, if valid,
                                        EnableWheel, else set def sampling rate
EnableWheel, send series of             send get device id after done,
 set sampling rate commands              ExpectingSetSamplingRateDefaultACK
got set sampling ack                    send sampling value
got sampling value ack                  mouse idle
 ++*/
typedef enum _MOUSE_RESET_SUBSTATE {
    ExpectingReset = 0,
    ExpectingResetId,                           /*  1 */
    ExpectingGetDeviceIdACK,                    /*  2 */
    ExpectingGetDeviceIdValue,                  /*  3 */

    ExpectingSetResolutionDefaultACK,           /*  4 */
    ExpectingSetResolutionDefaultValueACK,      /*  5 */

    ExpectingSetResolutionACK,                  /*  6 */
    ExpectingSetResolutionValueACK,             /*  7 */
    ExpectingSetScaling1to1ACK,                 /*  8 */
    ExpectingSetScaling1to1ACK2,                /*  9 */
    ExpectingSetScaling1to1ACK3,                /* 10 */
    ExpectingReadMouseStatusACK,                /* 11 */
    ExpectingReadMouseStatusByte1,              /* 12 */
    ExpectingReadMouseStatusByte2,              /* 13 */
    ExpectingReadMouseStatusByte3,              /* 14 */

    StartPnPIdDetection,                        /* 15 */

    ExpectingLoopSetSamplingRateACK,            /* 16 */
    ExpectingLoopSetSamplingRateValueACK,       /* 17 */

    ExpectingPnpIdByte1,                        /* 18 */
    ExpectingPnpIdByte2,                        /* 19 */
    ExpectingPnpIdByte3,                        /* 20 */
    ExpectingPnpIdByte4,                        /* 21 */
    ExpectingPnpIdByte5,                        /* 22 */
    ExpectingPnpIdByte6,                        /* 23 */
    ExpectingPnpIdByte7,                        /* 24 */

    EnableWheel,                                /* 25 */
    Enable5Buttons,                             /* 26 */

    ExpectingGetDeviceId2ACK,                   /* 27 */
    ExpectingGetDeviceId2Value,                 /* 28 */

    ExpectingSetSamplingRateACK,                /* 29 */
    ExpectingSetSamplingRateValueACK,           /* 30 */

    ExpectingEnableACK,                         /* 31 */

    ExpectingFinalResolutionACK,                /* 32 */
    ExpectingFinalResolutionValueACK,           /* 33 */

    CustomHookStateMinimum = 100,
    CustomHookStateMaximum = 999,

    I8042ReservedMinimum = 1000

} MOUSE_RESET_SUBSTATE, *PMOUSE_RESET_SUBSTATE;

/*--
IsrContext      -- user provided context
CurrentInput    -- current packet to being assembled
StatusByte      -- byte reported by the command port
Byte            -- byte reported by the mouse (ie, the data port)
MouseState      -- current state of the i8042prt ISR
ResetSubState   -- current reset sub state, only valid when
                   MouseState == MouseResetting (otherwise null)
ContinueProcessing -- if TRUE, the i8042prt ISR will continue executing after
                      calling the hook
  ++*/
typedef
BOOLEAN
(*PI8042_MOUSE_ISR) (
    PVOID                   IsrContext,
    PMOUSE_INPUT_DATA       CurrentInput,
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  Byte,
    PBOOLEAN                ContinueProcessing,
    PMOUSE_STATE            MouseState,
    PMOUSE_RESET_SUBSTATE   ResetSubState
);

typedef struct _INTERNAL_I8042_HOOK_MOUSE {

    //
    // Context variable for IsrRoutine, CancelRoutine
    //
    OUT PVOID Context;

    //
    // Routine to call when a byte is received via the interrupt
    //
    OUT PI8042_MOUSE_ISR IsrRoutine;

    //
    // Write function, will automatically write to the command port saying the
    // next byte is directed towards the auxilliary device.
    //
    // NB:  May only called within the context of the IsrRoutine provided above
    //      The mouse's response to the write will passed to the IsrRoutine when
    //      it is received (ie, if 0xF4 (enable) was written using this function,
    //      an 0xFA (ACK) will be passed to IsrRoutine if the enable was
    //      successful)
    //
    IN PI8042_ISR_WRITE_PORT IsrWritePort;

    //
    // Queue the current packet (ie the one passed into the isr callback hook)
    // to be reported to the class driver
    //
    IN PI8042_QUEUE_PACKET QueueMousePacket;

    //
    // Context for IsrWritePort, QueueMousePacket
    //
    IN PVOID CallContext;

} INTERNAL_I8042_HOOK_MOUSE, *PINTERNAL_I8042_HOOK_MOUSE;

//
// Define the keyboard scan code input states.
//
typedef enum _KEYBOARD_SCAN_STATE {
    Normal,
    GotE0,
    GotE1
} KEYBOARD_SCAN_STATE, *PKEYBOARD_SCAN_STATE;

typedef
NTSTATUS
(*PI8042_KEYBOARD_INITIALIZATION_ROUTINE) (
    IN PVOID                           InitializationContext,
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    );

typedef
BOOLEAN
(*PI8042_KEYBOARD_ISR) (
    PVOID                   IsrContext,
    PKEYBOARD_INPUT_DATA    CurrentInput,
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  Byte,
    PBOOLEAN                ContinueProcessing,
    PKEYBOARD_SCAN_STATE    ScanState
    );

typedef struct _INTERNAL_I8042_HOOK_KEYBOARD {

    //
    // Context variable for all callback routines
    //
    OUT PVOID Context;

    //
    // Routine to call after the mouse is reset
    //
    OUT PI8042_KEYBOARD_INITIALIZATION_ROUTINE InitializationRoutine;

    //
    // Routine to call when a byte is received via the interrupt
    //
    OUT PI8042_KEYBOARD_ISR IsrRoutine;

    //
    // Write function
    //
    IN PI8042_ISR_WRITE_PORT IsrWritePort;

    //
    // Queue the current packet (ie the one passed into the isr callback hook)
    // to be reported to the class driver
    //
    IN PI8042_QUEUE_PACKET QueueKeyboardPacket;

    //
    // Context for IsrWritePort, QueueKeyboardPacket
    //
    IN PVOID CallContext;

} INTERNAL_I8042_HOOK_KEYBOARD, *PINTERNAL_I8042_HOOK_KEYBOARD;

typedef struct _INTERNAL_I8042_START_INFORMATION {
    //
    // Size of this structure
    //
    ULONG Size;

    //
    // Interrupt object for the device.  Should only be used for calls to 
    // KeSynchronizeExecution
    //
    PKINTERRUPT InterruptObject;
    
    //
    // Future use
    //
    ULONG Reserved[8];

} INTERNAL_I8042_START_INFORMATION, *PINTERNAL_I8042_START_INFORMATION;

#ifdef __cplusplus
}
#endif

#endif // _NTDD8042_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntcsrmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntcsrmsg.h

Abstract:

    This module defines the public message format shared by the client and
    server sides of the Client-Server Runtime (Csr) Subsystem.

Author:

    Steve Wood (stevewo) 09-Oct-1990

Revision History:

--*/

#ifndef _NTCSRMSG_
#define _NTCSRMSG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define CSR_API_PORT_NAME L"ApiPort"

//
// This structure is filled in by the client prior to connecting to the CSR
// server.  The CSR server will fill in the OUT fields if prior to accepting
// the connection.
//

typedef struct _CSR_API_CONNECTINFO {
    IN ULONG ExpectedVersion;
    OUT ULONG CurrentVersion;
    OUT HANDLE ObjectDirectory;
    OUT PVOID SharedSectionBase;
    OUT PVOID SharedStaticServerData;
    OUT PVOID SharedSectionHeap;
    OUT ULONG DebugFlags;
    OUT ULONG SizeOfPebData;
    OUT ULONG SizeOfTebData;
    OUT ULONG NumberOfServerDllNames;
} CSR_API_CONNECTINFO, *PCSR_API_CONNECTINFO;

#define CSR_VERSION 0x10000

//
// Message format for messages sent from the client to the server
//

typedef struct _CSR_CLIENTCONNECT_MSG {
    IN ULONG ServerDllIndex;
    IN OUT PVOID ConnectionInformation;
    IN OUT ULONG ConnectionInformationLength;
} CSR_CLIENTCONNECT_MSG, *PCSR_CLIENTCONNECT_MSG;

typedef struct _CSR_THREADCONNECT_MSG {
    HANDLE SectionHandle;
    HANDLE EventPairHandle;
    OUT PCHAR MessageStack;
    OUT ULONG MessageStackSize;
    OUT ULONG RemoteViewDelta;
} CSR_THREADCONNECT_MSG, *PCSR_THREADCONNECT_MSG;

#define CSR_PROFILE_START       0x00000001
#define CSR_PROFILE_STOP        0x00000002
#define CSR_PROFILE_DUMP        0x00000003
#define CSR_PROFILE_STOPDUMP    0x00000004

typedef struct _CSR_PROFILE_CONTROL_MSG {
    IN ULONG ProfileControlFlag;
} CSR_PROFILE_CONTROL_MSG, *PCSR_PROFILE_CONTROL_MSG;

typedef struct _CSR_IDENTIFY_ALERTABLE_MSG {
    IN CLIENT_ID ClientId;
} CSR_IDENTIFY_ALERTABLE_MSG, *PCSR_IDENTIFY_ALERTABLE_MSG;

#define CSR_NORMAL_PRIORITY_CLASS   0x00000010
#define CSR_IDLE_PRIORITY_CLASS     0x00000020
#define CSR_HIGH_PRIORITY_CLASS     0x00000040
#define CSR_REALTIME_PRIORITY_CLASS 0x00000080

typedef struct _CSR_SETPRIORITY_CLASS_MSG {
    IN HANDLE ProcessHandle;
    IN ULONG PriorityClass;
} CSR_SETPRIORITY_CLASS_MSG, *PCSR_SETPRIORITY_CLASS_MSG;

typedef struct _CSR_CAPTURE_HEADER {
    ULONG Length;
    struct _CSR_CAPTURE_HEADER *RelatedCaptureBuffer;
    ULONG CountMessagePointers;
    PCHAR FreeSpace;
    ULONG_PTR MessagePointerOffsets[1]; // Offsets within CSR_API_MSG of pointers
} CSR_CAPTURE_HEADER, *PCSR_CAPTURE_HEADER;

typedef ULONG CSR_API_NUMBER;

typedef struct _CSR_API_MSG {
    PORT_MESSAGE h;
    union {
        CSR_API_CONNECTINFO ConnectionRequest;
        struct {
            PCSR_CAPTURE_HEADER CaptureBuffer;
            CSR_API_NUMBER ApiNumber;
            ULONG ReturnValue;
            ULONG Reserved;
            union {
                CSR_CLIENTCONNECT_MSG ClientConnect;
                CSR_THREADCONNECT_MSG ThreadConnect;
                CSR_PROFILE_CONTROL_MSG ProfileControl;
                CSR_IDENTIFY_ALERTABLE_MSG IndentifyAlertable;
                CSR_SETPRIORITY_CLASS_MSG PriorityClass;
                ULONG_PTR ApiMessageData[32];
            } u;
        };
    };
} CSR_API_MSG, *PCSR_API_MSG;

#define WINSS_OBJECT_DIRECTORY_NAME     L"\\Windows"

#define CSRSRV_SERVERDLL_INDEX          0
#define CSRSRV_FIRST_API_NUMBER         0

#define BASESRV_SERVERDLL_INDEX         1
#define BASESRV_FIRST_API_NUMBER        0

#define CONSRV_SERVERDLL_INDEX          2
#define CONSRV_FIRST_API_NUMBER         512

#define USERSRV_SERVERDLL_INDEX         3
#define USERSRV_FIRST_API_NUMBER        1024

#define CSR_MAKE_API_NUMBER( DllIndex, ApiIndex ) \
    (CSR_API_NUMBER)(((DllIndex) << 16) | (ApiIndex))

#define CSR_APINUMBER_TO_SERVERDLLINDEX( ApiNumber ) \
    ((ULONG)((ULONG)(ApiNumber) >> 16))

#define CSR_APINUMBER_TO_APITABLEINDEX( ApiNumber ) \
    ((ULONG)((USHORT)(ApiNumber)))

#ifdef __cplusplus
}
#endif

#endif // _NTCSRMSG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntcsrsrv.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntcsrsrv.h

Abstract:

    This module defines the public interfaces of the Server portion of
    the Client-Server Runtime (Csr) Subsystem.

Author:

    Steve Wood (stevewo) 09-Oct-1990

Revision History:

--*/

#ifndef _NTCSRSRVAPI_
#define _NTCSRSRVAPI_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Define API decoration for direct importing system DLL references.
//

#if !defined(_CSRSRV_)
#define NTCSRAPI DECLSPEC_IMPORT
#else
#define NTCSRAPI
#endif

#include "ntcsrmsg.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// NT Session structure allocated in the server context for each new NT
// session that is a client of the server.
//

typedef struct _CSR_NT_SESSION {
    LIST_ENTRY SessionLink;
    ULONG SessionId;
    ULONG ReferenceCount;
    STRING RootDirectory;
} CSR_NT_SESSION, *PCSR_NT_SESSION;

//
// Per Thread data structure allocated in the server context for each new
// client thread that is allowed to communicate with the server.
//

#define CSR_ALERTABLE_THREAD    0x00000001
#define CSR_THREAD_TERMINATING  0x00000002
#define CSR_THREAD_DESTROYED    0x00000004

typedef struct _CSR_THREAD {
    LARGE_INTEGER CreateTime;
    LIST_ENTRY Link;
    LIST_ENTRY HashLinks;
    CLIENT_ID ClientId;

    struct _CSR_PROCESS *Process;
    struct _CSR_WAIT_BLOCK *WaitBlock;
    HANDLE ThreadHandle;
    ULONG Flags;
    ULONG ReferenceCount;
    ULONG ImpersonateCount;
} CSR_THREAD, *PCSR_THREAD;


//
// Per Process data structure allocated in the server context for each new
// client process that successfully connects to the server.
//

//
// 0x00000010 -> 0x000000x0 are used in ntcsrmsg.h
//

#define CSR_DEBUG_THIS_PROCESS      0x00000001
#define CSR_DEBUG_PROCESS_TREE      0x00000002
#define CSR_DEBUG_WIN32SERVER       0x00000004

#define CSR_CREATE_PROCESS_GROUP    0x00000100
#define CSR_PROCESS_DESTROYED       0x00000200
#define CSR_PROCESS_LASTTHREADOK    0x00000400
#define CSR_PROCESS_CONSOLEAPP      0x00000800
#define CSR_PROCESS_TERMINATED      0x00001000

//
// Flags defines
//
#define CSR_PROCESS_TERMINATING     1
#define CSR_PROCESS_SHUTDOWNSKIP    2

typedef struct _CSR_PROCESS {
    CLIENT_ID ClientId;
    LIST_ENTRY ListLink;
    LIST_ENTRY ThreadList;
    struct _CSR_PROCESS *Parent;
    PCSR_NT_SESSION NtSession;
    ULONG ExpectedVersion;
    HANDLE ClientPort;
    PCH ClientViewBase;
    PCH ClientViewBounds;
    HANDLE ProcessHandle;
    ULONG SequenceNumber;
    ULONG Flags;
    ULONG DebugFlags;
    CLIENT_ID DebugUserInterface;

    ULONG ReferenceCount;
    ULONG ProcessGroupId;
    ULONG ProcessGroupSequence;

    ULONG fVDM;

    ULONG ThreadCount;

    UCHAR PriorityClass;
    UCHAR Spare0;
    UCHAR Spare1;
    UCHAR Spare2;
    ULONG Spare3;
    ULONG ShutdownLevel;
    ULONG ShutdownFlags;
    PVOID ServerDllPerProcessData[ 1 ];     // Variable length array
} CSR_PROCESS, *PCSR_PROCESS;


//
// All exported API calls define the same interface to the Server Request
// loop.  The return value is any arbritrary 32-bit value, which will be
// be returned in the ReturnValue field of the reply message.
//

typedef enum _CSR_REPLY_STATUS {
    CsrReplyImmediate,
    CsrReplyPending,
    CsrClientDied,
    CsrServerReplied
} CSR_REPLY_STATUS, *PCSR_REPLY_STATUS;

typedef
ULONG
(*PCSR_API_ROUTINE)(
    IN OUT PCSR_API_MSG ReplyMsg,
    OUT PCSR_REPLY_STATUS ReplyStatus
    );

#define CSR_SERVER_QUERYCLIENTTHREAD() \
    ((PCSR_THREAD)(NtCurrentTeb()->CsrClientThread))


//
// Server data structure allocated for each Server DLL loaded into the
// context of the server process.
//

typedef
NTSTATUS
(*PCSR_SERVER_CONNECT_ROUTINE)(
    IN PCSR_PROCESS Process,
    IN OUT PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength
    );

typedef
VOID
(*PCSR_SERVER_DISCONNECT_ROUTINE)(
    IN PCSR_PROCESS Process
    );

typedef
NTSTATUS
(*PCSR_SERVER_ADDPROCESS_ROUTINE)(
    IN PCSR_PROCESS ParentProcess,
    IN PCSR_PROCESS Process
    );

typedef
VOID
(*PCSR_SERVER_HARDERROR_ROUTINE)(
    IN PCSR_THREAD Thread,
    IN PHARDERROR_MSG HardErrorMsg
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrServerInitialization(
    IN ULONG argc,
    IN PCH argv[]
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrCallServerFromServer(
    PCSR_API_MSG ReceiveMsg,
    PCSR_API_MSG ReplyMsg
    );

//
// ShutdownProcessRoutine return values
//

#define SHUTDOWN_KNOWN_PROCESS   1
#define SHUTDOWN_UNKNOWN_PROCESS 2
#define SHUTDOWN_CANCEL          3

//
// Private ShutdownFlags flag
//
#define SHUTDOWN_SYSTEMCONTEXT   0x00000004
#define SHUTDOWN_OTHERCONTEXT    0x00000008

typedef
ULONG
(*PCSR_SERVER_SHUTDOWNPROCESS_ROUTINE)(
    IN PCSR_PROCESS Process,
    IN ULONG Flags,
    IN BOOLEAN fFirstPass
    );

NTCSRAPI
ULONG
NTAPI
CsrComputePriorityClass(
    IN PCSR_PROCESS Process
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrShutdownProcesses(
    PLUID LuidCaller,
    ULONG Flags
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrGetProcessLuid(
    HANDLE ProcessHandle,
    PLUID LuidProcess
    );

typedef struct _CSR_SERVER_DLL {
    ULONG Length;
    HANDLE CsrInitializationEvent;
    STRING ModuleName;
    HANDLE ModuleHandle;
    ULONG ServerDllIndex;
    ULONG ServerDllConnectInfoLength;
    ULONG ApiNumberBase;
    ULONG MaxApiNumber;
    PCSR_API_ROUTINE *ApiDispatchTable;
    PBOOLEAN ApiServerValidTable;
    PSZ *ApiNameTable;
    ULONG PerProcessDataLength;
    PCSR_SERVER_CONNECT_ROUTINE ConnectRoutine;
    PCSR_SERVER_DISCONNECT_ROUTINE DisconnectRoutine;
    PCSR_SERVER_HARDERROR_ROUTINE HardErrorRoutine;
    PVOID SharedStaticServerData;
    PCSR_SERVER_ADDPROCESS_ROUTINE AddProcessRoutine;
    PCSR_SERVER_SHUTDOWNPROCESS_ROUTINE ShutdownProcessRoutine;
} CSR_SERVER_DLL, *PCSR_SERVER_DLL;

typedef
NTSTATUS
(*PCSR_SERVER_DLL_INIT_ROUTINE)(
    IN PCSR_SERVER_DLL LoadedServerDll
    );

typedef
VOID
(*PCSR_ATTACH_COMPLETE_ROUTINE)(
    VOID
    );

NTCSRAPI
VOID
NTAPI
CsrReferenceThread(
    PCSR_THREAD t
    );

NTCSRAPI
VOID
NTAPI
CsrDereferenceThread(
    PCSR_THREAD t
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrCreateProcess(
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN PCSR_NT_SESSION Session,
    IN ULONG DebugFlags,
    IN PCLIENT_ID DebugUserInterface OPTIONAL
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrDebugProcess(
    IN ULONG TargetProcessId,
    IN PCLIENT_ID DebugUserInterface,
    IN PCSR_ATTACH_COMPLETE_ROUTINE AttachCompleteRoutine
    );

NTCSRAPI
VOID
NTAPI
CsrDereferenceProcess(
    PCSR_PROCESS p
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrDestroyProcess(
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ExitStatus
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrLockProcessByClientId(
    IN HANDLE UniqueProcessId,
    OUT PCSR_PROCESS *Process
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrUnlockProcess(
    IN PCSR_PROCESS Process
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrLockThreadByClientId(
    IN HANDLE UniqueThreadId,
    OUT PCSR_THREAD *Thread
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrUnlockThread(
    IN PCSR_THREAD Thread
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrCreateThread(
    IN PCSR_PROCESS Process,
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId
    );

NTCSRAPI
PCSR_THREAD
NTAPI
CsrLocateThreadInProcess(
    IN PCSR_PROCESS Process,
    IN PCLIENT_ID ClientId
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrCreateRemoteThread(
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId
    );

NTCSRAPI
NTSTATUS
NTAPI
CsrDestroyThread(
    IN PCLIENT_ID ClientId
    );

//
// WaitFlags
//

typedef
BOOLEAN
(*CSR_WAIT_ROUTINE)(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    );

typedef struct _CSR_WAIT_BLOCK {
    ULONG Length;
    LIST_ENTRY Link;
    LIST_ENTRY UserLink;
    PVOID WaitParameter;
    PCSR_THREAD WaitingThread;
    CSR_WAIT_ROUTINE WaitRoutine;
    CSR_API_MSG WaitReplyMessage;
} CSR_WAIT_BLOCK, *PCSR_WAIT_BLOCK;

NTCSRAPI
BOOLEAN
NTAPI
CsrCreateWait(
    IN PLIST_ENTRY WaitQueue,
    IN CSR_WAIT_ROUTINE WaitRoutine,
    IN PCSR_THREAD WaitingThread,
    IN OUT PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PLIST_ENTRY UserLinkListHead OPTIONAL
    );

NTCSRAPI
VOID
NTAPI
CsrDereferenceWait(
    IN PLIST_ENTRY WaitQueue
    );

NTCSRAPI
BOOLEAN
NTAPI
CsrNotifyWait(
    IN PLIST_ENTRY WaitQueue,
    IN BOOLEAN SatisfyAll,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2
    );

NTCSRAPI
VOID
NTAPI
CsrMoveSatisfiedWait(
    IN PLIST_ENTRY DstWaitQueue,
    IN PLIST_ENTRY SrcWaitQueue
    );

NTCSRAPI
PVOID
NTAPI
CsrAddStaticServerThread(
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN ULONG Flags
    );

NTCSRAPI
PCSR_THREAD
NTAPI
CsrConnectToUser(
    VOID
    );

NTCSRAPI
BOOLEAN
NTAPI
CsrImpersonateClient(
    IN PCSR_THREAD Thread
    );

NTCSRAPI
BOOLEAN
NTAPI
CsrRevertToSelf(
    VOID
    );

NTCSRAPI
VOID
NTAPI
CsrSetForegroundPriority(
    IN PCSR_PROCESS Process
    );

NTCSRAPI
VOID
NTAPI
CsrSetBackgroundPriority(
    IN PCSR_PROCESS Process
    );

NTCSRAPI
EXCEPTION_DISPOSITION
NTAPI
CsrUnhandledExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionInfo
    );

NTCSRAPI
BOOLEAN
NTAPI
CsrValidateMessageBuffer(
    IN PCSR_API_MSG m,
    IN PVOID *Buffer,
    IN ULONG Count,
    IN ULONG Size
    );

NTCSRAPI
BOOLEAN
NTAPI
CsrValidateMessageString(
    IN PCSR_API_MSG m,
    IN PWSTR *Buffer
    );

typedef struct _CSR_FAST_ANSI_OEM_TABLES {
    char OemToAnsiTable[256];
    char AnsiToOemTable[256];
} CSR_FAST_ANSI_OEM_TABLES, *PCSR_FAST_ANSI_OEM_TABLES;

#ifdef __cplusplus
}
#endif

#endif // _NTCSRSRVAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntdbg.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ntdbg.h

Abstract:

    This module contains the public data structures, data types,
    and procedures exported by the NT Dbg subsystem.

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#ifndef _NTDBG_
#define _NTDBG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif



// begin_windbgkd
//
// The following are explicitly sized versions of common system
// structures which appear in the kernel debugger API.
//
// All of the debugger structures which are exposed to both
// sides of the KD API are declared below in explicitly sized
// versions as well, with inline converter functions.
//

//
// Macro for sign extending 32 bit addresses into 64 bits
//

#define COPYSE(p64,p32,f) p64->f = (ULONG64)(LONG64)(LONG)p32->f

__inline
void
ExceptionRecord32To64(
    IN PEXCEPTION_RECORD32 Ex32,
    OUT PEXCEPTION_RECORD64 Ex64
    )
{
    ULONG i;
    Ex64->ExceptionCode = Ex32->ExceptionCode;
    Ex64->ExceptionFlags = Ex32->ExceptionFlags;
    Ex64->ExceptionRecord = Ex32->ExceptionRecord;
    COPYSE(Ex64,Ex32,ExceptionAddress);
    Ex64->NumberParameters = Ex32->NumberParameters;
    for (i = 0; i < Ex64->NumberParameters; i++) {
        COPYSE(Ex64,Ex32,ExceptionInformation[i]);
    }
}

__inline
void
ExceptionRecord64To32(
    IN PEXCEPTION_RECORD64 Ex64,
    OUT PEXCEPTION_RECORD32 Ex32
    )
{
    ULONG i;
    Ex32->ExceptionCode = Ex64->ExceptionCode;
    Ex32->ExceptionFlags = Ex64->ExceptionFlags;
    Ex32->ExceptionRecord = (ULONG) Ex64->ExceptionRecord;
    Ex32->ExceptionAddress = (ULONG) Ex64->ExceptionAddress;
    Ex32->NumberParameters = Ex64->NumberParameters;
    for (i = 0; i < Ex32->NumberParameters; i++) {
        Ex32->ExceptionInformation[i] = (ULONG) Ex64->ExceptionInformation[i];
    }
}

// end_windbgkd

//
// DbgKm Apis are from the kernel component (Dbgk) through a process
// debug port.
//

#define DBGKM_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGKM_APIMSG, u.Exception) - sizeof(PORT_MESSAGE))

#define DBGKM_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGKM_APIMSG) << 16) | (DBGKM_MSG_OVERHEAD + (TypeSize)))

#define DBGKM_FORMAT_API_MSG(m,Number,TypeSize)             \
    (m).h.u1.Length = DBGKM_API_MSG_LENGTH((TypeSize));     \
    (m).h.u2.ZeroInit = LPC_DEBUG_EVENT;                    \
    (m).ApiNumber = (Number)

typedef enum _DBGKM_APINUMBER {
    DbgKmExceptionApi,
    DbgKmCreateThreadApi,
    DbgKmCreateProcessApi,
    DbgKmExitThreadApi,
    DbgKmExitProcessApi,
    DbgKmLoadDllApi,
    DbgKmUnloadDllApi,
    DbgKmMaxApiNumber
} DBGKM_APINUMBER;

// begin_windbgkd

#if !DBG_NO_PORTABLE_TYPES
typedef struct _DBGKM_EXCEPTION {
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;
#endif

typedef struct _DBGKM_EXCEPTION32 {
    EXCEPTION_RECORD32 ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION32, *PDBGKM_EXCEPTION32;

typedef struct _DBGKM_EXCEPTION64 {
    EXCEPTION_RECORD64 ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION64, *PDBGKM_EXCEPTION64;

__inline
void
DbgkmException32To64(
    IN PDBGKM_EXCEPTION32 E32,
    OUT PDBGKM_EXCEPTION64 E64
    )
{
    ExceptionRecord32To64(&E32->ExceptionRecord, &E64->ExceptionRecord);
    E64->FirstChance = E32->FirstChance;
}

__inline
void
DbgkmException64To32(
    IN PDBGKM_EXCEPTION64 E64,
    OUT PDBGKM_EXCEPTION32 E32
    )
{
    ExceptionRecord64To32(&E64->ExceptionRecord, &E32->ExceptionRecord);
    E32->FirstChance = E64->FirstChance;
}

// end_windbgkd

//
// The DbgSS, DbgKm and DbgSs stuff is not needed in the portable debugger,
// and some of the following types and prototypes use portable types, so just
// turn them all off when building the debugger.
//

#if !DBG_NO_PORTABLE_TYPES
typedef struct _DBGKM_CREATE_THREAD {
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS {
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL {
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL {
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef struct _DBGKM_APIMSG {
    PORT_MESSAGE h;
    DBGKM_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    union {
        DBGKM_EXCEPTION Exception;
        DBGKM_CREATE_THREAD CreateThread;
        DBGKM_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } u;
} DBGKM_APIMSG, *PDBGKM_APIMSG;

//
// DbgSrv Messages are from Dbg subsystem to emulation subsystem.
// The only defined message at this time is continue
//

#define DBGSRV_MSG_OVERHEAD \
    (sizeof(DBGSRV_APIMSG) - sizeof(PORT_MESSAGE))

#define DBGSRV_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGSRV_APIMSG) << 16) | (DBGSRV_MSG_OVERHEAD))

#define DBGSRV_FORMAT_API_MSG(m,Number,TypeSize,CKey)     \
    (m).h.u1.Length = DBGSRV_API_MSG_LENGTH((TypeSize));  \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number);                             \
    (m).ContinueKey = (PVOID)(CKey)

typedef enum _DBGSRV_APINUMBER {
    DbgSrvContinueApi,
    DbgSrvMaxApiNumber
} DBGSRV_APINUMBER;

typedef struct _DBGSRV_APIMSG {
    PORT_MESSAGE h;
    DBGSRV_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    PVOID ContinueKey;
} DBGSRV_APIMSG, *PDBGSRV_APIMSG;

//
//
// DbgSs Apis are from the system service emulation subsystems to the Dbg
// subsystem
//

typedef enum _DBG_STATE {
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

#define DBGSS_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGSS_APIMSG, u.Exception) - sizeof(PORT_MESSAGE))

#define DBGSS_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGSS_APIMSG) << 16) | (DBGSS_MSG_OVERHEAD + (TypeSize)))

#define DBGSS_FORMAT_API_MSG(m,Number,TypeSize,pApp,CKey)  \
    (m).h.u1.Length = DBGSS_API_MSG_LENGTH((TypeSize));   \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number);                             \
    (m).AppClientId = *(pApp);                            \
    (m).ContinueKey = (PVOID)(CKey)

typedef enum _DBGSS_APINUMBER {
    DbgSsExceptionApi,
    DbgSsCreateThreadApi,
    DbgSsCreateProcessApi,
    DbgSsExitThreadApi,
    DbgSsExitProcessApi,
    DbgSsLoadDllApi,
    DbgSsUnloadDllApi,
    DbgSsMaxApiNumber
} DBGSS_APINUMBER;

typedef struct _DBGSS_CREATE_PROCESS {
    CLIENT_ID DebugUiClientId;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGSS_CREATE_PROCESS, *PDBGSS_CREATE_PROCESS;

typedef struct _DBGSS_APIMSG {
    PORT_MESSAGE h;
    DBGKM_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    CLIENT_ID AppClientId;
    PVOID ContinueKey;
    union {
        DBGKM_EXCEPTION Exception;
        DBGKM_CREATE_THREAD CreateThread;
        DBGSS_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } u;
} DBGSS_APIMSG, *PDBGSS_APIMSG;

#define DBGUI_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGUI_APIMSG, u.Continue) - sizeof(PORT_MESSAGE))

#define DBGUI_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGUI_APIMSG) << 16) | (DBGUI_MSG_OVERHEAD + (TypeSize)))

#define DBGUI_FORMAT_API_MSG(m,Number,TypeSize)            \
    (m).h.u1.Length = DBGUI_API_MSG_LENGTH((TypeSize));     \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number)

typedef enum _DBGUI_APINUMBER {
    DbgUiWaitStateChangeApi,
    DbgUiContinueApi,
    DbgUiMaxApiNumber
} DBGUI_APINUMBER;

typedef struct _DBGUI_CREATE_THREAD {
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS {
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE {
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

typedef struct _DBGUI_CONTINUE {
    CLIENT_ID AppClientId;
    NTSTATUS ContinueStatus;
} DBGUI_CONTINUE, *PDBGUI_CONTINUE;

typedef struct _DBGUI_APIMSG {
    PORT_MESSAGE h;
    union {
        HANDLE DbgStateChangeSemaphore;
        struct {
            DBGKM_APINUMBER ApiNumber;
            NTSTATUS ReturnedStatus;
            union {
                DBGUI_CONTINUE Continue;
                DBGUI_WAIT_STATE_CHANGE WaitStateChange;
            } u;
        };
    };
} DBGUI_APIMSG, *PDBGUI_APIMSG;

typedef
NTSTATUS
(*PDBGSS_UI_LOOKUP) (
    IN PCLIENT_ID AppClientId,
    OUT PCLIENT_ID DebugUiClientId
    );

typedef
NTSTATUS
(*PDBGSS_DBGKM_APIMSG_FILTER) (
    IN OUT PDBGKM_APIMSG ApiMsg
    );

typedef
NTSTATUS
(*PDBGSS_SUBSYSTEMKEY_LOOKUP) (
    IN PCLIENT_ID AppClientId,
    OUT PULONG SubsystemKey,
    IN BOOLEAN ProcessKey
    );
//
// DbgSs APIs
//

NTSTATUS
NTAPI
DbgSsInitialize(
    IN HANDLE KmReplyPort,
    IN PDBGSS_UI_LOOKUP UiLookUpRoutine,
    IN PDBGSS_SUBSYSTEMKEY_LOOKUP SubsystemKeyLookupRoutine OPTIONAL,
    IN PDBGSS_DBGKM_APIMSG_FILTER KmApiMsgFilter OPTIONAL
    );

VOID
NTAPI
DbgSsHandleKmApiMsg(
    IN PDBGKM_APIMSG ApiMsg,
    IN HANDLE ReplyEvent OPTIONAL
    );

typedef
NTSTATUS
(*PDBGSS_INITIALIZE_ROUTINE)(
    IN HANDLE KmReplyPort,
    IN PDBGSS_UI_LOOKUP UiLookUpRoutine,
    IN PDBGSS_SUBSYSTEMKEY_LOOKUP SubsystemKeyLookupRoutine OPTIONAL,
    IN PDBGSS_DBGKM_APIMSG_FILTER KmApiMsgFilter OPTIONAL
    );

typedef
VOID
(*PDBGSS_HANDLE_MSG_ROUTINE)(
    IN PDBGKM_APIMSG ApiMsg,
    IN HANDLE ReplyEvent OPTIONAL
    );

//
// DbgUi APIs
//

NTSTATUS
NTAPI
DbgUiConnectToDbg( VOID );

NTSTATUS
NTAPI
DbgUiWaitStateChange (
    OUT PDBGUI_WAIT_STATE_CHANGE StateChange,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSTATUS
NTAPI
DbgUiContinue (
    IN PCLIENT_ID AppClientId,
    IN NTSTATUS ContinueStatus
    );
#endif // DBG_NO_PORTABLE_TYPES

// begin_windbgkd

//
// DbgKd APIs are for the portable kernel debugger
//

//
// KD_PACKETS are the low level data format used in KD. All packets
// begin with a packet leader, byte count, packet type. The sequence
// for accepting a packet is:
//
//  - read 4 bytes to get packet leader.  If read times out (10 seconds)
//    with a short read, or if packet leader is incorrect, then retry
//    the read.
//
//  - next read 2 byte packet type.  If read times out (10 seconds) with
//    a short read, or if packet type is bad, then start again looking
//    for a packet leader.
//
//  - next read 4 byte packet Id.  If read times out (10 seconds)
//    with a short read, or if packet Id is not what we expect, then
//    ask for resend and restart again looking for a packet leader.
//
//  - next read 2 byte count.  If read times out (10 seconds) with
//    a short read, or if byte count is greater than PACKET_MAX_SIZE,
//    then start again looking for a packet leader.
//
//  - next read 4 byte packet data checksum.
//
//  - The packet data immediately follows the packet.  There should be
//    ByteCount bytes following the packet header.  Read the packet
//    data, if read times out (10 seconds) then start again looking for
//    a packet leader.
//


typedef struct _KD_PACKET {
    ULONG PacketLeader;
    USHORT PacketType;
    USHORT ByteCount;
    ULONG PacketId;
    ULONG Checksum;
} KD_PACKET, *PKD_PACKET;


#define PACKET_MAX_SIZE 4000
#define INITIAL_PACKET_ID 0x80800000    // Don't use 0
#define SYNC_PACKET_ID    0x00000800    // Or in with INITIAL_PACKET_ID
                                        // to force a packet ID reset.

//
// BreakIn packet
//

#define BREAKIN_PACKET                  0x62626262
#define BREAKIN_PACKET_BYTE             0x62

//
// Packet lead in sequence
//

#define PACKET_LEADER                   0x30303030 //0x77000077
#define PACKET_LEADER_BYTE              0x30

#define CONTROL_PACKET_LEADER           0x69696969
#define CONTROL_PACKET_LEADER_BYTE      0x69

//
// Packet Trailing Byte
//

#define PACKET_TRAILING_BYTE            0xAA

//
// Packet Types
//

#define PACKET_TYPE_UNUSED              0
#define PACKET_TYPE_KD_STATE_CHANGE32   1
#define PACKET_TYPE_KD_STATE_MANIPULATE 2
#define PACKET_TYPE_KD_DEBUG_IO         3
#define PACKET_TYPE_KD_ACKNOWLEDGE      4       // Packet-control type
#define PACKET_TYPE_KD_RESEND           5       // Packet-control type
#define PACKET_TYPE_KD_RESET            6       // Packet-control type
#define PACKET_TYPE_KD_STATE_CHANGE64   7
#define PACKET_TYPE_MAX                 8

//
// If the packet type is PACKET_TYPE_KD_STATE_CHANGE, then
// the format of the packet data is as follows:
//

#define DbgKdExceptionStateChange   0x00003030L
#define DbgKdLoadSymbolsStateChange 0x00003031L

//
// Pathname Data follows directly
//

typedef struct _DBGKD_LOAD_SYMBOLS32 {
    ULONG PathNameLength;
    ULONG BaseOfDll;
    ULONG ProcessId;
    ULONG CheckSum;
    ULONG SizeOfImage;
    BOOLEAN UnloadSymbols;
} DBGKD_LOAD_SYMBOLS32, *PDBGKD_LOAD_SYMBOLS32;

typedef struct _DBGKD_LOAD_SYMBOLS64 {
    ULONG PathNameLength;
    ULONG64 BaseOfDll;
    ULONG64 ProcessId;
    ULONG CheckSum;
    ULONG SizeOfImage;
    BOOLEAN UnloadSymbols;
} DBGKD_LOAD_SYMBOLS64, *PDBGKD_LOAD_SYMBOLS64;

__inline
void
DbgkdLoadSymbols32To64(
    IN PDBGKD_LOAD_SYMBOLS32 Ls32,
    OUT PDBGKD_LOAD_SYMBOLS64 Ls64
    )
{
    Ls64->PathNameLength = Ls32->PathNameLength;
    Ls64->ProcessId = Ls32->ProcessId;
    COPYSE(Ls64,Ls32,BaseOfDll);
    Ls64->CheckSum = Ls32->CheckSum;
    Ls64->SizeOfImage = Ls32->SizeOfImage;
    Ls64->UnloadSymbols = Ls32->UnloadSymbols;
}

__inline
void
LoadSymbols64To32(
    IN PDBGKD_LOAD_SYMBOLS64 Ls64,
    OUT PDBGKD_LOAD_SYMBOLS32 Ls32
    )
{
    Ls32->PathNameLength = Ls64->PathNameLength;
    Ls32->ProcessId = (ULONG)Ls64->ProcessId;
    Ls32->BaseOfDll = (ULONG)Ls64->BaseOfDll;
    Ls32->CheckSum = Ls64->CheckSum;
    Ls32->SizeOfImage = Ls64->SizeOfImage;
    Ls32->UnloadSymbols = Ls64->UnloadSymbols;
}

#ifdef _IA64_
#include <pshpck16.h>
#endif

typedef struct _DBGKD_WAIT_STATE_CHANGE32 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG Thread;
    ULONG ProgramCounter;
    union {
        DBGKM_EXCEPTION32 Exception;
        DBGKD_LOAD_SYMBOLS32 LoadSymbols;
    } u;
    DBGKD_CONTROL_REPORT ControlReport;
    CONTEXT Context;
} DBGKD_WAIT_STATE_CHANGE32, *PDBGKD_WAIT_STATE_CHANGE32;

typedef struct _DBGKD_WAIT_STATE_CHANGE64 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
    } u;
    DBGKD_CONTROL_REPORT ControlReport;
    CONTEXT Context;
} DBGKD_WAIT_STATE_CHANGE64, *PDBGKD_WAIT_STATE_CHANGE64;

__inline
void
WaitStateChange32To64(
    IN PDBGKD_WAIT_STATE_CHANGE32 Ws32,
    OUT PDBGKD_WAIT_STATE_CHANGE64 Ws64
    )
{
    Ws64->NewState = Ws32->NewState;
    Ws64->ProcessorLevel = Ws32->ProcessorLevel;
    Ws64->Processor = Ws32->Processor;
    Ws64->NumberProcessors = Ws32->NumberProcessors;
    COPYSE(Ws64,Ws32,Thread);
    COPYSE(Ws64,Ws32,ProgramCounter);
    Ws64->ControlReport = Ws32->ControlReport;
    memcpy(&Ws64->Context, &Ws32->Context, sizeof(CONTEXT));
    if (Ws32->NewState == DbgKdLoadSymbolsStateChange) {
        DbgkdLoadSymbols32To64(&Ws32->u.LoadSymbols, &Ws64->u.LoadSymbols);
    } else {
        DbgkmException32To64(&Ws32->u.Exception, &Ws64->u.Exception);
    }
}

__inline
void
WaitStateChange64To32(
    IN PDBGKD_WAIT_STATE_CHANGE64 Ws64,
    OUT PDBGKD_WAIT_STATE_CHANGE32 Ws32
    )
{
    Ws32->NewState = Ws64->NewState;
    Ws32->ProcessorLevel = Ws64->ProcessorLevel;
    Ws32->Processor = Ws64->Processor;
    Ws32->NumberProcessors = Ws64->NumberProcessors;
    Ws32->Thread = (ULONG)Ws64->Thread;
    Ws32->ProgramCounter = (ULONG)Ws64->ProgramCounter;
    Ws32->ControlReport = Ws64->ControlReport;
    memcpy(&Ws32->Context, &Ws64->Context, sizeof(CONTEXT));
    if (Ws32->NewState == DbgKdLoadSymbolsStateChange) {
        LoadSymbols64To32(&Ws64->u.LoadSymbols, &Ws32->u.LoadSymbols);
    } else {
        DbgkmException64To32(&Ws64->u.Exception, &Ws32->u.Exception);
    }
}


#ifdef _IA64_
#include <poppack.h>
#endif

//
// If the packet type is PACKET_TYPE_KD_STATE_MANIPULATE, then
// the format of the packet data is as follows:
//
// Api Numbers for state manipulation
//

#define DbgKdReadVirtualMemoryApi           0x00003130L
#define DbgKdWriteVirtualMemoryApi          0x00003131L
#define DbgKdGetContextApi                  0x00003132L
#define DbgKdSetContextApi                  0x00003133L
#define DbgKdWriteBreakPointApi             0x00003134L
#define DbgKdRestoreBreakPointApi           0x00003135L
#define DbgKdContinueApi                    0x00003136L
#define DbgKdReadControlSpaceApi            0x00003137L
#define DbgKdWriteControlSpaceApi           0x00003138L
#define DbgKdReadIoSpaceApi                 0x00003139L
#define DbgKdWriteIoSpaceApi                0x0000313AL
#define DbgKdRebootApi                      0x0000313BL
#define DbgKdContinueApi2                   0x0000313CL
#define DbgKdReadPhysicalMemoryApi          0x0000313DL
#define DbgKdWritePhysicalMemoryApi         0x0000313EL
//#define DbgKdQuerySpecialCallsApi           0x0000313FL
#define DbgKdSetSpecialCallApi              0x00003140L
#define DbgKdClearSpecialCallsApi           0x00003141L
#define DbgKdSetInternalBreakPointApi       0x00003142L
#define DbgKdGetInternalBreakPointApi       0x00003143L
#define DbgKdReadIoSpaceExtendedApi         0x00003144L
#define DbgKdWriteIoSpaceExtendedApi        0x00003145L
#define DbgKdGetVersionApi                  0x00003146L
#define DbgKdWriteBreakPointExApi           0x00003147L
#define DbgKdRestoreBreakPointExApi         0x00003148L
#define DbgKdCauseBugCheckApi               0x00003149L
#define DbgKdSwitchProcessor                0x00003150L
#define DbgKdPageInApi                      0x00003151L // obsolete
#define DbgKdReadMachineSpecificRegister    0x00003152L
#define DbgKdWriteMachineSpecificRegister   0x00003153L
#define OldVlm1                             0x00003154L
#define OldVlm2                             0x00003155L
#define DbgKdSearchMemoryApi                0x00003156L
#define DbgKdGetBusDataApi                  0x00003157L
#define DbgKdSetBusDataApi                  0x00003158L
#define DbgKdCheckLowMemoryApi              0X00003159L

//
// Response is a read memory message with data following
//

typedef struct _DBGKD_READ_MEMORY32 {
    ULONG TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesRead;
} DBGKD_READ_MEMORY32, *PDBGKD_READ_MEMORY32;

typedef struct _DBGKD_READ_MEMORY64 {
    ULONG64 TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesRead;
} DBGKD_READ_MEMORY64, *PDBGKD_READ_MEMORY64;

__inline
void
DbgkdReadMemory32To64(
    IN PDBGKD_READ_MEMORY32 r32,
    OUT PDBGKD_READ_MEMORY64 r64
    )
{
    COPYSE(r64,r32,TargetBaseAddress);
    r64->TransferCount = r32->TransferCount;
    r64->ActualBytesRead = r32->ActualBytesRead;
}

__inline
void
DbgkdReadMemory64To32(
    IN PDBGKD_READ_MEMORY64 r64,
    OUT PDBGKD_READ_MEMORY32 r32
    )
{
    r32->TargetBaseAddress = (ULONG)r64->TargetBaseAddress;
    r32->TransferCount = r64->TransferCount;
    r32->ActualBytesRead = r64->ActualBytesRead;
}

//
// Data follows directly
//

typedef struct _DBGKD_WRITE_MEMORY32 {
    ULONG TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesWritten;
} DBGKD_WRITE_MEMORY32, *PDBGKD_WRITE_MEMORY32;

typedef struct _DBGKD_WRITE_MEMORY64 {
    ULONG64 TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesWritten;
} DBGKD_WRITE_MEMORY64, *PDBGKD_WRITE_MEMORY64;


__inline
void
DbgkdWriteMemory32To64(
    IN PDBGKD_WRITE_MEMORY32 r32,
    OUT PDBGKD_WRITE_MEMORY64 r64
    )
{
    COPYSE(r64,r32,TargetBaseAddress);
    r64->TransferCount = r32->TransferCount;
    r64->ActualBytesWritten = r32->ActualBytesWritten;
}

__inline
void
DbgkdWriteMemory64To32(
    IN PDBGKD_WRITE_MEMORY64 r64,
    OUT PDBGKD_WRITE_MEMORY32 r32
    )
{
    r32->TargetBaseAddress = (ULONG)r64->TargetBaseAddress;
    r32->TransferCount = r64->TransferCount;
    r32->ActualBytesWritten = r64->ActualBytesWritten;
}
//
// Response is a get context message with a full context record following
//

typedef struct _DBGKD_GET_CONTEXT {
    ULONG Unused;
} DBGKD_GET_CONTEXT, *PDBGKD_GET_CONTEXT;

//
// Full Context record follows
//

typedef struct _DBGKD_SET_CONTEXT {
    ULONG ContextFlags;
} DBGKD_SET_CONTEXT, *PDBGKD_SET_CONTEXT;

#define BREAKPOINT_TABLE_SIZE   32      // max number supported by kernel

typedef struct _DBGKD_WRITE_BREAKPOINT32 {
    ULONG BreakPointAddress;
    ULONG BreakPointHandle;
} DBGKD_WRITE_BREAKPOINT32, *PDBGKD_WRITE_BREAKPOINT32;

typedef struct _DBGKD_WRITE_BREAKPOINT64 {
    ULONG64 BreakPointAddress;
    ULONG BreakPointHandle;
} DBGKD_WRITE_BREAKPOINT64, *PDBGKD_WRITE_BREAKPOINT64;


__inline
void
DbgkdWriteBreakpoint32To64(
    IN PDBGKD_WRITE_BREAKPOINT32 r32,
    OUT PDBGKD_WRITE_BREAKPOINT64 r64
    )
{
    COPYSE(r64,r32,BreakPointAddress);
    r64->BreakPointHandle = r32->BreakPointHandle;
}

__inline
void
DbgkdWriteBreakpoint64To32(
    IN PDBGKD_WRITE_BREAKPOINT64 r64,
    OUT PDBGKD_WRITE_BREAKPOINT32 r32
    )
{
    r32->BreakPointAddress = (ULONG)r64->BreakPointAddress;
    r32->BreakPointHandle = r64->BreakPointHandle;
}

typedef struct _DBGKD_RESTORE_BREAKPOINT {
    ULONG BreakPointHandle;
} DBGKD_RESTORE_BREAKPOINT, *PDBGKD_RESTORE_BREAKPOINT;

typedef struct _DBGKD_BREAKPOINTEX {
    ULONG     BreakPointCount;
    NTSTATUS  ContinueStatus;
} DBGKD_BREAKPOINTEX, *PDBGKD_BREAKPOINTEX;

typedef struct _DBGKD_CONTINUE {
    NTSTATUS ContinueStatus;
} DBGKD_CONTINUE, *PDBGKD_CONTINUE;

typedef struct _DBGKD_CONTINUE2 {
    NTSTATUS ContinueStatus;
    DBGKD_CONTROL_SET ControlSet;
} DBGKD_CONTINUE2, *PDBGKD_CONTINUE2;

typedef struct _DBGKD_READ_WRITE_IO32 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO32, *PDBGKD_READ_WRITE_IO32;

typedef struct _DBGKD_READ_WRITE_IO64 {
    ULONG64 IoAddress;
    ULONG DataSize;                     // 1, 2, 4
    ULONG DataValue;
} DBGKD_READ_WRITE_IO64, *PDBGKD_READ_WRITE_IO64;

__inline
void
DbgkdReadWriteIo32To64(
    IN PDBGKD_READ_WRITE_IO32 r32,
    OUT PDBGKD_READ_WRITE_IO64 r64
    )
{
    COPYSE(r64,r32,IoAddress);
    r64->DataSize = r32->DataSize;
    r64->DataValue = r32->DataValue;
}

__inline
void
DbgkdReadWriteIo64To32(
    IN PDBGKD_READ_WRITE_IO64 r64,
    OUT PDBGKD_READ_WRITE_IO32 r32
    )
{
    r32->IoAddress = (ULONG)r64->IoAddress;
    r32->DataSize = r64->DataSize;
    r32->DataValue = r64->DataValue;
}

typedef struct _DBGKD_READ_WRITE_IO_EXTENDED32 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
    ULONG IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO_EXTENDED32, *PDBGKD_READ_WRITE_IO_EXTENDED32;

typedef struct _DBGKD_READ_WRITE_IO_EXTENDED64 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
    ULONG64 IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO_EXTENDED64, *PDBGKD_READ_WRITE_IO_EXTENDED64;

__inline
void
DbgkdReadWriteIoExtended32To64(
    IN PDBGKD_READ_WRITE_IO_EXTENDED32 r32,
    OUT PDBGKD_READ_WRITE_IO_EXTENDED64 r64
    )
{
    r64->DataSize = r32->DataSize;
    r64->InterfaceType = r32->InterfaceType;
    r64->BusNumber = r32->BusNumber;
    r64->AddressSpace = r32->AddressSpace;
    COPYSE(r64,r32,IoAddress);
    r64->DataValue = r32->DataValue;
}

__inline
void
DbgkdReadWriteIoExtended64To32(
    IN PDBGKD_READ_WRITE_IO_EXTENDED64 r64,
    OUT PDBGKD_READ_WRITE_IO_EXTENDED32 r32
    )
{
    r32->DataSize = r64->DataSize;
    r32->InterfaceType = r64->InterfaceType;
    r32->BusNumber = r64->BusNumber;
    r32->AddressSpace = r64->AddressSpace;
    r32->IoAddress = (ULONG)r64-> IoAddress;
    r32->DataValue = r64->DataValue;
}

typedef struct _DBGKD_READ_WRITE_MSR {
    ULONG Msr;
    ULONG DataValueLow;
    ULONG DataValueHigh;
} DBGKD_READ_WRITE_MSR, *PDBGKD_READ_WRITE_MSR;


typedef struct _DBGKD_QUERY_SPECIAL_CALLS {
    ULONG NumberOfSpecialCalls;
    // ULONG64 SpecialCalls[];
} DBGKD_QUERY_SPECIAL_CALLS, *PDBGKD_QUERY_SPECIAL_CALLS;

typedef struct _DBGKD_SET_SPECIAL_CALL32 {
    ULONG SpecialCall;
} DBGKD_SET_SPECIAL_CALL32, *PDBGKD_SET_SPECIAL_CALL32;

typedef struct _DBGKD_SET_SPECIAL_CALL64 {
    ULONG64 SpecialCall;
} DBGKD_SET_SPECIAL_CALL64, *PDBGKD_SET_SPECIAL_CALL64;

__inline
void
DbgkdSetSpecialCall64To32(
    IN PDBGKD_SET_SPECIAL_CALL64 r64,
    OUT PDBGKD_SET_SPECIAL_CALL32 r32
    )
{
    r32->SpecialCall = (ULONG)r64->SpecialCall;
}

typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT32 {
    ULONG BreakpointAddress;
    ULONG Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT32, *PDBGKD_SET_INTERNAL_BREAKPOINT32;

typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT64 {
    ULONG64 BreakpointAddress;
    ULONG Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT64, *PDBGKD_SET_INTERNAL_BREAKPOINT64;

__inline
void
DbgkdSetInternalBreakpoint64To32(
    IN PDBGKD_SET_INTERNAL_BREAKPOINT64 r64,
    OUT PDBGKD_SET_INTERNAL_BREAKPOINT32 r32
    )
{
    r32->BreakpointAddress = (ULONG)r64->BreakpointAddress;
    r32->Flags = r64->Flags;
}

typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT32 {
    ULONG BreakpointAddress;
    ULONG Flags;
    ULONG Calls;
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;
    ULONG MaxInstructions;
    ULONG TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT32, *PDBGKD_GET_INTERNAL_BREAKPOINT32;

typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT64 {
    ULONG64 BreakpointAddress;
    ULONG Flags;
    ULONG Calls;
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;
    ULONG MaxInstructions;
    ULONG TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT64, *PDBGKD_GET_INTERNAL_BREAKPOINT64;

__inline
void
DbgkdGetInternalBreakpoint32To64(
    IN PDBGKD_GET_INTERNAL_BREAKPOINT32 r32,
    OUT PDBGKD_GET_INTERNAL_BREAKPOINT64 r64
    )
{
    COPYSE(r64,r32,BreakpointAddress);
    r64->Flags = r32->Flags;
    r64->Calls = r32->Calls;
    r64->MaxCallsPerPeriod = r32->MaxCallsPerPeriod;
    r64->MinInstructions = r32->MinInstructions;
    r64->MaxInstructions = r32->MaxInstructions;
    r64->TotalInstructions = r32->TotalInstructions;
}

__inline
void
DbgkdGetInternalBreakpoint64To32(
    IN PDBGKD_GET_INTERNAL_BREAKPOINT64 r64,
    OUT PDBGKD_GET_INTERNAL_BREAKPOINT32 r32
    )
{
    r32->BreakpointAddress = (ULONG)r64->BreakpointAddress;
    r32->Flags = r64->Flags;
    r32->Calls = r64->Calls;
    r32->MaxCallsPerPeriod = r64->MaxCallsPerPeriod;
    r32->MinInstructions = r64->MinInstructions;
    r32->MaxInstructions = r64->MaxInstructions;
    r32->TotalInstructions = r64->TotalInstructions;
}

#define DBGKD_INTERNAL_BP_FLAG_COUNTONLY 0x00000001 // don't count instructions
#define DBGKD_INTERNAL_BP_FLAG_INVALID   0x00000002 // disabled BP
#define DBGKD_INTERNAL_BP_FLAG_SUSPENDED 0x00000004 // temporarily suspended
#define DBGKD_INTERNAL_BP_FLAG_DYING     0x00000008 // kill on exit


//
// The packet protocol was widened to 64 bits in version 5.
// The PTR64 flag allows the debugger to read the right
// size of pointer when neccessary.
//
// The version packet was changed in the same revision, to remove the
// data that are now available in KDDEBUGGER_DATA.
//
#define DBGKD_64BIT_PROTOCOL_VERSION 5


#ifndef DBGKD_GET_VERSION_DEFINED
#define DBGKD_GET_VERSION_DEFINED
//
// The following structures have changed in more than pointer size.
//
//
// This is the version packet for pre-NT5 Beta 2 systems.
// For now, it is also still used on x86
//
typedef struct _DBGKD_GET_VERSION32 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    ULONG   KernBase;
    ULONG   PsLoadedModuleList;

    USHORT  MachineType;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // Address of the kernel callout routine.
    //

    ULONG   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    //
    // DbgBreakPointWithStatus is a function which takes a ULONG argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG   BreakpointWithStatus;       // address of breakpoint

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //

    ULONG   DebuggerDataList;

} DBGKD_GET_VERSION32, *PDBGKD_GET_VERSION32;



typedef struct _DBGKD_GET_VERSION64 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    USHORT  MachineType;

    USHORT  Unused[3];

    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //
    // There will always be an entry for the debugger.
    //

    ULONG64 DebuggerDataList;

} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;


//
// If DBGKD_VERS_FLAG_DATA is set in Flags, info should be retrieved from
// the KDDEBUGGER_DATA block rather than from the DBGKD_GET_VERSION
// packet.  The data will remain in the version packet for a while to
// reduce compatibility problems.
//

#define DBGKD_VERS_FLAG_MP      0x0001      // kernel is MP built
#define DBGKD_VERS_FLAG_DATA    0x0002      // DebuggerDataList is valid
#define DBGKD_VERS_FLAG_PTR64   0x0004      // native pointers are 64 bits
#define DBGKD_VERS_FLAG_NOMM    0x0008      // No MM - don't decode PTEs

#define KDBG_TAG    'GBDK'

typedef struct _DBGKD_DEBUG_DATA_HEADER32 {

    //
    // Link to other blocks
    //

    LIST_ENTRY32 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER32, *PDBGKD_DEBUG_DATA_HEADER32;




//
// DO NOT CHANGE THIS STRUCTURE!
// ONLY MAKE CHAGES TO THE 64 BIT VERSION ABOVE!!
//
// This is the debugger data packet for pre NT5 Beta 2 systems.
// For now, it is still used on x86
//
typedef struct _KDDEBUGGER_DATA32 {

    DBGKD_DEBUG_DATA_HEADER32 Header;

    //
    // Base address of kernel image
    //

    ULONG   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    USHORT  PaeEnabled:1;

    //
    // Address of the kernel callout routine.
    //

    ULONG   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG   PsLoadedModuleList;
    ULONG   PsActiveProcessHead;
    ULONG   PspCidTable;

    ULONG   ExpSystemResourcesList;
    ULONG   ExpPagedPoolDescriptor;
    ULONG   ExpNumberOfPagedPools;

    ULONG   KeTimeIncrement;
    ULONG   KeBugCheckCallbackListHead;
    ULONG   KiBugcheckData;

    ULONG   IopErrorLogListHead;

    ULONG   ObpRootDirectoryObject;
    ULONG   ObpTypeObjectType;

    ULONG   MmSystemCacheStart;
    ULONG   MmSystemCacheEnd;
    ULONG   MmSystemCacheWs;

    ULONG   MmPfnDatabase;
    ULONG   MmSystemPtesStart;
    ULONG   MmSystemPtesEnd;
    ULONG   MmSubsectionBase;
    ULONG   MmNumberOfPagingFiles;

    ULONG   MmLowestPhysicalPage;
    ULONG   MmHighestPhysicalPage;
    ULONG   MmNumberOfPhysicalPages;

    ULONG   MmMaximumNonPagedPoolInBytes;
    ULONG   MmNonPagedSystemStart;
    ULONG   MmNonPagedPoolStart;
    ULONG   MmNonPagedPoolEnd;

    ULONG   MmPagedPoolStart;
    ULONG   MmPagedPoolEnd;
    ULONG   MmPagedPoolInformation;
    ULONG   MmPageSize;

    ULONG   MmSizeOfPagedPoolInBytes;

    ULONG   MmTotalCommitLimit;
    ULONG   MmTotalCommittedPages;
    ULONG   MmSharedCommit;
    ULONG   MmDriverCommit;
    ULONG   MmProcessCommit;
    ULONG   MmPagedPoolCommit;
    ULONG   MmExtendedCommit;

    ULONG   MmZeroedPageListHead;
    ULONG   MmFreePageListHead;
    ULONG   MmStandbyPageListHead;
    ULONG   MmModifiedPageListHead;
    ULONG   MmModifiedNoWritePageListHead;
    ULONG   MmAvailablePages;
    ULONG   MmResidentAvailablePages;

    ULONG   PoolTrackTable;
    ULONG   NonPagedPoolDescriptor;

    ULONG   MmHighestUserAddress;
    ULONG   MmSystemRangeStart;
    ULONG   MmUserProbeAddress;

    ULONG   KdPrintCircularBuffer;
    ULONG   KdPrintCircularBufferEnd;
    ULONG   KdPrintWritePointer;
    ULONG   KdPrintRolloverCount;

    ULONG   MmLoadedUserImageList;
} KDDEBUGGER_DATA32, *PKDDEBUGGER_DATA32;

//
// DO NOT CHANGE KDDEBUGGER_DATA32!!
// ONLY MAKE CHANGES TO KDDEBUGGER_DATA64!!!
//




//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;


//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled:1;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;
} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;

#endif

__inline
void
DbgkdGetVersion32To64(
    IN PDBGKD_GET_VERSION32 vs32,
    OUT PDBGKD_GET_VERSION64 vs64,
    OUT PKDDEBUGGER_DATA64 dd64
    )
{
    vs64->MajorVersion = vs32->MajorVersion;
    vs64->MinorVersion = vs32->MinorVersion;
    vs64->ProtocolVersion = vs32->ProtocolVersion;
    vs64->Flags = vs32->Flags;
    vs64->MachineType = vs32->MachineType;
    COPYSE(vs64,vs32,PsLoadedModuleList);
    COPYSE(vs64,vs32,DebuggerDataList);
    COPYSE(vs64,vs32,KernBase);

    COPYSE(dd64,vs32,KernBase);
    COPYSE(dd64,vs32,PsLoadedModuleList);
    dd64->ThCallbackStack = vs32->ThCallbackStack;
    dd64->NextCallback = vs32->NextCallback;
    dd64->FramePointer = vs32->FramePointer;
    COPYSE(dd64,vs32,KiCallUserMode);
    COPYSE(dd64,vs32,KeUserCallbackDispatcher);
    COPYSE(dd64,vs32,BreakpointWithStatus);

}

__inline
void
DbgkdGetVersion64To32(
    IN PDBGKD_GET_VERSION64 vs64,
    IN PKDDEBUGGER_DATA64 dd64,
    OUT PDBGKD_GET_VERSION32 vs32
    )
{
    vs32->MajorVersion = vs64->MajorVersion;
    vs32->MinorVersion = vs64->MinorVersion;
    vs32->ProtocolVersion = vs64->ProtocolVersion;
    vs32->Flags = vs64->Flags;

    vs32->KernBase = (ULONG)vs64->KernBase;
    vs32->PsLoadedModuleList = (ULONG)vs64->PsLoadedModuleList;

    vs32->MachineType = vs64->MachineType;

    vs32->DebuggerDataList = (ULONG)vs64->DebuggerDataList;

    vs32->ThCallbackStack = dd64->ThCallbackStack;
    vs32->NextCallback = dd64->NextCallback;
    vs32->FramePointer = dd64->FramePointer;

    vs32->KiCallUserMode = (ULONG)dd64->KiCallUserMode;
    vs32->KeUserCallbackDispatcher = (ULONG)dd64->KeUserCallbackDispatcher;
    vs32->BreakpointWithStatus = (ULONG)dd64->BreakpointWithStatus;
}

__inline
void
DebuggerDataHeader32To64(
    IN  PDBGKD_DEBUG_DATA_HEADER32 Dd32,
    OUT PDBGKD_DEBUG_DATA_HEADER64 Dd64
    )
{
#define UIP(f) Dd64->f = (ULONG64)(LONG64)(LONG)Dd32->f
#define CP(f) Dd64->f = Dd32->f

    UIP(List.Flink);
    UIP(List.Blink);
    CP(OwnerTag);
    Dd64->Size = sizeof(KDDEBUGGER_DATA64);

#undef UIP
#undef CP
}

__inline
void
DebuggerDataHeader64To32(
    IN  PDBGKD_DEBUG_DATA_HEADER64 Dd64,
    OUT PDBGKD_DEBUG_DATA_HEADER32 Dd32
    )
{
#define UIP(f) Dd32->f = (ULONG)Dd64->f
#define CP(f) Dd32->f = Dd64->f

    UIP(List.Flink);
    UIP(List.Blink);
    CP(OwnerTag);
    Dd32->Size = sizeof(KDDEBUGGER_DATA32);

#undef UIP
#undef CP
}

__inline
void
DebuggerData32To64(
    IN PKDDEBUGGER_DATA32 Dd32,
    OUT PKDDEBUGGER_DATA64 Dd64
    )
{
#define UIP(f) Dd64->f = (ULONG64)(LONG64)(LONG)Dd32->f
#define CP(f) Dd64->f = Dd32->f

    DebuggerDataHeader32To64(&Dd32->Header, &Dd64->Header);

    UIP(KernBase);
    UIP(BreakpointWithStatus);
    UIP(SavedContext);
    CP(ThCallbackStack);
    CP(NextCallback);
    CP(FramePointer);
    CP(PaeEnabled);
    UIP(KiCallUserMode);
    UIP(KeUserCallbackDispatcher);
    UIP(PsLoadedModuleList);
    UIP(PsActiveProcessHead);
    UIP(PspCidTable);
    UIP(ExpSystemResourcesList);
    UIP(ExpPagedPoolDescriptor);
    UIP(ExpNumberOfPagedPools);
    UIP(KeTimeIncrement);
    UIP(KeBugCheckCallbackListHead);
    UIP(KiBugcheckData);
    UIP(IopErrorLogListHead);
    UIP(ObpRootDirectoryObject);
    UIP(ObpTypeObjectType);
    UIP(MmSystemCacheStart);
    UIP(MmSystemCacheEnd);
    UIP(MmSystemCacheWs);
    UIP(MmPfnDatabase);
    UIP(MmSystemPtesStart);
    UIP(MmSystemPtesEnd);
    UIP(MmSubsectionBase);
    UIP(MmNumberOfPagingFiles);
    UIP(MmLowestPhysicalPage);
    UIP(MmHighestPhysicalPage);
    UIP(MmNumberOfPhysicalPages);
    UIP(MmMaximumNonPagedPoolInBytes);
    UIP(MmNonPagedSystemStart);
    UIP(MmNonPagedPoolStart);
    UIP(MmNonPagedPoolEnd);
    UIP(MmPagedPoolStart);
    UIP(MmPagedPoolEnd);
    UIP(MmPagedPoolInformation);
    CP(MmPageSize);
    UIP(MmSizeOfPagedPoolInBytes);
    UIP(MmTotalCommitLimit);
    UIP(MmTotalCommittedPages);
    UIP(MmSharedCommit);
    UIP(MmDriverCommit);
    UIP(MmProcessCommit);
    UIP(MmPagedPoolCommit);
    UIP(MmExtendedCommit);
    UIP(MmZeroedPageListHead);
    UIP(MmFreePageListHead);
    UIP(MmStandbyPageListHead);
    UIP(MmModifiedPageListHead);
    UIP(MmModifiedNoWritePageListHead);
    UIP(MmAvailablePages);
    UIP(MmResidentAvailablePages);
    UIP(PoolTrackTable);
    UIP(NonPagedPoolDescriptor);
    UIP(MmHighestUserAddress);
    UIP(MmSystemRangeStart);
    UIP(MmUserProbeAddress);
    UIP(KdPrintCircularBuffer);
    UIP(KdPrintCircularBufferEnd);
    UIP(KdPrintWritePointer);
    UIP(KdPrintRolloverCount);
    UIP(MmLoadedUserImageList);

#undef UIP
#undef CP
}

__inline
void
DebuggerData64To32(
    IN PKDDEBUGGER_DATA64 Dd64,
    OUT PKDDEBUGGER_DATA32 Dd32
    )
{
#define UIP(f) Dd32->f = (ULONG)Dd64->f
#define CP(f) Dd32->f = Dd64->f

    DebuggerDataHeader64To32(&Dd64->Header, &Dd32->Header);

    UIP(KernBase);
    UIP(BreakpointWithStatus);
    UIP(SavedContext);
    CP(ThCallbackStack);
    CP(NextCallback);
    CP(FramePointer);
    CP(PaeEnabled);
    UIP(KiCallUserMode);
    UIP(KeUserCallbackDispatcher);
    UIP(PsLoadedModuleList);
    UIP(PsActiveProcessHead);
    UIP(PspCidTable);
    UIP(ExpSystemResourcesList);
    UIP(ExpPagedPoolDescriptor);
    UIP(ExpNumberOfPagedPools);
    UIP(KeTimeIncrement);
    UIP(KeBugCheckCallbackListHead);
    UIP(KiBugcheckData);
    UIP(IopErrorLogListHead);
    UIP(ObpRootDirectoryObject);
    UIP(ObpTypeObjectType);
    UIP(MmSystemCacheStart);
    UIP(MmSystemCacheEnd);
    UIP(MmSystemCacheWs);
    UIP(MmPfnDatabase);
    UIP(MmSystemPtesStart);
    UIP(MmSystemPtesEnd);
    UIP(MmSubsectionBase);
    UIP(MmNumberOfPagingFiles);
    UIP(MmLowestPhysicalPage);
    UIP(MmHighestPhysicalPage);
    UIP(MmNumberOfPhysicalPages);
    UIP(MmMaximumNonPagedPoolInBytes);
    UIP(MmNonPagedSystemStart);
    UIP(MmNonPagedPoolStart);
    UIP(MmNonPagedPoolEnd);
    UIP(MmPagedPoolStart);
    UIP(MmPagedPoolEnd);
    UIP(MmPagedPoolInformation);
    UIP(MmPageSize);
    UIP(MmSizeOfPagedPoolInBytes);
    UIP(MmTotalCommitLimit);
    UIP(MmTotalCommittedPages);
    UIP(MmSharedCommit);
    UIP(MmDriverCommit);
    UIP(MmProcessCommit);
    UIP(MmPagedPoolCommit);
    UIP(MmExtendedCommit);
    UIP(MmZeroedPageListHead);
    UIP(MmFreePageListHead);
    UIP(MmStandbyPageListHead);
    UIP(MmModifiedPageListHead);
    UIP(MmModifiedNoWritePageListHead);
    UIP(MmAvailablePages);
    UIP(MmResidentAvailablePages);
    UIP(PoolTrackTable);
    UIP(NonPagedPoolDescriptor);
    UIP(MmHighestUserAddress);
    UIP(MmSystemRangeStart);
    UIP(MmUserProbeAddress);
    UIP(KdPrintCircularBuffer);
    UIP(KdPrintCircularBufferEnd);
    UIP(KdPrintWritePointer);
    UIP(KdPrintRolloverCount);
    UIP(MmLoadedUserImageList);

#undef UIP
#undef CP
}

typedef struct _DBGKD_SEARCH_MEMORY {
    union {
        ULONG64 SearchAddress;
        ULONG64 FoundAddress;
    };
    ULONG64 SearchLength;
    ULONG PatternLength;
} DBGKD_SEARCH_MEMORY, *PDBGKD_SEARCH_MEMORY;


typedef struct _DBGKD_GET_SET_BUS_DATA {
    ULONG BusDataType;
    ULONG BusNumber;
    ULONG SlotNumber;
    ULONG Offset;
    ULONG Length;
} DBGKD_GET_SET_BUS_DATA, *PDBGKD_GET_SET_BUS_DATA;


#include <pshpack4.h>

typedef struct _DBGKD_MANIPULATE_STATE32 {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    NTSTATUS ReturnStatus;
    union {
        DBGKD_READ_MEMORY32 ReadMemory;
        DBGKD_WRITE_MEMORY32 WriteMemory;
        DBGKD_READ_MEMORY64 ReadMemory64;
        DBGKD_WRITE_MEMORY64 WriteMemory64;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT32 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO32 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED32 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL32 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT32 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT32 GetInternalBreakpoint;
        DBGKD_GET_VERSION32 GetVersion32;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
    } u;
} DBGKD_MANIPULATE_STATE32, *PDBGKD_MANIPULATE_STATE32;

#include <poppack.h>


typedef struct _DBGKD_MANIPULATE_STATE64 {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    NTSTATUS ReturnStatus;
    union {
        DBGKD_READ_MEMORY64 ReadMemory;
        DBGKD_WRITE_MEMORY64 WriteMemory;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT64 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO64 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED64 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL64 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT64 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT64 GetInternalBreakpoint;
        DBGKD_GET_VERSION64 GetVersion64;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
        DBGKD_GET_SET_BUS_DATA GetSetBusData;
    } u;
} DBGKD_MANIPULATE_STATE64, *PDBGKD_MANIPULATE_STATE64;

__inline
ULONG
DbgkdManipulateState32To64(
    IN PDBGKD_MANIPULATE_STATE32 r32,
    OUT PDBGKD_MANIPULATE_STATE64 r64,
    OUT PULONG AdditionalDataSize
    )
{
    r64->ApiNumber = r32->ApiNumber;
    r64->ProcessorLevel = r32->ProcessorLevel;
    r64->Processor = r32->Processor;
    r64->ReturnStatus = r32->ReturnStatus;

    *AdditionalDataSize = 0;

    //
    // translate the messages which may be sent by the kernel
    //

    switch (r64->ApiNumber) {

        case DbgKdSetContextApi:
        case DbgKdRestoreBreakPointApi:
        case DbgKdContinueApi:
        case DbgKdContinueApi2:
        case DbgKdRebootApi:
        case DbgKdClearSpecialCallsApi:
        case DbgKdRestoreBreakPointExApi:
        case DbgKdCauseBugCheckApi:
        case DbgKdSwitchProcessor:
        case DbgKdWriteMachineSpecificRegister:
        case DbgKdWriteIoSpaceApi:
        case DbgKdSetSpecialCallApi:
        case DbgKdSetInternalBreakPointApi:
        case DbgKdWriteIoSpaceExtendedApi:
            break;



        case DbgKdReadMachineSpecificRegister:
            r64->u.ReadWriteMsr = r32->u.ReadWriteMsr;
            break;

        //
        // GetVersion may need to be handled by the calling code;
        // it needs to call DbgkdGetVersion32To64 with the DebuggerDataBlock.
        //

        case DbgKdGetVersionApi:
            break;

        case DbgKdGetContextApi:
            *AdditionalDataSize = sizeof(CONTEXT);
            break;

        //case DbgKdQuerySpecialCallsApi:
        //    r64->u.QuerySpecialCalls = r32->u.QuerySpecialCalls;
        //    *AdditionalDataSize = r64->u.QuerySpecialCalls.NumberOfSpecialCalls * sizeof(ULONG);
        //    break;

        case DbgKdWriteBreakPointExApi:
            r64->u.BreakPointEx = r32->u.BreakPointEx;
            *AdditionalDataSize = r64->u.BreakPointEx.BreakPointCount * sizeof(ULONG);
            break;

        case DbgKdReadVirtualMemoryApi:
        case DbgKdReadPhysicalMemoryApi:
        case DbgKdReadControlSpaceApi:
            DbgkdReadMemory32To64(&r32->u.ReadMemory, &r64->u.ReadMemory);
            if (NT_SUCCESS(r32->ReturnStatus)) {
                *AdditionalDataSize = r64->u.ReadMemory.ActualBytesRead;
            }
            break;

        case DbgKdWriteVirtualMemoryApi:
        case DbgKdWritePhysicalMemoryApi:
        case DbgKdWriteControlSpaceApi:
            DbgkdWriteMemory32To64(&r32->u.WriteMemory, &r64->u.WriteMemory);
            break;



        case DbgKdWriteBreakPointApi:
            DbgkdWriteBreakpoint32To64(&r32->u.WriteBreakPoint, &r64->u.WriteBreakPoint);
            break;

        case DbgKdReadIoSpaceApi:
            DbgkdReadWriteIo32To64(&r32->u.ReadWriteIo, &r64->u.ReadWriteIo);
            break;

        case DbgKdReadIoSpaceExtendedApi:
            DbgkdReadWriteIoExtended32To64(&r32->u.ReadWriteIoExtended, &r64->u.ReadWriteIoExtended);
            break;

        case DbgKdGetInternalBreakPointApi:
            DbgkdGetInternalBreakpoint32To64(&r32->u.GetInternalBreakpoint, &r64->u.GetInternalBreakpoint);
            break;

        case DbgKdSearchMemoryApi:
            r64->u.SearchMemory = r32->u.SearchMemory;
            break;
    }

    return sizeof(DBGKD_MANIPULATE_STATE64);
}

__inline
ULONG
DbgkdManipulateState64To32(
    IN PDBGKD_MANIPULATE_STATE64 r64,
    OUT PDBGKD_MANIPULATE_STATE32 r32
    )
{
    r32->ApiNumber = r64->ApiNumber;
    r32->ProcessorLevel = r64->ProcessorLevel;
    r32->Processor = r64->Processor;
    r32->ReturnStatus = r64->ReturnStatus;

    //
    // translate the messages sent by the debugger
    //

    switch (r32->ApiNumber) {

        //
        // These send nothing in the u part.
        case DbgKdGetContextApi:
        case DbgKdSetContextApi:
        case DbgKdClearSpecialCallsApi:
        case DbgKdRebootApi:
        case DbgKdCauseBugCheckApi:
        case DbgKdSwitchProcessor:
            break;


        case DbgKdRestoreBreakPointApi:
            r32->u.RestoreBreakPoint = r64->u.RestoreBreakPoint;
            break;

        case DbgKdContinueApi:
            r32->u.Continue = r64->u.Continue;
            break;

        case DbgKdContinueApi2:
            r32->u.Continue2 = r64->u.Continue2;
            break;

        //case DbgKdQuerySpecialCallsApi:
        //    r32->u.QuerySpecialCalls = r64->u.QuerySpecialCalls;
        //    break;

        case DbgKdRestoreBreakPointExApi:
            // NYI
            break;

        case DbgKdReadMachineSpecificRegister:
        case DbgKdWriteMachineSpecificRegister:
            r32->u.ReadWriteMsr = r64->u.ReadWriteMsr;
            break;

        case DbgKdGetVersionApi:
            r32->u.GetVersion32.ProtocolVersion = r64->u.GetVersion64.ProtocolVersion;
            break;

        case DbgKdWriteBreakPointExApi:
            r32->u.BreakPointEx = r64->u.BreakPointEx;
            break;

        case DbgKdWriteVirtualMemoryApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        //
        // 32 bit systems only support 32 bit physical r/w
        //
        case DbgKdReadControlSpaceApi:
        case DbgKdReadVirtualMemoryApi:
        case DbgKdReadPhysicalMemoryApi:
            DbgkdReadMemory64To32(&r64->u.ReadMemory, &r32->u.ReadMemory);
            break;

        case DbgKdWritePhysicalMemoryApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        case DbgKdWriteBreakPointApi:
            DbgkdWriteBreakpoint64To32(&r64->u.WriteBreakPoint, &r32->u.WriteBreakPoint);
            break;

        case DbgKdWriteControlSpaceApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        case DbgKdReadIoSpaceApi:
        case DbgKdWriteIoSpaceApi:
            DbgkdReadWriteIo64To32(&r64->u.ReadWriteIo, &r32->u.ReadWriteIo);
            break;

        case DbgKdSetSpecialCallApi:
            DbgkdSetSpecialCall64To32(&r64->u.SetSpecialCall, &r32->u.SetSpecialCall);
            break;

        case DbgKdSetInternalBreakPointApi:
            DbgkdSetInternalBreakpoint64To32(&r64->u.SetInternalBreakpoint, &r32->u.SetInternalBreakpoint);
            break;

        case DbgKdGetInternalBreakPointApi:
            DbgkdGetInternalBreakpoint64To32(&r64->u.GetInternalBreakpoint, &r32->u.GetInternalBreakpoint);
            break;

        case DbgKdReadIoSpaceExtendedApi:
        case DbgKdWriteIoSpaceExtendedApi:
            DbgkdReadWriteIoExtended64To32(&r64->u.ReadWriteIoExtended, &r32->u.ReadWriteIoExtended);
            break;

        case DbgKdSearchMemoryApi:
            r32->u.SearchMemory = r64->u.SearchMemory;
            break;
    }

    return sizeof(DBGKD_MANIPULATE_STATE32);
}

//
// This is the format for the trace data passed back from the kernel to
// the debugger to describe multiple calls that have returned since the
// last trip back.  The basic format is that there are a bunch of these
// (4 byte) unions stuck together.  Each union is of one of two types: a
// 4 byte unsigned long integer, or a three field struct, describing a
// call (where "call" is delimited by returning or exiting the symbol
// scope).  If the number of instructions executed is too big to fit
// into a USHORT -1, then the Instructions field has
// TRACE_DATA_INSTRUCTIONS_BIG and the next union is a LongNumber
// containing the real number of instructions executed.
//
// The very first union returned in each callback is a LongNumber
// containing the number of unions returned (including the "size"
// record, so it's always at least 1 even if there's no data to return).
//
// This is all returned to the debugger when one of two things
// happens:
//
//   1) The pc moves out of all defined symbol ranges
//   2) The buffer of trace data entries is filled.
//
// The "trace done" case is hacked around on the debugger side.  It
// guarantees that the pc address that indicates a trace exit never
// winds up in a defined symbol range.
//
// The only other complexity in this system is handling the SymbolNumber
// table.  This table is kept in parallel by the kernel and the
// debugger.  When the PC exits a known symbol range, the Begin and End
// symbol ranges are set by the debugger and are allocated to the next
// symbol slot upon return.  "The next symbol slot" means the numerical
// next slot number, unless we've filled all slots, in which case it is
// #0.  (ie., allocation is cyclic and not LRU or something).  The
// SymbolNumber table is flushed when a SpecialCalls call is made (ie.,
// at the beginning of the WatchTrace).
//

typedef union _DBGKD_TRACE_DATA {
    struct {
        UCHAR SymbolNumber;
        CHAR LevelChange;
        USHORT Instructions;
    } s;
    ULONG LongNumber;
} DBGKD_TRACE_DATA, *PDBGKD_TRACE_DATA;

#define TRACE_DATA_INSTRUCTIONS_BIG 0xffff

#define TRACE_DATA_BUFFER_MAX_SIZE 40

//
// If the packet type is PACKET_TYPE_KD_DEBUG_IO, then
// the format of the packet data is as follows:
//

#define DbgKdPrintStringApi     0x00003230L
#define DbgKdGetStringApi       0x00003231L

//
// For print string, the Null terminated string to print
// immediately follows the message
//
typedef struct _DBGKD_PRINT_STRING {
    ULONG LengthOfString;
} DBGKD_PRINT_STRING, *PDBGKD_PRINT_STRING;

//
// For get string, the Null terminated prompt string
// immediately follows the message. The LengthOfStringRead
// field initially contains the maximum number of characters
// to read. Upon reply, this contains the number of bytes actually
// read. The data read immediately follows the message.
//
//
typedef struct _DBGKD_GET_STRING {
    ULONG LengthOfPromptString;
    ULONG LengthOfStringRead;
} DBGKD_GET_STRING, *PDBGKD_GET_STRING;

typedef struct _DBGKD_DEBUG_IO {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    union {
        DBGKD_PRINT_STRING PrintString;
        DBGKD_GET_STRING GetString;
    } u;
} DBGKD_DEBUG_IO, *PDBGKD_DEBUG_IO;


// end_windbgkd









typedef struct _KAPC_STATE32 {
    LIST_ENTRY32 ApcListHead[2];
    ULONG Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE32;

typedef struct _KAPC_STATE64 {
    LIST_ENTRY64 ApcListHead[2];
    ULONG64 Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE64;

typedef struct _DISPATCHER_HEADER32 {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY32 WaitListHead;
} DISPATCHER_HEADER32;

typedef struct _DISPATCHER_HEADER64 {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY64 WaitListHead;
} DISPATCHER_HEADER64;

typedef struct _X86_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER32 Header;
    LIST_ENTRY32 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG InitialStack;
    ULONG StackLimit;
    ULONG Teb;
    ULONG TlsArray;
    ULONG KernelStack;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE32 ApcState;
} X86_THREAD;


typedef struct _ALPHA_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER32 Header;
    LIST_ENTRY32 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG InitialStack;
    ULONG StackLimit;
    ULONG Teb;
    ULONG TlsArray;
    ULONG KernelStack;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE32 ApcState;
} ALPHA_THREAD, *PALPHA_THREAD;


typedef struct _AXP64_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER64 Header;
    LIST_ENTRY64 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG64 InitialStack;
    ULONG64 StackLimit;
    ULONG64 Teb;
    ULONG64 TlsArray;
    ULONG64 KernelStack;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE64 ApcState;
} AXP64_THREAD;


typedef struct _IA64_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER64 Header;
    LIST_ENTRY64 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG64 InitialStack;
    ULONG64 StackLimit;
    ULONG64 InitialBStore;
    ULONG64 BStoreLimit;
    ULONG64 Teb;
    ULONG64 TlsArray;
    ULONG64 KernelStack;
    ULONG64 KernelBStore;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE64 ApcState;
} IA64_THREAD;


typedef struct _CROSS_PLATFORM_THREAD {

    union {
        X86_THREAD   X86Thread;
        ALPHA_THREAD AlphaThread;
        AXP64_THREAD Axp64Thread;
        IA64_THREAD  IA64Thread;
    };

} CROSS_PLATFORM_THREAD, *PCROSS_PLATFORM_THREAD;



//
// Special Registers for i386
//

typedef struct _X86_DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} X86_DESCRIPTOR, *PX86_DESCRIPTOR;

typedef struct _X86_KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    X86_DESCRIPTOR Gdtr;
    X86_DESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} X86_KSPECIAL_REGISTERS, *PX86_KSPECIAL_REGISTERS;


//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define X86_SIZE_OF_80387_REGISTERS      80

typedef struct _X86_FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[X86_SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} X86_FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _X86_CONTEXT {

    ULONG ContextFlags;
    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;
    X86_FLOATING_SAVE_AREA FloatSave;
    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;
    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;
    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} X86_CONTEXT, *PX86_CONTEXT;

#define MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _X86_NT5_CONTEXT {

    ULONG ContextFlags;
    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;
    X86_FLOATING_SAVE_AREA FloatSave;
    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;
    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;
    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;
    UCHAR   ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} X86_NT5_CONTEXT, *PX86_NT5_CONTEXT;

typedef struct _ALPHA_CONTEXT {

    ULONG FltF0;
    ULONG FltF1;
    ULONG FltF2;
    ULONG FltF3;
    ULONG FltF4;
    ULONG FltF5;
    ULONG FltF6;
    ULONG FltF7;
    ULONG FltF8;
    ULONG FltF9;
    ULONG FltF10;
    ULONG FltF11;
    ULONG FltF12;
    ULONG FltF13;
    ULONG FltF14;
    ULONG FltF15;
    ULONG FltF16;
    ULONG FltF17;
    ULONG FltF18;
    ULONG FltF19;
    ULONG FltF20;
    ULONG FltF21;
    ULONG FltF22;
    ULONG FltF23;
    ULONG FltF24;
    ULONG FltF25;
    ULONG FltF26;
    ULONG FltF27;
    ULONG FltF28;
    ULONG FltF29;
    ULONG FltF30;
    ULONG FltF31;

    ULONG IntV0;        //  $0: return value register, v0
    ULONG IntT0;        //  $1: temporary registers, t0 - t7
    ULONG IntT1;        //  $2:
    ULONG IntT2;        //  $3:
    ULONG IntT3;        //  $4:
    ULONG IntT4;        //  $5:
    ULONG IntT5;        //  $6:
    ULONG IntT6;        //  $7:
    ULONG IntT7;        //  $8:
    ULONG IntS0;        //  $9: nonvolatile registers, s0 - s5
    ULONG IntS1;        // $10:
    ULONG IntS2;        // $11:
    ULONG IntS3;        // $12:
    ULONG IntS4;        // $13:
    ULONG IntS5;        // $14:
    ULONG IntFp;        // $15: frame pointer register, fp/s6
    ULONG IntA0;        // $16: argument registers, a0 - a5
    ULONG IntA1;        // $17:
    ULONG IntA2;        // $18:
    ULONG IntA3;        // $19:
    ULONG IntA4;        // $20:
    ULONG IntA5;        // $21:
    ULONG IntT8;        // $22: temporary registers, t8 - t11
    ULONG IntT9;        // $23:
    ULONG IntT10;       // $24:
    ULONG IntT11;       // $25:
    ULONG IntRa;        // $26: return address register, ra
    ULONG IntT12;       // $27: temporary register, t12
    ULONG IntAt;        // $28: assembler temp register, at
    ULONG IntGp;        // $29: global pointer register, gp
    ULONG IntSp;        // $30: stack pointer register, sp
    ULONG IntZero;      // $31: zero register, zero

    ULONG Fpcr;         // floating point control register
    ULONG SoftFpcr;     // software extension to FPCR

    ULONG Fir;          // (fault instruction) continuation address

    ULONG Psr;          // processor status
    ULONG ContextFlags;

    //
    // Beginning of the "second half".
    // The name "High" parallels the HighPart of a LargeInteger.
    //

    ULONG HighFltF0;
    ULONG HighFltF1;
    ULONG HighFltF2;
    ULONG HighFltF3;
    ULONG HighFltF4;
    ULONG HighFltF5;
    ULONG HighFltF6;
    ULONG HighFltF7;
    ULONG HighFltF8;
    ULONG HighFltF9;
    ULONG HighFltF10;
    ULONG HighFltF11;
    ULONG HighFltF12;
    ULONG HighFltF13;
    ULONG HighFltF14;
    ULONG HighFltF15;
    ULONG HighFltF16;
    ULONG HighFltF17;
    ULONG HighFltF18;
    ULONG HighFltF19;
    ULONG HighFltF20;
    ULONG HighFltF21;
    ULONG HighFltF22;
    ULONG HighFltF23;
    ULONG HighFltF24;
    ULONG HighFltF25;
    ULONG HighFltF26;
    ULONG HighFltF27;
    ULONG HighFltF28;
    ULONG HighFltF29;
    ULONG HighFltF30;
    ULONG HighFltF31;

    ULONG HighIntV0;        //  $0: return value register, v0
    ULONG HighIntT0;        //  $1: temporary registers, t0 - t7
    ULONG HighIntT1;        //  $2:
    ULONG HighIntT2;        //  $3:
    ULONG HighIntT3;        //  $4:
    ULONG HighIntT4;        //  $5:
    ULONG HighIntT5;        //  $6:
    ULONG HighIntT6;        //  $7:
    ULONG HighIntT7;        //  $8:
    ULONG HighIntS0;        //  $9: nonvolatile registers, s0 - s5
    ULONG HighIntS1;        // $10:
    ULONG HighIntS2;        // $11:
    ULONG HighIntS3;        // $12:
    ULONG HighIntS4;        // $13:
    ULONG HighIntS5;        // $14:
    ULONG HighIntFp;        // $15: frame pointer register, fp/s6
    ULONG HighIntA0;        // $16: argument registers, a0 - a5
    ULONG HighIntA1;        // $17:
    ULONG HighIntA2;        // $18:
    ULONG HighIntA3;        // $19:
    ULONG HighIntA4;        // $20:
    ULONG HighIntA5;        // $21:
    ULONG HighIntT8;        // $22: temporary registers, t8 - t11
    ULONG HighIntT9;        // $23:
    ULONG HighIntT10;       // $24:
    ULONG HighIntT11;       // $25:
    ULONG HighIntRa;        // $26: return address register, ra
    ULONG HighIntT12;       // $27: temporary register, t12
    ULONG HighIntAt;        // $28: assembler temp register, at
    ULONG HighIntGp;        // $29: global pointer register, gp
    ULONG HighIntSp;        // $30: stack pointer register, sp
    ULONG HighIntZero;      // $31: zero register, zero

    ULONG HighFpcr;         // floating point control register
    ULONG HighSoftFpcr;     // software extension to FPCR
    ULONG HighFir;          // processor status

    double DoNotUseThisField; // to force quadword structure alignment
    ULONG HighFill[2];      // padding for 16-byte stack frame alignment


} ALPHA_CONTEXT, *PALPHA_CONTEXT;


typedef struct _ALPHA_NT5_CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG FltF0;
    ULONGLONG FltF1;
    ULONGLONG FltF2;
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;
    ULONGLONG FltF10;
    ULONGLONG FltF11;
    ULONGLONG FltF12;
    ULONGLONG FltF13;
    ULONGLONG FltF14;
    ULONGLONG FltF15;
    ULONGLONG FltF16;
    ULONGLONG FltF17;
    ULONGLONG FltF18;
    ULONGLONG FltF19;
    ULONGLONG FltF20;
    ULONGLONG FltF21;
    ULONGLONG FltF22;
    ULONGLONG FltF23;
    ULONGLONG FltF24;
    ULONGLONG FltF25;
    ULONGLONG FltF26;
    ULONGLONG FltF27;
    ULONGLONG FltF28;
    ULONGLONG FltF29;
    ULONGLONG FltF30;
    ULONGLONG FltF31;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, and ra are defined in this section, but are
    //  considered part of the control context rather than part of the integer
    //  context.
    //

    ULONGLONG IntV0;    //  $0: return value register, v0
    ULONGLONG IntT0;    //  $1: temporary registers, t0 - t7
    ULONGLONG IntT1;    //  $2:
    ULONGLONG IntT2;    //  $3:
    ULONGLONG IntT3;    //  $4:
    ULONGLONG IntT4;    //  $5:
    ULONGLONG IntT5;    //  $6:
    ULONGLONG IntT6;    //  $7:
    ULONGLONG IntT7;    //  $8:
    ULONGLONG IntS0;    //  $9: nonvolatile registers, s0 - s5
    ULONGLONG IntS1;    // $10:
    ULONGLONG IntS2;    // $11:
    ULONGLONG IntS3;    // $12:
    ULONGLONG IntS4;    // $13:
    ULONGLONG IntS5;    // $14:
    ULONGLONG IntFp;    // $15: frame pointer register, fp/s6
    ULONGLONG IntA0;    // $16: argument registers, a0 - a5
    ULONGLONG IntA1;    // $17:
    ULONGLONG IntA2;    // $18:
    ULONGLONG IntA3;    // $19:
    ULONGLONG IntA4;    // $20:
    ULONGLONG IntA5;    // $21:
    ULONGLONG IntT8;    // $22: temporary registers, t8 - t11
    ULONGLONG IntT9;    // $23:
    ULONGLONG IntT10;   // $24:
    ULONGLONG IntT11;   // $25:
    ULONGLONG IntRa;    // $26: return address register, ra
    ULONGLONG IntT12;   // $27: temporary register, t12
    ULONGLONG IntAt;    // $28: assembler temp register, at
    ULONGLONG IntGp;    // $29: global pointer register, gp
    ULONGLONG IntSp;    // $30: stack pointer register, sp
    ULONGLONG IntZero;  // $31: zero register, zero

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG Fpcr;     // floating point control register
    ULONGLONG SoftFpcr; // software extension to FPCR

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //
    // N.B. The registers gp, sp, and ra are defined in the integer section,
    //   but are considered part of the control context rather than part of
    //   the integer context.
    //

    ULONGLONG Fir;      // (fault instruction) continuation address
    ULONG Psr;          // processor status

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill[4];      // padding for 16-byte stack frame alignment

} ALPHA_NT5_CONTEXT, *PALPHA_NT5_CONTEXT;

















































































































































































typedef struct _IA64_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill1[3];         // for alignment of following on 16-byte boundary

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_DEBUG.
    //
    // N.B. CONTEXT_DEBUG is *not* part of CONTEXT_FULL.
    //

// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT


















    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT.
    //
















    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_HIGHER_FLOATING_POINT.
    //




























































































































    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT | CONTEXT_CONTROL.
    //



    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, rp are part of the control context
    //














































    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    // Other application registers






    // Register stack info






    // Trap Status Information




    // iA32 related control registers










// @@END_DDKSPLIT

} IA64_CONTEXT, *PIA64_CONTEXT;


typedef struct _CROSS_PLATFORM_CONTEXT {

    union {
        X86_CONTEXT       X86Context;
        X86_NT5_CONTEXT   X86Nt5Context;
        ALPHA_CONTEXT     AlphaContext;
        ALPHA_NT5_CONTEXT AlphaNt5Context;
        IA64_CONTEXT      IA64Context;
    };

} CROSS_PLATFORM_CONTEXT, *PCROSS_PLATFORM_CONTEXT;


typedef struct _X86_KPROCESSOR_STATE {
    struct _X86_CONTEXT ContextFrame;
    struct _X86_KSPECIAL_REGISTERS SpecialRegisters;
} X86_KPROCESSOR_STATE, *PX86_KPROCESSOR_STATE;

typedef struct _X86_NT5_KPROCESSOR_STATE {
    struct _X86_NT5_CONTEXT ContextFrame;
    struct _X86_KSPECIAL_REGISTERS SpecialRegisters;
} X86_NT5_KPROCESSOR_STATE, *PX86_NT5_KPROCESSOR_STATE;


typedef struct _ALPHA_NT5_KPROCESSOR_STATE {
    struct _ALPHA_NT5_CONTEXT ContextFrame;
} ALPHA_NT5_KPROCESSOR_STATE, *PALPHA_NT5_KPROCESSOR_STATE;


typedef struct _IA64_KPROCESSOR_STATE {
    struct _IA64_CONTEXT ContextFrame;
} IA64_KPROCESSOR_STATE, *PIA64_KPROCESSOR_STATE;



//
//  LDT descriptor entry
//

typedef struct _X86_LDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} X86_LDT_ENTRY, *PX86_LDT_ENTRY;

typedef struct _X86_DESCRIPTOR_TABLE_ENTRY {
    ULONG Selector;
    X86_LDT_ENTRY Descriptor;
} X86_DESCRIPTOR_TABLE_ENTRY, *PX86_DESCRIPTOR_TABLE_ENTRY;

typedef struct _X86_KTRAP_FRAME {


//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Debug registers.
//

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

//
//  Segment registers
//

    ULONG   SegGs;
    ULONG   SegEs;
    ULONG   SegDs;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    ULONG   PreviousPreviousMode;

    ULONG   ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  FS is TIB/PCR pointer, is here to make save sequence easy
//

    ULONG   SegFs;

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.

    ULONG   V86Es;          // these will be present for all transitions from
    ULONG   V86Ds;          // V86 mode
    ULONG   V86Fs;
    ULONG   V86Gs;
} X86_KTRAP_FRAME, *PX86_KTRAP_FRAME;


typedef struct _X86_PARTIAL_KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
    USHORT MinorVersion;
    USHORT MajorVersion;

    ULONG CurrentThread;
    ULONG NextThread;
    ULONG IdleThread;

    CCHAR  Number;
    CCHAR  Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;

    CCHAR   CpuType;
    CCHAR   CpuID;
    USHORT  CpuStep;

    X86_KPROCESSOR_STATE ProcessorState;

} X86_PARTIAL_KPRCB, *PX86_PARTIAL_KPRCB;



typedef struct _X86_KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB  NtTib;
    ULONG SelfPcr;              // flat address of this PCR
    ULONG Prcb;                // pointer to Prcb
    KIRQL   Irql;
    ULONG   IRR;
    ULONG   IrrActive;
    ULONG   IDR;
    ULONG   Reserved2;

    ULONG              IDT;
    ULONG              GDT;
    ULONG              TSS;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    KAFFINITY SetMember;
    ULONG   StallScaleFactor;
    UCHAR   DebugActive;
    UCHAR   Number;

    UCHAR   VdmAlert;
    UCHAR   Reserved[1];                // dword align
    ULONG   KernelReserved[15];         // For use by the kernel
    ULONG   SecondLevelCacheSize;
    ULONG   HalReserved[16];            // For use by Hal

// End of the architecturally defined section of the PCR.

    ULONG   InterruptMode;
    UCHAR   Spare1;
    ULONG   KernelReserved2[17];
    struct _X86_PARTIAL_KPRCB PrcbData;

} X86_KPCR, *PX86_KPCR;


typedef struct _ALPHA_PARTIAL_KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;
    ULONG  CurrentThread;
    ULONG NextThread;
    ULONG IdleThread;

    CCHAR  Number;
    CCHAR  Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;

    CCHAR   CpuType;
    CCHAR   CpuID;
    USHORT  CpuStep;

    ALPHA_NT5_KPROCESSOR_STATE ProcessorState;

} ALPHA_PARTIAL_KPRCB, *PALPHA_PARTIAL_KPRCB;


typedef struct _AXP64_PARTIAL_KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;
    ULONG64  CurrentThread;

} AXP64_PARTIAL_KPRCB, *PAXP64_PARTIAL_KPRCB;


typedef struct _IA64_PARTIAL_KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;
    ULONG64  CurrentThread;
    ULONG64 NextThread;
    ULONG64 IdleThread;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;
    ULONG64 RestartBlock;
    ULONG64 PcrPage;
    ULONG Spares1[4];

//
// Space reserved for the system.
//

    ULONGLONG SystemReserved[8];

//
// Space reserved for the HAL.
//

    ULONGLONG HalReserved[16];

//
// End of the architecturally defined section of the PRCB.
// end_nthal end_ntddk
//

    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG KernelTime;
    ULONG UserTime;
    ULONG InterruptCount;
    ULONG DispatchInterruptCount;
    ULONG ApcBypassCount;
    ULONG DpcBypassCount;
    ULONG Spare0[4];

//
// MP information.
//

    ULONG64 Spare1;
    ULONG64 Spare2;
    ULONG64 Spare3;
    volatile ULONG IpiFrozen;
    struct _IA64_KPROCESSOR_STATE ProcessorState;

} IA64_PARTIAL_KPRCB, *PIA64_PARTIAL_KPRCB;



typedef struct _ALPHA_KEXCEPTION_FRAME {

    ULONGLONG IntRa;    // return address register, ra

    ULONGLONG FltF2;    // nonvolatile floating registers, f2 - f9
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;

    ULONGLONG IntS0;    //  nonvolatile integer registers, s0 - s5
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntS4;
    ULONGLONG IntS5;
    ULONGLONG IntFp;    // frame pointer register, fp/s6

    ULONGLONG SwapReturn;
    ULONG Psr;          // processor status
    ULONG Fill[5];      // padding for 32-byte stack frame alignment
                        // N.B. - Ulongs from the filler section are used
                        //        in ctxsw.s - do not delete

} ALPHA_KEXCEPTION_FRAME, *PALPHA_KEXCEPTION_FRAME;

#ifdef _IA64
typedef struct _IA64_KNONVOLATILE_CONTEXT_POINTERS {
// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT



















































// @@END_DDKSPLIT

} IA64_KNONVOLATILE_CONTEXT_POINTERS, *PIA64_KNONVOLATILE_CONTEXT_POINTERS;

typedef struct _IA64_KEXCEPTION_FRAME {

// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT









































// @@END_DDKSPLIT

} IA64_KEXCEPTION_FRAME, *PIA64_KEXCEPTION_FRAME;









    // ULONGLONG Pad;







// @@END_DDKSPLIT

typedef struct _IA64_KTRAP_FRAME {
// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT

    //
    // Reserved for additional memory arguments and stack scratch area
    // The size of Reserved[] must be a multiple of 16 bytes.
    //















    // Temporary (volatile) interger registers






























































// @@END_DDKSPLIT
    // Exception record
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD64) + 15) & (~15)];

    // End of frame marker (for debugging)
    ULONGLONG Handler;  // Handler for this trap
    ULONGLONG EOFMarker;
} IA64_KTRAP_FRAME, *PIA64_KTRAP_FRAME;

#endif // _IA64










#define IA64_MM_EPC_VA          0xe0000000ffa00000
#define IA64_STACK_SCRATCH_AREA 16
#define IA64_SYSCALL_FRAME      0
#define IA64_INTERRUPT_FRAME    1
#define IA64_EXCEPTION_FRAME    2
#define IA64_CONTEXT_FRAME      10

#define IA64_IFS_IFM        0
#define IA64_IFS_IFM_LEN    38
#define IA64_IFS_MBZ0       38
#define IA64_IFS_MBZ0_V     0x1ffffffi64
#define IA64_IFS_V          63
#define IA64_IFS_V_LEN      1
#define IA64_PFS_EC_SHIFT             52
#define IA64_PFS_EC_SIZE              6
#define IA64_PFS_EC_MASK              0x3F
#define IA64_PFS_SIZE_SHIFT           7
#define IA64_PFS_SIZE_MASK            0x7F
#define IA64_NAT_BITS_PER_RNAT_REG    63
#define IA64_RNAT_ALIGNMENT           (IA64_NAT_BITS_PER_RNAT_REG << 3)


#define X86_CONTEXT_X86              0x00010000
#define ALPHA_CONTEXT_ALPHA          0x00020000
#define IA64_CONTEXT_IA64            0x00080000

#define   ALPHA_PEB_IN_EPROCESS 424
#define     X86_PEB_IN_EPROCESS 432
#define X86_NT4_PEB_IN_EPROCESS 396
#define   AXP64_PEB_IN_EPROCESS 688
#define    IA64_PEB_IN_EPROCESS 752

#define PEB_FROM_TEB32    48
#define PEB_FROM_TEB64    96

#define PEBLDR_FROM_PEB32 12
#define PEBLDR_FROM_PEB64 24

#define MODULE_LIST_FROM_PEBLDR32 12
#define MODULE_LIST_FROM_PEBLDR64 16


#define X86_KGDT_LDT                72
#define X86_KGDT_R0_PCR             48
#define X86_KGDT_TSS                40
#define X86_FRAME_EDITED            0xfff8
#define X86_MODE_MASK               1
#define X86_EFLAGS_V86_MASK         0x00020000

//
// Memory management info
//
#define X86_PAGE_SIZE                0x1000
#define X86_PAGE_SHIFT               12L
#define X86_PTE_BASE                 0xc0000000
#define X86_PDE_BASE_PAE             0xc0600000
#define X86_PDE_BASE                 0xc0300000
#define X86_PDE_TOP                  0xC03FFFFF
#define X86_MM_PTE_TRANSITION_MASK   0x800
#define X86_MM_PTE_PROTOTYPE_MASK    0x400

#define IA64_PAGE_SIZE               0x2000
#define IA64_PAGE_SHIFT              13L
#define IA64_PTE_MASK                0x3ff
#define IA64_PDE_SHIFT               21
#define IA64_PTE_SHIFT               3
#define IA64_PTE_BASE                0
#define IA64_PDE_BASE                0
#define IA64_PDE_TOP                 0
#define IA64_MM_PTE_TRANSITION_MASK  0x0080
#define IA64_MM_PTE_PROTOTYPE_MASK   0x0002

#define AXP64_PAGE_SIZE              0x2000
#define AXP64_PAGE_SHIFT             13L
#define AXP64_PDI_SHIFT              23
#define AXP64_PTI_SHIFT              13
#define AXP64_PTE_BASE               0xFFFFFE0000000000UI64
#define AXP64_PDE_BASE               0xFFFFFE01807FE000UI64
#define AXP64_PDE_TOP                0                  // BUGBUG
#define AXP64_MM_PTE_TRANSITION_MASK 0x4
#define AXP64_MM_PTE_PROTOTYPE_MASK  0x2

#define ALPHA_PAGE_SIZE              0x2000
#define ALPHA_PAGE_SHIFT             13L
#define ALPHA_PDI_SHIFT              24
#define ALPHA_PTI_SHIFT              13
#define ALPHA_PTE_BASE               0xC0000000
#define ALPHA_PDE_BASE               0xC0180000
#define ALPHA_PDE_TOP                0xC01FFFFF
#define ALPHA_MM_PTE_TRANSITION_MASK 0x4
#define ALPHA_MM_PTE_PROTOTYPE_MASK  0x2



#define IA64_DEBUG_CONTROL_SPACE_PCR       1
#define IA64_DEBUG_CONTROL_SPACE_THREAD    4


#define ALPHA_DEBUG_CONTROL_SPACE_PCR       1
#define ALPHA_DEBUG_CONTROL_SPACE_THREAD    2
#define ALPHA_DEBUG_CONTROL_SPACE_PRCB      3
#define ALPHA_DEBUG_CONTROL_SPACE_TEB       6

#define ALPHA_RF_NOT_CONTIGUOUS    0
#define ALPHA_RF_ALT_ENT_PROLOG    1
#define ALPHA_RF_NULL_CONTEXT      2

#define ALPHA_RF_BEGIN_ADDRESS(RF)      ((RF)->BeginAddress & (~3))
#define ALPHA_RF_END_ADDRESS(RF)        ((RF)->EndAddress & (~3))
#define ALPHA_RF_EXCEPTION_HANDLER(RF)  (PEXCEPTION_ROUTINE)((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_ENTRY_TYPE(RF)         (ULONG)((ULONG_PTR)((RF)->HandlerData) & 3)
#define ALPHA_RF_PROLOG_END_ADDRESS(RF) ((RF)->PrologEndAddress & (~3))
#define ALPHA_RF_IS_FIXED_RETURN(RF)    (BOOLEAN)(((ULONG_PTR)((RF)->ExceptionHandler) & 2) >> 1)
#define ALPHA_RF_NULL_CONTEXT_COUNT(RF) (ULONG)((ULONG_PTR)((RF)->EndAddress) & 3)
#define ALPHA_RF_FIXED_RETURN(RF)       ((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_ALT_PROLOG(RF)         ((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_STACK_ADJUST(RF)       (ULONG)((ULONG_PTR)((RF)->ExceptionHandler) & (~3))




typedef struct _CROSS_PLATFORM_WAIT_STATE_CHANGE64 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
    } u;
    DBGKD_CONTROL_REPORT ControlReport;         // BUGBUG - differs by platforms
    CROSS_PLATFORM_CONTEXT Context;
} CROSS_PLATFORM_WAIT_STATE_CHANGE64, *PCROSS_PLATFORM_WAIT_STATE_CHANGE64;

typedef struct _CROSS_PLATFORM_WAIT_STATE_CHANGE32 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG Thread;
    ULONG ProgramCounter;
    union {
        DBGKM_EXCEPTION32 Exception;
        DBGKD_LOAD_SYMBOLS32 LoadSymbols;
    } u;
    DBGKD_CONTROL_REPORT ControlReport;
    CROSS_PLATFORM_CONTEXT Context;
} CROSS_PLATFORM_WAIT_STATE_CHANGE32, *PCROSS_PLATFORM_WAIT_STATE_CHANGE32;


// More stuff currently used by crashdump

#define X86_TRANSITION_MASK     0xC00
#define X86_TRANSITION_CHECK    0x800
#define X86_VALID_PFN_MASK      0xFFFFF000
#define X86_VALID_PFN_SHIFT     12
#define X86_PDE_SHIFT           22
#define X86_PTE_SHIFT           12
#define X86_PTE_MASK            0x3ff
#define X86_PHYSICAL_MASK       0x0
#define X86_PHYSICAL_START      0x1
#define X86_PHYSICAL_END        0x0
#define X86_PAGESIZE            4096
#define X86_PAGESHIFT           12
#define X86_LARGE_PAGE_MASK     0x80
#define X86_LARGE_PAGE_SIZE     (4*1024*1024)

#define X86_LARGE_PAGE_SIZE_PAE (2 * 1024 * 1024)   // 2 MB

#define IA64_TRANSITION_MASK    0x006
#define IA64_TRANSITION_CHECK   0x004
#define IA64_VALID_PFN_MASK     0xFFFFF000
#define IA64_VALID_PFN_SHIFT    12
#define IA64_PDE_SHIFT          21
#define IA64_PTE_SHIFT          3
#define IA64_PTE_MASK           0x3ff
#define IA64_PHYSICAL_MASK      0x0
#define IA64_PHYSICAL_START     0x1
#define IA64_PHYSICAL_END       0x0
#define IA64_PAGESIZE           4096
#define IA64_PAGESHIFT          12

#define ALPHA_TRANSITION_MASK   0x6
#define ALPHA_TRANSITION_CHECK  0x4
#define ALPHA_VALID_PFN_MASK    0xFFFFFE00
#define ALPHA_VALID_PFN_SHIFT   9
#define ALPHA_PDE_SHIFT         24
#define ALPHA_PTE_SHIFT         13
#define ALPHA_PTE_MASK          0x7ff
#define ALPHA_PHYSICAL_MASK     0x3FFFFFFF
#define ALPHA_PHYSICAL_START    0x80000000
#define ALPHA_PHYSICAL_END      0xBFFFFFFF
#define ALPHA_PAGESIZE          8192
#define ALPHA_PAGESHIFT         13

#define MAX_PHYSICAL_MEMORY_FRAGMENTS 20


typedef struct _PAE_ADDRESS {
    union {
        struct {
            ULONG Offset : 12;                  // 0  .. 11
            ULONG Table : 9;                    // 12 .. 20
            ULONG Directory : 9;                // 21 .. 29
            ULONG DirectoryPointer : 2;         // 30 .. 31
        };
        struct {
            ULONG Offset : 21 ;
            ULONG Directory : 9 ;
            ULONG DirectoryPointer : 2;
        } LargeAddress;

        ULONG DwordPart;
    };
} PAE_ADDRESS, * PPAE_ADDRESS;

typedef struct _X86PAE_HARDWARE_PTE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 24;
            ULONGLONG reserved1 : 28;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} X86PAE_HARDWARE_PTE, *PX86PAE_HARDWARE_PTE;

typedef X86PAE_HARDWARE_PTE X86PAE_HARDWARE_PDPTE;


typedef struct _X86PAE_HARDWARE_PDE {
    union {
        struct _X86PAE_HARDWARE_PTE;

        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1;
            ULONGLONG Prototype : 1;
            ULONGLONG reserved0 : 1;
            ULONGLONG reserved2 : 9;
            ULONGLONG PageFrameNumber : 15;
            ULONGLONG reserved1 : 28;
        } Large;
        
        ULONGLONG QuadPart;
    };
} X86PAE_HARDWARE_PDE;



#ifdef __cplusplus
}
#endif

#endif // _NTDBG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddaux.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntddaux.h

Abstract:

    This include file defines all constants and types for
    accessing an NT auxiliary sound devices.

Author:

    Robin Speed (RobinSp) - 24-Aug-1992

Revision History:

--*/

#ifndef _NTDDAUX_
#define _NTDDAUX_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntddsnd.h>    // general sound stuff

#ifdef __cplusplus
extern "C" {
#endif

#define IOCTL_AUX_BASE 0x0100

//
// Device Name - this string is the name of the device.  It is the name
// that when added to the name of the root of the device tree and with
// the device number appended, gives the name of the device required for
// a call to NtOpenFile.
// So for example, if the root is \Device and the Device type is
// MMAux and the device number is 2, the full name is \Device\MMAux2
//

#define DD_AUX_DEVICE_NAME     "\\Device\\MMAux"
#define DD_AUX_DEVICE_NAME_U  L"\\Device\\MMAux"

//
// WAVE device driver IOCTL set
//

#define IOCTL_AUX_GET_CAPABILITIES     CTL_CODE(IOCTL_SOUND_BASE, IOCTL_AUX_BASE + 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AUX_SET_VOLUME           CTL_CODE(IOCTL_SOUND_BASE, IOCTL_AUX_BASE + 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AUX_GET_VOLUME           CTL_CODE(IOCTL_SOUND_BASE, IOCTL_AUX_BASE + 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Input and output are AUX_DD_VOLUME structure.
// Completes when real device volume != volume passed in.
// Returns new volume
//
#define IOCTL_SOUND_GET_CHANGED_VOLUME   CTL_CODE(IOCTL_SOUND_BASE, IOCTL_AUX_BASE + 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Aux volume structure
//

typedef struct _AUX_DD_VOLUME {
    ULONG   Left;
    ULONG   Right;
} AUX_DD_VOLUME, *PAUX_DD_VOLUME;

#define AUX_DD_MAX_VOLUME 0xFFFFFFFF // Maximum volume

//
// Data returned by IOCTL_AUX_GET_CAPABILITIES is AUXCAPSW structure
// defined in mmsystem.h
//

#ifdef __cplusplus
}
#endif

#endif // _NTDDAUX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddchgr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ntddchgr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing medium changer devices.

Author:

    chuckp (Charles Park)

Revision History:

--*/

#ifndef _NTDDCHGR_H_
#define _NTDDCHGR_H_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_CHANGER_DEVICE_NAME "\\Device\\Changer"

//
// NtDeviceIoControlFile IoControlCode values for changer devices.
//


// begin_winioctl

#define IOCTL_CHANGER_BASE                FILE_DEVICE_CHANGER

#define IOCTL_CHANGER_GET_PARAMETERS         CTL_CODE(IOCTL_CHANGER_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_STATUS             CTL_CODE(IOCTL_CHANGER_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_PRODUCT_DATA       CTL_CODE(IOCTL_CHANGER_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_ACCESS             CTL_CODE(IOCTL_CHANGER_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_GET_ELEMENT_STATUS     CTL_CODE(IOCTL_CHANGER_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS  CTL_CODE(IOCTL_CHANGER_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_POSITION           CTL_CODE(IOCTL_CHANGER_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_EXCHANGE_MEDIUM        CTL_CODE(IOCTL_CHANGER_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_MOVE_MEDIUM            CTL_CODE(IOCTL_CHANGER_BASE, 0x0009, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_REINITIALIZE_TRANSPORT CTL_CODE(IOCTL_CHANGER_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_QUERY_VOLUME_TAGS      CTL_CODE(IOCTL_CHANGER_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


// end_winioctl

//
// The following file contains the IOCTL_STORAGE class ioctls
//

#include <ntddstor.h>

#ifdef __cplusplus
extern "C" {
#endif

// begin_winioctl

#define MAX_VOLUME_ID_SIZE       36
#define MAX_VOLUME_TEMPLATE_SIZE 40

#define VENDOR_ID_LENGTH          8
#define PRODUCT_ID_LENGTH        16
#define REVISION_LENGTH           4
#define SERIAL_NUMBER_LENGTH     32

//
// Common structures describing elements.
//

typedef  enum _ELEMENT_TYPE {
    AllElements,        // As defined by SCSI
    ChangerTransport,   // As defined by SCSI
    ChangerSlot,        // As defined by SCSI
    ChangerIEPort,      // As defined by SCSI
    ChangerDrive,       // As defined by SCSI
    ChangerDoor,        // Front panel, used to access internal of cabinet.
    ChangerKeypad,      // Keypad/input on front panel.
    ChangerMaxElement   // Placeholder only. Not a valid type.
} ELEMENT_TYPE, *PELEMENT_TYPE;

typedef  struct _CHANGER_ELEMENT {
    ELEMENT_TYPE    ElementType;
    ULONG   ElementAddress;
} CHANGER_ELEMENT, *PCHANGER_ELEMENT;

typedef  struct _CHANGER_ELEMENT_LIST {
    CHANGER_ELEMENT Element;
    ULONG   NumberOfElements;
} CHANGER_ELEMENT_LIST , *PCHANGER_ELEMENT_LIST;


//
// Definitions for  IOCTL_CHANGER_GET_PARAMETERS
//

//
// Definitions for Features0 of GET_CHANGER_PARAMETERS
//

#define CHANGER_BAR_CODE_SCANNER_INSTALLED  0x00000001 // The medium-changer has a bar code scanner installed.
#define CHANGER_INIT_ELEM_STAT_WITH_RANGE   0x00000002 // The medium-changer has the ability to initialize elements within a specified range.
#define CHANGER_CLOSE_IEPORT                0x00000004 // The medium-changer has the ability to close the i/e port door.
#define CHANGER_OPEN_IEPORT                 0x00000008 // The medium-changer can open the i/e port door.

#define CHANGER_STATUS_NON_VOLATILE         0x00000010 // The medium-changer uses non-volatile memory for element status information.
#define CHANGER_EXCHANGE_MEDIA              0x00000020 // The medium-changer supports exchange operations.
#define CHANGER_CLEANER_SLOT                0x00000040 // The medium-changer has a fixed slot designated for cleaner cartridges.
#define CHANGER_LOCK_UNLOCK                 0x00000080 // The medium-changer can be (un)secured to (allow)prevent media removal.

#define CHANGER_CARTRIDGE_MAGAZINE          0x00000100 // The medium-changer uses cartridge magazines for some storage slots.
#define CHANGER_MEDIUM_FLIP                 0x00000200 // The medium-changer can flip medium.
#define CHANGER_POSITION_TO_ELEMENT         0x00000400 // The medium-changer can position the transport to a particular element.
#define CHANGER_REPORT_IEPORT_STATE         0x00000800 // The medium-changer can determine whether media is present
                                                       // in the IE Port.

#define CHANGER_STORAGE_DRIVE               0x00001000 // The medium-changer can use a drive as an independent storage element.
#define CHANGER_STORAGE_IEPORT              0x00002000 // The medium-changer can use a i/e port as an independent storage element.
#define CHANGER_STORAGE_SLOT                0x00004000 // The medium-changer can use a slot as an independent storage element.
#define CHANGER_STORAGE_TRANSPORT           0x00008000 // The medium-changer can use a transport as an independent storage element.

#define CHANGER_DRIVE_CLEANING_REQUIRED     0x00010000 // The drives controlled by the medium changer require periodic cleaning
                                                       // initiated by an application.
#define CHANGER_PREDISMOUNT_EJECT_REQUIRED  0x00020000 // The medium-changer requires a drive eject command to be issued, before a changer
                                                       // move / exchange command can be issued to the drive.

#define CHANGER_CLEANER_ACCESS_NOT_VALID    0x00040000 // The access bit in GES isn't valid for cleaner cartridges.
#define CHANGER_PREMOUNT_EJECT_REQUIRED     0x00080000 // The medium-changer requires a drive eject command to be issued
                                                       // before a move / exchange command can be issued with the drive as src/dst.

#define CHANGER_VOLUME_IDENTIFICATION       0x00100000 // The medium-changer supports volume identification.
#define CHANGER_VOLUME_SEARCH               0x00200000 // The medium-changer can search for volume information.
#define CHANGER_VOLUME_ASSERT               0x00400000 // The medium-changer can verify volume information.
#define CHANGER_VOLUME_REPLACE              0x00800000 // The medium-changer can replace volume information.
#define CHANGER_VOLUME_UNDEFINE             0x01000000 // The medium-changer can undefine volume information.

#define CHANGER_SERIAL_NUMBER_VALID         0x04000000 // The serial number reported in GetProductData is valid
                                                       // and unique.

#define CHANGER_DEVICE_REINITIALIZE_CAPABLE 0x08000000 // The medium-changer can be issued a ChangerReinitializeUnit.
#define CHANGER_KEYPAD_ENABLE_DISABLE       0x10000000 // Indicates that the keypad can be enabled/disabled.
#define CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS  0x20000000 // Drives must be empty before access via the door is possible.

#define CHANGER_RESERVED_BIT                0x80000000 // Will be used to indicate Features1 capability bits.


//
// Definitions for Features1 of GET_CHANGER_PARAMETERS
//

#define CHANGER_PREDISMOUNT_ALIGN_TO_SLOT   0x80000001 // The transport must be prepositioned to the slot prior to ejecting the media.
#define CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE  0x80000002 // The transport must be prepositioned to the drive prior to ejecting the media.
#define CHANGER_CLEANER_AUTODISMOUNT        0x80000004 // The device will move the cleaner cartridge back into the slot when cleaning has completed.
#define CHANGER_TRUE_EXCHANGE_CAPABLE       0x80000008 // Device can do src -> dest2 exchanges.
#define CHANGER_SLOTS_USE_TRAYS             0x80000010 // Slots have removable trays, requiring multiple moves for inject/eject.
#define CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR  0x80000020 // Media must be returned to the slot from which it originated after a move to another element.
#define CHANGER_CLEANER_OPS_NOT_SUPPORTED   0x80000040 // Automated cleaning operations are not supported on this device.
#define CHANGER_IEPORT_USER_CONTROL_OPEN    0x80000080 // Indicates that user action is necessary to open a closed ieport.
#define CHANGER_IEPORT_USER_CONTROL_CLOSE   0x80000100 // Indicates that user action is necessary to close an opened ieport.
#define CHANGER_MOVE_EXTENDS_IEPORT         0x80000200 // Indicates that a move media to the ieport extends the tray.
#define CHANGER_MOVE_RETRACTS_IEPORT        0x80000400 // Indicates that a move media from the ieport retracts the tray.


//
// Definitions for MoveFrom, ExchangeFrom, and PositionCapabilities
//

#define CHANGER_TO_TRANSPORT    0x01 // The device can carry out the operation to a transport from the specified element.
#define CHANGER_TO_SLOT         0x02 // The device can carry out the operation to a slot from the specified element.
#define CHANGER_TO_IEPORT       0x04 // The device can carry out the operation to an IE Port from the specified element.
#define CHANGER_TO_DRIVE        0x08 // The device can carry out the operation to a drive from the specified element.

//
// Definitions for LockUnlockCapabilities
//

#define LOCK_UNLOCK_IEPORT      0x01 // The device can lock/unlock the ieport(s).
#define LOCK_UNLOCK_DOOR        0x02 // The device can lock/unlock the door(s).
#define LOCK_UNLOCK_KEYPAD      0x04 // The device can lock/unlock the keypad.

typedef  struct _GET_CHANGER_PARAMETERS {

    //
    // Size of the structure. Can be used for versioning.
    //

    ULONG Size;

    //
    // Number of N element(s) as defined by the Element Address Page (or equivalent...).
    //

    USHORT NumberTransportElements;
    USHORT NumberStorageElements;                // for data cartridges only
    USHORT NumberCleanerSlots;                   // for cleaner cartridges
    USHORT NumberIEElements;
    USHORT NumberDataTransferElements;

    //
    // Number of doors/front panels (allows user entry into the cabinet).
    //

    USHORT NumberOfDoors;

    //
    // The device-specific address (from user manual of the device) of the first N element. Used
    // by the UI to relate the various elements to the user.
    //

    USHORT FirstSlotNumber;
    USHORT FirstDriveNumber;
    USHORT FirstTransportNumber;
    USHORT FirstIEPortNumber;
    USHORT FirstCleanerSlotAddress;

    //
    // Indicates the capacity of each magazine, if they exist.
    //

    USHORT MagazineSize;

    //
    // Specifies the approximate number of seconds for when a cleaning should be completed.
    // Only applicable if drive cleaning is supported. See Features0.
    //

    ULONG DriveCleanTimeout;

    //
    // See features bits, above.
    //

    ULONG Features0;
    ULONG Features1;

    //
    // Bitmask defining Move from N element to element. Defined by Device Capabilities Page (or equivalent).
    // AND-masking with the TO_XXX values will indicate legal destinations.
    //

    UCHAR MoveFromTransport;
    UCHAR MoveFromSlot;
    UCHAR MoveFromIePort;
    UCHAR MoveFromDrive;

    //
    // Bitmask defining Exchange from N element to element. Defined by Device Capabilities Page (or equivalent).
    // AND-masking with the TO_XXX values will indicate legal destinations.
    //

    UCHAR ExchangeFromTransport;
    UCHAR ExchangeFromSlot;
    UCHAR ExchangeFromIePort;
    UCHAR ExchangeFromDrive;

    //
    // Bitmask defining which elements are capable of lock/unlock. Valid only if
    // CHANGER_LOCK_UNLOCK is set in Features0.
    //

    UCHAR LockUnlockCapabilities;

    //
    // Bitmask defining which elements valid for positioning operations. Valid only if
    // CHANGER_POSITION_TO_ELEMENT is set in Features0.
    //

    UCHAR PositionCapabilities;

    //
    // For future expansion.
    //

    UCHAR Reserved1[2];
    ULONG Reserved2[2];

} GET_CHANGER_PARAMETERS, * PGET_CHANGER_PARAMETERS;


//
// Definitions for IOCTL_CHANGER_GET_PRODUCT_DATA
//

typedef  struct _CHANGER_PRODUCT_DATA {

    //
    // Device manufacturer's name - based on inquiry data
    //

    UCHAR VendorId[VENDOR_ID_LENGTH];

    //
    // Product identification as defined by the vendor - based on Inquiry data
    //

    UCHAR ProductId[PRODUCT_ID_LENGTH];

    //
    // Product revision as defined by the vendor.
    //

    UCHAR Revision[REVISION_LENGTH];

    //
    // Vendor unique value used to globally identify this device. Can
    // be from Vital Product Data, for example.
    //

    UCHAR SerialNumber[SERIAL_NUMBER_LENGTH];

    //
    // Indicates device type of data transports, as defined by SCSI-2.
    //

    UCHAR DeviceType;

} CHANGER_PRODUCT_DATA, *PCHANGER_PRODUCT_DATA;


//
// Definitions for IOCTL_CHANGER_SET_ACCESS
//

#define LOCK_ELEMENT        0
#define UNLOCK_ELEMENT      1
#define EXTEND_IEPORT       2
#define RETRACT_IEPORT      3

typedef struct _CHANGER_SET_ACCESS {

    //
    // Element can be ChangerIEPort, ChangerDoor, ChangerKeypad
    //

    CHANGER_ELEMENT Element;

    //
    // See above for possible operations.
    //

    ULONG           Control;
} CHANGER_SET_ACCESS, *PCHANGER_SET_ACCESS;


//
// Definitions for IOCTL_CHANGER_GET_ELEMENT_STATUS
//

//
// Input buffer.
//

typedef struct _CHANGER_READ_ELEMENT_STATUS {

    //
    // List describing the elements and range on which to return information.
    //

    CHANGER_ELEMENT_LIST ElementList;

    //
    // Indicates whether volume tag information is to be returned.
    //

    BOOLEAN VolumeTagInfo;
} CHANGER_READ_ELEMENT_STATUS, *PCHANGER_READ_ELEMENT_STATUS;

//
// Output buffer.
//

typedef  struct _CHANGER_ELEMENT_STATUS {

    //
    // Element to which this structure refers.
    //

    CHANGER_ELEMENT Element;

    //
    // Address of the element from which the media was originally moved.
    // Valid if ELEMENT_STATUS_SVALID bit of Flags ULONG is set.
    // Needs to be converted to a zero-based offset from the device-unique value.
    //

    CHANGER_ELEMENT SrcElementAddress;

    //
    // See below.
    //

    ULONG Flags;

    //
    // See below for possible values.
    //

    ULONG ExceptionCode;

    //
    // Scsi Target Id of this element.
    // Valid only if ELEMENT_STATUS_ID_VALID is set in Flags.
    //

    UCHAR TargetId;

    //
    // LogicalUnitNumber of this element.
    // Valid only if ELEMENT_STATUS_LUN_VALID is set in Flags.
    //

    UCHAR Lun;
    USHORT Reserved;

    //
    // Primary volume identification for the media.
    // Valid only if ELEMENT_STATUS_PVOLTAG bit is set in Flags.
    //

    UCHAR PrimaryVolumeID[MAX_VOLUME_ID_SIZE];

    //
    // Alternate volume identification for the media.
    // Valid for two-sided media only, and pertains to the id. of the inverted side.
    // Valid only if ELEMENT_STATUS_AVOLTAG bit is set in Flags.
    //

    UCHAR AlternateVolumeID[MAX_VOLUME_ID_SIZE];
} CHANGER_ELEMENT_STATUS, *PCHANGER_ELEMENT_STATUS;

//
// Possible flag values
//

#define ELEMENT_STATUS_FULL      0x00000001 // Element contains a unit of media.
#define ELEMENT_STATUS_IMPEXP    0x00000002 // Media in i/e port was placed there by an operator.
#define ELEMENT_STATUS_EXCEPT    0x00000004 // Element is in an abnormal state; check ExceptionCode field for more information.
#define ELEMENT_STATUS_ACCESS    0x00000008 // Access to the i/e port from the medium changer is allowed.
#define ELEMENT_STATUS_EXENAB    0x00000010 // Export of media is supported.
#define ELEMENT_STATUS_INENAB    0x00000020 // Import of media is supported.

#define ELEMENT_STATUS_LUN_VALID 0x00001000 // Lun information is valid.
#define ELEMENT_STATUS_ID_VALID  0x00002000 // SCSI Id information is valid.
#define ELEMENT_STATUS_NOT_BUS   0x00008000 // Lun and SCSI Id fields are not on same bus as medium changer.
#define ELEMENT_STATUS_INVERT    0x00400000 // Media in element was inverted (valid only if ELEMENT_STATUS_SVALID bit is set)
#define ELEMENT_STATUS_SVALID    0x00800000 // SourceElementAddress field and ELEMENT_STATUS_INVERT bit are valid.

#define ELEMENT_STATUS_PVOLTAG   0x10000000 // Primary volume information is valid.
#define ELEMENT_STATUS_AVOLTAG   0x20000000 // Alternate volume information is valid.

//
// ExceptionCode values.
//

#define ERROR_LABEL_UNREADABLE    0x00000001 // Bar code scanner could not read bar code label.
#define ERROR_LABEL_QUESTIONABLE  0x00000002 // Label could be invalid due to unit attention condition.
#define ERROR_SLOT_NOT_PRESENT    0x00000004 // Slot is currently not addressable in the device.
#define ERROR_DRIVE_NOT_INSTALLED 0x00000008 // Drive is not installed.
#define ERROR_TRAY_MALFUNCTION    0x00000010 // Media tray is malfunctioning/broken.
#define ERROR_INIT_STATUS_NEEDED  0x00000011 // An Initialize Element Status command is needed.
#define ERROR_UNHANDLED_ERROR     0xFFFFFFFF // Unknown error condition


//
// Definitions for IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS
//

typedef struct _CHANGER_INITIALIZE_ELEMENT_STATUS {

    //
    // List describing the elements and range on which to initialize.
    //

    CHANGER_ELEMENT_LIST ElementList;

    //
    // Indicates whether a bar code scan should be used. Only applicable if
    // CHANGER_BAR_CODE_SCANNER_INSTALLED is set in Features0 of CHANGER_GET_PARAMETERS.
    //

    BOOLEAN BarCodeScan;
} CHANGER_INITIALIZE_ELEMENT_STATUS, *PCHANGER_INITIALIZE_ELEMENT_STATUS;


//
// Definitions for IOCTL_CHANGER_SET_POSITION
//

typedef struct _CHANGER_SET_POSITION {


    //
    // Indicates which transport to move.
    //

    CHANGER_ELEMENT Transport;

    //
    // Indicates the final destination of the transport.
    //

    CHANGER_ELEMENT Destination;

    //
    // Indicates whether the media currently carried by Transport, should be flipped.
    //

    BOOLEAN         Flip;
} CHANGER_SET_POSITION, *PCHANGER_SET_POSITION;


//
// Definitions for IOCTL_CHANGER_EXCHANGE_MEDIUM
//

typedef struct _CHANGER_EXCHANGE_MEDIUM {

    //
    // Indicates which transport to use for the exchange operation.
    //

    CHANGER_ELEMENT Transport;

    //
    // Indicates the source for the media that is to be moved.
    //

    CHANGER_ELEMENT Source;

    //
    // Indicates the final destination of the media originally at Source.
    //

    CHANGER_ELEMENT Destination1;

    //
    // Indicates the destination of the media moved from Destination1.
    //

    CHANGER_ELEMENT Destination2;

    //
    // Indicates whether the medium should be flipped.
    //

    BOOLEAN         Flip1;
    BOOLEAN         Flip2;
} CHANGER_EXCHANGE_MEDIUM, *PCHANGER_EXCHANGE_MEDIUM;


//
// Definitions for IOCTL_CHANGER_MOVE_MEDIUM
//

typedef struct _CHANGER_MOVE_MEDIUM {

    //
    // Indicates which transport to use for the move operation.
    //

    CHANGER_ELEMENT Transport;

    //
    // Indicates the source for the media that is to be moved.
    //

    CHANGER_ELEMENT Source;

    //
    // Indicates the destination of the media originally at Source.
    //

    CHANGER_ELEMENT Destination;

    //
    // Indicates whether the media should be flipped.
    //

    BOOLEAN         Flip;
} CHANGER_MOVE_MEDIUM, *PCHANGER_MOVE_MEDIUM;



//
// Definitions for IOCTL_QUERY_VOLUME_TAGS
//

//
// Input buffer.
//

typedef  struct _CHANGER_SEND_VOLUME_TAG_INFORMATION {

    //
    // Describes the starting element for which to return information.
    //

    CHANGER_ELEMENT StartingElement;

    //
    // Indicates the specific action to perform. See below.
    //

    ULONG ActionCode;

    //
    // Template used by the device to search for volume ids.
    //

    UCHAR VolumeIDTemplate[MAX_VOLUME_TEMPLATE_SIZE];
} CHANGER_SEND_VOLUME_TAG_INFORMATION, *PCHANGER_SEND_VOLUME_TAG_INFORMATION;


//
// Output buffer.
//

typedef struct _READ_ELEMENT_ADDRESS_INFO {

    //
    // Number of elements matching criteria set forth by ActionCode.
    //

    ULONG NumberOfElements;

    //
    // Array of CHANGER_ELEMENT_STATUS structures, one for each element that corresponded
    // with the information passed in with the CHANGER_SEND_VOLUME_TAG_INFORMATION structure.
    //

    CHANGER_ELEMENT_STATUS ElementStatus[1];
} READ_ELEMENT_ADDRESS_INFO, *PREAD_ELEMENT_ADDRESS_INFO;

//
// Possible ActionCode values. See Features0 of CHANGER_GET_PARAMETERS for compatibility with
// the current device.
//

#define SEARCH_ALL         0x0 // Translate - search all defined volume tags.
#define SEARCH_PRIMARY     0x1 // Translate - search only primary volume tags.
#define SEARCH_ALTERNATE   0x2 // Translate - search only alternate volume tags.
#define SEARCH_ALL_NO_SEQ  0x4 // Translate - search all defined volume tags but ignore sequence numbers.
#define SEARCH_PRI_NO_SEQ  0x5 // Translate - search only primary volume tags but ignore sequence numbers.
#define SEARCH_ALT_NO_SEQ  0x6 // Translate - search only alternate volume tags but ignore sequence numbers.

#define ASSERT_PRIMARY     0x8 // Assert - as the primary volume tag - if tag now undefined.
#define ASSERT_ALTERNATE   0x9 // Assert - as the alternate volume tag - if tag now undefined.

#define REPLACE_PRIMARY    0xA // Replace - the primary volume tag - current tag ignored.
#define REPLACE_ALTERNATE  0xB // Replace - the alternate volume tag - current tag ignored.

#define UNDEFINE_PRIMARY   0xC // Undefine - the primary volume tag - current tag ignored.
#define UNDEFINE_ALTERNATE 0xD // Undefine - the alternate volume tag - current tag ignored.


// end_winioctl

#ifdef __cplusplus
}
#endif

#endif // _NTDDCHGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddbrow.h ===
/*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    ntddbrow.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the datagram receiver device driver, better know as the
    Browser.

Authors:

    Larry Osterman (larryo) & Rita Wong (ritaw)   25-Mar-1991

Revision History:

--*/

#ifndef _NTDDBROW_
#define _NTDDBROW_

#if _MSC_VER > 1000
#pragma once
#endif

#include <windef.h>
#include <lmcons.h>
#include <lmwksta.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_BROWSER_DEVICE_NAME "\\Device\\LanmanDatagramReceiver"

#define DD_BROWSER_DEVICE_NAME_U L"\\Device\\LanmanDatagramReceiver"

//
// The file system name as returned by
// NtQueryInformationVolume(FileFsAttributeInformation)
//

#define DD_BROWSER_NAME "LMBROWSER"

//
// Name of the event used to force the scavenger thread to announce the
// server.
//

#define SERVER_ANNOUNCE_EVENT_W  L"\\LanmanServerAnnounceEvent"

#define BOWSER_CONFIG_PARAMETERS    L"Parameters"

#define BOWSER_CONFIG_IRP_STACK_SIZE    L"IrpStackSize"

#define BOWSER_CONFIG_MAILSLOT_THRESHOLD    L"MailslotDatagramThreshold"
#define BOWSER_CONFIG_GETBLIST_THRESHOLD    L"GetBrowserListThreshold"

#define BOWSER_CONFIG_SERVER_DELETION_THRESHOLD L"BrowserServerDeletionThreshold"
#define BOWSER_CONFIG_DOMAIN_DELETION_THRESHOLD L"BrowserDomainDeletionThreshold"
#define BOWSER_CONFIG_FIND_MASTER_TIMEOUT       L"BrowserFindMasterTimeout"
#define BOWSER_CONFIG_MINIMUM_CONFIGURED_BROWSER L"BrowserMinimumConfiguredBrowsers"
#define BROWSER_CONFIG_BACKUP_RECOVERY_TIME L"BackupBrowserRecoveryTime"
#define BROWSER_CONFIG_MAXIMUM_BROWSE_ENTRIES L"MaximumBrowseEntries"



//
// This defines the revision of the NT browser.
//
// To guarantee that a newer browser is preferred over an older version, bump
// this version number.
//

#define BROWSER_ELECTION_VERSION  0x0001

#define BROWSER_VERSION_MAJOR       0x01
#define BROWSER_VERSION_MINOR       0x0F

//
//  Number of seconds a GetBrowserServerList request will wait until it forces
//  an election.
//

#define BOWSER_GETBROWSERLIST_TIMEOUT 1

//
//  Number of retries of the GetBrowserServerList request we will issue before we
//  give up.
//

#define BOWSER_GETBROWSERLIST_RETRY_COUNT 3

//
//  The browser service on a master browser will query the driver with this
//  frequency.
//

#define BROWSER_QUERY_DRIVER_FREQUENCY  30

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_DGR_BASE                  FILE_DEVICE_NETWORK_BROWSER

#define _BROWSER_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_DGR_BASE, request, method, access)

#define IOCTL_LMDR_START                    _BROWSER_CONTROL_CODE(0x001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_LMDR_STOP                     _BROWSER_CONTROL_CODE(0x002, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_LMDR_ADD_NAME                 _BROWSER_CONTROL_CODE(0x003, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_DELETE_NAME              _BROWSER_CONTROL_CODE(0x004, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_ADD_NAME_DOM             _BROWSER_CONTROL_CODE(0x003, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_LMDR_DELETE_NAME_DOM          _BROWSER_CONTROL_CODE(0x004, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_LMDR_ENUMERATE_NAMES          _BROWSER_CONTROL_CODE(0x005, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_LMDR_ENUMERATE_SERVERS        _BROWSER_CONTROL_CODE(0x006, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_LMDR_BIND_TO_TRANSPORT        _BROWSER_CONTROL_CODE(0x007, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_BIND_TO_TRANSPORT_DOM    _BROWSER_CONTROL_CODE(0x007, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_LMDR_ENUMERATE_TRANSPORTS     _BROWSER_CONTROL_CODE(0x008, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_LMDR_UNBIND_FROM_TRANSPORT    _BROWSER_CONTROL_CODE(0x008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM _BROWSER_CONTROL_CODE(0x009, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_LMDR_RENAME_DOMAIN            _BROWSER_CONTROL_CODE(0x00A, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_LMDR_GET_BROWSER_SERVER_LIST  _BROWSER_CONTROL_CODE(0x00C, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_LMDR_GET_MASTER_NAME          _BROWSER_CONTROL_CODE(0x00D, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_BECOME_BACKUP            _BROWSER_CONTROL_CODE(0x00E, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_BECOME_MASTER            _BROWSER_CONTROL_CODE(0x00F, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE _BROWSER_CONTROL_CODE(0x011, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_WRITE_MAILSLOT           _BROWSER_CONTROL_CODE(0x012, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_LMDR_UPDATE_STATUS            _BROWSER_CONTROL_CODE(0x013, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_LMDR_CHANGE_ROLE              _BROWSER_CONTROL_CODE(0x014, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_NEW_MASTER_NAME          _BROWSER_CONTROL_CODE(0x015, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_QUERY_STATISTICS         _BROWSER_CONTROL_CODE(0x016, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_RESET_STATISTICS         _BROWSER_CONTROL_CODE(0x017, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_DEBUG_CALL               _BROWSER_CONTROL_CODE(0x018, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_NETLOGON_MAILSLOT_READ   _BROWSER_CONTROL_CODE(0x019, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE _BROWSER_CONTROL_CODE(0x020, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_IP_ADDRESS_CHANGED       _BROWSER_CONTROL_CODE(0x021, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT _BROWSER_CONTROL_CODE(0x022, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMDR_BROWSER_PNP_READ         _BROWSER_CONTROL_CODE(0x023, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_LMDR_BROWSER_PNP_ENABLE       _BROWSER_CONTROL_CODE(0x024, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Identifies the data structure type for Buffer 2 of each IoCtl
//

typedef enum _IOCTL_LMDR_STRUCTURES {
    EnumerateNames,                   // IOCTL_LMDR_ENUMERATE_NAMES
    EnumerateServers,                 // IOCTL_LMDR_ENUMERATE_SERVERS
    EnumerateXports,                  // IOCTL_LMDR_ENUMERATE_TRANSPORTS
    Datagram
} IOCTL_LMDR_STRUCTURES;


typedef enum _DGRECEIVER_NAME_TYPE {
    ComputerName = 1,           // 1: Computer name (signature 0), unique
    PrimaryDomain,              // 2: Primary domain (signature 0), group
    LogonDomain,                // 3: Logon domain (signature 0), group
    OtherDomain,                // 4: Other domain (signature 0), group
    DomainAnnouncement,         // 5: domain announce (__MSBROWSE__), group
    MasterBrowser,              // 6: Master browser (domain name, signature 1d), unique
    BrowserElection,            // 7: Election name (domain name, signature 1e), group
    BrowserServer,              // 8: Server name (signature 20)
    DomainName,                 // 9: DC Domain name (domain name, signature 1c)
    PrimaryDomainBrowser,       // a: PDC Browser name (domain name, signature 1b), unique
    AlternateComputerName,      // b: Computer name (signature 0), unique
} DGRECEIVER_NAME_TYPE, *PDGRECEIVER_NAME_TYPE;


//
// LAN Man Redirector Request Packet used by the Workstation service
// to pass parameters to the Redirector through Buffer 1 of
// NtDeviceIoControlFile.
//
// Additional input or output of each IoCtl is found in Buffer 2.
//

#define LMDR_REQUEST_PACKET_VERSION_DOM  0x00000007L // Structure version.
#define LMDR_REQUEST_PACKET_VERSION  0x00000006L // Structure version.

typedef struct _LMDR_REQUEST_PACKET {

    IOCTL_LMDR_STRUCTURES Type;         // Type of structure in Buffer 2
    ULONG Version;                      // Version of structure in Buffer 2
    ULONG Level;                        // Level of information or force level
    LUID LogonId;                       // User logon session identifier

    UNICODE_STRING TransportName;
    UNICODE_STRING EmulatedDomainName;

    union {

        struct {
            ULONG   NumberOfMailslotBuffers;
            ULONG   NumberOfServerAnnounceBuffers;
            ULONG   IllegalDatagramThreshold;
            ULONG   EventLogResetFrequency;
            BOOLEAN LogElectionPackets;
            BOOLEAN IsLanManNt;
        } Start;                        // IN

        struct {
            DGRECEIVER_NAME_TYPE Type;  // Type of name
            ULONG DgReceiverNameLength; // Length of datagram receiver name
            WCHAR Name[1];              // Null terminated datagram receiver name.
        } AddDelName;

        struct {
            ULONG EntriesRead;          // OUT Number of entries returned
            ULONG TotalEntries;         // OUT Total entries available.
            ULONG TotalBytesNeeded;     // OUT Number of bytes needed for API
            ULONG ResumeHandle;         // IN OUT Resume handle
        } EnumerateNames;               // OUT Buffer2 is an array of DGRECEIVE

        struct {
            ULONG EntriesRead;          // OUT Number of entries returned
            ULONG TotalEntries;         // OUT Total entries available
            ULONG TotalBytesNeeded;     // OUT Total bytes needed to read all
                                        //     entries
            ULONG ResumeHandle;         // IN OUT Resume handle
            ULONG ServerType;           // IN Type of servers to enumerate
                                        //    (defined in lmserver.h)
            ULONG DomainNameLength;     // IN Length of domain name
            WCHAR DomainName[1];        // IN Name of domain to enumerate servers
                                        //    from

        } EnumerateServers;             // OUT Buffer2 contains array of
                                        //     ServerInfo structures

        struct {
            ULONG EntriesRead;          // OUT Number of entries returned
            ULONG TotalEntries;         // OUT Total entries available
            ULONG TotalBytesNeeded;     // OUT Total bytes needed to read all
                                        //     entries
            ULONG ResumeHandle;         // IN OUT Resume handle

        } EnumerateTransports;          // OUT Buffer2 contains array of

        struct {
            ULONG TransportNameLength;  // not including terminator
            WCHAR TransportName[1];     // Name of transport provider
        } Bind;                         // IN

        struct {
            ULONG TransportNameLength;  // not including terminator
            WCHAR TransportName[1];     // Name of transport provider
        } Unbind;                       // IN


        struct {
            ULONG EntriesRead;          // OUT Number of entries returned
            ULONG TotalEntries;         // OUT Total entries available.
            ULONG TotalBytesNeeded;     // OUT Number of bytes needed for API
            ULONG ResumeHandle;         // IN OUT Resume handle (Ignored)
            USHORT DomainNameLength;    // IN Length of domain name.
            BOOLEAN ForceRescan;        // IN Discard internal list and re-query.
            BOOLEAN UseBrowseList;      // IN TRUE if use server list (not net)
            WCHAR DomainName[1];        // IN Name of domain to retreive domain for
        } GetBrowserServerList;

// Begin Never Used (But don't delete it since it is largest branch of union)
        struct {
            LARGE_INTEGER TimeReceived; //  Time request was received.
            LARGE_INTEGER TimeQueued;   //  Time request was queued.
            LARGE_INTEGER TimeQueuedToBrowserThread; //  Time request was queued.
            ULONG RequestorNameLength;  // Length of name requesting list
            ULONG Token;                // Client token.
            USHORT RequestedCount;      // Number of entries requested.
            WCHAR Name[1];              // IN Name of transport, OUT name of requestor
        } WaitForBrowserServerRequest;
// End Never Used

        struct {
            ULONG MasterNameLength;     // Length of name requesting list
            WCHAR Name[1];              // IN Name of transport, OUT name of master
        } WaitForMasterAnnouncement;

        struct {
            ULONG MasterNameLength;     // OUT Length of master for domain
            WCHAR Name[1];              // IN Name of transport, OUT name of master
        } GetMasterName;

        struct {
            DGRECEIVER_NAME_TYPE DestinationNameType; // IN Name type of name to send.

            ULONG MailslotNameLength;   // IN Length of mailslot name.
                                        //    If 0, use default (\MAILSLOT\BROWSE)
            ULONG NameLength;           // IN Destination name length.
            WCHAR Name[1];              // IN Name of destination
        } SendDatagram;

        struct {
            ULONG NewStatus;
            ULONG NumberOfServersInTable;
            BOOLEAN IsLanmanNt;
// Begin Never Used
            BOOLEAN NeverUsed1;
            BOOLEAN NeverUsed2;
            BOOLEAN NeverUsed3;
// End Never Used
            BOOLEAN MaintainServerList;
        } UpdateStatus;

        struct {
            UCHAR RoleModification;
        } ChangeRole;

        struct {
            DWORD DebugTraceBits;       // IN New debug trace bits.
            BOOL  OpenLog;              // IN True if we should open log file
            BOOL  CloseLog;             // IN True if we should close log file
            BOOL  TruncateLog;          // IN True if we should truncate log
            WCHAR TraceFileName[1];     // IN If OpenLog, LogFileName (NT file)
        } Debug;

        struct {
            DWORD MaxMessageCount;      // IN number of netlogon messages to queue
        } NetlogonMailslotEnable;       // Use 0 to disable queuing

        struct {
            BOOL EnableTransport;       // IN True if we should enable transport
            BOOL PreviouslyEnabled;     // Returns if the transport was previously enabled
        } EnableDisableTransport;

        struct {
            BOOL ValidateOnly;       // True if new name is to be validated
            ULONG DomainNameLength;  // not including terminator
            WCHAR DomainName[1];     // New name of domain
        } DomainRename;                         // IN

    } Parameters;

} LMDR_REQUEST_PACKET, *PLMDR_REQUEST_PACKET;

//
// The NETLOGON_MAILSLOT structure describes a mailslot messages received by
// the browser's IOCTL_LMDR_NETLOGON_MAILSLOT_READ
//
// A NETLOGON_MAILSLOT message is also returned to Netlogon when an
// interesting PNP event occurs.  In that case, the fields will be set as
// follows:
//
// MailslotNameSize: 0 indicating this is a PNP event.
// MailslotNameOffset: One of the NETLOGON_PNP_OPCODEs indicating the
//  event being notified.
// TransportName*: Name of transport being affected.
// DestinationName*: Name of the hosted domain being affected
//

typedef enum _NETLOGON_PNP_OPCODE {
    NlPnpMailslotMessage,
    NlPnpTransportBind,
    NlPnpTransportUnbind,
    NlPnpNewIpAddress,
    NlPnpDomainRename,
    NlPnpNewRole
} NETLOGON_PNP_OPCODE, *PNETLOGON_PNP_OPCODE;

typedef struct {
    LARGE_INTEGER TimeReceived;
    DWORD MailslotNameSize;   // Unicode name of mailslot message was received on
    DWORD MailslotNameOffset;
    DWORD TransportNameSize;  // Unicode name of transport message was received on
    DWORD TransportNameOffset;
    DWORD MailslotMessageSize;// Actual mailslot message
    DWORD MailslotMessageOffset;
    DWORD DestinationNameSize;// Unicode name of computer or domain message was received on
    DWORD DestinationNameOffset;
    DWORD ClientSockAddrSize; // IP Address (Sockaddr) (Network byte order) of the sender
                              // 0: if not an IP transport
    DWORD ClientSockAddrOffset;
} NETLOGON_MAILSLOT, *PNETLOGON_MAILSLOT;


//
//      The DGRECEIVE structure describes the list of names that have been
//      added to the datagram browser.
//

typedef struct _DGRECEIVE_NAMES {
    UNICODE_STRING DGReceiverName;
    DGRECEIVER_NAME_TYPE Type;
} DGRECEIVE_NAMES, *PDGRECEIVE_NAMES;


typedef struct _LMDR_TRANSPORT_LIST {
    ULONG NextEntryOffset;          // Offset of next entry (dword aligned)
    ULONG TransportNameLength;
    ULONG Flags;                    // Flags for transport
    WCHAR TransportName[1];
} LMDR_TRANSPORT_LIST, *PLMDR_TRANSPORT_LIST;

#define LMDR_TRANSPORT_WANNISH  0x00000001  // If set, Xport is wannish.
#define LMDR_TRANSPORT_RAS      0x00000002  // If set, Xport is RAS.
#define LMDR_TRANSPORT_IPX      0x00000004  // If set, Xport is direct host IPX.
#define LMDR_TRANSPORT_PDC      0x00000008  // If set, Xport has <Domain>[1B] registered

//
//  Browser statistics.
//

typedef struct _BOWSER_STATISTICS {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    ULONG           NumberOfMissedServerAnnouncements;
    ULONG           NumberOfMissedMailslotDatagrams;
    ULONG           NumberOfMissedGetBrowserServerListRequests;
    ULONG           NumberOfFailedServerAnnounceAllocations;
    ULONG           NumberOfFailedMailslotAllocations;
    ULONG           NumberOfFailedMailslotReceives;
    ULONG           NumberOfFailedMailslotWrites;
    ULONG           NumberOfFailedMailslotOpens;
    ULONG           NumberOfDuplicateMasterAnnouncements;
    LARGE_INTEGER   NumberOfIllegalDatagrams;
} BOWSER_STATISTICS, *PBOWSER_STATISTICS;

#ifdef __cplusplus
}
#endif

#endif  // ifndef _NTDDBROW_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntdddfs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntdddfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Distributed file service device.

Author:

    Alan Whitney (alanw) 27 May 1992

Revision History:

--*/


#ifndef _NTDDDFS_
#define _NTDDDFS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// The names of logical roots are restricted to be less than or equal to
// MAX_LOGICAL_ROOT_NAME chars.
//

#define MAX_LOGICAL_ROOT_NAME   8

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//

extern LPCWSTR DD_DFS_DEVICE_DIR;
extern LPCWSTR DD_DFS_DLORG_DEVICE_NAME;  // Device for downlevel access
extern LPCWSTR DD_DFS_ORG_DEVICE_NAME;    // Device pointing to root of dfs

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_DFS_BASE                  FILE_DEVICE_DFS


// BUGBUG - borrow a currently unused bit in CreateOptions to indicate
//          that the file server is calling into DNR.

#define FILE_OPEN_LOCAL_SCOPE   FILE_OPEN_BY_FILE_ID    //BUGBUG - need a real bit defn.


#define STATUS_CHILD_VOLUME     STATUS_DFS_EXIT_PATH_FOUND      // vol. is child of local volume


// BUGBUG - End TEMP declarations

//
//  Distributed file service file control code and structure declarations
//

//
//  External Distributed file service file control operations
//

#define FSCTL_DFS_DEFINE_LOGICAL_ROOT   CTL_CODE(IOCTL_DFS_BASE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_DELETE_LOGICAL_ROOT   CTL_CODE(IOCTL_DFS_BASE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_LOGICAL_ROOT_PREFIX CTL_CODE(IOCTL_DFS_BASE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_GET_DSMACHINE         CTL_CODE(IOCTL_DFS_BASE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_GET_HANDLE_IDS        CTL_CODE(IOCTL_DFS_BASE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_DEFINE_PROVIDER       CTL_CODE(IOCTL_DFS_BASE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_GET_REFERRAL          CTL_CODE(IOCTL_DFS_BASE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_INIT_LOCAL_PARTITIONS         CTL_CODE(IOCTL_DFS_BASE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_CREATE_LOCAL_PARTITION        CTL_CODE(IOCTL_DFS_BASE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_DELETE_LOCAL_PARTITION        CTL_CODE(IOCTL_DFS_BASE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_SET_LOCAL_VOLUME_STATE        CTL_CODE(IOCTL_DFS_BASE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_SET_SERVICE_STATE             CTL_CODE(IOCTL_DFS_BASE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_DC_SET_VOLUME_STATE           CTL_CODE(IOCTL_DFS_BASE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_IS_CHILDNAME_LEGAL    CTL_CODE(IOCTL_DFS_BASE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_PKT_CREATE_ENTRY      CTL_CODE(IOCTL_DFS_BASE, 16, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_CREATE_SUBORDINATE_ENTRY  CTL_CODE(IOCTL_DFS_BASE, 17, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_CHECK_STGID_IN_USE    CTL_CODE(IOCTL_DFS_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_UPDATE_MACHINE_ADDRESS CTL_CODE(IOCTL_DFS_BASE, 19, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_SET_DOMAIN_GLUON      CTL_CODE(IOCTL_DFS_BASE, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_UPDATE_SITE_COSTS     CTL_CODE(IOCTL_DFS_BASE, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_SET_RELATION_INFO CTL_CODE(IOCTL_DFS_BASE, 22, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_SERVER_INFO       CTL_CODE(IOCTL_DFS_BASE, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_SET_SERVER_INFO       CTL_CODE(IOCTL_DFS_BASE, 24, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_NAME_RESOLVE          CTL_CODE(IOCTL_DFS_BASE, 25, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_DESTROY_ENTRY     CTL_CODE(IOCTL_DFS_BASE, 26, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_GET_RELATION_INFO CTL_CODE(IOCTL_DFS_BASE, 27, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_LOCAL_NAME_RESOLVE    CTL_CODE(IOCTL_DFS_BASE, 28, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_CREATE_EXIT_POINT     CTL_CODE(IOCTL_DFS_BASE, 29, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_DELETE_EXIT_POINT     CTL_CODE(IOCTL_DFS_BASE, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_ALL_ENTRIES       CTL_CODE(IOCTL_DFS_BASE, 31, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_CAIRO_SERVER      CTL_CODE(IOCTL_DFS_BASE, 32, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_CHILDREN          CTL_CODE(IOCTL_DFS_BASE, 33, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_CHECK_REMOTE_PARTITION CTL_CODE(IOCTL_DFS_BASE, 34, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_VERIFY_REMOTE_VOLUME_KNOWLEDGE CTL_CODE(IOCTL_DFS_BASE, 35, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_VERIFY_LOCAL_VOLUME_KNOWLEDGE CTL_CODE(IOCTL_DFS_BASE, 36, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_KNOWLEDGE_SYNC_PARAMETERS CTL_CODE(IOCTL_DFS_BASE, 37, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_MODIFY_PREFIX         CTL_CODE(IOCTL_DFS_BASE, 38, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_FIX_LOCAL_VOLUME      CTL_CODE(IOCTL_DFS_BASE, 39, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_DRIVE_INFO        CTL_CODE(IOCTL_DFS_BASE, 40, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_DRIVE_FOR_PATH    CTL_CODE(IOCTL_DFS_BASE, 41, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PATH_TO_INFO          CTL_CODE(IOCTL_DFS_BASE, 42, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_INIT_MACH_SHARES      CTL_CODE(IOCTL_DFS_BASE, 43, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_ENTRY_MODIFY_GUID CTL_CODE(IOCTL_DFS_BASE, 44, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_UPDATE_DOMAIN_KNOWLEDGE CTL_CODE(IOCTL_DFS_BASE, 45, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_LINK_DRIVE             CTL_CODE(IOCTL_DFS_BASE, 46, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_CONNECTED_RESOURCES CTL_CODE(IOCTL_DFS_BASE, 47, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_SERVER_NAME       CTL_CODE(IOCTL_DFS_BASE, 48, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_PATH_FROM_PREFIX  CTL_CODE(IOCTL_DFS_BASE, 49, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_READ_METERS           CTL_CODE(IOCTL_DFS_BASE, 50, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_SHUFFLE_ENTRY         CTL_CODE(IOCTL_DFS_BASE, 51, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_FIRST_SVC         CTL_CODE(IOCTL_DFS_BASE, 52, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_NEXT_SVC          CTL_CODE(IOCTL_DFS_BASE, 53, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_ENTRY_TYPE        CTL_CODE(IOCTL_DFS_BASE, 54, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_GET_HANDLE_SERVER_INFO CTL_CODE(IOCTL_DFS_BASE, 55, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Ea buffer name to open JPs
//

#define EA_NAME_OPENIFJP        ".OpenIfJP"

//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//


//[ dfs_object_guids
//
// The following structure describes the guids that identify an object
// anywhere on the network. This is returned by FSCTL_DFS_GET_HANDLE_IDS.
//

typedef struct _DFS_OBJECT_GUIDS {
    GUID        guidDomain;
    GUID        guidVolume;
    GUID        guidObject;
    ULONG       ulUniquifier;
} DFS_OBJECT_GUIDS, *PDFS_OBJECT_GUIDS;

//[ dfs_site_cost
//
//  The following structure describes a site cost.
//

typedef struct _DFS_SITE_COST {
    GUID        guidSite;
    unsigned long dwCost;
} DFS_SITE_COST, *PDFS_SITE_COST;

//[ dfs_referral
//
//  The following structures describe a set of referrals.
//

typedef enum _DFS_REF_TYPE {
    MasterReplica = 1,
    ReadOnlyReplica = 2,
    KnowledgeSource = 3,
    LocalReplica = 4,
} DFS_REF_TYPE;


//  Standardized provider IDs as given in eProviderId

#define PROV_ID_LOCAL_FS        0x101   // generic local file system
#define PROV_ID_DFS_RDR         0x201   // The standard Cairo redirector
#define PROV_ID_LM_RDR          0x202   // The usual LanMan (downlevel) redir


//  Provider capabilities as given in fRefCapability and fProvCapability
#define PROV_OFS_API      1     // accepts OFS extension APIs
#define PROV_DFS_RDR      2     // accepts NtCreateFile with EA Principal
#define PROV_STRIP_PREFIX 4     // strip file name prefix before redispatching
#define PROV_UNAVAILABLE  8     // provider unavailable - try to reattach.


typedef struct _DFS_REFERRAL {
    ULONG       cbRefSize;      // total size of referral struct
    USHORT      eProviderId;    // ID of provider
    USHORT      fRefCapability; // Capabilities of provider
    DFS_REF_TYPE eRefType;      // type of referral
    ULONG       cbAddrSize;     // size in bytes of address part
    ULONG       cwPrincipal;    // size of principal name
    ULONG       cbMachine;      // size of Machine Buf below.
    UCHAR       bAddr[1];       // server and resource name/address
    WCHAR       Principal[1];   // server principal name if cwPrincipal != 0
    UCHAR       MachineBuf[1];  // Machine struct is marshalled into this.
} DFS_REFERRAL;

typedef struct _DFS_REF_LIST {
    ULONG       cReferrals;     // num of referral structs which follow
    DFS_REFERRAL sReferrals[1]; // one or more referral structures
} DFS_REF_LIST;
//]


//[ dsfs_fsctlstructs
//  Control structure for FSCTL_DFS_DEFINE_LOGICAL_ROOT

typedef struct _FILE_DFS_DEF_LOGICAL_ROOT_BUFFER {
    BOOLEAN     fForce;
    WCHAR       LogicalRoot[MAX_LOGICAL_ROOT_NAME];
    WCHAR       RootPrefix[1];
} FILE_DFS_DEF_ROOT_BUFFER, *PFILE_DFS_DEF_ROOT_BUFFER;


// Control structure for FSCTL_DFS_NAME_RESOLVE

#define DFS_NAME_RES_TYPE_REFERRAL      0
#define DFS_NAME_RES_TYPE_LOCAL         1

typedef struct _FILE_DFS_NAME_RESOLVE_BUFFER {
    ULONG       ServiceTypes;
    ULONG       ReferralType;                    // 1 means return entry that
    WCHAR       PrefixName[1];                   // matches Prefix, 0 means
                                                 // return referral for Prefix
} FILE_DFS_NAME_RESOLVE_BUFFER, *PFILE_DFS_NAME_RESOLVE_BUFFER;


//  Control structure for FSCTL_DFS_UPD_REFERRAL

typedef struct _FILE_DFS_UPD_REFERRAL_BUFFER {
    ULONG       ReferralOffset; // Offset in buffer of referral data
    GUID        PrefixID;       // partition ID
    ULONG       ReferralEntryType;
    WCHAR       PrefixName[1];
    DFS_REF_LIST ReferralData;
} FILE_DFS_UPD_REFERRAL_BUFFER, *PFILE_DFS_UPD_REFERRAL_BUFFER;




//  Control structure for FSCTL_DFS_DEFINE_PROVIDER

typedef struct _FILE_DFS_DEF_PROVIDER {
    USHORT      eProviderId;    // ID of provider
    USHORT      fProvCapability; // Capabilities of provider
    WCHAR       ProviderName[1];
} FILE_DFS_DEF_PROVIDER, *PFILE_DFS_DEF_PROVIDER;


//  Control structure for FSCTL_DFS_GET_DRIVE_FOR_PATH

typedef struct _FILE_DFS_GET_DRIVE {
    WCHAR       wcDrive;
    ULONG       cbMatchLength;
} FILE_DFS_GET_DRIVE, *PFILE_DFS_GET_DRIVE;

//]

#ifdef __cplusplus
}
#endif

#endif  // _NTDDDFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddcdrm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddcdrm.h

Abstract:

    This module contains structures and definitions
    associated with CDROM IOCTls.

Author:

    Mike Glass

Revision History:

--*/

// begin_winioctl

#ifndef _NTDDCDRM_
#define _NTDDCDRM_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_CDROM_BASE                 FILE_DEVICE_CD_ROM

#define IOCTL_CDROM_UNLOAD_DRIVER        CTL_CODE(IOCTL_CDROM_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// CDROM Audio Device Control Functions
//

#define IOCTL_CDROM_READ_TOC         CTL_CODE(IOCTL_CDROM_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_CONTROL      CTL_CODE(IOCTL_CDROM_BASE, 0x000D, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_PLAY_AUDIO_MSF   CTL_CODE(IOCTL_CDROM_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SEEK_AUDIO_MSF   CTL_CODE(IOCTL_CDROM_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_STOP_AUDIO       CTL_CODE(IOCTL_CDROM_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_PAUSE_AUDIO      CTL_CODE(IOCTL_CDROM_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RESUME_AUDIO     CTL_CODE(IOCTL_CDROM_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_VOLUME       CTL_CODE(IOCTL_CDROM_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SET_VOLUME       CTL_CODE(IOCTL_CDROM_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_READ_Q_CHANNEL   CTL_CODE(IOCTL_CDROM_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_LAST_SESSION CTL_CODE(IOCTL_CDROM_BASE, 0x000E, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RAW_READ         CTL_CODE(IOCTL_CDROM_BASE, 0x000F, METHOD_OUT_DIRECT,  FILE_READ_ACCESS)
#define IOCTL_CDROM_DISK_TYPE        CTL_CODE(IOCTL_CDROM_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CDROM_GET_DRIVE_GEOMETRY CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)

// end_winioctl

//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future with the IOCTL_STORAGE
// codes included below
//

#define IOCTL_CDROM_CHECK_VERIFY    CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_MEDIA_REMOVAL   CTL_CODE(IOCTL_CDROM_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_EJECT_MEDIA     CTL_CODE(IOCTL_CDROM_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_LOAD_MEDIA      CTL_CODE(IOCTL_CDROM_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RESERVE         CTL_CODE(IOCTL_CDROM_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RELEASE         CTL_CODE(IOCTL_CDROM_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_FIND_NEW_DEVICES CTL_CODE(IOCTL_CDROM_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following file contains the IOCTL_STORAGE class ioctl definitions
//

#include <ntddstor.h>

// begin_winioctl

//
// The following device control code is for the SIMBAD simulated bad
// sector facility. See SIMBAD.H in this directory for related structures.
//

#define IOCTL_CDROM_SIMBAD        CTL_CODE(IOCTL_CDROM_BASE, 0x1003, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Maximum CD Rom size
//

#define MAXIMUM_NUMBER_TRACKS 100
#define MAXIMUM_CDROM_SIZE 804

//
// CD ROM Table OF Contents (TOC)
//
// Format 0 - Get table of contents
//

typedef struct _TRACK_DATA {
    UCHAR Reserved;
    UCHAR Control : 4;
    UCHAR Adr : 4;
    UCHAR TrackNumber;
    UCHAR Reserved1;
    UCHAR Address[4];
} TRACK_DATA, *PTRACK_DATA;

typedef struct _CDROM_TOC {

    //
    // Header
    //

    UCHAR Length[2];
    UCHAR FirstTrack;
    UCHAR LastTrack;

    //
    // Track data
    //

    TRACK_DATA TrackData[MAXIMUM_NUMBER_TRACKS];
} CDROM_TOC, *PCDROM_TOC;

#define CDROM_TOC_SIZE sizeof(CDROM_TOC)

//
// Play audio starting at MSF and ending at MSF
//

typedef struct _CDROM_PLAY_AUDIO_MSF {
    UCHAR StartingM;
    UCHAR StartingS;
    UCHAR StartingF;
    UCHAR EndingM;
    UCHAR EndingS;
    UCHAR EndingF;
} CDROM_PLAY_AUDIO_MSF, *PCDROM_PLAY_AUDIO_MSF;

//
// Seek to MSF
//

typedef struct _CDROM_SEEK_AUDIO_MSF {
    UCHAR M;
    UCHAR S;
    UCHAR F;
} CDROM_SEEK_AUDIO_MSF, *PCDROM_SEEK_AUDIO_MSF;


//
//  Flags for the disk type
//

typedef struct _CDROM_DISK_DATA {

    ULONG DiskData;

} CDROM_DISK_DATA, *PCDROM_DISK_DATA;

#define CDROM_DISK_AUDIO_TRACK      (0x00000001)
#define CDROM_DISK_DATA_TRACK       (0x00000002)

//
// CD ROM Data Mode Codes, used with IOCTL_CDROM_READ_Q_CHANNEL
//

#define IOCTL_CDROM_SUB_Q_CHANNEL    0x00
#define IOCTL_CDROM_CURRENT_POSITION 0x01
#define IOCTL_CDROM_MEDIA_CATALOG    0x02
#define IOCTL_CDROM_TRACK_ISRC       0x03

typedef struct _CDROM_SUB_Q_DATA_FORMAT {
    UCHAR Format;
    UCHAR Track;
} CDROM_SUB_Q_DATA_FORMAT, *PCDROM_SUB_Q_DATA_FORMAT;


//
// CD ROM Sub-Q Channel Data Format
//

typedef struct _SUB_Q_HEADER {
    UCHAR Reserved;
    UCHAR AudioStatus;
    UCHAR DataLength[2];
} SUB_Q_HEADER, *PSUB_Q_HEADER;

typedef struct _SUB_Q_CURRENT_POSITION {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Control : 4;
    UCHAR ADR : 4;
    UCHAR TrackNumber;
    UCHAR IndexNumber;
    UCHAR AbsoluteAddress[4];
    UCHAR TrackRelativeAddress[4];
} SUB_Q_CURRENT_POSITION, *PSUB_Q_CURRENT_POSITION;

typedef struct _SUB_Q_MEDIA_CATALOG_NUMBER {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Reserved[3];
    UCHAR Reserved1 : 7;
    UCHAR Mcval : 1;
    UCHAR MediaCatalog[15];
} SUB_Q_MEDIA_CATALOG_NUMBER, *PSUB_Q_MEDIA_CATALOG_NUMBER;

typedef struct _SUB_Q_TRACK_ISRC {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Reserved0;
    UCHAR Track;
    UCHAR Reserved1;
    UCHAR Reserved2 : 7;
    UCHAR Tcval : 1;
    UCHAR TrackIsrc[15];
} SUB_Q_TRACK_ISRC, *PSUB_Q_TRACK_ISRC;

typedef union _SUB_Q_CHANNEL_DATA {
    SUB_Q_CURRENT_POSITION CurrentPosition;
    SUB_Q_MEDIA_CATALOG_NUMBER MediaCatalog;
    SUB_Q_TRACK_ISRC TrackIsrc;
} SUB_Q_CHANNEL_DATA, *PSUB_Q_CHANNEL_DATA;

//
// Audio Status Codes
//

#define AUDIO_STATUS_NOT_SUPPORTED  0x00
#define AUDIO_STATUS_IN_PROGRESS    0x11
#define AUDIO_STATUS_PAUSED         0x12
#define AUDIO_STATUS_PLAY_COMPLETE  0x13
#define AUDIO_STATUS_PLAY_ERROR     0x14
#define AUDIO_STATUS_NO_STATUS      0x15

//
// ADR Sub-channel Q Field
//

#define ADR_NO_MODE_INFORMATION     0x0
#define ADR_ENCODES_CURRENT_POSITION 0x1
#define ADR_ENCODES_MEDIA_CATALOG   0x2
#define ADR_ENCODES_ISRC            0x3

//
// Sub-channel Q Control Bits
//

#define AUDIO_WITH_PREEMPHASIS      0x1
#define DIGITAL_COPY_PERMITTED      0x2
#define AUDIO_DATA_TRACK            0x4
#define TWO_FOUR_CHANNEL_AUDIO      0x8

//
// Get Audio control parameters
//

typedef struct _CDROM_AUDIO_CONTROL {
    UCHAR LbaFormat;
    USHORT LogicalBlocksPerSecond;
} CDROM_AUDIO_CONTROL, *PCDROM_AUDIO_CONTROL;

//
// Volume control - Volume takes a value between 1 and 0xFF.
// SCSI-II CDROM audio suppports up to 4 audio ports with
// Independent volume control.
//

typedef struct _VOLUME_CONTROL {
    UCHAR PortVolume[4];
} VOLUME_CONTROL, *PVOLUME_CONTROL;

typedef enum _TRACK_MODE_TYPE {
    YellowMode2,
    XAForm2,
    CDDA
} TRACK_MODE_TYPE, *PTRACK_MODE_TYPE;

//
// Passed to cdrom to describe the raw read, ie. Mode 2, Form 2, CDDA...
//

typedef struct __RAW_READ_INFO {
    LARGE_INTEGER DiskOffset;
    ULONG    SectorCount;
    TRACK_MODE_TYPE TrackMode;
} RAW_READ_INFO, *PRAW_READ_INFO;

#ifdef __cplusplus
}
#endif

#endif  // _NTDDCDRM_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddbeep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddbeep.h

Abstract:

    This is the include file that defines all constants and types for
    the beep device.

Author:

    Lee A. Smith (lees) 02-Aug-1991.

Revision History:

--*/

#ifndef _NTDDBEEP_
#define _NTDDBEEP_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_BEEP_DEVICE_NAME    "\\Device\\Beep"
#define DD_BEEP_DEVICE_NAME_U L"\\Device\\Beep"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_BEEP_SET CTL_CODE(FILE_DEVICE_BEEP, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile OutputBuffer record structures for
// IOCTL_BEEP_SET.
//

typedef struct _BEEP_SET_PARAMETERS {
    ULONG Frequency;
    ULONG Duration;
} BEEP_SET_PARAMETERS, *PBEEP_SET_PARAMETERS;

#define BEEP_FREQUENCY_MINIMUM 0x25
#define BEEP_FREQUENCY_MAXIMUM 0x7FFF

#ifdef __cplusplus
}
#endif

#endif // _NTDDBEEP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddcdvd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddcdvd.h

Abstract:

    This module contains structures and definitions
    associated with DVD ioctls.

    This module is used in conjunction with ntddcdrm.h which contains the
    cdrom specific ioctls which will work on CDVD drives

Author:

    Peter Wieland

Revision History:

--*/

// begin_winioctl

#ifndef _NTDDCDVD_
#define _NTDDCDVD_

#if _MSC_VER > 1000
#pragma once
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_DVD_BASE                 FILE_DEVICE_DVD

//
// CDVD Device Control Functions
//
// Warning: Ioctls from 200 through 300 are used for the old common class
// driver ioctls and should not be used for device specific functionality
//

//
// Copyright ioctls
//

#define IOCTL_DVD_START_SESSION     CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_READ_KEY          CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY          CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_END_SESSION       CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SET_READ_AHEAD    CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_GET_REGION        CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY2         CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// DVD Structure queries
//

#define IOCTL_DVD_READ_STRUCTURE    CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following file contains the IOCTL_STORAGE class ioctl definitions
//

#define IOCTL_STORAGE_SET_READ_AHEAD        CTL_CODE(IOCTL_STORAGE_BASE, 0x0100, METHOD_BUFFERED, FILE_READ_ACCESS)

// end_winioctl

#include <ntddstor.h>

// begin_winioctl


#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    DvdChallengeKey = 0x01,
    DvdBusKey1,
    DvdBusKey2,
    DvdTitleKey,
    DvdAsf,
    DvdSetRpcKey = 0x6,
    DvdGetRpcKey = 0x8,
    DvdDiskKey = 0x80,
    DvdInvalidateAGID = 0x3f
} DVD_KEY_TYPE;

typedef ULONG DVD_SESSION_ID, *PDVD_SESSION_ID;

typedef struct _DVD_COPY_PROTECT_KEY {
    ULONG KeyLength;
    DVD_SESSION_ID SessionId;
    DVD_KEY_TYPE KeyType;
    ULONG KeyFlags;
    union {
        HANDLE FileHandle;
        LARGE_INTEGER TitleOffset;
    } Parameters;
    UCHAR KeyData[0];
} DVD_COPY_PROTECT_KEY, *PDVD_COPY_PROTECT_KEY;

//
// Predefined (Mt. Fuji) key sizes
// Add sizeof(DVD_COPY_PROTECT_KEY) to get allocation size for
// the full key structure
//

#define DVD_CHALLENGE_KEY_LENGTH    (12 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_BUS_KEY_LENGTH          (8 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_TITLE_KEY_LENGTH        (8 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_DISK_KEY_LENGTH         (2048 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_RPC_KEY_LENGTH          (sizeof(DVD_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_SET_RPC_KEY_LENGTH      (sizeof(DVD_SET_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_ASF_LENGTH              (sizeof(DVD_ASF) + sizeof(DVD_COPY_PROTECT_KEY))

//
// Used with IOCTL_DVD_END_SESSION to end all DVD sessions at once
//

#define DVD_END_ALL_SESSIONS ((DVD_SESSION_ID) 0xffffffff)

//
// CGMS Copy Protection Flags
//

#define DVD_CGMS_RESERVED_MASK      0x00000078

#define DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define DVD_CGMS_COPY_PERMITTED     0x00000000
#define DVD_CGMS_COPY_ONCE          0x00000010
#define DVD_CGMS_NO_COPY            0x00000018

#define DVD_COPYRIGHT_MASK          0x00000040
#define DVD_NOT_COPYRIGHTED         0x00000000
#define DVD_COPYRIGHTED             0x00000040

#define DVD_SECTOR_PROTECT_MASK     0x00000020
#define DVD_SECTOR_NOT_PROTECTED    0x00000000
#define DVD_SECTOR_PROTECTED        0x00000020

/*++

IOCTL_STORAGE_SET_READ_AHEAD

Requests that the storage device skip to TargetAddress once it has run across
TriggerAddress during the course of it's read-ahead caching operations.

Input:

    a STORAGE_SET_READ_AHEAD structure which contains:
        * the trigger address
        * the target address

Output:

    none

--*/

typedef struct _STORAGE_SET_READ_AHEAD {
    LARGE_INTEGER TriggerAddress;
    LARGE_INTEGER TargetAddress;
} STORAGE_SET_READ_AHEAD, *PSTORAGE_SET_READ_AHEAD;

/*++

IOCTL_DVD_READ_STRUCTURE

Issues a READ_DVD_STRUCTURE command to the drive.

Input:

    a DVD_READ_STRUCTURE describing what information is requested

Output:

    a DVD Layer Descriptor as defined below

--*/

typedef enum DVD_STRUCTURE_FORMAT {
    DvdPhysicalDescriptor,
    DvdCopyrightDescriptor,
    DvdDiskKeyDescriptor,
    DvdBCADescriptor,
    DvdManufacturerDescriptor,
    DvdMaxDescriptor
} DVD_STRUCTURE_FORMAT, *PDVD_STRUCTURE_FORMAT;

typedef struct DVD_READ_STRUCTURE {
    LARGE_INTEGER BlockByteOffset;
    DVD_STRUCTURE_FORMAT Format;
    DVD_SESSION_ID SessionId;
    UCHAR LayerNumber;
} DVD_READ_STRUCTURE, *PDVD_READ_STRUCTURE;

typedef struct _DVD_DESCRIPTOR_HEADER {
    USHORT Length;
    UCHAR Reserved[2];
    UCHAR Data[0];
} DVD_DESCRIPTOR_HEADER, *PDVD_DESCRIPTOR_HEADER;

typedef struct _DVD_LAYER_DESCRIPTOR {
    USHORT Length;
    UCHAR BookVersion : 4;
    UCHAR BookType : 4;
    UCHAR MinimumRate : 4;
    UCHAR DiskSize : 4;
    UCHAR LayerType : 4;
    UCHAR TrackPath : 1;
    UCHAR NumberOfLayers : 2;
    UCHAR Reserved1 : 1;
    UCHAR TrackDensity : 4;
    UCHAR LinearDensity : 4;
    ULONG StartingDataSector;
    ULONG EndDataSector;
    ULONG EndLayerZeroSector;
    UCHAR Reserved5 : 7;
    UCHAR BCAFlag : 1;
    UCHAR Reserved6;
} DVD_LAYER_DESCRIPTOR, *PDVD_LAYER_DESCRIPTOR;

typedef struct _DVD_COPYRIGHT_DESCRIPTOR {
    UCHAR CopyrightProtectionType;
    UCHAR RegionManagementInformation;
    USHORT Reserved;
} DVD_COPYRIGHT_DESCRIPTOR, *PDVD_COPYRIGHT_DESCRIPTOR;

typedef struct _DVD_DISK_KEY_DESCRIPTOR {
    UCHAR DiskKeyData[2048];
} DVD_DISK_KEY_DESCRIPTOR, *PDVD_DISK_KEY_DESCRIPTOR;

typedef struct _DVD_BCA_DESCRIPTOR {
    UCHAR BCAInformation[0];
} DVD_BCA_DESCRIPTOR, *PDVD_BCA_DESCRIPTOR;

typedef struct _DVD_MANUFACTURER_DESCRIPTOR {
    UCHAR ManufacturingInformation[2048];
} DVD_MANUFACTURER_DESCRIPTOR, *PDVD_MANUFACTURER_DESCRIPTOR;

typedef struct _DVD_RPC_KEY {
    UCHAR UserResetsAvailable:3;
    UCHAR ManufacturerResetsAvailable:3;
    UCHAR TypeCode:2;
    UCHAR RegionMask;
    UCHAR RpcScheme;
    UCHAR Reserved2[1];
} DVD_RPC_KEY, * PDVD_RPC_KEY;

typedef struct _DVD_SET_RPC_KEY {
    UCHAR PreferredDriveRegionCode;
    UCHAR Reserved[3];
} DVD_SET_RPC_KEY, * PDVD_SET_RPC_KEY;

typedef struct _DVD_ASF {
    UCHAR Reserved0[3];
    UCHAR SuccessFlag:1;
    UCHAR Reserved1:7;
} DVD_ASF, * PDVD_ASF;

typedef struct _DVD_REGION {
     UCHAR CopySystem;
     UCHAR RegionData;                      // current media region (not playable when set)
     UCHAR SystemRegion;                    // current drive region (playable when set)
     UCHAR ResetCount;                      // number of resets available
} DVD_REGION, *PDVD_REGION;

#ifdef __cplusplus
}
#endif

#endif  // _NTDDCDVD_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddft2.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    ntddft2.h

Abstract:

    This header file defines new IOCTLs for the FTDISK driver to support
    the new FT API.

Author:

    Norbert Kusters 13-July-1996

Notes:

Revision History:

--*/

#ifndef _NTDDFT2_
#define _NTDDFT2_

#if _MSC_VER > 1000
#pragma once
#endif

#include <fttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// The name of the control device for the FT disk driver.
//

#define DD_FT_CONTROL_DEVICE_NAME   L"\\Device\\FtControl"
#define DD_DOS_FT_CONTROL_NAME      L"\\\\.\\FtControl"

//
// Control codes handled by the 'FtControl' device.
//

#define FTCONTROLTYPE   ((ULONG) 'g')

#define FT_CREATE_LOGICAL_DISK                      CTL_CODE(FTCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_BREAK_LOGICAL_DISK                       CTL_CODE(FTCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_ENUMERATE_LOGICAL_DISKS                  CTL_CODE(FTCONTROLTYPE, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_QUERY_LOGICAL_DISK_INFORMATION           CTL_CODE(FTCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_ORPHAN_LOGICAL_DISK_MEMBER               CTL_CODE(FTCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_REPLACE_LOGICAL_DISK_MEMBER              CTL_CODE(FTCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK    CTL_CODE(FTCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_INITIALIZE_LOGICAL_DISK                  CTL_CODE(FTCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK      CTL_CODE(FTCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_CHECK_IO                                 CTL_CODE(FTCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK        CTL_CODE(FTCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION       CTL_CODE(FTCONTROLTYPE, 12, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_CHANGE_NOTIFY                            CTL_CODE(FTCONTROLTYPE, 13, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_STOP_SYNC_OPERATIONS                     CTL_CODE(FTCONTROLTYPE, 14, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Control codes handles by FT logical disks.
//

#define FT_QUERY_LOGICAL_DISK_ID                    CTL_CODE(FTCONTROLTYPE, 100, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_CREATE_PARTITION_LOGICAL_DISK            CTL_CODE(FTCONTROLTYPE, 101, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Input parameter for FT_CREATE_LOGICAL_DISK.
//

typedef struct _FT_CREATE_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_TYPE    LogicalDiskType;
    USHORT                  NumberOfMembers;
    USHORT                  ConfigurationInformationSize;
    FT_LOGICAL_DISK_ID      MemberArray[1];
} FT_CREATE_LOGICAL_DISK_INPUT, *PFT_CREATE_LOGICAL_DISK_INPUT;

//
// Output parameter for FT_CREATE_LOGICAL_DISK.
//

typedef struct _FT_CREATE_LOGICAL_DISK_OUTPUT {
    FT_LOGICAL_DISK_ID  NewLogicalDiskId;
} FT_CREATE_LOGICAL_DISK_OUTPUT, *PFT_CREATE_LOGICAL_DISK_OUTPUT;

//
// Input parameter for FT_BREAK_LOGICAL_DISK.
//

typedef struct _FT_BREAK_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_BREAK_LOGICAL_DISK_INPUT, *PFT_BREAK_LOGICAL_DISK_INPUT;

//
// Output parameter for FT_ENUMERATE_LOGICAL_DISKS.
//

typedef struct _FT_ENUMERATE_LOGICAL_DISKS_OUTPUT {
    ULONG               NumberOfRootLogicalDisks;
    ULONG               Reserved;
    FT_LOGICAL_DISK_ID  RootLogicalDiskIds[1];
} FT_ENUMERATE_LOGICAL_DISKS_OUTPUT, *PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT;

//
// Input parameter for FT_QUERY_LOGICAL_DISK_INFORMATION.
//

typedef struct _FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
} FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT, *PFT_QUERY_LOGICAL_DISK_INFORMATION_INPUT;

//
// Output parameter for FT_QUERY_LOGICAL_DISK_INFORMATION.
//

typedef struct _FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT {
    FT_LOGICAL_DISK_TYPE    LogicalDiskType;
    LONGLONG                VolumeSize;
    USHORT                  NumberOfMembers;
    USHORT                  ConfigurationInformationSize;
    USHORT                  StateInformationSize;
    USHORT                  Reserved;
    FT_LOGICAL_DISK_ID      MemberArray[1];
} FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT, *PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT;

//
// Input parameter for FT_ORPHAN_LOGICAL_DISK_MEMBER.
//

typedef struct _FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
    USHORT              MemberNumberToOrphan;
    USHORT              Reserved[3];
} FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT, *PFT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT;

//
// Input parameter for FT_REPLACE_LOGICAL_DISK_MEMBER.
//

typedef struct _FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
    USHORT              MemberNumberToReplace;
    USHORT              Reserved[3];
    FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId;
} FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT, *PFT_REPLACE_LOGICAL_DISK_MEMBER_INPUT;

//
// Output parameter for FT_REPLACE_LOGICAL_DISK_MEMBER.
//

typedef struct _FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT {
    FT_LOGICAL_DISK_ID  NewLogicalDiskId;
} FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT, *PFT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT;

//
// Input parameter for FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT;

//
// Output parameter for FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT {
    USHORT  NumberOfCharactersInNtDeviceName;
    WCHAR   NtDeviceName[1];
} FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT;

//
// Input parameter for FT_INITIALIZE_LOGICAL_DISK.
//

typedef struct _FT_INITIALIZE_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
    BOOLEAN             RegenerateOrphans;
} FT_INITIALIZE_LOGICAL_DISK_INPUT, *PFT_INITIALIZE_LOGICAL_DISK_INPUT;

//
// Input parameter for FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT, *PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT;

//
// Output parameter for FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT {
    UCHAR   DriveLetter;
} FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT, *PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT;

//
// Input parameter for FT_CHECK_IO.
//

typedef struct _FT_CHECK_IO_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
} FT_CHECK_IO_INPUT, *PFT_CHECK_IO_INPUT;

//
// Output parameter for FT_CHECK_IO.
//

typedef struct _FT_CHECK_IO_OUTPUT {
    BOOLEAN IsIoOk;
} FT_CHECK_IO_OUTPUT, *PFT_CHECK_IO_OUTPUT;

//
// Input parameter for FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK.
//

typedef struct _FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
    UCHAR               DriveLetter;
} FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT, *PFT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT;

//
// Input parameter for FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT {
    ULONG       Signature;
    ULONG       Reserved;
    LONGLONG    Offset;
} FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT;

//
// Output parameter for FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT {
    USHORT  NumberOfCharactersInNtDeviceName;
    WCHAR   NtDeviceName[1];
} FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT;

//
// Input parameter for FT_STOP_SYNC_OPERATIONS.
//

typedef struct _FT_STOP_SYNC_OPERATIONS_INPUT {
    FT_LOGICAL_DISK_ID RootLogicalDiskId;
} FT_STOP_SYNC_OPERATIONS_INPUT, *PFT_STOP_SYNC_OPERATIONS_INPUT;

//
// Output parameter for FT_QUERY_LOGICAL_DISK_ID.
//

typedef struct _FT_QUERY_LOGICAL_DISK_ID_OUTPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_QUERY_LOGICAL_DISK_ID_OUTPUT, *PFT_QUERY_LOGICAL_DISK_ID_OUTPUT;

//
// Output parameter for FT_CREATE_PARTITION_LOGICAL_DISK.
//

typedef struct _FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT {
    FT_LOGICAL_DISK_ID  NewLogicalDiskId;
} FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT, *PFT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT;

#ifdef __cplusplus
}
#endif

#endif  // _NTDDFT2_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddft.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntddft.h

Abstract:

    This file contains NTFT definitions and prototypes.

Authors:

    Bob Rinne
    Mike Glass

Notes:

Revision History:

--*/

#ifndef _NTDDFT_
#define _NTDDFT_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntdskreg.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Control Codes
//

#define FTTYPE  ((ULONG)'f')

#define FT_INITIALIZE_SET CTL_CODE(FTTYPE, 0, METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define FT_REGENERATE     CTL_CODE(FTTYPE, 1, METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define FT_CONFIGURE      CTL_CODE(FTTYPE, 2, METHOD_NEITHER,    FILE_ANY_ACCESS)
#define FT_VERIFY         CTL_CODE(FTTYPE, 3, METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define FT_SECONDARY_READ CTL_CODE(FTTYPE, 4, METHOD_OUT_DIRECT, FILE_READ_ACCESS)
#define FT_PRIMARY_READ   CTL_CODE(FTTYPE, 5, METHOD_OUT_DIRECT, FILE_READ_ACCESS)
#define FT_BALANCED_READ_MODE    CTL_CODE(FTTYPE, 6, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FT_SYNC_REDUNDANT_COPY   CTL_CODE(FTTYPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FT_SEQUENTIAL_WRITE_MODE CTL_CODE(FTTYPE, 8, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FT_PARALLEL_WRITE_MODE   CTL_CODE(FTTYPE, 9, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FT_QUERY_SET_STATE       CTL_CODE(FTTYPE,10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FT_CLUSTER_SET_MEMBER_STATE CTL_CODE(FTTYPE,11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FT_CLUSTER_GET_MEMBER_STATE CTL_CODE(FTTYPE,12, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Used as input parameters to the SECONDARY and PRIMARY read device controls
//

typedef struct _FT_SPECIAL_READ {
    LARGE_INTEGER ByteOffset;
    ULONG         Length;
} FT_SPECIAL_READ, *PFT_SPECIAL_READ;

//
// Used to find a partition in the system.
//

typedef struct _FT_CONTROL_BLOCK {
    USHORT     Type;
    USHORT     FtGroup;
} FT_CONTROL_BLOCK, *PFT_CONTROL_BLOCK;

//
// FT SYNC primary from secondary IOCTL
//

typedef struct _FT_SYNC_INFORMATION {
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER ByteCount;
} FT_SYNC_INFORMATION, *PFT_SYNC_INFORMATION;

//
// Define for registry information.
//

#define DISK_REGISTRY_KEY  "\\REGISTRY\\MACHINE\\SYSTEM\\DISK"

//
// Define for value name for registry information.
//

#define DISK_REGISTRY_VALUE "Information"

//
// Structures for config registry.
//

//
// The header for the registry information structure.
//

#include "pshpack4.h"
typedef struct _DISK_CONFIG_HEADER {

    ULONG Version;
    ULONG CheckSum;
    BOOLEAN DirtyShutdown;
    UCHAR Reserved[3];
    ULONG DiskInformationOffset;
    ULONG DiskInformationSize;
    ULONG FtInformationOffset;
    ULONG FtInformationSize;
    ULONG FtStripeWidth;
    ULONG FtPoolSize;
    ULONG NameOffset;  // Reserved for future.
    ULONG NameSize;    // Reserved for future.

} DISK_CONFIG_HEADER, *PDISK_CONFIG_HEADER;

#define DISK_INFORMATION_VERSION    0x03

//
// FT_STATE is an enumerated field that describes the state of the FT
// volume as a whole.
//

typedef enum _FT_STATE {

    FtStateOk,      // set is complete
    FtHasOrphan,    // set is running, but one member is turned off
    FtDisabled,     // set has been turned off - it cannot be used
    FtRegenerating, // member of set is being generated from check data
    FtInitializing, // set is being initialized
    FtCheckParity,  // check data is not in sync
    FtNoCheckData   // parity has not been initialized

} FT_STATE, *PFT_STATE;

//
// State information for an FT set.  The partition state enum is used to
// specify the state for the complete set.
//

typedef struct _FT_SET_INFORMATION {
    ULONG        NumberOfMembers;
    FT_TYPE      Type;
    FT_STATE     SetState;
} FT_SET_INFORMATION, *PFT_SET_INFORMATION;

//
// The description information for an FT component member.
//

typedef struct _FT_MEMBER_DESCRIPTION {

    USHORT        State;
    USHORT        ReservedShort;
    ULONG         Signature;
    ULONG         OffsetToPartitionInfo;
    ULONG         LogicalNumber;

} FT_MEMBER_DESCRIPTION, *PFT_MEMBER_DESCRIPTION;

//
// Definitions for FT volume state.
//

//
// When this state is set, FT assumes at boot time that the volume
// must be initialized and starts a system thread of execution to
// perform the initialization work.
//

#define FT_VOLUME_INITIALIZING 0x0001
#define FT_VOLUME_REGENERATING 0x0002

//
// The description information for an FT component.
//

typedef struct _FT_DESCRIPTION {

    USHORT   NumberOfMembers;
    USHORT   Type;
    ULONG    Reserved;

    //
    // The volume state will indicate which member is being regenerated
    //

    FT_STATE FtVolumeState;

    //
    // Array for NumberOfMembers
    //

    FT_MEMBER_DESCRIPTION FtMemberDescription[1];

} FT_DESCRIPTION, *PFT_DESCRIPTION;

//
// Header for all FT information.
//

typedef struct _FT_REGISTRY {

    USHORT NumberOfComponents;
    USHORT ReservedShort;

    //
    // An array of NumberOfComponents
    //

    FT_DESCRIPTION FtDescription[1];

} FT_REGISTRY, *PFT_REGISTRY;
#include "poppack.h"

#ifdef __cplusplus
}
#endif

#endif  // _NTDDFT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntdddisk.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntdddisk.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Disk device.

Revision History:

--*/

#ifndef _NTDDDISK_H_
#define _NTDDDISK_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_DISK_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile

// begin_winioctl

//
// IoControlCode values for disk devices.
//

#define IOCTL_DISK_BASE                 FILE_DEVICE_DISK
#define IOCTL_DISK_GET_DRIVE_GEOMETRY   CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_GET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_VERIFY               CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS        CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_REASSIGN_BLOCKS      CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_PERFORMANCE          CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_IS_WRITABLE          CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_LOGGING              CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS_EX     CTL_CODE(IOCTL_DISK_BASE, 0x000b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_HISTOGRAM_STRUCTURE  CTL_CODE(IOCTL_DISK_BASE, 0x000c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_DATA       CTL_CODE(IOCTL_DISK_BASE, 0x000d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_RESET      CTL_CODE(IOCTL_DISK_BASE, 0x000e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_STRUCTURE    CTL_CODE(IOCTL_DISK_BASE, 0x000f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_DATA         CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)


#if(_WIN32_WINNT >= 0x0400)
#define IOCTL_DISK_CONTROLLER_NUMBER    CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL support for SMART drive fault prediction.
//

#define SMART_GET_VERSION               CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS)
#define SMART_SEND_DRIVE_COMMAND        CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define SMART_RCV_DRIVE_DATA            CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)
#define IOCTL_DISK_UPDATE_DRIVE_SIZE    CTL_CODE(IOCTL_DISK_BASE, 0x0032, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GROW_PARTITION       CTL_CODE(IOCTL_DISK_BASE, 0x0034, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_DISK_GET_CACHE_INFORMATION CTL_CODE(IOCTL_DISK_BASE, 0x0035, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_CACHE_INFORMATION CTL_CODE(IOCTL_DISK_BASE, 0x0036, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_DISK_DELETE_DRIVE_LAYOUT  CTL_CODE(IOCTL_DISK_BASE, 0x0040, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
//  Special IOCTLs needed to support PC-98 machines in Japan
//

#define IOCTL_DISK_FORMAT_DRIVE         CTL_CODE(IOCTL_DISK_BASE, 0x00f3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_SENSE_DEVICE         CTL_CODE(IOCTL_DISK_BASE, 0x00f8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0500 */

// end_winioctl

//
// Internal disk driver device controls to maintain the verify status bit
// for the device object.
//

#define IOCTL_DISK_INTERNAL_SET_VERIFY   CTL_CODE(IOCTL_DISK_BASE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_CLEAR_VERIFY CTL_CODE(IOCTL_DISK_BASE, 0x0101, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Internal disk driver device control to set notification routine for
// the device object. Used in DiskPerf.
//

#define IOCTL_DISK_INTERNAL_SET_NOTIFY   CTL_CODE(IOCTL_DISK_BASE, 0x0102, METHOD_BUFFERED, FILE_ANY_ACCESS)

// begin_winioctl
//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future by equivalent
// IOCTL_STORAGE codes
//

#define IOCTL_DISK_CHECK_VERIFY     CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_MEDIA_REMOVAL    CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_EJECT_MEDIA      CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_LOAD_MEDIA       CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RESERVE          CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RELEASE          CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_FIND_NEW_DEVICES CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_GET_MEDIA_TYPES CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

// end_winioctl

//
// The following file contains the IOCTL_STORAGE class ioctls
//

#include <ntddstor.h>

// begin_winioctl
//
// Define the partition types returnable by known disk drivers.
//

#define PARTITION_ENTRY_UNUSED          0x00      // Entry unused
#define PARTITION_FAT_12                0x01      // 12-bit FAT entries
#define PARTITION_XENIX_1               0x02      // Xenix
#define PARTITION_XENIX_2               0x03      // Xenix
#define PARTITION_FAT_16                0x04      // 16-bit FAT entries
#define PARTITION_EXTENDED              0x05      // Extended partition entry
#define PARTITION_HUGE                  0x06      // Huge partition MS-DOS V4
#define PARTITION_IFS                   0x07      // IFS Partition
#define PARTITION_FAT32                 0x0B      // FAT32
#define PARTITION_FAT32_XINT13          0x0C      // FAT32 using extended int13 services
#define PARTITION_XINT13                0x0E      // Win95 partition using extended int13 services
#define PARTITION_XINT13_EXTENDED       0x0F      // Same as type 5 but uses extended int13 services
#define PARTITION_PREP                  0x41      // PowerPC Reference Platform (PReP) Boot Partition
#define PARTITION_LDM                   0x42      // Logical Disk Manager partition
#define PARTITION_UNIX                  0x63      // Unix

#define VALID_NTFT                      0xC0      // NTFT uses high order bits

//
// The high bit of the partition type code indicates that a partition
// is part of an NTFT mirror or striped array.
//

#define PARTITION_NTFT                  0x80     // NTFT partition

//
// The following macro is used to determine which partitions should be
// assigned drive letters.
//

//++
//
// BOOLEAN
// IsRecognizedPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partitions drive letters
//     should be assigned.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is recognized,
//     otherwise FALSE is returned.
//
//--

#define IsRecognizedPartition( PartitionType ) (       \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT_12)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT_16)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_IFS)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_HUGE)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT32)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_XINT13)) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT_12) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT_16) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_IFS)    ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_HUGE)    ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT32)  || \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT32_XINT13) || \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_XINT13) )

//++
//
// BOOLEAN
// IsContainerPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partition types are actually
//     containers for other partitions (ie, extended partitions).
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is a container,
//     otherwise FALSE is returned.
//
//--

#define IsContainerPartition( PartitionType ) \
    ((PartitionType == PARTITION_EXTENDED) || (PartitionType == PARTITION_XINT13_EXTENDED))

//
// Define the media types supported by the driver.
//

typedef enum _MEDIA_TYPE {
    Unknown,                // Format is unknown
    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    RemovableMedia,         // Removable media other than floppy
    FixedMedia,             // Fixed hard disk media
    F3_120M_512,            // 3.5", 120M Floppy
    F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    F8_256_128              // 8",     256KB,  128 bytes/sector
} MEDIA_TYPE, *PMEDIA_TYPE;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS.
//

typedef struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType;
   ULONG StartCylinderNumber;
   ULONG EndCylinderNumber;
   ULONG StartHeadNumber;
   ULONG EndHeadNumber;
} FORMAT_PARAMETERS, *PFORMAT_PARAMETERS;

//
// Define the BAD_TRACK_NUMBER type. An array of elements of this type is
// returned by the driver on IOCTL_DISK_FORMAT_TRACKS requests, to indicate
// what tracks were bad during formatting. The length of that array is
// reported in the `Information' field of the I/O Status Block.
//

typedef USHORT BAD_TRACK_NUMBER;
typedef USHORT *PBAD_TRACK_NUMBER;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS_EX.
//

typedef struct _FORMAT_EX_PARAMETERS {
   MEDIA_TYPE MediaType;
   ULONG StartCylinderNumber;
   ULONG EndCylinderNumber;
   ULONG StartHeadNumber;
   ULONG EndHeadNumber;
   USHORT FormatGapLength;
   USHORT SectorsPerTrack;
   USHORT SectorNumber[1];
} FORMAT_EX_PARAMETERS, *PFORMAT_EX_PARAMETERS;

//
// The following structure is returned on an IOCTL_DISK_GET_DRIVE_GEOMETRY
// request and an array of them is returned on an IOCTL_DISK_GET_MEDIA_TYPES
// request.
//

typedef struct _DISK_GEOMETRY {
    LARGE_INTEGER Cylinders;
    MEDIA_TYPE MediaType;
    ULONG TracksPerCylinder;
    ULONG SectorsPerTrack;
    ULONG BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;


//
// This wmi guid returns a DISK_GEOMETRY structure
//
#define WMI_DISK_GEOMETRY_GUID         { 0x25007f51, 0x57c2, 0x11d1, { 0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } }



//
// The following structure is returned on an IOCTL_DISK_GET_PARTITION_INFO
// and an IOCTL_DISK_GET_DRIVE_LAYOUT request.  It is also used in a request
// to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
//

typedef struct _PARTITION_INFORMATION {
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    ULONG HiddenSectors;
    ULONG PartitionNumber;
    UCHAR PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

//
// The following structure is used to change the partition type of a
// specified disk partition using an IOCTL_DISK_SET_PARTITION_INFO
// request.
//

typedef struct _SET_PARTITION_INFORMATION {
    UCHAR PartitionType;
} SET_PARTITION_INFORMATION, *PSET_PARTITION_INFORMATION;

//
// The following structures is returned on an IOCTL_DISK_GET_DRIVE_LAYOUT
// request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT request.
//

typedef struct _DRIVE_LAYOUT_INFORMATION {
    ULONG PartitionCount;
    ULONG Signature;
    PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_VERIFY request.
// The offset and length parameters are both given in bytes.
//

typedef struct _VERIFY_INFORMATION {
    LARGE_INTEGER StartingOffset;
    ULONG Length;
} VERIFY_INFORMATION, *PVERIFY_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_REASSIGN_BLOCKS
// request.
//

typedef struct _REASSIGN_BLOCKS {
    USHORT Reserved;
    USHORT Count;
    ULONG BlockNumber[1];
} REASSIGN_BLOCKS, *PREASSIGN_BLOCKS;

#if(_WIN32_WINNT >= 0x0400)
//
// IOCTL_DISK_CONTROLLER_NUMBER returns the controller and disk
// number for the handle.  This is used to determine if a disk
// is attached to the primary or secondary IDE controller.
//

typedef struct _DISK_CONTROLLER_NUMBER {
    ULONG ControllerNumber;
    ULONG DiskNumber;
} DISK_CONTROLLER_NUMBER, *PDISK_CONTROLLER_NUMBER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)


//
// IOCTL_DISK_SET_CACHE allows the caller to get or set the state of the disk
// read/write caches.
//
// If the structure is provided as the input buffer for the ioctl the read &
// write caches will be enabled or disabled depending on the parameters
// provided.
//
// If the structure is provided as an output buffer for the ioctl the state
// of the read & write caches will be returned. If both input and outut buffers
// are provided the output buffer will contain the cache state BEFORE any
// changes are made
//

typedef enum {
    EqualPriority,
    KeepPrefetchedData,
    KeepReadData
} DISK_CACHE_RETENTION_PRIORITY;


typedef struct _DISK_CACHE_INFORMATION {

    //
    // on return indicates that the device is capable of saving any parameters
    // in non-volatile storage.  On send indicates that the device should
    // save the state in non-volatile storage.
    //

    BOOLEAN ParametersSavable;

    //
    // Indicates whether the write and read caches are enabled.
    //

    BOOLEAN ReadCacheEnabled;
    BOOLEAN WriteCacheEnabled;

    //
    // Controls the likelyhood of data remaining in the cache depending on how
    // it got there.  Data cached from a READ or WRITE operation may be given
    // higher, lower or equal priority to data entered into the cache for other
    // means (like prefetch)
    //

    DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
    DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;

    //
    // Requests for a larger number of blocks than this may have prefetching
    // disabled.  If this value is set to 0 prefetch will be disabled.
    //

    USHORT DisablePrefetchTransferLength;

    //
    // If TRUE then ScalarPrefetch (below) will be valid.  If FALSE then
    // the minimum and maximum values should be treated as a block count
    // (BlockPrefetch)
    //

    BOOLEAN PrefetchScalar;

    //
    // Contains the minimum and maximum amount of data which will be
    // will be prefetched into the cache on a disk operation.  This value
    // may either be a scalar multiplier of the transfer length of the request,
    // or an abolute number of disk blocks.  PrefetchScalar (above) indicates
    // which interpretation is used.
    //

    union {
        struct {
            USHORT Minimum;
            USHORT Maximum;

            //
            // The maximum number of blocks which will be prefetched - useful
            // with the scalar limits to set definite upper limits.
            //

            USHORT MaximumBlocks;
        } ScalarPrefetch;

        struct {
            USHORT Minimum;
            USHORT Maximum;
        } BlockPrefetch;
    };

} DISK_CACHE_INFORMATION, *PDISK_CACHE_INFORMATION;

//
// IOCTL_DISK_GROW_PARTITION will update the size of a partition
// by adding sectors to the length. The number of sectors must be
// predetermined by examining PARTITION_INFORMATION.
//

typedef struct _DISK_GROW_PARTITION {
    ULONG PartitionNumber;
    LARGE_INTEGER BytesToGrow;
} DISK_GROW_PARTITION, *PDISK_GROW_PARTITION;
#endif /* _WIN32_WINNT >= 0x0500 */

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk performance  //
// statistics: specifically the locations of all the //
// reads and writes which have occured on the disk.  //
//                                                   //
// To use these structures, you must issue an IOCTL_ //
// DISK_HIST_STRUCTURE (with a DISK_HISTOGRAM) to    //
// obtain the basic histogram information. The       //
// number of buckets which must allocated is part of //
// this structure. Allocate the required number of   //
// buckets and call an IOCTL_DISK_HIST_DATA to fill  //
// in the data                                       //
//                                                   //
///////////////////////////////////////////////////////

#define HIST_NO_OF_BUCKETS  24

typedef struct _HISTOGRAM_BUCKET {
    ULONG       Reads;
    ULONG       Writes;
} HISTOGRAM_BUCKET, *PHISTOGRAM_BUCKET;

#define HISTOGRAM_BUCKET_SIZE   sizeof(HISTOGRAM_BUCKET)

typedef struct _DISK_HISTOGRAM {
    LARGE_INTEGER   DiskSize;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    LARGE_INTEGER   Average;
    LARGE_INTEGER   AverageRead;
    LARGE_INTEGER   AverageWrite;
    ULONG           Granularity;
    ULONG           Size;
    ULONG           ReadCount;
    ULONG           WriteCount;
    PHISTOGRAM_BUCKET  Histogram;
} DISK_HISTOGRAM, *PDISK_HISTOGRAM;

#define DISK_HISTOGRAM_SIZE sizeof(DISK_HISTOGRAM)

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk debugging    //
// capabilities. The IOCTLs are directed to one of   //
// the two disk filter drivers.                      //
//                                                   //
// DISKPERF is a utilty for collecting disk request  //
// statistics.                                       //
//                                                   //
// SIMBAD is a utility for injecting faults in       //
// IO requests to disks.                             //
//                                                   //
///////////////////////////////////////////////////////

//
// The following structure is exchanged on an IOCTL_DISK_GET_PERFORMANCE
// request. This ioctl collects summary disk request statistics used
// in measuring performance.
//

typedef struct _DISK_PERFORMANCE {
        LARGE_INTEGER BytesRead;
        LARGE_INTEGER BytesWritten;
        LARGE_INTEGER ReadTime;
        LARGE_INTEGER WriteTime;
        LARGE_INTEGER IdleTime;
        ULONG ReadCount;
        ULONG WriteCount;
        ULONG QueueDepth;
        ULONG SplitCount;
        LARGE_INTEGER QueryTime;
        ULONG   StorageDeviceNumber;
        WCHAR   StorageManagerName[8];
} DISK_PERFORMANCE, *PDISK_PERFORMANCE;

//
// This structure defines the disk logging record. When disk logging
// is enabled, one of these is written to an internal buffer for each
// disk request.
//

typedef struct _DISK_RECORD {
   LARGE_INTEGER ByteOffset;
   LARGE_INTEGER StartTime;
   LARGE_INTEGER EndTime;
   PVOID VirtualAddress;
   ULONG NumberOfBytes;
   UCHAR DeviceNumber;
   BOOLEAN ReadRequest;
} DISK_RECORD, *PDISK_RECORD;

//
// The following structure is exchanged on an IOCTL_DISK_LOG request.
// Not all fields are valid with each function type.
//

typedef struct _DISK_LOGGING {
    UCHAR Function;
    PVOID BufferAddress;
    ULONG BufferSize;
} DISK_LOGGING, *PDISK_LOGGING;

//
// Disk logging functions
//
// Start disk logging. Only the Function and BufferSize fields are valid.
//

#define DISK_LOGGING_START    0

//
// Stop disk logging. Only the Function field is valid.
//

#define DISK_LOGGING_STOP     1

//
// Return disk log. All fields are valid. Data will be copied from internal
// buffer to buffer specified for the number of bytes requested.
//

#define DISK_LOGGING_DUMP     2

//
// DISK BINNING
//
// DISKPERF will keep counters for IO that falls in each of these ranges.
// The application determines the number and size of the ranges.
// Joe Lin wanted me to keep it flexible as possible, for instance, IO
// sizes are interesting in ranges like 0-4096, 4097-16384, 16385-65536, 65537+.
//

#define DISK_BINNING          3

//
// Bin types
//

typedef enum _BIN_TYPES {
    RequestSize,
    RequestLocation
} BIN_TYPES;

//
// Bin ranges
//

typedef struct _BIN_RANGE {
    LARGE_INTEGER StartValue;
    LARGE_INTEGER Length;
} BIN_RANGE, *PBIN_RANGE;

//
// Bin definition
//

typedef struct _PERF_BIN {
    ULONG NumberOfBins;
    ULONG TypeOfBin;
    BIN_RANGE BinsRanges[1];
} PERF_BIN, *PPERF_BIN ;

//
// Bin count
//

typedef struct _BIN_COUNT {
    BIN_RANGE BinRange;
    ULONG BinCount;
} BIN_COUNT, *PBIN_COUNT;

//
// Bin results
//

typedef struct _BIN_RESULTS {
    ULONG NumberOfBins;
    BIN_COUNT BinCounts[1];
} BIN_RESULTS, *PBIN_RESULTS;

#if(_WIN32_WINNT >= 0x0400)
//
// Data structures for SMART drive fault prediction.
//
// GETVERSIONINPARAMS contains the data returned from the
// Get Driver Version function.
//

#include <pshpack1.h>
typedef struct _GETVERSIONINPARAMS {
        UCHAR    bVersion;               // Binary driver version.
        UCHAR    bRevision;              // Binary driver revision.
        UCHAR    bReserved;              // Not used.
        UCHAR    bIDEDeviceMap;          // Bit map of IDE devices.
        ULONG   fCapabilities;          // Bit mask of driver capabilities.
        ULONG   dwReserved[4];          // For future use.
} GETVERSIONINPARAMS, *PGETVERSIONINPARAMS, *LPGETVERSIONINPARAMS;
#include <poppack.h>

//
// Bits returned in the fCapabilities member of GETVERSIONINPARAMS
//

#define CAP_ATA_ID_CMD          1       // ATA ID command supported
#define CAP_ATAPI_ID_CMD        2       // ATAPI ID command supported
#define CAP_SMART_CMD           4       // SMART commannds supported

//
// IDE registers
//

#include <pshpack1.h>
typedef struct _IDEREGS {
        UCHAR    bFeaturesReg;           // Used for specifying SMART "commands".
        UCHAR    bSectorCountReg;        // IDE sector count register
        UCHAR    bSectorNumberReg;       // IDE sector number register
        UCHAR    bCylLowReg;             // IDE low order cylinder value
        UCHAR    bCylHighReg;            // IDE high order cylinder value
        UCHAR    bDriveHeadReg;          // IDE drive/head register
        UCHAR    bCommandReg;            // Actual IDE command.
        UCHAR    bReserved;                      // reserved for future use.  Must be zero.
} IDEREGS, *PIDEREGS, *LPIDEREGS;
#include <poppack.h>

//
// Valid values for the bCommandReg member of IDEREGS.
//

#define ATAPI_ID_CMD    0xA1            // Returns ID sector for ATAPI.
#define ID_CMD          0xEC            // Returns ID sector for ATA.
#define SMART_CMD       0xB0            // Performs SMART cmd.
                                        // Requires valid bFeaturesReg,
                                        // bCylLowReg, and bCylHighReg

//
// Cylinder register defines for SMART command
//

#define SMART_CYL_LOW   0x4F
#define SMART_CYL_HI    0xC2


//
// SENDCMDINPARAMS contains the input parameters for the
// Send Command to Drive function.
//

#include <pshpack1.h>
typedef struct _SENDCMDINPARAMS {
        ULONG   cBufferSize;            // Buffer size in bytes
        IDEREGS irDriveRegs;            // Structure with drive register values.
        UCHAR    bDriveNumber;           // Physical drive number to send
                                                                // command to (0,1,2,3).
        UCHAR    bReserved[3];           // Reserved for future expansion.
        ULONG   dwReserved[4];          // For future use.
        UCHAR    bBuffer[1];                     // Input buffer.
} SENDCMDINPARAMS, *PSENDCMDINPARAMS, *LPSENDCMDINPARAMS;
#include <poppack.h>

//
// Status returned from driver
//

#include <pshpack1.h>
typedef struct _DRIVERSTATUS {
        UCHAR    bDriverError;           // Error code from driver,
                                                                // or 0 if no error.
        UCHAR    bIDEError;                      // Contents of IDE Error register.
                                                                // Only valid when bDriverError
                                                                // is SMART_IDE_ERROR.
        UCHAR    bReserved[2];           // Reserved for future expansion.
        ULONG   dwReserved[2];          // Reserved for future expansion.
} DRIVERSTATUS, *PDRIVERSTATUS, *LPDRIVERSTATUS;
#include <poppack.h>

//
// bDriverError values
//

#define SMART_NO_ERROR          0       // No error
#define SMART_IDE_ERROR         1       // Error from IDE controller
#define SMART_INVALID_FLAG      2       // Invalid command flag
#define SMART_INVALID_COMMAND   3       // Invalid command byte
#define SMART_INVALID_BUFFER    4       // Bad buffer (null, invalid addr..)
#define SMART_INVALID_DRIVE     5       // Drive number not valid
#define SMART_INVALID_IOCTL     6       // Invalid IOCTL
#define SMART_ERROR_NO_MEM      7       // Could not lock user's buffer
#define SMART_INVALID_REGISTER  8       // Some IDE Register not valid
#define SMART_NOT_SUPPORTED     9       // Invalid cmd flag set
#define SMART_NO_IDE_DEVICE     10      // Cmd issued to device not present
                                        // although drive number is valid

#include <pshpack1.h>
typedef struct _SENDCMDOUTPARAMS {
        ULONG                   cBufferSize;            // Size of bBuffer in bytes
        DRIVERSTATUS            DriverStatus;           // Driver status structure.
        UCHAR                   bBuffer[1];             // Buffer of arbitrary length in which to store the data read from the                                                                                  // drive.
} SENDCMDOUTPARAMS, *PSENDCMDOUTPARAMS, *LPSENDCMDOUTPARAMS;
#include <poppack.h>


#define READ_ATTRIBUTE_BUFFER_SIZE  512
#define IDENTIFY_BUFFER_SIZE        512
#define READ_THRESHOLD_BUFFER_SIZE  512

//
// Feature register defines for SMART "sub commands"
//

#define READ_ATTRIBUTES         0xD0
#define READ_THRESHOLDS         0xD1
#define ENABLE_DISABLE_AUTOSAVE 0xD2
#define SAVE_ATTRIBUTE_VALUES   0xD3
#define EXECUTE_OFFLINE_DIAGS   0xD4
#define ENABLE_SMART            0xD8
#define DISABLE_SMART           0xD9
#define RETURN_SMART_STATUS     0xDA
#define ENABLE_DISABLE_AUTO_OFFLINE 0xDB
#endif /* _WIN32_WINNT >= 0x0400 */


// end_winioctl

//
// The following device control code is for the SIMBAD simulated bad
// sector facility. See SIMBAD.H in this directory for related structures.
//

#define IOCTL_DISK_SIMBAD               CTL_CODE(IOCTL_DISK_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Queue link for mapped addresses stored for unmapping.
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID MappedAddress;
    ULONG NumberOfBytes;
    LARGE_INTEGER IoAddress;
    ULONG BusNumber;
} MAPPED_ADDRESS, *PMAPPED_ADDRESS;


#ifdef __cplusplus
}
#endif

#endif // _NTDDDISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddkbd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddkbd.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the keyboard device.

Author:

    Lee A. Smith (lees) 02-Aug-1991.

Revision History:

--*/

#ifndef _NTDDKBD_
#define _NTDDKBD_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_KEYBOARD_DEVICE_NAME    "\\Device\\KeyboardClass"
#define DD_KEYBOARD_DEVICE_NAME_U L"\\Device\\KeyboardClass"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_KEYBOARD_QUERY_ATTRIBUTES      CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_SET_TYPEMATIC         CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0001, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_SET_INDICATORS        CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0002, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_QUERY_TYPEMATIC       CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_QUERY_INDICATORS      CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION   CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0020, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_INSERT_DATA           CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0040, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These Device IO control query/set IME status to keyboard hardware.
//
#define IOCTL_KEYBOARD_QUERY_IME_STATUS      CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_SET_IME_STATUS        CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0401, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Declair the GUID that represents the device interface for mice.
//
#ifndef FAR
#define FAR
#endif

DEFINE_GUID( GUID_CLASS_KEYBOARD, 0x884b96c3, 0x56ef, 0x11d1, \
             0xbc, 0x8c, 0x00, 0xa0, 0xc9, 0x14, 0x05, 0xdd);


//
// NtReadFile Output Buffer record structures for this device.
//

typedef struct _KEYBOARD_INPUT_DATA {

    //
    // Unit number.  E.g., for \Device\KeyboardPort0 the unit is '0',
    // for \Device\KeyboardPort1 the unit is '1', and so on.
    //

    USHORT UnitId;

    //
    // The "make" scan code (key depression).
    //

    USHORT MakeCode;

    //
    // The flags field indicates a "break" (key release) and other
    // miscellaneous scan code information defined below.
    //

    USHORT Flags;

    USHORT Reserved;

    //
    // Device-specific additional information for the event.
    //

    ULONG ExtraInformation;

} KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA;

//
// Define the keyboard overrun MakeCode.
//

#define KEYBOARD_OVERRUN_MAKE_CODE    0xFF

//
// Define the keyboard input data Flags.
//

#define KEY_MAKE  0
#define KEY_BREAK 1
#define KEY_E0    2
#define KEY_E1    4
#define KEY_TERMSRV_SET_LED 8


//
// NtDeviceIoControlFile Input/Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_TYPEMATIC/IOCTL_KEYBOARD_SET_TYPEMATIC.
//

typedef struct _KEYBOARD_TYPEMATIC_PARAMETERS {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

    //
    // Typematic rate, in repeats per second.
    //

    USHORT  Rate;

    //
    // Typematic delay, in milliseconds.
    //

    USHORT  Delay;

} KEYBOARD_TYPEMATIC_PARAMETERS, *PKEYBOARD_TYPEMATIC_PARAMETERS;

//
// NtDeviceIoControlFile OutputBuffer record structures for
// IOCTL_KEYBOARD_QUERY_ATTRIBUTES.
//

typedef struct _KEYBOARD_ID {
    UCHAR Type;       // Keyboard type
    UCHAR Subtype;    // Keyboard subtype (OEM-dependent value)
} KEYBOARD_ID, *PKEYBOARD_ID;

typedef struct _KEYBOARD_ATTRIBUTES {

    //
    // Keyboard ID value.  Used to distinguish between keyboard types.
    //

    KEYBOARD_ID KeyboardIdentifier;

    //
    // Scan code mode.
    //

    USHORT KeyboardMode;

    //
    // Number of function keys located on the keyboard.
    //

    USHORT NumberOfFunctionKeys;

    //
    // Number of LEDs located on the keyboard.
    //

    USHORT NumberOfIndicators;

    //
    // Total number of keys located on the keyboard.
    //

    USHORT NumberOfKeysTotal;

    //
    // Length of the typeahead buffer, in bytes.
    //

    ULONG  InputDataQueueLength;

    //
    // Minimum allowable values of keyboard typematic rate and delay.
    //

    KEYBOARD_TYPEMATIC_PARAMETERS KeyRepeatMinimum;

    //
    // Maximum allowable values of keyboard typematic rate and delay.
    //

    KEYBOARD_TYPEMATIC_PARAMETERS KeyRepeatMaximum;

} KEYBOARD_ATTRIBUTES, *PKEYBOARD_ATTRIBUTES;

//
// ENHANCED_KEYBOARD() is TRUE if the value for keyboard type indicates an
// Enhanced (101- or 102-key) or compatible keyboard.  The result is FALSE
// if the keyboard is an old-style AT keyboard (83- or 84- or 86-key keyboard).
//
#define ENHANCED_KEYBOARD(Id) ((Id).Type == 2 || (Id).Type == 4 || FAREAST_KEYBOARD(Id))
//
// Japanese keyboard(7) and Korean keyboard(8) are also Enhanced (101-)
// or compatible keyboard.
//
#define FAREAST_KEYBOARD(Id)  ((Id).Type == 7 || (Id).Type == 8)

//
// NtDeviceIoControlFile Input/Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_INDICATORS/IOCTL_KEYBOARD_SET_INDICATORS.
//

typedef struct _KEYBOARD_INDICATOR_PARAMETERS {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

    //
    // LED indicator state.
    //

    USHORT    LedFlags;

} KEYBOARD_INDICATOR_PARAMETERS, *PKEYBOARD_INDICATOR_PARAMETERS;

//
// NtDeviceIoControlFile Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION.
//

typedef struct _INDICATOR_LIST {

    //
    // The "make" scan code (key depression).
    //

    USHORT MakeCode;

    //
    // The associated LED indicators.
    //

    USHORT IndicatorFlags;

} INDICATOR_LIST, *PINDICATOR_LIST;

typedef struct _KEYBOARD_INDICATOR_TRANSLATION {

    //
    // Number of entries in IndicatorList.
    //

    USHORT NumberOfIndicatorKeys;

    //
    // List of the scancode-to-indicator mappings.
    //

    INDICATOR_LIST IndicatorList[1];

} KEYBOARD_INDICATOR_TRANSLATION, *PKEYBOARD_INDICATOR_TRANSLATION;

//
// Define the keyboard indicators.
//

#define KEYBOARD_LED_INJECTED     0x8000 //Used by Terminal Server
//#if defined(FE_SB) || defined(WINDOWS_FE) || defined(DBCS)
#define KEYBOARD_KANA_LOCK_ON     8 // Japanese keyboard
//#endif // defined(FE_SB) || defined(WINDOWS_FE) || defined(DBCS)
#define KEYBOARD_CAPS_LOCK_ON     4
#define KEYBOARD_NUM_LOCK_ON      2
#define KEYBOARD_SCROLL_LOCK_ON   1

//
// Generic NtDeviceIoControlFile Input Buffer record structure for
// various keyboard IOCTLs.
//

typedef struct _KEYBOARD_UNIT_ID_PARAMETER {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

} KEYBOARD_UNIT_ID_PARAMETER, *PKEYBOARD_UNIT_ID_PARAMETER;

//
// Define the base values for the keyboard error log packet's
// UniqueErrorValue field.
//

#define KEYBOARD_ERROR_VALUE_BASE        10000

//
// NtDeviceIoControlFile Input/Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_IME_STATUS/IOCTL_KEYBOARD_SET_IME_STATUS.
//

typedef struct _KEYBOARD_IME_STATUS {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

    //
    // Ime open or close status.
    //
    ULONG ImeOpen;

    //
    // Ime conversion status.
    //
    ULONG ImeConvMode;

} KEYBOARD_IME_STATUS, *PKEYBOARD_IME_STATUS;

#ifdef __cplusplus
}
#endif

#endif // _NTDDKBD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddjoy.h ===
/*
Copyright (c) 1995-1999  Microsoft Corporation

Module Name:
    ntddjoy.h

Abstract:
    Definitions of all constants and types for the joystick driver.
*/


#ifndef __NTDDJOY_H__
#define __NTDDJOY_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Device Name
#define JOY_DD_DEVICE_NAME       "\\Device\\IBMJOY"
#define JOY_DD_DEVICE_NAME_U    L"\\Device\\IBMJOY"

// Device Parameters
#define JOY_DD_NAXES             "NumberOfAxes"
#define JOY_DD_NAXES_U          L"NumberOfAxes"

#define JOY_DD_DEVICE_ADDRESS    "DeviceAddress"
#define JOY_DD_DEVICE_ADDRESS_U L"DeviceAddress"

#define JOY_DD_TWOSTICKS         "Two Joysticks"
#define JOY_DD_TWOSTICKS_U      L"Two Joysticks"


// Device I/O Port Address
#define JOY_IO_PORT_ADDRESS    0x201

// Device specific bitmasks
#define X_AXIS_BITMASK	0x01

// Analog joystick bitmasks
#define JOYSTICK2_BUTTON2   0x80
#define JOYSTICK2_BUTTON1   0x40
#define JOYSTICK1_BUTTON2   0x20
#define JOYSTICK1_BUTTON1   0x10
#define JOYSTICK2_Y_MASK    0x08
#define JOYSTICK2_X_MASK    0x04
#define JOYSTICK1_R_MASK    0x08
#define JOYSTICK1_Z_MASK    0x04
#define JOYSTICK1_Y_MASK    0x02
#define JOYSTICK1_X_MASK    0x01


#define JOY_START_TIMERS    0

// Device specific timer values
#define ANALOG_POLL_TIMEOUT    16000  // 16 mS upper bound on analog polling, 8ms largest expected value, use 16 for safety
#define ANALOG_POLL_RESOLUTION   100  // 100 uS accuracy on polling time

// Joystick position information is transfered from the device driver to other
// drivers or applications using the JOY_DD_INPUT_DATA structure. Since
// the type of data returned varies whether the device is in analog mode or
// digital mode, a union is formed to convey both types of data. The Mode
// variable allows the recipient of the data to determing how to interpret
// the data.

typedef struct {

    // True if the device is unplugged. This is determined by a timeout mechanism
    BOOL    Unplugged;

    // The number of axi configured for this device (specified in the registry).
    DWORD   Axi;

    // current button state bitmask
    DWORD   Buttons;

    // X, Y, Z, and T axi positioning information contained below. The
    // values are expressed interms of microseconds. The values are
    // generated by measuring the duration of a pulse supplied by
    // the IBM compatable or Soundblaster game port. This is the raw
    // data, and it is the caller's responsibility to perform
    // calibration, ranging, hysteresis, etc.
    //
    // Because of inaccuracies in sampling this data, there is some
    // variation in readings of a stationary joystick.
    //
    // Analog Positioning information for typical joystick
    // values as follows (range information measured using a
    // Soundblaster analog game port).
    //
    //           apprx
    //  name     range        direction
    //  ----     -----        ---------
    //
    //  XTime  20..1600 uS    20 = leftmost, 1600 = rightmost
    //  YTime  20..1600 uS    20 = up,       1600 = down
    //  ZTime  20..1600 uS    20 = left,     1600 = right
    //  TTime  20..1600 uS    20 = forward   1600 = back
    //

    DWORD   XTime;   // Time in microseconds for X
    DWORD   YTime;   // Time in microseconds for Y
    DWORD   ZTime;   // Time in microseconds for Z if 3-axis
    DWORD   TTime;   // Time in microseconds for Throttle if 4 axis
    // return 3rd axis for 3 axis joysticks as TTime.

    } JOY_DD_INPUT_DATA, *PJOY_DD_INPUT_DATA;

#define JOY_TYPE 40001

// The following IOCTL code is used to obtain statistical information for
// debugging and performance testing the joystick driver.
#define IOCTL_JOY_GET_STATISTICS \
    CTL_CODE( JOY_TYPE, 0x903, METHOD_BUFFERED, FILE_READ_ACCESS)

// The following IOCTL code is used by the user-mode driver to determine
// the capabilities which the kernel-mode driver is capable of supporting.
#define IOCTL_JOY_GET_JOYREGHWCONFIG \
    CTL_CODE( JOY_TYPE, 0x906, METHOD_BUFFERED, FILE_READ_ACCESS)

// These stats are used for performance testing and debugging
typedef struct
{
    DWORD   Polls;
    DWORD   Timeouts;
    DWORD   Frequency;
    DWORD   dwQPCLatency;
    LONG    nQuiesceLoop;
    DWORD   Version;
    DWORD   PolledTooSoon;
    DWORD   NumberOfAxes;
    BOOL    bTwoSticks;
    DWORD   Redo;
} JOY_STATISTICS, *PJOY_STATISTICS;

#ifdef __cplusplus
}
#endif

#endif // __NTDDJOY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddksec.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddksec.h

Abstract:

    This file defines the IOCTLs and names for the KSecDD driver (the kernel
    mode security API driver).

Author:

    Richard Ward (richardw)

Revision History:

--*/

#ifndef _NTDDKSEC_
#define _NTDDKSEC_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define DD_KSEC_DEVICE_NAME     "\\Device\\KSecDD"
#define DD_KSEC_DEVICE_NAME_U   L"\\Device\\KsecDD"

#define IOCTL_KSEC_CONNECT_LSA          CTL_CODE(FILE_DEVICE_KSEC, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define IOCTL_KSEC_RNG                  CTL_CODE(FILE_DEVICE_KSEC, 1, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define IOCTL_KSEC_RNG_REKEY            CTL_CODE(FILE_DEVICE_KSEC, 2, METHOD_BUFFERED, FILE_ANY_ACCESS )

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntdddlc.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation
          (c) 1991  Nokia Data Systems AB

Module Name:

    ntdddlc.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the DLC driver interface device.

Author:

    Antti Saarenheimo (o-anttis) 08-JUNE-1991

Revision History:

--*/

#ifndef _NTDDDLC_
#define _NTDDDLC_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//


#define FILE_DEVICE_DLC     FILE_DEVICE_TRANSPORT

#define DD_DLC_DEVICE_NAME L"\\Device\\Dlc"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define _DLC_CONTROL_CODE(request,method) \
    CTL_CODE(FILE_DEVICE_DLC, request, method, FILE_ANY_ACCESS)

#define IOCTL_DLC_READ                  _DLC_CONTROL_CODE(0, METHOD_BUFFERED)
#define IOCTL_DLC_RECEIVE               _DLC_CONTROL_CODE(1, METHOD_BUFFERED)
#define IOCTL_DLC_TRANSMIT              _DLC_CONTROL_CODE(2, METHOD_OUT_DIRECT)
#define IOCTL_DLC_BUFFER_FREE           _DLC_CONTROL_CODE(3, METHOD_BUFFERED)
#define IOCTL_DLC_BUFFER_GET            _DLC_CONTROL_CODE(4, METHOD_BUFFERED)
#define IOCTL_DLC_BUFFER_CREATE         _DLC_CONTROL_CODE(5, METHOD_BUFFERED)
#define IOCTL_DLC_SET_EXCEPTION_FLAGS   _DLC_CONTROL_CODE(6, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_STATION         _DLC_CONTROL_CODE(7, METHOD_OUT_DIRECT)
#define IOCTL_DLC_CONNECT_STATION       _DLC_CONTROL_CODE(8, METHOD_BUFFERED)
#define IOCTL_DLC_FLOW_CONTROL          _DLC_CONTROL_CODE(9, METHOD_BUFFERED)
#define IOCTL_DLC_OPEN_STATION          _DLC_CONTROL_CODE(10, METHOD_BUFFERED)
#define IOCTL_DLC_RESET                 _DLC_CONTROL_CODE(11, METHOD_OUT_DIRECT)
#define IOCTL_DLC_READ_CANCEL           _DLC_CONTROL_CODE(12, METHOD_BUFFERED)
#define IOCTL_DLC_RECEIVE_CANCEL        _DLC_CONTROL_CODE(13, METHOD_BUFFERED)
#define IOCTL_DLC_QUERY_INFORMATION     _DLC_CONTROL_CODE(14, METHOD_BUFFERED)
#define IOCTL_DLC_SET_INFORMATION       _DLC_CONTROL_CODE(15, METHOD_BUFFERED)
#define IOCTL_DLC_TIMER_CANCEL          _DLC_CONTROL_CODE(16, METHOD_BUFFERED)
#define IOCTL_DLC_TIMER_CANCEL_GROUP    _DLC_CONTROL_CODE(17, METHOD_BUFFERED)
#define IOCTL_DLC_TIMER_SET             _DLC_CONTROL_CODE(18, METHOD_BUFFERED)
#define IOCTL_DLC_OPEN_SAP              _DLC_CONTROL_CODE(19, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_SAP             _DLC_CONTROL_CODE(20, METHOD_OUT_DIRECT)
#define IOCTL_DLC_OPEN_DIRECT           _DLC_CONTROL_CODE(21, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_DIRECT          _DLC_CONTROL_CODE(22, METHOD_OUT_DIRECT)
#define IOCTL_DLC_OPEN_ADAPTER          _DLC_CONTROL_CODE(23, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_ADAPTER         _DLC_CONTROL_CODE(24, METHOD_BUFFERED)
#define IOCTL_DLC_REALLOCTE_STATION     _DLC_CONTROL_CODE(25, METHOD_BUFFERED)
#define IOCTL_DLC_READ2                 _DLC_CONTROL_CODE(26, METHOD_BUFFERED)
#define IOCTL_DLC_RECEIVE2              _DLC_CONTROL_CODE(27, METHOD_BUFFERED)
#define IOCTL_DLC_TRANSMIT2             _DLC_CONTROL_CODE(28, METHOD_BUFFERED)
#define IOCTL_DLC_COMPLETE_COMMAND      _DLC_CONTROL_CODE(29, METHOD_BUFFERED)
#define IOCTL_DLC_TRACE_INITIALIZE      _DLC_CONTROL_CODE(30, METHOD_OUT_DIRECT)

#define IOCTL_DLC_MAX                   _DLC_CONTROL_CODE(30, METHOD_BUFFERED)

#define IOCTL_DLC_LAST_COMMAND          31  // for xlation tables

#ifdef __cplusplus
}
#endif

#endif  // _NTDDDLC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddfs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the File system device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDFS_
#define _NTDDFS_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_FS_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_FS_BASE                   FILE_DEVICE_DISK_FILE_SYSTEM


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#endif  // _NTDDFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddmidi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddmidi.h

Abstract:

    This include file defines all constants and types for
    accessing an NT wave device.

Author:

    Robin Speed (RobinSp) 12-Dec-91

Revision History:

--*/

#ifndef _NTDDMIDI_
#define _NTDDMIDI_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntddsnd.h>    // general sound stuff

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that when added to the name of the root of the device tree and with
// the device number appended, gives the name of the device required for
// a call to NtOpenFile.
// So for example, if the root is \Device and the Device type is
// MidiIn and the device number is 2, the full name is \Device\MidiIn2
//

#define DD_MIDI_IN_DEVICE_NAME     "\\Device\\MidiIn"
#define DD_MIDI_IN_DEVICE_NAME_U  L"\\Device\\MidiIn"
#define DD_MIDI_OUT_DEVICE_NAME    "\\Device\\MidiOut"
#define DD_MIDI_OUT_DEVICE_NAME_U L"\\Device\\MidiOut"

//
// MIDI device driver IOCTL set
//

#define IOCTL_MIDI_GET_CAPABILITIES   CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MIDI_SET_STATE          CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_MIDI_GET_STATE          CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_MIDI_SET_VOLUME         CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MIDI_GET_VOLUME         CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MIDI_PLAY               CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0006, METHOD_NEITHER, FILE_WRITE_ACCESS)
#define IOCTL_MIDI_RECORD             CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_MIDI_CACHE_PATCHES      CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0008, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_MIDI_CACHE_DRUM_PATCHES CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// IOCTL used in the debug build only
//

#if DBG

#define IOCTL_MIDI_SET_DEBUG_LEVEL    CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0040, METHOD_BUFFERED, FILE_READ_ACCESS)

#endif // DBG


//
// Product Ids - see winmm.h
//


//
// Midi input output buffer format
//

typedef struct {
    LARGE_INTEGER     Time;                // Time when data received
                                           // (in units of 100ns from when
                                           //  midi input was started)
    UCHAR             Data[sizeof(ULONG)]; // Data (at least 4 byts for
                                           // alignment).
} MIDI_DD_INPUT_DATA, *PMIDI_DD_INPUT_DATA;


//
// Midi volume structure
//

typedef struct _MIDI_DD_VOLUME {
    ULONG   Left;
	ULONG   Right;
} MIDI_DD_VOLUME, *PMIDI_DD_VOLUME;

//
// Patch array structure
//

//
// Midi cache patches structures
//

typedef struct _MIDI_DD_CACHE_PATCHES {
    ULONG   Bank;
    ULONG   Flags;
    USHORT  Patches[128];
} MIDI_DD_CACHE_PATCHES, *PMIDI_DD_CACHE_PATCHES;

//
// Midi cache drum patches structures
//

typedef struct _MIDI_DD_CACHE_DRUM_PATCHES {
    ULONG   Patch;
    ULONG   Flags;
    USHORT  DrumPatches[128];
} MIDI_DD_CACHE_DRUM_PATCHES, *PMIDI_DD_CACHE_DRUM_PATCHES;

//
// State flags used to set the state of a driver
//

#define MIDI_DD_STOP        0x0001
#define MIDI_DD_PLAY        0x0002      // output devices only
#define MIDI_DD_RECORD      0x0003      // input devices only
#define MIDI_DD_RESET       0x0004

//
// States returned by the get state ioctl
//

#define MIDI_DD_IDLE        0x0000
#define MIDI_DD_STOPPED     0x0001      // stopped
#define MIDI_DD_PLAYING     0x0002      // output devices only
#define MIDI_DD_RECORDING   0x0003      // input devices only

#ifdef __cplusplus
}
#endif

#endif // _NTDDMIDI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddndis.h ===
/*++ BUILD Version: 0001		// Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

	ntddndis.h

Abstract:

	This is the include file that defines all constants and types for
	accessing the Network driver interface device.

Author:

	NDIS/ATM Development Team

Revision History:

	added the correct values for NDIS 3.0.
	added Pnp IoCTLs and structures
	added general co ndis oids.
	added PnP and PM OIDs.

--*/

#ifndef _NTDDNDIS_
#define _NTDDNDIS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device. It is the name
// that should be passed to NtOpenFile when accessing the device.

//
// Note: For devices that support multiple units, it should be suffixed
//		 with the Ascii representation of the unit number.
//

#define DD_NDIS_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning: Remember that the low two bits of the code specify how the
//			buffers are passed to the driver!
//

#define _NDIS_CONTROL_CODE(request,method) \
			CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, request, method, FILE_ANY_ACCESS)

#define IOCTL_NDIS_QUERY_GLOBAL_STATS	_NDIS_CONTROL_CODE(0, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_QUERY_ALL_STATS		_NDIS_CONTROL_CODE(1, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_DO_PNP_OPERATION		_NDIS_CONTROL_CODE(2, METHOD_BUFFERED)
#define IOCTL_NDIS_QUERY_SELECTED_STATS	_NDIS_CONTROL_CODE(3, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_ENUMERATE_INTERFACES	_NDIS_CONTROL_CODE(4, METHOD_BUFFERED)
#define IOCTL_NDIS_ADD_TDI_DEVICE		_NDIS_CONTROL_CODE(5, METHOD_BUFFERED)
#define	IOCTL_NDIS_GET_DEVICE_BUNDLE	_NDIS_CONTROL_CODE(6, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_GET_LOG_DATA			_NDIS_CONTROL_CODE(7, METHOD_OUT_DIRECT)


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// This is the type of an NDIS OID value.
//

typedef ULONG NDIS_OID, *PNDIS_OID;

//
// IOCTL_NDIS_QUERY_ALL_STATS returns a sequence of these, packed
// together.  This structure is unaligned because not all statistics
// have a length that is a ULONG multiple.
//

typedef UNALIGNED struct _NDIS_STATISTICS_VALUE
{
	NDIS_OID	Oid;
	ULONG		DataLength;
	UCHAR		Data[1];			// variable length
} NDIS_STATISTICS_VALUE, *PNDIS_STATISTICS_VALUE;

//
// Structure used to define a self-contained variable data structure
//
typedef struct _NDIS_VAR_DATA_DESC
{
	USHORT		Length;			// # of octects of data
	USHORT		MaximumLength;	// # of octects available
	ULONG_PTR	Offset;			// Offset of data relative to the descriptor
} NDIS_VAR_DATA_DESC, *PNDIS_VAR_DATA_DESC;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif // !GUID_DEFINED

//
// General Objects
//

//
//	Required OIDs
//
#define OID_GEN_SUPPORTED_LIST					0x00010101
#define OID_GEN_HARDWARE_STATUS					0x00010102
#define OID_GEN_MEDIA_SUPPORTED					0x00010103
#define OID_GEN_MEDIA_IN_USE					0x00010104
#define OID_GEN_MAXIMUM_LOOKAHEAD				0x00010105
#define OID_GEN_MAXIMUM_FRAME_SIZE				0x00010106
#define OID_GEN_LINK_SPEED						0x00010107
#define OID_GEN_TRANSMIT_BUFFER_SPACE			0x00010108
#define OID_GEN_RECEIVE_BUFFER_SPACE			0x00010109
#define OID_GEN_TRANSMIT_BLOCK_SIZE				0x0001010A
#define OID_GEN_RECEIVE_BLOCK_SIZE				0x0001010B
#define OID_GEN_VENDOR_ID						0x0001010C
#define OID_GEN_VENDOR_DESCRIPTION				0x0001010D
#define OID_GEN_CURRENT_PACKET_FILTER			0x0001010E
#define OID_GEN_CURRENT_LOOKAHEAD				0x0001010F
#define OID_GEN_DRIVER_VERSION					0x00010110
#define OID_GEN_MAXIMUM_TOTAL_SIZE				0x00010111
#define OID_GEN_PROTOCOL_OPTIONS				0x00010112
#define OID_GEN_MAC_OPTIONS						0x00010113
#define OID_GEN_MEDIA_CONNECT_STATUS			0x00010114
#define OID_GEN_MAXIMUM_SEND_PACKETS			0x00010115
#define OID_GEN_VENDOR_DRIVER_VERSION			0x00010116
#define	OID_GEN_SUPPORTED_GUIDS					0x00010117
#define	OID_GEN_NETWORK_LAYER_ADDRESSES			0x00010118	// Set only
#define OID_GEN_TRANSPORT_HEADER_OFFSET			0x00010119  // Set only

//
//	Optional OIDs
//
#define	OID_GEN_MEDIA_CAPABILITIES				0x00010201
#define OID_GEN_PHYSICAL_MEDIUM					0x00010202

//
//	Required statistics
//
#define OID_GEN_XMIT_OK							0x00020101
#define OID_GEN_RCV_OK							0x00020102
#define OID_GEN_XMIT_ERROR						0x00020103
#define OID_GEN_RCV_ERROR						0x00020104
#define OID_GEN_RCV_NO_BUFFER					0x00020105

//
//	Optional statistics
//
#define OID_GEN_DIRECTED_BYTES_XMIT				0x00020201
#define OID_GEN_DIRECTED_FRAMES_XMIT			0x00020202
#define OID_GEN_MULTICAST_BYTES_XMIT			0x00020203
#define OID_GEN_MULTICAST_FRAMES_XMIT			0x00020204
#define OID_GEN_BROADCAST_BYTES_XMIT			0x00020205
#define OID_GEN_BROADCAST_FRAMES_XMIT			0x00020206
#define OID_GEN_DIRECTED_BYTES_RCV				0x00020207
#define OID_GEN_DIRECTED_FRAMES_RCV				0x00020208
#define OID_GEN_MULTICAST_BYTES_RCV				0x00020209
#define OID_GEN_MULTICAST_FRAMES_RCV			0x0002020A
#define OID_GEN_BROADCAST_BYTES_RCV				0x0002020B
#define OID_GEN_BROADCAST_FRAMES_RCV			0x0002020C

#define OID_GEN_RCV_CRC_ERROR					0x0002020D
#define OID_GEN_TRANSMIT_QUEUE_LENGTH			0x0002020E

#define OID_GEN_GET_TIME_CAPS					0x0002020F
#define OID_GEN_GET_NETCARD_TIME				0x00020210
#define	OID_GEN_NETCARD_LOAD					0x00020211
#define	OID_GEN_DEVICE_PROFILE					0x00020212

//
// The following is exported by NDIS itself and is only queryable. It returns
// the time in milliseconds a driver took to initialize.
//
#define	OID_GEN_INIT_TIME_MS					0x00020213
#define	OID_GEN_RESET_COUNTS					0x00020214
#define	OID_GEN_MEDIA_SENSE_COUNTS				0x00020215
#define	OID_GEN_FRIENDLY_NAME					0x00020216


//
//	These are connection-oriented general OIDs.
//	These replace the above OIDs for connection-oriented media.
//
#define OID_GEN_CO_SUPPORTED_LIST				OID_GEN_SUPPORTED_LIST
#define OID_GEN_CO_HARDWARE_STATUS				OID_GEN_HARDWARE_STATUS
#define OID_GEN_CO_MEDIA_SUPPORTED				OID_GEN_MEDIA_SUPPORTED
#define OID_GEN_CO_MEDIA_IN_USE					OID_GEN_MEDIA_IN_USE
#define OID_GEN_CO_LINK_SPEED					OID_GEN_LINK_SPEED
#define OID_GEN_CO_VENDOR_ID					OID_GEN_VENDOR_ID
#define OID_GEN_CO_VENDOR_DESCRIPTION			OID_GEN_VENDOR_DESCRIPTION
#define OID_GEN_CO_DRIVER_VERSION				OID_GEN_DRIVER_VERSION
#define OID_GEN_CO_PROTOCOL_OPTIONS				OID_GEN_PROTOCOL_OPTIONS
#define OID_GEN_CO_MAC_OPTIONS					OID_GEN_MAC_OPTIONS
#define OID_GEN_CO_MEDIA_CONNECT_STATUS			OID_GEN_MEDIA_CONNECT_STATUS
#define OID_GEN_CO_VENDOR_DRIVER_VERSION		OID_GEN_VENDOR_DRIVER_VERSION
#define	OID_GEN_CO_SUPPORTED_GUIDS				OID_GEN_SUPPORTED_GUIDS
#define OID_GEN_CO_GET_TIME_CAPS				OID_GEN_GET_TIME_CAPS
#define OID_GEN_CO_GET_NETCARD_TIME				OID_GEN_GET_NETCARD_TIME
#define OID_GEN_CO_MINIMUM_LINK_SPEED			0x00020120

//
//	These are connection-oriented statistics OIDs.
//
#define	OID_GEN_CO_XMIT_PDUS_OK					OID_GEN_XMIT_OK
#define	OID_GEN_CO_RCV_PDUS_OK					OID_GEN_RCV_OK
#define	OID_GEN_CO_XMIT_PDUS_ERROR				OID_GEN_XMIT_ERROR
#define	OID_GEN_CO_RCV_PDUS_ERROR				OID_GEN_RCV_ERROR
#define	OID_GEN_CO_RCV_PDUS_NO_BUFFER			OID_GEN_RCV_NO_BUFFER


#define	OID_GEN_CO_RCV_CRC_ERROR				OID_GEN_RCV_CRC_ERROR
#define OID_GEN_CO_TRANSMIT_QUEUE_LENGTH		OID_GEN_TRANSMIT_QUEUE_LENGTH
#define	OID_GEN_CO_BYTES_XMIT					OID_GEN_DIRECTED_BYTES_XMIT
#define OID_GEN_CO_BYTES_RCV					OID_GEN_DIRECTED_BYTES_RCV
#define	OID_GEN_CO_NETCARD_LOAD					OID_GEN_NETCARD_LOAD
#define	OID_GEN_CO_DEVICE_PROFILE				OID_GEN_DEVICE_PROFILE
#define	OID_GEN_CO_BYTES_XMIT_OUTSTANDING		0x00020221

//
// 802.3 Objects (Ethernet)
//
#define OID_802_3_PERMANENT_ADDRESS				0x01010101
#define OID_802_3_CURRENT_ADDRESS				0x01010102
#define OID_802_3_MULTICAST_LIST				0x01010103
#define OID_802_3_MAXIMUM_LIST_SIZE				0x01010104
#define OID_802_3_MAC_OPTIONS					0x01010105

#define	NDIS_802_3_MAC_OPTION_PRIORITY			0x00000001

#define OID_802_3_RCV_ERROR_ALIGNMENT			0x01020101
#define OID_802_3_XMIT_ONE_COLLISION			0x01020102
#define OID_802_3_XMIT_MORE_COLLISIONS			0x01020103

#define OID_802_3_XMIT_DEFERRED					0x01020201
#define OID_802_3_XMIT_MAX_COLLISIONS			0x01020202
#define OID_802_3_RCV_OVERRUN					0x01020203
#define OID_802_3_XMIT_UNDERRUN					0x01020204
#define OID_802_3_XMIT_HEARTBEAT_FAILURE		0x01020205
#define OID_802_3_XMIT_TIMES_CRS_LOST			0x01020206
#define OID_802_3_XMIT_LATE_COLLISIONS			0x01020207


//
// 802.5 Objects (Token-Ring)
//
#define OID_802_5_PERMANENT_ADDRESS				0x02010101
#define OID_802_5_CURRENT_ADDRESS				0x02010102
#define OID_802_5_CURRENT_FUNCTIONAL			0x02010103
#define OID_802_5_CURRENT_GROUP					0x02010104
#define OID_802_5_LAST_OPEN_STATUS				0x02010105
#define OID_802_5_CURRENT_RING_STATUS			0x02010106
#define OID_802_5_CURRENT_RING_STATE			0x02010107

#define OID_802_5_LINE_ERRORS					0x02020101
#define OID_802_5_LOST_FRAMES					0x02020102

#define OID_802_5_BURST_ERRORS					0x02020201
#define OID_802_5_AC_ERRORS						0x02020202
#define OID_802_5_ABORT_DELIMETERS				0x02020203
#define OID_802_5_FRAME_COPIED_ERRORS			0x02020204
#define OID_802_5_FREQUENCY_ERRORS				0x02020205
#define OID_802_5_TOKEN_ERRORS					0x02020206
#define OID_802_5_INTERNAL_ERRORS				0x02020207


//
// FDDI Objects
//
#define OID_FDDI_LONG_PERMANENT_ADDR			0x03010101
#define OID_FDDI_LONG_CURRENT_ADDR				0x03010102
#define OID_FDDI_LONG_MULTICAST_LIST			0x03010103
#define OID_FDDI_LONG_MAX_LIST_SIZE				0x03010104
#define OID_FDDI_SHORT_PERMANENT_ADDR			0x03010105
#define OID_FDDI_SHORT_CURRENT_ADDR				0x03010106
#define OID_FDDI_SHORT_MULTICAST_LIST			0x03010107
#define OID_FDDI_SHORT_MAX_LIST_SIZE			0x03010108

#define OID_FDDI_ATTACHMENT_TYPE				0x03020101
#define OID_FDDI_UPSTREAM_NODE_LONG				0x03020102
#define OID_FDDI_DOWNSTREAM_NODE_LONG			0x03020103
#define OID_FDDI_FRAME_ERRORS					0x03020104
#define OID_FDDI_FRAMES_LOST					0x03020105
#define OID_FDDI_RING_MGT_STATE					0x03020106
#define OID_FDDI_LCT_FAILURES					0x03020107
#define OID_FDDI_LEM_REJECTS					0x03020108
#define OID_FDDI_LCONNECTION_STATE				0x03020109

#define OID_FDDI_SMT_STATION_ID					0x03030201
#define OID_FDDI_SMT_OP_VERSION_ID				0x03030202
#define OID_FDDI_SMT_HI_VERSION_ID				0x03030203
#define OID_FDDI_SMT_LO_VERSION_ID				0x03030204
#define OID_FDDI_SMT_MANUFACTURER_DATA			0x03030205
#define OID_FDDI_SMT_USER_DATA					0x03030206
#define OID_FDDI_SMT_MIB_VERSION_ID				0x03030207
#define OID_FDDI_SMT_MAC_CT						0x03030208
#define OID_FDDI_SMT_NON_MASTER_CT				0x03030209
#define OID_FDDI_SMT_MASTER_CT					0x0303020A
#define OID_FDDI_SMT_AVAILABLE_PATHS			0x0303020B
#define OID_FDDI_SMT_CONFIG_CAPABILITIES		0x0303020C
#define OID_FDDI_SMT_CONFIG_POLICY				0x0303020D
#define OID_FDDI_SMT_CONNECTION_POLICY			0x0303020E
#define OID_FDDI_SMT_T_NOTIFY					0x0303020F
#define OID_FDDI_SMT_STAT_RPT_POLICY			0x03030210
#define OID_FDDI_SMT_TRACE_MAX_EXPIRATION		0x03030211
#define OID_FDDI_SMT_PORT_INDEXES				0x03030212
#define OID_FDDI_SMT_MAC_INDEXES				0x03030213
#define OID_FDDI_SMT_BYPASS_PRESENT				0x03030214
#define OID_FDDI_SMT_ECM_STATE					0x03030215
#define OID_FDDI_SMT_CF_STATE					0x03030216
#define OID_FDDI_SMT_HOLD_STATE					0x03030217
#define OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG		0x03030218
#define OID_FDDI_SMT_STATION_STATUS				0x03030219
#define OID_FDDI_SMT_PEER_WRAP_FLAG				0x0303021A
#define OID_FDDI_SMT_MSG_TIME_STAMP				0x0303021B
#define OID_FDDI_SMT_TRANSITION_TIME_STAMP		0x0303021C
#define OID_FDDI_SMT_SET_COUNT					0x0303021D
#define OID_FDDI_SMT_LAST_SET_STATION_ID		0x0303021E
#define OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS 	0x0303021F
#define OID_FDDI_MAC_BRIDGE_FUNCTIONS			0x03030220
#define OID_FDDI_MAC_T_MAX_CAPABILITY			0x03030221
#define OID_FDDI_MAC_TVX_CAPABILITY				0x03030222
#define OID_FDDI_MAC_AVAILABLE_PATHS			0x03030223
#define OID_FDDI_MAC_CURRENT_PATH				0x03030224
#define OID_FDDI_MAC_UPSTREAM_NBR				0x03030225
#define OID_FDDI_MAC_DOWNSTREAM_NBR				0x03030226
#define OID_FDDI_MAC_OLD_UPSTREAM_NBR			0x03030227
#define OID_FDDI_MAC_OLD_DOWNSTREAM_NBR			0x03030228
#define OID_FDDI_MAC_DUP_ADDRESS_TEST			0x03030229
#define OID_FDDI_MAC_REQUESTED_PATHS			0x0303022A
#define OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE		0x0303022B
#define OID_FDDI_MAC_INDEX						0x0303022C
#define OID_FDDI_MAC_SMT_ADDRESS				0x0303022D
#define OID_FDDI_MAC_LONG_GRP_ADDRESS			0x0303022E
#define OID_FDDI_MAC_SHORT_GRP_ADDRESS			0x0303022F
#define OID_FDDI_MAC_T_REQ						0x03030230
#define OID_FDDI_MAC_T_NEG						0x03030231
#define OID_FDDI_MAC_T_MAX						0x03030232
#define OID_FDDI_MAC_TVX_VALUE					0x03030233
#define OID_FDDI_MAC_T_PRI0						0x03030234
#define OID_FDDI_MAC_T_PRI1						0x03030235
#define OID_FDDI_MAC_T_PRI2						0x03030236
#define OID_FDDI_MAC_T_PRI3						0x03030237
#define OID_FDDI_MAC_T_PRI4						0x03030238
#define OID_FDDI_MAC_T_PRI5						0x03030239
#define OID_FDDI_MAC_T_PRI6						0x0303023A
#define OID_FDDI_MAC_FRAME_CT					0x0303023B
#define OID_FDDI_MAC_COPIED_CT					0x0303023C
#define OID_FDDI_MAC_TRANSMIT_CT				0x0303023D
#define OID_FDDI_MAC_TOKEN_CT					0x0303023E
#define OID_FDDI_MAC_ERROR_CT					0x0303023F
#define OID_FDDI_MAC_LOST_CT					0x03030240
#define OID_FDDI_MAC_TVX_EXPIRED_CT				0x03030241
#define OID_FDDI_MAC_NOT_COPIED_CT				0x03030242
#define OID_FDDI_MAC_LATE_CT					0x03030243
#define OID_FDDI_MAC_RING_OP_CT					0x03030244
#define OID_FDDI_MAC_FRAME_ERROR_THRESHOLD		0x03030245
#define OID_FDDI_MAC_FRAME_ERROR_RATIO			0x03030246
#define OID_FDDI_MAC_NOT_COPIED_THRESHOLD		0x03030247
#define OID_FDDI_MAC_NOT_COPIED_RATIO			0x03030248
#define OID_FDDI_MAC_RMT_STATE					0x03030249
#define OID_FDDI_MAC_DA_FLAG					0x0303024A
#define OID_FDDI_MAC_UNDA_FLAG					0x0303024B
#define OID_FDDI_MAC_FRAME_ERROR_FLAG			0x0303024C
#define OID_FDDI_MAC_NOT_COPIED_FLAG			0x0303024D
#define OID_FDDI_MAC_MA_UNITDATA_AVAILABLE		0x0303024E
#define OID_FDDI_MAC_HARDWARE_PRESENT			0x0303024F
#define OID_FDDI_MAC_MA_UNITDATA_ENABLE			0x03030250
#define OID_FDDI_PATH_INDEX						0x03030251
#define OID_FDDI_PATH_RING_LATENCY				0x03030252
#define OID_FDDI_PATH_TRACE_STATUS				0x03030253
#define OID_FDDI_PATH_SBA_PAYLOAD				0x03030254
#define OID_FDDI_PATH_SBA_OVERHEAD				0x03030255
#define OID_FDDI_PATH_CONFIGURATION				0x03030256
#define OID_FDDI_PATH_T_R_MODE					0x03030257
#define OID_FDDI_PATH_SBA_AVAILABLE				0x03030258
#define OID_FDDI_PATH_TVX_LOWER_BOUND			0x03030259
#define OID_FDDI_PATH_T_MAX_LOWER_BOUND			0x0303025A
#define OID_FDDI_PATH_MAX_T_REQ					0x0303025B
#define OID_FDDI_PORT_MY_TYPE					0x0303025C
#define OID_FDDI_PORT_NEIGHBOR_TYPE				0x0303025D
#define OID_FDDI_PORT_CONNECTION_POLICIES		0x0303025E
#define OID_FDDI_PORT_MAC_INDICATED				0x0303025F
#define OID_FDDI_PORT_CURRENT_PATH				0x03030260
#define OID_FDDI_PORT_REQUESTED_PATHS			0x03030261
#define OID_FDDI_PORT_MAC_PLACEMENT				0x03030262
#define OID_FDDI_PORT_AVAILABLE_PATHS			0x03030263
#define OID_FDDI_PORT_MAC_LOOP_TIME				0x03030264
#define OID_FDDI_PORT_PMD_CLASS					0x03030265
#define OID_FDDI_PORT_CONNECTION_CAPABILITIES	0x03030266
#define OID_FDDI_PORT_INDEX						0x03030267
#define OID_FDDI_PORT_MAINT_LS					0x03030268
#define OID_FDDI_PORT_BS_FLAG					0x03030269
#define OID_FDDI_PORT_PC_LS						0x0303026A
#define OID_FDDI_PORT_EB_ERROR_CT				0x0303026B
#define OID_FDDI_PORT_LCT_FAIL_CT				0x0303026C
#define OID_FDDI_PORT_LER_ESTIMATE				0x0303026D
#define OID_FDDI_PORT_LEM_REJECT_CT				0x0303026E
#define OID_FDDI_PORT_LEM_CT					0x0303026F
#define OID_FDDI_PORT_LER_CUTOFF				0x03030270
#define OID_FDDI_PORT_LER_ALARM					0x03030271
#define OID_FDDI_PORT_CONNNECT_STATE			0x03030272
#define OID_FDDI_PORT_PCM_STATE					0x03030273
#define OID_FDDI_PORT_PC_WITHHOLD				0x03030274
#define OID_FDDI_PORT_LER_FLAG					0x03030275
#define OID_FDDI_PORT_HARDWARE_PRESENT			0x03030276
#define OID_FDDI_SMT_STATION_ACTION				0x03030277
#define OID_FDDI_PORT_ACTION					0x03030278
#define OID_FDDI_IF_DESCR						0x03030279
#define OID_FDDI_IF_TYPE						0x0303027A
#define OID_FDDI_IF_MTU							0x0303027B
#define OID_FDDI_IF_SPEED						0x0303027C
#define OID_FDDI_IF_PHYS_ADDRESS				0x0303027D
#define OID_FDDI_IF_ADMIN_STATUS				0x0303027E
#define OID_FDDI_IF_OPER_STATUS					0x0303027F
#define OID_FDDI_IF_LAST_CHANGE					0x03030280
#define OID_FDDI_IF_IN_OCTETS					0x03030281
#define OID_FDDI_IF_IN_UCAST_PKTS				0x03030282
#define OID_FDDI_IF_IN_NUCAST_PKTS				0x03030283
#define OID_FDDI_IF_IN_DISCARDS					0x03030284
#define OID_FDDI_IF_IN_ERRORS					0x03030285
#define OID_FDDI_IF_IN_UNKNOWN_PROTOS			0x03030286
#define OID_FDDI_IF_OUT_OCTETS					0x03030287
#define OID_FDDI_IF_OUT_UCAST_PKTS				0x03030288
#define OID_FDDI_IF_OUT_NUCAST_PKTS				0x03030289
#define OID_FDDI_IF_OUT_DISCARDS				0x0303028A
#define OID_FDDI_IF_OUT_ERRORS					0x0303028B
#define OID_FDDI_IF_OUT_QLEN					0x0303028C
#define OID_FDDI_IF_SPECIFIC					0x0303028D

//
// WAN objects
//
#define OID_WAN_PERMANENT_ADDRESS				0x04010101
#define OID_WAN_CURRENT_ADDRESS					0x04010102
#define OID_WAN_QUALITY_OF_SERVICE				0x04010103
#define OID_WAN_PROTOCOL_TYPE					0x04010104
#define OID_WAN_MEDIUM_SUBTYPE					0x04010105
#define OID_WAN_HEADER_FORMAT					0x04010106

#define OID_WAN_GET_INFO						0x04010107
#define OID_WAN_SET_LINK_INFO					0x04010108
#define OID_WAN_GET_LINK_INFO					0x04010109

#define OID_WAN_LINE_COUNT						0x0401010A
#define OID_WAN_PROTOCOL_CAPS					0x0401010B

#define OID_WAN_GET_BRIDGE_INFO					0x0401020A
#define OID_WAN_SET_BRIDGE_INFO					0x0401020B
#define OID_WAN_GET_COMP_INFO					0x0401020C
#define OID_WAN_SET_COMP_INFO					0x0401020D
#define OID_WAN_GET_STATS_INFO					0x0401020E

//
//	These are connection-oriented WAN OIDs.
//	These replace the above OIDs for CoNDIS WAN Miniports
//
#define OID_WAN_CO_GET_INFO						0x04010180
#define OID_WAN_CO_SET_LINK_INFO				0x04010181
#define OID_WAN_CO_GET_LINK_INFO				0x04010182
#define OID_WAN_CO_GET_COMP_INFO				0x04010280
#define OID_WAN_CO_SET_COMP_INFO				0x04010281
#define OID_WAN_CO_GET_STATS_INFO				0x04010282


//
// LocalTalk objects
//
#define OID_LTALK_CURRENT_NODE_ID				0x05010102

#define OID_LTALK_IN_BROADCASTS					0x05020101
#define OID_LTALK_IN_LENGTH_ERRORS				0x05020102

#define OID_LTALK_OUT_NO_HANDLERS				0x05020201
#define OID_LTALK_COLLISIONS					0x05020202
#define OID_LTALK_DEFERS						0x05020203
#define OID_LTALK_NO_DATA_ERRORS				0x05020204
#define OID_LTALK_RANDOM_CTS_ERRORS				0x05020205
#define OID_LTALK_FCS_ERRORS					0x05020206

//
// Arcnet objects
//
#define OID_ARCNET_PERMANENT_ADDRESS			0x06010101
#define OID_ARCNET_CURRENT_ADDRESS				0x06010102

#define OID_ARCNET_RECONFIGURATIONS				0x06020201


//
// TAPI objects
//
#define OID_TAPI_ACCEPT							0x07030101
#define OID_TAPI_ANSWER							0x07030102
#define OID_TAPI_CLOSE							0x07030103
#define OID_TAPI_CLOSE_CALL						0x07030104
#define OID_TAPI_CONDITIONAL_MEDIA_DETECTION	0x07030105
#define OID_TAPI_CONFIG_DIALOG					0x07030106
#define OID_TAPI_DEV_SPECIFIC					0x07030107
#define OID_TAPI_DIAL							0x07030108
#define OID_TAPI_DROP							0x07030109
#define OID_TAPI_GET_ADDRESS_CAPS				0x0703010A
#define OID_TAPI_GET_ADDRESS_ID					0x0703010B
#define OID_TAPI_GET_ADDRESS_STATUS				0x0703010C
#define OID_TAPI_GET_CALL_ADDRESS_ID			0x0703010D
#define OID_TAPI_GET_CALL_INFO					0x0703010E
#define OID_TAPI_GET_CALL_STATUS				0x0703010F
#define OID_TAPI_GET_DEV_CAPS					0x07030110
#define OID_TAPI_GET_DEV_CONFIG					0x07030111
#define OID_TAPI_GET_EXTENSION_ID				0x07030112
#define OID_TAPI_GET_ID							0x07030113
#define OID_TAPI_GET_LINE_DEV_STATUS			0x07030114
#define OID_TAPI_MAKE_CALL						0x07030115
#define OID_TAPI_NEGOTIATE_EXT_VERSION			0x07030116
#define OID_TAPI_OPEN							0x07030117
#define OID_TAPI_PROVIDER_INITIALIZE			0x07030118
#define OID_TAPI_PROVIDER_SHUTDOWN				0x07030119
#define OID_TAPI_SECURE_CALL					0x0703011A
#define OID_TAPI_SELECT_EXT_VERSION				0x0703011B
#define OID_TAPI_SEND_USER_USER_INFO			0x0703011C
#define OID_TAPI_SET_APP_SPECIFIC				0x0703011D
#define OID_TAPI_SET_CALL_PARAMS				0x0703011E
#define OID_TAPI_SET_DEFAULT_MEDIA_DETECTION	0x0703011F
#define OID_TAPI_SET_DEV_CONFIG					0x07030120
#define OID_TAPI_SET_MEDIA_MODE					0x07030121
#define OID_TAPI_SET_STATUS_MESSAGES			0x07030122
#define OID_TAPI_GATHER_DIGITS   	            0x07030123
#define OID_TAPI_MONITOR_DIGITS   	            0x07030124

//
// ATM Connection Oriented OIDs
//
#define OID_ATM_SUPPORTED_VC_RATES				0x08010101
#define OID_ATM_SUPPORTED_SERVICE_CATEGORY		0x08010102
#define OID_ATM_SUPPORTED_AAL_TYPES				0x08010103
#define OID_ATM_HW_CURRENT_ADDRESS				0x08010104
#define OID_ATM_MAX_ACTIVE_VCS					0x08010105
#define OID_ATM_MAX_ACTIVE_VCI_BITS				0x08010106
#define OID_ATM_MAX_ACTIVE_VPI_BITS				0x08010107
#define OID_ATM_MAX_AAL0_PACKET_SIZE			0x08010108
#define OID_ATM_MAX_AAL1_PACKET_SIZE			0x08010109
#define OID_ATM_MAX_AAL34_PACKET_SIZE			0x0801010A
#define OID_ATM_MAX_AAL5_PACKET_SIZE			0x0801010B

#define OID_ATM_SIGNALING_VPIVCI				0x08010201
#define OID_ATM_ASSIGNED_VPI					0x08010202
#define OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES	0x08010203
#define OID_ATM_RELEASE_ACCESS_NET_RESOURCES	0x08010204
#define OID_ATM_ILMI_VPIVCI						0x08010205
#define OID_ATM_DIGITAL_BROADCAST_VPIVCI		0x08010206
#define	OID_ATM_GET_NEAREST_FLOW				0x08010207
#define OID_ATM_ALIGNMENT_REQUIRED				0x08010208
#define	OID_ATM_LECS_ADDRESS					0x08010209
#define	OID_ATM_SERVICE_ADDRESS					0x0801020A

#define OID_ATM_CALL_PROCEEDING					0x0801020B	// UNI 4.0
#define OID_ATM_CALL_ALERTING					0x0801020C	// UNI 4.0
#define OID_ATM_PARTY_ALERTING					0x0801020D	// UNI 4.0
#define OID_ATM_CALL_NOTIFY						0x0801020E	// UNI 4.0

#define OID_ATM_MY_IP_NM_ADDRESS				0x0801020F


//
//	ATM specific statistics OIDs.
//
#define	OID_ATM_RCV_CELLS_OK					0x08020101
#define	OID_ATM_XMIT_CELLS_OK					0x08020102
#define	OID_ATM_RCV_CELLS_DROPPED				0x08020103

#define	OID_ATM_RCV_INVALID_VPI_VCI				0x08020201
#define	OID_ATM_CELLS_HEC_ERROR					0x08020202
#define	OID_ATM_RCV_REASSEMBLY_ERROR			0x08020203

//
// PCCA (Wireless) object
//

//
// All WirelessWAN devices must support the following OIDs
//

#define OID_WW_GEN_NETWORK_TYPES_SUPPORTED		0x09010101
#define OID_WW_GEN_NETWORK_TYPE_IN_USE			0x09010102
#define OID_WW_GEN_HEADER_FORMATS_SUPPORTED		0x09010103
#define OID_WW_GEN_HEADER_FORMAT_IN_USE			0x09010104
#define OID_WW_GEN_INDICATION_REQUEST			0x09010105
#define OID_WW_GEN_DEVICE_INFO					0x09010106
#define OID_WW_GEN_OPERATION_MODE				0x09010107
#define OID_WW_GEN_LOCK_STATUS					0x09010108
#define OID_WW_GEN_DISABLE_TRANSMITTER			0x09010109
#define OID_WW_GEN_NETWORK_ID					0x0901010A
#define OID_WW_GEN_PERMANENT_ADDRESS			0x0901010B
#define OID_WW_GEN_CURRENT_ADDRESS				0x0901010C
#define OID_WW_GEN_SUSPEND_DRIVER				0x0901010D
#define OID_WW_GEN_BASESTATION_ID				0x0901010E
#define OID_WW_GEN_CHANNEL_ID					0x0901010F
#define OID_WW_GEN_ENCRYPTION_SUPPORTED			0x09010110
#define OID_WW_GEN_ENCRYPTION_IN_USE			0x09010111
#define OID_WW_GEN_ENCRYPTION_STATE				0x09010112
#define OID_WW_GEN_CHANNEL_QUALITY				0x09010113
#define OID_WW_GEN_REGISTRATION_STATUS			0x09010114
#define OID_WW_GEN_RADIO_LINK_SPEED				0x09010115
#define OID_WW_GEN_LATENCY						0x09010116
#define OID_WW_GEN_BATTERY_LEVEL				0x09010117
#define OID_WW_GEN_EXTERNAL_POWER				0x09010118

//
// These are optional
//
#define OID_WW_GEN_PING_ADDRESS					0x09010201
#define OID_WW_GEN_RSSI							0x09010202
#define OID_WW_GEN_SIM_STATUS					0x09010203
#define OID_WW_GEN_ENABLE_SIM_PIN				0x09010204
#define OID_WW_GEN_CHANGE_SIM_PIN				0x09010205
#define OID_WW_GEN_SIM_PUK						0x09010206
#define OID_WW_GEN_SIM_EXCEPTION				0x09010207

//
// Network Dependent OIDs - Mobitex:
//

#define OID_WW_MBX_SUBADDR						0x09050101
// OID 0x09050102 is reserved and may not be used
#define OID_WW_MBX_FLEXLIST						0x09050103
#define OID_WW_MBX_GROUPLIST					0x09050104
#define OID_WW_MBX_TRAFFIC_AREA					0x09050105
#define OID_WW_MBX_LIVE_DIE						0x09050106
#define OID_WW_MBX_TEMP_DEFAULTLIST				0x09050107

//
// Network Dependent OIDs - Pinpoint:
//
//
// The following Pin Point characteristics have been deprecated by the
// PCCA and are considered reserved values. They are include here only for
// historical purposes and should not be used
//
#define OID_WW_PIN_LOC_AUTHORIZE				0x09090101
#define OID_WW_PIN_LAST_LOCATION				0x09090102
#define OID_WW_PIN_LOC_FIX						0x09090103

//
// Network Dependent - CDPD:
//
#define OID_WW_CDPD_SPNI						0x090D0101
#define OID_WW_CDPD_WASI						0x090D0102
#define OID_WW_CDPD_AREA_COLOR					0x090D0103
#define OID_WW_CDPD_TX_POWER_LEVEL				0x090D0104
#define OID_WW_CDPD_EID							0x090D0105
#define OID_WW_CDPD_HEADER_COMPRESSION			0x090D0106
#define OID_WW_CDPD_DATA_COMPRESSION			0x090D0107
#define OID_WW_CDPD_CHANNEL_SELECT				0x090D0108
#define OID_WW_CDPD_CHANNEL_STATE				0x090D0109
#define OID_WW_CDPD_NEI							0x090D010A
#define OID_WW_CDPD_NEI_STATE					0x090D010B
#define OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER	0x090D010C
#define OID_WW_CDPD_SLEEP_MODE					0x090D010D

//
// At the request of the PCCA STD-201 Annex C working group the following OID
// value has been superceeded by more specific objects. Its value is reserved by
// the PCCA,is included here for historical purposes only, and should not be
// used.
//
#define OID_WW_CDPD_CIRCUIT_SWITCHED			0x090D010E

#define	OID_WW_CDPD_TEI							0x090D010F
#define	OID_WW_CDPD_RSSI						0x090D0110

//
// CDPD Circuit Switched objects
//
#define OID_WW_CDPD_CS_SERVICE_PREFERENCE		0x090D0111
#define OID_WW_CDPD_CS_SERVICE_STATUS			0x090D0112
#define OID_WW_CDPD_CS_INFO						0x090D0113
#define OID_WW_CDPD_CS_SUSPEND					0x090D0114
#define OID_WW_CDPD_CS_DEFAULT_DIAL_CODE		0x090D0115
#define OID_WW_CDPD_CS_CALLBACK					0x090D0116
#define OID_WW_CDPD_CS_SID_LIST					0x090D0117
#define OID_WW_CDPD_CS_CONFIGURATION			0x090D0118

//
// Network Dependent - Ardis:
//
//
// At the request of Ardis these OID value have been superceeded. Their
// functionality has been merged with the DataTAC objects. Therefore
// these values are reserved by the PCCA, are include here for
// historical purposes only, and should not be used.
//
#define OID_WW_ARD_SNDCP						0x09110101
#define OID_WW_ARD_TMLY_MSG						0x09110102
#define OID_WW_ARD_DATAGRAM						0x09110103

//
// Network Dependent - DataTac:
//

#define OID_WW_TAC_COMPRESSION					0x09150101

//
// At the request of Motorola, the following two OID values have been
// superceeded. Their functionality has been subsumed by other more specific
// DataTac objects and should not be used. These values are reserved by the
// PCCA and are include here only for historical purposes only.
//
#define OID_WW_TAC_SET_CONFIG					0x09150102
#define OID_WW_TAC_GET_STATUS					0x09150103
#define OID_WW_TAC_USER_HEADER					0x09150104

//
// DataTAC characteristic object values
//
#define OID_WW_TAC_UNIQUE_SDU_TAG				0x09150105
#define OID_WW_TAC_SEND_COMMAND					0x09150106
#define OID_WW_TAC_GET_RESPONSE					0x09150107
#define OID_WW_TAC_DISABLE_RECEIVER				0x09150108
#define OID_WW_TAC_ANTENNA_MODE					0x09150109
#define OID_WW_TAC_FLUSH_DATA					0x0915010A
#define OID_WW_TAC_SHUTDOWN_DEVICE				0x0915010B
#define OID_WW_TAC_DEVICE_EXCEPTION				0x0915010C
#define OID_WW_TAC_RECEIVE_EXCEPTION			0x0915010D
#define OID_WW_TAC_BUFFER_EXCEPTION				0x0915010E
#define OID_WW_TAC_BATTERY_EXCEPTION			0x0915010F
#define OID_WW_TAC_TRANSMITTER_KEYED			0x09150110
#define OID_WW_TAC_SYSTEM_TABLE					0x09150111
#define OID_WW_TAC_CHANNEL_TABLE				0x09150112
#define OID_WW_TAC_DCHANNEL_TABLE				0x09150113
#define OID_WW_TAC_RECEIVE_QUEUE_COUNT			0x09150114

//
// DataTac statistic object value
//
#define OID_WW_TAC_STATISTICS					0x09160101

//
// Network Dependent - Metricom:
//

#define OID_WW_MET_FUNCTION						0x09190101

//
// IRDA objects
//
#define OID_IRDA_RECEIVING						0x0A010100
#define OID_IRDA_TURNAROUND_TIME				0x0A010101
#define OID_IRDA_SUPPORTED_SPEEDS				0x0A010102
#define OID_IRDA_LINK_SPEED						0x0A010103
#define OID_IRDA_MEDIA_BUSY						0x0A010104

#define OID_IRDA_EXTRA_RCV_BOFS					0x0A010200
#define OID_IRDA_RATE_SNIFF						0x0A010201
#define OID_IRDA_UNICAST_LIST					0x0A010202
#define OID_IRDA_MAX_UNICAST_LIST_SIZE			0x0A010203
#define OID_IRDA_MAX_RECEIVE_WINDOW_SIZE		0x0A010204
#define OID_IRDA_MAX_SEND_WINDOW_SIZE			0x0A010205
#define OID_IRDA_RESERVED1						0x0A01020A	// The range between OID_IRDA_RESERVED1
#define OID_IRDA_RESERVED2						0x0A01020F	// and OID_IRDA_RESERVED2 is reserved

//
// BPC OIDs
//
#define	OID_BPC_ADAPTER_CAPS					0x0B010100
#define	OID_BPC_DEVICES							0x0B010101
#define	OID_BPC_DEVICE_CAPS						0x0B010102
#define	OID_BPC_DEVICE_SETTINGS					0x0B010103
#define	OID_BPC_CONNECTION_STATUS				0x0B010104
#define	OID_BPC_ADDRESS_COMPARE					0x0B010105
#define	OID_BPC_PROGRAM_GUIDE					0x0B010106
#define	OID_BPC_LAST_ERROR						0x0B020107
#define	OID_BPC_POOL							0x0B010108

#define	OID_BPC_PROVIDER_SPECIFIC				0x0B020109
#define	OID_BPC_ADAPTER_SPECIFIC				0x0B02010A

#define	OID_BPC_CONNECT							0x0B01010B
#define	OID_BPC_COMMIT							0x0B01010C
#define	OID_BPC_DISCONNECT						0x0B01010D
#define	OID_BPC_CONNECTION_ENABLE				0x0B01010E
#define	OID_BPC_POOL_RESERVE					0x0B01010F
#define	OID_BPC_POOL_RETURN						0x0B010110
#define	OID_BPC_FORCE_RECEIVE					0x0B010111

#define	OID_BPC_LAST							0x0B020112

//
// IEEE1394 mandatory general OIDs.
//
#define OID_1394_LOCAL_NODE_INFO				0x0C010101
#define OID_1394_VC_INFO						0x0C010102

//
// The following OIDs are not specific to a media.
//

//
// These are objects for Connection-oriented media call-managers.
//
#define OID_CO_ADD_PVC							0xFE000001
#define OID_CO_DELETE_PVC						0xFE000002
#define OID_CO_GET_CALL_INFORMATION				0xFE000003
#define OID_CO_ADD_ADDRESS						0xFE000004
#define OID_CO_DELETE_ADDRESS					0xFE000005
#define OID_CO_GET_ADDRESSES					0xFE000006
#define OID_CO_ADDRESS_CHANGE					0xFE000007
#define OID_CO_SIGNALING_ENABLED				0xFE000008
#define OID_CO_SIGNALING_DISABLED				0xFE000009
#define	OID_CO_AF_CLOSE							0xFE00000A

//
// Objects for call-managers and MCMs that support TAPI access.
//
#define OID_CO_TAPI_CM_CAPS						0xFE001001
#define OID_CO_TAPI_LINE_CAPS					0xFE001002
#define OID_CO_TAPI_ADDRESS_CAPS				0xFE001003
#define OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS	0xFE001004
#define OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS	0xFE001005
#define OID_CO_TAPI_TRANSLATE_TAPI_SAP			0xFE001006
#define OID_CO_TAPI_GET_CALL_DIAGNOSTICS		0xFE001007
#define OID_CO_TAPI_REPORT_DIGITS 		  		0xFE001008 
#define OID_CO_TAPI_DONT_REPORT_DIGITS	  		0xFE001009

//
//	PnP and PM OIDs
//
#define	OID_PNP_CAPABILITIES					0xFD010100
#define	OID_PNP_SET_POWER						0xFD010101
#define	OID_PNP_QUERY_POWER						0xFD010102
#define OID_PNP_ADD_WAKE_UP_PATTERN				0xFD010103
#define OID_PNP_REMOVE_WAKE_UP_PATTERN			0xFD010104
#define	OID_PNP_WAKE_UP_PATTERN_LIST			0xFD010105
#define	OID_PNP_ENABLE_WAKE_UP					0xFD010106

//
//	PnP/PM Statistics (Optional).
//
#define	OID_PNP_WAKE_UP_OK						0xFD020200
#define	OID_PNP_WAKE_UP_ERROR					0xFD020201

//
//	The following bits are defined for OID_PNP_ENABLE_WAKE_UP
//
#define	NDIS_PNP_WAKE_UP_MAGIC_PACKET			0x00000001
#define	NDIS_PNP_WAKE_UP_PATTERN_MATCH			0x00000002
#define	NDIS_PNP_WAKE_UP_LINK_CHANGE			0x00000004

//
//	TCP/IP OIDs
//
#define	OID_TCP_TASK_OFFLOAD					0xFC010201
#define	OID_TCP_TASK_IPSEC_ADD_SA				0xFC010202
#define	OID_TCP_TASK_IPSEC_DELETE_SA			0xFC010203
#define OID_TCP_SAN_SUPPORT						0xFC010204


//
//	Defines for FFP
//
#define OID_FFP_SUPPORT							0xFC010210
#define	OID_FFP_FLUSH							0xFC010211
#define	OID_FFP_CONTROL							0xFC010212
#define	OID_FFP_PARAMS							0xFC010213
#define	OID_FFP_DATA							0xFC010214

#define	OID_FFP_DRIVER_STATS					0xFC020210
#define	OID_FFP_ADAPTER_STATS					0xFC020211

//
//	Defines for QOS
//
#define OID_QOS_TC_SUPPORTED					0xFB010100
#define OID_QOS_REMAINING_BANDWIDTH				0xFB010101
#define OID_QOS_ISSLOW_FLOW         			0xFB010102
#define OID_QOS_BESTEFFORT_BANDWIDTH			0xFB010103
#define OID_QOS_LATENCY							0xFB010104
#define OID_QOS_FLOW_IP_CONFORMING    			0xFB010105
#define OID_QOS_FLOW_COUNT						0xFB010106
#define OID_QOS_NON_BESTEFFORT_LIMIT			0xFB010107
#define OID_QOS_SCHEDULING_PROFILES_SUPPORTED	0xFB010108
#define OID_QOS_CURRENT_SCHEDULING_PROFILE		0xFB010109
#define OID_QOS_TIMER_RESOLUTION        		0xFB01010A
#define OID_QOS_STATISTICS_BUFFER				0xFB01010B
#define OID_QOS_HIERARCHY_CLASS					0xFB01010C
#define OID_QOS_FLOW_MODE						0xFB01010D
#define OID_QOS_ISSLOW_FRAGMENT_SIZE			0xFB01010E
#define OID_QOS_FLOW_IP_NONCONFORMING           0xFB01010F
#define OID_QOS_FLOW_8021P_CONFORMING           0xFB010110
#define OID_QOS_FLOW_8021P_NONCONFORMING        0xFB010111

//
// NDIS Proxy OID_GEN_CO_DEVICE_PROFILE structure. The optional OID and
// this structure is a generic means of describing a CO device's
// capabilites, and is used by the NDIS Proxy to construct a TAPI device
// capabilities structure.
//
typedef struct NDIS_CO_DEVICE_PROFILE
{
	NDIS_VAR_DATA_DESC	DeviceDescription;	// e.g. 'GigabitATMNet'
	NDIS_VAR_DATA_DESC	DevSpecificInfo;	// special features

	ULONG	ulTAPISupplementaryPassThru;// reserved in NT5
	ULONG	ulAddressModes;
	ULONG	ulNumAddresses;
	ULONG	ulBearerModes;
	ULONG	ulMaxTxRate; // bytes per second
	ULONG	ulMinTxRate; // bytes per second
	ULONG	ulMaxRxRate; // bytes per second
	ULONG	ulMinRxRate; // bytes per second
	ULONG	ulMediaModes;	

	//
	// Tone/digit generation and recognition capabilities
	//
	ULONG	ulGenerateToneModes;
	ULONG	ulGenerateToneMaxNumFreq;
	ULONG	ulGenerateDigitModes;
	ULONG	ulMonitorToneMaxNumFreq;
	ULONG	ulMonitorToneMaxNumEntries;
	ULONG	ulMonitorDigitModes;
	ULONG	ulGatherDigitsMinTimeout;// milliseconds
	ULONG	ulGatherDigitsMaxTimeout;// milliseconds

	ULONG	ulDevCapFlags;			// Misc. capabilities
	ULONG	ulMaxNumActiveCalls;	// (This * ulMinRate) = total bandwidth (which may equal ulMaxRate)
	ULONG	ulAnswerMode;			// Effect of answering a new call when an
									// existing call is non-idle
	//
	// User-User info sizes allowed to accompany each operation
	//
	ULONG	ulUUIAcceptSize;	// bytes
	ULONG	ulUUIAnswerSize;	// bytes
	ULONG	ulUUIMakeCallSize;	// bytes
	ULONG	ulUUIDropSize;		// bytes
	ULONG	ulUUISendUserUserInfoSize; // bytes
	ULONG	ulUUICallInfoSize;	// bytes

} NDIS_CO_DEVICE_PROFILE, *PNDIS_CO_DEVICE_PROFILE;

//
//	Structures for TCP IPSec.
//
typedef ULONG	IPAddr, IPMask;
typedef	ULONG	SPI_TYPE;

typedef enum	_OFFLOAD_OPERATION_E
{
	AUTHENTICATE = 1,
	ENCRYPT
}
	OFFLOAD_OPERATION_E;

typedef struct _OFFLOAD_ALGO_INFO
{
	ULONG	algoIdentifier;
	ULONG	algoKeylen;
	ULONG	algoRounds;
}
	OFFLOAD_ALGO_INFO,
	*POFFLOAD_ALGO_INFO;

typedef enum _OFFLOAD_CONF_ALGO
{
	OFFLOAD_IPSEC_CONF_NONE,
	OFFLOAD_IPSEC_CONF_DES,
	OFFLOAD_IPSEC_CONF_RESERVED,
	OFFLOAD_IPSEC_CONF_3_DES,
	OFFLOAD_IPSEC_CONF_MAX
}
	OFFLOAD_CONF_ALGO;

typedef enum _OFFLOAD_INTEGRITY_ALGO
{
	OFFLOAD_IPSEC_INTEGRITY_NONE,
	OFFLOAD_IPSEC_INTEGRITY_MD5,
	OFFLOAD_IPSEC_INTEGRITY_SHA,
	OFFLOAD_IPSEC_INTEGRITY_MAX
}
	OFFLOAD_INTEGRITY_ALGO;

typedef struct _OFFLOAD_SECURITY_ASSOCIATION
{
	OFFLOAD_OPERATION_E		Operation;
	SPI_TYPE				SPI;
	OFFLOAD_ALGO_INFO		IntegrityAlgo;
	OFFLOAD_ALGO_INFO		ConfAlgo;
	OFFLOAD_ALGO_INFO		Reserved;
}
	OFFLOAD_SECURITY_ASSOCIATION,
	*POFFLOAD_SECURITY_ASSOCIATION;

#define OFFLOAD_MAX_SAS				3

#define OFFLOAD_INBOUND_SA			0x0001
#define OFFLOAD_OUTBOUND_SA			0x0002

typedef struct _OFFLOAD_IPSEC_ADD_SA
{
	IPAddr							SrcAddr;
	IPMask							SrcMask;
	IPAddr							DestAddr;
	IPMask							DestMask;
	ULONG							Protocol;
	USHORT							SrcPort;
	USHORT							DestPort;
	IPAddr							SrcTunnelAddr;
	IPAddr							DestTunnelAddr;
	USHORT							Flags;
	SHORT							NumSAs;
	OFFLOAD_SECURITY_ASSOCIATION	SecAssoc[OFFLOAD_MAX_SAS];
	HANDLE							OffloadHandle;
	ULONG							KeyLen;
	UCHAR							KeyMat[1];
} OFFLOAD_IPSEC_ADD_SA, *POFFLOAD_IPSEC_ADD_SA;

typedef struct _OFFLOAD_IPSEC_DELETE_SA
{
	HANDLE	OffloadHandle;
} OFFLOAD_IPSEC_DELETE_SA, *POFFLOAD_IPSEC_DELETE_SA;

//
// Medium the Ndis Driver is running on (OID_GEN_MEDIA_SUPPORTED/ OID_GEN_MEDIA_IN_USE).
//
typedef enum _NDIS_MEDIUM
{
	NdisMedium802_3,
	NdisMedium802_5,
	NdisMediumFddi,
	NdisMediumWan,
	NdisMediumLocalTalk,
	NdisMediumDix,				// defined for convenience, not a real medium
	NdisMediumArcnetRaw,
	NdisMediumArcnet878_2,
	NdisMediumAtm,
	NdisMediumWirelessWan,
	NdisMediumIrda,
	NdisMediumBpc,
	NdisMediumCoWan,
	NdisMedium1394,
	NdisMediumMax				// Not a real medium, defined as an upper-bound
} NDIS_MEDIUM, *PNDIS_MEDIUM;


//
// Physical Medium Type definitions. Used with OID_GEN_PHYSICAL_MEDIUM.
//
typedef enum _NDIS_PHYSICAL_MEDIUM
{
	NdisPhysicalMediumReserved0,
	NdisPhysicalMediumWirelessLan,
	NdisPhysicalMediumCableModem,
	NdisPhysicalMediumPhoneLine,
	NdisPhysicalMediumPowerLine,
	NdisPhysicalMediumDSL,		// includes ADSL and UADSL (G.Lite)
	NdisPhysicalMediumMax		// Not a real physical type, defined as an upper-bound
} NDIS_PHYSICAL_MEDIUM, *PNDIS_PHYSICAL_MEDIUM;


//
//	Protocol types supported by ndis. These values need to be consistent with ADDRESS_TYPE_XXX defined in TDI.H
//
#define	NDIS_PROTOCOL_ID_DEFAULT		0x00
#define	NDIS_PROTOCOL_ID_TCP_IP			0x02
#define	NDIS_PROTOCOL_ID_IPX			0x06
#define	NDIS_PROTOCOL_ID_NBF			0x07
#define	NDIS_PROTOCOL_ID_MAX			0x0F
#define	NDIS_PROTOCOL_ID_MASK			0x0F

//
// The following is used with OID_GEN_TRANSPORT_HEADER_OFFSET to indicate the length of the layer-2 header
// for packets sent by a particular protocol.
//
typedef struct _TRANSPORT_HEADER_OFFSET
{
	USHORT		ProtocolType;		// The protocol that is sending this OID (NDIS_PROTOCOL_ID_XXX above)
	USHORT		HeaderOffset;		// The header offset
} TRANSPORT_HEADER_OFFSET, *PTRANSPORT_HEADER_OFFSET;


//
// The structures below need to be consistent with TRANSPORT_ADDRESS structures in TDI.H
//
typedef struct _NETWORK_ADDRESS
{
	USHORT		AddressLength;		// length in bytes of Address[] in this
	USHORT		AddressType;		// type of this address (NDIS_PROTOCOL_ID_XXX above)
	UCHAR		Address[1];			// actually AddressLength bytes long
} NETWORK_ADDRESS, *PNETWORK_ADDRESS;

//
// The following is used with OID_GEN_NETWORK_LAYER_ADDRESSES to set network layer addresses on an interface
//
typedef struct _NETWORK_ADDRESS_LIST
{
	LONG		AddressCount;		// number of addresses following
	USHORT		AddressType;		// type of this address (NDIS_PROTOCOL_ID_XXX above)
	NETWORK_ADDRESS Address[1];		// actually AddressCount elements long
} NETWORK_ADDRESS_LIST, *PNETWORK_ADDRESS_LIST;

//
// IP address - This must remain consistent with TDI_ADDRESS_IP in tdi.h
//
typedef struct _NETWORK_ADDRESS_IP
{
	USHORT		sin_port;
	ULONG		in_addr;
	UCHAR		sin_zero[8];
} NETWORK_ADDRESS_IP, *PNETWORK_ADDRESS_IP;

#define NETWORK_ADDRESS_LENGTH_IP sizeof (NETWORK_ADDRESS_IP)

//
// IPX address - This must remain consistent with TDI_ADDRESS_IPX in tdi.h.
//
typedef struct _NETWORK_ADDRESS_IPX
{
	ULONG		NetworkAddress;
	UCHAR		NodeAddress[6];
	USHORT		Socket;
} NETWORK_ADDRESS_IPX, *PNETWORK_ADDRESS_IPX;

#define NETWORK_ADDRESS_LENGTH_IPX sizeof (NETWORK_ADDRESS_IPX)

//
// Hardware status codes (OID_GEN_HARDWARE_STATUS).
//

typedef enum _NDIS_HARDWARE_STATUS
{
	NdisHardwareStatusReady,
	NdisHardwareStatusInitializing,
	NdisHardwareStatusReset,
	NdisHardwareStatusClosing,
	NdisHardwareStatusNotReady
} NDIS_HARDWARE_STATUS, *PNDIS_HARDWARE_STATUS;


//
// this is the type passed in the OID_GEN_GET_TIME_CAPS request
//
typedef struct _GEN_GET_TIME_CAPS
{
	ULONG						Flags;	// Bits defined below
	ULONG						ClockPrecision;
} GEN_GET_TIME_CAPS, *PGEN_GET_TIME_CAPS;

#define	READABLE_LOCAL_CLOCK					0x00000001
#define	CLOCK_NETWORK_DERIVED					0x00000002
#define	CLOCK_PRECISION							0x00000004
#define	RECEIVE_TIME_INDICATION_CAPABLE			0x00000008
#define	TIMED_SEND_CAPABLE						0x00000010
#define	TIME_STAMP_CAPABLE						0x00000020

//
// this is the type passed in the OID_GEN_GET_NETCARD_TIME request
//
typedef struct _GEN_GET_NETCARD_TIME
{
	ULONGLONG					ReadTime;
} GEN_GET_NETCARD_TIME, *PGEN_GET_NETCARD_TIME;

//
//	NDIS PnP routines and definitions.
//
typedef struct _NDIS_PM_PACKET_PATTERN
{
	ULONG	Priority;					// Importance of the given pattern.
	ULONG	Reserved;					// Context information for transports.
	ULONG	MaskSize;					// Size in bytes of the pattern mask.
	ULONG	PatternOffset;				// Offset from beginning of this
										// structure to the pattern bytes.
	ULONG	PatternSize;				// Size in bytes of the pattern.
	ULONG	PatternFlags;				// Flags (TBD).
} NDIS_PM_PACKET_PATTERN, *PNDIS_PM_PACKET_PATTERN;


//
//	The following structure defines the device power states.
//
typedef enum _NDIS_DEVICE_POWER_STATE
{
	NdisDeviceStateUnspecified = 0,
	NdisDeviceStateD0,
	NdisDeviceStateD1,
	NdisDeviceStateD2,
	NdisDeviceStateD3,
	NdisDeviceStateMaximum
} NDIS_DEVICE_POWER_STATE, *PNDIS_DEVICE_POWER_STATE;

//
//	The following structure defines the wake-up capabilities of the device.
//
typedef struct _NDIS_PM_WAKE_UP_CAPABILITIES
{
	NDIS_DEVICE_POWER_STATE	MinMagicPacketWakeUp;
	NDIS_DEVICE_POWER_STATE	MinPatternWakeUp;
	NDIS_DEVICE_POWER_STATE	MinLinkChangeWakeUp;
} NDIS_PM_WAKE_UP_CAPABILITIES, *PNDIS_PM_WAKE_UP_CAPABILITIES;

//
// the following flags define the -enabled- wake-up capabilities of the device
// passed in the Flags field of NDIS_PNP_CAPABILITIES structure
//
#define NDIS_DEVICE_WAKE_UP_ENABLE          0x00000001

//
//	This structure defines general PnP capabilities of the miniport driver.
//
typedef struct _NDIS_PNP_CAPABILITIES
{
	ULONG							Flags;
	NDIS_PM_WAKE_UP_CAPABILITIES	WakeUpCapabilities;
} NDIS_PNP_CAPABILITIES, *PNDIS_PNP_CAPABILITIES;

//
// Defines the attachment types for FDDI (OID_FDDI_ATTACHMENT_TYPE).
//
typedef enum _NDIS_FDDI_ATTACHMENT_TYPE
{
	NdisFddiTypeIsolated = 1,
	NdisFddiTypeLocalA,
	NdisFddiTypeLocalB,
	NdisFddiTypeLocalAB,
	NdisFddiTypeLocalS,
	NdisFddiTypeWrapA,
	NdisFddiTypeWrapB,
	NdisFddiTypeWrapAB,
	NdisFddiTypeWrapS,
	NdisFddiTypeCWrapA,
	NdisFddiTypeCWrapB,
	NdisFddiTypeCWrapS,
	NdisFddiTypeThrough
} NDIS_FDDI_ATTACHMENT_TYPE, *PNDIS_FDDI_ATTACHMENT_TYPE;


//
// Defines the ring management states for FDDI (OID_FDDI_RING_MGT_STATE).
//
typedef enum _NDIS_FDDI_RING_MGT_STATE
{
	NdisFddiRingIsolated = 1,
	NdisFddiRingNonOperational,
	NdisFddiRingOperational,
	NdisFddiRingDetect,
	NdisFddiRingNonOperationalDup,
	NdisFddiRingOperationalDup,
	NdisFddiRingDirected,
	NdisFddiRingTrace
} NDIS_FDDI_RING_MGT_STATE, *PNDIS_FDDI_RING_MGT_STATE;


//
// Defines the Lconnection state for FDDI (OID_FDDI_LCONNECTION_STATE).
//
typedef enum _NDIS_FDDI_LCONNECTION_STATE
{
	NdisFddiStateOff = 1,
	NdisFddiStateBreak,
	NdisFddiStateTrace,
	NdisFddiStateConnect,
	NdisFddiStateNext,
	NdisFddiStateSignal,
	NdisFddiStateJoin,
	NdisFddiStateVerify,
	NdisFddiStateActive,
	NdisFddiStateMaintenance
} NDIS_FDDI_LCONNECTION_STATE, *PNDIS_FDDI_LCONNECTION_STATE;


//
// Defines the medium subtypes for WAN medium (OID_WAN_MEDIUM_SUBTYPE).
// Sub-medium used only by connection-oriented WAN devices
// i.e. NdisMediumWan, NdisMediumCoWan.
//
typedef enum _NDIS_WAN_MEDIUM_SUBTYPE
{
	NdisWanMediumHub,
	NdisWanMediumX_25,
	NdisWanMediumIsdn,
	NdisWanMediumSerial,
	NdisWanMediumFrameRelay,
	NdisWanMediumAtm,
	NdisWanMediumSonet,
	NdisWanMediumSW56K,
	NdisWanMediumPPTP,
	NdisWanMediumL2TP,
	NdisWanMediumIrda,
	NdisWanMediumParallel
} NDIS_WAN_MEDIUM_SUBTYPE, *PNDIS_WAN_MEDIUM_SUBTYPE;


//
// Defines the header format for WAN medium (OID_WAN_HEADER_FORMAT).
//
typedef enum _NDIS_WAN_HEADER_FORMAT
{
	NdisWanHeaderNative,		// src/dest based on subtype, followed by NLPID
	NdisWanHeaderEthernet		// emulation of ethernet header
} NDIS_WAN_HEADER_FORMAT, *PNDIS_WAN_HEADER_FORMAT;


//
// Defines the line quality on a WAN line (OID_WAN_QUALITY_OF_SERVICE).
//
typedef enum _NDIS_WAN_QUALITY
{
	NdisWanRaw,
	NdisWanErrorControl,
	NdisWanReliable
} NDIS_WAN_QUALITY, *PNDIS_WAN_QUALITY;


//
// Defines a protocol's WAN specific capabilities (OID_WAN_PROTOCOL_CAPS).
//
typedef struct _NDIS_WAN_PROTOCOL_CAPS
{
	IN	ULONG	Flags;
	IN	ULONG	Reserved;
} NDIS_WAN_PROTOCOL_CAPS, *PNDIS_WAN_PROTOCOL_CAPS;


//
// Flags used in NDIS_WAN_PROTOCOL_CAPS
//
#define WAN_PROTOCOL_KEEPS_STATS	0x00000001


//
// Defines the state of a token-ring adapter (OID_802_5_CURRENT_RING_STATE).
//
typedef enum _NDIS_802_5_RING_STATE
{
	NdisRingStateOpened = 1,
	NdisRingStateClosed,
	NdisRingStateOpening,
	NdisRingStateClosing,
	NdisRingStateOpenFailure,
	NdisRingStateRingFailure
} NDIS_802_5_RING_STATE, *PNDIS_802_5_RING_STATE;

//
// Defines the state of the LAN media
//
typedef enum _NDIS_MEDIA_STATE
{
	NdisMediaStateConnected,
	NdisMediaStateDisconnected
} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;

//
// The following is set on a per-packet basis as OOB data with NdisClass802_3Priority
//
typedef	ULONG	Priority_802_3;			// 0-7 priority levels

//
//	The following structure is used to query OID_GEN_CO_LINK_SPEED and
//	OID_GEN_CO_MINIMUM_LINK_SPEED. The first OID will return the current
//	link speed of the adapter. The second will return the minimum link speed
//	the adapter is capable of.
//
typedef struct _NDIS_CO_LINK_SPEED
{
	ULONG	Outbound;
	ULONG	Inbound;
} NDIS_CO_LINK_SPEED, *PNDIS_CO_LINK_SPEED;

#ifndef	_NDIS_
typedef	int	NDIS_STATUS, *PNDIS_STATUS;
#endif

//
//	Structure to be used for OID_GEN_SUPPORTED_GUIDS.
//	This structure describes an OID to GUID mapping.
//	Or a Status to GUID mapping.
//	When ndis receives a request for a give GUID it will
//	query the miniport with the supplied OID.
//
typedef struct _NDIS_GUID
{
	GUID			Guid;
	union
	{
		NDIS_OID	Oid;
		NDIS_STATUS	Status;
	};
	ULONG		Size;				//	Size of the data element. If the GUID
									//	represents an array then this is the
									//	size of an element in the array.
									//	This is -1 for strings.
	ULONG		Flags;
} NDIS_GUID, *PNDIS_GUID;

#define	fNDIS_GUID_TO_OID			0x00000001
#define	fNDIS_GUID_TO_STATUS		0x00000002
#define	fNDIS_GUID_ANSI_STRING		0x00000004
#define	fNDIS_GUID_UNICODE_STRING	0x00000008
#define	fNDIS_GUID_ARRAY			0x00000010

//
// Ndis Packet Filter Bits (OID_GEN_CURRENT_PACKET_FILTER).
//
#define NDIS_PACKET_TYPE_DIRECTED				0x00000001
#define NDIS_PACKET_TYPE_MULTICAST				0x00000002
#define NDIS_PACKET_TYPE_ALL_MULTICAST			0x00000004
#define NDIS_PACKET_TYPE_BROADCAST				0x00000008
#define NDIS_PACKET_TYPE_SOURCE_ROUTING			0x00000010
#define NDIS_PACKET_TYPE_PROMISCUOUS			0x00000020
#define NDIS_PACKET_TYPE_SMT					0x00000040
#define NDIS_PACKET_TYPE_ALL_LOCAL				0x00000080
#define NDIS_PACKET_TYPE_GROUP					0x00001000
#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL			0x00002000
#define NDIS_PACKET_TYPE_FUNCTIONAL				0x00004000
#define NDIS_PACKET_TYPE_MAC_FRAME				0x00008000


//
// Ndis Token-Ring Ring Status Codes (OID_802_5_CURRENT_RING_STATUS).
//
#define NDIS_RING_SIGNAL_LOSS					0x00008000
#define NDIS_RING_HARD_ERROR					0x00004000
#define NDIS_RING_SOFT_ERROR					0x00002000
#define NDIS_RING_TRANSMIT_BEACON				0x00001000
#define NDIS_RING_LOBE_WIRE_FAULT				0x00000800
#define NDIS_RING_AUTO_REMOVAL_ERROR			0x00000400
#define NDIS_RING_REMOVE_RECEIVED				0x00000200
#define NDIS_RING_COUNTER_OVERFLOW				0x00000100
#define NDIS_RING_SINGLE_STATION				0x00000080
#define NDIS_RING_RING_RECOVERY					0x00000040


//
// Ndis protocol option bits (OID_GEN_PROTOCOL_OPTIONS).
//
#define NDIS_PROT_OPTION_ESTIMATED_LENGTH		0x00000001
#define NDIS_PROT_OPTION_NO_LOOPBACK			0x00000002
#define NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT		0x00000004

//
// Ndis MAC option bits (OID_GEN_MAC_OPTIONS).
//
#define NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA		0x00000001
#define NDIS_MAC_OPTION_RECEIVE_SERIALIZED		0x00000002
#define NDIS_MAC_OPTION_TRANSFERS_NOT_PEND		0x00000004
#define NDIS_MAC_OPTION_NO_LOOPBACK				0x00000008
#define NDIS_MAC_OPTION_FULL_DUPLEX				0x00000010
#define	NDIS_MAC_OPTION_EOTX_INDICATION			0x00000020
#define	NDIS_MAC_OPTION_8021P_PRIORITY			0x00000040
#define NDIS_MAC_OPTION_RESERVED				0x80000000

//
//	NDIS media capabilities bits (OID_GEN_MEDIA_CAPABILITIES).
//
#define NDIS_MEDIA_CAP_TRANSMIT					0x00000001	// Supports sending data
#define NDIS_MEDIA_CAP_RECEIVE					0x00000002	// Supports receiving data

//
//	NDIS MAC option bits for OID_GEN_CO_MAC_OPTIONS.
//
#define	NDIS_CO_MAC_OPTION_DYNAMIC_LINK_SPEED	0x00000001

#ifdef	IRDA

//
// The following is set on a per-packet basis as OOB data with NdisClassIrdaPacketInfo
// This is the per-packet info specified on a per-packet basis
//
typedef	struct _NDIS_IRDA_PACKET_INFO
{
	ULONG						ExtraBOFs;
	ULONG						MinTurnAroundTime;
} NDIS_IRDA_PACKET_INFO, *PNDIS_IRDA_PACKET_INFO;

#endif

#ifdef WIRELESS_WAN

//
// Wireless WAN structure definitions
//
//
// currently defined Wireless network subtypes
//
typedef enum _NDIS_WW_NETWORK_TYPE
{
	NdisWWGeneric,
	NdisWWMobitex,
	NdisWWPinpoint,
	NdisWWCDPD,
	NdisWWArdis,
	NdisWWDataTAC,
	NdisWWMetricom,
	NdisWWGSM,
	NdisWWCDMA,
	NdisWWTDMA,
	NdisWWAMPS,
	NdisWWInmarsat,
	NdisWWpACT,
	NdisWWFlex,
	NdisWWIDEN
} NDIS_WW_NETWORK_TYPE;

//
// currently defined header formats
//
typedef enum _NDIS_WW_HEADER_FORMAT
{
	NdisWWDIXEthernetFrames,
	NdisWWMPAKFrames,
	NdisWWRDLAPFrames,
	NdisWWMDC4800Frames,
	NdisWWNCLFrames
} NDIS_WW_HEADER_FORMAT;

//
// currently defined encryption types
//
typedef enum _NDIS_WW_ENCRYPTION_TYPE
{
	NdisWWUnknownEncryption = -1,
	NdisWWNoEncryption,
	NdisWWDefaultEncryption,
	NdisWWDESEncryption,
	NdisWWRC2Encryption,
	NdisWWRC4Encryption,
	NdisWWRC5Encryption
} NDIS_WW_ENCRYPTION_TYPE, *PNDIS_WW_ENCRYPTION_TYPE;

typedef enum _WW_ADDRESS_FORMAT
{
	WW_IEEE_ADDRESS = 0,
	WW_MOBITEX_MAN_ADDRESS,
	WW_DATATAC_RDLAP_ADDRESS,
	WW_DATATAC_MDC4800_ADDRESS,
	WW_DATATAC_RESERVED,
	WW_IPv4_ADDRESS,
	WW_IPv6_ADDRESS,
	WW_PROPRIETARY_ADDRESS,
} WW_ADDRESS_FORMAT;

typedef enum _WW_GEN_SUM_EXCEPTION
{
	SIM_STATUS_OK = 0,
	SIM_STATUS_ERROR,
	SIM_STATUS_MISSING,
	SIM_STATUS_NO_RESPONSE,
	SIM_STATUS_REMOVED,
	SIM_STATUS_CRYPT_ERROR,
	SIM_STATUS_AUTH_ERROR,
	SIM_STATUS_NEED_PIN,
	SIM_STATUS_NEED_PUK,
	SIM_STATUS_WRONG,
} WW_GEN_SIM_EXCEPTION;


//
// OID_WW_GEN_INDICATION_REQUEST
//
typedef struct _NDIS_WW_INDICATION_REQUEST
{
	NDIS_OID			Oid;					// IN
	ULONG				uIndicationFlag;		// IN
	ULONG				uApplicationToken;		// IN OUT
	HANDLE				hIndicationHandle;		// IN OUT
	INT					iPollingInterval;		// IN OUT
	NDIS_VAR_DATA_DESC	InitialValue;			// IN OUT
	NDIS_VAR_DATA_DESC	OIDIndicationValue;		// OUT - only valid after indication
	NDIS_VAR_DATA_DESC	TriggerValue;			// IN
} NDIS_WW_INDICATION_REQUEST, *PNDIS_WW_INDICATION_REQUEST;

#define OID_INDICATION_REQUEST_ENABLE			0x0000
#define OID_INDICATION_REQUEST_CANCEL			0x0001

//
// OID_WW_GEN_DEVICE_INFO
//
typedef struct _WW_DEVICE_INFO
{
	NDIS_VAR_DATA_DESC	Manufacturer;
	NDIS_VAR_DATA_DESC	ModelNum;
	NDIS_VAR_DATA_DESC	SWVersionNum;
	NDIS_VAR_DATA_DESC	SerialNum;
} WW_DEVICE_INFO, *PWW_DEVICE_INFO;

//
// OID_WW_GEN_OPERATION_MODE
//
typedef INT WW_OPERATION_MODE;					//  0 = Normal mode
												//  1 = Power saving mode
												// -1 = mode unknown

//
// OID_WW_GEN_LOCK_STATUS
//
typedef INT WW_LOCK_STATUS;						//  0 = unlocked
												//  1 = locked
												// -1 = unknown lock status

//
// OID_WW_GEN_DISABLE_TRANSMITTER
//
typedef INT WW_DISABLE_TRANSMITTER;				//  0 = transmitter enabled
												//  1 = transmitter disabled
												// -1 = unknown value

//
// OID_WW_GEN_NETWORK_ID
//
typedef NDIS_VAR_DATA_DESC	WW_NETWORK_ID;

//
// OID_WW_GEN_PERMANENT_ADDRESS	
//
typedef NDIS_VAR_DATA_DESC	WW_PERMANENT_ADDRESS;

//
// OID_WW_GEN_CURRENT_ADDRESS	
//
typedef struct _WW_CURRENT_ADDRESS
{
	NDIS_WW_HEADER_FORMAT	Format;
	NDIS_VAR_DATA_DESC		Address;
} WW_CURRENT_ADDRESS, *PWW_CURRENT_ADDRESS;

//
// OID_WW_GEN_SUSPEND_DRIVER
//
typedef BOOLEAN WW_SUSPEND_DRIVER;				// 0 = driver operational
												// 1 = driver suspended
//
// OID_WW_GEN_BASESTATION_ID
//
typedef NDIS_VAR_DATA_DESC	WW_BASESTATION_ID;

//
// OID_WW_GEN_CHANNEL_ID
//
typedef NDIS_VAR_DATA_DESC	WW_CHANNEL_ID;

//
// OID_WW_GEN_ENCRYPTION_STATE
//
typedef BOOLEAN	WW_ENCRYPTION_STATE;			// 0 = if encryption is disabled
												// 1 = if encryption is enabled

//
// OID_WW_GEN_CHANNEL_QUALITY
//
typedef INT		WW_CHANNEL_QUALITY;				//  0 = Not in network contact,
												// 1-100 = Quality of Channel (100 is highest quality).
												// -1 = channel quality is unknown

//
// OID_WW_GEN_REGISTRATION_STATUS
//
typedef INT		WW_REGISTRATION_STATUS;			//  0 = Registration denied
												//  1 = Registration pending
												//  2 = Registered
												// -1 = unknown registration status

//
// OID_WW_GEN_RADIO_LINK_SPEED
//
typedef ULONG	WW_RADIO_LINK_SPEED;			// Bits per second.

//
// OID_WW_GEN_LATENCY
//
typedef ULONG	WW_LATENCY;						//  milliseconds

//
// OID_WW_GEN_BATTERY_LEVEL
//
typedef INT		WW_BATTERY_LEVEL;				//  0-100 = battery level in percentage
												//	(100=fully charged)
												// -1 = unknown battery level.

//
// OID_WW_GEN_EXTERNAL_POWER
//
typedef INT		WW_EXTERNAL_POWER;				//	0 = no external power connected
												//	1 = external power connected
												//  -1 = unknown

//
// Ping Address structure
//
typedef struct _WW_PING_ADDRESS
{
	WW_ADDRESS_FORMAT	Format;					// IN
	NDIS_VAR_DATA_DESC	TargetAddress;			// IN
	UINT				uTime;					// OUT in milleseconds
} WW_PING_ADDRESS;


//
// RSSI structure
//
typedef struct _WW_RECEIVE_SIGNAL_STRENGTH_INDICATOR
{
	INT					iDecibels;				// value in DB
	INT					iFactor;				// power of 10
} WW_RECEIVE_SIGNAL_STRENGTH_INDICATOR;


//
// SIM status structure
//
typedef struct _WW_SIM_STATUS
{
	BOOLEAN				bHasSIM;				// TRUE = SIM required
	BOOLEAN 			bBlocked;				// TRUE = SIM PIN access blocked
	BOOLEAN 			bLocked;				// TRUE = PIN need to access device
	BOOLEAN 			bInitialized;			// TRUE = SIM initialized
	UINT				uCountdown;				// = remaining number of attempt to
												// enter correct PIN
} WW_SIM_STATUS;

//
// enable SIM PIN structure
//
typedef struct _WW_ENABLE_SIM_PIN
{
	BOOLEAN				bEnabled;				// TRUE = security feature of SIM enabled
	NDIS_VAR_DATA_DESC	CurrentPIN;				// describes buffer containing PIN value
} WW_ENABLE_SIM_PIN;

//
// SIM PIN structure
//
typedef struct _WW_CHANGE_SIM_PIN
{
	NDIS_VAR_DATA_DESC	OldPIN;					// describes buffer containing OLD PIN
	NDIS_VAR_DATA_DESC	NewPIN;					// describes buffer containing new PIN
} WW_CHANGE_SIM_PIN;


//
// new change SIM PUK structure
//
typedef NDIS_VAR_DATA_DESC		WW_ENABLE_SIM_PUK;


//
// OID_WW_MET_FUNCTION
//
typedef NDIS_VAR_DATA_DESC		WW_MET_FUNCTION;

//
// OID_WW_TAC_COMPRESSION
//
typedef BOOLEAN	WW_TAC_COMPRESSION;				// Determines whether or not network level compression
												// is being used.

//
// OID_WW_TAC_SET_CONFIG
//
// The DataTAC OID that referenced this object has been superceeded. The
// definition is still included for historical purposes only and should not
// be used
//
typedef struct _WW_TAC_SETCONFIG
{
	NDIS_VAR_DATA_DESC	RCV_MODE;				// Select confirmed/unconfirmed
												// receive mode
	NDIS_VAR_DATA_DESC	TX_CONTROL;				// Enable or Disable transmitter
	NDIS_VAR_DATA_DESC	RX_CONTROL;				// Enable or disable radio in
												// the modem
	NDIS_VAR_DATA_DESC	FLOW_CONTROL;			// Set flow control between DTE
												// and DCE
	NDIS_VAR_DATA_DESC	RESET_CNF;				// Reset configuration to
												// default
	NDIS_VAR_DATA_DESC	READ_CNF;				// Read the current
												// configuration
} WW_TAC_SETCONFIG, *PWW_TAC_SETCONFIG;

//
// OID_WW_TAC_GET_STATUS
//
// The DataTAC OID that referenced this object has been superceeded. The
// definition is still included for historical purposes only and should not
// be used
//
typedef struct _WW_TAC_GETSTATUS
{
	BOOLEAN					Action;				// Set = Execute command.
	NDIS_VAR_DATA_DESC		Command;
	NDIS_VAR_DATA_DESC		Option;
	NDIS_VAR_DATA_DESC		Response;			// The response to the requested command
												// - max. length of string is 256 octets.
} WW_TAC_GETSTATUS, *PWW_TAC_GETSTATUS;

//
// OID_WW_TAC_USER_HEADER
//
typedef NDIS_VAR_DATA_DESC	WW_TAC_USERHEADER;	// This will hold the user header - Max. 64 octets.

// August 25, 1998 @14:16 EDT by Emil Sturniolo - WRQ
// added new DataTAC get response structure
typedef  struct _WW_TAC_GET_RESPONSE
{
	UINT				SDUTag;					// previousl assigned token
	NDIS_VAR_DATA_DESC	Response;				// response - max 2048 octets
} WW_TAC_GET_RESPONSE;

//
// DataTAC disable receiver structure
//
typedef INT WW_TAC_DISABLE_RECEIVER;			// 0 = receiver enabled
												// 1 = receiver disabled
												// -1 = state of recevier unknown

//
// DataTAC antenna mode structure
//
typedef INT WW_TAC_ANTENNA_MODE;				// 0 = Automatic Antenna selection
												// 1 = Always use primary antenna
												// 2 = Always use secondary antenna
												// -1 = Antenna algorithm unknown

//
// DataTAC get response structure
//
typedef INT WW_TAC_FLUSH_DATA;					// 1 = flush buffered data destine to net
												// 2 = flush buffered data received from net
												// 3 = flush all buffered data

//
// DataTAC shutdown device structure
//
typedef INT	WW_TAC_SHUTDOWN_DEVICE;				// 0 = device enabled
												// 1 = device disabled
												// -1 = state of device unknown

//
// DataTAC transmitter keyed structure
//
typedef BOOLEAN WW_TAC_TRANSMITTER_KEYED;

//
// added new DataTAC system table structure
//
typedef struct _WW_TAC_SYSTEM_TABLE
{
	UINT		SystemCount;
	UCHAR		ContryTable[32];
	UCHAR		PrefixTable[32];
	UCHAR		IDTable[32];
} WW_TAC_SYSTEM_TABLE;

//
// added new DataTAC channel table structure
//
typedef struct _WW_TAC_CHANNEL_TABLE
{
	UINT		ChannelCount;
	UCHAR		ChannelTable[64];
	UCHAR		AttrTable[64];
} WW_TAC_CHANNEL_TABLE;


//
// added new DataTAC statistics structure
//
typedef NDIS_VAR_DATA_DESC WW_TAC_STATISTICS;



//
// OID_WW_ARD_SNDCP
//
// The ARDIS OIDs that referenced these object have been deprecated and merged
// with the new DataTAC objects. Their definition are still included for
// historical purposes only and should not be used.
//
typedef struct _WW_ARD_SNDCP
{
	NDIS_VAR_DATA_DESC	Version;				// The version of SNDCP protocol supported.
	INT					BlockSize;				// The block size used for SNDCP
	INT					Window;					// The window size used in SNDCP
} WW_ARD_SNDCP, *PWW_ARD_SNDCP;

//
// OID_WW_ARD_TMLY_MSG
//
typedef BOOLEAN	WW_ARD_CHANNEL_STATUS;			// The current status of the inbound RF Channel.

//
// OID_WW_ARD_DATAGRAM
//
typedef struct _WW_ARD_DATAGRAM
{
	BOOLEAN				LoadLevel;				// Byte that contains the load level info.
	INT					SessionTime;			// Datagram session time remaining.
	NDIS_VAR_DATA_DESC	HostAddr;				// Host address.
	NDIS_VAR_DATA_DESC	THostAddr;				// Test host address.
} WW_ARD_DATAGRAM, *PWW_ARD_DATAGRAM;

//
// OID_WW_CDPD_SPNI
//
typedef struct _WW_CDPD_SPNI
{
	ULONG	SPNI[10];							//10 16-bit service provider network IDs
	INT		OperatingMode;						// 0 = ignore SPNI,
												// 1 = require SPNI from list,
												// 2 = prefer SPNI from list.
												// 3 = exclude SPNI from list.
} WW_CDPD_SPNI, *PWW_CDPD_SPNI;

//
// OID_WW_CDPD_WASI
//
typedef struct _WW_CDPD_WIDE_AREA_SERVICE_ID
{
	ULONG	WASI[10];							//10 16-bit wide area service IDs
	INT		OperatingMode;						// 0 = ignore WASI,
												// 1 = Require WASI from list,
												// 2 = prefer WASI from list
												// 3 = exclude WASI from list.
} WW_CDPD_WIDE_AREA_SERVICE_ID, *PWW_CDPD_WIDE_AREA_SERVICE_ID;

//
// OID_WW_CDPD_AREA_COLOR
//
typedef INT		WW_CDPD_AREA_COLOR;

//
// OID_WW_CDPD_TX_POWER_LEVEL
//
typedef ULONG	WW_CDPD_TX_POWER_LEVEL;

//
// OID_WW_CDPD_EID
//
typedef NDIS_VAR_DATA_DESC	WW_CDPD_EID;
//
// OID_WW_CDPD_HEADER_COMPRESSION
//
typedef INT	WW_CDPD_HEADER_COMPRESSION;			//  0 = no header compression,
												//  1 = always compress headers,
												//  2 = compress headers if MD-IS does
												// -1 = unknown

//
// OID_WW_CDPD_DATA_COMPRESSION
//
typedef INT	WW_CDPD_DATA_COMPRESSION;			// 0  = no data compression,
												// 1  = data compression enabled
												// -1 = unknown

//
// OID_WW_CDPD_CHANNEL_SELECT
//
typedef struct _WW_CDPD_CHANNEL_SELECT
{
	ULONG	ChannelID;							// channel number
	ULONG	fixedDuration;						// duration in seconds
} WW_CDPD_CHANNEL_SELECT, *PWW_CDPD_CHANNEL_SELECT;

//
// OID_WW_CDPD_CHANNEL_STATE
//
typedef enum _WW_CDPD_CHANNEL_STATE
{
	CDPDChannelNotAvail,
	CDPDChannelScanning,
	CDPDChannelInitAcquired,
	CDPDChannelAcquired,
	CDPDChannelSleeping,
	CDPDChannelWaking,
	CDPDChannelCSDialing,
	CDPDChannelCSRedial,
	CDPDChannelCSAnswering,
	CDPDChannelCSConnected,
	CDPDChannelCSSuspended
} WW_CDPD_CHANNEL_STATE, *PWW_CDPD_CHANNEL_STATE;

//
// OID_WW_CDPD_NEI
//
typedef enum _WW_CDPD_NEI_FORMAT
{
	CDPDNeiIPv4,
	CDPDNeiCLNP,
	CDPDNeiIPv6
} WW_CDPD_NEI_FORMAT, *PWW_CDPD_NEI_FORMAT;

typedef enum _WW_CDPD_NEI_TYPE
{
	CDPDNeiIndividual,
	CDPDNeiMulticast,
	CDPDNeiBroadcast
} WW_CDPD_NEI_TYPE;


typedef struct _WW_CDPD_NEI
{
	ULONG				uNeiIndex;
	WW_CDPD_NEI_FORMAT	NeiFormat;
	WW_CDPD_NEI_TYPE	NeiType;
	WORD				NeiGmid;				// group member identifier, only
												// meaningful if NeiType ==
												// CDPDNeiMulticast
	NDIS_VAR_DATA_DESC	NeiAddress;
} WW_CDPD_NEI;

//
// OID_WW_CDPD_NEI_STATE
//

typedef enum _WW_CDPD_NEI_STATE
{
	CDPDUnknown,
	CDPDRegistered,
	CDPDDeregistered
} WW_CDPD_NEI_STATE, *PWW_CDPD_NEI_STATE;

typedef enum _WW_CDPD_NEI_SUB_STATE
{
	CDPDPending,								// Registration pending
	CDPDNoReason,								// Registration denied - no reason given
	CDPDMDISNotCapable,							// Registration denied - MD-IS not capable of
												//  handling M-ES at this time
	CDPDNEINotAuthorized,						// Registration denied - NEI is not authorized to
												//  use this subnetwork
	CDPDInsufficientAuth,						// Registration denied - M-ES gave insufficient
												//  authentication credentials
	CDPDUnsupportedAuth,						// Registration denied - M-ES gave unsupported
												//  authentication credentials
	CDPDUsageExceeded,							// Registration denied - NEI has exceeded usage
												//  limitations
	CDPDDeniedThisNetwork						// Registration denied on this network, service
												//  may be obtained on alternate Service Provider
												//  network
} WW_CDPD_NEI_SUB_STATE;

typedef struct _WW_CDPD_NEI_REG_STATE
{
	ULONG				uNeiIndex;
	WW_CDPD_NEI_STATE	NeiState;
	WW_CDPD_NEI_SUB_STATE NeiSubState;
} WW_CDPD_NEI_REG_STATE, *PWW_CDPD_NEI_REG_STATE;

//
// OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER
//
typedef struct _WW_CDPD_SERVICE_PROVIDER_ID
{
	ULONG	SPI[10];							//10 16-bit service provider IDs
	INT		OperatingMode;						// 0 = ignore SPI,
												// 1 = require SPI from list,
												// 2 = prefer SPI from list.
												// 3 = SPI from list is excluded
} WW_CDPD_SERVICE_PROVIDER_ID, *PWW_CDPD_SERVICE_PROVIDER_ID;

//
// OID_WW_CDPD_SLEEP_MODE
//
typedef INT WW_CDPD_SLEEP_MODE;

//
// OID_WW_CDPD_TEI
//
typedef ULONG	WW_CDPD_TEI;

//
// OID_WW_CDPD_CIRCUIT_SWITCHED
//
// The CDPD OID that referenced this object has been deprecated and superceeded
// by new discrete CDPD objects. The definition is still included for
// historical purposes only and should not be used.
//
typedef struct _WW_CDPD_CIRCUIT_SWITCHED
{
	INT					service_preference;	 // -1 = unknown,
												//  0 = always use packet switched CDPD,
												//  1 = always use CS CDPD via AMPS,
												//  2 = always use CS CDPD via PSTN,
												//  3 = use circuit switched via AMPS only
												//	when packet switched is not available.
												//  4 = use packet switched only when circuit
												//	switched via AMPS is not available.
												//  5 = device manuf. defined service
												//	preference.
												//  6 = device manuf. defined service
												//	preference.
	
	INT					service_status;			// -1 = unknown,
												//  0 = packet switched CDPD,
												//  1 = circuit switched CDPD via AMPS,
												//  2 = circuit switched CDPD via PSTN.
	
	INT					connect_rate;			//  CS connection bit rate (bits per second).
												//  0 = no active connection,
												// -1 = unknown

												//  Dial code last used to dial.
	NDIS_VAR_DATA_DESC	dial_code[20];
	
	ULONG				sid;					//  Current AMPS system ID
	
	INT					a_b_side_selection;		// -1 = unknown,
												//  0 = no AMPS service
												//  1 = AMPS "A" side channels selected
												//  2 = AMPS "B" side channels selected
	
	INT					AMPS_channel;			// -1= unknown
												//  0 = no AMPS service.
												//  1-1023 = AMPS channel number in use
	
	ULONG				action;					//  0 = no action
												//  1 = suspend (hangup)
												//  2 = dial
	
												//  Default dial code for CS CDPD service
												//  encoded as specified in the CS CDPD
												//  implementor guidelines.
	NDIS_VAR_DATA_DESC	default_dial[20];
	
												//  Number for the CS CDPD network to call
												//	back the mobile, encoded as specified in
												//	the CS CDPD implementor guidelines.
	NDIS_VAR_DATA_DESC	call_back[20];
	
	ULONG				sid_list[10];			//  List of 10 16-bit preferred AMPS
												//	system IDs for CS CDPD.
	
	ULONG				inactivity_timer;		//  Wait time after last data before dropping
												//	call.
												//  0-65535 = inactivity time limit (seconds).
	
	ULONG				receive_timer;			//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				conn_resp_timer;		//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				reconn_resp_timer;		//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				disconn_timer;			//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				NEI_reg_timer;			//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				reconn_retry_timer;		//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				link_reset_timer;		//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				link_reset_ack_timer;	//  secs. per CS-CDPD Implementor Guidelines.
	
	ULONG				n401_retry_limit;		//  per CS-CDPD Implementor Guidelines.
	
	ULONG				n402_retry_limit;		//  per CS-CDPD Implementor Guidelines.
	
	ULONG				n404_retry_limit;		//  per CS-CDPD Implementor Guidelines.
	
	ULONG				n405_retry_limit;		//  per CS-CDPD Implementor Guidelines.
} WW_CDPD_CIRCUIT_SWITCHED, *WW_PCDPD_CIRCUIT_SWITCHED;

typedef	ULONG	WW_CDPD_RSSI;

//
// cs-cdpd service preference structure
//
typedef INT	WW_CDPD_CS_SERVICE_PREFERENCE;		// 0 = use packet switched CDPD only
												// 1 = use CS-CDPD via AMPS only
												// 2 = use CS-CDPD via PSTN only
												// 3 = use CS-CDPD via AMPS only
												//     when packet switched is N/A
												// 4 = use packet switched CDPD only
												//     when  CS-CDPD via AMPS is N/A
												// 5 = Device manufacture defined
												//     service preference
												// 6 = device manufacture defined
												//     service preference
												// -1 = unknown

//
// cs-cdpd service status structure
//
typedef INT WW_CDPD_CS_SERVICE_STATUS;			// 0 = Packet switched CDPD
												// 1 = CS-CDPD via AMPS
												// 2 = CS-CDPD via PSTN
												// -1 = unknown



//
// cs-cdpd info structure
//
typedef struct _WW_CDPD_CS_INFO {
	INT					ConnectRage;			// 0 = no active connection
												// -1 = unknown
												// all other values represent BPS
	NDIS_VAR_DATA_DESC	DialCode;				// describes buffer of last dial code
	UINT				SID;					// Current AMPS System ID
	INT					ABSideSelection;		// 0 = no AMPS service
												// 1 = AMPS "A" side channel selected
												// 2 = AMPS "B" side channel selected
	INT					AMPSChannel;			// 0 = no AMPS service
												// 1-1023 = current AMPS channel
												// -1 = Unknown
												// all other values reserved
} WW_CDPD_CS_INFO;



//
// cs-cdpd suspend structure
//
typedef UINT WW_CDPD_CS_SUSPEND;				// 0 = nop; 1 = hang up


//
// cs-cdpd default dial code structure
//
typedef NDIS_VAR_DATA_DESC WW_CDPD_DEFAULT_DIAL_CODE;	// max 20 octets

//
// cs-cdpd callback structure
//
typedef struct _WW_CDPD_CS_CALLBACK
{
	UINT				Enabled;				// 0 = disable; 1 = enable; -1 = unknown
	NDIS_VAR_DATA_DESC	Number;					// descibes buffer contianing dial code
												// max 20 octets
} WW_CDPD_CS_CALLBACK;


//
// cs-cdpd system id list structure
//
typedef struct _WW_CDPD_CS_SID_LIST
{
	UINT	AMPSystemId[10];
} WW_CDPD_CS_SID_LIST;

//
// cs-cdpd configuration structure
//
typedef struct _WW_CDPD_CS_CONFIGURATION
{
	UINT	InactivityTimer;					// in seconds
	UINT	ReceiveTimer;						// in seconds
	UINT	ConnResTimer;						// in seconds
	UINT	ReconnRespTimer;					// in seconds
	UINT	DisconnTimer;						// in seconds
	UINT	NEIRegTimer;						// in seconds
	UINT	ReconnRetryTimer;					// in seconds
	UINT	LinkResetTimer;						// in seconds
	UINT	LinkResetAckTimer;					// in seconds
	UINT	n401RetryLimit;						// per CS-CDPD Implementers guidelines
	UINT	n402RetryLimit;						// per CS-CDPD Implementers guidelines
	UINT	n404RetryLimit;						// per CS-CDPD Implementers guidelines
	UINT	n405RetryLimit;						// per CS-CDPD Implementers guidelines
} WW_CDPD_CS_CONFIGURATION;


//
// OID_WW_PIN_LOC_AUTHORIZE
//
// The Pin Point OIDs that referenced the structures below have been
// deprecated from the PCCA STD-201 standard. Their definitions are still
// included for historical purposes only and should not be used.
//
typedef INT	WW_PIN_AUTHORIZED;					// 0  = unauthorized
												// 1  = authorized
												// -1 = unknown

//
// OID_WW_PIN_LAST_LOCATION
// OID_WW_PIN_LOC_FIX
//
typedef struct _WW_PIN_LOCATION
{
	INT		Latitude;							// Latitude in hundredths of a second
	INT		Longitude;							// Longitude in hundredths of a second
	INT		Altitude;							// Altitude in feet
	INT		FixTime;							// Time of the location fix, since midnight,  local time (of the
												// current day), in tenths of a second
	INT		NetTime;							// Current local network time of the current day, since midnight,
												// in tenths of a second
	INT		LocQuality;							// 0-100 = location quality
	INT		LatReg;								// Latitude registration offset, in hundredths of a second
	INT		LongReg;							// Longitude registration offset, in hundredths of a second
	INT		GMTOffset;							// Offset in minutes of the local time zone from GMT
} WW_PIN_LOCATION, *PWW_PIN_LOCATION;


//
// The following is set on a per-packet basis as OOB data with NdisClassWirelessWanMbxMailbox
//
typedef	ULONG	WW_MBX_MAILBOX_FLAG;			// 1 = set mailbox flag, 0 = do not set mailbox flag

//
// OID_WW_MBX_SUBADDR
//
typedef struct _WW_MBX_PMAN
{
	BOOLEAN				ACTION;					// 0 = Login PMAN,  1 = Logout PMAN
	ULONG				MAN;
	UCHAR				PASSWORD[8];			// Password should be null for Logout and indications.
												// Maximum length of password is 8 chars.
} WW_MBX_PMAN, *PWW_MBX_PMAN;

//
// OID_WW_MBX_FLEXLIST
//
typedef struct  _WW_MBX_FLEXLIST
{
	INT		count;								//  Number of MAN entries used.
												// -1=unknown.
	ULONG	MAN[7];								//  List of MANs.
} WW_MBX_FLEXLIST;

//
// OID_WW_MBX_GROUPLIST
//
typedef struct  _WW_MBX_GROUPLIST
{
	INT	 count;									//  Number of MAN entries used.
												// -1=unknown.
	ULONG	MAN[15];							//  List of MANs.
} WW_MBX_GROUPLIST;

//
// OID_WW_MBX_TRAFFIC_AREA
//
typedef enum	_WW_MBX_TRAFFIC_AREA
{
	unknown_traffic_area,						// The driver has no information about the current traffic area.
	in_traffic_area,							// Mobile unit has entered a subscribed traffic area.
	in_auth_traffic_area,						// Mobile unit is outside traffic area but is authorized.
	unauth_traffic_area							// Mobile unit is outside traffic area but is un-authorized.
} WW_MBX_TRAFFIC_AREA;

//
// OID_WW_MBX_LIVE_DIE
//
typedef INT	WW_MBX_LIVE_DIE;					//  0 = DIE last received	
												//  1 = LIVE last received
												// -1 = unknown

//
// OID_WW_MBX_TEMP_DEFAULTLIST
//
typedef struct _WW_MBX_CHANNEL_PAIR
{
	ULONG				Mobile_Tx;
	ULONG				Mobile_Rx;
} WW_MBX_CHANNEL_PAIR, *PWW_MBX_CHANNEL_PAIR;

typedef struct _WW_MBX_TEMPDEFAULTLIST
{
	ULONG				Length;
	WW_MBX_CHANNEL_PAIR	ChannelPair[1];
} WW_MBX_TEMPDEFAULTLIST, *WW_PMBX_TEMPDEFAULTLIST;

#endif // WIRELESS_WAN

//
//
// Base types that were redefined for BPC
//
// BPC_FILETIME is used exactly like FILETIME in Win32
//
// BPC_HANDLE is opaque to everything except the Miniport
//				
typedef struct _BPC_FILETIME
{
	ULONG	dwLowDateTime;
	ULONG	dwHighDateTime;
} BPC_FILETIME, *PBPC_FILETIME;

typedef	PVOID	BPC_HANDLE;

//
// BPC Extension Globals
//
//
#define	BPC_MIN_DIMENSION		1
#define	BPC_MAX_BUFFER_SIZE		64
#define	BPC_MIN_BUFFER_SIZE		4
#define	BPC_DEVICE_ANY			((BPC_HANDLE) 0xFFFFFFFF)

//
// Buffer indicate reason codes
//
//
typedef	enum _NDIS_BPC_INDICATE_REASON
{
	bpcBufferFull = 0,
	bpcBufferForced,
	bpcBufferTimeOut,
	bpcBufferDiscontinuity,
	bpcBufferOverflow,
	bpcBufferStatusEvent

} NDIS_BPC_INDICATE_REASON, *PNDIS_BPC_INDICATE_REASON;


//
// BPC Stream Types
//
#define	BPC_STREAM_TYPE_GENERIC_MIN		0x01000000
#define	BPC_STREAM_TYPE_RAW				0x01000000
#define	BPC_STREAM_TYPE_MPT_128			0x01000001
#define	BPC_STREAM_TYPE_MPT_128_CRC		0x01000002
#define	BPC_STREAM_TYPE_IP				0x01000003
#define	BPC_STREAM_TYPE_PROVIDER_MIN	0x02000000
#define	BPC_STREAM_TYPE_PROVIDER_MAX	0x02ffffff
#define	BPC_STREAM_TYPE_ADAPTER_MIN		0x03000000
#define	BPC_STREAM_TYPE_ADAPTER_MAX		0x03ffffff


//
// BPC Adapter Capabilities
//
typedef	struct _NDIS_BPC_ADAPTER_CAPS
{
	ULONG	ulBPCMajorRev;
	ULONG	ulBPCMinorRev;
	ULONG	ulcHSDataDevices;
	ULONG	ulbpsHSDeviceMax;
	ULONG	ulcLSDataDevices;
	ULONG	ulbpsLSDeviceMax;
	ULONG	ulcTuningDevices;
	ULONG	ulcbLargestStatus;
	ULONG	ulVendorId;
	ULONG	ulAdapterId;
	GUID	guidProvider;

} NDIS_BPC_ADAPTER_CAPS, *PNDIS_BPC_ADAPTER_CAPS;


//
//	BPC	Device Enumeration
//
typedef	struct _NDIS_BPC_DEVICES
{
	ULONG		ulcDevices;
	BPC_HANDLE	rgnhDevices[BPC_MIN_DIMENSION];

} NDIS_BPC_DEVICES, *PNDIS_BPC_DEVICES;

#define	CbDevices(cnt) (FIELD_OFFSET(NDIS_BPC_DEVICES, rgnhDevices) + (cnt) * sizeof(BPC_HANDLE))


//
// BPC Device Capabilities Structure
//
typedef	struct NDIS_BPC_DEVICE_CAPS
{
	BPC_HANDLE	nhDevice;
	ULONG		ulBPCCaps;
	ULONG		ulbpsMax;
	ULONG		ulcStreamTypes;
	ULONG		rgulStreamTypes[BPC_MIN_DIMENSION];

} NDIS_BPC_DEVICE_CAPS, *PNDIS_BPC_DEVICE_CAPS;

#define	CbDeviceCaps(cnt) (FIELD_OFFSET(NDIS_BPC_DEVICE_CAPS, rgulStreamTypes) + (cnt) * sizeof(ULONG))


//
// BPC Device Capability Definitions
// (ie Flags that can be set in ulBPCCaps
//
#define	BPCCapBusMasteredData	0x01
#define	BPCCapIndependentTuner	0x02
#define	BPCCapExternalDataBus	0x04
#define	BPCCapLowSpeedData		0x10
#define	BPCCapHighSpeedData		0x20


//
// BPC Device Settings Structure
//
typedef	struct NDIS_BPC_DEVICE_SETTINGS
{
	BPC_HANDLE	nhDevice;
	ULONG		ulBPCCaps;
	ULONG		ulcConnections;
	BOOLEAN		fEnabled;
	ULONG		ulStreamType;
	ULONG		ulcbAddressConnection;
	ULONG		rgulAddressConnection[BPC_MIN_DIMENSION];

} NDIS_BPC_DEVICE_SETTINGS, *PNDIS_BPC_DEVICE_SETTINGS;

#define	CbDeviceSettings(cnt) (FIELD_OFFSET(NDIS_BPC_DEVICE_SETTINGS, rgulAddressConnection) + (cnt) * sizeof(ULONG))


//
// BPC Connection State Definitions
// (ie Acceptable values for ulState)
//
#define	BPC_CONNECT_STATE_UNCOMMITTED	0
#define	BPC_CONNECT_STATE_QUEUED		1
#define	BPC_CONNECT_STATE_ACTIVE		2
#define	BPC_CONNECT_STATE_DISCONNECTING	3


//
// BPC Connections Status Structure
//
typedef	struct NDIS_BPC_CONNECTION_STATUS
{
	BPC_HANDLE	nhConnection;
	BPC_HANDLE	nhDevice;
	ULONG		ulConnectPriority;
	ULONG		ulDisconnectPriority;
	ULONG		ulbpsAverage;
	ULONG		ulbpsBurst;
	ULONG		ulState;
	BOOLEAN		fEnabled;

} NDIS_BPC_CONNECTION_STATUS, *PNDIS_BPC_CONNECTION_STATUS;


//
// BPC Address Comparison Structure
//
typedef	struct NDIS_BPC_ADDRESS_COMPARE
{
	BOOLEAN	fEqual;
	ULONG	ulcbFirstOffset;
	ULONG	ulcbFirstLength;
	ULONG	ulcbSecondOffset;
	ULONG	ulcbSecondLength;

} NDIS_BPC_ADDRESS_COMPARE, *PNDIS_BPC_ADDRESS_COMPARE;


//
// BPC Program Guide Types
//
// Currently there are no Generic BPC Program Guide types.
//
#define	BPC_GUIDE_GENERIC_MIN	0x01000000
#define	BPC_GUIDE_GENERIC_MAX	0x01ffffff
#define	BPC_GUIDE_PROVIDER_MIN	0x02000000
#define	BPC_GUIDE_PROVIDER_MAX	0x02ffffff
#define	BPC_GUIDE_ADAPTER_MIN	0x03000000
#define	BPC_GUIDE_ADAPTER_MAX	0x03ffffff


//
// BPC Program Guide Structure
//
typedef	struct NDIS_BPC_PROGRAM_GUIDE
{
	ULONG		ulGuideType;
	BPC_FILETIME ftLastUpdate;
	ULONG		ulChangeNumber;
	ULONG		ulcbGuideSize;
	ULONG		rgulGuideData[BPC_MIN_DIMENSION];

} NDIS_BPC_PROGRAM_GUIDE, *PNDIS_BPC_PROGRAM_GUIDE;


//
// BPC Extension Errors
// (ie Acceptable values for ulBPCError)
//
typedef	enum _NDIS_BPC_ERROR
{
	bpcErrorUnknownFailure = 0xc0ff0000,
	bpcErrorHardwareFailure,
	bpcErrorProviderFailure,
	bpcErrorNoDataDevice,
	bpcErrorNoTuningDevice,
	bpcErrorDeviceNotCapable,
	bpcErrorConflictingDevice,
	bpcErrorConflictingCapability,
	bpcErrorNoBufferMemory,
	bpcErrorNoResources,
	bpcErrorAdapterClosing,
	bpcErrorConnectionClosing,
	bpcErrorTooComplex,
	bpcErrorProviderNotSupported,
	bpcErrorUnknownProviderStructure,
	bpcErrorAddressNotSupported,
	bpcErrorInvalidAddress,
	bpcErrorUnknownAdapterStructure
} NDIS_BPC_ERROR, *PNDIS_BPC_ERROR;


//
//	BPC	Last Error Structure
//
typedef	struct NDIS_BPC_LAST_ERROR
{
	ULONG		ulErrorContext;
	ULONG		ulBPCError;
	ULONG		ulAdapterError;
	ULONG		ulAdapterContext;

} NDIS_BPC_LAST_ERROR, *PNDIS_BPC_LAST_ERROR;


//
//	BPC	Buffer Pool Request/Report Structure
//
typedef	struct NDIS_BPC_POOL
{
	BPC_HANDLE	nhConnection;
	ULONG		ulcbPoolSize;
	ULONG		ulcbMaxBufferSize;
	ULONG		ulcbBufferReserved;

} NDIS_BPC_POOL, *PNDIS_BPC_POOL;


//
// BPC Provider and Adapter Specific Structures are defined in the
// BpcXXXX.H file which the Provider/Adapter Manufacturer supplies.
//

//
// BPC Connect Structure
//
typedef	struct NDIS_BPC_CONNECT
{
	BPC_HANDLE	nhConnection;
	BPC_HANDLE	nhDevice;
	ULONG		ulConnectPriority;
	ULONG		ulDisconnectPriority;
	BOOLEAN		fImmediate;
	ULONG		ulcbAddress;
	GUID		guidProvider;
	ULONG		rgulAddress[BPC_MIN_DIMENSION];

} NDIS_BPC_CONNECT, *PNDIS_BPC_CONNECT;

#define	CbConnect(cnt)	(FIELD_OFFSET(NDIS_BPC_CONNECT, rgulAddress) + (cnt) * sizeof(ULONG))


//
//	BPC	Commit Connections Structure
//
typedef	struct NDIS_BPC_COMMIT
{
	ULONG		ulcConnections;
	BPC_HANDLE	rgnhConnections[BPC_MIN_DIMENSION];

} NDIS_BPC_COMMIT, *PNDIS_BPC_COMMIT;


//
//	BPC	Disconnect Structure
//
typedef	struct NDIS_BPC_DISCONNECT
{
	BPC_HANDLE	nhConnection;

} NDIS_BPC_DISCONNECT, *PNDIS_BPC_DISCONNECT;


//
//	BPC	Enable Connection Structure
//
typedef	struct NDIS_BPC_CONNECTION_ENABLE
{
	BPC_HANDLE	nhConnection;
	BOOLEAN		fEnabled;

} NDIS_BPC_CONNECTION_ENABLE, *PNDIS_BPC_CONNECTION_ENABLE;


//
// BPC Pool Return Structure
//
typedef	struct NDIS_BPC_POOL_RETURN
{
	BPC_HANDLE	nhConnection;

} NDIS_BPC_POOL_RETURN, *PNDIS_BPC_POOL_RETURN;


typedef	struct NDIS_BPC_FORCE_RECEIVE
{
	BPC_HANDLE	nhConnection;
	ULONG		ulReasonCode;

} NDIS_BPC_FORCE_RECEIVE, *PNDIS_BPC_FORCE_RECEIVE;


//
//	BPC	Media Specific Information Structure
//
typedef	struct NDIS_BPC_MEDIA_SPECIFIC_INFORMATION
{
	BPC_HANDLE nhConnection;					// The handle to the data device.
	ULONG		ulBPCStreamType;				// The stream type of the data in packet
	ULONG		ulReasonCode;					// The reason the buffer was indicated
	PVOID		pvMiniportReserved1;
	ULONG		ulMiniportReserved2;

} NDIS_BPC_MEDIA_SPECIFIC_INFORMATION, *PNDIS_BPC_MEDIA_SPECIFIC_INFORMATION;


//
// BPC Status Categories
//
#define	BPC_CATEGORY_BPC			0x01000000
#define	BPC_CATEGORY_PROVIDER		0x02000000
#define	BPC_CATEGORY_ADAPTER		0x03000000


//
// BPC Status Types for Category BPC_CATEGORY_BPC
//
#define	BPC_STATUS_CONNECTED		0x00000001
#define	BPC_STATUS_QUEUED			0x00000002
#define	BPC_STATUS_ACTIVE			0x00000003
#define	BPC_STATUS_DISCONNECTED		0x00000004
#define	BPC_STATUS_OVERFLOW			0x00000005
#define	BPC_STATUS_DATA_STOP		0x00000006
#define	BPC_STATUS_DATA_START		0x00000007
#define	BPC_STATUS_DATA_ERROR		0x00000008


//
// BPC Status Indication Structure
//
typedef	struct NDIS_BPC_STATUS
{
	ULONG ulStatusCategory;
	ULONG ulStatusType;
	ULONG ulcbStatus;
	ULONG rgulStatus;
} NDIS_BPC_STATUS, *PNDIS_BPC_STATUS;


//
// BPC Connection Status Structure
//
// All BPC Generic Connection Status package this structure
// in rgulStatus to indicate to which connection and device
// the status pertains.
//
typedef	struct NDIS_BPC_STATUS_CONNECTION
{
	BPC_HANDLE	nhConnection;
	BPC_HANDLE nhDevice;

} NDIS_BPC_STATUS_CONNECTED, *PNDIS_BPC_STATUS_CONNECTED;

#ifdef __cplusplus
}
#endif

#endif // _NTDDNDIS_





=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddmou.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddmou.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the mouse device.

Author:

    Lee A. Smith (lees) 02-Aug-1991.

Revision History:

--*/

#ifndef _NTDDMOU_
#define _NTDDMOU_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_MOUSE_DEVICE_NAME    "\\Device\\PointerClass"
#define DD_MOUSE_DEVICE_NAME_U L"\\Device\\PointerClass"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_MOUSE_QUERY_ATTRIBUTES CTL_CODE(FILE_DEVICE_MOUSE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUSE_INSERT_DATA      CTL_CODE(FILE_DEVICE_MOUSE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Declair the GUID that represents the device interface for mice.
//

#ifndef FAR
#define FAR
#endif

DEFINE_GUID( GUID_CLASS_MOUSE, 0x378de44c, 0x56ef, 0x11d1,
             0xbc, 0x8c, 0x00, 0xa0, 0xc9, 0x14, 0x05, 0xdd );

//
// NtReadFile Output Buffer record structures for this device.
//

typedef struct _MOUSE_INPUT_DATA {

    //
    // Unit number.  E.g., for \Device\PointerPort0  the unit is '0',
    // for \Device\PointerPort1 the unit is '1', and so on.
    //

    USHORT UnitId;

    //
    // Indicator flags.
    //

    USHORT Flags;

    //
    // The transition state of the mouse buttons.
    //

    union {
        ULONG Buttons;
        struct  {
            USHORT  ButtonFlags;
            USHORT  ButtonData;
        };
    };


    //
    // The raw state of the mouse buttons.
    //

    ULONG RawButtons;

    //
    // The signed relative or absolute motion in the X direction.
    //

    LONG LastX;

    //
    // The signed relative or absolute motion in the Y direction.
    //

    LONG LastY;

    //
    // Device-specific additional information for the event.
    //

    ULONG ExtraInformation;

} MOUSE_INPUT_DATA, *PMOUSE_INPUT_DATA;

//
// Define the mouse button state indicators.
//

#define MOUSE_LEFT_BUTTON_DOWN   0x0001  // Left Button changed to down.
#define MOUSE_LEFT_BUTTON_UP     0x0002  // Left Button changed to up.
#define MOUSE_RIGHT_BUTTON_DOWN  0x0004  // Right Button changed to down.
#define MOUSE_RIGHT_BUTTON_UP    0x0008  // Right Button changed to up.
#define MOUSE_MIDDLE_BUTTON_DOWN 0x0010  // Middle Button changed to down.
#define MOUSE_MIDDLE_BUTTON_UP   0x0020  // Middle Button changed to up.

#define MOUSE_BUTTON_1_DOWN     MOUSE_LEFT_BUTTON_DOWN
#define MOUSE_BUTTON_1_UP       MOUSE_LEFT_BUTTON_UP
#define MOUSE_BUTTON_2_DOWN     MOUSE_RIGHT_BUTTON_DOWN
#define MOUSE_BUTTON_2_UP       MOUSE_RIGHT_BUTTON_UP
#define MOUSE_BUTTON_3_DOWN     MOUSE_MIDDLE_BUTTON_DOWN
#define MOUSE_BUTTON_3_UP       MOUSE_MIDDLE_BUTTON_UP

#define MOUSE_BUTTON_4_DOWN     0x0040
#define MOUSE_BUTTON_4_UP       0x0080
#define MOUSE_BUTTON_5_DOWN     0x0100
#define MOUSE_BUTTON_5_UP       0x0200

#define MOUSE_WHEEL             0x0400

//
// Define the mouse indicator flags.
//

#define MOUSE_MOVE_RELATIVE         0
#define MOUSE_MOVE_ABSOLUTE         1
#define MOUSE_VIRTUAL_DESKTOP    0x02  // the coordinates are mapped to the virtual desktop
#define MOUSE_ATTRIBUTES_CHANGED 0x04  // requery for mouse attributes

//
// NtDeviceIoControlFile OutputBuffer record structures for
// IOCTL_MOUSE_QUERY_ATTRIBUTES.
//

typedef struct _MOUSE_ATTRIBUTES {

    //
    // Mouse ID value.  Used to distinguish between mouse types.
    //

    USHORT MouseIdentifier;

    //
    // Number of buttons located on the mouse.
    //

    USHORT NumberOfButtons;

    //
    // Specifies the rate at which the hardware reports mouse input
    // (reports per second).  This may not be applicable for every mouse device.
    //

    USHORT SampleRate;

    //
    // Length of the readahead buffer, in bytes.
    //

    ULONG  InputDataQueueLength;

} MOUSE_ATTRIBUTES, *PMOUSE_ATTRIBUTES;

//
// Define the mouse identifier types.
//

#define MOUSE_INPORT_HARDWARE       0x0001
#define MOUSE_I8042_HARDWARE        0x0002
#define MOUSE_SERIAL_HARDWARE       0x0004
#define BALLPOINT_I8042_HARDWARE    0x0008
#define BALLPOINT_SERIAL_HARDWARE   0x0010
#define WHEELMOUSE_I8042_HARDWARE   0x0020
#define WHEELMOUSE_SERIAL_HARDWARE  0x0040
#define MOUSE_HID_HARDWARE          0x0080
#define WHEELMOUSE_HID_HARDWARE     0x0100


//
// Generic NtDeviceIoControlFile Input Buffer record structure for
// various mouse IOCTLs.
//

typedef struct _MOUSE_UNIT_ID_PARAMETER {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

} MOUSE_UNIT_ID_PARAMETER, *PMOUSE_UNIT_ID_PARAMETER;

//
// Define the base values for the mouse error log packet's
// UniqueErrorValue field.
//

#define MOUSE_ERROR_VALUE_BASE        20000

#ifdef __cplusplus
}
#endif

#endif // _NTDDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddmup.h ===
/*++ BUILD Version: 0001    // Increent this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddmup.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Multiple UNC prodiver system device.

Author:

    Manny Weiser (mannyw) 27-Dec-1991

Revision History:

--*/

#ifndef _NTDDMUP_
#define _NTDDMUP_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
//

#define DD_MUP_DEVICE_NAME L"\\Device\\Mup"    // ntifs

//
// NtFsControlFile FsControlCode values for this device.
//

#define FSCTL_MUP_REGISTER_UNC_PROVIDER     CTL_CODE(FILE_DEVICE_MULTI_UNC_PROVIDER, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Fs control parameter blocks.
//

typedef struct _REDIRECTOR_REGISTRATION {
    ULONG DeviceNameOffset;
    ULONG DeviceNameLength;
    ULONG ShortNameOffset;
    ULONG ShortNameLength;
    BOOLEAN MailslotsSupported;
    // PWCH DeviceName[];
    // PWCH ShortName[];
} REDIRECTOR_REGISTRATION, *PREDIRECTOR_REGISTRATION;


//!!! Move to redir
//
// NtDeviceIoControlFile calls to the redirector
//
// begin_ntifs

#define IOCTL_REDIR_QUERY_PATH              CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 99, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _QUERY_PATH_REQUEST {
    ULONG PathNameLength;
    PIO_SECURITY_CONTEXT SecurityContext;
    WCHAR FilePathName[1];
} QUERY_PATH_REQUEST, *PQUERY_PATH_REQUEST;

typedef struct _QUERY_PATH_RESPONSE {
    ULONG LengthAccepted;
} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;

// end_ntifs

#ifdef __cplusplus
}
#endif

#endif  // _NTDDMUP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddmodm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    ntddmodm.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the modem device.

Author:

    Tony Ercolano (tonye) 14-Jul-1995

Revision History:

--*/

#ifndef _NTDDMODM_
#define _NTDDMODM_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//

#define IOCTL_MODEM_GET_PASSTHROUGH      CTL_CODE(FILE_DEVICE_MODEM, 1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MODEM_SET_PASSTHROUGH      CTL_CODE(FILE_DEVICE_MODEM, 2,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SET_DLE_MONITORING   CTL_CODE(FILE_DEVICE_MODEM, 3,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_GET_DLE              CTL_CODE(FILE_DEVICE_MODEM, 4,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SET_DLE_SHIELDING    CTL_CODE(FILE_DEVICE_MODEM, 5,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_STOP_WAVE_RECEIVE    CTL_CODE(FILE_DEVICE_MODEM, 6,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SEND_MESSAGE         CTL_CODE(FILE_DEVICE_MODEM, 7,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MODEM_GET_MESSAGE          CTL_CODE(FILE_DEVICE_MODEM, 8,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MODEM_SEND_GET_MESSAGE     CTL_CODE(FILE_DEVICE_MODEM, 9,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SEND_LOOPBACK_MESSAGE CTL_CODE(FILE_DEVICE_MODEM, 10,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_CHECK_FOR_MODEM      CTL_CODE(FILE_DEVICE_MODEM, 11,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SET_MIN_POWER        CTL_CODE(FILE_DEVICE_MODEM, 12,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_WATCH_FOR_RESUME     CTL_CODE(FILE_DEVICE_MODEM, 13,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_CANCEL_GET_SEND_MESSAGE    CTL_CODE(FILE_DEVICE_MODEM, 14,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SET_SERVER_STATE           CTL_CODE(FILE_DEVICE_MODEM, 15,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define MODEM_NOPASSTHROUGH 0x00000000U
#define MODEM_PASSTHROUGH   0x00000001U
#define MODEM_DCDSNIFF      0x00000002U
#define MODEM_NOPASSTHROUGH_INC_SESSION_COUNT 0x00000003U

#define MODEM_DLE_MONITORING_OFF  0x00000000
#define MODEM_DLE_MONITORING_ON   0x00000001

#define MODEM_DLE_SHIELDING_OFF   0x00000000
#define MODEM_DLE_SHIELDING_ON    0x00000001

#define MODEM_OPEN_TYPE_TSP       0
#define MODEM_OPEN_TYPE_CLIENT    1
#define MODEM_OPEN_TYPE_WAVE      2

typedef struct _MODEM_MESSAGE {

    ULONG    TotalSize;
    ULONG    Flags;
    ULONG    SessionId;
    ULONG    RequestId;
    ULONG    Reserved[2];

} MODEM_MESSAGE, *PMODEM_MESSAGE;

#ifdef DEFINE_GUID

DEFINE_GUID(GUID_CLASS_MODEM,0x2c7089aa, 0x2e0e,0x11d1,0xb1, 0x14, 0x00, 0xc0, 0x4f, 0xc2, 0xaa, 0xe4);

#endif //DEFINE_GUID

#ifdef __cplusplus
}
#endif

#endif  // _NTDDMODM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddmix.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntddmix.h

Abstract:

    This include file defines all constants and types for
    accessing a Windows NT sound mixer device.

Author:

    Robin Speed (RobinSp) - 14-Sep-1993

Revision History:

--*/

#ifndef _NTDDMIX_
#define _NTDDMIX_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntddsnd.h>    // general sound stuff

#ifdef __cplusplus
extern "C" {
#endif

#define IOCTL_MIX_BASE 0x0180

//
// Device Name - this string is the name of the device.  It is the name
// that when added to the name of the root of the device tree and with
// the device number appended, gives the name of the device required for
// a call to NtOpenFile.
// So for example, if the root is \Device and the Device type is
// MMMix and the device number is 2, the full name is \Device\MMMix2
//

#define DD_MIX_DEVICE_NAME     "\\Device\\MMMix"
#define DD_MIX_DEVICE_NAME_U  L"\\Device\\MMMix"

//
// Mixer device driver IOCTL set
// No caps call - the caps are dumped to the registry on load which saves
// some code and time.
//

#define IOCTL_MIX_GET_CONFIGURATION    CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIX_BASE + 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MIX_GET_CONTROL_DATA     CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIX_BASE + 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MIX_GET_LINE_DATA        CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIX_BASE + 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MIX_REQUEST_NOTIFY       CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIX_BASE + 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// mix structures
//

//
//  IOCTL_MIX_GET_LINE_DATA and
//  IOCTL_MIX_GET_CONTROL_DATA
//
//  Line structure (NB LineID is implicit from location in array)
//

typedef struct {
    ULONG     Id;                    // Either Line or control ID
} MIXER_DD_READ_DATA, *PMIXER_DD_READ_DATA;

//
//  Variable line data
//

typedef struct {
    ULONG     fdwLine;
} MIXER_DD_LINE_DATA;

typedef struct {
    UCHAR     Destination;           // Destination
    UCHAR     Source;                // Source (relative to destination)
    UCHAR     cChannels;
    UCHAR     cConnections;          // Redundant
    UCHAR     cControls;             // NB - redundant - could be deduced
                                     // from the control set.
    ULONG     dwUser;                // settable?
    SHORT     ShortNameStringId;
    SHORT     LongNameStringId;
    ULONG     dwComponentType;       // SRC and DEST types

    //
    //  Target information
    //

    USHORT    Type;
    USHORT    wPid;                  // No USHORT !!!
    SHORT     PnameStringId;         // Target product name


} MIXER_DD_LINE_CONFIGURATION_DATA, *PMIXER_DD_LINE_CONFIGURATION_DATA;

//
//  Control structure (NB Control ID is implicit from location in array)
//

typedef struct {
    ULONG     dwControlType;
    ULONG     fdwControl;
    UCHAR     LineID;
    UCHAR     cMultipleItems;
    SHORT     ShortNameStringId;
    SHORT     LongNameStringId;

    union
    {
        struct
        {
            LONG    lMinimum;           // signed minimum for this control
            LONG    lMaximum;           // signed maximum for this control
        };
        struct
        {
            ULONG   dwMinimum;          // unsigned minimum for this control
            ULONG   dwMaximum;          // unsigned maximum for this control
        };
        ULONG       dwReserved[6];
    } Bounds;
    union
    {
        ULONG       cSteps;             // # of steps between min & max
        ULONG       cbCustomData;       // size in bytes of custom data
        ULONG       dwReserved[6];      // !!! needed? we have cbStruct....
    } Metrics;

    ULONG     TextDataOffset;     // Offset to strings if any (or 0)
                                  // Each string is indexed by a string id.
} MIXER_DD_CONTROL_CONFIGURATION_DATA, *PMIXER_DD_CONTROL_CONFIGURATION_DATA;

typedef struct {
    ULONG     dwParam1;
    ULONG     dwParam2;
    SHORT     SubControlTextStringId;
    USHORT    ControlId;          // Debug cross reference.
} MIXER_DD_CONTROL_LISTTEXT, *PMIXER_DD_CONTROL_LISTTEXT;

//
//  Capabilities data (using string id)
//

typedef struct {
    USHORT          wMid;                   // manufacturer id
    USHORT          wPid;                   // product id
    MMVERSION       vDriverVersion;         // version of the driver
    ULONG           PnameStringId;          // product name
    ULONG           fdwSupport;             // misc. support bits
    ULONG           cDestinations;          // count of destinations
} MIXER_DD_CAPS;
//
//  The data dumped into the registry.
//  The two counts are followed immediately by the appropriate number of
//
//      MIXER_DD_LINE_CONFIGURATION_DATA  and
//
//      MIXER_DD_CONTROL_CONFIGURATION_DATA structures
//
//  Next is the set of
//
//      MIXER_DD_CONTROL_LISTTEXT structures ordered by control id.
//
//  The MIXER_DD_LINE_CONFIGURATION_DATA structures must be ordered
//  dest lines first (ie the destination lines have the lowest ids).
//  The source lines must be ordered so that their destination lines
//  either increase and stay the same - ie the sources for the first
//  destination are first etc etc.
//

typedef struct {
    ULONG         cbSize;             // Total size including this field
    MIXER_DD_CAPS DeviceCaps;         // Mixer device capabilities
    ULONG         NumberOfLines;
    ULONG         NumberOfControls;
} MIXER_DD_CONFIGURATION_DATA, *PMIXER_DD_CONFIGURATION_DATA;
//
//
// IOCTL_MIX_REQUEST_NOTIFY - use same data for input and output
// This request will continue to be completed until either
// SetCurrentLogicalTime is set or
//
//     CurrentLogicalTime = Logical time of last change to mixer
//     controls or lines.
//
// It will next be completed either when the device is closed or the
// next change is made to a control or line.
//

typedef struct {
    LARGE_INTEGER   CurrentLogicalTime; // Used by driver
    BOOLEAN         Initialized;        // Set to 0 on first use
    USHORT          Message;            // What sort of thing changed?
    USHORT          Id;                 // Id of thing that changed
} MIXER_DD_REQUEST_NOTIFY, *PMIXER_DD_REQUEST_NOTIFY;


//
// Data returned by IOCTL_MIX_GET_CAPABILITIES is MIXCAPSW structure
// defined in mmsystem.h
//

#ifdef __cplusplus
}
#endif

#endif // _NTDDMIX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddnfs.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    ntddnfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system device.

Author:

    Steve Wood (stevewo)     27-May-1990

Revision History:

    Larry Osterman (larryo)
    Rita Wong      (ritaw)   19-Feb-1991
    John Rogers    (JohnRo)  08-Mar-1991

--*/

#ifndef _NTDDNFS_
#define _NTDDNFS_

#if _MSC_VER > 1000
#pragma once
#endif

#include <windef.h>
#include <lmcons.h>
#include <lmwksta.h>
#include <ntmsv1_0.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//
//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_NFS2_DEVICE_NAME "\\Device\\FsWrap"
#define DD_NFS2_DEVICE_NAME_U L"\\Device\\FsWrap"

#define DD_NFS_DEVICE_NAME "\\Device\\LanmanRedirector"
#define DD_NFS_DEVICE_NAME_U L"\\Device\\LanmanRedirector"

//
// The file system name as returned by
// NtQueryInformationVolume(FileFsAttributeInformation)
//
#define DD_NFS_FILESYS_NAME "LMRDR"
#define DD_NFS_FILESYS_NAME_U L"LMRDR"

//
// EA Names for creating a tree connection
//
#define EA_NAME_CONNECT         "NoConnect"
#define EA_NAME_DOMAIN          "Domain"
#define EA_NAME_USERNAME        "UserName"
#define EA_NAME_PASSWORD        "Password"
#define EA_NAME_TYPE            "Type"
#define EA_NAME_TRANSPORT       "Transport"
#define EA_NAME_PRINCIPAL       "Principal"
#define EA_NAME_MRXCONTEXT      "MinirdrContext"
#define EA_NAME_CSCAGENT        "CscAgent"

#define EA_NAME_DOMAIN_U        L"Domain"
#define EA_NAME_USERNAME_U      L"UserName"
#define EA_NAME_PASSWORD_U      L"Password"
#define EA_NAME_TYPE_U          L"Type"
#define EA_NAME_TRANSPORT_U     L"Transport"
#define EA_NAME_PRINCIPAL_U  	L"Principal"
#define EA_NAME_MRXCONTEXT_U    L"MinirdrContext"
#define EA_NAME_CSCAGENT_U      L"CscAgent"

#define TRANSACTION_REQUEST     0x00000003

//
//  Redirector specific configuration options (separate from workstation
//  service configuration options)
//

#define RDR_CONFIG_PARAMETERS    L"Parameters"

#define RDR_CONFIG_USE_WRITEBHND    L"UseWriteBehind"
#define RDR_CONFIG_USE_ASYNC_WRITEBHND L"UseAsyncWriteBehind"
#define RDR_CONFIG_LOWER_SEARCH_THRESHOLD L"LowerSearchThreshold"
#define RDR_CONFIG_LOWER_SEARCH_BUFFSIZE  L"LowerSearchBufferSize"
#define RDR_CONFIG_UPPER_SEARCH_BUFFSIZE  L"UpperSearchBufferSize"
#define RDR_CONFIG_STACK_SIZE  L"StackSize"
#define RDR_CONFIG_CONNECT_TIMEOUT  L"ConnectMaxTimeout"
#define RDR_CONFIG_RAW_TIME_LIMIT  L"RawIoTimeLimit"
#define RDR_CONFIG_OS2_SESSION_LIMIT  L"Os2SessionLimit"
#define RDR_CONFIG_TURBO_MODE               L"TurboMode"

#define RDR_CONFIG_CURRENT_WINDOWS_VERSION L"\\REGISTRY\\Machine\\Software\\Microsoft\\Windows Nt\\CurrentVersion"
#define RDR_CONFIG_OPERATING_SYSTEM L"CurrentBuildNumber"
#define RDR_CONFIG_OPERATING_SYSTEM_VERSION L"CurrentVersion"
#define RDR_CONFIG_OPERATING_SYSTEM_NAME    L"Windows 2000 "

//
// NtDeviceIoControlFile/NtFsControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_RDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _RDR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_RDR_BASE, request, method, access)


#define FSCTL_LMR_START                  _RDR_CONTROL_CODE(100, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_LMR_STOP                   _RDR_CONTROL_CODE(101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_SET_CONFIG_INFO        _RDR_CONTROL_CODE(102, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_LMR_GET_CONFIG_INFO        _RDR_CONTROL_CODE(103, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_LMR_GET_CONNECTION_INFO    _RDR_CONTROL_CODE(104, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_LMR_ENUMERATE_CONNECTIONS  _RDR_CONTROL_CODE(105, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_LMR_GET_VERSIONS           _RDR_CONTROL_CODE(106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_DELETE_CONNECTION      _RDR_CONTROL_CODE(107, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_BIND_TO_TRANSPORT      _RDR_CONTROL_CODE(108, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_UNBIND_FROM_TRANSPORT  _RDR_CONTROL_CODE(109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_ENUMERATE_TRANSPORTS   _RDR_CONTROL_CODE(110, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_LMR_GET_HINT_SIZE          _RDR_CONTROL_CODE(113, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_TRANSACT               _RDR_CONTROL_CODE(114, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_ENUMERATE_PRINT_INFO   _RDR_CONTROL_CODE(115, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_GET_STATISTICS         _RDR_CONTROL_CODE(116, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_START_SMBTRACE         _RDR_CONTROL_CODE(117, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_END_SMBTRACE           _RDR_CONTROL_CODE(118, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_START_RBR              _RDR_CONTROL_CODE(119, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMR_SET_DOMAIN_NAME        _RDR_CONTROL_CODE(120, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// the following fsctl controlcodes are reserved for the fswrap device and minirdrs
//
#define FSCTL_FSWRAP_RESERVED_LOW         _RDR_CONTROL_CODE(200, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FSWRAP_RESERVED_HIGH        _RDR_CONTROL_CODE(219, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MINIRDR_RESERVED_LOW        _RDR_CONTROL_CODE(220, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MINIRDR_RESERVED_HIGH       _RDR_CONTROL_CODE(239, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// WARNING: codes from 240-255 are reserved, do not use them.
//

//
// Identifies the data structure type for Buffer 2 of each FSCtl
//
typedef enum {
    ConfigInformation,                  // FSCTL_LMR_START,
                                        // FSCTL_LMR_SET_CONFIG_INFO,
                                        // FSCTL_LMR_GET_CONFIG_INFO
                                        //  (structure found in wksta.h)

    GetConnectionInfo,                  // FSCTL_LMR_ENUMERATE_CONNECTIONS,
                                        // FSCTL_LMR_GET_CONNECTION_INFO
    EnumerateTransports                 // FSCTL_LMR_ENUMERATE_TRANSPORTS
                                        //  (structure found in wksta.h)
} FSCTL_LMR_STRUCTURES;

//
// LAN Man Redirector Request Packet used by the Workstation service
// to pass parameters to the Redirector through Buffer 1 of
// NtFsControlFile.
//
// Additional input or output of each FSCtl is found in Buffer 2.
//

#define REQUEST_PACKET_VERSION  0x00000006L // Structure version.

typedef struct _LMR_REQUEST_PACKET {

    FSCTL_LMR_STRUCTURES Type;          // Type of structure in Buffer 2
    ULONG Version;                      // Version of structure in Buffer 2
    ULONG Level;                        // Level of information of force level
    LUID LogonId;                       // User logon session identifier

    union {

        struct {
            ULONG RedirectorNameLength; // Length of computer name.
            ULONG DomainNameLength;     // Length of primary domain name.
            WCHAR RedirectorName[1];    // Computer name (NOT null terminated)
//            WCHAR DomainName[1];      // Domain name - After computer name.
        } Start;                        // IN

        struct {
            ULONG EntriesRead;          // Number of entries returned
            ULONG TotalEntries;         // Total entries available
            ULONG TotalBytesNeeded;     // Total bytes needed to read all entries
            ULONG ResumeHandle;         // Resume handle.
        } Get;                          // OUT

        struct {
            ULONG WkstaParameter;       // Specifies the entire structure or a
                                        //     field to set on input; if any
                                        //     field is invalid, specifies the
                                        //     one at fault on output.
        } Set;                          // IN OUT

        struct {
            ULONG RedirectorVersion;    // Version of the Redirector
            ULONG RedirectorPlatform;   // Redirector platform base number
            ULONG MajorVersion;         // LAN Man major version number
            ULONG MinorVersion;         // LAN Man minor version number
        } GetVersion;                   // OUT

        struct {
            ULONG WkstaParameter;       // Specifies the parameter at fault
                                        //     if a parameter is invalid  OUT
            ULONG QualityOfService;     // Quality of service indicator   IN
            ULONG TransportNameLength;  // not including terminator       IN
            WCHAR TransportName[1];     // Name of transport provider     IN
        } Bind;

        struct {
            ULONG TransportNameLength;  // not including terminator
            WCHAR TransportName[1];     // Name of transport provider
        } Unbind;                       // IN

        struct {
            ULONG ConnectionsHint;      // Number of bytes needed for buffer
                                        //   to enumerate tree connections
            ULONG TransportsHint;       // Number of bytes needed for buffer
                                        //   to enumerate transports
        } GetHintSize;                  // OUT

        struct {
            ULONG Index;                // Entry in the queue to return, 0 on
                                        // first call, value of RestartIndex on
                                        // subsequent calls.
        } GetPrintQueue;                // IN

    } Parameters;

} LMR_REQUEST_PACKET, *PLMR_REQUEST_PACKET;

//
// Mask bits for use with Parameters.GetConnectionInfo.Capabilities:
//

#define CAPABILITY_CASE_SENSITIVE_PASSWDS       0x00000001L
#define CAPABILITY_REMOTE_ADMIN_PROTOCOL        0x00000002L
#define CAPABILITY_RPC                          0x00000004L
#define CAPABILITY_SAM_PROTOCOL                 0x00000008L
#define CAPABILITY_UNICODE                      0x00000010L

//
//  Output buffer structure of FSCTL_LMR_ENUMERATE_CONNECTIONS used
//  to implement NetUseEnum.  The returned data is actually an array
//  of this structure.
//

typedef struct _LMR_CONNECTION_INFO_0 {
    UNICODE_STRING UNCName;             // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.
}  LMR_CONNECTION_INFO_0, *PLMR_CONNECTION_INFO_0;

typedef struct _LMR_CONNECTION_INFO_1 {
    UNICODE_STRING UNCName;             // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.

    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ConnectionStatus;             // Status of the connection
    ULONG NumberFilesOpen;              // Number of opened files
} LMR_CONNECTION_INFO_1, *PLMR_CONNECTION_INFO_1;

typedef struct _LMR_CONNECTION_INFO_2 {
    UNICODE_STRING UNCName;             // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.
    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ConnectionStatus;             // Status of the connection
    ULONG NumberFilesOpen;              // Number of opened files

    UNICODE_STRING UserName;            // User who created connection.
    UNICODE_STRING DomainName;          // Domain of user who created connection.
    ULONG Capabilities;                 // Bit mask of remote abilities.
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH]; // User session key
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH]; // Lanman session key
}  LMR_CONNECTION_INFO_2, *PLMR_CONNECTION_INFO_2;

typedef struct _LMR_CONNECTION_INFO_3 {
    UNICODE_STRING UNCName;             // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.
    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ConnectionStatus;             // Status of the connection
    ULONG NumberFilesOpen;              // Number of opened files

    UNICODE_STRING UserName;            // User who created connection.
    UNICODE_STRING DomainName;          // Domain of user who created connection.
    ULONG Capabilities;                 // Bit mask of remote abilities.
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH]; // User session key
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH]; // Lanman session key
    UNICODE_STRING TransportName;       // Transport connection is active on
    ULONG   Throughput;                 // Throughput of connection.
    ULONG   Delay;                      // Small packet overhead.
    LARGE_INTEGER TimeZoneBias;         // Time zone delta in 100ns units.
    BOOL    IsSpecialIpcConnection;     // True IFF there is a special IPC connection active.
    BOOL    Reliable;                   // True iff the connection is reliable
    BOOL    ReadAhead;                  // True iff readahead is active on connection.
    BOOL    Core;
    BOOL    MsNet103;
    BOOL    Lanman10;
    BOOL    WindowsForWorkgroups;
    BOOL    Lanman20;
    BOOL    Lanman21;
    BOOL    WindowsNt;
    BOOL    MixedCasePasswords;
    BOOL    MixedCaseFiles;
    BOOL    LongNames;
    BOOL    ExtendedNegotiateResponse;
    BOOL    LockAndRead;
    BOOL    NtSecurity;
    BOOL    SupportsEa;
    BOOL    NtNegotiateResponse;
    BOOL    CancelSupport;
    BOOL    UnicodeStrings;
    BOOL    LargeFiles;
    BOOL    NtSmbs;
    BOOL    RpcRemoteAdmin;
    BOOL    NtStatusCodes;
    BOOL    LevelIIOplock;
    BOOL    UtcTime;
    BOOL    UserSecurity;
    BOOL    EncryptsPasswords;
}  LMR_CONNECTION_INFO_3, *PLMR_CONNECTION_INFO_3;

#define TRANSACTION_VERSION     0x00000002L     // Structure version.
typedef struct _LMR_TRANSACTION {
    ULONG       Type;                   // Type of structure
    ULONG       Size;                   // Size of fixed portion of structure
    ULONG       Version;                // Structure version.
    ULONG       NameLength;             // Number of bytes in name (in path
                                        // format, e.g., \server\pipe\netapi\4)
    ULONG       NameOffset;             // Offset of name in buffer.
    BOOLEAN     ResponseExpected;       // Should remote system respond?
    ULONG       Timeout;                // Timeout time in milliseconds.
    ULONG       SetupWords;             // Number of trans setup words (may be
                                        // 0).  (setup words are input/output.)
    ULONG       SetupOffset;            // Offset of setup (may be 0 for none).
    ULONG       MaxSetup;               // Size of setup word array (may be 0).
    ULONG       ParmLength;             // Input param area length (may be 0).
    PVOID       ParmPtr;                // Input parameter area (may be NULL).
    ULONG       MaxRetParmLength;       // Output param. area length (may be 0).
    ULONG       DataLength;             // Input data area length (may be 0).
    PVOID       DataPtr;                // Input data area (may be NULL).
    ULONG       MaxRetDataLength;       // Output data area length (may be 0).
    PVOID       RetDataPtr;             // Output data area (may be NULL).
} LMR_TRANSACTION, *PLMR_TRANSACTION;


//
//  Output buffer structure of FSCTL_LMR_ENUMERATE_PRINT_INFO used
//  to implement DosPrintQEnum to down level servers. Caller must supply
//  a buffer at least sizeof( LMR_GET_PRINT_QUEUE ) + UNLEN
//

typedef struct _LMR_GET_PRINT_QUEUE {
    ANSI_STRING OriginatorName;         // Name of user that did print
    LARGE_INTEGER CreateTime;           // When file was created
    ULONG EntryStatus;                  // Held/Printing etc.
    ULONG FileNumber;                   // Spool file number from create
                                        // print request.
    ULONG FileSize;
    ULONG RestartIndex;                 // Index of the next entry in queue
                                        // note this is not last index+1
                                        // either a value of 0 or an error
                                        // indicates end-of-queue

}  LMR_GET_PRINT_QUEUE, *PLMR_GET_PRINT_QUEUE;

//
// NB: The following structure is STAT_WORKSTATION_0 in sdk\inc\lmstats.h. If
//     you change the structure, change it in both places
//

typedef struct _REDIR_STATISTICS {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   SmbsReceived;
    LARGE_INTEGER   PagingReadBytesRequested;
    LARGE_INTEGER   NonPagingReadBytesRequested;
    LARGE_INTEGER   CacheReadBytesRequested;
    LARGE_INTEGER   NetworkReadBytesRequested;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   SmbsTransmitted;
    LARGE_INTEGER   PagingWriteBytesRequested;
    LARGE_INTEGER   NonPagingWriteBytesRequested;
    LARGE_INTEGER   CacheWriteBytesRequested;
    LARGE_INTEGER   NetworkWriteBytesRequested;

    ULONG           InitiallyFailedOperations;
    ULONG           FailedCompletionOperations;

    ULONG           ReadOperations;
    ULONG           RandomReadOperations;
    ULONG           ReadSmbs;
    ULONG           LargeReadSmbs;
    ULONG           SmallReadSmbs;

    ULONG           WriteOperations;
    ULONG           RandomWriteOperations;
    ULONG           WriteSmbs;
    ULONG           LargeWriteSmbs;
    ULONG           SmallWriteSmbs;

    ULONG           RawReadsDenied;
    ULONG           RawWritesDenied;

    ULONG           NetworkErrors;

    //  Connection/Session counts
    ULONG           Sessions;
    ULONG           FailedSessions;
    ULONG           Reconnects;
    ULONG           CoreConnects;
    ULONG           Lanman20Connects;
    ULONG           Lanman21Connects;
    ULONG           LanmanNtConnects;
    ULONG           ServerDisconnects;
    ULONG           HungSessions;
    ULONG           UseCount;
    ULONG           FailedUseCount;

    //
    //  Queue Lengths (updates protected by RdrMpxTableSpinLock NOT
    //  RdrStatisticsSpinlock)
    //

    ULONG           CurrentCommands;
} REDIR_STATISTICS, *PREDIR_STATISTICS;

#ifdef __cplusplus
}
#endif

#endif  // ifndef _NTDDNFS_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddnetd.h ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntddnetd.h

Abstract:

    Header file for Netcard Detection DLLs

Author:

    Sean Selitrennikoff (SeanSe) December 1992

Revision History:

--*/

#ifndef _NTDDNETD_
#define _NTDDNETD_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Routines for Detection DLLs.
//


NTSTATUS
__stdcall
NDetCheckPortUsage(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG Port,
    IN  ULONG Length
    );

NTSTATUS
__stdcall
NDetReadPortUchar(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG Port,
    OUT PUCHAR Value
    );

NTSTATUS
__stdcall
NDetReadPortUshort(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG Port,
    OUT PUSHORT Value
    );

NTSTATUS
__stdcall
NDetReadPortUlong(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG Port,
    OUT PULONG Value
    );

NTSTATUS
__stdcall
NDetWritePortUchar(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG Port,
    IN  UCHAR Value
    );

NTSTATUS
__stdcall
NDetWritePortUshort(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG Port,
    IN  USHORT Value
    );

NTSTATUS
__stdcall
NDetWritePortUlong(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG Port,
    IN  ULONG Value
    );

NTSTATUS
__stdcall
NDetCheckMemoryUsage(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG BaseAddress,
    IN  ULONG Length
    );

NTSTATUS
__stdcall
NDetReadMappedMemory(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG BaseAddress,
    IN  ULONG Length,
    OUT PVOID Data
    );

NTSTATUS
__stdcall
NDetWriteMappedMemory(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    IN  ULONG BaseAddress,
    IN  ULONG Length,
    IN  PVOID Data
    );

NTSTATUS
__stdcall
NDetSetInterruptTrap(
    IN  INTERFACE_TYPE InterfaceType,
    IN  ULONG BusNumber,
    OUT PHANDLE TrapHandle,
    IN  UCHAR InterruptList[],
    IN  ULONG InterruptListLength
    );

NTSTATUS
__stdcall
NDetQueryInterruptTrap(
    IN  HANDLE TrapHandle,
    OUT UCHAR InterruptList[],
    IN  ULONG InterruptListLength
    );

NTSTATUS
__stdcall
NDetRemoveInterruptTrap(
    IN  HANDLE TrapHandle
    );

NTSTATUS
__stdcall
NDetReadEisaSlotInformation(
    IN  ULONG   BusNumber,
    IN  ULONG   SlotNumber,
    IN  ULONG   Length,
    OUT PVOID   Data
    );

NTSTATUS
__stdcall
NDetReadMcaSlotInformation(
    IN  ULONG   BusNumber,
    IN  ULONG   SlotNumber,
    IN  ULONG   Length,
    OUT PVOID   Data
    );

typedef struct _NETDTECT_DMA_STATUS {

    ULONG   CurrentCount;

} NETDTECT_DMA_STATUS, *PNETDTECT_DMA_STATUS;

NTSTATUS
__stdcall
NDetAllocateDmaChannel(
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG DmaChannel,
    OUT PHANDLE DmaHandle
    );

NTSTATUS
__stdcall
NDetBeginDmaTransfer(
    IN HANDLE DmaHandle,
    IN ULONG TransferLength,
    IN BOOLEAN WriteToDevice,
    IN UCHAR FillValue OPTIONAL
    );

NTSTATUS
__stdcall
NDetEndDmaTransfer(
    IN HANDLE DmaHandle
    );

NTSTATUS
__stdcall
NDetQueryDmaChannel(
    IN HANDLE DmaHandle,
    OUT PNETDTECT_DMA_STATUS DmaStatus
    );

NTSTATUS
__stdcall
NDetFreeDmaChannel(
    IN HANDLE DmaHandle
    );


//
// Resource information for Detection DLLs
//

#define NETDTECT_IRQ_RESOURCE    1
#define NETDTECT_MEMORY_RESOURCE 2
#define NETDTECT_PORT_RESOURCE   3
#define NETDTECT_DMA_RESOURCE    4

#define NETDTECT_IRQ_RESOURCE_LEVEL_SENSITIVE CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE
#define NETDTECT_IRQ_RESOURCE_LATCHED CM_RESOURCE_INTERRUPT_LATCHED

typedef struct _NETDTECT_RESOURCE {

    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    ULONG Type;
    ULONG Value;
    ULONG Length;
    ULONG Flags;

} NETDTECT_RESOURCE, *PNETDTECT_RESOURCE;

NTSTATUS
__stdcall
NDetTemporaryClaimResource(
    IN  PNETDTECT_RESOURCE Resource
    );

NTSTATUS
__stdcall
NDetFreeTemporaryResources(
    );

NTSTATUS
__stdcall
NDetFreeSpecificTemporaryResource(
    IN  PNETDTECT_RESOURCE  Resource
    );

#ifdef __cplusplus
}
#endif

#endif  // _NTDDNETD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddnpfs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddnpfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Named pipe file system device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDNPFS_
#define _NTDDNPFS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_NPFS_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_NPFS_BASE                 FILE_DEVICE_NAMED_PIPE


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#ifdef __cplusplus
}
#endif

#endif  // _NTDDNPFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddnull.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddnull.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Null device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDNULL_
#define _NTDDNULL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_NULL_DEVICE_NAME "\\Device\\Null"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_NULL_BASE                 FILE_DEVICE_NULL


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#ifdef __cplusplus
}
#endif

#endif  // _NTDDNULL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddpar.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddpar.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Parallel device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

//
// Interface GUID
//
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddpar.h>  in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddpar.h>  in that source file a second time to instantiate the GUIDs
//
// #ifdef WANT_WDM
#ifndef FAR
#define FAR
#endif

#ifdef DEFINE_GUID
DEFINE_GUID(GUID_PARALLEL_DEVICE, 0x97F76EF0, 0xF883, 0x11D0, 0xAF, 0x1F, 0x00, 0x00, 0xF8, 0x00, 0x84, 0x5C);
DEFINE_GUID(GUID_PARCLASS_DEVICE, 0x811FC6A5, 0xF728, 0x11D0, 0xA5, 0x37, 0x00, 0x00, 0xF8, 0x75, 0x3E, 0xD1);
#endif
// #endif

#ifndef _NTDDPAR_
#define _NTDDPAR_

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_PAR_BASE                  FILE_DEVICE_PARALLEL_PORT
#define IOCTL_PAR_QUERY_INFORMATION     CTL_CODE(FILE_DEVICE_PARALLEL_PORT,1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_INFORMATION       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,2,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Returns NULL terminated device ID string
//
#define IOCTL_PAR_QUERY_DEVICE_ID       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,3,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Returns buffer size required for a call to IOCTL_PAR_QUERY_DEVICE_ID 
//   to succeed. This includes device ID size plus space for terminating NULL.
//
#define IOCTL_PAR_QUERY_DEVICE_ID_SIZE  CTL_CODE(FILE_DEVICE_PARALLEL_PORT,4,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_IEEE1284_GET_MODE         CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IEEE1284_NEGOTIATE        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_WRITE_ADDRESS     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_READ_ADDRESS      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_DEVICE_CAPS       CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_DEFAULT_MODES     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_PING                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Similar to IOCTL_PAR_QUERY_DEVICE_ID above, but includes (i.e., does 
//   not discard) the two byte size prefix returned by the device.
//
#define IOCTL_PAR_QUERY_RAW_DEVICE_ID   CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_ECP_HOST_RECOVERY     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_READ_ADDRESS      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_WRITE_ADDRESS     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PAR_TEST                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_IS_PORT_FREE          CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

typedef struct _PAR_QUERY_INFORMATION{
       UCHAR Status;
} PAR_QUERY_INFORMATION, *PPAR_QUERY_INFORMATION;

typedef struct _PAR_SET_INFORMATION{
       UCHAR Init;
} PAR_SET_INFORMATION, *PPAR_SET_INFORMATION;

#define PARALLEL_INIT            0x1
#define PARALLEL_AUTOFEED        0x2
#define PARALLEL_PAPER_EMPTY     0x4
#define PARALLEL_OFF_LINE        0x8
#define PARALLEL_POWER_OFF       0x10
#define PARALLEL_NOT_CONNECTED   0x20
#define PARALLEL_BUSY            0x40
#define PARALLEL_SELECTED        0x80

//
// This is the structure returned by IOCTL_PAR_QUERY_DEVICE_ID_SIZE.
//

typedef struct _PAR_DEVICE_ID_SIZE_INFORMATION {
    ULONG   DeviceIdSize;
} PAR_DEVICE_ID_SIZE_INFORMATION, *PPAR_DEVICE_ID_SIZE_INFORMATION;


//
// These constants are used to construct the mask for the negotiation IOCTL.
// These need to be moved to ntddpar.h so that they are available to User Mode...
// IOCTL_INTERNAL_IEEE1284_NEGOTIATE.
//

typedef struct _PARCLASS_NEGOTIATION_MASK {
	USHORT      usReadMask;
	USHORT      usWriteMask;
} PARCLASS_NEGOTIATION_MASK, *PPARCLASS_NEGOTIATION_MASK;

#define NONE                0x0000
#define CENTRONICS          0x0001       /* Write Only */
#define IEEE_COMPATIBILITY  0x0002       /* Write Only */
#define NIBBLE              0x0004       /* Read Only */
#define CHANNEL_NIBBLE      0x0008       /* Read Only */
#define BYTE_BIDIR          0x0010       /* Read Only */
#define EPP_HW              0x0020
#define EPP_SW              0x0040
#define EPP_ANY             0x0060
#define BOUNDED_ECP         0x0080
#define ECP_HW_NOIRQ        0x0100      /* HWECP PIO */
#define ECP_HW_IRQ          0x0200      /* HWECP with IRQ */
#define ECP_SW              0x0400
#define ECP_ANY             0x0780

#ifdef __cplusplus
}
#endif

#endif  // _NTDDPAR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddpsch.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ntddpsch.h

Abstract:

    defines that are exported to user mode

Author:

Revision History:

--*/

#ifndef _NTDDPSCH_
#define _NTDDPSCH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// flow data returned in the Stats structure
//

#pragma pack(1)
typedef struct _PS_COMPONENT_STATS {

#define PS_COMPONENT_ADAPTER        1
#define PS_COMPONENT_FLOW           2
#define PS_COMPONENT_CONFORMER      3
#define PS_COMPONENT_SHAPER         4
#define PS_COMPONENT_DRRSEQ         5

    ULONG Type;
    ULONG Length;
    UCHAR Stats[1];
} PS_COMPONENT_STATS, *PPS_COMPONENT_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_CONFORMER_STATS {
    ULONG NonconformingPacketsScheduled;
} PS_CONFORMER_STATS, *PPS_CONFORMER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_SHAPER_STATS {
    ULONG MaxPacketsInShaper;
    ULONG AveragePacketsInShaper;
} PS_SHAPER_STATS, *PPS_SHAPER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_DRRSEQ_STATS {
    ULONG MaxPacketsInNetcard;
    ULONG AveragePacketsInNetcard;
    ULONG MaxPacketsInSequencer;
    ULONG AveragePacketsInSequencer;
    ULONG NonconformingPacketsTransmitted;
} PS_DRRSEQ_STATS, *PPS_DRRSEQ_STATS;
#pragma pack()


#pragma pack(1)
typedef struct _PS_FLOW_STATS {

    ULONG DroppedPackets;
    ULONG PacketsScheduled;
	ULONG PacketsTransmitted;
    LARGE_INTEGER BytesScheduled;
    LARGE_INTEGER BytesTransmitted;
} PS_FLOW_STATS, *PPS_FLOW_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_ADAPTER_STATS {

    //
    // OutOfPackets is incremented when no packets for sending/receive packet
    // indications are available.
    //

    ULONG OutOfPackets;

    //
    // general flow stats
    //

    ULONG FlowsOpened;
    ULONG FlowsClosed;
    ULONG FlowsRejected;
    ULONG FlowsModified;
    ULONG FlowModsRejected;
    ULONG MaxSimultaneousFlows;

} PS_ADAPTER_STATS, *PPS_ADAPTER_STATS;
#pragma pack()

//
// Defines that can be used for OID_QOS_FLOW_MODE
//
#define ADAPTER_FLOW_MODE_DIFFSERV           1
#define ADAPTER_FLOW_MODE_STANDARD           2


#ifdef __cplusplus
}
#endif

#endif /* _NTDDPSCH_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddrdr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    ntddrdr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing a network redirector device.

Author:

    Manny Weiser (mannyw)     27-Jun-1993

Revision History:

--*/

#ifndef _NTDDRDR_
#define _NTDDRDR_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define RDR_SERVER_LENGTH   80
#define RDR_QUEUE_LENGTH    80

//
// NtDeviceIoControlFile/NtFsControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_REDIR_BASE                 FILE_DEVICE_NETWORK_REDIRECTOR

#define _REDIR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_REDIR_BASE, request, method, access)

#define FSCTL_GET_PRINT_ID           _REDIR_CONTROL_CODE(1, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _QUERY_PRINT_JOB_INFO {
    ULONG       JobId;                           // Print job ID
    WCHAR       ServerName[RDR_SERVER_LENGTH+1]; // Server name
    WCHAR       QueueName[RDR_QUEUE_LENGTH+1];   // Queue name.
} QUERY_PRINT_JOB_INFO, *PQUERY_PRINT_JOB_INFO;

#ifdef __cplusplus
}
#endif

#endif  // ifndef _NTDDRDR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddredb.h ===
#ifndef _ntddredb_h_
#define _ntddredb_h_

// MSRedbook_DriverInformation - REDBOOK_WMI_STD_DATA
// Digital Audio Filter Driver Information (redbook)
#define GUID_REDBOOK_WMI_STD_DATA \
    { 0xb90550e7,0xae0a,0x11d1, { 0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30 } }

DEFINE_GUID(MSRedbook_DriverInformationGuid, \
            0xb90550e7,0xae0a,0x11d1,0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30);


typedef struct _REDBOOK_WMI_STD_DATA
{
    // NumberOfBuffers*SectorsPerRead*2352 is the amount of memory used to reduce skipping.
    ULONG NumberOfBuffers;
    #define REDBOOK_WMI_NUMBER_OF_BUFFERS_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_NUMBER_OF_BUFFERS_ID 1

    // Sectors (2352 bytes each) per read.
    ULONG SectorsPerRead;
    #define REDBOOK_WMI_SECTORS_PER_READ_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_SECTORS_PER_READ_ID 2

    // Bitwise mask of supported sectors per read for this drive.  The lowest bit is one sector reads.  If all bits are set, there are no restrictions.
    ULONG SectorsPerReadMask;
    #define REDBOOK_WMI_SECTORS_PER_READ_MASK_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_SECTORS_PER_READ_MASK_ID 3

    // Maximum sectors per read (depends on both adapter and drive).
    ULONG MaximumSectorsPerRead;
    #define REDBOOK_WMI_MAX_SECTORS_PER_READ_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_MAX_SECTORS_PER_READ_ID 4

    // PlayEnabled indicates the drive is currently using the RedBook filter.
    BOOLEAN PlayEnabled;
    #define REDBOOK_WMI_PLAY_ENABLED_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_PLAY_ENABLED_ID 5

    // CDDASupported indicates the drive supports digital audio for some sector sizes.
    BOOLEAN CDDASupported;
    #define REDBOOK_WMI_CDDA_SUPPORTED_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_CDDA_SUPPORTED_ID 6

    // CDDAAccurate indicates the drive acccurately reads digital audio.  This ensures the highest quality audio
    BOOLEAN CDDAAccurate;
    #define REDBOOK_WMI_CDDA_ACCURATE_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_CDDA_ACCURATE_ID 7

    // Reserved for future use
    BOOLEAN Reserved1;
    #define REDBOOK_WMI_STD_DATA_Reserved1_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_STD_DATA_Reserved1_ID 8

} REDBOOK_WMI_STD_DATA, *PREDBOOK_WMI_STD_DATA;

// MSRedbook_Performance - REDBOOK_WMI_PERF_DATA
// Digital Audio Filter Driver Performance Data (redbook)
#define GUID_REDBOOK_WMI_PERF_DATA \
    { 0xb90550e8,0xae0a,0x11d1, { 0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30 } }

DEFINE_GUID(MSRedbook_PerformanceGuid, \
            0xb90550e8,0xae0a,0x11d1,0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30);


typedef struct _REDBOOK_WMI_PERF_DATA
{
    // Seconds spent ready to read, but unused. (*1E-7)
    LONGLONG TimeReadDelay;
    #define REDBOOK_WMI_PERF_TIME_READING_DELAY_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_READING_DELAY_ID 1

    // Seconds spent reading data from source. (*1E-7)
    LONGLONG TimeReading;
    #define REDBOOK_WMI_PERF_TIME_READING_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_READING_ID 2

    // Seconds spent ready to stream, but unused. (*1E-7)
    LONGLONG TimeStreamDelay;
    #define REDBOOK_WMI_PERF_TIME_STREAMING_DELAY_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_STREAMING_DELAY_ID 3

    // Seconds spent streaming data. (*1E-7)
    LONGLONG TimeStreaming;
    #define REDBOOK_WMI_PERF_TIME_STREAMING_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_STREAMING_ID 4

    // Number of bytes of data read and streamed.
    LONGLONG DataProcessed;
    #define REDBOOK_WMI_PERF_DATA_PROCESSED_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_DATA_PROCESSED_ID 5

    // Number of times the stream has paused due to insufficient stream buffers.
    ULONG StreamPausedCount;
    #define REDBOOK_WMI_PERF_STREAM_PAUSED_COUNT_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_PERF_STREAM_PAUSED_COUNT_ID 6

} REDBOOK_WMI_PERF_DATA, *PREDBOOK_WMI_PERF_DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddser.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddser.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Serial device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:
    Louis J. Giliberto, Jr. (louisg) 28-Oct-97

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddser.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddser.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

// begin_wioctlguids
DEFINE_GUID(GUID_CLASS_COMPORT,          0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73);
DEFINE_GUID(GUID_SERENUM_BUS_ENUMERATOR, 0x4D36E978L, 0xE325, 0x11CE, 0xBF, 0xC1, 0x08, 0x00, 0x2B, 0xE1, 0x03, 0x18);
// end_wioctlguids
#endif // DEFINE_GUID

#ifndef _NTDDSER_
#define _NTDDSER_

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//

#define IOCTL_SERIAL_SET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_QUEUE_SIZE     CTL_CODE(FILE_DEVICE_SERIAL_PORT, 2,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT, 3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_BREAK_ON       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 4,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_BREAK_OFF      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 5,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_IMMEDIATE_CHAR     CTL_CODE(FILE_DEVICE_SERIAL_PORT, 6,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_TIMEOUTS       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 7,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_TIMEOUTS       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 8,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_DTR            CTL_CODE(FILE_DEVICE_SERIAL_PORT, 9,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLR_DTR            CTL_CODE(FILE_DEVICE_SERIAL_PORT,10,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_RESET_DEVICE       CTL_CODE(FILE_DEVICE_SERIAL_PORT,11,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_RTS            CTL_CODE(FILE_DEVICE_SERIAL_PORT,12,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLR_RTS            CTL_CODE(FILE_DEVICE_SERIAL_PORT,13,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_XOFF           CTL_CODE(FILE_DEVICE_SERIAL_PORT,14,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_XON            CTL_CODE(FILE_DEVICE_SERIAL_PORT,15,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_WAIT_MASK      CTL_CODE(FILE_DEVICE_SERIAL_PORT,16,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_WAIT_MASK      CTL_CODE(FILE_DEVICE_SERIAL_PORT,17,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_WAIT_ON_MASK       CTL_CODE(FILE_DEVICE_SERIAL_PORT,18,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_PURGE              CTL_CODE(FILE_DEVICE_SERIAL_PORT,19,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT,20,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,21,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,22,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,23,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,24,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,25,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_MODEMSTATUS    CTL_CODE(FILE_DEVICE_SERIAL_PORT,26,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_COMMSTATUS     CTL_CODE(FILE_DEVICE_SERIAL_PORT,27,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_XOFF_COUNTER       CTL_CODE(FILE_DEVICE_SERIAL_PORT,28,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_PROPERTIES     CTL_CODE(FILE_DEVICE_SERIAL_PORT,29,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_DTRRTS         CTL_CODE(FILE_DEVICE_SERIAL_PORT,30,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Serenum reserves function codes between 128 and 255.  Do not use.
//

// begin_winioctl

#define IOCTL_SERIAL_LSRMST_INSERT      CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SERENUM_EXPOSE_HARDWARE   CTL_CODE(FILE_DEVICE_SERENUM,128,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_REMOVE_HARDWARE   CTL_CODE(FILE_DEVICE_SERENUM,129,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_PORT_DESC         CTL_CODE(FILE_DEVICE_SERENUM,130,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_GET_PORT_NAME     CTL_CODE(FILE_DEVICE_SERENUM,131,METHOD_BUFFERED,FILE_ANY_ACCESS)

// end_winioctl

#define IOCTL_SERIAL_CONFIG_SIZE        CTL_CODE(FILE_DEVICE_SERIAL_PORT,32,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_COMMCONFIG     CTL_CODE(FILE_DEVICE_SERIAL_PORT,33,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_COMMCONFIG     CTL_CODE(FILE_DEVICE_SERIAL_PORT,34,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SERIAL_GET_STATS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,35,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLEAR_STATS        CTL_CODE(FILE_DEVICE_SERIAL_PORT,36,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,37,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,38,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_FIFO_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,39,METHOD_BUFFERED,FILE_ANY_ACCESS)


//
// internal serial IOCTL's
//

#define IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE  CTL_CODE(FILE_DEVICE_SERIAL_PORT, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS    CTL_CODE(FILE_DEVICE_SERIAL_PORT, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS  CTL_CODE(FILE_DEVICE_SERIAL_PORT, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _SERIALPERF_STATS {
    ULONG ReceivedCount;
    ULONG TransmittedCount;
    ULONG FrameErrorCount;
    ULONG SerialOverrunErrorCount;
    ULONG BufferOverrunErrorCount;
    ULONG ParityErrorCount;
} SERIALPERF_STATS, *PSERIALPERF_STATS;

typedef struct _SERIALCONFIG {
    ULONG Size;
    USHORT Version;
    ULONG SubType;
    ULONG ProvOffset;
    ULONG ProviderSize;
    WCHAR ProviderData[1];
} SERIALCONFIG,*PSERIALCONFIG;

//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// This structure used to set line parameters.
//

typedef struct _SERIAL_LINE_CONTROL {
    UCHAR StopBits;
    UCHAR Parity;
    UCHAR WordLength;
    } SERIAL_LINE_CONTROL,*PSERIAL_LINE_CONTROL;

typedef struct _SERIAL_TIMEOUTS {
    ULONG ReadIntervalTimeout;
    ULONG ReadTotalTimeoutMultiplier;
    ULONG ReadTotalTimeoutConstant;
    ULONG WriteTotalTimeoutMultiplier;
    ULONG WriteTotalTimeoutConstant;
    } SERIAL_TIMEOUTS,*PSERIAL_TIMEOUTS;

//
// This structure used to resize the input/output buffers.
// An error code will be returned if the size exceeds the
// drivers capacity.  The driver reserves the right to
// allocate a larger buffer.
//

typedef struct _SERIAL_QUEUE_SIZE {
    ULONG InSize;
    ULONG OutSize;
    } SERIAL_QUEUE_SIZE,*PSERIAL_QUEUE_SIZE;


//
// This structure used by set baud rate
//

typedef struct _SERIAL_BAUD_RATE {
    ULONG BaudRate;
    } SERIAL_BAUD_RATE,*PSERIAL_BAUD_RATE;



//
// Defines the bitmask that the driver can used to notify
// app of various changes in the state of the UART.
//

#define SERIAL_EV_RXCHAR           0x0001  // Any Character received
#define SERIAL_EV_RXFLAG           0x0002  // Received certain character
#define SERIAL_EV_TXEMPTY          0x0004  // Transmitt Queue Empty
#define SERIAL_EV_CTS              0x0008  // CTS changed state
#define SERIAL_EV_DSR              0x0010  // DSR changed state
#define SERIAL_EV_RLSD             0x0020  // RLSD changed state
#define SERIAL_EV_BREAK            0x0040  // BREAK received
#define SERIAL_EV_ERR              0x0080  // Line status error occurred
#define SERIAL_EV_RING             0x0100  // Ring signal detected
#define SERIAL_EV_PERR             0x0200  // Printer error occured
#define SERIAL_EV_RX80FULL         0x0400  // Receive buffer is 80 percent full
#define SERIAL_EV_EVENT1           0x0800  // Provider specific event 1
#define SERIAL_EV_EVENT2           0x1000  // Provider specific event 2

//
// A longword is used to send down a mask that
// instructs the driver what to purge.
//
// SERIAL_PURGE_TXABORT - Implies the current and all pending writes.
// SERIAL_PURGE_RXABORT - Implies the current and all pending reads.
// SERIAL_PURGE_TXCLEAR - Implies the transmit buffer if exists
// SERIAL_PURGE_RXCLEAR - Implies the receive buffer if exists.
//

#define SERIAL_PURGE_TXABORT 0x00000001
#define SERIAL_PURGE_RXABORT 0x00000002
#define SERIAL_PURGE_TXCLEAR 0x00000004
#define SERIAL_PURGE_RXCLEAR 0x00000008

//
// Communication defines
//

#define STOP_BIT_1      0
#define STOP_BITS_1_5   1
#define STOP_BITS_2     2

#define NO_PARITY        0
#define ODD_PARITY       1
#define EVEN_PARITY      2
#define MARK_PARITY      3
#define SPACE_PARITY     4


//
// This structure is used to set and retrieve the special characters
// used by the nt serial driver.
//
// Note that the driver will return an error if xonchar == xoffchar.
//

typedef struct _SERIAL_CHARS {
    UCHAR EofChar;
    UCHAR ErrorChar;
    UCHAR BreakChar;
    UCHAR EventChar;
    UCHAR XonChar;
    UCHAR XoffChar;
    } SERIAL_CHARS,*PSERIAL_CHARS;

//
// This structure is used to contain the flow control
// and handshaking setup.
//
// A reasonably precise explaination of how they all
// work can be found in the OS/2 tech references.
//
// For Xon/Xofflimit:
//
// When there are more characters then
//
// (typeaheadbuffersize - xofflimit)
//
// in the typeahead buffer then the driver will perform all flow
// control that the app has enabled so that the sender will (hopefully)
// stop sending characters.
//
// When there are less than xonlimit number of characters in the
// typeahead buffer the driver will perform all flow control that
// the app has enabled so that the sender will hopefully start sending
// characters again.
//
// It should be noted that if Xoff character is sent then the
// driver will also stop transmitting any more characters.  This is to
// provide support for those systems that take any character that
// follows an Xoff as an implied Xon.
//

typedef struct _SERIAL_HANDFLOW {
    ULONG ControlHandShake;
    ULONG FlowReplace;
    LONG XonLimit;
    LONG XoffLimit;
    } SERIAL_HANDFLOW,*PSERIAL_HANDFLOW;

#define SERIAL_DTR_MASK           ((ULONG)0x03)
#define SERIAL_DTR_CONTROL        ((ULONG)0x01)
#define SERIAL_DTR_HANDSHAKE      ((ULONG)0x02)
#define SERIAL_CTS_HANDSHAKE      ((ULONG)0x08)
#define SERIAL_DSR_HANDSHAKE      ((ULONG)0x10)
#define SERIAL_DCD_HANDSHAKE      ((ULONG)0x20)
#define SERIAL_OUT_HANDSHAKEMASK  ((ULONG)0x38)
#define SERIAL_DSR_SENSITIVITY    ((ULONG)0x40)
#define SERIAL_ERROR_ABORT        ((ULONG)0x80000000)
#define SERIAL_CONTROL_INVALID    ((ULONG)0x7fffff84)
#define SERIAL_AUTO_TRANSMIT      ((ULONG)0x01)
#define SERIAL_AUTO_RECEIVE       ((ULONG)0x02)
#define SERIAL_ERROR_CHAR         ((ULONG)0x04)
#define SERIAL_NULL_STRIPPING     ((ULONG)0x08)
#define SERIAL_BREAK_CHAR         ((ULONG)0x10)
#define SERIAL_RTS_MASK           ((ULONG)0xc0)
#define SERIAL_RTS_CONTROL        ((ULONG)0x40)
#define SERIAL_RTS_HANDSHAKE      ((ULONG)0x80)
#define SERIAL_TRANSMIT_TOGGLE    ((ULONG)0xc0)
#define SERIAL_XOFF_CONTINUE      ((ULONG)0x80000000)
#define SERIAL_FLOW_INVALID       ((ULONG)0x7fffff20)

//
// These are the following reasons that the device could be holding.
//
#define SERIAL_TX_WAITING_FOR_CTS      ((ULONG)0x00000001)
#define SERIAL_TX_WAITING_FOR_DSR      ((ULONG)0x00000002)
#define SERIAL_TX_WAITING_FOR_DCD      ((ULONG)0x00000004)
#define SERIAL_TX_WAITING_FOR_XON      ((ULONG)0x00000008)
#define SERIAL_TX_WAITING_XOFF_SENT    ((ULONG)0x00000010)
#define SERIAL_TX_WAITING_ON_BREAK     ((ULONG)0x00000020)
#define SERIAL_RX_WAITING_FOR_DSR      ((ULONG)0x00000040)

//
// These are the error values that can be returned by the
// driver.
//
#define SERIAL_ERROR_BREAK             ((ULONG)0x00000001)
#define SERIAL_ERROR_FRAMING           ((ULONG)0x00000002)
#define SERIAL_ERROR_OVERRUN           ((ULONG)0x00000004)
#define SERIAL_ERROR_QUEUEOVERRUN      ((ULONG)0x00000008)
#define SERIAL_ERROR_PARITY            ((ULONG)0x00000010)


//
// This structure is used by IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS
// and IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS
//

typedef struct _SERIAL_BASIC_SETTINGS {
   SERIAL_TIMEOUTS Timeouts;
   SERIAL_HANDFLOW HandFlow;
   ULONG RxFifo;
   ULONG TxFifo;
} SERIAL_BASIC_SETTINGS, *PSERIAL_BASIC_SETTINGS;


//
// This structure is used to get the current error and
// general status of the driver.
//

typedef struct _SERIAL_STATUS {
    ULONG Errors;
    ULONG HoldReasons;
    ULONG AmountInInQueue;
    ULONG AmountInOutQueue;
    BOOLEAN EofReceived;
    BOOLEAN WaitForImmediate;
    } SERIAL_STATUS,*PSERIAL_STATUS;

//
// This structure is used for XOFF counter ioctl.  The xoff ioctl
// is used to support those subsystems that feel the need to emulate
// the serial chip in software.
//
// It has the following semantics:
//
// This io request is placed into the normal device write
// queue.  That is, it will be queued behind any writes
// already given to the driver.
//
// When this request becomes the current request, the character
// specified in the field XoffChar will be sent, subject to
// all other flow control already defined.
//
// Immediately upon sending the character the driver will
// perform the following actions.
//
// A timer will be initiated that will expire after the
// number of milliseconds in the Timeout field of the
// SERIAL_XOFF_COUNTER structure.
//
// The driver will initialize a counter to the value specified
// in the Counter field of the SERIAL_XOFF_RECORD.  The driver
// will decrement this counter whenever a character is received.
//
// This request will then be held by the driver.  It will
// actually complete under the following circumstances:
//
// 1) If there is another "write" request behind it in the queue.
//    The "xoff" request will be completed with the informational status
//    STATUS_SERIAL_MORE_WRITES.  The Information field of the
//    IOSTATUS block will be set to 0.
//
//    Note: By write request we mean another SERIAL_XOFF_COUNTER
//    request, or a simple write request.  If the only subsequent
//    request is a flush request, the driver WILL NOT automatically
//    complete the SERIAL_XOFF_COUNTER request.  NOTE: Transmit
//    immediate requests DO NOT count as a normal write, and therefore
//    would not cause a counter request to complete.
//
// 2) The timer expires.  The driver will complete the request
//    with the informational status STATUS_SERIAL_COUNTER_TIMEOUT.
//    The Information field of the IOSTATUS of the request will be set to 0.
//
// 3) The driver maintained counter goes to zero.  (By implication,
//    at least "Counter" number of characters have been received.)
//    The request will be completed with a successful status
//    of STATUS_SUCCESS.  The Information field of the
//    IOSTATUS of the request will be set to 0.
//
// 4) This is really a degenerate case of "1" above.  The request
//    is started and no request follow it on the queue.  However
//    at some point, before "2" or "3" above occur, another "write"
//    request is started.  This will cause the completion actions
//    stated in "1" to occur.
//
// NOTE: This request being issued WILL NOT cause the normal flow
//       control code of the driver to be invoked.
//
// NOTE: This request has no interaction with the IOCTL_SERIAL_WAIT_ON_MASK
//       request.  An application CAN NOT wait via the above ^^^^^^ ioctl
//       on the counter going to zero.  The application must synchronize
//       with the particular IOCTL_SERIAL_XOFF_COUNTER request.
//
// NOTE: The Timeout value equal to zero would cause the counter
//       to NEVER timeout.  The only way that such a request could
//       be killed at that point would be issue another write, or
//       to purge the WRITE queue.
//

typedef struct _SERIAL_XOFF_COUNTER {
    ULONG Timeout; // Zero based.  In milliseconds
    LONG Counter; // Must be greater than zero.
    UCHAR XoffChar;
    } SERIAL_XOFF_COUNTER,*PSERIAL_XOFF_COUNTER;

//
// The following structure (and defines) are passed back by
// the serial driver in response to the get properties ioctl.
//

#define SERIAL_SP_SERIALCOMM         ((ULONG)0x00000001)

//
// Provider subtypes
//
#define SERIAL_SP_UNSPECIFIED       ((ULONG)0x00000000)
#define SERIAL_SP_RS232             ((ULONG)0x00000001)
#define SERIAL_SP_PARALLEL          ((ULONG)0x00000002)
#define SERIAL_SP_RS422             ((ULONG)0x00000003)
#define SERIAL_SP_RS423             ((ULONG)0x00000004)
#define SERIAL_SP_RS449             ((ULONG)0x00000005)
#define SERIAL_SP_MODEM             ((ULONG)0X00000006)
#define SERIAL_SP_FAX               ((ULONG)0x00000021)
#define SERIAL_SP_SCANNER           ((ULONG)0x00000022)
#define SERIAL_SP_BRIDGE            ((ULONG)0x00000100)
#define SERIAL_SP_LAT               ((ULONG)0x00000101)
#define SERIAL_SP_TELNET            ((ULONG)0x00000102)
#define SERIAL_SP_X25               ((ULONG)0x00000103)

//
// Provider capabilities flags.
//

#define SERIAL_PCF_DTRDSR        ((ULONG)0x0001)
#define SERIAL_PCF_RTSCTS        ((ULONG)0x0002)
#define SERIAL_PCF_CD            ((ULONG)0x0004)
#define SERIAL_PCF_PARITY_CHECK  ((ULONG)0x0008)
#define SERIAL_PCF_XONXOFF       ((ULONG)0x0010)
#define SERIAL_PCF_SETXCHAR      ((ULONG)0x0020)
#define SERIAL_PCF_TOTALTIMEOUTS ((ULONG)0x0040)
#define SERIAL_PCF_INTTIMEOUTS   ((ULONG)0x0080)
#define SERIAL_PCF_SPECIALCHARS  ((ULONG)0x0100)
#define SERIAL_PCF_16BITMODE     ((ULONG)0x0200)

//
// Comm provider settable parameters.
//

#define SERIAL_SP_PARITY         ((ULONG)0x0001)
#define SERIAL_SP_BAUD           ((ULONG)0x0002)
#define SERIAL_SP_DATABITS       ((ULONG)0x0004)
#define SERIAL_SP_STOPBITS       ((ULONG)0x0008)
#define SERIAL_SP_HANDSHAKING    ((ULONG)0x0010)
#define SERIAL_SP_PARITY_CHECK   ((ULONG)0x0020)
#define SERIAL_SP_CARRIER_DETECT ((ULONG)0x0040)

//
// Settable baud rates in the provider.
//

#define SERIAL_BAUD_075          ((ULONG)0x00000001)
#define SERIAL_BAUD_110          ((ULONG)0x00000002)
#define SERIAL_BAUD_134_5        ((ULONG)0x00000004)
#define SERIAL_BAUD_150          ((ULONG)0x00000008)
#define SERIAL_BAUD_300          ((ULONG)0x00000010)
#define SERIAL_BAUD_600          ((ULONG)0x00000020)
#define SERIAL_BAUD_1200         ((ULONG)0x00000040)
#define SERIAL_BAUD_1800         ((ULONG)0x00000080)
#define SERIAL_BAUD_2400         ((ULONG)0x00000100)
#define SERIAL_BAUD_4800         ((ULONG)0x00000200)
#define SERIAL_BAUD_7200         ((ULONG)0x00000400)
#define SERIAL_BAUD_9600         ((ULONG)0x00000800)
#define SERIAL_BAUD_14400        ((ULONG)0x00001000)
#define SERIAL_BAUD_19200        ((ULONG)0x00002000)
#define SERIAL_BAUD_38400        ((ULONG)0x00004000)
#define SERIAL_BAUD_56K          ((ULONG)0x00008000)
#define SERIAL_BAUD_128K         ((ULONG)0x00010000)
#define SERIAL_BAUD_115200       ((ULONG)0x00020000)
#define SERIAL_BAUD_57600        ((ULONG)0x00040000)
#define SERIAL_BAUD_USER         ((ULONG)0x10000000)

//
// Settable Data Bits
//

#define SERIAL_DATABITS_5        ((USHORT)0x0001)
#define SERIAL_DATABITS_6        ((USHORT)0x0002)
#define SERIAL_DATABITS_7        ((USHORT)0x0004)
#define SERIAL_DATABITS_8        ((USHORT)0x0008)
#define SERIAL_DATABITS_16       ((USHORT)0x0010)
#define SERIAL_DATABITS_16X      ((USHORT)0x0020)

//
// Settable Stop and Parity bits.
//

#define SERIAL_STOPBITS_10       ((USHORT)0x0001)
#define SERIAL_STOPBITS_15       ((USHORT)0x0002)
#define SERIAL_STOPBITS_20       ((USHORT)0x0004)
#define SERIAL_PARITY_NONE       ((USHORT)0x0100)
#define SERIAL_PARITY_ODD        ((USHORT)0x0200)
#define SERIAL_PARITY_EVEN       ((USHORT)0x0400)
#define SERIAL_PARITY_MARK       ((USHORT)0x0800)
#define SERIAL_PARITY_SPACE      ((USHORT)0x1000)

typedef struct _SERIAL_COMMPROP {
    USHORT PacketLength;
    USHORT PacketVersion;
    ULONG ServiceMask;
    ULONG Reserved1;
    ULONG MaxTxQueue;
    ULONG MaxRxQueue;
    ULONG MaxBaud;
    ULONG ProvSubType;
    ULONG ProvCapabilities;
    ULONG SettableParams;
    ULONG SettableBaud;
    USHORT SettableData;
    USHORT SettableStopParity;
    ULONG CurrentTxQueue;
    ULONG CurrentRxQueue;
    ULONG ProvSpec1;
    ULONG ProvSpec2;
    WCHAR ProvChar[1];
} SERIAL_COMMPROP,*PSERIAL_COMMPROP;

//
// Define masks for the rs-232 input and output.
//

#define SERIAL_DTR_STATE         ((ULONG)0x00000001)
#define SERIAL_RTS_STATE         ((ULONG)0x00000002)
#define SERIAL_CTS_STATE         ((ULONG)0x00000010)
#define SERIAL_DSR_STATE         ((ULONG)0x00000020)
#define SERIAL_RI_STATE          ((ULONG)0x00000040)
#define SERIAL_DCD_STATE         ((ULONG)0x00000080)


// begin_winioctl

//
// The following values follow the escape designator in the
// data stream if the LSRMST_INSERT mode has been turned on.
//
#define SERIAL_LSRMST_ESCAPE     ((UCHAR)0x00)

//
// Following this value is the contents of the line status
// register, and then the character in the RX hardware when
// the line status register was encountered.
//
#define SERIAL_LSRMST_LSR_DATA   ((UCHAR)0x01)

//
// Following this value is the contents of the line status
// register.  No error character follows
//
#define SERIAL_LSRMST_LSR_NODATA ((UCHAR)0x02)

//
// Following this value is the contents of the modem status
// register.
//
#define SERIAL_LSRMST_MST        ((UCHAR)0x03)

//
// Bit values for FIFO Control Register
//

#define SERIAL_IOC_FCR_FIFO_ENABLE      ((ULONG)0x00000001)
#define SERIAL_IOC_FCR_RCVR_RESET       ((ULONG)0x00000002)
#define SERIAL_IOC_FCR_XMIT_RESET       ((ULONG)0x00000004)
#define SERIAL_IOC_FCR_DMA_MODE         ((ULONG)0x00000008)
#define SERIAL_IOC_FCR_RES1             ((ULONG)0x00000010)
#define SERIAL_IOC_FCR_RES2             ((ULONG)0x00000020)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_LSB ((ULONG)0x00000040)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_MSB ((ULONG)0x00000080)

//
// Bit values for Modem Control Register
//

#define SERIAL_IOC_MCR_DTR              ((ULONG)0x00000001)
#define SERIAL_IOC_MCR_RTS              ((ULONG)0x00000002)
#define SERIAL_IOC_MCR_OUT1             ((ULONG)0x00000004)
#define SERIAL_IOC_MCR_OUT2             ((ULONG)0x00000008)
#define SERIAL_IOC_MCR_LOOP             ((ULONG)0x00000010)

// end_winioctl

//
// Serenum internal ioctl's
//

#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER

typedef struct _SERENUM_PORT_DESC
{
    IN  ULONG               Size; // sizeof (struct _PORT_DESC)
    OUT PVOID               PortHandle;
    OUT PHYSICAL_ADDRESS    PortAddress;
        USHORT              Reserved[1];
} SERENUM_PORT_DESC, * PSERENUM_PORT_DESC;

// **************************************************************************
// Internal IOCTL interface for (pdo)
// The HID to legacy serial port minidriver uses this interface to
// find the address of the device.
// **************************************************************************

#define IOCTL_INTERNAL_SERENUM_REMOVE_SELF \
    CTL_CODE(FILE_DEVICE_SERENUM, 129, METHOD_NEITHER, FILE_ANY_ACCESS)


// of which IO_STACK_LOCATION->Parameters.Others.Argument1 is set to
// a pointer to struct _SERENUM_SER_PARAMETERS

typedef
UCHAR
(*PSERENUM_READPORT) (
    PVOID  SerPortAddress
    );

typedef
VOID
(*PSERENUM_WRITEPORT) (
    PVOID  SerPortAddress,
    UCHAR   Value
    );

typedef enum _SERENUM_PORTION {
    SerenumFirstHalf,
    SerenumSecondHalf,
    SerenumWhole
} SERENUM_PORTION;

typedef struct _SERENUM_PORT_PARAMETERS
{
    IN  ULONG               Size; // sizeof (SERENUM_GET_PORT_PARAMETERS)

    OUT PSERENUM_READPORT  ReadAccessor;  // read the serial port
    OUT PSERENUM_WRITEPORT WriteAccessor;  // write the serial port
    OUT PVOID               SerPortAddress; // token to read this serial port

    OUT PVOID               HardwareHandle; // a handle to this particular PDO.
    OUT SERENUM_PORTION    Portion;
    OUT USHORT              NumberAxis; // legacy joysticks only
        USHORT              Reserved [3];
} SERENUM_PORT_PARAMETERS, *PSERENUM_PORT_PARAMETERS;

#ifdef __cplusplus
}
#endif

#endif  // _NTDDSER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddscsi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddscsi.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the SCSI port adapters.

Author:

    Jeff Havens

Revision History:

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddscsi.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddscsi.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

DEFINE_GUID(ScsiRawInterfaceGuid, 0x53f56309L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(WmiScsiAddressGuid,   0x53f5630fL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
#endif

#ifndef _NTDDSCSIH_
#define _NTDDSCSIH_

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER

#define DD_SCSI_DEVICE_NAME "\\Device\\ScsiPort"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_SCSI_PASS_THROUGH         CTL_CODE(IOCTL_SCSI_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_MINIPORT             CTL_CODE(IOCTL_SCSI_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_INQUIRY_DATA     CTL_CODE(IOCTL_SCSI_BASE, 0x0403, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_CAPABILITIES     CTL_CODE(IOCTL_SCSI_BASE, 0x0404, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_ADDRESS          CTL_CODE(IOCTL_SCSI_BASE, 0x0406, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_RESCAN_BUS           CTL_CODE(IOCTL_SCSI_BASE, 0x0407, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_DUMP_POINTERS    CTL_CODE(IOCTL_SCSI_BASE, 0x0408, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_FREE_DUMP_POINTERS   CTL_CODE(IOCTL_SCSI_BASE, 0x0409, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Define the SCSI pass through structure.
//

typedef struct _SCSI_PASS_THROUGH {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG_PTR DataBufferOffset;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH, *PSCSI_PASS_THROUGH;

//
// Define the SCSI pass through direct structure.
//

typedef struct _SCSI_PASS_THROUGH_DIRECT {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT;

//
// Define SCSI information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_BUS_DATA {
    UCHAR NumberOfLogicalUnits;
    UCHAR InitiatorBusId;
    ULONG InquiryDataOffset;
}SCSI_BUS_DATA, *PSCSI_BUS_DATA;

//
// Define SCSI adapter bus information structure..
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_ADAPTER_BUS_INFO {
    UCHAR NumberOfBuses;
    SCSI_BUS_DATA BusData[1];
} SCSI_ADAPTER_BUS_INFO, *PSCSI_ADAPTER_BUS_INFO;

//
// Define SCSI adapter bus information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_INQUIRY_DATA {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    ULONG InquiryDataLength;
    ULONG NextInquiryDataOffset;
    UCHAR InquiryData[1];
}SCSI_INQUIRY_DATA, *PSCSI_INQUIRY_DATA;

//
// Define header for I/O control SRB.
//

typedef struct _SRB_IO_CONTROL {
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

//
// SCSI port driver capabilities structure.
//

typedef struct _IO_SCSI_CAPABILITIES {

    //
    // Length of this structure
    //

    ULONG Length;

    //
    // Maximum transfer size in single SRB
    //

    ULONG MaximumTransferLength;

    //
    // Maximum number of physical pages per data buffer
    //

    ULONG MaximumPhysicalPages;

    //
    // Async calls from port to class
    //

    ULONG SupportedAsynchronousEvents;

    //
    // Alignment mask for data transfers.
    //

    ULONG AlignmentMask;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Host adapter scans down for bios devices.
    //

    BOOLEAN AdapterScansDown;

    //
    // The host adapter uses programmed I/O.
    //

    BOOLEAN AdapterUsesPio;

} IO_SCSI_CAPABILITIES, *PIO_SCSI_CAPABILITIES;

typedef struct _SCSI_ADDRESS {
    ULONG Length;
    UCHAR PortNumber;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
}SCSI_ADDRESS, *PSCSI_ADDRESS;

//
// Define structure for returning crash dump pointers.
//

struct _ADAPTER_OBJECT;

typedef struct _DUMP_POINTERS {
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID DumpData;
    PVOID CommonBufferVa;
    LARGE_INTEGER CommonBufferPa;
    ULONG CommonBufferSize;
    BOOLEAN AllocateCommonBuffers;
    UCHAR Spare1[3];
    PVOID DeviceObject;
} DUMP_POINTERS, *PDUMP_POINTERS;

//
// Define values for pass-through DataIn field.
//

#define SCSI_IOCTL_DATA_OUT          0
#define SCSI_IOCTL_DATA_IN           1
#define SCSI_IOCTL_DATA_UNSPECIFIED  2

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddpcm.h ===
/*++

Copyright (c) 1994-1999  Digital Equipment Corporation

Module Name:

    ntddpcm.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the PCMCIA Adapters.

// @@BEGIN_DDKSPLIT
Author:

    Jeff McLeman

Revision History:

    Ravisankar Pudipeddi (ravisp) 1-Jan-1997

// @@END_DDKSPLIT
--*/

#ifndef _NTDDPCMH_
#define _NTDDPCMH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define IOCTL_PCMCIA_BASE                 FILE_DEVICE_CONTROLLER

#define DD_PCMCIA_DEVICE_NAME "\\\\.\\Pcmcia"


//
// IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_GET_TUPLE_DATA         CTL_CODE(IOCTL_PCMCIA_BASE, 3000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SOCKET_INFORMATION     CTL_CODE(IOCTL_PCMCIA_BASE, 3004, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Tuple request parameters.
//

typedef struct _TUPLE_REQUEST {
   USHORT  Socket;
} TUPLE_REQUEST, *PTUPLE_REQUEST;

#define MANUFACTURER_NAME_LENGTH 64
#define DEVICE_IDENTIFIER_LENGTH 64
#define DRIVER_NAME_LENGTH       32

#define PcmciaInvalidControllerType 0xffffffff

//
// Controller classes returned in socket information structure.
//

typedef enum _PCMCIA_CONTROLLER_CLASS {
   PcmciaInvalidControllerClass = -1,
   PcmciaIntelCompatible,
   PcmciaCardBusCompatible,
   PcmciaElcController,
   PcmciaDatabook,     
   PcmciaPciPcmciaBridge,
   PcmciaCirrusLogic,  
   PcmciaTI,           
   PcmciaTopic,        
   PcmciaRicoh,        
   PcmciaDatabookCB,   
   PcmciaOpti,         
   PcmciaTrid,         
   PcmciaO2Micro,      
   PcmciaNEC,          
   PcmciaNEC_98                
} PCMCIA_CONTROLLER_CLASS, *PPCMCIA_CONTROLLER_CLASS;


typedef struct _PCMCIA_SOCKET_INFORMATION {
   USHORT  Socket;
   USHORT  TupleCrc;
   UCHAR   Manufacturer[MANUFACTURER_NAME_LENGTH];
   UCHAR   Identifier[DEVICE_IDENTIFIER_LENGTH];
   UCHAR   DriverName[DRIVER_NAME_LENGTH];
   UCHAR   DeviceFunctionId;
   UCHAR   Reserved;
   UCHAR   CardInSocket;
   UCHAR   CardEnabled;
   ULONG   ControllerType;
} PCMCIA_SOCKET_INFORMATION, *PPCMCIA_SOCKET_INFORMATION;

//
// macros to crack the ControllerId field of the socket info structure
//
#define PcmciaClassFromControllerType(type) ((PCMCIA_CONTROLLER_CLASS)((type) & 0xff))
#define PcmciaModelFromControllerType(type) (((type) >> 8) & 0x3ffff)
#define PcmciaRevisionFromControllerType(type) ((type) >> 26)


// @@BEGIN_DDKSPLIT
//
// These are macros to manipulate the PcCardConfig type resource
// descriptors - which are set by configmgr when passing in override
// configurations.
//

//
// Type of the descriptor: 1 .. 0xFFFF
//
#define DPTYPE_PCMCIA_CONFIGURATION 0x1
#define DPTYPE_PCMCIA_MF_CONFIGURATION 0x2

//
// The device private structure for PC-Card configuration:
//
// Data[0] is configuration descriptior. Lay out below.
//   Byte 0: Configuration entry number (config index)
//   Byte 1: IO  width  16-bit (bit 0)
//           Mem width  16-bit (bit 1)
//   Byte 2: Type of configuration, hardcoded to DPTYPE_PCMCIA_CONFIGURATION
//   Byte 3: unused
//
// Data [1]:  Cardbase offset for first memory window
// Data [2]:  Cardbase offset for second memory window
//
//
// The device private structure for MF-Card configuration:
//
// Data[0] is configuration descriptior. Lay out below.
//   Byte 0: Configuration Option Register (config index)
//   Byte 1: Configuration and Status Register
//           Audio Enable (bit 3)
//   Byte 2: Type of configuration, hardcoded to DPTYPE_PCMCIA_MF_CONFIGURATION
//   Byte 3: Port Io resource descriptor index
//
// Data [1]:  Configuration Register base
// Data [2]:  Unused
//

//
// Macros for manipulating the IoResource device privates
//
#define IORES_SET_DESCRIPTOR_TYPE(IoResourceDesc, Type)    (IoResourceDesc)->u.DevicePrivate.Data[0] |= ((Type) << sizeof(UCHAR)*8*2)
#define IORES_GET_DESCRIPTOR_TYPE(IoResourceDesc) ((UCHAR) ((IoResourceDesc)->u.DevicePrivate.Data[0] >> sizeof(UCHAR)*8*2))

//
// Macros specific to DPTYPE_PCMCIA_CONFIGURATION
//

#define IORES_SET_CONFIG_INDEX(desc, ConfigIndex) (desc)->u.DevicePrivate.Data[0] |= ConfigIndex
#define IORES_GET_CONFIG_INDEX(desc)    ((UCHAR) ((desc)->u.DevicePrivate.Data[0]))

//
// Flag definitions
//

#define IORESF_IO_16BIT_ACCESS  0x00000100
#define IORESF_MEM_16BIT_ACCESS 0x00000200
#define IORESF_MEM_1_ATTRIBUTE  0x00000400
#define IORESF_MEM_2_ATTRIBUTE  0x00000800
#define IORESF_IO_ZERO_WAIT_8   0x00001000
#define IORESF_IO_SOURCE_16     0x00002000
#define IORESF_IO_WAIT_16       0x00004000
#define IORESF_MEM_WAIT_1       0x01000000
#define IORESF_MEM_WAIT_2       0x02000000
#define IORESF_MEM_WAIT_3       0x03000000

//
// IO size flag
//
#define IORES_SET_IO_16BIT_ACCESS(desc)   (desc)->u.DevicePrivate.Data[0] |= IORESF_IO_16BIT_ACCESS
#define IORES_GET_IO_16BIT_ACCESS(desc) (((desc)->u.DevicePrivate.Data[0] &  IORESF_IO_16BIT_ACCESS) != 0)
#define IORES_SET_IO_8BIT_ACCESS(desc)    (desc)->u.DevicePrivate.Data[0] &= ~IORESF_IO_16BIT_ACCESS

//
// Misc IO flags
//

#define IORES_SET_IO_ZERO_WAIT_8(desc)    (desc)->u.DevicePrivate.Data[0] |= IORESF_IO_ZERO_WAIT_8
#define IORES_SET_IO_SOURCE_16(desc)      (desc)->u.DevicePrivate.Data[0] |= IORESF_IO_SOURCE_16
#define IORES_SET_IO_WAIT_16(desc)        (desc)->u.DevicePrivate.Data[0] |= IORESF_IO_WAIT_16

#define IORES_GET_IO_ZERO_WAIT_8(desc)    (((desc)->u.DevicePrivate.Data[0] &  IORESF_IO_ZERO_WAIT_8) != 0)
#define IORES_GET_IO_SOURCE_16(desc)      (((desc)->u.DevicePrivate.Data[0] &  IORESF_IO_SOURCE_16) != 0)
#define IORES_GET_IO_WAIT_16(desc)        (((desc)->u.DevicePrivate.Data[0] &  IORESF_IO_WAIT_16) != 0)

//
// MEM size flag
//
#define IORES_SET_MEM_16BIT_ACCESS(desc)   (desc)->u.DevicePrivate.Data[0] |= IORESF_MEM_16BIT_ACCESS
#define IORES_GET_MEM_16BIT_ACCESS(desc) (((desc)->u.DevicePrivate.Data[0] &  IORESF_MEM_16BIT_ACCESS) != 0)
#define IORES_SET_MEM_8BIT_ACCESS(desc)    (desc)->u.DevicePrivate.Data[0] &= ~IORESF_MEM_16BIT_ACCESS

//
// MEM attribute/common flags
//
#define IORES_SET_MEM_1_ATTRIBUTE_ACCESS(desc)   (desc)->u.DevicePrivate.Data[0] |= IORESF_MEM_1_ATTRIBUTE
#define IORES_GET_MEM_1_ATTRIBUTE_ACCESS(desc) (((desc)->u.DevicePrivate.Data[0] &  IORESF_MEM_1_ATTRIBUTE) != 0)

#define IORES_SET_MEM_2_ATTRIBUTE_ACCESS(desc)   (desc)->u.DevicePrivate.Data[0] |= IORESF_MEM_2_ATTRIBUTE
#define IORES_GET_MEM_2_ATTRIBUTE_ACCESS(desc) (((desc)->u.DevicePrivate.Data[0] &  IORESF_MEM_2_ATTRIBUTE) != 0)

//
// MEM card base
//

#define IORES_SET_MEMORY_CARDBASE_1(desc, base)  (desc)->u.DevicePrivate.Data[1] = base
#define IORES_GET_MEMORY_CARDBASE_1(desc)       ((desc)->u.DevicePrivate.Data[1])

#define IORES_SET_MEMORY_CARDBASE_2(desc, base)  (desc)->u.DevicePrivate.Data[2] = base
#define IORES_GET_MEMORY_CARDBASE_2(desc)       ((desc)->u.DevicePrivate.Data[2])

//
// MEM wait states
//

#define IORES_SET_MEM_WAIT_ONE(desc)           (desc)->u.DevicePrivate.Data[0] |= IORESF_MEM_WAIT_1
#define IORES_SET_MEM_WAIT_TWO(desc)           (desc)->u.DevicePrivate.Data[0] |= IORESF_MEM_WAIT_2
#define IORES_SET_MEM_WAIT_THREE(desc)         (desc)->u.DevicePrivate.Data[0] |= IORESF_MEM_WAIT_3
#define IORES_GET_MEM_WAIT(desc)               ((UCHAR) (((desc)->u.DevicePrivate.Data[0] >> 24)) & 3)


//
// Macros specific to DPTYPE_PCMCIA_MF_CONFIGURATION
//

#define IORESF_AUDIO_ENABLE     0x00000800
#define IORES_MF_PORT_INDEX_SHIFT   24

#define IORES_SET_CONFIG_OPTIONS(desc, opt)      (desc)->u.DevicePrivate.Data[0] |= opt
#define IORES_GET_CONFIG_OPTIONS(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0]))

#define IORES_SET_PORT_RESOURCE_INDEX(desc, Index)    (desc)->u.DevicePrivate.Data[0] |= ((Index) << IORES_MF_PORT_INDEX_SHIFT)
#define IORES_GET_PORT_RESOURCE_INDEX(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0] >> IORES_MF_PORT_INDEX_SHIFT))

#define IORES_SET_AUDIO_ENABLE(desc)           (desc)->u.DevicePrivate.Data[0] |= IORESF_AUDIO_ENABLE
#define IORES_GET_AUDIO_ENABLE(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0] &  IORESF_AUDIO_ENABLE) != 0)

#define IORES_SET_CONFIG_REGISTER_BASE(desc, cfgbase)  (desc)->u.DevicePrivate.Data[1] = cfgbase
#define IORES_GET_CONFIG_REGISTER_BASE(desc)          ((desc)->u.DevicePrivate.Data[1])

//
// Macros for CmResource device privates (same layout as IoRes)
//
#define CMRES_SET_DESCRIPTOR_TYPE      IORES_SET_DESCRIPTOR_TYPE
#define CMRES_GET_DESCRIPTOR_TYPE      IORES_GET_DESCRIPTOR_TYPE

#define CMRES_SET_CONFIG_INDEX         IORES_SET_CONFIG_INDEX
#define CMRES_GET_CONFIG_INDEX         IORES_GET_CONFIG_INDEX
#define CMRES_SET_IO_16BIT_ACCESS      IORES_SET_IO_16BIT_ACCESS
#define CMRES_GET_IO_16BIT_ACCESS      IORES_GET_IO_16BIT_ACCESS
#define CMRES_SET_IO_8BIT_ACCESS       IORES_SET_IO_8BIT_ACCESS

#define CMRES_SET_IO_ZERO_WAIT_8       IORES_SET_IO_ZERO_WAIT_8
#define CMRES_SET_IO_SOURCE_16         IORES_SET_IO_SOURCE_16
#define CMRES_SET_IO_WAIT_16           IORES_SET_IO_WAIT_16
#define CMRES_GET_IO_ZERO_WAIT_8       IORES_GET_IO_ZERO_WAIT_8
#define CMRES_GET_IO_SOURCE_16         IORES_GET_IO_SOURCE_16
#define CMRES_GET_IO_WAIT_16           IORES_GET_IO_WAIT_16

#define CMRES_SET_MEM_16BIT_ACCESS     IORES_SET_MEM_16BIT_ACCESS
#define CMRES_GET_MEM_16BIT_ACCESS     IORES_GET_MEM_16BIT_ACCESS
#define CMRES_SET_MEM_8BIT_ACCESS      IORES_SET_MEM_8BIT_ACCESS

#define CMRES_SET_MEM_WAIT_ONE         IORES_SET_MEM_WAIT_ONE
#define CMRES_SET_MEM_WAIT_TWO         IORES_SET_MEM_WAIT_TWO
#define CMRES_SET_MEM_WAIT_THREE       IORES_SET_MEM_WAIT_THREE
#define CMRES_GET_MEM_WAIT             IORES_GET_MEM_WAIT

#define CMRES_SET_MEM_1_ATTRIBUTE_ACCESS IORES_SET_MEM_1_ATTRIBUTE_ACCESS 
#define CMRES_GET_MEM_1_ATTRIBUTE_ACCESS IORES_GET_MEM_1_ATTRIBUTE_ACCESS 
#define CMRES_SET_MEM_2_ATTRIBUTE_ACCESS IORES_SET_MEM_2_ATTRIBUTE_ACCESS 
#define CMRES_GET_MEM_2_ATTRIBUTE_ACCESS IORES_GET_MEM_2_ATTRIBUTE_ACCESS 

#define CMRES_SET_MEMORY_CARDBASE_1    IORES_SET_MEMORY_CARDBASE_1
#define CMRES_GET_MEMORY_CARDBASE_1    IORES_GET_MEMORY_CARDBASE_1
#define CMRES_SET_MEMORY_CARDBASE_2    IORES_SET_MEMORY_CARDBASE_2
#define CMRES_GET_MEMORY_CARDBASE_2    IORES_GET_MEMORY_CARDBASE_2

#define CMRES_SET_CONFIG_OPTIONS       IORES_SET_CONFIG_OPTIONS
#define CMRES_GET_CONFIG_OPTIONS       IORES_GET_CONFIG_OPTIONS
#define CMRES_SET_PORT_RESOURCE_INDEX  IORES_SET_PORT_RESOURCE_INDEX
#define CMRES_GET_PORT_RESOURCE_INDEX  IORES_GET_PORT_RESOURCE_INDEX
#define CMRES_SET_AUDIO_ENABLE         IORES_SET_AUDIO_ENABLE
#define CMRES_GET_AUDIO_ENABLE         IORES_GET_AUDIO_ENABLE
#define CMRES_SET_CONFIG_REGISTER_BASE IORES_SET_CONFIG_REGISTER_BASE
#define CMRES_GET_CONFIG_REGISTER_BASE IORES_GET_CONFIG_REGISTER_BASE

//
// Begin pcmcia exported interfaces to other drivers
//
// @@END_DDKSPLIT

#ifdef _NTDDK_

DEFINE_GUID( GUID_PCMCIA_INTERFACE_STANDARD,     0xbed5dadfL, 0x38fb, 0x11d1, 0x94, 0x62, 0x00, 0xc0, 0x4f, 0xb9, 0x60, 0xee);

#define  PCMCIA_MEMORY_8BIT_ACCESS     0
#define  PCMCIA_MEMORY_16BIT_ACCESS    1

typedef
BOOLEAN
(*PPCMCIA_MODIFY_MEMORY_WINDOW)(
                               IN   PVOID Context,
                               IN   ULONGLONG HostBase,
                               IN   ULONGLONG CardBase,
                               IN   BOOLEAN Enable,
                               IN   ULONG   WindowSize OPTIONAL,
                               IN   UCHAR   AccessSpeed OPTIONAL,
                               IN   UCHAR   BusWidth OPTIONAL,
                               IN   BOOLEAN IsAttributeMemory OPTIONAL
                               );

#define     PCMCIA_VPP_0V     0
#define     PCMCIA_VPP_12V    1
#define     PCMCIA_VPP_IS_VCC 2

typedef
BOOLEAN
(*PPCMCIA_SET_VPP)(
                  IN  PVOID Context,
                  IN  UCHAR VppLevel
                  );

typedef
BOOLEAN
(*PPCMCIA_IS_WRITE_PROTECTED)(
                             IN PVOID Context
                             );

//
// These are interfaces for manipulating memory windows, setting Vpp etc.,
// primarily used by flash memory card drivers
//
typedef struct _PCMCIA_INTERFACE_STANDARD {
   USHORT Size;
   USHORT Version;
   PINTERFACE_REFERENCE InterfaceReference;
   PINTERFACE_DEREFERENCE  InterfaceDereference;
   PVOID Context;
   PPCMCIA_MODIFY_MEMORY_WINDOW ModifyMemoryWindow;
   PPCMCIA_SET_VPP           SetVpp;
   PPCMCIA_IS_WRITE_PROTECTED     IsWriteProtected;
} PCMCIA_INTERFACE_STANDARD, *PPCMCIA_INTERFACE_STANDARD;

//
// Definitions for PCMCIA_BUS_INTERFACE_STANDARD.
// This interface is obtained using GUID_PCMCIA_BUS_INTERFACE_STANDARD
// and is used for reading/writing to PCMCIA config. space
//

typedef
ULONG
(*PPCMCIA_READ_WRITE_CONFIG) (
                             IN PVOID   Context,
                             IN ULONG   WhichSpace,
                             IN PUCHAR  Buffer,
                             IN ULONG   Offset,
                             IN ULONG   Length
                             );
//
// WhichSpace for IRP_MN_READ_CONFIG/WRITE_CONFIG
// and PCMCIA_BUS_INTERFACE_STANDARD
//
typedef ULONG MEMORY_SPACE;

#define    PCCARD_PCI_CONFIGURATION_SPACE    0  // for cardbus cards
#define    PCCARD_ATTRIBUTE_MEMORY           1
#define    PCCARD_COMMON_MEMORY              2
#define    PCCARD_ATTRIBUTE_MEMORY_INDIRECT  3
#define    PCCARD_COMMON_MEMORY_INDIRECT     4

// Legacy support
//
#define    PCMCIA_CONFIG_SPACE               PCCARD_ATTRIBUTE_MEMORY

typedef struct _PCMCIA_BUS_INTERFACE_STANDARD {
   //
   // generic interface header
   //
   USHORT Size;
   USHORT Version;
   PVOID Context;
   PINTERFACE_REFERENCE InterfaceReference;
   PINTERFACE_DEREFERENCE InterfaceDereference;
   //
   // standard PCMCIA bus interfaces
   //
   PPCMCIA_READ_WRITE_CONFIG ReadConfig;
   PPCMCIA_READ_WRITE_CONFIG WriteConfig;
} PCMCIA_BUS_INTERFACE_STANDARD, *PPCMCIA_BUS_INTERFACE_STANDARD;

#endif

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddsbp2.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sbp2api.h

Abstract:

    Definitions for the 1394 Sbp2 transport/protocol driver api

Author:

    George Chrysanthakopoulos (georgioc) 2/12/99

Environment:

    Kernel mode only

Revision History:


--*/

#ifndef _NTDDSBP2_H_
#define _NTDDSBP2_H_

#if (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Various definitions
//
#define IOCTL_SBP2_REQUEST                      CTL_CODE( \
                                                FILE_DEVICE_UNKNOWN, \
                                                0x200, \
                                                METHOD_IN_DIRECT, \
                                                FILE_ANY_ACCESS \
                                                )

//
// IEEE 1394 Sbp2 Request packet.  It is how other
// device drivers communicate with the 1sbp2 trasnport.
//

typedef struct _SBP2_REQUEST {

    //
    // Holds the zero based Function number that corresponds to the request
    // that device drivers are asking the sbp2 port driver to carry out.
    //

    ULONG RequestNumber;

    //
    // Holds Flags that may be unique to this particular operation
    //

    ULONG Flags;

    //
    // Holds the structures used in performing the various 1394 APIs
    //

    union {

        //
        // Fields necessary in order for the 1394 stack to carry out an
        // ParseTextLeaf request.
        //

        struct {
            ULONG           fulFlags;
            ULONG           Key;        // quadlet direct value to search for
            ULONG           ulLength;
            PVOID           Buffer;        // mdl to store the retrieved text leaf
        } RetrieveTextLeaf;

        struct {
            ULONG           fulFlags;
            ULONG           Parameter;   
            ULONG           Value;    
        } AccessTransportSettings;

    } u;

} SBP2_REQUEST, *PSBP2_REQUEST;

#define SBP2REQ_FLAG_RETRIEVE_VALUE         0x1
#define SBP2REQ_FLAG_MODIFY_VALUE           0x2

//
// sbp2 requests
//

#define SBP2_REQUEST_RETRIEVE_TEXT_LEAFS        1
#define SBP2_REQUEST_ACCESS_TRANSPORT_SETTINGS  2

//
// values required for the SBP2_REQUEST_RETRIEVE_TEXT_LEAFS call
//

#define SBP2REQ_RETRIEVE_TEXT_LEAF_DIRECT           0x00000001
#define SBP2REQ_RETRIEVE_TEXT_LEAF_INDIRECT         0x00000002
#define SBP2REQ_RETRIEVE_TEXT_LEAF_FROM_UNIT_DIR    0x00000004
#define SBP2REQ_RETRIEVE_TEXT_LEAF_FROM_LU_DIR      0x00000008

//
// values required for the parameter in SBP2_REQUEST_ACCESS_TRANSPORT_SETTINGS call
//

#define SBP2REQ_ACCESS_SETTINGS_QUEUE_SIZE      0x00000001


#ifdef __cplusplus
}
#endif

#endif      // _NTDDSBP2_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddsjoy.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    swndr3p.h

Abstract:

    Definitions of all constants and types for the Sidewinder 3p joystick.

Author:

    edbriggs 30-Nov-95


Revision History:


--*/


#ifndef __NTDDSJOY_H__
#define __NTDDSJOY_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define UnusedParameter(x) x = x



//
// Device Name
//

#define JOY_DD_DEVICE_NAME       "\\Device\\IBMJOY"
#define JOY_DD_DEVICE_NAME_U    L"\\Device\\IBMJOY"


//
// Device Parameters
//

#define JOY_DD_NAXES             "NumberOfAxes"
#define JOY_DD_NAXES_U          L"NumberOfAxes"

#define JOY_DD_DEVICE_TYPE       "DeviceType"
#define JOY_DD_DEVICE_TYPE_U    L"DeviceType"

#define JOY_DD_DEVICE_ADDRESS    "DeviceAddress"
#define JOY_DD_DEVICE_ADDRESS_U L"DeviceAddress"




//
// Device Types
//

#define JOY_TYPE_UNKNOWN       0x00
#define JOY_TYPE_SIDEWINDER    0x01

//
// Device I/O Port Address
//

#define JOY_IO_PORT_ADDRESS    0x201

//
// Device specific bitmasks
//


#define X_AXIS_BITMASK	0x01
#define CLOCK_BITMASK	0x10
#define DATA0_BITMASK	0x20
#define DATA1_BITMASK	0x40
#define DATA2_BITMASK	0x80
#define ALLDATA_BITMASK	0xE0
#define ALLAXIS_BITMASK 0x0F


//
// Analog joystick bitmasks
//

#define JOYSTICK2_BUTTON2   0x80
#define JOYSTICK2_BUTTON1   0x40
#define JOYSTICK1_BUTTON2   0x20
#define JOYSTICK1_BUTTON1   0x10
#define JOYSTICK2_Y_MASK    0x08
#define JOYSTICK2_X_MASK    0x04
#define JOYSTICK1_R_MASK    0x08
#define JOYSTICK1_Z_MASK    0x04
#define JOYSTICK1_Y_MASK    0x02
#define JOYSTICK1_X_MASK    0x01


#define JOY_START_TIMERS    0


//
// Device specific timer values
//

#define ANALOG_POLL_TIMEOUT 5000            // 5 mS upper bound on analog polling
#define ANALOG_POLL_RESOLUTION  100         // 100 uS accuracy on polling time

#define ANALOG_XA_VERYSLOW	1500
#define	ANALOG_XA_SLOW		1200
#define ANALOG_XA_MEDIUM	900
#define ANALOG_XA_FAST		300
#define ANALOG_XA_VERYFAST	100

#define DIGITAL_XA_VERYSLOW	1100
#define	DIGITAL_XA_SLOW		700
#define DIGITAL_XA_MEDIUM	510
#define DIGITAL_XA_FAST		100
#define DIGITAL_XA_VERYFAST	50

#define GODIGITAL_BASEDELAY_VERYSLOW	25
#define GODIGITAL_BASEDELAY_SLOW	    50
#define GODIGITAL_BASEDELAY_MEDIUM	    75
#define GODIGITAL_BASEDELAY_FAST	    120
#define GODIGITAL_BASEDELAY_VERYFAST	130


//
// Device specific operating mode. Both INVALID_MODE and MAXIMUM_MODE are for
// assertion checking and do not correspond to real operating modes
//


#define SIDEWINDER3P_INVALID_MODE           0
#define SIDEWINDER3P_ANALOG_MODE            1
#define SIDEWINDER3P_DIGITAL_MODE           2
#define SIDEWINDER3P_ENHANCED_DIGITAL_MODE  3
#define SIDEWINDER3P_MAXIMUM_MODE           4


#define CLOCK_RISING_EDGE     0
#define CLOCK_FALLING_EDGE    1


//
// These constants define how polling errors will be handled
//

#define MAX_ENHANCEDMODE_ATTEMPTS   10


//
// Joystick position information is transfered from the device driver to other
// drivers or applications using the JOY_DD_INPUT_DATA structure. Since
// the type of data returned varies whether the device is in analog mode or
// digital mode, a union is formed to convey both types of data. The Mode
// variable allows the recipient of the data to determing how to interpret
// the data.
//


typedef struct {

    //
    // True if the device is unplugged. This is determined by a timeout
    // mechanism
    //
    BOOL    Unplugged;

    //
    // The mode is a value used to allow the recipient to determine how to
    // interpret the data and the union. Valid values are:
    //
    //         SIDEWINDER3P_ANALOG_MODE,
    //         SIDEWINDER3P_DIGITAL_MODE,
    //         SIDEWINDER3P_ENHANCED_DIGITAL_MODE
    //

    DWORD   Mode;


    union {

      //
      // Digital mode data packet
      //

        struct {

          //
          // Digital Positioning information values as follows
          //
          //  name     range        direction
          //  ----     -----        ---------
          //
          //  XOffset  [0..1024)    0 = leftmost, 1023 = rightmost
          //  YOffset  [0..1024)    0 = up,       1023 = down
          //  RzOffset [0..512)     0 = left,      511 = right
          //  TOffset  [0..1024)    Throttle position
          //

          WORD   XOffset;
          WORD   YOffset;
          WORD   RzOffset;
          WORD   TOffset;

          //
          // hat position. The hat is an eight position switch.
          // 0 = Not Pressed; 1 = 0 degrees, 2 = 45, 3 = 90 ... 8 = 315
          // 0 degrees is up.
          //

          BYTE   Hat;

          //
          // Button states. Buttons are bitmapped into the low order
          // bit 0 - 7.  Depressed = 0, released = 1.
          //

          BYTE   Buttons;

          //
          // Checksum for packet
          //

          BYTE   Checksum;

          //
          // Switch indicating whether we are emulating a CH Joystick or a
          // Thrustmaster Joystick.
          //

          BYTE   Switch_CH_TM;

          //
          // Driver Internal processing determines if the checksum and framing
          // of the packet are correct. The following boolean values reflect
          // the findings
          //

          BOOL   fChecksumCorrect;
          BOOL   fSyncBitsCorrect;

        } DigitalData;


      //
      // Analog mode data packet
      //

        struct {

          //
          // The number of axi configured for this device (specified in the
          // registry).
          //

          DWORD   Axi;

          //
          // current button state bitmask
          //

          DWORD   Buttons;

          //
          // X, Y, Z, and T axi positioning information contained below. The
          // values are expressed interms of microseconds. The values are
          // generated by measuring the duration of a pulse supplied by
          // the IBM compatable or Soundblaster game port. This is the raw
          // data, and it is the callers responsibility to perform
          // calibration, ranging, hysteresis, etc.
          //
          // Because of inaccuracies in sampling this data, there is some
          // variation in readings of a stationary joystick.
          //
          //
          // Analog Positioning information for Microsoft Sidewinder IIId P
          // values as follows (range information measured using a
          // Soundblaster analog game port.
          //
          //           apprx
          //  name     range        direction
          //  ----     -----        ---------
          //
          //  XTime  20..1600 uS    20 = leftmost, 1600 = rightmost
          //  YTime  20..1600 uS    20 = up,       1600 = down
          //  ZTime  20..1600 uS    20 = left,     1600 = right
          //  TTime  20..1600 uS    20 = forward   1600 = back
          //

          DWORD   XTime;   // Time in microseconds for X
          DWORD   YTime;   // Time in microseconds for Y
          DWORD   ZTime;   // Time in microseconds for Z if 3-axis
          DWORD   TTime;   // Time in microseconds for Throttle if 4 axis

        } AnalogData;

    } u;

} JOY_DD_INPUT_DATA, *PJOY_DD_INPUT_DATA;



//
// The following IOCTL codes are used for testing the device driver. They
// export internal functions of the driver which will not be needed in the
// final version of the driver
//

#define JOY_TYPE 40001

#define IOCTL_JOY_GET_DRIVER_MODE_DWORD \
    CTL_CODE( JOY_TYPE, 0x900, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_GET_DEVICE_MODE_DWORD \
    CTL_CODE( JOY_TYPE, 0x901, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_SET_DIGITAL_MODE \
    CTL_CODE( JOY_TYPE, 0x902, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_GET_STATISTICS \
    CTL_CODE( JOY_TYPE, 0x903, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_SET_ENHANCED_MODE \
    CTL_CODE( JOY_TYPE, 0x904, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_SET_ANALOG_MODE \
    CTL_CODE( JOY_TYPE, 0x905, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_GET_JOYREGHWCONFIG \
    CTL_CODE( JOY_TYPE, 0x906, METHOD_BUFFERED, FILE_READ_ACCESS)



typedef union
{
    BYTE    Byte;
    WORD    Word;
    DWORD   Dword;

} JOY_IOCTL_INFO, *PJOY_IOCTL_INFO;


typedef struct
{
    DWORD   Retries[MAX_ENHANCEDMODE_ATTEMPTS];
    DWORD   EnhancedPolls;
    DWORD   EnhancedPollTimeouts;
    DWORD   EnhancedPollErrors;
    DWORD   Frequency;
    DWORD   dwQPCLatency;
    LONG    nReadLoopMax;
    DWORD   nVersion;
    DWORD   nPolledTooSoon;
    DWORD   nReset;
} JOY_STATISTICS, *PJOY_STATISTICS;

#ifdef __cplusplus
}
#endif

#endif // __NTDDJOY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddtime.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntddtime.h

Abstract:

    This include file defines all constants and types for
    accessing an NT wave device.

Author:

    Robin Speed (RobinSp) 30-Jan-92

Revision History:

--*/

#ifndef _NTDDTIME_
#define _NTDDTIME_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define FILE_DEVICE_TIME 0x00000026


//
// Timer IOCTLs
//

#define IOCTL_TIMER_SET_TIMER_EVENT   CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0001, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_GET_TIME          CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0002, METHOD_NEITHER, FILE_WRITE_DATA)
#define IOCTL_TIMER_GET_DEV_CAPS      CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0003, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_BEGIN_MIN_PERIOD  CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0004, METHOD_NEITHER, FILE_WRITE_DATA)
#define IOCTL_TIMER_END_MIN_PERIOD    CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0005, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_RESET             CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0006, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_RESET_EVENT       CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0007, METHOD_NEITHER, FILE_WRITE_DATA)

#define DD_TIMER_DEVICE_NAME_U     L"\\Device\\Timer"

#define IO_TIMER_INCREMENT 8

typedef struct {
    ULONG EventTime;                      // Time in ms for event
    ULONG EventId;                        // Id (cannot be 0)
    LARGE_INTEGER EventTicks;             // Driver use (not seen by caller)
} TIMER_DD_SET_EVENT, *PTIMER_DD_SET_EVENT;

#ifdef __cplusplus
}
#endif

#endif  // _NTDDTIME_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddtx.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddtx.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the transaction device.

Author:

    Chandan Chauhan (ChandanC) 15-Feb-1991

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif


#define IOCTL_TRNXT_XCEIVE	 0x12
#define IOCTL_TRNXT_READ	 0x22
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddsnd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddsnd.h

Abstract:

    This is the include file that defines all the common
    constants and types for sound devices.

Author:

    Nigel Thompson (NigelT) 17-May-91

Revision History:

--*/

#ifndef _NTDDSND_
#define _NTDDSND_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Define the IOCTL base values for sound devices and each class
// of sound device
//

#define IOCTL_SOUND_BASE                  FILE_DEVICE_SOUND
#define IOCTL_WAVE_BASE 0x0000
#define IOCTL_MIDI_BASE 0x0080

//
// Define some useful limits
//

#define SOUND_MAX_DEVICE_NAME 80    // BUGBUG this is a wild guess
#define SOUND_MAX_DEVICES     100   // Max no of devices of a given type

#ifdef __cplusplus
}
#endif

#endif // _NTDDSND_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddstrm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntddstrm.h

Abstract:

    This header file defines constants and types for accessing the NT
    STREAMS environment.

    Include the STREAMS header file, <sys/stropts.h>, before this !!

Author:

    Eric Chin (ericc)    July 2, 1991

Revision History:

--*/

#ifndef _NTDDSTRM_
#define _NTDDSTRM_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
#define DD_STREAMS_DEVICE_NAME              "\\Device\\Streams"


//
// EA to be used when opening a STREAMS driver for putmsg()/getmsg().
//
#define NormalStreamEA                      "NormalStream"
#define NORMAL_STREAM_EA_LENGTH             (sizeof(NormalStreamEA) - 1)


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
#define _STRM_CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_STREAMS, function, method, access)


#define IOCTL_STREAMS_GETMSG        _STRM_CTRL_CODE( 0, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS)

#define IOCTL_STREAMS_IOCTL         _STRM_CTRL_CODE( 1, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)

#define IOCTL_STREAMS_POLL          _STRM_CTRL_CODE( 2, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)

#define IOCTL_STREAMS_PUTMSG        _STRM_CTRL_CODE( 3, METHOD_BUFFERED, \
                                                        FILE_WRITE_ACCESS)

#define IOCTL_STREAMS_TDI_TEST      _STRM_CTRL_CODE(32, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)



struct queue;                               // forward declaration for ANSI C

/*
 * General buffer structure (putmsg, getmsg, etc)
 */

struct strbuf {
        int     maxlen;                 /* no. of bytes in buffer */
        int     len;                    /* no. of bytes returned */
        char    *buf;                   /* pointer to data */
};

/*
 * General ioctl
 */

struct strioctl {
	int 	ic_cmd;			/* command */
	int	ic_timout;		/* timeout value */
	int	ic_len;			/* length of data */
	char	*ic_dp;			/* pointer to data */
};


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer Record Structures
//
//
typedef struct _GETMSG_ARGS_INOUT_ {        // getmsg()
    int                     a_retval;       //  return value
    long                    a_flags;        //  0 or RS_HIPRI
    struct strbuf           a_ctlbuf;       //  (required)
    struct strbuf           a_databuf;      //  (required)
    char                    a_stuff[1];     //  a_ctlbuf.buf  (optional)
                                            //  a_databuf.buf (optional)
} GETMSG_ARGS_INOUT, *PGETMSG_ARGS_INOUT;


typedef struct _ISTR_ARGS_INOUT {           // ioctl(I_STR)
    int                     a_iocode;       //  I_STR, retval on return
    struct strioctl         a_strio;        //  (required)
    int                     a_unused[2];    //  (required) BUGBUG
    char                    a_stuff[1];     //  (optional)

} ISTR_ARGS_INOUT, *PISTR_ARGS_INOUT;


typedef struct _PUTMSG_ARGS_IN_ {           // ioctl(I_FDINSERT) and putmsg()
    int                     a_iocode;       //  I_FDINSERT or 0
    long                    a_flags;        //  0 or RS_HIPRI
    struct strbuf           a_ctlbuf;       //  (required)
    struct strbuf           a_databuf;      //  (required)

    union {                                 //  used only for I_FDINSERT
        HANDLE              i_fildes;       //      (optional)
        struct queue *      i_targetq;      //      for Stream Head Driver use
    } a_insert;

    int                     a_offset;       //  (optional)
    char                    a_stuff[1];     //  a_ctlbuf.buf  (optional)
                                            //  a_databuf.buf (optional)
} PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;


typedef struct _STRM_ARGS_OUT_ {            // generic return parameters
    int     a_retval;                       //  return value
    int     a_errno;                        //  errno if retval == -1

} STRM_ARGS_OUT, *PSTRM_ARGS_OUT;


#ifdef __cplusplus
}
#endif

#endif  // ifndef _NTDDSTRM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddvdsk.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddvdsk.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Virtual Disk device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDVDSK_
#define _NTDDVDSK_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_VDSK_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_VDSK_BASE                  FILE_DEVICE_VIRTUAL_DISK


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#ifdef __cplusplus
}
#endif

#endif   // _NTDDVDSK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddtape.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddtape.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Tape device.

Author:

    Mike Glass (mglass)

Revision History:

--*/

#ifndef _NTDDTAPE_
#define _NTDDTAPE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_TAPE_DEVICE_NAME "\\Device\\Tape"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_TAPE_BASE                 FILE_DEVICE_TAPE

#define IOCTL_TAPE_ERASE                CTL_CODE(IOCTL_TAPE_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TAPE_PREPARE              CTL_CODE(IOCTL_TAPE_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_WRITE_MARKS          CTL_CODE(IOCTL_TAPE_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TAPE_GET_POSITION         CTL_CODE(IOCTL_TAPE_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_SET_POSITION         CTL_CODE(IOCTL_TAPE_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_GET_DRIVE_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_SET_DRIVE_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TAPE_GET_MEDIA_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_SET_MEDIA_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_GET_STATUS           CTL_CODE(IOCTL_TAPE_BASE, 0x0009, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOCTL_TAPE_CREATE_PARTITION     CTL_CODE(IOCTL_TAPE_BASE, 0x000a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future with the IOCTL_STORAGE
// codes included below
//

#define IOCTL_TAPE_CHECK_VERIFY         CTL_CODE(IOCTL_TAPE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_MEDIA_REMOVAL        CTL_CODE(IOCTL_TAPE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_EJECT_MEDIA          CTL_CODE(IOCTL_TAPE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_LOAD_MEDIA           CTL_CODE(IOCTL_TAPE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_RESERVE              CTL_CODE(IOCTL_TAPE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_RELEASE              CTL_CODE(IOCTL_TAPE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_FIND_NEW_DEVICES     CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following file contains the IOCTL_STORAGE class ioctls
//

#include <ntddstor.h>

// begin_winnt begin_ntminitape


//
// IOCTL_TAPE_ERASE definitions
//

#define TAPE_ERASE_SHORT            0L
#define TAPE_ERASE_LONG             1L

typedef struct _TAPE_ERASE {
    ULONG Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//

#define TAPE_LOAD                   0L
#define TAPE_UNLOAD                 1L
#define TAPE_TENSION                2L
#define TAPE_LOCK                   3L
#define TAPE_UNLOCK                 4L
#define TAPE_FORMAT                 5L

typedef struct _TAPE_PREPARE {
    ULONG Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//

#define TAPE_SETMARKS               0L
#define TAPE_FILEMARKS              1L
#define TAPE_SHORT_FILEMARKS        2L
#define TAPE_LONG_FILEMARKS         3L

typedef struct _TAPE_WRITE_MARKS {
    ULONG Type;
    ULONG Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//

#define TAPE_ABSOLUTE_POSITION       0L
#define TAPE_LOGICAL_POSITION        1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L

typedef struct _TAPE_GET_POSITION {
    ULONG Type;
    ULONG Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//

#define TAPE_REWIND                 0L
#define TAPE_ABSOLUTE_BLOCK         1L
#define TAPE_LOGICAL_BLOCK          2L
#define TAPE_PSEUDO_LOGICAL_BLOCK   3L
#define TAPE_SPACE_END_OF_DATA      4L
#define TAPE_SPACE_RELATIVE_BLOCKS  5L
#define TAPE_SPACE_FILEMARKS        6L
#define TAPE_SPACE_SEQUENTIAL_FMKS  7L
#define TAPE_SPACE_SETMARKS         8L
#define TAPE_SPACE_SEQUENTIAL_SMKS  9L

typedef struct _TAPE_SET_POSITION {
    ULONG Method;
    ULONG Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

#define TAPE_DRIVE_FIXED            0x00000001
#define TAPE_DRIVE_SELECT           0x00000002
#define TAPE_DRIVE_INITIATOR        0x00000004

#define TAPE_DRIVE_ERASE_SHORT      0x00000010
#define TAPE_DRIVE_ERASE_LONG       0x00000020
#define TAPE_DRIVE_ERASE_BOP_ONLY   0x00000040
#define TAPE_DRIVE_ERASE_IMMEDIATE  0x00000080

#define TAPE_DRIVE_TAPE_CAPACITY    0x00000100
#define TAPE_DRIVE_TAPE_REMAINING   0x00000200
#define TAPE_DRIVE_FIXED_BLOCK      0x00000400
#define TAPE_DRIVE_VARIABLE_BLOCK   0x00000800

#define TAPE_DRIVE_WRITE_PROTECT    0x00001000
#define TAPE_DRIVE_EOT_WZ_SIZE      0x00002000

#define TAPE_DRIVE_ECC              0x00010000
#define TAPE_DRIVE_COMPRESSION      0x00020000
#define TAPE_DRIVE_PADDING          0x00040000
#define TAPE_DRIVE_REPORT_SMKS      0x00080000

#define TAPE_DRIVE_GET_ABSOLUTE_BLK 0x00100000
#define TAPE_DRIVE_GET_LOGICAL_BLK  0x00200000
#define TAPE_DRIVE_SET_EOT_WZ_SIZE  0x00400000

#define TAPE_DRIVE_EJECT_MEDIA      0x01000000
#define TAPE_DRIVE_CLEAN_REQUESTS   0x02000000
#define TAPE_DRIVE_SET_CMP_BOP_ONLY 0x04000000

#define TAPE_DRIVE_RESERVED_BIT     0x80000000  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

#define TAPE_DRIVE_LOAD_UNLOAD      0x80000001
#define TAPE_DRIVE_TENSION          0x80000002
#define TAPE_DRIVE_LOCK_UNLOCK      0x80000004
#define TAPE_DRIVE_REWIND_IMMEDIATE 0x80000008

#define TAPE_DRIVE_SET_BLOCK_SIZE   0x80000010
#define TAPE_DRIVE_LOAD_UNLD_IMMED  0x80000020
#define TAPE_DRIVE_TENSION_IMMED    0x80000040
#define TAPE_DRIVE_LOCK_UNLK_IMMED  0x80000080

#define TAPE_DRIVE_SET_ECC          0x80000100
#define TAPE_DRIVE_SET_COMPRESSION  0x80000200
#define TAPE_DRIVE_SET_PADDING      0x80000400
#define TAPE_DRIVE_SET_REPORT_SMKS  0x80000800

#define TAPE_DRIVE_ABSOLUTE_BLK     0x80001000
#define TAPE_DRIVE_ABS_BLK_IMMED    0x80002000
#define TAPE_DRIVE_LOGICAL_BLK      0x80004000
#define TAPE_DRIVE_LOG_BLK_IMMED    0x80008000

#define TAPE_DRIVE_END_OF_DATA      0x80010000
#define TAPE_DRIVE_RELATIVE_BLKS    0x80020000
#define TAPE_DRIVE_FILEMARKS        0x80040000
#define TAPE_DRIVE_SEQUENTIAL_FMKS  0x80080000

#define TAPE_DRIVE_SETMARKS         0x80100000
#define TAPE_DRIVE_SEQUENTIAL_SMKS  0x80200000
#define TAPE_DRIVE_REVERSE_POSITION 0x80400000
#define TAPE_DRIVE_SPACE_IMMEDIATE  0x80800000

#define TAPE_DRIVE_WRITE_SETMARKS   0x81000000
#define TAPE_DRIVE_WRITE_FILEMARKS  0x82000000
#define TAPE_DRIVE_WRITE_SHORT_FMKS 0x84000000
#define TAPE_DRIVE_WRITE_LONG_FMKS  0x88000000

#define TAPE_DRIVE_WRITE_MARK_IMMED 0x90000000
#define TAPE_DRIVE_FORMAT           0xA0000000
#define TAPE_DRIVE_FORMAT_IMMEDIATE 0xC0000000
#define TAPE_DRIVE_HIGH_FEATURES    0x80000000  //mask for high features flag

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG DefaultBlockSize;
    ULONG MaximumBlockSize;
    ULONG MinimumBlockSize;
    ULONG MaximumPartitionCount;
    ULONG FeaturesLow;
    ULONG FeaturesHigh;
    ULONG EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    ULONG BlockSize;
    ULONG PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

#define TAPE_FIXED_PARTITIONS       0L
#define TAPE_SELECT_PARTITIONS      1L
#define TAPE_INITIATOR_PARTITIONS   2L

typedef struct _TAPE_CREATE_PARTITION {
    ULONG Method;
    ULONG Count;
    ULONG Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;

// end_winnt end_ntminitape

#ifdef __cplusplus
}
#endif

#endif  // _NTDDTAPE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddtdi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddtdi.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Transport driver interface device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

    Dave Beaver (dbeaver) 5 June 1991
     add support for TDI version 2.0 -- associate_address,
                                        disassociate_address

--*/

#ifndef _NTDDTDI_
#define _NTDDTDI_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_TDI_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define _TDI_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_TRANSPORT, request, method, FILE_ANY_ACCESS)

#define IOCTL_TDI_ACCEPT                _TDI_CONTROL_CODE( 0, METHOD_BUFFERED )
#define IOCTL_TDI_CONNECT               _TDI_CONTROL_CODE( 1, METHOD_BUFFERED )
#define IOCTL_TDI_DISCONNECT            _TDI_CONTROL_CODE( 2, METHOD_BUFFERED )
#define IOCTL_TDI_LISTEN                _TDI_CONTROL_CODE( 3, METHOD_BUFFERED )
#define IOCTL_TDI_QUERY_INFORMATION     _TDI_CONTROL_CODE( 4, METHOD_OUT_DIRECT )
#define IOCTL_TDI_RECEIVE               _TDI_CONTROL_CODE( 5, METHOD_OUT_DIRECT )
#define IOCTL_TDI_RECEIVE_DATAGRAM      _TDI_CONTROL_CODE( 6, METHOD_OUT_DIRECT )
#define IOCTL_TDI_SEND                  _TDI_CONTROL_CODE( 7, METHOD_IN_DIRECT )
#define IOCTL_TDI_SEND_DATAGRAM         _TDI_CONTROL_CODE( 8, METHOD_IN_DIRECT )
#define IOCTL_TDI_SET_EVENT_HANDLER     _TDI_CONTROL_CODE( 9, METHOD_BUFFERED )
#define IOCTL_TDI_SET_INFORMATION       _TDI_CONTROL_CODE( 10, METHOD_IN_DIRECT )
#define IOCTL_TDI_ASSOCIATE_ADDRESS     _TDI_CONTROL_CODE( 11, METHOD_BUFFERED )
#define IOCTL_TDI_DISASSOCIATE_ADDRESS  _TDI_CONTROL_CODE( 12, METHOD_BUFFERED )
#define IOCTL_TDI_ACTION                _TDI_CONTROL_CODE( 13, METHOD_OUT_DIRECT )

#ifdef __cplusplus
}
#endif

#endif // ndef _NTDDTDI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddstor.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddstor.h

Abstract:

    This is the include file that defines all common constants and types
    accessing the storage class drivers

Author:

    Peter Wieland 19-Jun-1996

Revision History:

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddstor.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddstor.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

// begin_wioctlguids
DEFINE_GUID(DiskClassGuid,               0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(CdRomClassGuid,              0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(PartitionClassGuid,          0x53f5630aL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(TapeClassGuid,               0x53f5630bL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(WriteOnceDiskClassGuid,      0x53f5630cL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(VolumeClassGuid,             0x53f5630dL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(MediumChangerClassGuid,      0x53f56310L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(FloppyClassGuid,             0x53f56311L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(CdChangerClassGuid,          0x53f56312L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(StoragePortClassGuid,        0x2accfe60L, 0xc130, 0x11d2, 0xb0, 0x82, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
// end_wioctlguids
#endif

// begin_winioctl

#ifndef _NTDDSTOR_H_
#define _NTDDSTOR_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// IoControlCode values for storage devices
//

#define IOCTL_STORAGE_BASE FILE_DEVICE_MASS_STORAGE

//
// The following device control codes are common for all class drivers.  They
// should be used in place of the older IOCTL_DISK, IOCTL_CDROM and IOCTL_TAPE
// common codes
//

#define IOCTL_STORAGE_CHECK_VERIFY     CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_CHECK_VERIFY2    CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MEDIA_REMOVAL    CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECT_MEDIA      CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA       CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA2      CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_RESERVE          CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RELEASE          CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_FIND_NEW_DEVICES CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_STORAGE_EJECTION_CONTROL CTL_CODE(IOCTL_STORAGE_BASE, 0x0250, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MCN_CONTROL      CTL_CODE(IOCTL_STORAGE_BASE, 0x0251, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_STORAGE_GET_MEDIA_TYPES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_TYPES_EX CTL_CODE(IOCTL_STORAGE_BASE, 0x0301, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_STORAGE_RESET_BUS        CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RESET_DEVICE     CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_STORAGE_GET_DEVICE_NUMBER CTL_CODE(IOCTL_STORAGE_BASE, 0x0420, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_STORAGE_PREDICT_FAILURE CTL_CODE(IOCTL_STORAGE_BASE, 0x0440, METHOD_BUFFERED, FILE_ANY_ACCESS)

// end_winioctl


#define IOCTL_STORAGE_QUERY_PROPERTY   CTL_CODE(IOCTL_STORAGE_BASE, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS)


// begin_winioctl

//
// These ioctl codes are obsolete.  They are defined here to avoid resuing them
// and to allow class drivers to respond to them more easily.
//

#define OBSOLETE_IOCTL_STORAGE_RESET_BUS        CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define OBSOLETE_IOCTL_STORAGE_RESET_DEVICE     CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL_STORAGE_GET_DEVICE_NUMBER
//
// input - none
//
// output - STORAGE_DEVICE_NUMBER structure
//          The values in the STORAGE_DEVICE_NUMBER structure are guaranteed
//          to remain unchanged until the system is rebooted.  They are not
//          guaranteed to be persistant across boots.
//

typedef struct _STORAGE_DEVICE_NUMBER {

    //
    // The FILE_DEVICE_XXX type for this device.
    //

    DEVICE_TYPE DeviceType;

    //
    // The number of this device
    //

    ULONG       DeviceNumber;

    //
    // If the device is partitionable, the partition number of the device.
    // Otherwise -1
    //

    ULONG       PartitionNumber;
} STORAGE_DEVICE_NUMBER, *PSTORAGE_DEVICE_NUMBER;

//
// Define the structures for scsi resets
//

typedef struct _STORAGE_BUS_RESET_REQUEST {
    UCHAR PathId;
} STORAGE_BUS_RESET_REQUEST, *PSTORAGE_BUS_RESET_REQUEST;

//
// IOCTL_STORAGE_MEDIA_REMOVAL disables the mechanism
// on a storage device that ejects media. This function
// may or may not be supported on storage devices that
// support removable media.
//
// TRUE means prevent media from being removed.
// FALSE means allow media removal.
//

typedef struct _PREVENT_MEDIA_REMOVAL {
    BOOLEAN PreventMediaRemoval;
} PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;

// begin_ntminitape


typedef struct _TAPE_STATISTICS {
    ULONG Version;
    ULONG Flags;
    LARGE_INTEGER RecoveredWrites;
    LARGE_INTEGER UnrecoveredWrites;
    LARGE_INTEGER RecoveredReads;
    LARGE_INTEGER UnrecoveredReads;
    UCHAR         CompressionRatioReads;
    UCHAR         CompressionRatioWrites;
} TAPE_STATISTICS, *PTAPE_STATISTICS;

#define RECOVERED_WRITES_VALID   0x00000001
#define UNRECOVERED_WRITES_VALID 0x00000002
#define RECOVERED_READS_VALID    0x00000004
#define UNRECOVERED_READS_VALID  0x00000008
#define WRITE_COMPRESSION_INFO_VALID  0x00000010
#define READ_COMPRESSION_INFO_VALID   0x00000020

typedef struct _TAPE_GET_STATISTICS {
    ULONG Operation;
} TAPE_GET_STATISTICS, *PTAPE_GET_STATISTICS;

#define TAPE_RETURN_STATISTICS 0L
#define TAPE_RETURN_ENV_INFO   1L
#define TAPE_RESET_STATISTICS  2L

//
// IOCTL_STORAGE_GET_MEDIA_TYPES_EX will return an array of DEVICE_MEDIA_INFO
// structures, one per supported type, embedded in the GET_MEDIA_TYPES struct.
//

typedef enum _STORAGE_MEDIA_TYPE {
    //
    // Following are defined in ntdddisk.h in the MEDIA_TYPE enum
    //
    // Unknown,                // Format is unknown
    // F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    // F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    // F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    // F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    // F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    // F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    // F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    // F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    // F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    // F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    // RemovableMedia,         // Removable media other than floppy
    // FixedMedia,             // Fixed hard disk media
    // F3_120M_512,            // 3.5", 120M Floppy
    // F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    // F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    // F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    // F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    // F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    // F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    // F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    // F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    // F8_256_128,             // 8",     256KB,  128 bytes/sector
    //

    DDS_4mm = 0x20,            // Tape - DAT DDS1,2,... (all vendors)
    MiniQic,                   // Tape - miniQIC Tape
    Travan,                    // Tape - Travan TR-1,2,3,...
    QIC,                       // Tape - QIC
    MP_8mm,                    // Tape - 8mm Exabyte Metal Particle
    AME_8mm,                   // Tape - 8mm Exabyte Advanced Metal Evap
    AIT1_8mm,                  // Tape - 8mm Sony AIT1
    DLT,                       // Tape - DLT Compact IIIxt, IV
    NCTP,                      // Tape - Philips NCTP
    IBM_3480,                  // Tape - IBM 3480
    IBM_3490E,                 // Tape - IBM 3490E
    IBM_Magstar_3590,          // Tape - IBM Magstar 3590
    IBM_Magstar_MP,            // Tape - IBM Magstar MP
    STK_DATA_D3,               // Tape - STK Data D3
    SONY_DTF,                  // Tape - Sony DTF
    DV_6mm,                    // Tape - 6mm Digital Video
    DMI,                       // Tape - Exabyte DMI and compatibles
    SONY_D2,                   // Tape - Sony D2S and D2L
    CLEANER_CARTRIDGE,         // Cleaner - All Drive types that support Drive Cleaners
    CD_ROM,                    // Opt_Disk - CD
    CD_R,                      // Opt_Disk - CD-Recordable (Write Once)
    CD_RW,                     // Opt_Disk - CD-Rewriteable
    DVD_ROM,                   // Opt_Disk - DVD-ROM
    DVD_R,                     // Opt_Disk - DVD-Recordable (Write Once)
    DVD_RW,                    // Opt_Disk - DVD-Rewriteable
    MO_3_RW,                   // Opt_Disk - 3.5" Rewriteable MO Disk
    MO_5_WO,                   // Opt_Disk - MO 5.25" Write Once
    MO_5_RW,                   // Opt_Disk - MO 5.25" Rewriteable (not LIMDOW)
    MO_5_LIMDOW,               // Opt_Disk - MO 5.25" Rewriteable (LIMDOW)
    PC_5_WO,                   // Opt_Disk - Phase Change 5.25" Write Once Optical
    PC_5_RW,                   // Opt_Disk - Phase Change 5.25" Rewriteable
    PD_5_RW,                   // Opt_Disk - PhaseChange Dual Rewriteable
    ABL_5_WO,                  // Opt_Disk - Ablative 5.25" Write Once Optical
    PINNACLE_APEX_5_RW,        // Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical
    SONY_12_WO,                // Opt_Disk - Sony 12" Write Once
    PHILIPS_12_WO,             // Opt_Disk - Philips/LMS 12" Write Once
    HITACHI_12_WO,             // Opt_Disk - Hitachi 12" Write Once
    CYGNET_12_WO,              // Opt_Disk - Cygnet/ATG 12" Write Once
    KODAK_14_WO,               // Opt_Disk - Kodak 14" Write Once
    MO_NFR_525,                // Opt_Disk - Near Field Recording (Terastor)
    NIKON_12_RW,               // Opt_Disk - Nikon 12" Rewriteable
    IOMEGA_ZIP,                // Mag_Disk - Iomega Zip
    IOMEGA_JAZ,                // Mag_Disk - Iomega Jaz
    SYQUEST_EZ135,             // Mag_Disk - Syquest EZ135
    SYQUEST_EZFLYER,           // Mag_Disk - Syquest EzFlyer
    SYQUEST_SYJET,             // Mag_Disk - Syquest SyJet
    AVATAR_F2,                 // Mag_Disk - 2.5" Floppy
    MP2_8mm,                   // Tape - 8mm Hitachi
    DST_S,                     // Ampex DST Small Tapes
    DST_M,                     // Ampex DST Medium Tapes
    DST_L,                     // Ampex DST Large Tapes
    VXATape_1,                 // Ecrix 8mm Tape
    VXATape_2,                 // Ecrix 8mm Tape
    STK_EAGLE,                 // STK Eagle
    LTO_Ultrium,               // IBM, HP, Seagate LTO Ultrium
    LTO_Accelis                // IBM, HP, Seagate LTO Accelis
} STORAGE_MEDIA_TYPE, *PSTORAGE_MEDIA_TYPE;

#define MEDIA_ERASEABLE         0x00000001
#define MEDIA_WRITE_ONCE        0x00000002
#define MEDIA_READ_ONLY         0x00000004
#define MEDIA_READ_WRITE        0x00000008

#define MEDIA_WRITE_PROTECTED   0x00000100
#define MEDIA_CURRENTLY_MOUNTED 0x80000000

//
// Define the different storage bus types
// Bus types below 128 (0x80) are reserved for Microsoft use
//

typedef enum _STORAGE_BUS_TYPE {
    BusTypeUnknown = 0x00,
    BusTypeScsi,
    BusTypeAtapi,
    BusTypeAta,
    BusType1394,
    BusTypeSsa,
    BusTypeFibre,
    BusTypeUsb,
    BusTypeRAID,
    BusTypeMaxReserved = 0x7F
} STORAGE_BUS_TYPE, *PSTORAGE_BUS_TYPE;

typedef struct _DEVICE_MEDIA_INFO {
    union {
        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } DiskInfo;

        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } RemovableDiskInfo;

        struct {
            STORAGE_MEDIA_TYPE MediaType;
            ULONG   MediaCharacteristics; // Bitmask of MEDIA_XXX values.
            ULONG   CurrentBlockSize;
            STORAGE_BUS_TYPE BusType;

            //
            // Bus specific information describing the medium supported.
            //

            union {
                struct {
                    UCHAR MediumType;
                    UCHAR DensityCode;
                } ScsiInformation;
            } BusSpecificData;

        } TapeInfo;
    } DeviceSpecific;
} DEVICE_MEDIA_INFO, *PDEVICE_MEDIA_INFO;

typedef struct _GET_MEDIA_TYPES {
    ULONG DeviceType;              // FILE_DEVICE_XXX values
    ULONG MediaInfoCount;
    DEVICE_MEDIA_INFO MediaInfo[1];
} GET_MEDIA_TYPES, *PGET_MEDIA_TYPES;


//
// IOCTL_STORAGE_PREDICT_FAILURE
//
// input - none
//
// output - STORAGE_PREDICT_FAILURE structure
//          PredictFailure returns zero if no failure predicted and non zero
//                         if a failure is predicted.
//
//          VendorSpecific returns 512 bytes of vendor specific information
//                         if a failure is predicted
//
typedef struct _STORAGE_PREDICT_FAILURE
{
    ULONG PredictFailure;
    UCHAR VendorSpecific[512];
} STORAGE_PREDICT_FAILURE, *PSTORAGE_PREDICT_FAILURE;

// end_ntminitape
// end_winioctl

//
// Property Query Structures
//

//
// IOCTL_STORAGE_QUERY_PROPERTY
//
// Input Buffer:
//      a STORAGE_PROPERTY_QUERY structure which describes what type of query
//      is being done, what property is being queried for, and any additional
//      parameters which a particular property query requires.
//
//  Output Buffer:
//      Contains a buffer to place the results of the query into.  Since all
//      property descriptors can be cast into a STORAGE_DESCRIPTOR_HEADER,
//      the IOCTL can be called once with a small buffer then again using
//      a buffer as large as the header reports is necessary.
//


//
// Types of queries
//

typedef enum _STORAGE_QUERY_TYPE {
    PropertyStandardQuery = 0,          // Retrieves the descriptor
    PropertyExistsQuery,                // Used to test whether the descriptor is supported
    PropertyMaskQuery,                  // Used to retrieve a mask of writeable fields in the descriptor
    PropertyQueryMaxDefined     // use to validate the value
} STORAGE_QUERY_TYPE, *PSTORAGE_QUERY_TYPE;

//
// define some initial property id's
//

typedef enum _STORAGE_PROPERTY_ID {
    StorageDeviceProperty = 0,
    StorageAdapterProperty
} STORAGE_PROPERTY_ID, *PSTORAGE_PROPERTY_ID;

//
// Query structure - additional parameters for specific queries can follow
// the header
//

typedef struct _STORAGE_PROPERTY_QUERY {

    //
    // ID of the property being retrieved
    //

    STORAGE_PROPERTY_ID PropertyId;

    //
    // Flags indicating the type of query being performed
    //

    STORAGE_QUERY_TYPE QueryType;

    //
    // Space for additional parameters if necessary
    //

    UCHAR AdditionalParameters[1];

} STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;

//
// Standard property descriptor header.  All property pages should use this
// as their first element or should contain these two elements
//

typedef struct _STORAGE_DESCRIPTOR_HEADER {

    ULONG Version;

    ULONG Size;

} STORAGE_DESCRIPTOR_HEADER, *PSTORAGE_DESCRIPTOR_HEADER;

//
// Device property descriptor - this is really just a rehash of the inquiry
// data retrieved from a scsi device
//
// This may only be retrieved from a target device.  Sending this to the bus
// will result in an error
//

typedef struct _STORAGE_DEVICE_DESCRIPTOR {

    //
    // Sizeof(STORAGE_DEVICE_DESCRIPTOR)
    //

    ULONG Version;

    //
    // Total size of the descriptor, including the space for additional
    // data and id strings
    //

    ULONG Size;

    //
    // The SCSI-2 device type
    //

    UCHAR DeviceType;

    //
    // The SCSI-2 device type modifier (if any) - this may be zero
    //

    UCHAR DeviceTypeModifier;

    //
    // Flag indicating whether the device's media (if any) is removable.  This
    // field should be ignored for media-less devices
    //

    BOOLEAN RemovableMedia;

    //
    // Flag indicating whether the device can support mulitple outstanding
    // commands.  The actual synchronization in this case is the responsibility
    // of the port driver.
    //

    BOOLEAN CommandQueueing;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // vendor id string.  For devices with no such ID this will be zero
    //

    ULONG VendorIdOffset;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // product id string.  For devices with no such ID this will be zero
    //

    ULONG ProductIdOffset;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // product revision string.  For devices with no such string this will be
    // zero
    //

    ULONG ProductRevisionOffset;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // serial number.  For devices with no serial number this will be zero
    //

    ULONG SerialNumberOffset;

    //
    // Contains the bus type (as defined above) of the device.  It should be
    // used to interpret the raw device properties at the end of this structure
    // (if any)
    //

    STORAGE_BUS_TYPE BusType;

    //
    // The number of bytes of bus-specific data which have been appended to
    // this descriptor
    //

    ULONG RawPropertiesLength;

    //
    // Place holder for the first byte of the bus specific property data
    //

    UCHAR RawDeviceProperties[1];

} STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;


//
// Adapter properties
//
// This descriptor can be retrieved from a target device object of from the
// device object for the bus.  Retrieving from the target device object will
// forward the request to the underlying bus
//

typedef struct _STORAGE_ADAPTER_DESCRIPTOR {

    ULONG Version;

    ULONG Size;

    ULONG MaximumTransferLength;

    ULONG MaximumPhysicalPages;

    ULONG AlignmentMask;

    BOOLEAN AdapterUsesPio;

    BOOLEAN AdapterScansDown;

    BOOLEAN CommandQueueing;

    BOOLEAN AcceleratedTransfer;

    BOOLEAN BusType;

    USHORT BusMajorVersion;

    USHORT BusMinorVersion;

} STORAGE_ADAPTER_DESCRIPTOR, *PSTORAGE_ADAPTER_DESCRIPTOR;

// begin_winioctl

#ifdef __cplusplus
}
#endif

#endif // _NTDDSTOR_H_
// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ntddvdeo.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ddvdeo.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Video device.

Author:

    Andre Vachon (andreva) 21-Jan-1992

Revision History:

--*/

#ifndef _NTDDVDEO_
#define _NTDDVDEO_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <tvout.h>

//
// VideoIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// Name used to create the miniport logical device names
//

#define VIDEO_DEVICE_NAME "DISPLAY%d"
#define WVIDEO_DEVICE_NAME L"DISPLAY%d"

//
// Display output interfaces
//

// DEFINE_GUID(GUID_DISPLAY_OUTPUT_INTERFACE_STANDARD, 0x96304D9F, 0x54b5, 0x11d1, 0x8b, 0x0f, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);


//
// The first set of IOCTLs are handle by the port driver and never seen
// by the miniport.
//

#define IOCTL_VIDEO_ENABLE_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x00, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_DISABLE_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x01, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REGISTER_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x02, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x03, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x04, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MONITOR_DEVICE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x05, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENUM_MONITOR_PDO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x06, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_INIT_WIN32K_CALLBACKS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x07, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x08, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_IS_VGA_DEVICE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x09, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// All these IOCTL's must be both handled by the port and miniport since
// they require processing by both parties.
//
#define IOCTL_VIDEO_SAVE_HARDWARE_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x80, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESTORE_HARDWARE_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x81, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// All these IOCTL's are public and must/can be handled by the miniport
// driver
//

#define IOCTL_VIDEO_QUERY_AVAIL_MODES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESET_DEVICE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x104, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_LOAD_AND_SET_FONT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x105, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_PALETTE_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_COLOR_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x107, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_CURSOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x108, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_DISABLE_CURSOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURSOR_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURSOR_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10b, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10d, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_POINTER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_DISABLE_POINTER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_POINTER_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x110, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x111, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_POINTER_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x112, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x113, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x114, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_BANK_SELECT_CODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x115, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x116, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x117, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x118, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x119, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11a, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// New IOCTLs defined for product 1.0A
//

#define IOCTL_VIDEO_SET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11b, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11c, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SHARE_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11e, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_COLOR_LUT_DATA \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11f, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_CHILD_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x120, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x121, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x122, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// All these IOCTL's are handled by the Far East Full Screen Video driver
//

#define IOCTL_FSVIDEO_COPY_FRAME_BUFFER \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x200, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x201, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x202, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_SET_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x203, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_SET_SCREEN_INFORMATION \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x204, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_SET_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x205, METHOD_BUFFERED, FILE_ANY_ACCESS)



//
// Many of the video ICOTLs are modal. When ever the palette is set, or the
// cursor is set or queried, it is done for the current mode.
//
// Modal specifies that the operation is only valid within a mode. Once a
// set mode operation is performed, the state associated to the modal IOCTL
// has been destroyed or reinitialized.
// Non-modal IOCTLs have their state preserved across set-mode operations.
//
// Optional IOCTLs are IOCTLs the miniport can optionally support. If the
// miniport does not support the IOCTL, it should return the appropriate
// error status.
// Required IOCTLs must be implemented in a miniport in order for the system
// to system properly.
//
// IOCTL_VIDEO_ENABLE_VDM                       Non-Modal    Private(1)
// IOCTL_VIDEO_DISABLE_VDM                      Non-Modal    Private(1)
// IOCTL_VIDEO_REGISTER_VDM                     Non-Modal    Private(1)
//
// IOCTL_VIDEO_SAVE_HARDWARE_STATE              Non-Modal    Required(2)
// IOCTL_VIDEO_RESTORE_HARDWARE_STATE           Non-Modal    Required(2)
//
// IOCTL_VIDEO_QUERY_AVAIL_MODES                Non-Modal    Required
// IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES            Non-Modal    Required
// IOCTL_VIDEO_QUERY_CURRENT_MODE               Modal        Required
// IOCTL_VIDEO_SET_CURRENT_MODE                 Non-Modal    Required
// IOCTL_VIDEO_RESET_DEVICE                     Non-Modal    Required
//
// IOCTL_VIDEO_LOAD_AND_SET_FONT                Modal        Required(2)
//
// IOCTL_VIDEO_SET_PALETTE_REGISTERS            Modal        Required(2)
// IOCTL_VIDEO_SET_COLOR_REGISTERS              Modal        Required(3)
//
// IOCTL_VIDEO_ENABLE_CURSOR                    Modal        Required(2)
// IOCTL_VIDEO_DISABLE_CURSOR                   Modal        Required(2)
// IOCTL_VIDEO_SET_CURSOR_ATTR                  Modal        Required(2)
// IOCTL_VIDEO_QUERY_CURSOR_ATTR                Modal        Required(2)
// IOCTL_VIDEO_SET_CURSOR_POSITION              Modal        Required(2)
// IOCTL_VIDEO_QUERY_CURSOR_POSITION            Modal        Required(2)
//
// IOCTL_VIDEO_ENABLE_POINTER                   Modal        Optional
// IOCTL_VIDEO_DISABLE_POINTER                  Modal        Optional
// IOCTL_VIDEO_SET_POINTER_ATTR                 Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_ATTR               Modal        Optional
// IOCTL_VIDEO_SET_POINTER_POSITION             Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_POSITION           Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES       Non-Modal    Optional
//
// IOCTL_VIDEO_GET_BANK_SELECT_CODE             Modal        Required(2)
//
// IOCTL_VIDEO_MAP_VIDEO_MEMORY                 Special(4)   Required
// IOCTL_VIDEO_UNMAP_VIDEO_MEMORY               Non-Modal    Required
// IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES       Non-Modal    Optional
// IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES        Non-Modal    Optional
//
// IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES         Non-Modal    Optional
//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT             Non-Modal    Optional
// IOCTL_VIDEO_GET_POWER_MANAGEMENT             Non-Modal    Optional
//
// IOCTL_VIDEO_SET_COLOR_LUT_DATA               Modal        Optional

//
// (1) Private means the IOCTL is completely implemeted within the port driver
//     and the miniport does not need to support it.
//
// (2) These Required functions are for "Vga Compatible" miniports. They are
//     Optional for other, non vga-compatible (i.e frame buffers) drivers.
//     VGA compatible means here that the miniport implements all the VGA
//     functionality and that the VgaCompatible flag for the miniport in the
//     registry parameters is turned on.
//
// (3) This IOCTL is required if the device has a color lookup table (also
//     commonly called palette) the PALETTE IOCTL is used for VGA while the
//     COLOR IOCTL is the more general IOCTL that is called by the display
//     driver or application to set the colors in the devices internal
//     lookup table
//
// (4) This IOCTL is both modal and non-modal. It should map all of video
//     memory in the caller's address space. A set mode MUST NOT cause the
//     video memory to change location - in this sense it is non-modal.
//     However, this IOCTL returns the location size of the frame buffer within
//     video memory, and the frame buffer size and location may vary from mode
//     to mode - so that information is modal.
//


//
// Any IOCTL that returns information should return in the status block the
// size of the data returned.
// If the output buffer was too small, an error should be returned.
//
//
//
//



//
// IOCTL_VIDEO_ENABLE_VDM
// IOCTL_VIDEO_DISABLE_VDM
// IOCTL_VIDEO_REGISTER_VDM
//
// These IOCTLs are used to enable or disable a VDM's access to the video
// hardware. This call will cause the real video frame buffer to be mapped
// into the VDM's address space and get the video validator connected to the
// V86 emulator for direct video register access.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_VDM {
    HANDLE ProcessHandle;
} VIDEO_VDM, *PVIDEO_VDM;

//
//ProcessHandle - Handle to the process for which this request must be
//    performed. This is required because the console calls the miniport on
//    the behalf of the VDM process; we are not performing this request in
//    the context of the current caller.
//


typedef struct _VIDEO_REGISTER_VDM {
    ULONG MinimumStateSize;
} VIDEO_REGISTER_VDM, *PVIDEO_REGISTER_VDM;

//
//MinimumStateSize - Output value determining the minimum size required to
//    store the video hardware state when performing SAVE_HARDWARE_SATE or
//    RESTORE_HARDWARE_STATE Ioctls.
//


//
// IOCTL_VIDEO_ENUM_MONITOR_PDO
//
// Descriptor of monitor devices
//

typedef struct tagVIDEO_MONITOR_DEVICE {
    ULONG   active;     // The monitor is ON/OFF
    HANDLE  pdo;        // Monitor device handle
    ULONG   HwID;
} VIDEO_MONITOR_DEVICE, *PVIDEO_MONITOR_DEVICE;


//
// IOCTL_VIDEO_INIT_WIN32K_CALLBACKS
//
// List of function pointers used to make callbacks to win32k
//

typedef enum _VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE {
    VideoPowerNotifyCallout = 1,
    VideoDisplaySwitchCallout,
    VideoEnumChildPdoNotifyCallout,
    VideoFindAdapterCallout,
    VideoWakeupCallout
} VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE;


typedef struct _VIDEO_WIN32K_CALLBACKS_PARAMS {
    VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE CalloutType;
    PVOID   PhysDisp;
    ULONG_PTR Param;
    LONG    Status;
} VIDEO_WIN32K_CALLBACKS_PARAMS, *PVIDEO_WIN32K_CALLBACKS_PARAMS;


typedef
VOID
(*PVIDEO_WIN32K_CALLOUT) (
    IN PVOID Params
    );


typedef struct _VIDEO_WIN32K_CALLBACKS {
    PVOID                 PhysDisp;
    PVIDEO_WIN32K_CALLOUT Callout;
    ULONG                 bACPI;
    HANDLE                pPhysDeviceObject;
} VIDEO_WIN32K_CALLBACKS, *PVIDEO_WIN32K_CALLBACKS;


//
// Second set of structures
//

//
// These IOCTLs are used by the VDM and the console to communicate state
// changes between the VDM and the kernel video driver.
//
// IOCTL_VIDEO_SAVE_HARDWARE_STATE -
// IOCTL_VIDEO_RESTORE_HARDWARE_STATE -
//
//
// This structure is at the start of the block used when saving or restoring
// the state of the video hardware using ConsoleHardwareState().
// the ULONG are offset to the location of the rest of the data. That data
// is stored within the same memory block pointed to by the
// VIDEO_HARDWARE_STATE structure, right after this header.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_HARDWARE_STATE_HEADER {
    ULONG Length;
    UCHAR PortValue[0x30];
    ULONG AttribIndexDataState;
    ULONG BasicSequencerOffset;
    ULONG BasicCrtContOffset;
    ULONG BasicGraphContOffset;
    ULONG BasicAttribContOffset;
    ULONG BasicDacOffset;
    ULONG BasicLatchesOffset;
    ULONG ExtendedSequencerOffset;
    ULONG ExtendedCrtContOffset;
    ULONG ExtendedGraphContOffset;
    ULONG ExtendedAttribContOffset;
    ULONG ExtendedDacOffset;
    ULONG ExtendedValidatorStateOffset;
    ULONG ExtendedMiscDataOffset;
    ULONG PlaneLength;
    ULONG Plane1Offset;
    ULONG Plane2Offset;
    ULONG Plane3Offset;
    ULONG Plane4Offset;
    ULONG VGAStateFlags;
    ULONG DIBOffset;
    ULONG DIBBitsPerPixel;
    ULONG DIBXResolution;
    ULONG DIBYResolution;
    ULONG DIBXlatOffset;
    ULONG DIBXlatLength;
} VIDEO_HARDWARE_STATE_HEADER, *PVIDEO_HARDWARE_STATE_HEADER;

//
// defines for VGAStateFlags
//

#define VIDEO_STATE_NON_STANDARD_VGA       0x00000001
#define VIDEO_STATE_UNEMULATED_VGA_STATE   0x00000002
#define VIDEO_STATE_PACKED_CHAIN4_MODE     0x00000004


typedef struct _VIDEO_HARDWARE_STATE {
    PVIDEO_HARDWARE_STATE_HEADER StateHeader;
    ULONG StateLength;
} VIDEO_HARDWARE_STATE, *PVIDEO_HARDWARE_STATE;

//
//Length - Length of the basic structure. Used for versioning purposes. The
//    length field should be initialized to be equal to
//    sizeof(VIDEO_HARDWARE_STATE_HEADER).
//
//PortValue - Array of entries containing the data values for port 3B0 through
//    3DF.
//
//AttribIndexDataState - State of the attribute index register.
//
//BasicSequencerOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    sequencer register set of the VGA.
//
//BasicCrtContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    CRT register set of the VGA.
//
//BasicGraphContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    graphics controller register set of the VGA.
//
//BasicAttribContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    attribute controller register set of the VGA.
//
//BasicDacOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    DAC registers of the VGA.
//
//BasicLatchesOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    latches of the VGA.
//
//ExtendedSequencerOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    sequencer register set of the VGA.
//
//ExtendedCrtContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    CRT register set of the VGA.
//
//ExtendedGraphContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    graphics controller register set of the VGA.
//
//ExtendedAttribContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    attribute controller register set of the VGA.
//
//ExtendedDacOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    DAC registers of the VGA.
//
//ExtendedValidatorStateOffset - Offset, in bytes, from the beginning of the
//    structure, to an area reserved for the miniport to put the unemulated
//    save state that the miniport uses to perform instruction validation for
//    DOS apps.
//
//ExtendedMiscDataOffset - Offset, in bytes, from the beginning of the structure,
//    to an area reserved for the use of the miniport.
//
//PlaneLength - Length of each of the following plane (if present)
//
//Plane1Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the first plane of video memory.
//
//Plane2Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the second plane of video memory.
//
//Plane3Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the third plane of video memory.
//
//Plane4Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the fourth plane of video memory.
//
//VGAStateFlags - Flags used for the interpretation of the VGA state.
//    VIDEO_STATE_NON_STANDARD_VGA is set when the set of registers the VGA
//        returns is not the basic set (all super vga's are not