Vtbl -> put_AllowClientToStartAndStop(This,newVal) ) 

#define IWMSBroadcastPublishingPoint_get_BroadcastDataSinks(This,pVal)	\
    ( (This)->lpVtbl -> get_BroadcastDataSinks(This,pVal) ) 

#define IWMSBroadcastPublishingPoint_get_SharedPlaylist(This,pVal)	\
    ( (This)->lpVtbl -> get_SharedPlaylist(This,pVal) ) 

#define IWMSBroadcastPublishingPoint_StartWithoutData(This)	\
    ( (This)->lpVtbl -> StartWithoutData(This) ) 

#define IWMSBroadcastPublishingPoint_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IWMSBroadcastPublishingPoint_StartArchive(This)	\
    ( (This)->lpVtbl -> StartArchive(This) ) 

#define IWMSBroadcastPublishingPoint_get_BroadcastStatus(This,pVal)	\
    ( (This)->lpVtbl -> get_BroadcastStatus(This,pVal) ) 

#define IWMSBroadcastPublishingPoint_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IWMSBroadcastPublishingPoint_StopArchive(This)	\
    ( (This)->lpVtbl -> StopArchive(This) ) 

#define IWMSBroadcastPublishingPoint_ExportXML(This,bstrXMLFileName)	\
    ( (This)->lpVtbl -> ExportXML(This,bstrXMLFileName) ) 

#define IWMSBroadcastPublishingPoint_get_UpTime(This,pVal)	\
    ( (This)->lpVtbl -> get_UpTime(This,pVal) ) 

#define IWMSBroadcastPublishingPoint_get_AnnouncementStreamFormats(This,ppFileNames)	\
    ( (This)->lpVtbl -> get_AnnouncementStreamFormats(This,ppFileNames) ) 

#define IWMSBroadcastPublishingPoint_Announce(This)	\
    ( (This)->lpVtbl -> Announce(This) ) 

#define IWMSBroadcastPublishingPoint_AnnounceToNSCFile(This,bstrDestinationFileName,fOverwriteFlag)	\
    ( (This)->lpVtbl -> AnnounceToNSCFile(This,bstrDestinationFileName,fOverwriteFlag) ) 

#define IWMSBroadcastPublishingPoint_AnnounceToNSCStream(This,ppNSCAnnounceStream)	\
    ( (This)->lpVtbl -> AnnounceToNSCStream(This,ppNSCAnnounceStream) ) 

#define IWMSBroadcastPublishingPoint_get_BufferSetting(This,pVal)	\
    ( (This)->lpVtbl -> get_BufferSetting(This,pVal) ) 

#define IWMSBroadcastPublishingPoint_put_BufferSetting(This,newVal)	\
    ( (This)->lpVtbl -> put_BufferSetting(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSBroadcastPublishingPoint_INTERFACE_DEFINED__ */


#ifndef __IWMSBroadcastPublishingPoint2_INTERFACE_DEFINED__
#define __IWMSBroadcastPublishingPoint2_INTERFACE_DEFINED__

/* interface IWMSBroadcastPublishingPoint2 */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSBroadcastPublishingPoint2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c94e9af0-f12d-4bff-b01a-1ce6d7f5d303")
    IWMSBroadcastPublishingPoint2 : public IWMSBroadcastPublishingPoint
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowStartupProfile( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowStartupProfile( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableStartVRootOnServiceStart( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableStartVRootOnServiceStart( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBroadcastPublishingPoint2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientsToConnect )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientsToConnect )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCounters )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPointCurrentCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventHandlers )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Limits )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPointLimits **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileDescriptions )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [defaultvalue][in] */ __RPC__in BSTR RelativePath,
            /* [retval][out] */ __RPC__deref_out_opt IWMSFileDescriptions **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSOutgoingDistributionConnections **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeakCounters )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPointPeakCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Players )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlayers **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCounters )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPointTotalCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out WMS_PUBLISHING_POINT_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WrapperPath )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WrapperPath )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticators )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out WMS_PUBLISHING_POINT_STATUS *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableWrapperPath )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableWrapperPath )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamFilters )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DistributionUserName )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetDistributionUserNamePassword )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [string][in] */ __RPC__in wchar_t *newUserName,
            /* [string][in] */ __RPC__in wchar_t *newUserPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheProxyExpiration )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CacheProxyExpiration )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDistributionPasswordSet )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlayerSideDiskCaching )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlayerSideDiskCaching )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableFEC )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableFEC )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowStreamSplitting )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowStreamSplitting )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientToStartAndStop )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientToStartAndStop )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BroadcastDataSinks )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SharedPlaylist )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlaylist **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartWithoutData )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartArchive )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BroadcastStatus )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out WMS_BROADCAST_PUBLISHING_POINT_STATUS *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopArchive )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportXML )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ __RPC__in BSTR bstrXMLFileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UpTime )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AnnouncementStreamFormats )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSAnnouncementStreamFormats **ppFileNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Announce )( 
            IWMSBroadcastPublishingPoint2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AnnounceToNSCFile )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ __RPC__in BSTR bstrDestinationFileName,
            /* [defaultvalue][in] */ VARIANT_BOOL fOverwriteFlag);
        
        /* [helpstring][id][restricted] */ HRESULT ( STDMETHODCALLTYPE *AnnounceToNSCStream )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppNSCAnnounceStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferSetting )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out WMS_BUFFER_SETTING *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BufferSetting )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ WMS_BUFFER_SETTING newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowStartupProfile )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowStartupProfile )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableStartVRootOnServiceStart )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableStartVRootOnServiceStart )( 
            IWMSBroadcastPublishingPoint2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IWMSBroadcastPublishingPoint2Vtbl;

    interface IWMSBroadcastPublishingPoint2
    {
        CONST_VTBL struct IWMSBroadcastPublishingPoint2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBroadcastPublishingPoint2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSBroadcastPublishingPoint2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSBroadcastPublishingPoint2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSBroadcastPublishingPoint2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSBroadcastPublishingPoint2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSBroadcastPublishingPoint2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSBroadcastPublishingPoint2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSBroadcastPublishingPoint2_get_AllowClientsToConnect(This,pVal)	\
    ( (This)->lpVtbl -> get_AllowClientsToConnect(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_AllowClientsToConnect(This,newVal)	\
    ( (This)->lpVtbl -> put_AllowClientsToConnect(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_CurrentCounters(This,pVal)	\
    ( (This)->lpVtbl -> get_CurrentCounters(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_EventHandlers(This,pVal)	\
    ( (This)->lpVtbl -> get_EventHandlers(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_ID(This,pVal)	\
    ( (This)->lpVtbl -> get_ID(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Limits(This,pVal)	\
    ( (This)->lpVtbl -> get_Limits(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_FileDescriptions(This,RelativePath,pVal)	\
    ( (This)->lpVtbl -> get_FileDescriptions(This,RelativePath,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_MonikerName(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_MonikerName(This,pbstrVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Name(This,pVal)	\
    ( (This)->lpVtbl -> get_Name(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_Name(This,newVal)	\
    ( (This)->lpVtbl -> put_Name(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_OutgoingDistributionConnections(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Path(This,pVal)	\
    ( (This)->lpVtbl -> get_Path(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_Path(This,newVal)	\
    ( (This)->lpVtbl -> put_Path(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_PeakCounters(This,pVal)	\
    ( (This)->lpVtbl -> get_PeakCounters(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Players(This,pVal)	\
    ( (This)->lpVtbl -> get_Players(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Properties(This,pVal)	\
    ( (This)->lpVtbl -> get_Properties(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_TotalCounters(This,pVal)	\
    ( (This)->lpVtbl -> get_TotalCounters(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Type(This,pVal)	\
    ( (This)->lpVtbl -> get_Type(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_WrapperPath(This,pVal)	\
    ( (This)->lpVtbl -> get_WrapperPath(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_WrapperPath(This,newVal)	\
    ( (This)->lpVtbl -> put_WrapperPath(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Authenticators(This,pVal)	\
    ( (This)->lpVtbl -> get_Authenticators(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_EnableWrapperPath(This,pVal)	\
    ( (This)->lpVtbl -> get_EnableWrapperPath(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_EnableWrapperPath(This,newVal)	\
    ( (This)->lpVtbl -> put_EnableWrapperPath(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_StreamFilters(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamFilters(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_DistributionUserName(This,pVal)	\
    ( (This)->lpVtbl -> get_DistributionUserName(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_SetDistributionUserNamePassword(This,newUserName,newUserPassword)	\
    ( (This)->lpVtbl -> SetDistributionUserNamePassword(This,newUserName,newUserPassword) ) 

#define IWMSBroadcastPublishingPoint2_get_CacheProxyExpiration(This,pVal)	\
    ( (This)->lpVtbl -> get_CacheProxyExpiration(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_CacheProxyExpiration(This,newVal)	\
    ( (This)->lpVtbl -> put_CacheProxyExpiration(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_IsDistributionPasswordSet(This,pVal)	\
    ( (This)->lpVtbl -> get_IsDistributionPasswordSet(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_AllowPlayerSideDiskCaching(This,pVal)	\
    ( (This)->lpVtbl -> get_AllowPlayerSideDiskCaching(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_AllowPlayerSideDiskCaching(This,newVal)	\
    ( (This)->lpVtbl -> put_AllowPlayerSideDiskCaching(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_EnableFEC(This,pVal)	\
    ( (This)->lpVtbl -> get_EnableFEC(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_EnableFEC(This,newVal)	\
    ( (This)->lpVtbl -> put_EnableFEC(This,newVal) ) 


#define IWMSBroadcastPublishingPoint2_get_AllowStreamSplitting(This,pVal)	\
    ( (This)->lpVtbl -> get_AllowStreamSplitting(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_AllowStreamSplitting(This,newVal)	\
    ( (This)->lpVtbl -> put_AllowStreamSplitting(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_AllowClientToStartAndStop(This,pVal)	\
    ( (This)->lpVtbl -> get_AllowClientToStartAndStop(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_AllowClientToStartAndStop(This,newVal)	\
    ( (This)->lpVtbl -> put_AllowClientToStartAndStop(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_BroadcastDataSinks(This,pVal)	\
    ( (This)->lpVtbl -> get_BroadcastDataSinks(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_SharedPlaylist(This,pVal)	\
    ( (This)->lpVtbl -> get_SharedPlaylist(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_StartWithoutData(This)	\
    ( (This)->lpVtbl -> StartWithoutData(This) ) 

#define IWMSBroadcastPublishingPoint2_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IWMSBroadcastPublishingPoint2_StartArchive(This)	\
    ( (This)->lpVtbl -> StartArchive(This) ) 

#define IWMSBroadcastPublishingPoint2_get_BroadcastStatus(This,pVal)	\
    ( (This)->lpVtbl -> get_BroadcastStatus(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IWMSBroadcastPublishingPoint2_StopArchive(This)	\
    ( (This)->lpVtbl -> StopArchive(This) ) 

#define IWMSBroadcastPublishingPoint2_ExportXML(This,bstrXMLFileName)	\
    ( (This)->lpVtbl -> ExportXML(This,bstrXMLFileName) ) 

#define IWMSBroadcastPublishingPoint2_get_UpTime(This,pVal)	\
    ( (This)->lpVtbl -> get_UpTime(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_get_AnnouncementStreamFormats(This,ppFileNames)	\
    ( (This)->lpVtbl -> get_AnnouncementStreamFormats(This,ppFileNames) ) 

#define IWMSBroadcastPublishingPoint2_Announce(This)	\
    ( (This)->lpVtbl -> Announce(This) ) 

#define IWMSBroadcastPublishingPoint2_AnnounceToNSCFile(This,bstrDestinationFileName,fOverwriteFlag)	\
    ( (This)->lpVtbl -> AnnounceToNSCFile(This,bstrDestinationFileName,fOverwriteFlag) ) 

#define IWMSBroadcastPublishingPoint2_AnnounceToNSCStream(This,ppNSCAnnounceStream)	\
    ( (This)->lpVtbl -> AnnounceToNSCStream(This,ppNSCAnnounceStream) ) 

#define IWMSBroadcastPublishingPoint2_get_BufferSetting(This,pVal)	\
    ( (This)->lpVtbl -> get_BufferSetting(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_BufferSetting(This,newVal)	\
    ( (This)->lpVtbl -> put_BufferSetting(This,newVal) ) 


#define IWMSBroadcastPublishingPoint2_get_AllowStartupProfile(This,pVal)	\
    ( (This)->lpVtbl -> get_AllowStartupProfile(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_AllowStartupProfile(This,newVal)	\
    ( (This)->lpVtbl -> put_AllowStartupProfile(This,newVal) ) 

#define IWMSBroadcastPublishingPoint2_get_EnableStartVRootOnServiceStart(This,pVal)	\
    ( (This)->lpVtbl -> get_EnableStartVRootOnServiceStart(This,pVal) ) 

#define IWMSBroadcastPublishingPoint2_put_EnableStartVRootOnServiceStart(This,newVal)	\
    ( (This)->lpVtbl -> put_EnableStartVRootOnServiceStart(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSBroadcastPublishingPoint2_INTERFACE_DEFINED__ */


#ifndef __IWMSPublishingPoints_INTERFACE_DEFINED__
#define __IWMSPublishingPoints_INTERFACE_DEFINED__

/* interface IWMSPublishingPoints */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("6ca388b5-eaee-492f-a8d6-8758efc72d76") 
enum WMS_PUBLISHING_POINT_CATEGORY
    {	WMS_PUBLISHING_POINT_ON_DEMAND	= 1,
	WMS_PUBLISHING_POINT_BROADCAST	= 2
    } 	WMS_PUBLISHING_POINT_CATEGORY;


EXTERN_C const IID IID_IWMSPublishingPoints;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1881274D-4BEC-11D2-BF25-00805FBE84A6")
    IWMSPublishingPoints : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ WMS_PUBLISHING_POINT_CATEGORY Category,
            /* [in] */ __RPC__in BSTR Path,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **ppNewPubPt) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ __RPC__in BSTR DestName,
            /* [in] */ __RPC__in_opt IWMSPublishingPoint *pSrcPubPt,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **ppDestPubPt) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportXML( 
            /* [in] */ __RPC__in BSTR bstrNewPubPtName,
            /* [in] */ __RPC__in BSTR bstrXMLFileName,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **ppNewPubPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPublishingPointsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPublishingPoints * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPublishingPoints * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPublishingPoints * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPublishingPoints * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPublishingPoints * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPublishingPoints * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPublishingPoints * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSPublishingPoints * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSPublishingPoints * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSPublishingPoints * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSPublishingPoints * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IWMSPublishingPoints * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ WMS_PUBLISHING_POINT_CATEGORY Category,
            /* [in] */ __RPC__in BSTR Path,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **ppNewPubPt);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMSPublishingPoints * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWMSPublishingPoints * This,
            /* [in] */ __RPC__in BSTR DestName,
            /* [in] */ __RPC__in_opt IWMSPublishingPoint *pSrcPubPt,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **ppDestPubPt);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportXML )( 
            IWMSPublishingPoints * This,
            /* [in] */ __RPC__in BSTR bstrNewPubPtName,
            /* [in] */ __RPC__in BSTR bstrXMLFileName,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoint **ppNewPubPt);
        
        END_INTERFACE
    } IWMSPublishingPointsVtbl;

    interface IWMSPublishingPoints
    {
        CONST_VTBL struct IWMSPublishingPointsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPublishingPoints_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSPublishingPoints_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSPublishingPoints_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSPublishingPoints_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSPublishingPoints_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSPublishingPoints_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSPublishingPoints_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSPublishingPoints_get_Item(This,varIndex,pVal)	\
    ( (This)->lpVtbl -> get_Item(This,varIndex,pVal) ) 

#define IWMSPublishingPoints_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define IWMSPublishingPoints_get_length(This,pVal)	\
    ( (This)->lpVtbl -> get_length(This,pVal) ) 

#define IWMSPublishingPoints_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define IWMSPublishingPoints_Add(This,Name,Category,Path,ppNewPubPt)	\
    ( (This)->lpVtbl -> Add(This,Name,Category,Path,ppNewPubPt) ) 

#define IWMSPublishingPoints_Remove(This,varIndex)	\
    ( (This)->lpVtbl -> Remove(This,varIndex) ) 

#define IWMSPublishingPoints_Clone(This,DestName,pSrcPubPt,ppDestPubPt)	\
    ( (This)->lpVtbl -> Clone(This,DestName,pSrcPubPt,ppDestPubPt) ) 

#define IWMSPublishingPoints_ImportXML(This,bstrNewPubPtName,bstrXMLFileName,ppNewPubPt)	\
    ( (This)->lpVtbl -> ImportXML(This,bstrNewPubPtName,bstrXMLFileName,ppNewPubPt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSPublishingPoints_INTERFACE_DEFINED__ */


#ifndef __IWMSServerCurrentCounters_INTERFACE_DEFINED__
#define __IWMSServerCurrentCounters_INTERFACE_DEFINED__

/* interface IWMSServerCurrentCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerCurrentCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18FA53CD-8EB9-4b5f-B750-659D9B96DB9F")
    IWMSServerCurrentCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionQueue( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileReadRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingHTTPPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LateReadRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingMMSPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionAllocatedBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionSendRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAllocatedBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerSendRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingRTSPPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamErrorRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CacheDownloads( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LateSendRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDPResendRequestsRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDPResendsSentRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerCurrentCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerCurrentCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerCurrentCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerCurrentCounters * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionQueue )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileReadRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingHTTPPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateReadRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingMMSPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionSendRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerSendRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingRTSPPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamErrorRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheDownloads )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateSendRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendRequestsRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendsSentRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingBandwidth )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSServerCurrentCountersVtbl;

    interface IWMSServerCurrentCounters
    {
        CONST_VTBL struct IWMSServerCurrentCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerCurrentCounters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSServerCurrentCounters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSServerCurrentCounters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSServerCurrentCounters_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSServerCurrentCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSServerCurrentCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSServerCurrentCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSServerCurrentCounters_get_ConnectedPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectedPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters_get_ConnectionQueue(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectionQueue(This,pVal) ) 

#define IWMSServerCurrentCounters_get_ConnectionRate(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectionRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_FileReadRate(This,pVal)	\
    ( (This)->lpVtbl -> get_FileReadRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_StreamingHTTPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingHTTPPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters_get_LateReadRate(This,pVal)	\
    ( (This)->lpVtbl -> get_LateReadRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_StreamingMMSPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingMMSPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal) ) 

#define IWMSServerCurrentCounters_get_OutgoingDistributionConnections(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal) ) 

#define IWMSServerCurrentCounters_get_OutgoingDistributionSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionSendRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_PlayerAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal) ) 

#define IWMSServerCurrentCounters_get_PlayerSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerSendRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_StreamingRTSPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingRTSPPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters_get_StreamErrorRate(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamErrorRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_StreamingPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters_get_CacheDownloads(This,pVal)	\
    ( (This)->lpVtbl -> get_CacheDownloads(This,pVal) ) 

#define IWMSServerCurrentCounters_get_LateSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_LateSendRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_UDPResendRequestsRate(This,pVal)	\
    ( (This)->lpVtbl -> get_UDPResendRequestsRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_UDPResendsSentRate(This,pVal)	\
    ( (This)->lpVtbl -> get_UDPResendsSentRate(This,pVal) ) 

#define IWMSServerCurrentCounters_get_IncomingBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_IncomingBandwidth(This,pVal) ) 

#define IWMSServerCurrentCounters_get_AllCounters(This,ppsaCounters)	\
    ( (This)->lpVtbl -> get_AllCounters(This,ppsaCounters) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSServerCurrentCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSServerCurrentCounters2_INTERFACE_DEFINED__
#define __IWMSServerCurrentCounters2_INTERFACE_DEFINED__

/* interface IWMSServerCurrentCounters2 */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerCurrentCounters2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E061553-1A6E-405f-ADFF-6B1BEF58ECFB")
    IWMSServerCurrentCounters2 : public IWMSServerCurrentCounters
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingUDPPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerCurrentCounters2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerCurrentCounters2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerCurrentCounters2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerCurrentCounters2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerCurrentCounters2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerCurrentCounters2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerCurrentCounters2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerCurrentCounters2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionQueue )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileReadRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingHTTPPlayers )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateReadRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingMMSPlayers )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionSendRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerSendRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingRTSPPlayers )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamErrorRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheDownloads )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateSendRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendRequestsRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendsSentRate )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingBandwidth )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaCounters);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingUDPPlayers )( 
            IWMSServerCurrentCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } IWMSServerCurrentCounters2Vtbl;

    interface IWMSServerCurrentCounters2
    {
        CONST_VTBL struct IWMSServerCurrentCounters2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerCurrentCounters2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSServerCurrentCounters2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSServerCurrentCounters2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSServerCurrentCounters2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSServerCurrentCounters2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSServerCurrentCounters2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSServerCurrentCounters2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSServerCurrentCounters2_get_ConnectedPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectedPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_ConnectionQueue(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectionQueue(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_ConnectionRate(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectionRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_FileReadRate(This,pVal)	\
    ( (This)->lpVtbl -> get_FileReadRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_StreamingHTTPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingHTTPPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_LateReadRate(This,pVal)	\
    ( (This)->lpVtbl -> get_LateReadRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_StreamingMMSPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingMMSPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_OutgoingDistributionConnections(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_OutgoingDistributionSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionSendRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_PlayerAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_PlayerSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerSendRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_StreamingRTSPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingRTSPPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_StreamErrorRate(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamErrorRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_StreamingPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingPlayers(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_CacheDownloads(This,pVal)	\
    ( (This)->lpVtbl -> get_CacheDownloads(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_LateSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_LateSendRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_UDPResendRequestsRate(This,pVal)	\
    ( (This)->lpVtbl -> get_UDPResendRequestsRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_UDPResendsSentRate(This,pVal)	\
    ( (This)->lpVtbl -> get_UDPResendsSentRate(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_IncomingBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_IncomingBandwidth(This,pVal) ) 

#define IWMSServerCurrentCounters2_get_AllCounters(This,ppsaCounters)	\
    ( (This)->lpVtbl -> get_AllCounters(This,ppsaCounters) ) 


#define IWMSServerCurrentCounters2_get_StreamingUDPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingUDPPlayers(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSServerCurrentCounters2_INTERFACE_DEFINED__ */


#ifndef __IWMSServerPeakCounters_INTERFACE_DEFINED__
#define __IWMSServerPeakCounters_INTERFACE_DEFINED__

/* interface IWMSServerPeakCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerPeakCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66F2D385-7081-40b9-863C-AFA4E5612CD3")
    IWMSServerPeakCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionAllocatedBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerSendRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAllocatedBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionSendRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountersStartTime( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerPeakCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerPeakCounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerPeakCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerPeakCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerPeakCounters * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerPeakCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerPeakCounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerPeakCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerSendRate )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionSendRate )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountersStartTime )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMSServerPeakCounters * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSServerPeakCountersVtbl;

    interface IWMSServerPeakCounters
    {
        CONST_VTBL struct IWMSServerPeakCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerPeakCounters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSServerPeakCounters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSServerPeakCounters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSServerPeakCounters_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSServerPeakCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSServerPeakCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSServerPeakCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSServerPeakCounters_get_ConnectedPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectedPlayers(This,pVal) ) 

#define IWMSServerPeakCounters_get_OutgoingDistributionConnections(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal) ) 

#define IWMSServerPeakCounters_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal) ) 

#define IWMSServerPeakCounters_get_PlayerSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerSendRate(This,pVal) ) 

#define IWMSServerPeakCounters_get_PlayerAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal) ) 

#define IWMSServerPeakCounters_get_OutgoingDistributionSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionSendRate(This,pVal) ) 

#define IWMSServerPeakCounters_get_CountersStartTime(This,pVal)	\
    ( (This)->lpVtbl -> get_CountersStartTime(This,pVal) ) 

#define IWMSServerPeakCounters_get_StreamingPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingPlayers(This,pVal) ) 

#define IWMSServerPeakCounters_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IWMSServerPeakCounters_get_AllCounters(This,ppsaCounters)	\
    ( (This)->lpVtbl -> get_AllCounters(This,ppsaCounters) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSServerPeakCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSServerPeakCounters2_INTERFACE_DEFINED__
#define __IWMSServerPeakCounters2_INTERFACE_DEFINED__

/* interface IWMSServerPeakCounters2 */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerPeakCounters2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F09DBB46-19C0-4fb7-BA22-B38994FBB293")
    IWMSServerPeakCounters2 : public IWMSServerPeakCounters
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingUDPPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingHTTPPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingRTSPPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerPeakCounters2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerPeakCounters2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerPeakCounters2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerPeakCounters2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerPeakCounters2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerPeakCounters2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerPeakCounters2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerPeakCounters2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerSendRate )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionSendRate )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountersStartTime )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMSServerPeakCounters2 * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaCounters);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingUDPPlayers )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingHTTPPlayers )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingRTSPPlayers )( 
            IWMSServerPeakCounters2 * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } IWMSServerPeakCounters2Vtbl;

    interface IWMSServerPeakCounters2
    {
        CONST_VTBL struct IWMSServerPeakCounters2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerPeakCounters2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSServerPeakCounters2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSServerPeakCounters2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSServerPeakCounters2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSServerPeakCounters2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSServerPeakCounters2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSServerPeakCounters2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSServerPeakCounters2_get_ConnectedPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectedPlayers(This,pVal) ) 

#define IWMSServerPeakCounters2_get_OutgoingDistributionConnections(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal) ) 

#define IWMSServerPeakCounters2_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal) ) 

#define IWMSServerPeakCounters2_get_PlayerSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerSendRate(This,pVal) ) 

#define IWMSServerPeakCounters2_get_PlayerAllocatedBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal) ) 

#define IWMSServerPeakCounters2_get_OutgoingDistributionSendRate(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionSendRate(This,pVal) ) 

#define IWMSServerPeakCounters2_get_CountersStartTime(This,pVal)	\
    ( (This)->lpVtbl -> get_CountersStartTime(This,pVal) ) 

#define IWMSServerPeakCounters2_get_StreamingPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingPlayers(This,pVal) ) 

#define IWMSServerPeakCounters2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IWMSServerPeakCounters2_get_AllCounters(This,ppsaCounters)	\
    ( (This)->lpVtbl -> get_AllCounters(This,ppsaCounters) ) 


#define IWMSServerPeakCounters2_get_StreamingUDPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingUDPPlayers(This,pVal) ) 

#define IWMSServerPeakCounters2_get_StreamingHTTPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingHTTPPlayers(This,pVal) ) 

#define IWMSServerPeakCounters2_get_StreamingRTSPPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamingRTSPPlayers(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSServerPeakCounters2_INTERFACE_DEFINED__ */


#ifndef __IWMSServerLimits_INTERFACE_DEFINED__
#define __IWMSServerLimits_INTERFACE_DEFINED__

/* interface IWMSServerLimits */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerLimits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D06CCFBB-994D-45f8-886E-81E9B7FAEDF1")
    IWMSServerLimits : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectedPlayers( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionRate( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionRate( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutgoingDistributionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutgoingDistributionConnections( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerOutgoingDistributionConnectionBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerOutgoingDistributionConnectionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerInactivityTimeout( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerInactivityTimeout( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerPlayerConnectionBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerPlayerConnectionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAcknowledgementTimeout( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerAcknowledgementTimeout( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CPUUtilizationDuringConnection( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CPUUtilizationDuringConnection( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiagnosticEvents( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiagnosticEvents( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingBandwidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IncomingBandwidth( 
            /* [in] */ long Val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerLimitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerLimits * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerLimits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerLimits * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerLimits * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerLimits * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerLimits * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerLimits * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectedPlayers )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionRate )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectionRate )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutgoingDistributionBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutgoingDistributionConnections )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerOutgoingDistributionConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerOutgoingDistributionConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerInactivityTimeout )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerInactivityTimeout )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerPlayerConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerPlayerConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAcknowledgementTimeout )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerAcknowledgementTimeout )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CPUUtilizationDuringConnection )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CPUUtilizationDuringConnection )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiagnosticEvents )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiagnosticEvents )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncomingBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        END_INTERFACE
    } IWMSServerLimitsVtbl;

    interface IWMSServerLimits
    {
        CONST_VTBL struct IWMSServerLimitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerLimits_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSServerLimits_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSServerLimits_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSServerLimits_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSServerLimits_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSServerLimits_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSServerLimits_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSServerLimits_get_ConnectedPlayers(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectedPlayers(This,pVal) ) 

#define IWMSServerLimits_put_ConnectedPlayers(This,Val)	\
    ( (This)->lpVtbl -> put_ConnectedPlayers(This,Val) ) 

#define IWMSServerLimits_get_ConnectionRate(This,pVal)	\
    ( (This)->lpVtbl -> get_ConnectionRate(This,pVal) ) 

#define IWMSServerLimits_put_ConnectionRate(This,Val)	\
    ( (This)->lpVtbl -> put_ConnectionRate(This,Val) ) 

#define IWMSServerLimits_get_OutgoingDistributionBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionBandwidth(This,pVal) ) 

#define IWMSServerLimits_put_OutgoingDistributionBandwidth(This,Val)	\
    ( (This)->lpVtbl -> put_OutgoingDistributionBandwidth(This,Val) ) 

#define IWMSServerLimits_get_OutgoingDistributionConnections(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal) ) 

#define IWMSServerLimits_put_OutgoingDistributionConnections(This,Val)	\
    ( (This)->lpVtbl -> put_OutgoingDistributionConnections(This,Val) ) 

#define IWMSServerLimits_get_PerOutgoingDistributionConnectionBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_PerOutgoingDistributionConnectionBandwidth(This,pVal) ) 

#define IWMSServerLimits_put_PerOutgoingDistributionConnectionBandwidth(This,Val)	\
    ( (This)->lpVtbl -> put_PerOutgoingDistributionConnectionBandwidth(This,Val) ) 

#define IWMSServerLimits_get_PlayerBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerBandwidth(This,pVal) ) 

#define IWMSServerLimits_put_PlayerBandwidth(This,Val)	\
    ( (This)->lpVtbl -> put_PlayerBandwidth(This,Val) ) 

#define IWMSServerLimits_get_PlayerInactivityTimeout(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerInactivityTimeout(This,pVal) ) 

#define IWMSServerLimits_put_PlayerInactivityTimeout(This,Val)	\
    ( (This)->lpVtbl -> put_PlayerInactivityTimeout(This,Val) ) 

#define IWMSServerLimits_get_PerPlayerConnectionBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_PerPlayerConnectionBandwidth(This,pVal) ) 

#define IWMSServerLimits_put_PerPlayerConnectionBandwidth(This,Val)	\
    ( (This)->lpVtbl -> put_PerPlayerConnectionBandwidth(This,Val) ) 

#define IWMSServerLimits_get_PlayerAcknowledgementTimeout(This,pVal)	\
    ( (This)->lpVtbl -> get_PlayerAcknowledgementTimeout(This,pVal) ) 

#define IWMSServerLimits_put_PlayerAcknowledgementTimeout(This,Val)	\
    ( (This)->lpVtbl -> put_PlayerAcknowledgementTimeout(This,Val) ) 

#define IWMSServerLimits_get_CPUUtilizationDuringConnection(This,pVal)	\
    ( (This)->lpVtbl -> get_CPUUtilizationDuringConnection(This,pVal) ) 

#define IWMSServerLimits_put_CPUUtilizationDuringConnection(This,Val)	\
    ( (This)->lpVtbl -> put_CPUUtilizationDuringConnection(This,Val) ) 

#define IWMSServerLimits_get_DiagnosticEvents(This,pVal)	\
    ( (This)->lpVtbl -> get_DiagnosticEvents(This,pVal) ) 

#define IWMSServerLimits_put_DiagnosticEvents(This,Val)	\
    ( (This)->lpVtbl -> put_DiagnosticEvents(This,Val) ) 

#define IWMSServerLimits_get_IncomingBandwidth(This,pVal)	\
    ( (This)->lpVtbl -> get_IncomingBandwidth(This,pVal) ) 

#define IWMSServerLimits_put_IncomingBandwidth(This,Val)	\
    ( (This)->lpVtbl -> put_IncomingBandwidth(This,Val) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSServerLimits_INTERFACE_DEFINED__ */


#ifndef __IWMSServer_INTERFACE_DEFINED__
#define __IWMSServer_INTERFACE_DEFINED__

/* interface IWMSServer */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("3E52E0EE-72A7-11D2-BF2F-00805FBE84A6") 
enum WMS_SERVER_STATUS
    {	WMS_SERVER_RUNNING	= 0,
	WMS_SERVER_ERROR	= 0x1,
	WMS_SERVER_ERROR_CRITICAL	= 0x2
    } 	WMS_SERVER_STATUS;

typedef /* [uuid][public] */  DECLSPEC_UUID("49A0F530-F475-45a6-99C5-E52382685BA8") 
enum WMS_OS_PRODUCT_TYPE
    {	WMS_OS_PRODUCT_SERVER	= 0x1,
	WMS_OS_PRODUCT_ADVANCED	= 0x2
    } 	WMS_OS_PRODUCT_TYPE;


EXTERN_C const IID IID_IWMSServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("845FB958-4279-11D2-BF23-00805FBE84A6")
    IWMSServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowClientsToConnect( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowClientsToConnect( 
            /* [in] */ VARIANT_BOOL val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Authenticators( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CacheProxy( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ControlProtocols( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCounters( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerCurrentCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataSources( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventHandlers( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Limits( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerLimits **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileDescriptions( 
            /* [in] */ __RPC__in BSTR Path,
            /* [defaultvalue][in] */ WMS_FILE_TYPE Type,
            /* [retval][out] */ __RPC__deref_out_opt IWMSFileDescriptions **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaParsers( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MonikerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PeakCounters( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerPeakCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlaylistParsers( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSNamedValues **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublishingPoints( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoints **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCounters( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerTotalCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UnicastDataSinks( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Players( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlayers **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out WMS_SERVER_STATUS *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreatePlaylist( 
            /* [retval][out] */ __RPC__deref_out_opt IXMLDOMDocument **ppPlaylist) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSOutgoingDistributionConnections **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CPUUtilization( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportXML( 
            /* [in] */ __RPC__in BSTR bstrXMLFileName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamFilters( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultPluginLoadType( 
            /* [retval][out] */ __RPC__out WMS_PLUGIN_LOAD_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultPluginLoadType( 
            /* [in] */ WMS_PLUGIN_LOAD_TYPE val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableIPAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSAvailableIPAddresses **ppIPAddrList) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RootDirectories( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSRootDirectories **ppRootDirectories) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiagnosticEvents( 
            /* [retval][out] */ __RPC__deref_out_opt IWMSDiagnosticEvents **ppDiagEvents) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableReverseProxyMode( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableReverseProxyMode( 
            /* [in] */ VARIANT_BOOL val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileType( 
            /* [in] */ __RPC__in BSTR path,
            /* [retval][out] */ __RPC__out WMS_FILE_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultPath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultPath( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DownloadContent( 
            /* [in] */ __RPC__in BSTR SourceUrl,
            /* [in] */ __RPC__in BSTR DestinationUrl,
            /* [defaultvalue][in] */ long lContentSizeLow = -1,
            /* [defaultvalue][in] */ long lContentSizeHigh = -1,
            /* [defaultvalue][in] */ long lBitRate = 0) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OSProductType( 
            /* [retval][out] */ __RPC__out WMS_OS_PRODUCT_TYPE *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServer * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientsToConnect )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientsToConnect )( 
            IWMSServer * This,
            /* [in] */ VARIANT_BOOL val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticators )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheProxy )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ControlProtocols )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCounters )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerCurrentCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSources )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventHandlers )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Limits )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerLimits **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileDescriptions )( 
            IWMSServer * This,
            /* [in] */ __RPC__in BSTR Path,
            /* [defaultvalue][in] */ WMS_FILE_TYPE Type,
            /* [retval][out] */ __RPC__deref_out_opt IWMSFileDescriptions **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaParsers )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeakCounters )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerPeakCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlaylistParsers )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublishingPoints )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPublishingPoints **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCounters )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSServerTotalCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UnicastDataSinks )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Players )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlayers **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__out WMS_SERVER_STATUS *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreatePlaylist )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IXMLDOMDocument **ppPlaylist);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSOutgoingDistributionConnections **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CPUUtilization )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportXML )( 
            IWMSServer * This,
            /* [in] */ __RPC__in BSTR bstrXMLFileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamFilters )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPluginLoadType )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__out WMS_PLUGIN_LOAD_TYPE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPluginLoadType )( 
            IWMSServer * This,
            /* [in] */ WMS_PLUGIN_LOAD_TYPE val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableIPAddresses )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSAvailableIPAddresses **ppIPAddrList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootDirectories )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSRootDirectories **ppRootDirectories);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiagnosticEvents )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWMSDiagnosticEvents **ppDiagEvents);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableReverseProxyMode )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableReverseProxyMode )( 
            IWMSServer * This,
            /* [in] */ VARIANT_BOOL val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileType )( 
            IWMSServer * This,
            /* [in] */ __RPC__in BSTR path,
            /* [retval][out] */ __RPC__out WMS_FILE_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPath )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPath )( 
            IWMSServer * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DownloadContent )( 
            IWMSServer * This,
            /* [in] */ __RPC__in BSTR SourceUrl,
            /* [in] */ __RPC__in BSTR DestinationUrl,
            /* [defaultvalue][in] */ long lContentSizeLow,
            /* [defaultvalue][in] */ long lContentSizeHigh,
            /* [defaultvalue][in] */ long lBitRate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSProductType )( 
            IWMSServer * This,
            /* [retval][out] */ __RPC__out WMS_OS_PRODUCT_TYPE *pVal);
        
        END_INTERFACE
    } IWMSServerVtbl;

    interface IWMSServer
    {
        CONST_VTBL struct IWMSServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSServer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSServer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSServer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMSServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMSServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMSServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMSServer_get_AllowClientsToConnect(This,pVal)	\
    ( (This)->lpVtbl -> get_AllowClientsToConnect(This,pVal) ) 

#define IWMSServer_put_AllowClientsToConnect(This,val)	\
    ( (This)->lpVtbl -> put_AllowClientsToConnect(This,val) ) 

#define IWMSServer_get_Authenticators(This,pVal)	\
    ( (This)->lpVtbl -> get_Authenticators(This,pVal) ) 

#define IWMSServer_get_CacheProxy(This,pVal)	\
    ( (This)->lpVtbl -> get_CacheProxy(This,pVal) ) 

#define IWMSServer_get_ControlProtocols(This,pVal)	\
    ( (This)->lpVtbl -> get_ControlProtocols(This,pVal) ) 

#define IWMSServer_get_CurrentCounters(This,pVal)	\
    ( (This)->lpVtbl -> get_CurrentCounters(This,pVal) ) 

#define IWMSServer_get_DataSources(This,pVal)	\
    ( (This)->lpVtbl -> get_DataSources(This,pVal) ) 

#define IWMSServer_get_EventHandlers(This,pVal)	\
    ( (This)->lpVtbl -> get_EventHandlers(This,pVal) ) 

#define IWMSServer_get_Limits(This,pVal)	\
    ( (This)->lpVtbl -> get_Limits(This,pVal) ) 

#define IWMSServer_get_FileDescriptions(This,Path,Type,pVal)	\
    ( (This)->lpVtbl -> get_FileDescriptions(This,Path,Type,pVal) ) 

#define IWMSServer_get_MediaParsers(This,pVal)	\
    ( (This)->lpVtbl -> get_MediaParsers(This,pVal) ) 

#define IWMSServer_get_MonikerName(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_MonikerName(This,pbstrVal) ) 

#define IWMSServer_get_Name(This,pVal)	\
    ( (This)->lpVtbl -> get_Name(This,pVal) ) 

#define IWMSServer_get_PeakCounters(This,pVal)	\
    ( (This)->lpVtbl -> get_PeakCounters(This,pVal) ) 

#define IWMSServer_get_PlaylistParsers(This,pVal)	\
    ( (This)->lpVtbl -> get_PlaylistParsers(This,pVal) ) 

#define IWMSServer_get_Properties(This,pVal)	\
    ( (This)->lpVtbl -> get_Properties(This,pVal) ) 

#define IWMSServer_get_PublishingPoints(This,pVal)	\
    ( (This)->lpVtbl -> get_PublishingPoints(This,pVal) ) 

#define IWMSServer_get_TotalCounters(This,pVal)	\
    ( (This)->lpVtbl -> get_TotalCounters(This,pVal) ) 

#define IWMSServer_get_UnicastDataSinks(This,pVal)	\
    ( (This)->lpVtbl -> get_UnicastDataSinks(This,pVal) ) 

#define IWMSServer_get_Players(This,pVal)	\
    ( (This)->lpVtbl -> get_Players(This,pVal) ) 

#define IWMSServer_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define IWMSServer_CreatePlaylist(This,ppPlaylist)	\
    ( (This)->lpVtbl -> CreatePlaylist(This,ppPlaylist) ) 

#define IWMSServer_get_StartTime(This,pVal)	\
    ( (This)->lpVtbl -> get_StartTime(This,pVal) ) 

#define IWMSServer_get_OutgoingDistributionConnections(This,pVal)	\
    ( (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal) ) 

#define IWMSServer_get_CPUUtilization(This,pVal)	\
    ( (This)->lpVtbl -> get_CPUUtilization(This,pVal) ) 

#define IWMSServer_ExportXML(This,bstrXMLFileName)	\
    ( (This)->lpVtbl -> ExportXML(This,bstrXMLFileName) ) 

#define IWMSServer_get_StreamFilters(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamFilters(This,pVal) ) 

#define IWMSServer_get_Version(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_Version(This,pbstrVal) ) 

#define IWMSServer_get_DefaultPluginLoadType(This,pVal)	\
    ( (This)->lpVtbl -> get_DefaultPluginLoadType(This,pVal) ) 

#define IWMSServer_put_DefaultPluginLoadType(This,val)	\
    ( (This)->lpVtbl -> put_DefaultPluginLoadType(This,val) ) 

#define IWMSServer_get_AvailableIPAddresses(This,ppIPAddrList)	\
    ( (This)->lpVtbl -> get_AvailableIPAddresses(This,ppIPAddrList) ) 

#define IWMSServer_get_RootDirectories(This,ppRootDirectories)	\
    ( (This)->lpVtbl -> get_RootDirectories(This,ppRootDirectories) ) 

#define IWMSServer_get_DiagnosticEvents(This,ppDiagEvents)	\
    ( (This)->lpVtbl -> get_DiagnosticEvents(This,ppDiagEvents) ) 

#define IWMSServer_get_EnableReverseProxyMode(This,pVal)	\
    ( (This)->lpVtbl -> get_EnableReverseProxyMode(This,pVal) ) 

#define IWMSServer_put_EnableReverseProxyMode(This,val)	\
    ( (This)->lpVtbl -> put_EnableReverseProxyMode(This,val) ) 

#define IWMSServer_get_FileType(This,path,pVal)	\
    ( (This)->lpVtbl -> get_FileType(This,path,pVal) ) 

#define IWMSServer_get_DefaultPath(This,pVal)	\
    ( (This)->lpVtbl -> get_DefaultPath(This,pVal) ) 

#define IWMSServer_put_DefaultPath(This,newVal)	\
    ( (This)->lpVtbl -> put_DefaultPath(This,newVal) ) 

#define IWMSServer_DownloadContent(This,SourceUrl,DestinationUrl,lContentSizeLow,lContentSizeHigh,lBitRate)	\
    ( (This)->lpVtbl -> DownloadContent(This,SourceUrl,DestinationUrl,lContentSizeLow,lContentSizeHigh,lBitRate) ) 

#define IWMSServer_get_OSProductType(This,pVal)	\
    ( (This)->lpVtbl -> get_OSProductType(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSServer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmsserver_0000_0037 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0000_0037_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wmspacket.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wmspacket.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmspacket_h__
#define __wmspacket_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSPacket_FWD_DEFINED__
#define __IWMSPacket_FWD_DEFINED__
typedef interface IWMSPacket IWMSPacket;
#endif 	/* __IWMSPacket_FWD_DEFINED__ */


#ifndef __IWMSPacketListCallback_FWD_DEFINED__
#define __IWMSPacketListCallback_FWD_DEFINED__
typedef interface IWMSPacketListCallback IWMSPacketListCallback;
#endif 	/* __IWMSPacketListCallback_FWD_DEFINED__ */


#ifndef __IWMSPacketList_FWD_DEFINED__
#define __IWMSPacketList_FWD_DEFINED__
typedef interface IWMSPacketList IWMSPacketList;
#endif 	/* __IWMSPacketList_FWD_DEFINED__ */


#ifndef __IWMSPacketParser_FWD_DEFINED__
#define __IWMSPacketParser_FWD_DEFINED__
typedef interface IWMSPacketParser IWMSPacketParser;
#endif 	/* __IWMSPacketParser_FWD_DEFINED__ */


#ifndef __IWMSStreamSignalHandler_FWD_DEFINED__
#define __IWMSStreamSignalHandler_FWD_DEFINED__
typedef interface IWMSStreamSignalHandler IWMSStreamSignalHandler;
#endif 	/* __IWMSStreamSignalHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "WMSBuffer.h"
#include "WMSContext.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmspacket_0000_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from wmspacket.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_IWMSPacket, 0x3309C901,0x10A4,0x11d2,0x9E,0xEE,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSPacketList, 0x3309C902,0x10A4,0x11d2,0x9E,0xEE,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSPacketParser, 0x8b59f7e1, 0x5411, 0x11d2, 0x9e, 0xff, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSPacketListCallback, 0x49c2a6f1, 0x64b8, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSStreamSignalHandler, 0x7B10F261,0x26AA,0x11d2,0x9E,0xF2,0x00,0x60,0x97,0xD2,0xD7,0xCF );
typedef /* [public] */ 
enum WMS_PACKET_ATTRIBUTES
    {	WMS_PACKET_PACKET_NUM	= 0,
	WMS_PACKET_NUM_BUFFERS	= ( WMS_PACKET_PACKET_NUM + 1 ) ,
	WMS_PACKET_LENGTH	= ( WMS_PACKET_NUM_BUFFERS + 1 ) ,
	WMS_PACKET_SEND_TIME_HI	= ( WMS_PACKET_LENGTH + 1 ) ,
	WMS_PACKET_SEND_TIME	= ( WMS_PACKET_SEND_TIME_HI + 1 ) ,
	WMS_PACKET_STREAM_NUM	= ( WMS_PACKET_SEND_TIME + 1 ) ,
	WMS_PACKET_FLAGS	= ( WMS_PACKET_STREAM_NUM + 1 ) ,
	WMS_PACKET_NET_SEQUENCE_NUMBER	= ( WMS_PACKET_FLAGS + 1 ) ,
	WMS_PACKET_PRESENT_TIME_HI	= ( WMS_PACKET_NET_SEQUENCE_NUMBER + 1 ) ,
	WMS_PACKET_PRESENT_TIME	= ( WMS_PACKET_PRESENT_TIME_HI + 1 ) ,
	WMS_PACKET_RECV_TIME	= ( WMS_PACKET_PRESENT_TIME + 1 ) ,
	WMS_PACKET_NUM_NACKS	= ( WMS_PACKET_RECV_TIME + 1 ) ,
	WMS_PACKET_DURATION	= ( WMS_PACKET_NUM_NACKS + 1 ) ,
	WMS_PACKET_ERASURES_DETECTED	= ( WMS_PACKET_DURATION + 1 ) ,
	WMS_PACKET_SEND_TIME_ADJUSTMENT	= ( WMS_PACKET_ERASURES_DETECTED + 1 ) ,
	WMS_PACKET_PACKETIZED_HDRLEN	= ( WMS_PACKET_SEND_TIME_ADJUSTMENT + 1 ) ,
	WMS_LAST_PACKET_ATTRIBUTE	= WMS_PACKET_PACKETIZED_HDRLEN
    } 	WMS_PACKET_ATTRIBUTES;

typedef /* [public] */ 
enum WMS_PACKET_FLAG_TYPES
    {	WMS_KEY_FRAME_PACKET	= 0x1,
	WMS_RETRANSMITTED_PACKET	= 0x2,
	WMS_PACKET_REPORTED	= 0x4,
	WMS_PACKET_PACKETIZED	= 0x8,
	WMS_RECOVERED_PACKET	= 0x10,
	WMS_FEC_PACKET	= 0x20,
	WMS_FEC_ENCODED_PACKET	= 0x40,
	WMS_PACKET_BURST_FLAG	= 0x80,
	WMS_PACKET_FIRST_PAYLOAD_FLAG	= 0x100
    } 	WMS_PACKET_FLAG_TYPES;

typedef /* [public] */ 
enum WMS_PACKET_LIST_ATTRIBUTES
    {	WMS_PACKET_LIST_FLAGS	= 0,
	WMS_STREAM_SIGNAL	= 1,
	WMS_PACKET_LIST_GENID	= 2,
	WMS_PACKET_LIST_SEND_TIME	= 3,
	WMS_PACKET_LIST_SEND_TIME_HI	= 4,
	WMS_PACKET_LIST_PLAYLIST_GEN_ID	= 5,
	WMS_LAST_PACKET_LIST_ATTRIBUTE	= WMS_PACKET_LIST_PLAYLIST_GEN_ID
    } 	WMS_PACKET_LIST_ATTRIBUTES;

typedef /* [public] */ 
enum WMS_PACKET_LIST_FLAG_TYPES
    {	WMS_PACKET_LIST_NEEDS_FIXUP	= 0x1,
	WMS_PACKET_LIST_UDP_RESEND	= 0x2,
	WMS_PACKET_LIST_PRESTUFF	= 0x4,
	WMS_PACKET_LIST_PLAYLIST_CHANGE_RECEDING	= 0x8
    } 	WMS_PACKET_LIST_FLAG_TYPES;

typedef /* [public] */ 
enum WMS_PACKET_LIST_EX_FLAGS
    {	WMS_NO_ADDREF	= 0x80000000,
	WMS_PACKET_NO_ADDREF	= 0x80000000,
	WMS_PACKET_NO_RELEASE	= 0x40000000,
	WMS_PLIST_BUFFER_NO_ADDREF	= 0x80000000,
	WMS_PLIST_BUFFER_NO_RELEASE	= 0x40000000,
	WMS_PLIST_NO_ADDREF	= 0x80000000
    } 	WMS_PACKET_LIST_EX_FLAGS;

typedef /* [public] */ 
enum WMS_PACKET_BUFFER_FLAGS
    {	WMS_INSERT_BUFFER_AT_END	= 0xffffffff
    } 	WMS_PACKET_BUFFER_FLAGS;

typedef /* [public] */ 
enum WMS_PACKET_BUFFER_EX_FLAGS
    {	WMS_BUFFER_NO_ADDREF	= 0x80000000,
	WMS_BUFFER_NO_RELEASE	= 0x40000000,
	WMS_BUFFER_NO_REFCOUNT	= 0x20000000,
	WMS_BUFFER_COMBINE	= 0x10000000
    } 	WMS_PACKET_BUFFER_EX_FLAGS;

typedef /* [public] */ 
enum WMS_PACKET_STATUS_FLAGS
    {	WMS_START_NEXT_READ	= 0x1,
	WMS_WRITE_COMPLETED	= 0x2,
	WMS_REQUEST_BUFFER	= 0x4,
	WMS_HEADER_BUFFER	= 0x8
    } 	WMS_PACKET_STATUS_FLAGS;

typedef /* [public] */ 
enum WMS_PARSER_FLAG_TYPES
    {	WMS_PARSER_PRESERVE_PADDING	= 0x1
    } 	WMS_PARSER_FLAG_TYPES;

typedef unsigned __int64 QWORD;






extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0000_0000_v0_0_s_ifspec;

#ifndef __IWMSPacket_INTERFACE_DEFINED__
#define __IWMSPacket_INTERFACE_DEFINED__

/* interface IWMSPacket */
/* [helpstring][version][uuid][unique][object] */ 

typedef /* [public][public] */ struct __MIDL_IWMSPacket_0001
    {
    INSSBuffer *pBuffer;
    DWORD dwBufferOffset;
    DWORD dwBufferLen;
    WORD wFlags;
    } 	WMSBUFFERDESC;


EXTERN_C const IID IID_IWMSPacket;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3309C901-10A4-11d2-9EEE-006097D2D7CF")
    IWMSPacket : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAllBuffers( 
            /* [in] */ DWORD dwMaxNumBuffers,
            /* [out] */ __RPC__out WMSBUFFERDESC *pDesc,
            /* [out] */ __RPC__out DWORD *pdwNumBuffers,
            /* [in] */ DWORD dwExFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [in] */ DWORD dwBufferNum,
            /* [out] */ __RPC__deref_out_opt INSSBuffer **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferOffset,
            /* [out] */ __RPC__out DWORD *pdwBufferLen,
            /* [out] */ __RPC__out WORD *pwFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertBuffer( 
            /* [in] */ DWORD dwBufferNum,
            /* [in] */ __RPC__in_opt INSSBuffer *pBuffer,
            /* [in] */ DWORD dwBufferOffset,
            /* [in] */ DWORD dwBufferLen,
            /* [in] */ WORD wFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveBuffer( 
            /* [in] */ DWORD dwBufferNum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAllBuffers( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [out] */ __RPC__out DWORD *pdwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [out] */ __RPC__out VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out DWORD *pdwValueName,
            /* [out] */ __RPC__out VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeCount( 
            /* [out] */ __RPC__out DWORD *pdwAttrs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyAttributes( 
            /* [in] */ __RPC__in_opt IWMSPacket *pDest,
            /* [defaultvalue][in] */ __RPC__in DWORD *pdwAttrNames = 0,
            /* [defaultvalue][in] */ DWORD dwNumAttr = 0,
            /* [defaultvalue][in] */ BOOL fCopyExtAttr = FALSE) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendHeader( 
            /* [in] */ __RPC__in_opt IWMSBufferAllocator *pAlloc,
            /* [in] */ DWORD dwHeaderLen,
            /* [in] */ __RPC__in BYTE *pbHeader) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInHeader( 
            /* [in] */ DWORD cbOffset,
            /* [in] */ __RPC__in BYTE *pbData,
            /* [in] */ DWORD cbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacket * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacket * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacket * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAllBuffers )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwMaxNumBuffers,
            /* [out] */ __RPC__out WMSBUFFERDESC *pDesc,
            /* [out] */ __RPC__out DWORD *pdwNumBuffers,
            /* [in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwBufferNum,
            /* [out] */ __RPC__deref_out_opt INSSBuffer **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferOffset,
            /* [out] */ __RPC__out DWORD *pdwBufferLen,
            /* [out] */ __RPC__out WORD *pwFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InsertBuffer )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwBufferNum,
            /* [in] */ __RPC__in_opt INSSBuffer *pBuffer,
            /* [in] */ DWORD dwBufferOffset,
            /* [in] */ DWORD dwBufferLen,
            /* [in] */ WORD wFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveBuffer )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwBufferNum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAllBuffers )( 
            IWMSPacket * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [out] */ __RPC__out DWORD *pdwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [out] */ __RPC__out VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeByIndex )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out DWORD *pdwValueName,
            /* [out] */ __RPC__out VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetExtendedAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeCount )( 
            IWMSPacket * This,
            /* [out] */ __RPC__out DWORD *pdwAttrs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CopyAttributes )( 
            IWMSPacket * This,
            /* [in] */ __RPC__in_opt IWMSPacket *pDest,
            /* [defaultvalue][in] */ __RPC__in DWORD *pdwAttrNames,
            /* [defaultvalue][in] */ DWORD dwNumAttr,
            /* [defaultvalue][in] */ BOOL fCopyExtAttr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppendHeader )( 
            IWMSPacket * This,
            /* [in] */ __RPC__in_opt IWMSBufferAllocator *pAlloc,
            /* [in] */ DWORD dwHeaderLen,
            /* [in] */ __RPC__in BYTE *pbHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInHeader )( 
            IWMSPacket * This,
            /* [in] */ DWORD cbOffset,
            /* [in] */ __RPC__in BYTE *pbData,
            /* [in] */ DWORD cbData);
        
        END_INTERFACE
    } IWMSPacketVtbl;

    interface IWMSPacket
    {
        CONST_VTBL struct IWMSPacketVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSPacket_GetAllBuffers(This,dwMaxNumBuffers,pDesc,pdwNumBuffers,dwExFlags)	\
    ( (This)->lpVtbl -> GetAllBuffers(This,dwMaxNumBuffers,pDesc,pdwNumBuffers,dwExFlags) ) 

#define IWMSPacket_GetBuffer(This,dwBufferNum,ppBuffer,pdwBufferOffset,pdwBufferLen,pwFlags,dwExFlags)	\
    ( (This)->lpVtbl -> GetBuffer(This,dwBufferNum,ppBuffer,pdwBufferOffset,pdwBufferLen,pwFlags,dwExFlags) ) 

#define IWMSPacket_InsertBuffer(This,dwBufferNum,pBuffer,dwBufferOffset,dwBufferLen,wFlags,dwExFlags)	\
    ( (This)->lpVtbl -> InsertBuffer(This,dwBufferNum,pBuffer,dwBufferOffset,dwBufferLen,wFlags,dwExFlags) ) 

#define IWMSPacket_RemoveBuffer(This,dwBufferNum)	\
    ( (This)->lpVtbl -> RemoveBuffer(This,dwBufferNum) ) 

#define IWMSPacket_RemoveAllBuffers(This)	\
    ( (This)->lpVtbl -> RemoveAllBuffers(This) ) 

#define IWMSPacket_GetAttribute(This,dwValueName,pdwValue)	\
    ( (This)->lpVtbl -> GetAttribute(This,dwValueName,pdwValue) ) 

#define IWMSPacket_SetAttribute(This,dwValueName,dwValue)	\
    ( (This)->lpVtbl -> SetAttribute(This,dwValueName,dwValue) ) 

#define IWMSPacket_GetExtendedAttribute(This,dwValueName,pVariantValue)	\
    ( (This)->lpVtbl -> GetExtendedAttribute(This,dwValueName,pVariantValue) ) 

#define IWMSPacket_GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue)	\
    ( (This)->lpVtbl -> GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue) ) 

#define IWMSPacket_SetExtendedAttribute(This,dwValueName,VariantValue)	\
    ( (This)->lpVtbl -> SetExtendedAttribute(This,dwValueName,VariantValue) ) 

#define IWMSPacket_GetExtendedAttributeCount(This,pdwAttrs)	\
    ( (This)->lpVtbl -> GetExtendedAttributeCount(This,pdwAttrs) ) 

#define IWMSPacket_CopyAttributes(This,pDest,pdwAttrNames,dwNumAttr,fCopyExtAttr)	\
    ( (This)->lpVtbl -> CopyAttributes(This,pDest,pdwAttrNames,dwNumAttr,fCopyExtAttr) ) 

#define IWMSPacket_AppendHeader(This,pAlloc,dwHeaderLen,pbHeader)	\
    ( (This)->lpVtbl -> AppendHeader(This,pAlloc,dwHeaderLen,pbHeader) ) 

#define IWMSPacket_SetInHeader(This,cbOffset,pbData,cbData)	\
    ( (This)->lpVtbl -> SetInHeader(This,cbOffset,pbData,cbData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSPacket_INTERFACE_DEFINED__ */


#ifndef __IWMSPacketListCallback_INTERFACE_DEFINED__
#define __IWMSPacketListCallback_INTERFACE_DEFINED__

/* interface IWMSPacketListCallback */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPacketListCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49C2A6F1-64B8-11d2-9F0E-006097D2D7CF")
    IWMSPacketListCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnReportPacketListStatus( 
            /* [in] */ __RPC__in_opt IWMSPacketList *pBuffer,
            /* [in] */ DWORD dwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketListCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacketListCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacketListCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacketListCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnReportPacketListStatus )( 
            IWMSPacketListCallback * This,
            /* [in] */ __RPC__in_opt IWMSPacketList *pBuffer,
            /* [in] */ DWORD dwStatus);
        
        END_INTERFACE
    } IWMSPacketListCallbackVtbl;

    interface IWMSPacketListCallback
    {
        CONST_VTBL struct IWMSPacketListCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacketListCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSPacketListCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSPacketListCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSPacketListCallback_OnReportPacketListStatus(This,pBuffer,dwStatus)	\
    ( (This)->lpVtbl -> OnReportPacketListStatus(This,pBuffer,dwStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSPacketListCallback_INTERFACE_DEFINED__ */


#ifndef __IWMSPacketList_INTERFACE_DEFINED__
#define __IWMSPacketList_INTERFACE_DEFINED__

/* interface IWMSPacketList */
/* [helpstring][version][uuid][unique][object][local] */ 

typedef /* [public][public] */ struct __MIDL_IWMSPacketList_0001
    {
    IWMSPacket *pPacket;
    struct 
        {
        DWORD dwPacketNum;
        DWORD dwPacketNumBuffers;
        DWORD dwPacketLength;
        DWORD dwPacketSendTimeHi;
        DWORD dwPacketSendTime;
        DWORD dwPacketStreamNum;
        DWORD dwPacketFlags;
        DWORD dwPacketNetSequenceNum;
        } 	Attrs;
    } 	WMSPACKETDESC;


EXTERN_C const IID IID_IWMSPacketList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3309C902-10A4-11d2-9EEE-006097D2D7CF")
    IWMSPacketList : public IWMSBufferAllocator
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPacketCount( 
            /* [out] */ DWORD *pdwNumPackets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPacket( 
            /* [in] */ DWORD dwPacketNum,
            /* [out] */ IWMSPacket **ppPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAllPackets( 
            /* [in] */ DWORD dwFirstPacket,
            /* [in] */ DWORD dwMaxNumPackets,
            /* [out] */ WMSPACKETDESC *pPacketDesc,
            /* [out] */ IWMSPacket **ppPacket,
            /* [out] */ DWORD *pdwDescNum,
            /* [in] */ DWORD dwExFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertPacket( 
            /* [in] */ DWORD dwPacketNum,
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendPacket( 
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePacket( 
            /* [in] */ DWORD dwPacketNum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAllPackets( 
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD *pdwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStreamSignalParam( 
            /* [out] */ VARIANT *pParameter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStreamSignalParam( 
            /* [in] */ VARIANT *pParameter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPacketParser( 
            /* [out] */ IWMSPacketParser **ppSource,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPacketParser( 
            /* [in] */ IWMSPacketParser *pSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ INSSBuffer **ppBuffer,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetBuffer( 
            /* [in] */ INSSBuffer *pBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCompletionCallback( 
            /* [in] */ IWMSPacketListCallback *pCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCompletionCallback( 
            /* [out] */ IWMSPacketListCallback **ppCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [out] */ VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwValueName,
            /* [out] */ VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeCount( 
            /* [out] */ DWORD *pdwAttrs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReportStatus( 
            /* [in] */ DWORD dwStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClonePacketList( 
            /* [out] */ IWMSPacketList **ppClonedPacketList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocPacket( 
            /* [out] */ IWMSPacket **ppPacket) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacketList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacketList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacketList * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocateBuffer )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocatePageSizeBuffer )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPacketCount )( 
            IWMSPacketList * This,
            /* [out] */ DWORD *pdwNumPackets);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPacket )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwPacketNum,
            /* [out] */ IWMSPacket **ppPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAllPackets )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwFirstPacket,
            /* [in] */ DWORD dwMaxNumPackets,
            /* [out] */ WMSPACKETDESC *pPacketDesc,
            /* [out] */ IWMSPacket **ppPacket,
            /* [out] */ DWORD *pdwDescNum,
            /* [in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InsertPacket )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwPacketNum,
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppendPacket )( 
            IWMSPacketList * This,
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePacket )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwPacketNum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAllPackets )( 
            IWMSPacketList * This,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD *pdwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStreamSignalParam )( 
            IWMSPacketList * This,
            /* [out] */ VARIANT *pParameter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStreamSignalParam )( 
            IWMSPacketList * This,
            /* [in] */ VARIANT *pParameter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPacketParser )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacketParser **ppSource,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPacketParser )( 
            IWMSPacketList * This,
            /* [in] */ IWMSPacketParser *pSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IWMSPacketList * This,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetBuffer )( 
            IWMSPacketList * This,
            /* [in] */ INSSBuffer *pBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCompletionCallback )( 
            IWMSPacketList * This,
            /* [in] */ IWMSPacketListCallback *pCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCompletionCallback )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacketListCallback **ppCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [out] */ VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeByIndex )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwValueName,
            /* [out] */ VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetExtendedAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeCount )( 
            IWMSPacketList * This,
            /* [out] */ DWORD *pdwAttrs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReportStatus )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClonePacketList )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacketList **ppClonedPacketList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocPacket )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacket **ppPacket);
        
        END_INTERFACE
    } IWMSPacketListVtbl;

    interface IWMSPacketList
    {
        CONST_VTBL struct IWMSPacketListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacketList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSPacketList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSPacketList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSPacketList_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    ( (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer) ) 

#define IWMSPacketList_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    ( (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer) ) 


#define IWMSPacketList_GetPacketCount(This,pdwNumPackets)	\
    ( (This)->lpVtbl -> GetPacketCount(This,pdwNumPackets) ) 

#define IWMSPacketList_GetPacket(This,dwPacketNum,ppPacket,dwExFlags)	\
    ( (This)->lpVtbl -> GetPacket(This,dwPacketNum,ppPacket,dwExFlags) ) 

#define IWMSPacketList_GetAllPackets(This,dwFirstPacket,dwMaxNumPackets,pPacketDesc,ppPacket,pdwDescNum,dwExFlags)	\
    ( (This)->lpVtbl -> GetAllPackets(This,dwFirstPacket,dwMaxNumPackets,pPacketDesc,ppPacket,pdwDescNum,dwExFlags) ) 

#define IWMSPacketList_InsertPacket(This,dwPacketNum,pPacket,dwExFlags)	\
    ( (This)->lpVtbl -> InsertPacket(This,dwPacketNum,pPacket,dwExFlags) ) 

#define IWMSPacketList_AppendPacket(This,pPacket,dwExFlags)	\
    ( (This)->lpVtbl -> AppendPacket(This,pPacket,dwExFlags) ) 

#define IWMSPacketList_RemovePacket(This,dwPacketNum)	\
    ( (This)->lpVtbl -> RemovePacket(This,dwPacketNum) ) 

#define IWMSPacketList_RemoveAllPackets(This,dwExFlags)	\
    ( (This)->lpVtbl -> RemoveAllPackets(This,dwExFlags) ) 

#define IWMSPacketList_GetAttribute(This,dwValueName,pdwValue)	\
    ( (This)->lpVtbl -> GetAttribute(This,dwValueName,pdwValue) ) 

#define IWMSPacketList_SetAttribute(This,dwValueName,dwValue)	\
    ( (This)->lpVtbl -> SetAttribute(This,dwValueName,dwValue) ) 

#define IWMSPacketList_GetStreamSignalParam(This,pParameter)	\
    ( (This)->lpVtbl -> GetStreamSignalParam(This,pParameter) ) 

#define IWMSPacketList_SetStreamSignalParam(This,pParameter)	\
    ( (This)->lpVtbl -> SetStreamSignalParam(This,pParameter) ) 

#define IWMSPacketList_GetPacketParser(This,ppSource,dwExFlags)	\
    ( (This)->lpVtbl -> GetPacketParser(This,ppSource,dwExFlags) ) 

#define IWMSPacketList_SetPacketParser(This,pSource)	\
    ( (This)->lpVtbl -> SetPacketParser(This,pSource) ) 

#define IWMSPacketList_GetBuffer(This,ppBuffer,dwExFlags)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppBuffer,dwExFlags) ) 

#define IWMSPacketList_SetBuffer(This,pBuffer)	\
    ( (This)->lpVtbl -> SetBuffer(This,pBuffer) ) 

#define IWMSPacketList_SetCompletionCallback(This,pCallback)	\
    ( (This)->lpVtbl -> SetCompletionCallback(This,pCallback) ) 

#define IWMSPacketList_GetCompletionCallback(This,ppCallback)	\
    ( (This)->lpVtbl -> GetCompletionCallback(This,ppCallback) ) 

#define IWMSPacketList_GetExtendedAttribute(This,dwValueName,pVariantValue)	\
    ( (This)->lpVtbl -> GetExtendedAttribute(This,dwValueName,pVariantValue) ) 

#define IWMSPacketList_GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue)	\
    ( (This)->lpVtbl -> GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue) ) 

#define IWMSPacketList_SetExtendedAttribute(This,dwValueName,VariantValue)	\
    ( (This)->lpVtbl -> SetExtendedAttribute(This,dwValueName,VariantValue) ) 

#define IWMSPacketList_GetExtendedAttributeCount(This,pdwAttrs)	\
    ( (This)->lpVtbl -> GetExtendedAttributeCount(This,pdwAttrs) ) 

#define IWMSPacketList_ReportStatus(This,dwStatus)	\
    ( (This)->lpVtbl -> ReportStatus(This,dwStatus) ) 

#define IWMSPacketList_ClonePacketList(This,ppClonedPacketList)	\
    ( (This)->lpVtbl -> ClonePacketList(This,ppClonedPacketList) ) 

#define IWMSPacketList_AllocPacket(This,ppPacket)	\
    ( (This)->lpVtbl -> AllocPacket(This,ppPacket) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSPacketList_INTERFACE_DEFINED__ */


#ifndef __IWMSPacketParser_INTERFACE_DEFINED__
#define __IWMSPacketParser_INTERFACE_DEFINED__

/* interface IWMSPacketParser */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPacketParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B59F7E1-5411-11d2-9EFF-006097D2D7CF")
    IWMSPacketParser : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdatePacket( 
            /* [in] */ __RPC__in_opt IWMSPacket *pPacket) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CombinePackets( 
            /* [in] */ DWORD dwNumInputPackets,
            /* [in] */ __RPC__deref_in_opt IWMSPacket **pInputPacketArray,
            /* [in] */ __RPC__in_opt IWMSPacketList *pPacketList,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacketParser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacketParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacketParser * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UpdatePacket )( 
            IWMSPacketParser * This,
            /* [in] */ __RPC__in_opt IWMSPacket *pPacket);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CombinePackets )( 
            IWMSPacketParser * This,
            /* [in] */ DWORD dwNumInputPackets,
            /* [in] */ __RPC__deref_in_opt IWMSPacket **pInputPacketArray,
            /* [in] */ __RPC__in_opt IWMSPacketList *pPacketList,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IWMSPacketParserVtbl;

    interface IWMSPacketParser
    {
        CONST_VTBL struct IWMSPacketParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacketParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSPacketParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSPacketParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSPacketParser_UpdatePacket(This,pPacket)	\
    ( (This)->lpVtbl -> UpdatePacket(This,pPacket) ) 

#define IWMSPacketParser_CombinePackets(This,dwNumInputPackets,pInputPacketArray,pPacketList,dwFlags)	\
    ( (This)->lpVtbl -> CombinePackets(This,dwNumInputPackets,pInputPacketArray,pPacketList,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSPacketParser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmspacket_0000_0004 */
/* [local] */ 

typedef /* [public] */ 
enum WMS_STREAM_SIGNAL_TYPE
    {	WMS_NO_STREAM_CHANGE	= 0,
	WMS_STREAM_ERROR	= ( WMS_NO_STREAM_CHANGE + 1 ) ,
	WMS_STREAM_ERROR_HANDLED_BY_PLAYLIST	= ( WMS_STREAM_ERROR + 1 ) ,
	WMS_PLAYLIST_CHANGED	= ( WMS_STREAM_ERROR_HANDLED_BY_PLAYLIST + 1 ) ,
	WMS_END_OF_STREAM	= ( WMS_PLAYLIST_CHANGED + 1 ) ,
	WMS_PLAYLIST_STREAM_QUEUED	= ( WMS_END_OF_STREAM + 1 ) ,
	WMS_BEGIN_NO_DATA_PERIOD	= ( WMS_PLAYLIST_STREAM_QUEUED + 1 ) ,
	WMS_PLAYLIST_EVENT	= ( WMS_BEGIN_NO_DATA_PERIOD + 1 ) ,
	WMS_PLAYLIST_CUE_EVENT	= ( WMS_PLAYLIST_EVENT + 1 ) ,
	WMS_PLAYLIST_UNCUE_EVENT	= ( WMS_PLAYLIST_CUE_EVENT + 1 ) ,
	WMS_PLAYLIST_BEGIN_ELEMENT_EVENT	= ( WMS_PLAYLIST_UNCUE_EVENT + 1 ) ,
	WMS_PLAYLIST_END_ELEMENT_EVENT	= ( WMS_PLAYLIST_BEGIN_ELEMENT_EVENT + 1 ) ,
	WMS_STREAM_SWITCH_DONE	= ( WMS_PLAYLIST_END_ELEMENT_EVENT + 1 ) ,
	WMS_RESET_TO_REAL_TIME	= ( WMS_STREAM_SWITCH_DONE + 1 ) ,
	WMS_DATA_LOSS_DETECTED	= ( WMS_RESET_TO_REAL_TIME + 1 ) ,
	WMS_REUSE_ACCEL_PARAMS	= ( WMS_DATA_LOSS_DETECTED + 1 ) 
    } 	WMS_STREAM_SIGNAL_TYPE;

typedef /* [public] */ 
enum WMS_STREAM_SIGNAL_EOS_TYPE
    {	WMS_STREAM_SIGNAL_EOS_RESERVED	= 1,
	WMS_STREAM_SIGNAL_EOS_RECEDING	= 2
    } 	WMS_STREAM_SIGNAL_EOS_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0000_0004_v0_0_s_ifspec;

#ifndef __IWMSStreamSignalHandler_INTERFACE_DEFINED__
#define __IWMSStreamSignalHandler_INTERFACE_DEFINED__

/* interface IWMSStreamSignalHandler */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSStreamSignalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7B10F261-26AA-11d2-9EF2-006097D2D7CF")
    IWMSStreamSignalHandler : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnStreamSignal( 
            /* [in] */ DWORD dwSignalType,
            /* [in] */ __RPC__in VARIANT *pSignalParameter,
            /* [in] */ __RPC__in_opt IWMSContext *pPresentation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSStreamSignalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSStreamSignalHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSStreamSignalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSStreamSignalHandler * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStreamSignal )( 
            IWMSStreamSignalHandler * This,
            /* [in] */ DWORD dwSignalType,
            /* [in] */ __RPC__in VARIANT *pSignalParameter,
            /* [in] */ __RPC__in_opt IWMSContext *pPresentation);
        
        END_INTERFACE
    } IWMSStreamSignalHandlerVtbl;

    interface IWMSStreamSignalHandler
    {
        CONST_VTBL struct IWMSStreamSignalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSStreamSignalHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSStreamSignalHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSStreamSignalHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSStreamSignalHandler_OnStreamSignal(This,dwSignalType,pSignalParameter,pPresentation)	\
    ( (This)->lpVtbl -> OnStreamSignal(This,dwSignalType,pSignalParameter,pPresentation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSStreamSignalHandler_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WPApi.h ===
/*-------------------------------------------------------*\
 *
 *	Copyright 1997 - 1999 Microsoft Corporation
 *
 *	Module Name:
 *
 *		wp15api.h
 *
 *	Abstract:
 *
 *		Declaration of the Microsoft Web Publishing API
 *
\*-------------------------------------------------------*/


#ifndef __WP15API_H__
#define __WP15API_H__


#include <windows.h>
#include "wptypes.h"

//
// Assume packing on DWORD boundary
//

#include <pshpack4.h>


//
//	Flags
//

#define WPF_NO_RECURSIVE_POST			0x00000001		//	WpPost
#define WPF_NO_WIZARD					0x00000002		//	WpPost
#define WPF_MINIMAL_UI					0x00000004		//	WpPost - OBSOLETE
#define WPF_FIRST_FILE_AS_DEFAULT		0x00000008		//	WpPost/PostFiles
#define WPF_NO_DIRECT_LOOKUP			0x00000010		//	WpBindToSite
#define WPF_NO_URL_LOOKUP				0x00000020		//	WpBindToSite
#define WPF_USE_PROVIDER_PASSED			0x00000040		//	WpCreateSite
#define WPF_NO_VERIFY_POST				0x00000080		//	WpPost
#define WPF_NO_PROGRESS_DLGS			0x00000200		//	WpPost
#define WPF_SHOWPAGE_WELCOME			0x00010000		//	WpPost/Wizard
#define WPF_SHOWPAGE_SRCFILE			0x00020000		//	WpPost/Wizard
#define WPF_SHOWPAGE_DESTSITE			0x00040000		//	WpPost/Wizard
#define WPF_SHOWPAGE_PROVIDER			0x00080000		//	WpPost/Wizard/AddWizardPages
#define WPF_ENABLE_LOCAL_BASE_DIR		0x00100000		//	WpPost/Wizard

#define WPF_NO_UI						WPF_NO_WIZARD | \
										WPF_NO_PROGRESS_DLGS
 
#define WPF_SHOWPAGE_ALL				WPF_SHOWPAGE_WELCOME | \
										WPF_SHOWPAGE_SRCFILE | \
										WPF_SHOWPAGE_DESTSITE | \
										WPF_SHOWPAGE_PROVIDER


//
//	Miscellaneous
//

#define MAX_SITENAME_LEN				128


//
//	Unicode APIs
//

#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI WpPostW(	HWND hwnd, 
						DWORD dwNumLocalPaths,
						LPWSTR *pwsLocalPaths, 
						LPDWORD pdwSiteNameBufLen,
						LPWSTR wsSiteName,
						LPDWORD pdwDestURLBufLen,
						LPWSTR wsDestURL, 
						DWORD dwFlag);

DWORD WINAPI WpListSitesW(	LPDWORD pdwSitesBufLen,
							LPWPSITEINFOW pSitesBuffer,
							LPDWORD pdwNumSites);

DWORD WINAPI WpDoesSiteExistW(	LPCWSTR wsSiteName,
								BOOL *pfSiteExists);

DWORD WINAPI WpDeleteSiteW(	LPCWSTR wsSiteName);

DWORD WINAPI WpBindToSiteW(	HWND	hwnd,
							LPCWSTR	wsSiteName,
							LPCWSTR	wsSitePostingURL,
							DWORD	dwFlag,
							DWORD	dwReserved,
							PVOID 	*ppvUnk);

DWORD WINAPI WpCreateSiteW(	LPCWSTR wsSiteName,
							LPCWSTR wsSiteLocalBaseDir,
							LPCWSTR wsSitePostingURL,
							LPCWSTR wsProviderCLSID,
							DWORD dwFlags);

DWORD WINAPI WpEnumProvidersW(	LPDWORD pdwProvidersBufLen,
								LPWPPROVINFOW pProvidersBuffer,
								LPDWORD pdwNumProviders);

DWORD WINAPI WpGetErrorStringW(	UINT uErrCode,
								LPWSTR wsOutputBuf,
								LPDWORD pdwBufLen);

//
//	ANSI APIs
//

DWORD WINAPI WpPostA(	HWND hwnd,
						DWORD dwNumLocalPaths,
						LPSTR *psLocalPaths, 
						LPDWORD pdwSiteNameBufLen,
						LPSTR sSiteName,
						LPDWORD pdwDestURLBufLen,
						LPSTR sDestURLBufLen, 
						DWORD dwFlag);

DWORD WINAPI WpListSitesA(	LPDWORD pdwSitesBufLen,
							LPWPSITEINFOA pSitesBuffer,
							LPDWORD pdwNumSites);

DWORD WINAPI WpDoesSiteExistA(	LPCSTR sSiteName,
								BOOL *pfSiteExists);

DWORD WINAPI WpDeleteSiteA(	LPCSTR sSiteName);

DWORD WINAPI WpBindToSiteA(	HWND	hwnd,
							LPCSTR	sSiteName,
							LPCSTR	sSitePostingURL,
							DWORD	dwFlag,
							DWORD	dwReserved,
						    PVOID 	*ppvUnk);

DWORD WINAPI WpCreateSiteA(	LPCSTR sSiteName,
							LPCSTR sSiteLocalBaseDir,
							LPCSTR sSitePostingURL,
							LPCSTR sProviderCLSID,
							DWORD dwFlags);

DWORD WINAPI WpEnumProvidersA(	LPDWORD pdwProvidersBufLen,
								LPWPPROVINFOA pProvidersBuffer,
								LPDWORD pdwNumProviders);

DWORD WINAPI WpGetErrorStringA(	UINT uErrCode,
								LPSTR sOutputBuf,
								LPDWORD pdwBufLen);


#ifdef __cplusplus
}
#endif


#ifdef UNICODE

#define WpPost					WpPostW
#define WpListSites				WpListSitesW
#define WpDoesSiteExist			WpDoesSiteExistW
#define WpDeleteSite			WpDeleteSiteW
#define WpBindToSite			WpBindToSiteW
#define WpCreateSite			WpCreateSiteW
#define WpEnumProviders			WpEnumProvidersW
#define WpGetErrorString		WpGetErrorStringW

#else

#define WpPost					WpPostA
#define WpListSites				WpListSitesA
#define WpDoesSiteExist			WpDoesSiteExistA
#define WpDeleteSite			WpDeleteSiteA
#define WpBindToSite			WpBindToSiteA
#define WpCreateSite			WpCreateSiteA
#define WpEnumProviders			WpEnumProvidersA
#define WpGetErrorString		WpGetErrorStringA

#endif


#include <poppack.h>


#endif // __WP15API_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WPApiMsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: WEBPOST_ERROR_FIRST
//
// MessageText:
//
//  Web Publishing Wizard first error message.
//
#define WEBPOST_ERROR_FIRST              0x40042100L

//
// MessageId: WEBPOST_ERROR_UNKNOWN
//
// MessageText:
//
//  An unknown error occurred in the Web Publishing Wizard.
//
#define WEBPOST_ERROR_UNKNOWN            0xC0042101L

//
// MessageId: WEBPOST_ERROR_PROVCLSID_UNKNOWN
//
// MessageText:
//
//  The Web Publishing Wizard could not locate the service provider used to transfer files to your Web server.
//
#define WEBPOST_ERROR_PROVCLSID_UNKNOWN  0xC0042102L

//
// MessageId: WEBPOST_ERROR_SITE_CORRUPT
//
// MessageText:
//
//  The Web Publishing Wizard could not retrieve all of the required information about your Web server.
//
#define WEBPOST_ERROR_SITE_CORRUPT       0xC0042103L

//
// MessageId: WEBPOST_ERROR_PROV_CORRUPT
//
// MessageText:
//
//  The Web Publishing Wizard could not retrieve all of the required information about this service provider.
//
#define WEBPOST_ERROR_PROV_CORRUPT       0xC0042104L

//
// MessageId: WEBPOST_ERROR_PROV_DLL
//
// MessageText:
//
//  The Web Publishing Wizard could not locate the file(s) for the requested service provider.
//
#define WEBPOST_ERROR_PROV_DLL           0xC0042105L

//
// MessageId: WEBPOST_ERROR_PROV_EP
//
// MessageText:
//
//  The file(s) for the requested service provider are either corrupt or outdated.
//
#define WEBPOST_ERROR_PROV_EP            0xC0042106L

//
// MessageId: WEBPOST_ERROR_INIT_FAILED
//
// MessageText:
//
//  An error occurred while attempting to start the Web Publishing Wizard.
//
#define WEBPOST_ERROR_INIT_FAILED        0xC0042107L

//
// MessageId: WEBPOST_ERROR_LIST_SITES
//
// MessageText:
//
//  An error occurred while the Web Publishing Wizard was enumerating the Web servers to which you have previously published.
//
#define WEBPOST_ERROR_LIST_SITES         0xC0042108L

//
// MessageId: WEBPOST_ERROR_SITE_EXISTS
//
// MessageText:
//
//  The Web Publishing Wizard could not use the requested descriptive name for your Web server because another Web server already uses the name.
//
#define WEBPOST_ERROR_SITE_EXISTS        0xC0042109L

//
// MessageId: WEBPOST_ERROR_CREATE_SITE
//
// MessageText:
//
//  An error occurred while the Web Publishing Wizard was saving information about your Web server.
//
#define WEBPOST_ERROR_CREATE_SITE        0xC004210AL

//
// MessageId: WEBPOST_ERROR_SITE_DOESNOTEXIST
//
// MessageText:
//
//  Your computer does not contain any information about the Web server you have selected.
//
#define WEBPOST_ERROR_SITE_DOESNOTEXIST  0xC004210BL

//
// MessageId: WEBPOST_ERROR_DELETE_SITE
//
// MessageText:
//
//  An error occurred while the Web Publishing Wizard was deleting information about your Web server.
//
#define WEBPOST_ERROR_DELETE_SITE        0xC004210CL

//
// MessageId: WEBPOST_ERROR_ENUM_PROVS
//
// MessageText:
//
//  An error occurred while the Web Publishing Wizard was enumerating the service providers on this system.
//
#define WEBPOST_ERROR_ENUM_PROVS         0xC004210DL

//
// MessageId: WEBPOST_ERROR_PROV_QI
//
// MessageText:
//
//  The Web Publishing Wizard was unable to determine the version number of your service provider.
//
#define WEBPOST_ERROR_PROV_QI            0xC004210EL

//
// MessageId: WEBPOST_ERROR_POST_FILES
//
// MessageText:
//
//  An error occurred while the Web Publishing Wizard was attempting to publish your files.
//
#define WEBPOST_ERROR_POST_FILES         0xC004210FL

//
// MessageId: WEBPOST_ERROR_COCREATE_WIZARD
//
// MessageText:
//
//  The Web Publishing Wizard is not installed correctly. Please uninstall and then reinstall the wizard.
//
#define WEBPOST_ERROR_COCREATE_WIZARD    0xC0042110L

//
// MessageId: WEBPOST_ERROR_POSTINFO_REQUIRED
//
// MessageText:
//
//  Your service provider requires that a PostInfo file be located on the server. No PostInfo file could be located.
//
#define WEBPOST_ERROR_POSTINFO_REQUIRED  0xC0042111L

//
// MessageId: WEBPOST_ERROR_AUTOBIND_FAILED
//
// MessageText:
//
//  The service provider could not be automatically selected for your Web server.
//
#define WEBPOST_ERROR_AUTOBIND_FAILED    0xC0042112L

//
// MessageId: WEBPOST_ERROR_BAD_PROV_PTR
//
// MessageText:
//
//  The Web Publishing Wizard was not able to obtain a valid pointer to the requested service provider.
//
#define WEBPOST_ERROR_BAD_PROV_PTR       0xC0042113L

//
// MessageId: WEBPOST_ERROR_PROV_NOT_IN_POSTINFO
//
// MessageText:
//
//  The Web server you selected does not indicate support for the service provider you selected.
//
#define WEBPOST_ERROR_PROV_NOT_IN_POSTINFO 0x80042114L

//
// MessageId: WEBPOST_ERROR_EXTENDED_ERROR
//
// MessageText:
//
//  Web Publishing Wizard extended error.
//
#define WEBPOST_ERROR_EXTENDED_ERROR     0xC0042116L

//
// MessageId: WEBPOST_ERROR_NO_EXT_ERR_INFO
//
// MessageText:
//
//  An extended error occurred in the Web Publishing Wizard, but the error message could not be retrieved.
//
#define WEBPOST_ERROR_NO_EXT_ERR_INFO    0xC0042117L

//
// MessageId: WEBPOST_ERROR_INVALID_POSTINFO
//
// MessageText:
//
//  The PostInfo file on the server is invalid.
//
#define WEBPOST_ERROR_INVALID_POSTINFO   0x40042118L

//
// MessageId: WEBPOST_ERROR_NO_POSTINFO
//
// MessageText:
//
//  There is no PostInfo file on the server.
//
#define WEBPOST_ERROR_NO_POSTINFO        0x40042119L

//
// MessageId: WEBPOST_ERROR_HTTP_GET_FAILED
//
// MessageText:
//
//  The Web Publishing Wizard was not able to retrieve the first file published using an HTTP connection.
//
#define WEBPOST_ERROR_HTTP_GET_FAILED    0x4004211AL

//
// MessageId: WEBPOST_ERROR_LAST
//
// MessageText:
//
//  Web Publishing Wizard last error message.
//
#define WEBPOST_ERROR_LAST               0x400421FFL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WPCrsMsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: CRSWPP_ERROR_FIRST
//
// MessageText:
//
//  CRS WebPost provider's first error message.
//
#define CRSWPP_ERROR_FIRST               0x40042200L

//
// MessageId: CRSWPP_INVALID_POSTINFO_FILE
//
// MessageText:
//
//  The PostInfo file is invalid on the server you selected.
//
#define CRSWPP_INVALID_POSTINFO_FILE     0xC0042201L

//
// MessageId: CRSWPP_NO_MATCHING_MAPURL
//
// MessageText:
//
//  The CRS project you selected has no MAPURL.
//
#define CRSWPP_NO_MATCHING_MAPURL        0xC0042202L

//
// MessageId: CRSWPP_SECURITY_PACKAGE
//
// MessageText:
//
//  The initialization of the security package failed.
//
#define CRSWPP_SECURITY_PACKAGE          0xC0042203L

//
// MessageId: CRSWPP_SECURITY_PACKAGE_NOT_FOUND
//
// MessageText:
//
//  The security package(s) required by the server could not be found on your computer.
//
#define CRSWPP_SECURITY_PACKAGE_NOT_FOUND 0xC0042204L

//
// MessageId: CRSWPP_PROJECT_BINDING_INCOMPLETE
//
// MessageText:
//
//  The CRS provider has not determined which CRS project on the server corresponds to the URL you selected.
//
#define CRSWPP_PROJECT_BINDING_INCOMPLETE 0xC0042205L

//
// MessageId: CRSWPP_SERVER_BINDING_INCOMPLETE
//
// MessageText:
//
//  The CRS provider has not determined the name of the server that corresponds to the URL you selected.
//
#define CRSWPP_SERVER_BINDING_INCOMPLETE 0xC0042206L

//
// MessageId: CRSWPP_SERVER_NOT_RESPONDING
//
// MessageText:
//
//  The CRS server is not responding.
//
#define CRSWPP_SERVER_NOT_RESPONDING     0xC0042207L

//
// MessageId: CRSWPP_FAILED_AUTH
//
// MessageText:
//
//  You do not have the necessary access privileges to publish to this CRS server.
//
#define CRSWPP_FAILED_AUTH               0xC0042208L

//
// MessageId: CRSWPP_POSTINFO_NEEDED
//
// MessageText:
//
//  The CRS provider could not retrieve all of the required information from the PostInfo file on the server.
//
#define CRSWPP_POSTINFO_NEEDED           0x40042209L

//
// MessageId: CRSWPP_BIND_FAILED
//
// MessageText:
//
//  The CRS provider could not connect to the CRS server.
//
#define CRSWPP_BIND_FAILED               0xC004220AL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WowNT16.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-1999, Microsoft Corporation

Module Name:

    wownt16.h

Abstract:

    Procedure declarations for functions in WOW32.DLL callable by
    3rd-party 16-bit thunking code.

--*/

#ifndef _WOWNT16_
#define _WOWNT16_

#if defined(_MSC_VER)
#if _MSC_VER > 1000
#pragma once
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// 16:16 -> 0:32 Pointer translation.
//
// GetVDMPointer32W will convert the passed in 16-bit address
// to the equivalent 32-bit flat pointer. The upper 16 bits
// of the address are treated according to the value passed in
// fMode: if fMode = 1, then the hiword of vp is used as a
// protected mode selector. Otherwise it is used as a real mode
// segment value.
// The lower 16 bits are treated as the offset.
//
// The return value is 0 if the selector is invalid.
//
// NOTE:  Limit checking is not performed in the retail build
// of Windows NT.  It is performed in the checked (debug) build
// of WOW32.DLL, which will cause 0 to be returned when the
// limit is exceeded by the supplied offset.
//

DWORD FAR PASCAL GetVDMPointer32W(LPVOID vp, UINT fMode);


//
// Win32 module management.
//
// The following routines accept parameters that correspond directly
// to the respective Win32 API function calls that they invoke. Refer
// to the Win32 reference documentation for more detail.

DWORD FAR PASCAL LoadLibraryEx32W(LPCSTR lpszLibFile, DWORD hFile, DWORD dwFlags);
DWORD FAR PASCAL GetProcAddress32W(DWORD hModule, LPCSTR lpszProc);
DWORD FAR PASCAL FreeLibrary32W(DWORD hLibModule);

//
// Generic Thunk Routine:
//
//   CallProc32W
//
// Transitions to 32 bits and calls specified routine
//
// This routine can pass a variable number of arguments, up to 32, to the
// target 32-bit routine. These arguments are given to CallProc32W following
// the 3 required parameters.
//
//   DWORD cParams          - Number of optional DWORD parameters (0-32)
//
//   LPVOID fAddressConvert - Bit Field, for 16:16 address Convertion. The
//                            optional parameters can be automatically converted
//                            from a 16:16 address format to flat by specifying
//                            a 1 bit in the corresponding position in this mask.
//                            eg (bit 1 means convert parameter 1 from 16:16
//                              to flat address before calling routine)
//
//   DWORD lpProcAddress   -  32 bit native address to call (use LoadLibraryEx32W
//                            and GetProcAddress32W to get this address).
//
// Returns:
//   What ever the API returned on 32 bit side in AX:DX
//
// Error Returns:
//   AX = 0, more than 32 parameters.
//
//
// The function prototype must be declared by the application source code
// in the following format:
//
// DWORD FAR PASCAL CallProc32W( DWORD p1, ... , DWORD lpProcAddress,
//                                        DWORD fAddressConvert, DWORD cParams);
//
// where the value in cParams must match the actual number of optional
// parameters (p1-pn) given AND the "DWORD p1, ..." must be replaced by
// the correct number of parameters being passed.  For example, passing 3
// parameter would simply require the removal of the ... and it insertion of
// "DWORD p2, DWORD p3" instead.  The fAddressConvert parameter uses bit 1
// for the last parameter (p3 in our example), with bit 2 for the next to last,
// etc.
//
// Generic Thunk Routine:
//
//   CallProcEx32W
//
// Transitions to 32 bits and calls specified routine
//
// Similar to the CallProc32W function, the CallProcEx32W is an equivalent
// function that is C calling convention and allows easier and more flexible
// prototyping.  See the prototype below.  The fAddressConvert parameter uses
// bit 1 for the 1st parameter, bit 2 for the 2nd parameter, etc.
//
// Both CallProc32W and CallProcEx32W accept a flag OR'd with the parameter
// count to indicate the calling convention of the function in 32 bits.
// For example, to call a cdecl function in 32-bits with 1 parameter, it would
// look like this:
//
// dwResult = CallProcEx32W( CPEX_DEST_CDECL | 1, 0, dwfn32, p1 );
//

DWORD FAR CDECL CallProcEx32W( DWORD, DWORD, DWORD, ... );

#define CPEX_DEST_STDCALL   0x00000000L
#define CPEX_DEST_CDECL     0x80000000L

#ifdef __cplusplus
}
#endif

#endif /* !_WOWNT16_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wmsysprf.h ===
//*@@@+++@@@@******************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************
//
#pragma once
///////////////////////////////////////////////////////////////////////////////

/* fd7f47f1-72a6-45a4-80f0-3aecefc32c07 */
EXTERN_GUID( WMProfile_V40_DialUpMBR, 
             0xfd7f47f1,
             0x72a6,
             0x45a4,
             0x80, 0xf0, 0x3a, 0xec, 0xef, 0xc3, 0x2c, 0x07 );

///////////////////////////////////////////////////////////////////////////////

/* 82cd3321-a94a-4ffc-9c2b-092c10ca16e7 */
EXTERN_GUID( WMProfile_V40_IntranetMBR, 
             0x82cd3321,
             0xa94a,
             0x4ffc,
             0x9c, 0x2b, 0x09, 0x2c, 0x10, 0xca, 0x16, 0xe7 );

///////////////////////////////////////////////////////////////////////////////

/* 5a1c2206-dc5e-4186-beb2-4c5a994b132e */
EXTERN_GUID( WMProfile_V40_2856100MBR, 
             0x5a1c2206,
             0xdc5e,
             0x4186,
             0xbe, 0xb2, 0x4c, 0x5a, 0x99, 0x4b, 0x13, 0x2e );

///////////////////////////////////////////////////////////////////////////////

/* D508978A-11A0-4d15-B0DA-ACDC99D4F890 */
EXTERN_GUID( WMProfile_V40_6VoiceAudio,
             0xD508978A,
             0x11A0,
             0x4d15,
             0xb0, 0xda, 0xac, 0xdc, 0x99, 0xd4, 0xf8, 0x90 );

///////////////////////////////////////////////////////////////////////////////

/* 0f4be81f-d57d-41e1-b2e3-2fad986bfec2 */
EXTERN_GUID( WMProfile_V40_16AMRadio, 
             0x0f4be81f,
             0xd57d,
             0x41e1,
             0xb2, 0xe3, 0x2f, 0xad, 0x98, 0x6b, 0xfe, 0xc2 );

///////////////////////////////////////////////////////////////////////////////

/* 7fa57fc8-6ea4-4645-8abf-b6e5a8f814a1 */
EXTERN_GUID( WMProfile_V40_288FMRadioMono, 
             0x7fa57fc8,
             0x6ea4,
             0x4645,
             0x8a, 0xbf, 0xb6, 0xe5, 0xa8, 0xf8, 0x14, 0xa1 );

///////////////////////////////////////////////////////////////////////////////

/* 22fcf466-aa40-431f-a289-06d0ea1a1e40 */
EXTERN_GUID( WMProfile_V40_288FMRadioStereo, 
             0x22fcf466,
             0xaa40,
             0x431f,
             0xa2, 0x89, 0x06, 0xd0, 0xea, 0x1a, 0x1e, 0x40 );

///////////////////////////////////////////////////////////////////////////////

/* e8026f87-e905-4594-a3c7-00d00041d1d9 */
EXTERN_GUID( WMProfile_V40_56DialUpStereo, 
             0xe8026f87,
             0xe905,
             0x4594,
             0xa3, 0xc7, 0x00, 0xd0, 0x00, 0x41, 0xd1, 0xd9 );

///////////////////////////////////////////////////////////////////////////////

/* 4820b3f7-cbec-41dc-9391-78598714c8e5 */
EXTERN_GUID( WMProfile_V40_64Audio, 
             0x4820b3f7,
             0xcbec,
             0x41dc,
             0x93, 0x91, 0x78, 0x59, 0x87, 0x14, 0xc8, 0xe5 );

///////////////////////////////////////////////////////////////////////////////

/* 0efa0ee3-9e64-41e2-837f-3c0038f327ba */
EXTERN_GUID( WMProfile_V40_96Audio, 
             0x0efa0ee3,
             0x9e64,
             0x41e2,
             0x83, 0x7f, 0x3c, 0x00, 0x38, 0xf3, 0x27, 0xba );

///////////////////////////////////////////////////////////////////////////////

/* 93ddbe12-13dc-4e32-a35e-40378e34279a */
EXTERN_GUID( WMProfile_V40_128Audio, 
             0x93ddbe12,
             0x13dc,
             0x4e32,
             0xa3, 0x5e, 0x40, 0x37, 0x8e, 0x34, 0x27, 0x9a );

///////////////////////////////////////////////////////////////////////////////

/* bb2bc274-0eb6-4da9-b550-ecf7f2b9948f */
EXTERN_GUID( WMProfile_V40_288VideoVoice, 
             0xbb2bc274,
             0x0eb6,
             0x4da9,
             0xb5, 0x50, 0xec, 0xf7, 0xf2, 0xb9, 0x94, 0x8f );

///////////////////////////////////////////////////////////////////////////////

/* ac617f2d-6cbe-4e84-8e9a-ce151a12a354 */
EXTERN_GUID( WMProfile_V40_288VideoAudio, 
             0xac617f2d,
             0x6cbe,
             0x4e84,
             0x8e, 0x9a, 0xce, 0x15, 0x1a, 0x12, 0xa3, 0x54 );

///////////////////////////////////////////////////////////////////////////////

/* abf2f00d-d555-4815-94ce-8275f3a70bfe */
EXTERN_GUID( WMProfile_V40_288VideoWebServer, 
             0xabf2f00d,
             0xd555,
             0x4815,
             0x94, 0xce, 0x82, 0x75, 0xf3, 0xa7, 0x0b, 0xfe );

///////////////////////////////////////////////////////////////////////////////

/* e21713bb-652f-4dab-99de-71e04400270f */
EXTERN_GUID( WMProfile_V40_56DialUpVideo, 
             0xe21713bb,
             0x652f,
             0x4dab,
             0x99, 0xde, 0x71, 0xe0, 0x44, 0x00, 0x27, 0x0f );

///////////////////////////////////////////////////////////////////////////////

/* b756ff10-520f-4749-a399-b780e2fc9250 */
EXTERN_GUID( WMProfile_V40_56DialUpVideoWebServer, 
             0xb756ff10,
             0x520f,
             0x4749,
             0xa3, 0x99, 0xb7, 0x80, 0xe2, 0xfc, 0x92, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* 8f99ddd8-6684-456b-a0a3-33e1316895f0 */
EXTERN_GUID( WMProfile_V40_100Video, 
             0x8f99ddd8,
             0x6684,
             0x456b,
             0xa0, 0xa3, 0x33, 0xe1, 0x31, 0x68, 0x95, 0xf0 );

///////////////////////////////////////////////////////////////////////////////

/* 541841c3-9339-4f7b-9a22-b11540894e42 */
EXTERN_GUID( WMProfile_V40_250Video, 
             0x541841c3,
             0x9339,
             0x4f7b,
             0x9a, 0x22, 0xb1, 0x15, 0x40, 0x89, 0x4e, 0x42 );

///////////////////////////////////////////////////////////////////////////////

/* 70440e6d-c4ef-4f84-8cd0-d5c28686e784 */
EXTERN_GUID( WMProfile_V40_512Video, 
             0x70440e6d,
             0xc4ef,
             0x4f84,
             0x8c, 0xd0, 0xd5, 0xc2, 0x86, 0x86, 0xe7, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* b4482a4c-cc17-4b07-a94e-9818d5e0f13f */
EXTERN_GUID( WMProfile_V40_1MBVideo, 
             0xb4482a4c,
             0xcc17,
             0x4b07,
             0xa9, 0x4e, 0x98, 0x18, 0xd5, 0xe0, 0xf1, 0x3f );

///////////////////////////////////////////////////////////////////////////////

/* 55374ac0-309b-4396-b88f-e6e292113f28 */
EXTERN_GUID( WMProfile_V40_3MBVideo, 
             0x55374ac0,
             0x309b,
             0x4396,
             0xb8, 0x8f, 0xe6, 0xe2, 0x92, 0x11, 0x3f, 0x28 );

///////////////////////////////////////////////////////////////////////////////

/* 5B16E74B-4068-45b5-B80E-7BF8C80D2C2F */
EXTERN_GUID( WMProfile_V70_DialUpMBR, 
             0x5b16e74b,
             0x4068,
             0x45b5,
             0xb8, 0xe, 0x7b, 0xf8, 0xc8, 0xd, 0x2c, 0x2f );

///////////////////////////////////////////////////////////////////////////////

/* 045880DC-34B6-4ca9-A326-73557ED143F3 */
EXTERN_GUID( WMProfile_V70_IntranetMBR, 
             0x45880dc,
             0x34b6,
             0x4ca9,
             0xa3, 0x26, 0x73, 0x55, 0x7e, 0xd1, 0x43, 0xf3 );

///////////////////////////////////////////////////////////////////////////////

/* 07DF7A25-3FE2-4a5b-8B1E-348B0721CA70 */
EXTERN_GUID( WMProfile_V70_2856100MBR, 
             0x7df7a25,
             0x3fe2,
             0x4a5b,
             0x8b, 0x1e, 0x34, 0x8b, 0x7, 0x21, 0xca, 0x70 );

///////////////////////////////////////////////////////////////////////////////

/* B952F38E-7DBC-4533-A9CA-B00B1C6E9800 */
EXTERN_GUID( WMProfile_V70_288VideoVoice, 
             0xb952f38e,
             0x7dbc,
             0x4533,
             0xa9, 0xca, 0xb0, 0xb, 0x1c, 0x6e, 0x98, 0x0 );

///////////////////////////////////////////////////////////////////////////////

/* 58BBA0EE-896A-4948-9953-85B736F83947 */
EXTERN_GUID( WMProfile_V70_288VideoAudio, 
             0x58bba0ee,
             0x896a,
             0x4948,
             0x99, 0x53, 0x85, 0xb7, 0x36, 0xf8, 0x39, 0x47 );

///////////////////////////////////////////////////////////////////////////////

/* 70A32E2B-E2DF-4ebd-9105-D9CA194A2D50 */
EXTERN_GUID( WMProfile_V70_288VideoWebServer, 
             0x70a32e2b,
             0xe2df,
             0x4ebd,
             0x91, 0x5, 0xd9, 0xca, 0x19, 0x4a, 0x2d, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* DEF99E40-57BC-4ab3-B2D1-B6E3CAF64257 */
EXTERN_GUID( WMProfile_V70_56VideoWebServer, 
             0xdef99e40,
             0x57bc,
             0x4ab3,
             0xb2, 0xd1, 0xb6, 0xe3, 0xca, 0xf6, 0x42, 0x57 );

///////////////////////////////////////////////////////////////////////////////

/* C2B7A7E9-7B8E-4992-A1A1-068217A3B311 */
EXTERN_GUID( WMProfile_V70_64VideoISDN,
             0xc2b7a7e9,
             0x7b8e,
             0x4992,
             0xa1, 0xa1, 0x06, 0x82, 0x17, 0xa3, 0xb3, 0x11 );

///////////////////////////////////////////////////////////////////////////////

/* D9F3C932-5EA9-4c6d-89B4-2686E515426E */
EXTERN_GUID( WMProfile_V70_100Video, 
             0xd9f3c932,
             0x5ea9,
             0x4c6d,
             0x89, 0xb4, 0x26, 0x86, 0xe5, 0x15, 0x42, 0x6e );

///////////////////////////////////////////////////////////////////////////////

/* AFE69B3A-403F-4a1b-8007-0E21CFB3DF84 */
EXTERN_GUID( WMProfile_V70_256Video,
             0xafe69b3a,
             0x403f,
             0x4a1b,
             0x80, 0x7, 0xe, 0x21, 0xcf, 0xb3, 0xdf, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* F3D45FBB-8782-44df-97C6-8678E2F9B13D */
EXTERN_GUID( WMProfile_V70_384Video,
             0xf3d45fbb,
             0x8782,
             0x44df,
             0x97, 0xc6, 0x86, 0x78, 0xe2, 0xf9, 0xb1, 0x3d );

///////////////////////////////////////////////////////////////////////////////

/* 0326EBB6-F76E-4964-B0DB-E729978D35EE */
EXTERN_GUID( WMProfile_V70_768Video, 
             0x326ebb6,
             0xf76e,
             0x4964,
             0xb0, 0xdb, 0xe7, 0x29, 0x97, 0x8d, 0x35, 0xee );

///////////////////////////////////////////////////////////////////////////////

/* 0B89164A-5490-4686-9E37-5A80884E5146 */
EXTERN_GUID( WMProfile_V70_1500Video, 
             0xb89164a,
             0x5490,
             0x4686,
             0x9e, 0x37, 0x5a, 0x80, 0x88, 0x4e, 0x51, 0x46 );

///////////////////////////////////////////////////////////////////////////////

/* AA980124-BF10-4e4f-9AFD-4329A7395CFF */
EXTERN_GUID( WMProfile_V70_2000Video,
             0xaa980124,
             0xbf10,
             0x4e4f, 
             0x9a, 0xfd, 0x43, 0x29, 0xa7, 0x39, 0x5c, 0xff );

///////////////////////////////////////////////////////////////////////////////

/* 7A747920-2449-4d76-99CB-FDB0C90484D4 */
EXTERN_GUID( WMProfile_V70_700FilmContentVideo,
             0x7a747920,
             0x2449,
             0x4d76,
             0x99, 0xcb, 0xfd, 0xb0, 0xc9, 0x4, 0x84, 0xd4 );

///////////////////////////////////////////////////////////////////////////////

/* F6A5F6DF-EE3F-434c-A433-523CE55F516B */
EXTERN_GUID( WMProfile_V70_1500FilmContentVideo,
             0xf6a5f6df,
             0xee3f,
             0x434c,
             0xa4, 0x33, 0x52, 0x3c, 0xe5, 0x5f, 0x51, 0x6b );

///////////////////////////////////////////////////////////////////////////////

/* EABA9FBF-B64F-49b3-AA0C-73FBDD150AD0 */
EXTERN_GUID( WMProfile_V70_6VoiceAudio, 
             0xeaba9fbf,
             0xb64f,
             0x49b3,
             0xaa, 0xc, 0x73, 0xfb, 0xdd, 0x15, 0xa, 0xd0 );

///////////////////////////////////////////////////////////////////////////////

/* C012A833-A03B-44a5-96DC-ED95CC65582D */
EXTERN_GUID( WMProfile_V70_288FMRadioMono, 
             0xc012a833,
             0xa03b,
             0x44a5,
             0x96, 0xdc, 0xed, 0x95, 0xcc, 0x65, 0x58, 0x2d );

///////////////////////////////////////////////////////////////////////////////

/* E96D67C9-1A39-4dc4-B900-B1184DC83620 */
EXTERN_GUID( WMProfile_V70_288FMRadioStereo, 
             0xe96d67c9,
             0x1a39,
             0x4dc4,
             0xb9, 0x0, 0xb1, 0x18, 0x4d, 0xc8, 0x36, 0x20 );

///////////////////////////////////////////////////////////////////////////////

/* 674EE767-0949-4fac-875E-F4C9C292013B */
EXTERN_GUID( WMProfile_V70_56DialUpStereo,
             0x674ee767,
             0x949,
             0x4fac,
             0x87, 0x5e, 0xf4, 0xc9, 0xc2, 0x92, 0x1, 0x3b );

///////////////////////////////////////////////////////////////////////////////

/* 91DEA458-9D60-4212-9C59-D40919C939E4 */
EXTERN_GUID( WMProfile_V70_64AudioISDN,
             0x91dea458,
             0x9d60,
             0x4212,
             0x9c, 0x59, 0xd4, 0x09, 0x19, 0xc9, 0x39, 0xe4 );

///////////////////////////////////////////////////////////////////////////////

/* B29CFFC6-F131-41db-B5E8-99D8B0B945F4 */
EXTERN_GUID( WMProfile_V70_64Audio, 
             0xb29cffc6,
             0xf131,
             0x41db,
             0xb5, 0xe8, 0x99, 0xd8, 0xb0, 0xb9, 0x45, 0xf4 );

///////////////////////////////////////////////////////////////////////////////

/* A9D4B819-16CC-4a59-9F37-693DBB0302D6 */
EXTERN_GUID( WMProfile_V70_96Audio, 
             0xa9d4b819,
             0x16cc,
             0x4a59,
             0x9f, 0x37, 0x69, 0x3d, 0xbb, 0x3, 0x2, 0xd6 );

///////////////////////////////////////////////////////////////////////////////

/* C64CF5DA-DF45-40d3-8027-DE698D68DC66 */
EXTERN_GUID( WMProfile_V70_128Audio, 
             0xc64cf5da,
             0xdf45,
             0x40d3,
             0x80, 0x27, 0xde, 0x69, 0x8d, 0x68, 0xdc, 0x66 );

///////////////////////////////////////////////////////////////////////////////

/* F55EA573-4C02-42b5-9026-A8260C438A9F */
EXTERN_GUID( WMProfile_V70_225VideoPDA, 
             0xf55ea573,
             0x4c02,
             0x42b5,
             0x90, 0x26, 0xa8, 0x26, 0xc, 0x43, 0x8a, 0x9f );

///////////////////////////////////////////////////////////////////////////////

/* 0F472967-E3C6-4797-9694-F0304C5E2F17 */
EXTERN_GUID( WMProfile_V70_150VideoPDA, 
             0xf472967,
             0xe3c6,
             0x4797,
             0x96, 0x94, 0xf0, 0x30, 0x4c, 0x5e, 0x2f, 0x17 );


///////////////////////////////////////////////////////////////////////////////

/* {FEEDBCDF-3FAC-4c93-AC0D-47941EC72C0B} */
EXTERN_GUID( WMProfile_V80_255VideoPDA, 
             0xfeedbcdf,
             0x3fac,
             0x4c93,
             0xac, 0xd, 0x47, 0x94, 0x1e, 0xc7, 0x2c, 0xb );

///////////////////////////////////////////////////////////////////////////////

/* {AEE16DFA-2C14-4a2f-AD3F-A3034031784F} */
EXTERN_GUID( WMProfile_V80_150VideoPDA, 
             0xaee16dfa,
             0x2c14,
             0x4a2f,
             0xad, 0x3f, 0xa3, 0x3, 0x40, 0x31, 0x78, 0x4f );

///////////////////////////////////////////////////////////////////////////////

/* {D66920C4-C21F-4ec8-A0B4-95CF2BD57FC4} */
EXTERN_GUID( WMProfile_V80_28856VideoMBR, 
             0xd66920c4,
             0xc21f,
             0x4ec8,
             0xa0, 0xb4, 0x95, 0xcf, 0x2b, 0xd5, 0x7f, 0xc4 );

///////////////////////////////////////////////////////////////////////////////

/* {5BDB5A0E-979E-47d3-9596-73B386392A55} */
EXTERN_GUID( WMProfile_V80_100768VideoMBR, 
             0x5bdb5a0e,
             0x979e,
             0x47d3,
             0x95, 0x96, 0x73, 0xb3, 0x86, 0x39, 0x2a, 0x55 );

///////////////////////////////////////////////////////////////////////////////

/* {D8722C69-2419-4b36-B4E0-6E17B60564E5} */
EXTERN_GUID( WMProfile_V80_288100VideoMBR, 
             0xd8722c69,
             0x2419,
             0x4b36,
             0xb4, 0xe0, 0x6e, 0x17, 0xb6, 0x5, 0x64, 0xe5 );

///////////////////////////////////////////////////////////////////////////////

/* {3DF678D9-1352-4186-BBF8-74F0C19B6AE2} */
EXTERN_GUID( WMProfile_V80_288Video, 
             0x3df678d9,
             0x1352,
             0x4186,
             0xbb, 0xf8, 0x74, 0xf0, 0xc1, 0x9b, 0x6a, 0xe2 );

///////////////////////////////////////////////////////////////////////////////

/* {254E8A96-2612-405c-8039-F0BF725CED7D} */
EXTERN_GUID( WMProfile_V80_56Video, 
             0x254e8a96,
             0x2612,
             0x405c,
             0x80, 0x39, 0xf0, 0xbf, 0x72, 0x5c, 0xed, 0x7d );

///////////////////////////////////////////////////////////////////////////////

/* {A2E300B4-C2D4-4fc0-B5DD-ECBD948DC0DF} */
EXTERN_GUID( WMProfile_V80_100Video, 
             0xa2e300b4,
             0xc2d4,
             0x4fc0,
             0xb5, 0xdd, 0xec, 0xbd, 0x94, 0x8d, 0xc0, 0xdf );

///////////////////////////////////////////////////////////////////////////////

/* {BBC75500-33D2-4466-B86B-122B201CC9AE} */
EXTERN_GUID( WMProfile_V80_256Video, 
             0xbbc75500,
             0x33d2,
             0x4466,
             0xb8, 0x6b, 0x12, 0x2b, 0x20, 0x1c, 0xc9, 0xae );

///////////////////////////////////////////////////////////////////////////////

/* {29B00C2B-09A9-48bd-AD09-CDAE117D1DA7} */
EXTERN_GUID( WMProfile_V80_384Video, 
             0x29b00c2b,
             0x9a9,
             0x48bd,
             0xad, 0x9, 0xcd, 0xae, 0x11, 0x7d, 0x1d, 0xa7 );

///////////////////////////////////////////////////////////////////////////////

/* {74D01102-E71A-4820-8F0D-13D2EC1E4872} */
EXTERN_GUID( WMProfile_V80_768Video, 
             0x74d01102,
             0xe71a,
             0x4820,
             0x8f, 0xd, 0x13, 0xd2, 0xec, 0x1e, 0x48, 0x72 );

///////////////////////////////////////////////////////////////////////////////

/* {C8C2985F-E5D9-4538-9E23-9B21BF78F745} */
EXTERN_GUID( WMProfile_V80_700NTSCVideo, 
             0xc8c2985f,
             0xe5d9,
             0x4538,
             0x9e, 0x23, 0x9b, 0x21, 0xbf, 0x78, 0xf7, 0x45 );

///////////////////////////////////////////////////////////////////////////////

/* {931D1BEE-617A-4bcd-9905-CCD0786683EE} */
EXTERN_GUID( WMProfile_V80_1400NTSCVideo, 
             0x931d1bee,
             0x617a,
             0x4bcd,
             0x99, 0x5, 0xcc, 0xd0, 0x78, 0x66, 0x83, 0xee );

///////////////////////////////////////////////////////////////////////////////

/* {9227C692-AE62-4f72-A7EA-736062D0E21E} */
EXTERN_GUID( WMProfile_V80_384PALVideo, 
             0x9227c692,
             0xae62,
             0x4f72,
             0xa7, 0xea, 0x73, 0x60, 0x62, 0xd0, 0xe2, 0x1e );

///////////////////////////////////////////////////////////////////////////////

/* {EC298949-639B-45e2-96FD-4AB32D5919C2} */
EXTERN_GUID( WMProfile_V80_700PALVideo, 
             0xec298949,
             0x639b,
             0x45e2,
             0x96, 0xfd, 0x4a, 0xb3, 0x2d, 0x59, 0x19, 0xc2 );

///////////////////////////////////////////////////////////////////////////////

/* {7EA3126D-E1BA-4716-89AF-F65CEE0C0C67} */
EXTERN_GUID( WMProfile_V80_288MonoAudio,  
             0x7ea3126d,
             0xe1ba,
             0x4716,
             0x89, 0xaf, 0xf6, 0x5c, 0xee, 0xc, 0xc, 0x67 );

///////////////////////////////////////////////////////////////////////////////

/* {7E4CAB5C-35DC-45bb-A7C0-19B28070D0CC} */
EXTERN_GUID( WMProfile_V80_288StereoAudio, 
             0x7e4cab5c,
             0x35dc,
             0x45bb,
             0xa7, 0xc0, 0x19, 0xb2, 0x80, 0x70, 0xd0, 0xcc );

///////////////////////////////////////////////////////////////////////////////

/* {60907F9F-B352-47e5-B210-0EF1F47E9F9D} */
EXTERN_GUID( WMProfile_V80_32StereoAudio, 
             0x60907f9f,
             0xb352,
             0x47e5,
             0xb2, 0x10, 0xe, 0xf1, 0xf4, 0x7e, 0x9f, 0x9d );

///////////////////////////////////////////////////////////////////////////////

/* {5EE06BE5-492B-480a-8A8F-12F373ECF9D4} */
EXTERN_GUID( WMProfile_V80_48StereoAudio, 
             0x5ee06be5,
             0x492b,
             0x480a,
             0x8a, 0x8f, 0x12, 0xf3, 0x73, 0xec, 0xf9, 0xd4 );

///////////////////////////////////////////////////////////////////////////////

/* {09BB5BC4-3176-457f-8DD6-3CD919123E2D} */
EXTERN_GUID( WMProfile_V80_64StereoAudio, 
             0x9bb5bc4,
             0x3176,
             0x457f,
             0x8d, 0xd6, 0x3c, 0xd9, 0x19, 0x12, 0x3e, 0x2d );

///////////////////////////////////////////////////////////////////////////////

/* {1FC81930-61F2-436f-9D33-349F2A1C0F10} */
EXTERN_GUID( WMProfile_V80_96StereoAudio, 
             0x1fc81930,
             0x61f2,
             0x436f,
             0x9d, 0x33, 0x34, 0x9f, 0x2a, 0x1c, 0xf, 0x10 );

///////////////////////////////////////////////////////////////////////////////

/* {407B9450-8BDC-4ee5-88B8-6F527BD941F2} */
EXTERN_GUID( WMProfile_V80_128StereoAudio, 
             0x407b9450,
             0x8bdc,
             0x4ee5,
             0x88, 0xb8, 0x6f, 0x52, 0x7b, 0xd9, 0x41, 0xf2 );

///////////////////////////////////////////////////////////////////////////////

/* {8C45B4C7-4AEB-4f78-A5EC-88420B9DADEF} */
EXTERN_GUID( WMProfile_V80_288VideoOnly, 
             0x8c45b4c7,
             0x4aeb,
             0x4f78,
             0xa5, 0xec, 0x88, 0x42, 0xb, 0x9d, 0xad, 0xef );

///////////////////////////////////////////////////////////////////////////////

/* {6E2A6955-81DF-4943-BA50-68A986A708F6} */
EXTERN_GUID( WMProfile_V80_56VideoOnly, 
             0x6e2a6955,
             0x81df,
             0x4943,
             0xba, 0x50, 0x68, 0xa9, 0x86, 0xa7, 0x8, 0xf6 );

///////////////////////////////////////////////////////////////////////////////

/* {3510A862-5850-4886-835F-D78EC6A64042} */
EXTERN_GUID( WMProfile_V80_FAIRVBRVideo, 
             0x3510a862,
             0x5850,
             0x4886,
             0x83, 0x5f, 0xd7, 0x8e, 0xc6, 0xa6, 0x40, 0x42 );

///////////////////////////////////////////////////////////////////////////////

/* {0F10D9D3-3B04-4fb0-A3D3-88D4AC854ACC} */
EXTERN_GUID( WMProfile_V80_HIGHVBRVideo, 
             0xf10d9d3,
             0x3b04,
             0x4fb0,
             0xa3, 0xd3, 0x88, 0xd4, 0xac, 0x85, 0x4a, 0xcc );

///////////////////////////////////////////////////////////////////////////////

/* {048439BA-309C-440e-9CB4-3DCCA3756423} */
EXTERN_GUID( WMProfile_V80_BESTVBRVideo, 
             0x48439ba,
             0x309c,
             0x440e,
             0x9c, 0xb4, 0x3d, 0xcc, 0xa3, 0x75, 0x64, 0x23 );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wpc.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  Wpc.h
//
//  Comments:
//      This file defines the Windows Parental Controls interfaces and events
//
//  Copyright (C) 2005 Microsoft Corporation  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <WpcApi.h>
#include <WpcEvent.h>

#ifndef E_FILE_NOT_FOUND
#define E_FILE_NOT_FOUND  MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#endif

#define FACILITY_WPC    0x999   
#define WPCERR(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_WPC, n)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wpcevent.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  WpcEvent.h
//
//  Comments:
//      This file defines the Windows Parental Controls interfaces and events
//
//  Copyright (C) 2005 Microsoft Corporation  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once 

#include <evntprov.h>

//
// Reasons
//
typedef enum tagWPCFLAG_ISBLOCKED
{
    WPCFLAG_ISBLOCKED_NOTBLOCKED            = 0x00000000,
    WPCFLAG_ISBLOCKED_IMBLOCKED             = 0x00000001,
    WPCFLAG_ISBLOCKED_EMAILBLOCKED          = 0x00000002,
    WPCFLAG_ISBLOCKED_MEDIAPLAYBACKBLOCKED  = 0x00000004,
    WPCFLAG_ISBLOCKED_WEBBLOCKED            = 0x00000008,
    WPCFLAG_ISBLOCKED_GAMESBLOCKED          = 0x00000010,
    WPCFLAG_ISBLOCKED_CONTACTBLOCKED        = 0x00000020, 
    WPCFLAG_ISBLOCKED_FEATUREBLOCKED        = 0x00000040, 
    WPCFLAG_ISBLOCKED_DOWNLOADBLOCKED       = 0x00000080, 
    WPCFLAG_ISBLOCKED_RATINGBLOCKED         = 0x00000100, 
    WPCFLAG_ISBLOCKED_DESCRIPTORBLOCKED     = 0x00000200, 
    WPCFLAG_ISBLOCKED_EXPLICITBLOCK         = 0x00000400,
    WPCFLAG_ISBLOCKED_BADPASS               = 0x00000800,
    WPCFLAG_ISBLOCKED_MAXHOURS              = 0x00001000,
    WPCFLAG_ISBLOCKED_SPECHOURS             = 0x00002000,
    
    WPCFLAG_ISBLOCKED_SETTINGSCHANGEBLOCKED = 0x00004000,

    WPCFLAG_ISBLOCKED_ATTACHMENTBLOCKED     = 0x00008000,
    WPCFLAG_ISBLOCKED_SENDERBLOCKED         = 0x00010000,
    WPCFLAG_ISBLOCKED_RECEIVERBLOCKED       = 0x00020000,
    WPCFLAG_ISBLOCKED_NOTEXPLICITLYALLOWED  = 0x00040000,
    WPCFLAG_ISBLOCKED_NOTINLIST             = 0x00080000,
    WPCFLAG_ISBLOCKED_CATEGORYBLOCKED       = 0x00100000,
    WPCFLAG_ISBLOCKED_CATEGORYNOTINLIST     = 0x00200000,
    WPCFLAG_ISBLOCKED_NOTKIDS               = 0x00400000,
    WPCFLAG_ISBLOCKED_UNRATED               = 0x00800000,
    WPCFLAG_ISBLOCKED_NOACCESS              = 0x01000000,
    WPCFLAG_ISBLOCKED_INTERNALERROR         = 0xFFFFFFFF
} WPCFLAG_ISBLOCKED;

typedef enum tagWPCFLAG_LOGOFF_TYPE
{
    WPCFLAG_LOGOFF_TYPE_LOGOUT              = 0x00000000,
    WPCFLAG_LOGOFF_TYPE_RESTART             = 0x00000001,
    WPCFLAG_LOGOFF_TYPE_SHUTDOWN            = 0x00000002,
    WPCFLAG_LOGOFF_TYPE_FUS                 = 0x00000004,
    WPCFLAG_LOGOFF_TYPE_FORCEDFUS           = 0x00000008
} WPCFLAG_LOGOFF_TYPE;

typedef enum tagWPCFLAG_IM_LEAVE_FLAG
{
    WPCFLAG_IM_LEAVE_NORMAL           = 0x00000000,
    WPCFLAG_IM_LEAVE_FORCED              = 0x00000001,
    WPCFLAG_IM_LEAVE_CONVERSATION_END  = 0x00000002 // This marks the end of the entire conversation
} WPCFLAG_IM_LEAVE;


//Event Data Lengths
//System

#define ARRAY_SEP_CHAR 0x9
typedef enum tagWPC_ARGS_SETTINGSCHANGEEVENT
{
    WPC_ARGS_SETTINGSCHANGEEVENT_CLASS = 0,
    WPC_ARGS_SETTINGSCHANGEEVENT_SETTING,
    WPC_ARGS_SETTINGSCHANGEEVENT_OWNER,
    WPC_ARGS_SETTINGSCHANGEEVENT_OLDVAL,
    WPC_ARGS_SETTINGSCHANGEEVENT_NEWVAL,
    WPC_ARGS_SETTINGSCHANGEEVENT_REASON,
    WPC_ARGS_SETTINGSCHANGEEVENT_OPTIONAL,
    WPC_ARGS_SETTINGSCHANGEEVENT_CARGS
} WPC_ARGS_SETTINGSCHANGEEVENT;


typedef enum tagWPC_ARGS_SAFERAPPBLOCKED
{
    WPC_ARGS_SAFERAPPBLOCKED_TIMESTAMP = 0,
    WPC_ARGS_SAFERAPPBLOCKED_USERID,
    WPC_ARGS_SAFERAPPBLOCKED_PATH,
    WPC_ARGS_SAFERAPPBLOCKED_RULEID,
    WPC_ARGS_SAFERAPPBLOCKED_CARGS
} WPC_ARGS_SAFERAPPBLOCKED;

//Email
typedef enum tagWPC_ARGS_EMAILRECEIEVEDEVENT
{
    WPC_ARGS_EMAILRECEIEVEDEVENT_SENDER = 0,
    WPC_ARGS_EMAILRECEIEVEDEVENT_APPNAME,
    WPC_ARGS_EMAILRECEIEVEDEVENT_APPVERSION,
    WPC_ARGS_EMAILRECEIEVEDEVENT_SUBJECT,
    WPC_ARGS_EMAILRECEIEVEDEVENT_REASON,
    WPC_ARGS_EMAILRECEIEVEDEVENT_RECIPCOUNT,
    WPC_ARGS_EMAILRECEIEVEDEVENT_RECIPIENT,
    WPC_ARGS_EMAILRECEIEVEDEVENT_ATTACHCOUNT,
    WPC_ARGS_EMAILRECEIEVEDEVENT_ATTACHMENTNAME,
    WPC_ARGS_EMAILRECEIEVEDEVENT_RECEIVEDTIME,
    WPC_ARGS_EMAILRECEIEVEDEVENT_EMAILACCOUNT,
    WPC_ARGS_EMAILRECEIEVEDEVENT_CARGS
} WPC_ARGS_EMAILRECEIEVEDEVENT;

typedef enum tagWPC_ARGS_EMAILSENTEVENT
{
    WPC_ARGS_EMAILSENTEVENT_SENDER = 0,
    WPC_ARGS_EMAILSENTEVENT_APPNAME,
    WPC_ARGS_EMAILSENTEVENT_APPVERSION,
    WPC_ARGS_EMAILSENTEVENT_SUBJECT,
    WPC_ARGS_EMAILSENTEVENT_REASON,
    WPC_ARGS_EMAILSENTEVENT_RECIPCOUNT,
    WPC_ARGS_EMAILSENTEVENT_RECIPIENT,
    WPC_ARGS_EMAILSENTEVENT_ATTACHCOUNT,
    WPC_ARGS_EMAILSENTEVENT_ATTACHMENTNAME,
    WPC_ARGS_EMAILSENTEVENT_EMAILACCOUNT,
    WPC_ARGS_EMAILSENTEVENT_CARGS
} WPC_ARGS_EMAILSENTEVENT;


typedef enum tagWPC_ARGS_EMAILCONTACTEVENT
{
    WPC_ARGS_EMAILCONTACTEVENT_APPNAME = 0,
    WPC_ARGS_EMAILCONTACTEVENT_APPVERSION,
    WPC_ARGS_EMAILCONTACTEVENT_OLDNAME,
    WPC_ARGS_EMAILCONTACTEVENT_OLDID,
    WPC_ARGS_EMAILCONTACTEVENT_NEWNAME,
    WPC_ARGS_EMAILCONTACTEVENT_NEWID,
    WPC_ARGS_EMAILCONTACTEVENT_REASON,
    WPC_ARGS_EMAILCONTACTEVENT_EMAILACCOUNT,
    WPC_ARGS_EMAILCONTACTEVENT_CARGS
} WPC_ARGS_EMAILCONTACTEVENT;

//Media
typedef enum tagWPC_MEDIA_TYPE
{   
    WPC_MEDIA_TYPE_OTHER    = 0,
    WPC_MEDIA_TYPE_DVD,
    WPC_MEDIA_TYPE_RECORDED_TV,
    WPC_MEDIA_TYPE_AUDIO_FILE,
    WPC_MEDIA_TYPE_CD_AUDIO,
    WPC_MEDIA_TYPE_VIDEO_FILE,
    WPC_MEDIA_TYPE_PICTURE_FILE,
    WPC_MEDIA_TYPE_MAX
}   WPC_MEDIA_TYPE;


typedef enum tagWPC_MEDIA_EXPLICIT_TYPE
{   
    WPC_MEDIA_EXPLICIT_FALSE = 0,
    WPC_MEDIA_EXPLICIT_TRUE,
    WPC_MEDIA_EXPLICIT_UNKNOWN
}   WPC_MEDIA_EXPLICIT;

typedef enum tagWPC_ARGS_MEDIAPLAYBACKEVENT
{
    WPC_ARGS_MEDIAPLAYBACKEVENT_APPNAME = 0,
    WPC_ARGS_MEDIAPLAYBACKEVENT_APPVERSION,
    WPC_ARGS_MEDIAPLAYBACKEVENT_MEDIATYPE,
    WPC_ARGS_MEDIAPLAYBACKEVENT_PATH,
    WPC_ARGS_MEDIAPLAYBACKEVENT_TITLE,
    WPC_ARGS_MEDIAPLAYBACKEVENT_PML,
    WPC_ARGS_MEDIAPLAYBACKEVENT_ALBUM,
    WPC_ARGS_MEDIAPLAYBACKEVENT_EXPLICIT,
    WPC_ARGS_MEDIAPLAYBACKEVENT_REASON,
    WPC_ARGS_MEDIAPLAYBACKEVENT_CARGS
} WPC_ARGS_MEDIAPLAYBACKEVENT;

typedef enum tagWPC_ARGS_MEDIADOWNLOADEVENT
{
    WPC_ARGS_MEDIADOWNLOADEVENT_APPNAME = 0,
    WPC_ARGS_MEDIADOWNLOADEVENT_APPVERSION,
    WPC_ARGS_MEDIADOWNLOADEVENT_MEDIATYPE,
    WPC_ARGS_MEDIADOWNLOADEVENT_PATH,
    WPC_ARGS_MEDIADOWNLOADEVENT_TITLE,
    WPC_ARGS_MEDIADOWNLOADEVENT_PML,
    WPC_ARGS_MEDIADOWNLOADEVENT_ALBUM,
    WPC_ARGS_MEDIADOWNLOADEVENT_EXPLICIT,
    WPC_ARGS_MEDIADOWNLOADEVENT_REASON,
    WPC_ARGS_MEDIADOWNLOADEVENT_CARGS
} WPC_ARGS_MEDIADOWNLOADEVENT;

//IM
typedef enum tagWPC_ARGS_CONVERSATIONINITEVENT
{
    WPC_ARGS_CONVERSATIONINITEVENT_APPNAME = 0,
    WPC_ARGS_CONVERSATIONINITEVENT_APPVERSION,
    WPC_ARGS_CONVERSATIONINITEVENT_ACCOUNTNAME,
    WPC_ARGS_CONVERSATIONINITEVENT_CONVID,
    WPC_ARGS_CONVERSATIONINITEVENT_REQUESTINGIP,
    WPC_ARGS_CONVERSATIONINITEVENT_SENDER,
    WPC_ARGS_CONVERSATIONINITEVENT_REASON,
    WPC_ARGS_CONVERSATIONINITEVENT_RECIPCOUNT,
    WPC_ARGS_CONVERSATIONINITEVENT_RECIPIENT,
    WPC_ARGS_CONVERSATIONINITEVENT_CARGS
} WPC_ARGS_CONVERSATIONINITEVENT;

typedef enum tagWPC_ARGS_CONVERSATIONJOINEVENT
{
    WPC_ARGS_CONVERSATIONJOINEVENT_APPNAME = 0,
    WPC_ARGS_CONVERSATIONJOINEVENT_APPVERSION,
    WPC_ARGS_CONVERSATIONJOINEVENT_ACCOUNTNAME,
    WPC_ARGS_CONVERSATIONJOINEVENT_CONVID,
    WPC_ARGS_CONVERSATIONJOINEVENT_JOININGIP,
    WPC_ARGS_CONVERSATIONJOINEVENT_JOININGUSER,
    WPC_ARGS_CONVERSATIONJOINEVENT_REASON,
    WPC_ARGS_CONVERSATIONJOINEVENT_MEMBERCOUNT,
    WPC_ARGS_CONVERSATIONJOINEVENT_MEMBER,
    WPC_ARGS_CONVERSATIONJOINEVENT_SENDER,
    WPC_ARGS_CONVERSATIONJOINEVENT_CARGS
} WPC_ARGS_CONVERSATIONJOINEVENT;

typedef enum tagWPC_ARGS_CONVERSATIONLEAVEEVENT
{
    WPC_ARGS_CONVERSATIONLEAVEEVENT_APPNAME = 0,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_APPVERSION,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_ACCOUNTNAME,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_CONVID,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_LEAVINGIP,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_LEAVINGUSER,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_REASON,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_MEMBERCOUNT,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_MEMBER,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_FLAGS,
    WPC_ARGS_CONVERSATIONLEAVEEVENT_CARGS
} WPC_ARGS_CONVERSATIONLEAVEEVENT;

typedef enum tagWPCFLAG_IM_FEATURE
{
    WPCFLAG_IM_FEATURE_NONE =     0x00,
    WPCFLAG_IM_FEATURE_VIDEO =    0x01,
    WPCFLAG_IM_FEATURE_AUDIO =    0x02,
    WPCFLAG_IM_FEATURE_GAME =     0x04,
    WPCFLAG_IM_FEATURE_SMS =      0x08,
    WPCFLAG_IM_FEATURE_FILESWAP = 0x10,
    WPCFLAG_IM_FEATURE_URLSWAP =  0x20,
    WPCFLAG_IM_FEATURE_SENDING = 0x80000000, // Top bit means sending or receiving.
    WPCFLAG_IM_FEATURE_ALL =      0xFFFFFFFF
} WPCFLAG_IM_FEATURE;

typedef enum tagWPC_ARGS_IMFEATUREEVENT
{
    WPC_ARGS_IMFEATUREEVENT_APPNAME = 0,
    WPC_ARGS_IMFEATUREEVENT_APPVERSION,
    WPC_ARGS_IMFEATUREEVENT_ACCOUNTNAME,
    WPC_ARGS_IMFEATUREEVENT_CONVID,
    WPC_ARGS_IMFEATUREEVENT_MEDIATYPE,
    WPC_ARGS_IMFEATUREEVENT_REASON,
    WPC_ARGS_IMFEATUREEVENT_RECIPCOUNT,
    WPC_ARGS_IMFEATUREEVENT_RECIPIENT,
    WPC_ARGS_IMFEATUREEVENT_SENDER,
    WPC_ARGS_IMFEATUREEVENT_SENDERIP,
    WPC_ARGS_IMFEATUREEVENT_DATA,
    WPC_ARGS_IMFEATUREEVENT_CARGS
} WPC_ARGS_IMFEATUREEVENT;

typedef enum tagWPC_ARGS_IMCONTACTEVENT
{
    WPC_ARGS_IMCONTACTEVENT_APPNAME = 0,
    WPC_ARGS_IMCONTACTEVENT_APPVERSION,
    WPC_ARGS_IMCONTACTEVENT_ACCOUNTNAME,
    WPC_ARGS_IMCONTACTEVENT_OLDNAME,
    WPC_ARGS_IMCONTACTEVENT_OLDID,
    WPC_ARGS_IMCONTACTEVENT_NEWNAME,
    WPC_ARGS_IMCONTACTEVENT_NEWID,
    WPC_ARGS_IMCONTACTEVENT_REASON,
    WPC_ARGS_IMCONTACTEVENT_CARGS
} WPC_ARGS_IMCONTACTEVENT;
//Games
typedef enum tagWPC_ARGS_GAMESTARTEVENT
{
    WPC_ARGS_GAMESTARTEVENT_APPID = 0,
    WPC_ARGS_GAMESTARTEVENT_INSTANCEID,
    WPC_ARGS_GAMESTARTEVENT_APPVERSION,
    WPC_ARGS_GAMESTARTEVENT_PATH,
    WPC_ARGS_GAMESTARTEVENT_RATING,
    WPC_ARGS_GAMESTARTEVENT_RATINGSYSTEM,
    WPC_ARGS_GAMESTARTEVENT_REASON,
    WPC_ARGS_GAMESTARTEVENT_DESCCOUNT,
    WPC_ARGS_GAMESTARTEVENT_DESCRIPTOR,
    WPC_ARGS_GAMESTARTEVENT_PID,
    WPC_ARGS_GAMESTARTEVENT_CARGS
} WPC_ARGS_GAMESTARTEVENT;

//Web
// Don't change anything in this--IE7 relies on it!!
typedef enum tagWPC_ARGS_FILEDOWNLOADEVENT
{
    WPC_ARGS_FILEDOWNLOADEVENT_URL = 0,
    WPC_ARGS_FILEDOWNLOADEVENT_APPNAME,
    WPC_ARGS_FILEDOWNLOADEVENT_VERSION,
    WPC_ARGS_FILEDOWNLOADEVENT_BLOCKED,
    WPC_ARGS_FILEDOWNLOADEVENT_PATH,
    WPC_ARGS_FILEDOWNLOADEVENT_CARGS
} WPC_ARGS_FILEDOWNLOADEVENT;

typedef enum tagWPC_ARGS_URLVISITEVENT
{
    WPC_ARGS_URLVISITEVENT_URL = 0,
    WPC_ARGS_URLVISITEVENT_APPNAME,
    WPC_ARGS_URLVISITEVENT_VERSION,
    WPC_ARGS_URLVISITEVENT_REASON,
    WPC_ARGS_URLVISITEVENT_RATINGSYSTEMID,
    WPC_ARGS_URLVISITEVENT_CATCOUNT,
    WPC_ARGS_URLVISITEVENT_CATEGORY,
    WPC_ARGS_URLVISITEVENT_CARGS
} WPC_ARGS_URLVISITEVENT;

typedef enum tagWPC_ARGS_CUSTOMEVENT
{
    WPC_ARGS_CUSTOMEVENT_PUBLISHER = 0,
    WPC_ARGS_CUSTOMEVENT_APPNAME,
    WPC_ARGS_CUSTOMEVENT_APPVERSION,
    WPC_ARGS_CUSTOMEVENT_EVENT,
    WPC_ARGS_CUSTOMEVENT_VALUE1,
    WPC_ARGS_CUSTOMEVENT_VALUE2,
    WPC_ARGS_CUSTOMEVENT_VALUE3,
    WPC_ARGS_CUSTOMEVENT_BLOCKED,
    WPC_ARGS_CUSTOMEVENT_REASON,
    WPC_ARGS_CUSTOMEVENT_CARGS
} WPC_ARGS_CUSTOMEVENT;

typedef enum tagWPC_ARGS_WEBOVERRIDEEVENT
{
    WPC_ARGS_WEBOVERRIDEEVENT_USERID = 0,
    WPC_ARGS_WEBOVERRIDEEVENT_URL,
    WPC_ARGS_WEBOVERRIDEEVENT_REASON,
    WPC_ARGS_WEBOVERRIDEEVENT_CARGS
} WPC_ARGS_WEBOVERRIDEEVENT;

typedef enum tagWPC_ARGS_APPOVERRIDEEVENT
{
    WPC_ARGS_APPOVERRIDEEVENT_USERID = 0,
    WPC_ARGS_APPOVERRIDEEVENT_PATH,
    WPC_ARGS_APPOVERRIDEEVENT_REASON,
    WPC_ARGS_APPOVERRIDEEVENT_CARGS
} WPC_ARGS_APPOVERRIDEEVENT;

//
// This is the list of settings that are written out to the log file as the setting id.
//
typedef enum tagWPC_SETTINGS
{
    WPC_SETTINGS_WPC_EXTENSION_PATH = 0,
    WPC_SETTINGS_WPC_EXTENSION_SILO,
    WPC_SETTINGS_WPC_EXTENSION_IMAGE_PATH,
    WPC_SETTINGS_WPC_EXTENSION_DISABLEDIMAGE_PATH,
    WPC_SETTINGS_WPC_EXTENSION_NAME,
    WPC_SETTINGS_WPC_EXTENSION_SUB_TITLE,
    WPC_SETTINGS_SYSTEM_CURRENT_RATING_SYSTEM,
    WPC_SETTINGS_SYSTEM_LAST_LOG_VIEW,
    WPC_SETTINGS_SYSTEM_LOG_VIEW_REMINDER_INTERVAL,
    WPC_SETTINGS_SYSTEM_HTTP_EXEMPTION_LIST,
    WPC_SETTINGS_SYSTEM_URL_EXEMPTION_LIST,
    WPC_SETTINGS_SYSTEM_FILTER_ID,
    WPC_SETTINGS_SYSTEM_FILTER_NAME, 
    WPC_SETTINGS_SYSTEM_LOCALE,
    WPC_SETTINGS_ALLOW_BLOCK,
    WPC_SETTINGS_GAME_BLOCKED,
    WPC_SETTINGS_GAME_ALLOW_UNRATED,
    WPC_SETTINGS_GAME_MAX_ALLOWED,
    WPC_SETTINGS_GAME_DENIED_DESCRIPTORS,
    WPC_SETTINGS_USER_WPC_ENABLED,
    WPC_SETTINGS_USER_LOGGING_REQUIRED,
    WPC_SETTINGS_USER_HOURLY_RESTRICTIONS,
    WPC_SETTINGS_USER_OVERRRIDE_REQUESTS,
    WPC_SETTINGS_USER_LOGON_HOURS,
    WPC_SETTINGS_USER_APP_RESTRICTIONS,
    WPC_SETTINGS_WEB_FILTER_ON,
    WPC_SETTINGS_WEB_DOWNLOAD_BLOCKED,
    WPC_SETTINGS_WEB_FILTER_LEVEL,
    WPC_SETTINGS_WEB_BLOCKED_CATEGORY_LIST,
    WPC_SETTINGS_WEB_BLOCK_UNRATED,
    WPC_SETTINGS_WPC_ENABLED,
    WPC_SETTINGS_WPC_LOGGING_REQUIRED,
    WPC_SETTINGS_RATING_SYSTEM_PATH,
    WPC_SETTING_COUNT
} WPC_SETTINGS;
#pragma once
EXTERN_C __declspec(selectany) const GUID WPCPROV = {0x01090065, 0xb467, 0x4503, {0x9b, 0x28,0x53,0x37,0x66,0x76,0x10,0x87}};
#define WPCCHANNEL 0x10
#define WPC_SETTINGS_LOCATE 0x14
#define WPC_SETTINGS_MODIFY 0x15
#define WPC_APP_LAUNCH 0x16
#define WPC_SYSTEM 0x17
#define WPC_WEB 0x18
#define WPCPROV_TASK_SettingChange 0x1
#define WPCPROV_TASK_GameStart 0x2
#define WPCPROV_TASK_UrlVisit 0x3
#define WPCPROV_TASK_EmailReceived 0x4
#define WPCPROV_TASK_EmailSent 0x5
#define WPCPROV_TASK_MediaPlayback 0x6
#define WPCPROV_TASK_IMInvitation 0x7
#define WPCPROV_TASK_IMJoin 0x8
#define WPCPROV_TASK_IMLeave 0x9
#define WPCPROV_TASK_FileDownload 0xa
#define WPCPROV_TASK_IMFeature 0xb
#define WPCPROV_TASK_Custom 0xd
#define WPCPROV_TASK_EmailContact 0xe
#define WPCPROV_TASK_IMContact 0xf
#define WPCPROV_TASK_AppBlocked 0x10
#define WPCPROV_TASK_AppOverride 0x11
#define WPCPROV_TASK_WebOverride 0x12
#define WPCPROV_KEYWORD_WPC 0x10
#define WPCPROV_KEYWORD_ThirdParty 0x20
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_SYS_SETTINGCHANGE = {0x1, 0x0, 0x10, 0x4, 0x15, 0x1, 0x8000000000000010};
#define WPCEVENT_SYS_SETTINGCHANGE_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_GAME_START = {0x2, 0x0, 0x10, 0x4, 0x16, 0x2, 0x8000000000000030};
#define WPCEVENT_GAME_START_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_WEB_URLVISIT = {0x3, 0x0, 0x10, 0x4, 0x18, 0x3, 0x8000000000000010};
#define WPCEVENT_WEB_URLVISIT_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_EMAIL_RECEIVED = {0x4, 0x0, 0x10, 0x4, 0x16, 0x4, 0x8000000000000030};
#define WPCEVENT_EMAIL_RECEIVED_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_EMAIL_SENT = {0x5, 0x0, 0x10, 0x4, 0x16, 0x5, 0x8000000000000030};
#define WPCEVENT_EMAIL_SENT_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_MEDIA_PLAYBACK = {0x6, 0x0, 0x10, 0x4, 0x16, 0x6, 0x8000000000000030};
#define WPCEVENT_MEDIA_PLAYBACK_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_IM_INVITATION = {0x7, 0x0, 0x10, 0x4, 0x16, 0x7, 0x8000000000000030};
#define WPCEVENT_IM_INVITATION_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_IM_JOIN = {0x8, 0x0, 0x10, 0x4, 0x16, 0x8, 0x8000000000000030};
#define WPCEVENT_IM_JOIN_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_IM_LEAVE = {0x9, 0x0, 0x10, 0x4, 0x16, 0x9, 0x8000000000000030};
#define WPCEVENT_IM_LEAVE_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_WEB_FILEDOWNLOAD = {0xa, 0x0, 0x10, 0x4, 0x18, 0xa, 0x8000000000000030};
#define WPCEVENT_WEB_FILEDOWNLOAD_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_IM_FEATURE = {0xb, 0x0, 0x10, 0x4, 0x16, 0xb, 0x8000000000000030};
#define WPCEVENT_IM_FEATURE_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_CUSTOM = {0xd, 0x0, 0x10, 0x4, 0x17, 0xd, 0x8000000000000030};
#define WPCEVENT_CUSTOM_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_EMAIL_CONTACT = {0xe, 0x0, 0x10, 0x4, 0x16, 0xe, 0x8000000000000030};
#define WPCEVENT_EMAIL_CONTACT_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_IM_CONTACT = {0xf, 0x0, 0x10, 0x4, 0x16, 0xf, 0x8000000000000030};
#define WPCEVENT_IM_CONTACT_value 0xf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_SYSTEM_APPBLOCKED = {0x10, 0x0, 0x10, 0x4, 0x16, 0x10, 0x8000000000000010};
#define WPCEVENT_SYSTEM_APPBLOCKED_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_APPOVERRIDE = {0x11, 0x0, 0x10, 0x4, 0x16, 0x11, 0x8000000000000010};
#define WPCEVENT_APPOVERRIDE_value 0x11
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WPCEVENT_WEBOVERRIDE = {0x12, 0x0, 0x10, 0x4, 0x16, 0x12, 0x8000000000000010};
#define WPCEVENT_WEBOVERRIDE_value 0x12
#define MSG_Event_AppBlocked             0xB0000010L

#define MSG_Event_AppOverride            0xB0000011L

#define MSG_Event_Custom                 0xB000000DL

#define MSG_Event_EmailContact           0xB000000EL

#define MSG_Event_EmailReceived          0xB0000004L

#define MSG_Event_EmailSent              0xB0000005L

#define MSG_Event_FileDownload           0xB000000AL

#define MSG_Event_GameStart              0xB0000002L

#define MSG_Event_IMContact              0xB000000FL

#define MSG_Event_IMFeature              0xB000000BL

#define MSG_Event_IMInvitation           0xB0000007L

#define MSG_Event_IMJoin                 0xB0000008L

#define MSG_Event_IMLeave                0xB0000009L

#define MSG_Event_MediaPlayback          0xB0000006L

#define MSG_Event_SettingChange          0xB0000001L

#define MSG_Event_UrlVisit               0xB0000003L

#define MSG_Event_WebOverride            0xB0000012L

#define MSG_Keyword_ThirdParty           0x10000006L

#define MSG_Keyword_WPC                  0x10000005L

#define MSG_Opcode_Launch                0x30160000L

#define MSG_Opcode_Locate                0x30140000L

#define MSG_Opcode_Modify                0x30150000L

#define MSG_Opcode_System                0x30170000L

#define MSG_Opcode_Web                   0x30180000L

#define MSG_Publisher_Name               0x90000001L

#define MSG_Task_AppBlocked              0x70000010L

#define MSG_Task_AppOverride             0x70000011L

#define MSG_Task_Custom                  0x7000000DL

#define MSG_Task_EmailContact            0x7000000EL

#define MSG_Task_EmailReceived           0x70000004L

#define MSG_Task_EmailSent               0x70000005L

#define MSG_Task_FileDownload            0x7000000AL

#define MSG_Task_GameStart               0x70000002L

#define MSG_Task_IMContact               0x7000000FL

#define MSG_Task_IMFeature               0x7000000BL

#define MSG_Task_IMInvitation            0x70000007L

#define MSG_Task_IMJoin                  0x70000008L

#define MSG_Task_IMLeave                 0x70000009L

#define MSG_Task_MediaPlayback           0x70000006L

#define MSG_Task_SettingChange           0x70000001L

#define MSG_Task_UrlVisit                0x70000003L

#define MSG_Task_WebOverride             0x70000012L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WowNT32.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-1999, Microsoft Corporation

Module Name:

    wownt32.h

Abstract:

    Procedure declarations for functions in WOW32.DLL callable by
    3rd-party 32-bit thunking code.

--*/

#ifndef _WOWNT32_
#define _WOWNT32_

#if defined(_MSC_VER)
#if _MSC_VER > 1000
#pragma once
#endif
#endif

//
// 16:16 -> 0:32 Pointer translation.
//
// WOWGetVDMPointer will convert the passed in 16-bit address
// to the equivalent 32-bit flat pointer.  If fProtectedMode
// is TRUE, the function treats the upper 16 bits as a selector
// in the local descriptor table.  If fProtectedMode is FALSE,
// the upper 16 bits are treated as a real-mode segment value.
// In either case the lower 16 bits are treated as the offset.
//
// The return value is NULL if the selector is invalid.
//
// NOTE:  Limit checking is not performed in the retail build
// of Windows NT.  It is performed in the checked (debug) build
// of WOW32.DLL, which will cause NULL to be returned when the
// limit is exceeded by the supplied offset.
//

LPVOID WINAPI WOWGetVDMPointer(DWORD vp, DWORD dwBytes,
                               BOOL fProtectedMode);

//
// The following two functions are here for compatibility with
// Windows 95.  On Win95, the global heap can be rearranged,
// invalidating flat pointers returned by WOWGetVDMPointer, while
// a thunk is executing.  On Windows NT, the 16-bit VDM is completely
// halted while a thunk executes, so the only way the heap will
// be rearranged is if a callback is made to Win16 code.
//
// The Win95 versions of these functions call GlobalFix to
// lock down a segment's flat address, and GlobalUnfix to
// release the segment.
//
// The Windows NT implementations of these functions do *not*
// call GlobalFix/GlobalUnfix on the segment, because there
// will not be any heap motion unless a callback occurs.
// If your thunk does callback to the 16-bit side, be sure
// to discard flat pointers and call WOWGetVDMPointer again
// to be sure the flat address is correct.
//

LPVOID WINAPI WOWGetVDMPointerFix(DWORD vp, DWORD dwBytes,
                                  BOOL fProtectedMode);
VOID WINAPI WOWGetVDMPointerUnfix(DWORD vp);


//
// Win16 memory management.
//
// These functions can be used to manage memory in the Win16
// heap.  The following four functions are identical to their
// Win16 counterparts, except that they are called from Win32
// code.
//

WORD  WINAPI WOWGlobalAlloc16(WORD wFlags, DWORD cb);
WORD  WINAPI WOWGlobalFree16(WORD hMem);
DWORD WINAPI WOWGlobalLock16(WORD hMem);
BOOL  WINAPI WOWGlobalUnlock16(WORD hMem);

//
// The following three functions combine two common operations in
// one switch to 16-bit mode.
//

DWORD WINAPI WOWGlobalAllocLock16(WORD wFlags, DWORD cb, WORD *phMem);
WORD  WINAPI WOWGlobalUnlockFree16(DWORD vpMem);
DWORD WINAPI WOWGlobalLockSize16(WORD hMem, PDWORD pcb);

//
// Yielding the Win16 nonpreemptive scheduler
//
// The following two functions are provided for Win32 code called
// via Generic Thunks which needs to yield the Win16 scheduler so
// that tasks in that VDM can execute while the thunk waits for
// something to complete.  These two functions are functionally
// identical to calling back to 16-bit code which calls Yield or
// DirectedYield.
//

VOID WINAPI WOWYield16(VOID);
VOID WINAPI WOWDirectedYield16(WORD htask16);


//
// 16 <--> 32 Handle mapping functions.
//
// NOTE:  While some of these functions perform trivial
// conversions, these functions must be used to maintain
// compatibility with future versions of Windows NT which
// may require different handle mapping.
//

typedef enum _WOW_HANDLE_TYPE { /* WOW */
    WOW_TYPE_HWND,
    WOW_TYPE_HMENU,
    WOW_TYPE_HDWP,
    WOW_TYPE_HDROP,
    WOW_TYPE_HDC,
    WOW_TYPE_HFONT,
    WOW_TYPE_HMETAFILE,
    WOW_TYPE_HRGN,
    WOW_TYPE_HBITMAP,
    WOW_TYPE_HBRUSH,
    WOW_TYPE_HPALETTE,
    WOW_TYPE_HPEN,
    WOW_TYPE_HACCEL,
    WOW_TYPE_HTASK,
    WOW_TYPE_FULLHWND
} WOW_HANDLE_TYPE;

HANDLE WINAPI WOWHandle32 (WORD, WOW_HANDLE_TYPE);
WORD WINAPI WOWHandle16 (HANDLE, WOW_HANDLE_TYPE);

#define HWND_32(h16)      ((HWND)      (WOWHandle32(h16, WOW_TYPE_HWND)))
#define HMENU_32(h16)     ((HMENU)     (WOWHandle32(h16, WOW_TYPE_HMENU)))
#define HDWP_32(h16)      ((HDWP)      (WOWHandle32(h16, WOW_TYPE_HDWP)))
#define HDROP_32(h16)     ((HDROP)     (WOWHandle32(h16, WOW_TYPE_HDROP)))
#define HDC_32(h16)       ((HDC)       (WOWHandle32(h16, WOW_TYPE_HDC)))
#define HFONT_32(h16)     ((HFONT)     (WOWHandle32(h16, WOW_TYPE_HFONT)))
#define HMETAFILE_32(h16) ((HMETAFILE) (WOWHandle32(h16, WOW_TYPE_HMETAFILE)))
#define HRGN_32(h16)      ((HRGN)      (WOWHandle32(h16, WOW_TYPE_HRGN)))
#define HBITMAP_32(h16)   ((HBITMAP)   (WOWHandle32(h16, WOW_TYPE_HBITMAP)))
#define HBRUSH_32(h16)    ((HBRUSH)    (WOWHandle32(h16, WOW_TYPE_HBRUSH)))
#define HPALETTE_32(h16)  ((HPALETTE)  (WOWHandle32(h16, WOW_TYPE_HPALETTE)))
#define HPEN_32(h16)      ((HPEN)      (WOWHandle32(h16, WOW_TYPE_HPEN)))
#define HACCEL_32(h16)	  ((HACCEL)    (WOWHandle32(h16, WOW_TYPE_HACCEL)))
#define HTASK_32(h16)	  ((DWORD)     (WOWHandle32(h16, WOW_TYPE_HTASK)))
#define FULLHWND_32(h16)  ((HWND)      (WOWHandle32(h16, WOW_TYPE_FULLHWND)))

#define HWND_16(h32)      (WOWHandle16(h32, WOW_TYPE_HWND))
#define HMENU_16(h32)     (WOWHandle16(h32, WOW_TYPE_HMENU))
#define HDWP_16(h32)      (WOWHandle16(h32, WOW_TYPE_HDWP))
#define HDROP_16(h32)     (WOWHandle16(h32, WOW_TYPE_HDROP))
#define HDC_16(h32)       (WOWHandle16(h32, WOW_TYPE_HDC))
#define HFONT_16(h32)     (WOWHandle16(h32, WOW_TYPE_HFONT))
#define HMETAFILE_16(h32) (WOWHandle16(h32, WOW_TYPE_HMETAFILE))
#define HRGN_16(h32)      (WOWHandle16(h32, WOW_TYPE_HRGN))
#define HBITMAP_16(h32)   (WOWHandle16(h32, WOW_TYPE_HBITMAP))
#define HBRUSH_16(h32)    (WOWHandle16(h32, WOW_TYPE_HBRUSH))
#define HPALETTE_16(h32)  (WOWHandle16(h32, WOW_TYPE_HPALETTE))
#define HPEN_16(h32)      (WOWHandle16(h32, WOW_TYPE_HPEN))
#define HACCEL_16(h32)	  (WOWHandle16(h32, WOW_TYPE_HACCEL))
#define HTASK_16(h32)	  (WOWHandle16(h32, WOW_TYPE_HTASK))

//
// Generic Callbacks.
//
// WOWCallback16 can be used in Win32 code called
// from 16-bit (such as by using Generic Thunks) to call back to
// the 16-bit side.  The function called must be declared similarly
// to the following:
//
// LONG FAR PASCAL CallbackRoutine(DWORD dwParam);
//
// If you are passing a pointer, declare the parameter as such:
//
// LONG FAR PASCAL CallbackRoutine(VOID FAR *vp);
//
// NOTE: If you are passing a pointer, you'll need to get the
// pointer using WOWGlobalAlloc16 or WOWGlobalAllocLock16
//
// If the function called returns a WORD instead of a DWORD, the
// upper 16 bits of the return value is undefined.  Similarly, if
// the function called has no return value, the entire return value
// is undefined.
//
// WOWCallback16Ex allows any combination of arguments up to
// WCB16_MAX_CBARGS bytes total to be passed to the 16-bit routine.
// cbArgs is used to properly clean up the 16-bit stack after calling
// the routine.  Regardless of the value of cbArgs, WCB16_MAX_CBARGS
// bytes will always be copied from pArgs to the 16-bit stack.  If
// pArgs is less than WCB16_MAX_CBARGS bytes from the end of a page,
// and the next page is inaccessible, WOWCallback16Ex will incur an
// access violation.
//
// If cbArgs is larger than the WCB16_MAX_ARGS which the running
// system supports, the function returns FALSE and GetLastError
// returns ERROR_INVALID_PARAMETER.  Otherwise the function
// returns TRUE and the DWORD pointed to by pdwRetCode contains
// the return code from the callback routine.  If the callback
// routine returns a WORD, the HIWORD of the return code is
// undefined and should be ignored using LOWORD(dwRetCode).
//
// WOWCallback16Ex can call routines using the PASCAL and CDECL
// calling conventions.  The default is to use the PASCAL
// calling convention.  To use CDECL, pass WCB16_CDECL in the
// dwFlags parameter.
//
// The arguments pointed to by pArgs must be in the correct
// order for the callback routine's calling convention.
// To call the PASCAL routine SetWindowText,
//
// LONG FAR PASCAL SetWindowText(HWND hwnd, LPCSTR lpsz);
//
// pArgs would point to an array of words:
//
// WORD SetWindowTextArgs[] = {OFFSETOF(lpsz), SELECTOROF(lpsz), hwnd};
//
// In other words, the arguments are placed in the array in reverse
// order with the least significant word first for DWORDs and offset
// first for FAR pointers.
//
// To call the CDECL routine wsprintf, for example
//
// LPSTR lpszFormat = "%d %s";
// int __cdecl wsprintf(lpsz, lpszFormat, nValue. lpszString);
//
// pArgs would point to the array:
//
// WORD wsprintfArgs[] = {OFFSETOF(lpsz), SELECTOROF(lpsz),
//                        OFFSETOF(lpszFormat), SELECTOROF(lpszFormat),
//                        nValue,
//                        OFFSETOF(lpszString), SELECTOROF(lpszString)};
//
// In other words, the arguments are placed in the array in the order
// listed in the function prototype with the least significant word
// first for DWORDs and offset first for FAR pointers.
//

DWORD WINAPI WOWCallback16(DWORD vpfn16, DWORD dwParam);

#define WCB16_MAX_CBARGS (16)

#define WCB16_PASCAL     (0x0)
#define WCB16_CDECL      (0x1)

BOOL WINAPI WOWCallback16Ex(
                DWORD  vpfn16,
                DWORD  dwFlags,
                DWORD  cbArgs,
                PVOID  pArgs,
                PDWORD pdwRetCode
                );

#endif /* !_WOWNT32_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wpcapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for WpcApi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __WpcApi_h__
#define __WpcApi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWPCSettings_FWD_DEFINED__
#define __IWPCSettings_FWD_DEFINED__
typedef interface IWPCSettings IWPCSettings;
#endif 	/* __IWPCSettings_FWD_DEFINED__ */


#ifndef __IWPCGamesSettings_FWD_DEFINED__
#define __IWPCGamesSettings_FWD_DEFINED__
typedef interface IWPCGamesSettings IWPCGamesSettings;
#endif 	/* __IWPCGamesSettings_FWD_DEFINED__ */


#ifndef __IWPCWebSettings_FWD_DEFINED__
#define __IWPCWebSettings_FWD_DEFINED__
typedef interface IWPCWebSettings IWPCWebSettings;
#endif 	/* __IWPCWebSettings_FWD_DEFINED__ */


#ifndef __IWindowsParentalControlsCore_FWD_DEFINED__
#define __IWindowsParentalControlsCore_FWD_DEFINED__
typedef interface IWindowsParentalControlsCore IWindowsParentalControlsCore;
#endif 	/* __IWindowsParentalControlsCore_FWD_DEFINED__ */


#ifndef __IWindowsParentalControls_FWD_DEFINED__
#define __IWindowsParentalControls_FWD_DEFINED__
typedef interface IWindowsParentalControls IWindowsParentalControls;
#endif 	/* __IWindowsParentalControls_FWD_DEFINED__ */


#ifndef __WpcSettingsProvider_FWD_DEFINED__
#define __WpcSettingsProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class WpcSettingsProvider WpcSettingsProvider;
#else
typedef struct WpcSettingsProvider WpcSettingsProvider;
#endif /* __cplusplus */

#endif 	/* __WpcSettingsProvider_FWD_DEFINED__ */


#ifndef __WindowsParentalControls_FWD_DEFINED__
#define __WindowsParentalControls_FWD_DEFINED__

#ifdef __cplusplus
typedef class WindowsParentalControls WindowsParentalControls;
#else
typedef struct WindowsParentalControls WindowsParentalControls;
#endif /* __cplusplus */

#endif 	/* __WindowsParentalControls_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_WpcApi_0000_0000 */
/* [local] */ 

/*******************************************************************************/
/*                                                                             */
/*    Copyright (C) Microsoft Corporation.  All rights reserved.                 */
/*                                                                             */
/*    Interfaces for Windows Parental Controls clients.                        */
/*                                                                             */
/*******************************************************************************/
typedef /* [v1_enum] */ 
enum tagWPCFLAG_RESTRICTION
    {	WPCFLAG_NO_RESTRICTION	= 0,
	WPCFLAG_LOGGING_REQUIRED	= 0x1,
	WPCFLAG_WEB_FILTERED	= 0x2,
	WPCFLAG_HOURS_RESTRICTED	= 0x4,
	WPCFLAG_GAMES_BLOCKED	= 0x8,
	WPCFLAG_APPS_RESTRICTED	= 0x10
    } 	WPCFLAG_RESTRICTION;



extern RPC_IF_HANDLE __MIDL_itf_WpcApi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_WpcApi_0000_0000_v0_0_s_ifspec;

#ifndef __IWPCSettings_INTERFACE_DEFINED__
#define __IWPCSettings_INTERFACE_DEFINED__

/* interface IWPCSettings */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWPCSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8FDF6CA1-0189-47e4-B670-1A8A4636E340")
    IWPCSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsLoggingRequired( 
            /* [out] */ __RPC__out BOOL *pfRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastSettingsChangeTime( 
            /* [out] */ __RPC__out SYSTEMTIME *pTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestrictions( 
            /* [out] */ __RPC__out DWORD *pdwRestrictions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWPCSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWPCSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWPCSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWPCSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsLoggingRequired )( 
            IWPCSettings * This,
            /* [out] */ __RPC__out BOOL *pfRequired);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastSettingsChangeTime )( 
            IWPCSettings * This,
            /* [out] */ __RPC__out SYSTEMTIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestrictions )( 
            IWPCSettings * This,
            /* [out] */ __RPC__out DWORD *pdwRestrictions);
        
        END_INTERFACE
    } IWPCSettingsVtbl;

    interface IWPCSettings
    {
        CONST_VTBL struct IWPCSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWPCSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWPCSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWPCSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWPCSettings_IsLoggingRequired(This,pfRequired)	\
    ( (This)->lpVtbl -> IsLoggingRequired(This,pfRequired) ) 

#define IWPCSettings_GetLastSettingsChangeTime(This,pTime)	\
    ( (This)->lpVtbl -> GetLastSettingsChangeTime(This,pTime) ) 

#define IWPCSettings_GetRestrictions(This,pdwRestrictions)	\
    ( (This)->lpVtbl -> GetRestrictions(This,pdwRestrictions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWPCSettings_INTERFACE_DEFINED__ */


#ifndef __IWPCGamesSettings_INTERFACE_DEFINED__
#define __IWPCGamesSettings_INTERFACE_DEFINED__

/* interface IWPCGamesSettings */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWPCGamesSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95E87780-E158-489e-B452-BBB850790715")
    IWPCGamesSettings : public IWPCSettings
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsBlocked( 
            /* [in] */ GUID guidAppID,
            /* [out] */ __RPC__out DWORD *pdwReasons) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWPCGamesSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWPCGamesSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWPCGamesSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWPCGamesSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsLoggingRequired )( 
            IWPCGamesSettings * This,
            /* [out] */ __RPC__out BOOL *pfRequired);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastSettingsChangeTime )( 
            IWPCGamesSettings * This,
            /* [out] */ __RPC__out SYSTEMTIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestrictions )( 
            IWPCGamesSettings * This,
            /* [out] */ __RPC__out DWORD *pdwRestrictions);
        
        HRESULT ( STDMETHODCALLTYPE *IsBlocked )( 
            IWPCGamesSettings * This,
            /* [in] */ GUID guidAppID,
            /* [out] */ __RPC__out DWORD *pdwReasons);
        
        END_INTERFACE
    } IWPCGamesSettingsVtbl;

    interface IWPCGamesSettings
    {
        CONST_VTBL struct IWPCGamesSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWPCGamesSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWPCGamesSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWPCGamesSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWPCGamesSettings_IsLoggingRequired(This,pfRequired)	\
    ( (This)->lpVtbl -> IsLoggingRequired(This,pfRequired) ) 

#define IWPCGamesSettings_GetLastSettingsChangeTime(This,pTime)	\
    ( (This)->lpVtbl -> GetLastSettingsChangeTime(This,pTime) ) 

#define IWPCGamesSettings_GetRestrictions(This,pdwRestrictions)	\
    ( (This)->lpVtbl -> GetRestrictions(This,pdwRestrictions) ) 


#define IWPCGamesSettings_IsBlocked(This,guidAppID,pdwReasons)	\
    ( (This)->lpVtbl -> IsBlocked(This,guidAppID,pdwReasons) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWPCGamesSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_WpcApi_0000_0002 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagWPCFLAG_WEB_SETTING
    {	WPCFLAG_WEB_SETTING_NOTBLOCKED	= 0,
	WPCFLAG_WEB_SETTING_DOWNLOADSBLOCKED	= 0x1
    } 	WPCFLAG_WEB_SETTING;



extern RPC_IF_HANDLE __MIDL_itf_WpcApi_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_WpcApi_0000_0002_v0_0_s_ifspec;

#ifndef __IWPCWebSettings_INTERFACE_DEFINED__
#define __IWPCWebSettings_INTERFACE_DEFINED__

/* interface IWPCWebSettings */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWPCWebSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FFCCBDB8-0992-4c30-B0F1-1CBB09C240AA")
    IWPCWebSettings : public IWPCSettings
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSettings( 
            /* [out] */ __RPC__out DWORD *pdwSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestURLOverride( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ __RPC__in LPCWSTR pcszURL,
            /* [in] */ DWORD cURLs,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cURLs) LPCWSTR *ppcszSubURLs,
            /* [unique][out][in] */ __RPC__inout_opt BOOL *pfChanged) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWPCWebSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWPCWebSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWPCWebSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWPCWebSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsLoggingRequired )( 
            IWPCWebSettings * This,
            /* [out] */ __RPC__out BOOL *pfRequired);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastSettingsChangeTime )( 
            IWPCWebSettings * This,
            /* [out] */ __RPC__out SYSTEMTIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestrictions )( 
            IWPCWebSettings * This,
            /* [out] */ __RPC__out DWORD *pdwRestrictions);
        
        HRESULT ( STDMETHODCALLTYPE *GetSettings )( 
            IWPCWebSettings * This,
            /* [out] */ __RPC__out DWORD *pdwSettings);
        
        HRESULT ( STDMETHODCALLTYPE *RequestURLOverride )( 
            IWPCWebSettings * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ __RPC__in LPCWSTR pcszURL,
            /* [in] */ DWORD cURLs,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cURLs) LPCWSTR *ppcszSubURLs,
            /* [unique][out][in] */ __RPC__inout_opt BOOL *pfChanged);
        
        END_INTERFACE
    } IWPCWebSettingsVtbl;

    interface IWPCWebSettings
    {
        CONST_VTBL struct IWPCWebSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWPCWebSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWPCWebSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWPCWebSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWPCWebSettings_IsLoggingRequired(This,pfRequired)	\
    ( (This)->lpVtbl -> IsLoggingRequired(This,pfRequired) ) 

#define IWPCWebSettings_GetLastSettingsChangeTime(This,pTime)	\
    ( (This)->lpVtbl -> GetLastSettingsChangeTime(This,pTime) ) 

#define IWPCWebSettings_GetRestrictions(This,pdwRestrictions)	\
    ( (This)->lpVtbl -> GetRestrictions(This,pdwRestrictions) ) 


#define IWPCWebSettings_GetSettings(This,pdwSettings)	\
    ( (This)->lpVtbl -> GetSettings(This,pdwSettings) ) 

#define IWPCWebSettings_RequestURLOverride(This,hWnd,pcszURL,cURLs,ppcszSubURLs,pfChanged)	\
    ( (This)->lpVtbl -> RequestURLOverride(This,hWnd,pcszURL,cURLs,ppcszSubURLs,pfChanged) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWPCWebSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_WpcApi_0000_0003 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagWPCFLAG_VISIBILITY
    {	WPCFLAG_WPC_VISIBLE	= 0,
	WPCFLAG_WPC_HIDDEN	= 0x1
    } 	WPCFLAG_VISIBILITY;



extern RPC_IF_HANDLE __MIDL_itf_WpcApi_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_WpcApi_0000_0003_v0_0_s_ifspec;

#ifndef __IWindowsParentalControlsCore_INTERFACE_DEFINED__
#define __IWindowsParentalControlsCore_INTERFACE_DEFINED__

/* interface IWindowsParentalControlsCore */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWindowsParentalControlsCore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FF40A0F-3F3B-4d7c-A41B-4F39D7B44D05")
    IWindowsParentalControlsCore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVisibility( 
            /* [out] */ __RPC__out WPCFLAG_VISIBILITY *peVisibility) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserSettings( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCSettings **ppSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWebSettings( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCWebSettings **ppSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWebFilterInfo( 
            /* [out] */ __RPC__out GUID *pguidID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowsParentalControlsCoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowsParentalControlsCore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowsParentalControlsCore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowsParentalControlsCore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisibility )( 
            IWindowsParentalControlsCore * This,
            /* [out] */ __RPC__out WPCFLAG_VISIBILITY *peVisibility);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserSettings )( 
            IWindowsParentalControlsCore * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCSettings **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *GetWebSettings )( 
            IWindowsParentalControlsCore * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCWebSettings **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *GetWebFilterInfo )( 
            IWindowsParentalControlsCore * This,
            /* [out] */ __RPC__out GUID *pguidID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszName);
        
        END_INTERFACE
    } IWindowsParentalControlsCoreVtbl;

    interface IWindowsParentalControlsCore
    {
        CONST_VTBL struct IWindowsParentalControlsCoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowsParentalControlsCore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowsParentalControlsCore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowsParentalControlsCore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowsParentalControlsCore_GetVisibility(This,peVisibility)	\
    ( (This)->lpVtbl -> GetVisibility(This,peVisibility) ) 

#define IWindowsParentalControlsCore_GetUserSettings(This,pcszSID,ppSettings)	\
    ( (This)->lpVtbl -> GetUserSettings(This,pcszSID,ppSettings) ) 

#define IWindowsParentalControlsCore_GetWebSettings(This,pcszSID,ppSettings)	\
    ( (This)->lpVtbl -> GetWebSettings(This,pcszSID,ppSettings) ) 

#define IWindowsParentalControlsCore_GetWebFilterInfo(This,pguidID,ppszName)	\
    ( (This)->lpVtbl -> GetWebFilterInfo(This,pguidID,ppszName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowsParentalControlsCore_INTERFACE_DEFINED__ */


#ifndef __IWindowsParentalControls_INTERFACE_DEFINED__
#define __IWindowsParentalControls_INTERFACE_DEFINED__

/* interface IWindowsParentalControls */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWindowsParentalControls;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28B4D88B-E072-49e6-804D-26EDBE21A7B9")
    IWindowsParentalControls : public IWindowsParentalControlsCore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGamesSettings( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCGamesSettings **ppSettings) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowsParentalControlsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowsParentalControls * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowsParentalControls * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowsParentalControls * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisibility )( 
            IWindowsParentalControls * This,
            /* [out] */ __RPC__out WPCFLAG_VISIBILITY *peVisibility);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserSettings )( 
            IWindowsParentalControls * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCSettings **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *GetWebSettings )( 
            IWindowsParentalControls * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCWebSettings **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *GetWebFilterInfo )( 
            IWindowsParentalControls * This,
            /* [out] */ __RPC__out GUID *pguidID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetGamesSettings )( 
            IWindowsParentalControls * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pcszSID,
            /* [out] */ __RPC__deref_out_opt IWPCGamesSettings **ppSettings);
        
        END_INTERFACE
    } IWindowsParentalControlsVtbl;

    interface IWindowsParentalControls
    {
        CONST_VTBL struct IWindowsParentalControlsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowsParentalControls_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowsParentalControls_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowsParentalControls_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowsParentalControls_GetVisibility(This,peVisibility)	\
    ( (This)->lpVtbl -> GetVisibility(This,peVisibility) ) 

#define IWindowsParentalControls_GetUserSettings(This,pcszSID,ppSettings)	\
    ( (This)->lpVtbl -> GetUserSettings(This,pcszSID,ppSettings) ) 

#define IWindowsParentalControls_GetWebSettings(This,pcszSID,ppSettings)	\
    ( (This)->lpVtbl -> GetWebSettings(This,pcszSID,ppSettings) ) 

#define IWindowsParentalControls_GetWebFilterInfo(This,pguidID,ppszName)	\
    ( (This)->lpVtbl -> GetWebFilterInfo(This,pguidID,ppszName) ) 


#define IWindowsParentalControls_GetGamesSettings(This,pcszSID,ppSettings)	\
    ( (This)->lpVtbl -> GetGamesSettings(This,pcszSID,ppSettings) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowsParentalControls_INTERFACE_DEFINED__ */



#ifndef __WPCAPILib_LIBRARY_DEFINED__
#define __WPCAPILib_LIBRARY_DEFINED__

/* library WPCAPILib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WPCAPILib;

EXTERN_C const CLSID CLSID_WpcSettingsProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("355DFFAA-3B9F-435c-B428-5D44290BC5F2")
WpcSettingsProvider;
#endif

EXTERN_C const CLSID CLSID_WindowsParentalControls;

#ifdef __cplusplus

class DECLSPEC_UUID("E77CC89B-7401-4c04-8CED-149DB35ADD04")
WindowsParentalControls;
#endif
#endif /* __WPCAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wpdmtpextensions.h ===
//=============================================================================
//
// @module      WpdMtpExtensions.h
//
// @created     12-08-2004
//
// @abstract    Contains WPD definitions for working with MTP vendor-extended functionalities
//
// @copyright   (C) COPYRIGHT MICROSOFT CORPORATION, 2004
//
//=============================================================================

/**************************************************************************** 
* This section defines WPD commands for MTP vendor-extended operations
****************************************************************************/
// {4D545058-1A2E-4106-A357-771E0819FC56}
DEFINE_GUID( WPD_CATEGORY_MTP_EXT_VENDOR_OPERATIONS , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 );

//
// MTP extended commands for WPD_CATEGORY_MTP_EXT_VENDOR_OPERATIONS
//
// Cmd Key: WPD_COMMAND_MTP_EXT_GET_SUPPORTED_VENDOR_OPCODES
// Usage:   queries for vendor extended operation codes
// Inputs:  None
// Outputs: WPD_PROPERTY_MTP_EXT_VENDOR_OPERATION_CODES: an IPortableDevicePropVariantCollection (of VT_UI4)
//                                which contains all vendor-extended operation codes 
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_GET_SUPPORTED_VENDOR_OPCODES , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 11 ); 

//
// Cmd Key: WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITHOUT_DATA_PHASE 
// Usage:   sends a MTP command block that no data phase follows
// Inputs:  WPD_PROPERTY_MTP_EXT_OPERATION_CODE (VT_UI4): identifies the vendor-extended MTP operation code
//          WPD_PROPERTY_MTP_EXT_OPERATION_PARAMS: An IPortableDevicePropVariantCollection (of VT_UI4)
//                                                 which identifies the required params for the vendor operation code.
// Outputs: WPD_PROPERTY_MTP_EXT_RESPONSE_CODE: [VT_UI4] the response code to the vendor operation code, and 
//          WPD_PROPERTY_MTP_EXT_RESPONSE_PARAMS: An IPortableDevicePropVariantCollection (of VT_UI4) identifying response params if any (could be empty)
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITHOUT_DATA_PHASE , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 12 ); 

//
// Cmd Key: WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_READ 
// Usage:   sends a MTP command block followed by a data phase with data from Device to Host
// Inputs:  WPD_PROPERTY_MTP_EXT_OPERATION_CODE (VT_UI4): identifies the vendor-extended MTP operation code
//          WPD_PROPERTY_MTP_EXT_OPERATION_PARAMS: An IPortableDevicePropVariantCollection (of VT_UI4)
//                                                 which identifies the required params for the vendor operation code.
// Outputs: WPD_PROPERTY_MTP_EXT_TRANSFER_TOTAL_DATA_SIZE: [VT_UI8] Returns the total data size in bytes (excluding any overhead) coming from device.
//                                                         if Devie reports unknown datasize (0xFFFFFFFF), call ReadData() repeatedly until a short chunk received
//          WPD_PROPERTY_MTP_EXT_OPTIMAL_TRANSFER_BUFFER_SIZE: [VT_UI4] Returns the optimal size of the transfer buffer
//          WPD_PROPERTY_MTP_EXT_TRANSFER_CONTEXT: [VT_LPWSTR] Returned as a context idetifier for subsequent data transfer 
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_READ , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 13 ); 

//
// Cmd Key: WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_WRITE 
// Usage:   sends a MTP command block followed by a data phase with data from Host to Device 
// Inputs:  WPD_PROPERTY_MTP_EXT_OPERATION_CODE (VT_UI4): identifies the vendor-extended MTP operation code
//          WPD_PROPERTY_MTP_EXT_OPERATION_PARAMS: An IPortableDevicePropVariantCollection (of VT_UI4)
//                                                 which identifies the required params for the vendor operation code.
//          WPD_PROPERTY_MTP_EXT_TRANSFER_TOTAL_DATA_SIZE: [VT_UI8] Specifies the total data size in bytes (excluding any overhead) to be sent to device
// Outputs: WPD_PROPERTY_MTP_EXT_OPTIMAL_TRANSFER_BUFFER_SIZE: [VT_UI4] Returns the optimal size of the transfer buffer
//          WPD_PROPERTY_MTP_EXT_TRANSFER_CONTEXT: [VT_LPWSTR] Returned as a context idetifier for subsequent data transfer 
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_WRITE , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 14 );

//
// Cmd Key: WPD_COMMAND_MTP_EXT_READ_DATA 
// Usage:   receives a chunk of data from device following WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_READ
// Inputs:  WPD_PROPERTY_MTP_EXT_TRANSFER_CONTEXT: [VT_LPWSTR] The context idetifier returned in previous calls 
//          WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_TO_READ: [VT_UI4] specifies the next number of bytes to read.
//          WPD_PROPERTY_MTP_EXT_TRANSFER_DATA: [VT_VECTOR|VT_UI1] specifies the buffer to which the data from device will be copied
// Outputs: WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_READ: [VT_UI4] returns actual number of bytes (no overhead) received from device in a read call 
//          WPD_PROPERTY_MTP_EXT_TRANSFER_DATA: [VT_VECTOR|VT_UI1] Returns the buffer with received data
//          
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_READ_DATA , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 15 ); 

//
// Cmd Key: WPD_COMMAND_MTP_EXT_WRITE_DATA 
// Usage:   sends a chunk of data to device following WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_WRITE
// Inputs:  WPD_PROPERTY_MTP_EXT_TRANSFER_CONTEXT: [VT_LPWSTR] The context idetifier returned in previous calls 
//          WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_TO_WRITE: [VT_UI4] specifies the next number of bytes to write.
//          WPD_PROPERTY_MTP_EXT_TRANSFER_DATA: [VT_VECTOR|VT_UI1] specifies the buffer which contains the data to send to device 
// Outputs: WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_WRITTEN: [VT_UI4] returns actual number of bytes (no overhead) sent to device in a write call 
//    
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_WRITE_DATA , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 16 );

//
// Cmd Key: WPD_COMMAND_MTP_EXT_END_DATA_TRANSFER 
// Usage:   completes a data transfer and read response from device. The transfer is initiated by either 
//              WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_READ, or WPD_COMMAND_MTP_EXT_EXECUTE_COMMAND_WITH_DATA_TO_WRITE
// Inputs:  WPD_PROPERTY_MTP_EXT_TRANSFER_CONTEXT: [VT_LPWSTR] The context idetifier returned in previous calls 
// Outputs: WPD_PROPERTY_MTP_EXT_RESPONSE_CODE: [VT_UI4] the response code to the vendor operation code, and 
//          WPD_PROPERTY_MTP_EXT_RESPONSE_PARAMS: An IPortableDevicePropVariantCollection (of VT_UI4) identifying response params if any (could be empty)
//  
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_END_DATA_TRANSFER , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 17 );  

//
// Cmd Key: WPD_COMMAND_MTP_EXT_GET_VENDOR_EXTENSION_DESCRIPTION
// Usage:   retrieves the vendor extension description string (as defined by DeviceInfo dataset)
// Inputs:  None
// Outputs: WPD_PROPERTY_MTP_EXT_VENDOR_EXTENSION_DESCRIPTION: [VT_LPWSTR] contains the vendor extension description string 
DEFINE_PROPERTYKEY( WPD_COMMAND_MTP_EXT_GET_VENDOR_EXTENSION_DESCRIPTION , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 18 ); 

// Command Parameters 
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_OPERATION_CODE , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1001 );    // [ VT_UI4 ] : Input param which identifies the vendor-extended MTP operation code
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_OPERATION_PARAMS , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1002 );    // [ VT_UNKNOWN ] : Input IPortableDevicePropVariantCollection (of VT_UI4) specifying the params for the vendor operation
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_RESPONSE_CODE , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1003 );    // [ VT_UI4 ] : Output param which identifies the response code for the vendor operation
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_RESPONSE_PARAMS , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1004 );    // [ VT_UNKNOWN ] : Returns an IPortableDevicePropVariantCollection (of VT_UI4) of response params for the vendor operation
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_VENDOR_OPERATION_CODES , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1005 );    // [ VT_UNKNOWN ] : Returns an IPortableDevicePropVariantCollection (of VT_UI4) of Vendor-extended MTP codes 
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_TRANSFER_CONTEXT , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1006 );    // [ VT_LPWSTR ] : Returned as a context idetifier (a string value) for subsequent data transfer 
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_TRANSFER_TOTAL_DATA_SIZE , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1007 );    // [ VT_UI8 ] : Input (when writing data) or output (when reading data) param which specifies total data size in bytes (excluding any overhead)
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_TO_READ , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1008 ); // [ VT_UI4 ] : Input param specifying the number of bytes to read from device in a series of read calls 
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_READ , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1009 ); // [ VT_UI4 ] : Output param specifying the actual number of bytes (no overhead) received from device in a read call 
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_TO_WRITE , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1010 ); // [ VT_UI4 ] : Input specifying the number of bytes to send to device in a series of write calls
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_TRANSFER_NUM_BYTES_WRITTEN , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1011 ); // [ VT_UI4 ] : Returns the actual number of bytes (no overhead) sent to device in a write call 
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_TRANSFER_DATA , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1012 ); // [ VT_VECTOR|VT_UI1 ] : Stores the binary data to transfer from/to device
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_OPTIMAL_TRANSFER_BUFFER_SIZE , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1013 ); // [ VT_UI4 ] : Returns the optimal size of the transfer buffer
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_VENDOR_EXTENSION_DESCRIPTION , 0x4d545058, 0x1a2e, 0x4106, 0xa3, 0x57, 0x77, 0x1e, 0x8, 0x19, 0xfc, 0x56 , 1014 ); // [ VT_LPWSTR ] : Returns vendor extension description string


/**************************************************************************** 
* This section defines the GUID for MTP Vendor-extended object properties 
****************************************************************************/
//
// Microsoft MTP driver combines this GUID and any vendor-extended MTP object property code (as pid) 
// to construct a WPD PROPERTYKEY, which is reported to WPD applications as a WPD property.
// For example, vendor extended object prop code, 0xD801, will be reported as WPD PROPERTYKEY:
// 	{4D545058-4FCE-4578-95C8-8698A9BC0F49}\D801
//
DEFINE_GUID( WPD_PROPERTIES_MTP_VENDOR_EXTENDED_OBJECT_PROPS , 0x4d545058, 0x4fce, 0x4578, 0x95, 0xc8, 0x86, 0x98, 0xa9, 0xbc, 0xf, 0x49 );


/**************************************************************************** 
* This section defines the GUID for MTP Vendor-extended device properties 
****************************************************************************/
//
// Microsoft MTP driver combines this GUID and any vendor-extended MTP device property code (as pid) 
// to construct a WPD PROPERTYKEY, which is reported to WPD applications as a WPD property.
// For example, vendor extended device prop code, 0xD001, will be reported as WPD PROPERTYKEY:
// 	{4D545058-8900-40b3-8F1D-DC246E1E8370}\D001
//
DEFINE_GUID( WPD_PROPERTIES_MTP_VENDOR_EXTENDED_DEVICE_PROPS , 0x4d545058, 0x8900, 0x40b3, 0x8f, 0x1d, 0xdc, 0x24, 0x6e, 0x1e, 0x83, 0x70 );


/**************************************************************************** 
* This section defines the mapping between WPD formats and MTP Vendor-extended formats
****************************************************************************/
//
// For a MTP vendor-extended format to work with WPD, Microsoft MTP driver creates a new WPD format GUID by combining the vendor 
// format code (UINT16) and WPD_OBJECT_FORMAT_UNSPECIFIED except its highest 16 bits (replaced by the vendor format code).
// For example, vendor-extended format code, 0xB001, will be reported as WPD format GUID:
//	{B0010000-AE6C-4804-98BA-C57B46965FE7}
//


/**************************************************************************** 
* This section defines the mapping between WPD event GUIDs and MTP Vendor-extended event codes
****************************************************************************/
//
// For a MTP vendor-extended event to work with WPD, Microsoft MTP driver creates a new WPD event GUID by 
// replacing the highest 16 bits of WPD_EVENT_MTP_VENDOR_EXTENDED_EVENTS with the vendor event code (UINT16).
// For example, vendor-extended event code, 0xC001, will be reported as WPD event GUID:
//	{C0010000-5738-4ff2-8445-BE3126691059}
//
DEFINE_GUID( WPD_EVENT_MTP_VENDOR_EXTENDED_EVENTS , 0x00000000, 0x5738, 0x4ff2, 0x84, 0x45, 0xbe, 0x31, 0x26, 0x69, 0x10, 0x59);


/**************************************************************************** 
* This section defines the WPD property key for event parameters of a vendor-extended event
****************************************************************************/
//
// Microsoft MTP driver reports a vendor-extended event to WPD with:
//      WPD_EVENT_PARAMETER_EVENT_ID: the WPD event GUID defined above; and 
//      WPD_PROPERTY_MTP_EXT_EVENT_PARAMS: a collection of PROPVARIANTs which map to parameters of the event.
// If there is no parameters for the event, the collection will be empty.
//
//	{4D545058-EF88-4e4d-95C3-4F327F728A96}
DEFINE_PROPERTYKEY( WPD_PROPERTY_MTP_EXT_EVENT_PARAMS , 0x4d545058, 0xef88, 0x4e4d, 0x95, 0xc3, 0x4f, 0x32, 0x7f, 0x72, 0x8a, 0x96 , 1011 );    // [ VT_UNKNOWN ] : Returns an IPortableDevicePropVariantCollection (of VT_UI4) of event params for a vendor-extended event
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WPFtpMsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: FTPWPP_ERROR_FIRST
//
// MessageText:
//
//  CFtpWpp's first error message.
//
#define FTPWPP_ERROR_FIRST               0x40042300L

//
// MessageId: FTPWPP_ERROR_INETOPEN_FAILED
//
// MessageText:
//
//  The FTP provider could not connect to the internet.
//
#define FTPWPP_ERROR_INETOPEN_FAILED     0xC0042301L

//
// MessageId: FTPWPP_ERROR_AUTHENTICATION_FAILED
//
// MessageText:
//
//  The FTP provider could not log in to the FTP server.
//
#define FTPWPP_ERROR_AUTHENTICATION_FAILED 0xC0042302L

//
// MessageId: FTPWPP_ERROR_LAST
//
// MessageText:
//
//  CFtpWpp's last error message.
//
#define FTPWPP_ERROR_LAST                0x400423FFL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wptypes.h ===
/*-------------------------------------------------------*\
 *
 *	Copyright (c) 1999 Microsoft Corporation
 *
 *	Module Name:
 *
 *		wptypes.h
 *
 *	Abstract:
 *
 *		Data types for the Microsoft Web Publishing API.
 *
\*-------------------------------------------------------*/


#ifndef __WPTYPES_H__
#define __WPTYPES_H__


#ifdef __cplusplus
extern "C" {
#endif


//
//	Site info structures
//

typedef struct tagWPSITEINFOA {

	DWORD dwSize;
	DWORD dwFlags;
	LPSTR lpszSiteName;
	LPSTR lpszSiteURL;

} WPSITEINFOA, *LPWPSITEINFOA;

typedef struct tagWPSITEINFOW {

	DWORD dwSize;
	DWORD dwFlags;
	LPWSTR lpszSiteName;
	LPWSTR lpszSiteURL;

} WPSITEINFOW, *LPWPSITEINFOW;


//
//	Provider info structures
//

typedef struct tagWPPROVINFOA {

	DWORD dwSize;
	DWORD dwFlags;
	DWORD dwPriority;
	LPSTR lpszProviderName;
	LPSTR lpszProviderCLSID;
	LPSTR lpszDllPath;

} WPPROVINFOA, *LPWPPROVINFOA;

typedef struct tagWPPROVINFOW {

	DWORD dwSize;
	DWORD dwFlags;
	DWORD dwPriority;
	LPWSTR lpszProviderName;
	LPWSTR lpszProviderCLSID;
	LPWSTR lpszDllPath;

} WPPROVINFOW, *LPWPPROVINFOW;


#ifdef UNICODE

#define WPSITEINFO				WPSITEINFOW
#define LPWPSITEINFO			LPWPSITEINFOW
#define WPPROVINFO				WPPROVINFOW
#define LPWPPROVINFO			LPWPPROVINFOW

#else

#define WPSITEINFO				WPSITEINFOA
#define LPWPSITEINFO			LPWPSITEINFOA
#define WPPROVINFO				WPPROVINFOA
#define LPWPPROVINFO			LPWPPROVINFOA

#endif


#ifdef __cplusplus
}
#endif



#endif  // __WPTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WPPstMsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: WPP_ERROR_FIRST
//
// MessageText:
//
//  WebPost Provider first error message.
//
#define WPP_ERROR_FIRST                  0x40042380L

//
// MessageId: WPP_POST_POSTING_URL_ERROR
//
// MessageText:
//
//  The URL you selected, %1, is invalid.
//
#define WPP_POST_POSTING_URL_ERROR       0xC0042381L

//
// MessageId: WPP_POST_POSTING_SERVER_ERROR
//
// MessageText:
//
//  The Web server returned the following error: %1.
//
#define WPP_POST_POSTING_SERVER_ERROR    0xC0042382L

//
// MessageId: WPP_POST_POSTING_NO_RESPONSE_ERROR
//
// MessageText:
//
//  The Web server either is not responding or returned an unrecognized response.
//
#define WPP_POST_POSTING_NO_RESPONSE_ERROR 0xC0042383L

//
// MessageId: WPP_ERROR_LAST
//
// MessageText:
//
//  WebPost Provider last error message.
//
#define WPP_ERROR_LAST                   0x400423FFL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WS2dnet.h ===
//************************************************************************
//  Winsock V2.0  DECnet definitions		File: WS2DNET.H 
//************************************************************************

#ifndef WS2DNET_H
#define WS2DNET_H

#include <winsock2.h>

#pragma pack(push,ws2dnet,1)
   
//
//  DECnet WinSock Definitions
//
#define DNPROTO_NSP      1  // DECnet NSP transport protocol
#define DNPROTO_RAW    255 

#define DN_MAXADDL      20  // maximum DECnet address length
#define DN_ADDL          2  // DECnet NSP address length
#define DN_MAXOPTL      16  // Maximum DECnet optional data length
#define DN_MAXOBJL      16  // Maximum DECnet object name length
#define DN_MAXACCL      39  // Maximum DECnet access string length
#define DN_MAXALIASL   128  // Maximum DECnet alias string length
#define DN_MAXNODEL      7  // Maximum DECnet Phase IV node string length

// DECnet Extension Function Identifiers
#define WS2API_DECNET_dnet_addr     1
#define WS2API_DECNET_dnet_eof      2
#define WS2API_DECNET_dnet_getacc   3
#define WS2API_DECNET_dnet_getalias 4
#define WS2API_DECNET_dnet_htoa     5
#define WS2API_DECNET_dnet_ntoa     6
#define WS2API_DECNET_getnodeadd    7
#define WS2API_DECNET_getnodebyaddr 8
#define WS2API_DECNET_getnodebyname 9
#define WS2API_DECNET_getnodename   10
#define WS2API_DECNET_MAX           10

//
//  DECnet address structure
//  
typedef struct dn_naddr {
	unsigned short	a_len;		        // length of address  
	unsigned char   a_addr[DN_MAXADDL]; // address as bytes  
} DNNADDR, FAR *LPDNNADDR;

//
//  DECnet socket address structure
//  
typedef struct sockaddr_dn {
	unsigned short	sdn_family;	    // AF_DECnet  
	unsigned char	sdn_flags;	    // flags  
	unsigned char	sdn_objnum;	    // object number  
	unsigned short	sdn_objnamel;	// size of object name  
	char sdn_objname[DN_MAXOBJL];	// object name  
	struct dn_naddr  sdn_add;	    // node address  
} SOCKADDRDN, FAR *LPSOCKADDRDN;

#define sdn_nodeaddrl	sdn_add.a_len	// node address length  
#define sdn_nodeaddr	sdn_add.a_addr 	// node address  

//  Common DECnet object numbers (used in sockaddr_dn)
#define DNOBJECT_FAL	17		// file access listener  
#define DNOBJECT_NICE	19		// network management  
#define DNOBJECT_DTERM	23		// remote terminals  
#define DNOBJECT_MIRROR	25		// loopback mirror  
#define DNOBJECT_EVR	26		// event receiver  
#define DNOBJECT_MAIL11	27		// Mail-11 service  
#define DNOBJECT_PHONE	29		// phone utility  
#define DNOBJECT_CTERM	42		// command terminals  
#define DNOBJECT_DTR	63		// data test receiver  

//
//  DECnet node structure
//
typedef struct	nodeent_f {
	char 		FAR * n_name;   // name of node  
	unsigned short	n_addrtype;	// node address type  
	unsigned short	n_length;	// address length
	unsigned char	FAR * n_addr;	// address  
	unsigned char	FAR * n_params;	// node parameters  
	unsigned char   n_reserved[16];	// Reserved
} NODEENTF, FAR *LPNODEENTF;                                          

//
//  DECnet set/get DSO_CONDATA, DSO_DISDATA (optional data) structure
//  
typedef struct optdata_dn {
	unsigned short	opt_status;	          // extended status return  
	unsigned short	opt_optl;	          // user data length 
	unsigned char   opt_data[DN_MAXOPTL]; // user data  
} OPTDATADN, FAR *LPOPTDATADN;

//
//  DECnet set/get DSO_CONACCESS access (control data) structure
//  
typedef struct accessdata_dn {
	unsigned short	acc_accl;	            // account string length 
	unsigned char	acc_acc[DN_MAXACCL+1];	// account string  
	unsigned short	acc_passl;	            // password string length  
	unsigned char	acc_pass[DN_MAXACCL+1];	// password string  
	unsigned short	acc_userl;	            // user string length 
	unsigned char	acc_user[DN_MAXACCL+1];	// user string  
} ACCESSDATADN, FAR *LPACCESSDATADN;

//
//  DECnet call data structure (concatenated access and optional data)
//
typedef struct calldata_dn { 
    struct optdata_dn       optdata_dn;
    struct accessdata_dn    accessdata_dn;
} CALLDATADN, FAR *LPCALLDATADN;   
    
//
//  DECnet incoming access control structure
//
typedef struct dnet_accent {
    unsigned char dac_status;      // Reserved 
    unsigned char dac_type;        // DN_NONE, etc.      
    char dac_username[DN_MAXACCL+1];  
    char dac_password[DN_MAXACCL+1]; 
} DNETACCENT, FAR *LPDNETACCENT;

#define DN_NONE          0x00   
#define DN_RO            0x01
#define DN_WO            0x02
#define DN_RW            0x03

// DECnet logical link information structure
typedef struct linkinfo_dn {
	unsigned short	idn_segsize;	/* segment size for link */
	unsigned char	idn_linkstate;	/* logical link state */
}LINKINFODN, FAR *LPLINKINFODN;

#define SO_LINKINFO	        7		/* set/get link information */
#define LL_INACTIVE		    0		/* logical link inactive */
#define LL_CONNECTING	    1		/* logical link connecting */
#define LL_RUNNING		    2		/* logical link running */
#define LL_DISCONNECTING	3		/* logical link disconnecting */

#pragma pack(pop,ws2dnet)

//*********************************************************************
//  DECnet WinSock 2 extended function prototypes	
//*********************************************************************  
struct dn_naddr FAR *WSAAPI dnet_addr(const char FAR *);
int WSAAPI dnet_eof(SOCKET);
struct dnet_accent FAR *WSAAPI dnet_getacc(const struct dnet_accent FAR *);
char FAR *WSAAPI dnet_getalias(const char FAR *);
char FAR *WSAAPI dnet_htoa(const struct dn_naddr FAR *);
char FAR *WSAAPI dnet_ntoa(const struct dn_naddr FAR *);
struct dn_naddr FAR *WSAAPI getnodeadd(void);
struct nodeent_f FAR *WSAAPI getnodebyaddr(const unsigned char FAR *addr, int, int);
struct nodeent_f FAR *WSAAPI getnodebyname(const char FAR *);
char FAR *WSAAPI getnodename(void);

// typedefs for C++ compatability
typedef struct dn_naddr FAR * (WSAAPI * LPDNETADDR)(const char FAR *);
typedef int (WSAAPI * LPDNETEOF)(SOCKET);
typedef struct dnet_accent FAR * (WSAAPI * LPDNETGETACC)(const struct 
dnet_accent FAR *);
typedef char FAR * (WSAAPI * LPDNETGETALIAS)(const char FAR *);
typedef char FAR * (WSAAPI * LPDNETHTOA)(const struct dn_naddr FAR *);
typedef char FAR * (WSAAPI * LPDNETNTOA)(const struct dn_naddr FAR *);
typedef struct dn_naddr FAR * (WSAAPI * LPGETNODEADD)(void);
typedef struct nodeent_f FAR * (WSAAPI * LPGETNODEBYADDR)(const unsigned 
char FAR *addr, int, int);
typedef struct nodeent_f FAR * (WSAAPI * LPGETNODEBYNAME)(const char FAR 
*);
typedef char FAR * (WSAAPI * LPGETNODENAME)(void);

#endif	// WS2DNET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wpdshellextension.h ===
//=============================================================================
//
// @module      WpdShellExtension.h
//
// @created     06-01-2005
//
// @abstract    Contains property keys specific to the WPD shell extension
//
// @copyright   (C) COPYRIGHT MICROSOFT CORPORATION, 2005
//
//=============================================================================


/**************************************************************************** 
* This section contains the WPD NSE CLSID to be used in SHParseDisplayName() 
* 
* 
****************************************************************************/ 
DEFINE_GUID( CLSID_WPD_NAMESPACE_EXTENSION , 0x35786d3c, 0xb075, 0x49b9, 0x88, 0xdd, 0x02, 0x98, 0x76, 0xe1, 0x1c, 0x01 ); 



/**************************************************************************** 
* This section defines all property keys associated with: 
* WPDNSE_OBJECT_PROPERTIES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPDNSE_OBJECT_PROPERTIES_V1 , 0x34d71409, 0x4b47, 0x4d80, 0xaa, 0xac, 0x3a, 0x28, 0xa4, 0xa3, 0xb3, 0xe6 ); 

// Properties 
DEFINE_PROPERTYKEY( WPDNSE_OBJECT_HAS_CONTACT_PHOTO , 0x34d71409, 0x4b47, 0x4d80, 0xaa, 0xac, 0x3a, 0x28, 0xa4, 0xa3, 0xb3, 0xe6 , 2 ); // [ VT_BOOL ] Indicates whether the object has a contact photo resource.  
DEFINE_PROPERTYKEY( WPDNSE_OBJECT_HAS_THUMBNAIL , 0x34d71409, 0x4b47, 0x4d80, 0xaa, 0xac, 0x3a, 0x28, 0xa4, 0xa3, 0xb3, 0xe6 , 3 ); // [ VT_BOOL ] Indicates whether the object has a thumbnail resource.  
DEFINE_PROPERTYKEY( WPDNSE_OBJECT_HAS_ICON , 0x34d71409, 0x4b47, 0x4d80, 0xaa, 0xac, 0x3a, 0x28, 0xa4, 0xa3, 0xb3, 0xe6 , 4 ); // [ VT_BOOL ] Indicates whether the object has an icon resource.  
DEFINE_PROPERTYKEY( WPDNSE_OBJECT_HAS_AUDIO_CLIP , 0x34d71409, 0x4b47, 0x4d80, 0xaa, 0xac, 0x3a, 0x28, 0xa4, 0xa3, 0xb3, 0xe6 , 5 ); // [ VT_BOOL ] Indicates whether the object has a voice annotation resource.  
DEFINE_PROPERTYKEY( WPDNSE_OBJECT_HAS_ALBUM_ART , 0x34d71409, 0x4b47, 0x4d80, 0xaa, 0xac, 0x3a, 0x28, 0xa4, 0xa3, 0xb3, 0xe6 , 6 ); // [ VT_BOOL ] Indicates whether the object has an album art resource.  
DEFINE_PROPERTYKEY( WPDNSE_OBJECT_OPTIMAL_READ_BLOCK_SIZE , 0x34d71409, 0x4b47, 0x4d80, 0xaa, 0xac, 0x3a, 0x28, 0xa4, 0xa3, 0xb3, 0xe6 , 7 ); // [ VT_UI4 ] The optimal buffer size clients can use to read data chunks of the default resource.  

/**************************************************************************** 
* This section defines all the property page values used with extensible 
* property pages. Property sheet extensions will receive a uint with one of
* of these values in the LOWORD and possibly an index in the HIWORD when
* their IShellPropSheetExt::ReplacePage method is called. Indexes in the
* HIWORD refer to the index into the PIDL array of the item whose property
* page will be replaced. This allows you to replace the correct storage or
* device property page in a multi-select scenario.
* 
* 
****************************************************************************/ 
#define WPDNSE_PROPSHEET_DEVICE_GENERAL     0x00000001
#define WPDNSE_PROPSHEET_STORAGE_GENERAL    0x00000002
#define WPDNSE_PROPSHEET_CONTENT_GENERAL    0x00000004
#define WPDNSE_PROPSHEET_CONTENT_REFERENCES 0x00000008
#define WPDNSE_PROPSHEET_CONTENT_RESOURCES  0x00000010
#define WPDNSE_PROPSHEET_CONTENT_DETAILS    0x00000020



/**************************************************************************** 
* This section defines the IBindCtx options used by IShellFolder::BindToObject.
* 
* 
****************************************************************************/ 
// BindCtx key which tells an IShellFolder to enumerate as quickly as possible.
// A limited property set will be available for objects when this bind option
// is used.  The limited property set contains name, size, date modified, the
// read-only, hidden and system file attributes, and the supported resources.
#define STR_WPDNSE_FAST_ENUM              L"WPDNSE Fast Enum"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wpframework.h ===
/*++

   Copyright    (c)    2004    Microsoft Corporation

   Module  Name :
     wp_framework.h

   Abstract:

    Definition of 
    - IWorkerProcessFramework and related data and interfaces
    - IProtocolManager and related interfaces


    Protocol manager is a module that gets loaded by worker process in order 
    to handle traffic for a protocol. The actual startup/stopping of protocol 
    activity happens by starting/stopping protocol ListenerChannels.
    
    Protocol manager is expected to handle
    - protocol ListenerChannel commands 
    - health/lifetime monitoring for the internal activity 
    - custom actions (aka RSCA queries/functions)
    - provide custom interfaces what other protocol managers may leverage 
      (it is meant to allow for protocol managers or their internal components
      to share objects with other protocol managers)


   Worker process framework is set of interfaces available in the worker 
   process that are presented to protocol managers.  

   Worker process framework allows protocol managers to
   - retrieve the Config interface to be used within the worker process. 
   - retrieve certain cooked values such as AppPool name that protocol managers
     may need
   - report unhealthy events
   - load another protocol manager to retrieve custom interface
   - some additional utility functions (such as one that returns site ID and 
     virtual path for given AppID)
   
--*/

#ifndef _WP_FRAMEWORK_H_
#define _WP_FRAMEWORK_H_



//
// Forward declarations
//

class  IProtocolManager;

//
// Simple refcounted base class 
//

class IWpfReferencedObject
{
public:
    virtual
    ULONG 
    AddRef(
        VOID
    ) = 0;

    virtual
    ULONG 
    Release
    (
        VOID
    ) = 0;
    
};

//
// IWorkerProcessFramework related interfaces
//

// 
// WorkerProcessFramework implements multiple interfaces
// that are used by IProtocolManager instances to retrieve
// configuration/settings and perform actions related to the worker process
// monitoring
//


enum WPF_INTERFACE_ID_ENUM
{
    // retrieve native config interface
    WPF_CONFIG_API_ID = 1,  
    
    // helps to translate application ID to site and virtual path
    WPF_APPLICATION_INFO_UTIL_ID,     
    
    // exposes some settings that have process wide impact such
    // as recycling counters, CLR version ...
    WPF_SETTINGS_ID,     

    // way to request a recycle, shutdown worker pocess
    WPF_ACTIONS_ID,      
    
    // way to ask worker process framework to
    // load a protocol manager and request custom interface
    // of that. This interface allows multiple protocol managers
    // to share objects between them
    //
    WPF_EXPOSE_PROTOCOL_MANAGER_CUSTOM_INTERFACE_ID,  
};


class IWorkerProcessFramework: public IWpfReferencedObject
{
public:

    virtual
    HRESULT 
    GetWpfInterface(
        IN  WPF_INTERFACE_ID_ENUM  WpfInterfaceId,
        OUT PVOID*                 ppInterface 
    ) = 0;

    virtual
    HRESULT 
    GetCustomInterface(
        IN  DWORD                           InterfaceId,
        OUT PVOID*                          ppInterface 
    ) = 0;

    //
    // return the IWorkerProcessFramework version
    // (it is meant to allow consumer to determine
    // what interfaces are available for retrieval)
    //
    virtual
    HRESULT 
    GetInterfaceVersion(
        OUT PDWORD      pdwMajorVersion,
        OUT PDWORD      pdwMinorVersion
    ) = 0;
};

//
// Interface ID: WPF_APPLICATION_INFO_ID
//
// Exposes helper function to retrieve SiteID and Virtual path for the 
// given AppId
//

class IWpfApplicationInfoUtil: public IWpfReferencedObject
{
public:
    virtual 
    HRESULT 
    GetApplicationPropertiesFromAppId(
        IN                                 PCWSTR      pszAppId, 
        __out_ecount_opt(*pcchVirtualPath) PWSTR       pszVirtualPath,
        OUT                                DWORD *     pcchVirtualPath,
        OUT                                DWORD *     pdwSiteId ) = 0;
};


//
// enums used by IWpfSettings (WFP_SETTINGS_ID) interface
// 
    
enum WPF_SETTINGS_STRING_ENUM
{
    CLR_VERSION,
    APP_POOL_NAME,
    APP_HOST_FILE_NAME,
    ROOT_WEB_CONFIG_FILE_NAME
};

enum WPF_SETTINGS_DWORD_ENUM
{
    PERIODIC_RESTART_REQUESTS = 1,
    PERIODIC_RESTART_TIME,
    IDLE_TIMEOUT,
    MANAGED_PIPELINE_MODE,
};

enum WPF_SETTINGS_ULONGLONG_ENUM
{
    PERIODIC_RESTART_VIRTUAL_MEMORY,
    PERIODIC_RESTART_PRIVATE_MEMORY,
};

enum WPF_SETTINGS_BOOL_ENUM
{
    ENABLED_CENTRAL_BINARY_LOGGING,
    ENABLED_HOSTABLE_WEB_CORE
};

enum WPF_SETTINGS_HANDLE_ENUM
{
    ANONYMOUS_USER_TOKEN
};

//
// Interface ID: WPF_SETTINGS_ID
//
// Exposes Application Pool / worker process related settings
// (based on applicationhost.config settings)
//

class IWpfSettings : public IWpfReferencedObject
{
public:
    virtual
    HRESULT
    GetDwordProperty(
        IN  WPF_SETTINGS_DWORD_ENUM  SettingId,
        OUT DWORD*                   pdwSetting
    ) = 0;

    virtual
    HRESULT
    GetUlonglongProperty(
        IN  WPF_SETTINGS_ULONGLONG_ENUM  SettingId,
        OUT ULONGLONG*                   pSetting
    ) = 0;

    virtual
    HRESULT
    GetStringProperty(
        IN                             WPF_SETTINGS_STRING_ENUM  SettingId,
        __out_ecount_opt(*pcchSetting) PWSTR                     pszSetting,
        OUT                            DWORD*                    pcchSetting
    ) = 0;
    
    virtual
    HRESULT
    GetBoolProperty(
        IN  WPF_SETTINGS_BOOL_ENUM  SettingId,
        OUT BOOL *                  pfSetting
    ) = 0;

    virtual
    HRESULT
    GetHandleProperty(
        IN  WPF_SETTINGS_HANDLE_ENUM  SettingId,
        OUT HANDLE *                  phSetting
    ) = 0;
};


//
// Interface ID: WPF_ACTIONS_ID
//
// Allows protocol manager to request recycling or
// allows to report health issues (FailWorkerProcess)
//


class IWpfActions : public IWpfReferencedObject
{
public:

    virtual
    VOID
    RecycleWorkerProcess(
        IN PCWSTR   pszReason
    ) = 0;
    
    virtual
    VOID
    FailWorkerProcess(
        IN PCWSTR   pszReason,
        IN HRESULT  hrFailureToReport,
        IN BOOL     fFailOnNextPing = FALSE        
    ) = 0;
};

//
// Interface ID: WPF_EXPOSE_PROTOCOL_MANAGER_CUSTOM_INTERFACE_ID
//
// Some protocol managers may have dependencies on other protocol managers
// (for reasons such as controling the lifetime of a shared singleton
// object). Use of this interface is expected to be very limited.
//

class IWpfExposeProtocolManagerCustomInterface: public IWpfReferencedObject
{
public:

    //
    // Load the given protocol manager and retrieve the requested interface
    // The meaning of the call is to enable one protocol manager to leverage 
    // some functionality implemented in other protocol manager.
    // Note that we don't allow full access to ProtocolManager interfaces 
    // because most of them are only meant for the interaction with 
    // the Worker Process Framework.
    //
    // Also note that when done using custom interface it is necessary 
    // to release the reference to custom interface not later then in 
    // Shutdown() call.
    //

    virtual
    HRESULT
    LoadProtocolManagerAndGetCustomInterface(
        IN PCWSTR                   pProtocolManagerDll,
        IN PCWSTR                   pProtocolManagerDllInitFunction,
        IN DWORD                    dwCustomInterfaceId,
        OUT PVOID*                  ppCustomInterface
    ) = 0;

};




//
// IProtocolManager related interfaces
// - exposed on the Protocol Manager for the Worker Process Framework to use    
//

class IWpfListenerChannelCallback;


//
// IProtocolManager interface and related enum
// listing supported interfaces
//

enum PM_INTERFACE_ID_ENUM
{
    // Protocol ListenerChannel management interface
    PM_LISTENER_CHANNEL_MANAGER_ID = 1,  
    
    // Health/ idle monitoring interface
    PM_HEALTH_AND_IDLE_MONITOR_ID,     
    
    // Custom actions interface (for RSCA query)
    PM_CUSTOM_ACTIONS_ID,  
};

//
// Finally the actual declaration of the IProtocolManager
//

class IProtocolManager   : public IWpfReferencedObject
{
public:
    virtual
    HRESULT 
    GetPmInterface(
        IN  PM_INTERFACE_ID_ENUM  PmInterfaceId,
        OUT PVOID*                ppInterface 
    ) = 0;

    
    virtual
    HRESULT 
    GetCustomInterface(
        IN  DWORD                           InterfaceId,
        OUT PVOID*                          ppInterface 
    ) = 0;
    
    virtual 
    HRESULT 
    Shutdown(
        IN BOOL             fImmediate
    ) = 0;

};


//
// Callback class used by IPmMonitor (PM_MONITOR_ID) interface
//

class IHealthStatusCallback: public IWpfReferencedObject
{
public:
   virtual 
    HRESULT 
    ReportHealth( 
        BOOL fHealthy
    ) = 0;   
};

//
// Interface ID: PM_HEALTH_AND_IDLE_MONITOR_ID
// IProtocolManager needs to expose health/ recycling monitoring means
//

class IPmHealthAndIdleMonitor : public IWpfReferencedObject
{
public:

    virtual 
    HRESULT 
    CheckIdle(
        OUT BOOL *pfIdle
    ) = 0;

    virtual 
    HRESULT 
    CheckHealth(   // health ping response
        IHealthStatusCallback * pIHealthStatusCallback
    ) = 0;    
};

//
// Callback class used by IPmCustomActions (PM_CUSTOM_ACTIONS_PM) interface
// 

class ICustomActionResultCallback
        : public IWpfReferencedObject
{
public:
    virtual
    HRESULT
    ReportResult( 
        IN HRESULT              hrStatus,
        IN PBYTE                pbResponse,
        IN DWORD                cbResponse
    ) = 0;
};

//
// Interface ID: PM_CUSTOM_ACTIONS_ID
// IProtocolManager needs to expose a way for Custom actions
// (so that custom queries such as RSCA query can be implemented)
//

class IPmCustomActions : public  IWpfReferencedObject
{
public:

    //
    // RunCustomAction can report results back
    // by using a callback interface
    //

    virtual
    HRESULT
    RunCustomAction(
        IN PCWSTR   pszFunctionName,
        IN PCWSTR   pszFunctionArgs,
        IN ICustomActionResultCallback * pCompletionCallbackClass
    ) = 0 ;

};

//
// Used by IPmListenerChannelManager (PM_LISTENER_CHANNEL_MANAGER_ID) 
// Interface ListenerChannelCallback provides notifications about 
// ListenerChannel status changes from Protocol managers.
// It also allows protocol managers to access extra parameters/blob
// that is communicated to worker process when ListenerChannels
// are asked to be started
//

class IWpfListenerChannelCallback : public IWpfReferencedObject
{
public:
    virtual 
    HRESULT 
    ReportStarted(
        VOID
    ) = 0;

    virtual 
    HRESULT 
    ReportStopped(
        HRESULT hr
    ) = 0;

    
    virtual 
    HRESULT 
    ReportMessageReceived(
        VOID
    ) = 0;

    virtual 
    HRESULT 
    GetId(
        OUT DWORD* pdwListenerChannelId
    ) = 0;

    virtual 
    HRESULT 
    GetBlob(
        IN OUT PBYTE pBlob, 
        IN OUT DWORD* pcbBlob 
    ) = 0;
};

//
// Interface ID: PM_LISTENER_CHANNEL_MANAGER_ID
// IProtocolManager needs to expose interface that allows
// controlling ListenerChannels (starting and stopping them)
//

class IPmListenerChannelManager: public IWpfReferencedObject
{
public:

    // Function will ask that a ListenerChannel be launched for
    // a protocol.
    virtual
    HRESULT
    StartListenerChannel(
        IN PCWSTR                          protocolId,
        IN IWpfListenerChannelCallback *   pListenerChannelCallback 
    ) = 0;

    virtual
    HRESULT 
    StopListenerChannel(
        IN PCWSTR                        protocolId,
        IN IWpfListenerChannelCallback * pListenerChannelCallback,
        IN BOOL                          fImmediate
    ) = 0;

    
};


//
// Default entrypoint of the protocol manager dll that allows worker 
// process to instantiate the ProtocolManager instance
//

#define DEFAULT_PROTOCOL_MANAGER_INIT_FUNCTION      L"GetProtocolManager"

typedef HRESULT (*PFN_GET_PROTOCOL_MANAGER)
                    ( IN  IWorkerProcessFramework * pWpFramework,
                      OUT IProtocolManager **       ppProtocolManager );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ws2bth.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

        ws2bth.h

Abstract:

        Winsock 2 Bluetooth Annex definitions.
        
Notes:

        Change BT_* to BTH_*        

--*/

#ifndef __WS2BTH__H
#define __WS2BTH__H

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)

#include <bthdef.h>

#include <pshpack1.h>

#define BT_PORT_ANY        ((ULONG)-1)
#define BT_PORT_MIN        0x1
#define BT_PORT_MAX        0xffff
#define BT_PORT_DYN_FIRST  0x1001

//
// These three definitions are duplicated in winsock2.h to reserve ordinals
//
#ifndef AF_BTH
#define AF_BTH  32
#endif
#ifndef PF_BTH
#define PF_BTH  AF_BTH
#endif
#ifndef NS_BTH
#define NS_BTH  16
#endif

typedef struct _SOCKADDR_BTH
{
    USHORT      addressFamily;  // Always AF_BTH
    BTH_ADDR    btAddr;         // Bluetooth device address
    GUID        serviceClassId; // [OPTIONAL] system will query SDP for port
    ULONG       port;           // RFCOMM channel or L2CAP PSM
} SOCKADDR_BTH, *PSOCKADDR_BTH;


DEFINE_GUID(SVCID_BTH_PROVIDER, 0x6aa63e0, 0x7d60, 0x41ff, 0xaf, 0xb2, 0x3e, 0xe6, 0xd2, 0xd9, 0x39, 0x2d);
#define BTH_ADDR_STRING_SIZE        12  // max size from WSAAddressToString

//
// Bluetooth protocol #s are assigned according to the Bluetooth
// Assigned Numbers portion of the Bluetooth Specification
//
#define BTHPROTO_RFCOMM  0x0003
#define BTHPROTO_L2CAP   0x0100

#define SOL_RFCOMM  BTHPROTO_RFCOMM
#define SOL_L2CAP   BTHPROTO_L2CAP
#define SOL_SDP     0x0101

//
// SOCKET OPTIONS
//
#define SO_BTH_AUTHENTICATE 0x80000001  // optlen=sizeof(ULONG), optval = &(ULONG)TRUE/FALSE 
#define SO_BTH_ENCRYPT      0x00000002  // optlen=sizeof(ULONG), optval = &(ULONG)TRUE/FALSE
#define SO_BTH_MTU          0x80000007  // optlen=sizeof(ULONG), optval = &mtu
#define SO_BTH_MTU_MAX      0x80000008  // optlen=sizeof(ULONG), optval = &max. mtu
#define SO_BTH_MTU_MIN      0x8000000a  // optlen=sizeof(ULONG), optval = &min. mtu

//
// Socket option parameters
//
// 3-DH5 => payload of 1021 => L2cap payload of 1017 => RFComm payload of 1011
#define RFCOMM_MAX_MTU      0x000003F3  // L2CAP MTU (1017) - RFCOMM header size (6)
#define RFCOMM_MIN_MTU      0x00000017  // RFCOMM spec sec 5.3 table 5.1

//
// NAME SERVICE PROVIDER DEFINITIONS
// For calling WSASetService
// and WSALookupServiceBegin, WSALookupServiceNext, WSALookupServiceEnd
// with Bluetooth-specific extensions
//
#define BTH_SDP_VERSION         1

//
// [OPTIONAL] passed in BLOB member of WSAQUERYSET
// QUERYSET and its lpBlob member are copied & converted
// to unicode in the system for non-unicode applications.  
// However, nothing is copied back upon return.  In 
// order for the system to return data such as pRecordHandle, 
// it much have an extra level of indirection from lpBlob 
//
typedef struct _BTH_SET_SERVICE {

        //
        // This version number will change when/if the binary format of
        // SDP records change, affecting the format of pRecord.
        // Set to BTH_SDP_VERSION by client, and returned by system
        //
        PULONG pSdpVersion;

        //
        // Handle to SDP record.  When BTH_SET_SERVICE structure is later 
        // passed to WSASetService RNRSERVICE_DELETE, this handle identifies the
        // record to delete.
        //
        HANDLE *pRecordHandle;
                        
        // 
        // COD_SERVICE_* bit(s) associated with this SDP record, which will be
        // advertised when the local radio is found during device inquiry.
        // When the last SDP record associated with a bit is deleted, that
        // service bit is no longer reported in repsonse to inquiries 
        //
        ULONG fCodService;    // COD_SERVICE_* bits

        ULONG Reserved[5];    // Reserved by system.  Must be zero.                
        ULONG ulRecordLength; // length of pRecord which follows
        UCHAR pRecord[1];     // SDP record as defined by bluetooth spec
        
} BTH_SET_SERVICE, *PBTH_SET_SERVICE;

//
// Default device inquiry duration in seconds
//
// The application thread will be blocked in WSALookupServiceBegin
// for the duration of the device inquiry, so this value needs to
// be balanced against the chance that a device that is actually
// present might not being found by Bluetooth in this time
//
// Paging improvements post-1.1 will cause devices to be 
// found generally uniformly in the 0-6 sec timeperiod
//
#define SDP_DEFAULT_INQUIRY_SECONDS         6
#define SDP_MAX_INQUIRY_SECONDS             60

//
// Default maximum number of devices to search for
//
#define SDP_DEFAULT_INQUIRY_MAX_RESPONSES   255

#define SDP_SERVICE_SEARCH_REQUEST           1
#define SDP_SERVICE_ATTRIBUTE_REQUEST        2
#define SDP_SERVICE_SEARCH_ATTRIBUTE_REQUEST 3

//
// [OPTIONAL] input restrictions on device inquiry
// Passed in BLOB of LUP_CONTAINERS (device) search
//
typedef struct _BTH_QUERY_DEVICE {
    ULONG   LAP;                    // reserved: must be 0 (GIAC inquiry only)
    UCHAR   length;                 // requested length of inquiry (seconds)       
} BTH_QUERY_DEVICE, *PBTH_QUERY_DEVICE;

//
// [OPTIONAL] Restrictions on searching for a particular service
// Passed in BLOB of !LUP_CONTAINERS (service) search
//
typedef struct _BTH_QUERY_SERVICE {
	ULONG                   type;           // one of SDP_SERVICE_*
	ULONG                   serviceHandle;
	SdpQueryUuid            uuids[MAX_UUIDS_IN_QUERY];
	ULONG                   numRange;
	SdpAttributeRange       pRange[1];
} BTH_QUERY_SERVICE, *PBTH_QUERY_SERVICE;

//
// BTHNS_RESULT_*
//
// Bluetooth specific flags returned from WSALookupServiceNext 
// in WSAQUERYSET.dwOutputFlags in response to device inquiry
//

//
// Local device is paired with remote device
//
#define BTHNS_RESULT_DEVICE_CONNECTED      0x00010000
#define BTHNS_RESULT_DEVICE_REMEMBERED     0x00020000
#define BTHNS_RESULT_DEVICE_AUTHENTICATED  0x00040000

//
// SOCKET IOCTLs
//

#define SIO_RFCOMM_SEND_COMMAND        _WSAIORW (IOC_VENDOR, 101)
#define SIO_RFCOMM_WAIT_COMMAND        _WSAIORW (IOC_VENDOR, 102)

//
// These IOCTLs are for test/validation/conformance and may only be
// present in debug/checked builds of the system
//
#define SIO_BTH_PING                      _WSAIORW (IOC_VENDOR, 8)
#define SIO_BTH_INFO                      _WSAIORW (IOC_VENDOR, 9)
#define SIO_RFCOMM_SESSION_FLOW_OFF       _WSAIORW (IOC_VENDOR, 103)
#define SIO_RFCOMM_TEST                   _WSAIORW (IOC_VENDOR, 104)
#define SIO_RFCOMM_USECFC                 _WSAIORW (IOC_VENDOR, 105)
/*      RESERVED                          _WSAIORW (IOC_VENDOR, 106) */


//
// SOCKET IOCTL DEFINITIONS
//

#ifndef BIT
#define BIT(b)   (1<<(b))
#endif

//
// Structure definition from Bluetooth RFCOMM spec, TS 07.10 5.4.6.3.7
//
typedef struct _RFCOMM_MSC_DATA {
    UCHAR       Signals;

        #define MSC_EA_BIT      EA_BIT
        #define MSC_FC_BIT      BIT(1)      // Flow control, clear if we can receive
        #define MSC_RTC_BIT     BIT(2)      // Ready to communicate, set when ready
        #define MSC_RTR_BIT     BIT(3)      // Ready to receive, set when ready
        #define MSC_RESERVED (BIT(4)|BIT(5))// Reserved by spec, must be 0
        #define MSC_IC_BIT      BIT(6)      // Incoming call
        #define MSC_DV_BIT      BIT(7)      // Data valid

    UCHAR       Break;

        #define MSC_BREAK_BIT   BIT(1)      // Set if sending break
        #define MSC_SET_BREAK_LENGTH(b, l)  ((b) = ((b)&0x3) | (((l)&0xf) << 4))

} RFCOMM_MSC_DATA, *PRFCOMM_MSC_DATA;

//
// Structure definition from Bluetooth RFCOMM spec, TS 07.10 5.4.6.3.10
//
typedef struct _RFCOMM_RLS_DATA {

    UCHAR       LineStatus;

        #define RLS_ERROR           0x01
        #define RLS_OVERRUN         0x02
        #define RLS_PARITY          0x04
        #define RLS_FRAMING         0x08

} RFCOMM_RLS_DATA, *PRFCOMM_RLS_DATA;

//
// Structure definition from Bluetooth RFCOMM spec, TS 07.10 5.4.6.3.9
//
typedef struct _RFCOMM_RPN_DATA {
    UCHAR       Baud;

        #define RPN_BAUD_2400       0
        #define RPN_BAUD_4800       1
        #define RPN_BAUD_7200       2
        #define RPN_BAUD_9600       3
        #define RPN_BAUD_19200      4
        #define RPN_BAUD_38400      5
        #define RPN_BAUD_57600      6
        #define RPN_BAUD_115200     7
        #define RPN_BAUD_230400     8

    UCHAR       Data;

        #define RPN_DATA_5          0x0
        #define RPN_DATA_6          0x1
        #define RPN_DATA_7          0x2
        #define RPN_DATA_8          0x3

        #define RPN_STOP_1          0x0
        #define RPN_STOP_1_5        0x4

        #define RPN_PARITY_NONE     0x00
        #define RPN_PARITY_ODD      0x08
        #define RPN_PARITY_EVEN     0x18
        #define RPN_PARITY_MARK     0x28
        #define RPN_PARITY_SPACE    0x38

    UCHAR       FlowControl;

        #define RPN_FLOW_X_IN       0x01
        #define RPN_FLOW_X_OUT      0x02
        #define RPN_FLOW_RTR_IN     0x04
        #define RPN_FLOW_RTR_OUT    0x08
        #define RPN_FLOW_RTC_IN     0x10
        #define RPN_FLOW_RTC_OUT    0x20

    UCHAR       XonChar;
    UCHAR       XoffChar;
    UCHAR       ParameterMask1;

        #define RPN_PARAM_BAUD      0x01
        #define RPN_PARAM_DATA      0x02
        #define RPN_PARAM_STOP      0x04
        #define RPN_PARAM_PARITY    0x08
        #define RPN_PARAM_P_TYPE    0x10
        #define RPN_PARAM_XON       0x20
        #define RPN_PARAM_XOFF      0x40

    UCHAR       ParameterMask2;

        #define RPN_PARAM_X_IN      0x01
        #define RPN_PARAM_X_OUT     0x02
        #define RPN_PARAM_RTR_IN    0x04
        #define RPN_PARAM_RTR_OUT   0x08
        #define RPN_PARAM_RTC_IN    0x10
        #define RPN_PARAM_RTC_OUT   0x20

} RFCOMM_RPN_DATA, *PRFCOMM_RPN_DATA;

#define RFCOMM_CMD_NONE             0
#define RFCOMM_CMD_MSC              1
#define RFCOMM_CMD_RLS              2
#define RFCOMM_CMD_RPN              3
#define RFCOMM_CMD_RPN_REQUEST      4
#define RFCOMM_CMD_RPN_RESPONSE     5
/*      RESERVED_CMD                6 */

typedef struct _RFCOMM_COMMAND
{
    ULONG       CmdType;          // one of RFCOMM_CMD_*
    union
    {
        RFCOMM_MSC_DATA    MSC;
        RFCOMM_RLS_DATA    RLS;
        RFCOMM_RPN_DATA    RPN;
    } Data;
} RFCOMM_COMMAND, *PRFCOMM_COMMAND;

//
// These structures are for test/validation/conformance and may only be
// present in debug/checked builds of the system
//
typedef struct _BTH_PING_REQ {
    BTH_ADDR  btAddr;
    UCHAR    dataLen;
    UCHAR    data[MAX_L2CAP_PING_DATA_LENGTH];
} BTH_PING_REQ, *PBTH_PING_REQ;

typedef struct _BTH_PING_RSP {
    UCHAR    dataLen;
    UCHAR    data[MAX_L2CAP_PING_DATA_LENGTH];
} BTH_PING_RSP, *PBTH_PING_RSP;

typedef struct _BTH_INFO_REQ {
    BTH_ADDR  btAddr;
    USHORT   infoType;
} BTH_INFO_REQ, *PBTH_INFO_REQ;

typedef struct _BTH_INFO_RSP {
    USHORT  result;
    UCHAR   dataLen;
    union {
        USHORT  connectionlessMTU;
        UCHAR   data[MAX_L2CAP_INFO_DATA_LENGTH];
    };
} BTH_INFO_RSP, *PBTH_INFO_RSP;

//
// WinCE compatible struct names
//
typedef struct _BTH_SET_SERVICE BTHNS_SETBLOB, *PBTHNS_SETBLOB;
typedef struct _BTH_QUERY_DEVICE BTHNS_INQUIRYBLOB, *PBTHNS_INQUIRYBLOB;
typedef struct _BTH_QUERY_SERVICE BTHNS_RESTRICTIONBLOB, *PBTHNS_RESTRICTIONBLOB;

#include <poppack.h>

#endif // (NTDDI_VERSION >= NTDDI_WINXPSP2)

#endif // __WS2BTH__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WS2atm.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

	ws2atm.h

Abstract:

	Winsock 2 ATM Annex definitions.

Revision History:

Notes:

--*/

#ifndef _WS2ATM_H_
#define _WS2ATM_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack4.h>

#define ATMPROTO_AALUSER           0x00   /* User-defined AAL */
#define ATMPROTO_AAL1              0x01   /* AAL 1 */
#define ATMPROTO_AAL2              0x02   /* AAL 2 */
#define ATMPROTO_AAL34             0x03   /* AAL 3/4 */
#define ATMPROTO_AAL5              0x05   /* AAL 5 */

#define SAP_FIELD_ABSENT           0xFFFFFFFE
#define SAP_FIELD_ANY              0xFFFFFFFF
#define SAP_FIELD_ANY_AESA_SEL     0xFFFFFFFA
#define SAP_FIELD_ANY_AESA_REST    0xFFFFFFFB

/*
 *  values used for AddressType in struct ATM_ADDRESS
 */
#define ATM_E164               0x01   /* E.164 addressing scheme */
#define ATM_NSAP               0x02   /* NSAP-style ATM Endsystem Address scheme */
#define ATM_AESA               0x02   /* NSAP-style ATM Endsystem Address scheme */

#define ATM_ADDR_SIZE          20
typedef struct {
    DWORD AddressType;                /* E.164 or NSAP-style ATM Endsystem Address */
    DWORD NumofDigits;                /* number of digits; */
    UCHAR Addr[ATM_ADDR_SIZE];        /* IA5 digits for E164, BCD encoding for NSAP */
                                      /* format as defined in the ATM Forum UNI 3.1 */
} ATM_ADDRESS;

/*
 *  values used for Layer2Protocol in B-LLI
 */
#define BLLI_L2_ISO_1745           0x01   /* Basic mode ISO 1745                      */
#define BLLI_L2_Q921               0x02   /* CCITT Rec. Q.921                         */
#define BLLI_L2_X25L               0x06   /* CCITT Rec. X.25, link layer              */
#define BLLI_L2_X25M               0x07   /* CCITT Rec. X.25, multilink               */
#define BLLI_L2_ELAPB              0x08   /* Extended LAPB; for half duplex operation */
#define BLLI_L2_HDLC_ARM           0x09   /* HDLC ARM (ISO 4335)                      */
#define BLLI_L2_HDLC_NRM           0x0A   /* HDLC NRM (ISO 4335)                      */
#define BLLI_L2_HDLC_ABM           0x0B   /* HDLC ABM (ISO 4335)                      */
#define BLLI_L2_LLC                0x0C   /* LAN logical link control (ISO 8802/2)    */
#define BLLI_L2_X75                0x0D   /* CCITT Rec. X.75, single link procedure   */
#define BLLI_L2_Q922               0x0E   /* CCITT Rec. Q.922                         */
#define BLLI_L2_USER_SPECIFIED     0x10   /* User Specified                           */
#define BLLI_L2_ISO_7776           0x11   /* ISO 7776 DTE-DTE operation               */

/*
 *  values used for Layer3Protocol in B-LLI
 */
#define BLLI_L3_X25                0x06   /* CCITT Rec. X.25, packet layer            */
#define BLLI_L3_ISO_8208           0x07   /* ISO/IEC 8208 (X.25 packet layer for DTE  */
#define BLLI_L3_X223               0x08   /* X.223/ISO 8878                           */
#define BLLI_L3_SIO_8473           0x09   /* ISO/IEC 8473 (OSI connectionless)        */
#define BLLI_L3_T70                0x0A   /* CCITT Rec. T.70 min. network layer       */
#define BLLI_L3_ISO_TR9577         0x0B   /* ISO/IEC TR 9577 Network Layer Protocol ID*/
#define BLLI_L3_USER_SPECIFIED     0x10   /* User Specified                           */

/*
 *  values used for Layer3IPI in B-LLI
 */
#define BLLI_L3_IPI_SNAP           0x80   /* IEEE 802.1 SNAP identifier               */
#define BLLI_L3_IPI_IP             0xCC   /* Internet Protocol (IP) identifier        */

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI;

/*
 *  values used for the HighLayerInfoType field in ATM_BHLI
 */
#define BHLI_ISO                   0x00   /* ISO                                 */
#define BHLI_UserSpecific          0x01   /* User Specific                       */
#define BHLI_HighLayerProfile      0x02   /* High layer profile (only in UNI3.0) */
#define BHLI_VendorSpecificAppId   0x03   /* Vendor-Specific Application ID      */

typedef struct {
    DWORD HighLayerInfoType;          /* High Layer Information Type      */
    DWORD HighLayerInfoLength;        /* number of bytes in HighLayerInfo */
    UCHAR HighLayerInfo[8];           /* the value dependent on the       */
                                      /*   HighLayerInfoType field        */
} ATM_BHLI;

typedef struct sockaddr_atm {
    u_short satm_family;              /* address family should be AF_ATM  */
    ATM_ADDRESS satm_number;          /* ATM address                      */
    ATM_BLLI satm_blli;               /* B-LLI                            */
    ATM_BHLI satm_bhli;               /* B-HLI                            */
} sockaddr_atm, SOCKADDR_ATM, *PSOCKADDR_ATM, *LPSOCKADDR_ATM;

typedef enum {
    IE_AALParameters,
    IE_TrafficDescriptor,
    IE_BroadbandBearerCapability,
    IE_BHLI,
    IE_BLLI,
    IE_CalledPartyNumber,
    IE_CalledPartySubaddress,
    IE_CallingPartyNumber,
    IE_CallingPartySubaddress,
    IE_Cause,
    IE_QOSClass,
    IE_TransitNetworkSelection,
} Q2931_IE_TYPE;

typedef struct {
    Q2931_IE_TYPE IEType;
    ULONG         IELength;
    UCHAR         IE[1];
} Q2931_IE;

/*
 *  manifest constants for the AALType field in struct AAL_PARAMETERS_IE
 */
typedef enum {
    AALTYPE_5     = 5,   /* AAL 5 */
    AALTYPE_USER  = 16,  /* user-defined AAL */
} AAL_TYPE;

/*
 *  values used for the Mode field in struct AAL5_PARAMETERS
 */
#define AAL5_MODE_MESSAGE           0x01
#define AAL5_MODE_STREAMING         0x02

/*
 *  values used for the SSCSType field in struct AAL5_PARAMETERS
 */
#define AAL5_SSCS_NULL              0x00
#define AAL5_SSCS_SSCOP_ASSURED     0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED 0x02
#define AAL5_SSCS_FRAME_RELAY       0x04

typedef struct {
    ULONG ForwardMaxCPCSSDUSize;
    ULONG BackwardMaxCPCSSDUSize;
    UCHAR Mode;                        /* only available in UNI 3.0 */
    UCHAR SSCSType;
} AAL5_PARAMETERS;

typedef struct {
    ULONG UserDefined;
} AALUSER_PARAMETERS;

typedef struct {
    AAL_TYPE AALType;
    union {
        AAL5_PARAMETERS     AAL5Parameters;
        AALUSER_PARAMETERS  AALUserParameters;
    } AALSpecificParameters;
} AAL_PARAMETERS_IE;

typedef struct {
    ULONG PeakCellRate_CLP0;
    ULONG PeakCellRate_CLP01;
    ULONG SustainableCellRate_CLP0;
    ULONG SustainableCellRate_CLP01;
    ULONG MaxBurstSize_CLP0;
    ULONG MaxBurstSize_CLP01;
    BOOL  Tagging;
} ATM_TD;

typedef struct {
    ATM_TD Forward;
    ATM_TD Backward;
    BOOL   BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE;

/*
 *  values used for the BearerClass field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define BCOB_A                   0x01   /* Bearer class A                      */
#define BCOB_C                   0x03   /* Bearer class C                      */
#define BCOB_X                   0x10   /* Bearer class X                      */

/*
 *  values used for the TrafficType field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TT_NOIND                 0x00   /* No indication of traffic type       */
#define TT_CBR                   0x04   /* Constant bit rate                   */
#define TT_VBR                   0x08   /* Variable bit rate                   */

/*
 *  values used for the TimingRequirements field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TR_NOIND                 0x00   /* No timing requirement indication    */
#define TR_END_TO_END            0x01   /* End-to-end timing required          */
#define TR_NO_END_TO_END         0x02   /* End-to-end timing not required      */

/*
 *  values used for the ClippingSusceptability field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define CLIP_NOT                 0x00   /* Not susceptible to clipping         */
#define CLIP_SUS                 0x20   /* Susceptible to clipping             */

/*
 *  values used for the UserPlaneConnectionConfig field in
 *  struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define UP_P2P                   0x00   /* Point-to-point connection           */
#define UP_P2MP                  0x01   /* Point-to-multipoint connection      */

typedef struct {
    UCHAR BearerClass;
    UCHAR TrafficType;
    UCHAR TimingRequirements;
    UCHAR ClippingSusceptability;
    UCHAR UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE;

typedef ATM_BHLI ATM_BHLI_IE;

/*
 *  values used for the Layer2Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L2_MODE_NORMAL         0x40
#define BLLI_L2_MODE_EXT            0x80

/*
 *  values used for the Layer3Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L3_MODE_NORMAL         0x40
#define BLLI_L3_MODE_EXT            0x80

/*
 *  values used for the Layer3DefaultPacketSize field in struct ATM_BLLI_IE
 */
#define BLLI_L3_PACKET_16           0x04
#define BLLI_L3_PACKET_32           0x05
#define BLLI_L3_PACKET_64           0x06
#define BLLI_L3_PACKET_128          0x07
#define BLLI_L3_PACKET_256          0x08
#define BLLI_L3_PACKET_512          0x09
#define BLLI_L3_PACKET_1024         0x0A
#define BLLI_L3_PACKET_2048         0x0B
#define BLLI_L3_PACKET_4096         0x0C

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    UCHAR Layer2Mode;
    UCHAR Layer2WindowSize;
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    UCHAR Layer3Mode;
    UCHAR Layer3DefaultPacketSize;
    UCHAR Layer3PacketWindowSize;
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Presentation_Indication field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define PI_ALLOWED                  0x00
#define PI_RESTRICTED               0x40
#define PI_NUMBER_NOT_AVAILABLE     0x80

/*
 *  values used for the Screening_Indicator field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define SI_USER_NOT_SCREENED        0x00
#define SI_USER_PASSED              0x01
#define SI_USER_FAILED              0x02
#define SI_NETWORK                  0x03

typedef struct {
    ATM_ADDRESS ATM_Number;
    UCHAR       Presentation_Indication;
    UCHAR       Screening_Indicator;
} ATM_CALLING_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLING_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Location field in struct ATM_CAUSE_IE
 */
#define CAUSE_LOC_USER                      0x00
#define CAUSE_LOC_PRIVATE_LOCAL             0x01
#define CAUSE_LOC_PUBLIC_LOCAL              0x02
#define CAUSE_LOC_TRANSIT_NETWORK           0x03
#define CAUSE_LOC_PUBLIC_REMOTE             0x04
#define CAUSE_LOC_PRIVATE_REMOTE            0x05
#define CAUSE_LOC_INTERNATIONAL_NETWORK     0x07
#define CAUSE_LOC_BEYOND_INTERWORKING       0x0A

/*
 *  values used for the Cause field in struct ATM_CAUSE_IE
 */
#define CAUSE_UNALLOCATED_NUMBER                0x01
#define CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK       0x02
#define CAUSE_NO_ROUTE_TO_DESTINATION           0x03
#define CAUSE_VPI_VCI_UNACCEPTABLE              0x0A
#define CAUSE_NORMAL_CALL_CLEARING              0x10
#define CAUSE_USER_BUSY                         0x11
#define CAUSE_NO_USER_RESPONDING                0x12
#define CAUSE_CALL_REJECTED                     0x15
#define CAUSE_NUMBER_CHANGED                    0x16
#define CAUSE_USER_REJECTS_CLIR                 0x17
#define CAUSE_DESTINATION_OUT_OF_ORDER          0x1B
#define CAUSE_INVALID_NUMBER_FORMAT             0x1C
#define CAUSE_STATUS_ENQUIRY_RESPONSE           0x1E
#define CAUSE_NORMAL_UNSPECIFIED                0x1F
#define CAUSE_VPI_VCI_UNAVAILABLE               0x23
#define CAUSE_NETWORK_OUT_OF_ORDER              0x26
#define CAUSE_TEMPORARY_FAILURE                 0x29
#define CAUSE_ACCESS_INFORMAION_DISCARDED       0x2B
#define CAUSE_NO_VPI_VCI_AVAILABLE              0x2D
#define CAUSE_RESOURCE_UNAVAILABLE              0x2F
#define CAUSE_QOS_UNAVAILABLE                   0x31
#define CAUSE_USER_CELL_RATE_UNAVAILABLE        0x33
#define CAUSE_BEARER_CAPABILITY_UNAUTHORIZED    0x39
#define CAUSE_BEARER_CAPABILITY_UNAVAILABLE     0x3A
#define CAUSE_OPTION_UNAVAILABLE                0x3F
#define CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED   0x41
#define CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS    0x49
#define CAUSE_INVALID_CALL_REFERENCE            0x51
#define CAUSE_CHANNEL_NONEXISTENT               0x52
#define CAUSE_INCOMPATIBLE_DESTINATION          0x58
#define CAUSE_INVALID_ENDPOINT_REFERENCE        0x59
#define CAUSE_INVALID_TRANSIT_NETWORK_SELECTION 0x5B
#define CAUSE_TOO_MANY_PENDING_ADD_PARTY        0x5C
#define CAUSE_AAL_PARAMETERS_UNSUPPORTED        0x5D
#define CAUSE_MANDATORY_IE_MISSING              0x60
#define CAUSE_UNIMPLEMENTED_MESSAGE_TYPE        0x61
#define CAUSE_UNIMPLEMENTED_IE                  0x63
#define CAUSE_INVALID_IE_CONTENTS               0x64
#define CAUSE_INVALID_STATE_FOR_MESSAGE         0x65
#define CAUSE_RECOVERY_ON_TIMEOUT               0x66
#define CAUSE_INCORRECT_MESSAGE_LENGTH          0x68
#define CAUSE_PROTOCOL_ERROR                    0x6F

/*
 *  values used for the Condition portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_COND_UNKNOWN                  0x00
#define CAUSE_COND_PERMANENT                0x01
#define CAUSE_COND_TRANSIENT                0x02

/*
 *  values used for the Rejection Reason portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_REASON_USER                   0x00
#define CAUSE_REASON_IE_MISSING             0x04
#define CAUSE_REASON_IE_INSUFFICIENT        0x08

/*
 *  values used for the P-U flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_PU_PROVIDER                   0x00
#define CAUSE_PU_USER                       0x08

/*
 *  values used for the N-A flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_NA_NORMAL                     0x00
#define CAUSE_NA_ABNORMAL                   0x04

typedef struct {
    UCHAR Location;
    UCHAR Cause;
    UCHAR DiagnosticsLength;
    UCHAR Diagnostics[4];
} ATM_CAUSE_IE;

/*
 *  values used for the QOSClassForward and QOSClassBackward
 *  field in struct ATM_QOS_CLASS_IE
 */
#define QOS_CLASS0                  0x00
#define QOS_CLASS1                  0x01
#define QOS_CLASS2                  0x02
#define QOS_CLASS3                  0x03
#define QOS_CLASS4                  0x04

typedef struct {
    UCHAR QOSClassForward;
    UCHAR QOSClassBackward;
} ATM_QOS_CLASS_IE;

/*
 *  values used for the TypeOfNetworkId field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_TYPE_NATIONAL           0x40

/*
 *  values used for the NetworkIdPlan field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_PLAN_CARRIER_ID_CODE    0x01

typedef struct {
    UCHAR TypeOfNetworkId;
    UCHAR NetworkIdPlan;
    UCHAR NetworkIdLength;
    UCHAR NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE;

/*
 *  ATM specific Ioctl codes
 */
#define SIO_GET_NUMBER_OF_ATM_DEVICES   0x50160001
#define SIO_GET_ATM_ADDRESS             0xd0160002
#define SIO_ASSOCIATE_PVC               0x90160003
#define SIO_GET_ATM_CONNECTION_ID       0x50160004

/* ATM Connection Identifier */

typedef struct {
    DWORD  DeviceNumber;
    DWORD  VPI;
    DWORD  VCI;
} ATM_CONNECTION_ID;

/*
 * Input buffer format for SIO_ASSOCIATE_PVC
 */

typedef struct {
   ATM_CONNECTION_ID   PvcConnectionId;
   QOS                 PvcQos;
} ATM_PVC_PARAMS;

#include <poppack.h>

#endif   /* _WS2ATM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WPSpiHlp.h ===
/*------------------------------------------------*\
 *
 *	Copyright 1997 - 1999 Microsoft Corporation
 *
 *	Module Name:
 *
 *		wpspihlp.h
 *
 *	Abstract:
 *
 *		Declaration of Microsoft Web Publishing
 *		Service Provider helper functions.
 *
 *	Note:
 *
 *		If you are #including this file in
 *		a Web Publishing Service Provider
 *		implementation, you should first
 *		#define IN_WPPDLL.
 *
\*------------------------------------------------*/


#ifndef __WPSPIHLP_H__
#define __WPSPIHLP_H__


#include <windows.h>
#include "wptypes.h"


#if defined(IN_WPPDLL)
#define WPPFUNC	__declspec( dllexport )
#else
#define WPPFUNC	__declspec( dllimport )
#endif	//	IN_WPPDLL


//
//	Flags
//

#define WPF_FORCE_BIND					0x00000100		//	WppBindToSite


//
//	Helper function declarations and typedefs
//

HRESULT WPPFUNC WINAPI WppBindToSiteA(
	HWND	hwnd,
	LPCSTR	sSiteName,
	LPCSTR	sURL,
    REFIID	riid,
	DWORD	dwFlag,
	DWORD	dwReserved,
    PVOID 	*ppvUnk);

typedef HRESULT (WINAPI *PFN_WPPBINDTOSITEA)(
						HWND	hwnd,
						LPCSTR	sSiteName,
						LPCSTR	sURL,
						REFIID 	riid,
						DWORD	dwFlag,
						DWORD	dwReserved,
						PVOID 	*ppvUnk);


HRESULT WPPFUNC WINAPI WppListSitesA(
	LPDWORD			pdwSitesBufLen,
	LPWPSITEINFOA	pSitesBuffer,
	LPDWORD			pdwNumSites);

typedef HRESULT (WINAPI *PFN_WPPLISTSITESA)(
						LPDWORD			pdwSitesBufLen,
						LPWPSITEINFOA	pSitesBuffer,
						LPDWORD			pdwNumSites);

										
HRESULT WPPFUNC WINAPI WppDeleteSiteA(LPCSTR sSiteName);

typedef HRESULT (WINAPI *PFN_WPPDELETESITEA)(LPCSTR sSiteName);


HRESULT WPPFUNC WINAPI WppBindToSiteW(
	HWND	hwnd,
	LPCWSTR	sSiteName,
	LPCWSTR	sURL,
    REFIID	riid,
	DWORD	dwFlag,
	DWORD	dwReserved,
    PVOID 	*ppvUnk);

typedef HRESULT (WINAPI *PFN_WPPBINDTOSITEW)(
						HWND	hwnd,
						LPCWSTR sSiteName,
						LPCWSTR	sURL,
						REFIID 	riid,
						DWORD	dwFlag,
						DWORD	dwReserved,
						PVOID 	*ppvUnk);

HRESULT WPPFUNC WINAPI WppListSitesW(
	LPDWORD			pdwSitesBufLen,
	LPWPSITEINFOW	pSitesBuffer,
	LPDWORD			pdwNumSites);

typedef HRESULT (WINAPI *PFN_WPPLISTSITESW)(
						LPDWORD			pdwSitesBufLen,
						LPWPSITEINFOW	pSitesBuffer,
						LPDWORD			pdwNumSites);
										
HRESULT WPPFUNC WINAPI WppDeleteSiteW(LPCWSTR sSiteName);

typedef HRESULT (WINAPI *PFN_WPPDELETESITEW)(LPCWSTR sSiteName);


//
//	Entry Points
//

#define	EP_WPPBINDTOSITEW	"WppBindToSiteW"
#define EP_WPPLISTSITESW	"WppListSitesW"
#define EP_WPPDELETESITEW	"WppDeleteSiteW"

#define EP_WPPBINDTOSITEA	"WppBindToSiteA"
#define EP_WPPLISTSITESA	"WppListSitesA"
#define EP_WPPDELETESITEA	"WppDeleteSiteA"



#endif	// __WPSPIHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WPWizMsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: WPWIZ_ERROR_FIRST
//
// MessageText:
//
//  Web Publishing Wizard first error message.
//
#define WPWIZ_ERROR_FIRST                0x40042000L

//
// MessageId: WPWIZ_ERROR_UNKNOWN
//
// MessageText:
//
//  An unknown error occurred in the Web Publishing Wizard.
//
#define WPWIZ_ERROR_UNKNOWN              0xC0042001L

//
// MessageId: WPWIZ_ERROR_PROV_QI
//
// MessageText:
//
//  The Web Publishing Wizard was unable to determine the version number of your service provider.
//
#define WPWIZ_ERROR_PROV_QI              0xC0042002L

//
// MessageId: WPWIZ_ERROR_INIT_FAILED
//
// MessageText:
//
//  An error occurred while attempting to start the Web Publishing Wizard.
//
#define WPWIZ_ERROR_INIT_FAILED          0xC0042003L

//
// MessageId: WPWIZ_ERROR_COCREATE_WEBPOST
//
// MessageText:
//
//  The Web Publishing Wizard is not installed correctly. Please uninstall and then reinstall the wizard.
//
#define WPWIZ_ERROR_COCREATE_WEBPOST     0xC0042004L

//
// MessageId: WPWIZ_ERROR_NO_PROVIDERS
//
// MessageText:
//
//  The Web Publishing Wizard could not run because there are no service providers installed.
//
#define WPWIZ_ERROR_NO_PROVIDERS         0xC0042005L

//
// MessageId: WPWIZ_ERROR_STATE_PTR
//
// MessageText:
//
//  An internal error (0x2006) occurred in the Web Publishing Wizard.
//
#define WPWIZ_ERROR_STATE_PTR            0xC0042006L

//
// MessageId: WPWIZ_ERROR_WEBPOST_PTR
//
// MessageText:
//
//  An internal error (0x2007) occurred in the Web Publishing Wizard.
//
#define WPWIZ_ERROR_WEBPOST_PTR          0xC0042007L

//
// MessageId: WPWIZ_ERROR_FILE_NOT_FOUND
//
// MessageText:
//
//  The file(s) you selected to publish could not be found.
//
#define WPWIZ_ERROR_FILE_NOT_FOUND       0xC0042008L

//
// MessageId: WPWIZ_ERROR_PROPSHEET_ERROR
//
// MessageText:
//
//  An error occurred in the user interface of the Web Publishing Wizard.
//
#define WPWIZ_ERROR_PROPSHEET_ERROR      0xC0042009L

//
// MessageId: WPWIZ_ERROR_OUTOFMEMORY
//
// MessageText:
//
//  The Web Publishing Wizard has run out of memory. Please close other running applications before continuing.
//
#define WPWIZ_ERROR_OUTOFMEMORY          0xC004200AL

//
// MessageId: WPWIZ_ERROR_LAST
//
// MessageText:
//
//  Web Publishing Wizard last error message.
//
#define WPWIZ_ERROR_LAST                 0x400420FFL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ws2def.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ws2def.h

Abstract:
 
    This file contains the core definitions for the Winsock2
    specification that can be used by both user-mode and 
    kernel mode modules.

    This file is included in WINSOCK2.H. User mode applications
    should include WINSOCK2.H rather than including this file
    directly. This file can not be included by a module that also
    includes WINSOCK.H.
 
Environment:

    user mode or kernel mode

--*/

#ifndef _WS2DEF_
#define _WS2DEF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_WINSOCK2API_) && defined(_WINSOCKAPI_)    
#error Do not include winsock.h and ws2def.h in the same module. Instead include only winsock2.h.
#endif

#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214) // bit field types other than int

//
// Allow Winsock components to disable PREfast errors.
//

#if defined(_PREFAST_) && defined(IPV6_PREFAST_SAFE)
#include <ipv6prefast.h>
#endif // _PREFAST_

#if(_WIN32_WINNT >= 0x0600)

#ifdef _MSC_VER
#define WS2DEF_INLINE __inline
#else
#define WS2DEF_INLINE extern inline /* GNU style */
#endif

#endif//(_WIN32_WINNT >= 0x0600)

#include <inaddr.h>

//#if(_WIN32_WINNT >= 0x0600)

//
// Address families.
//

typedef USHORT ADDRESS_FAMILY;

//#endif//(_WIN32_WINNT >= 0x0600)

//
// Although AF_UNSPEC is defined for backwards compatibility, using
// AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
// DISCOURAGED.  The interpretation of the "protocol" parameter
// depends on the actual address family chosen.  As environments grow
// to include more and more address families that use overlapping
// protocol values there is more and more chance of choosing an
// undesired address family when AF_UNSPEC is used.
//
#define AF_UNSPEC       0               // unspecified
#define AF_UNIX         1               // local to host (pipes, portals)
#define AF_INET         2               // internetwork: UDP, TCP, etc.
#define AF_IMPLINK      3               // arpanet imp addresses
#define AF_PUP          4               // pup protocols: e.g. BSP
#define AF_CHAOS        5               // mit CHAOS protocols
#define AF_NS           6               // XEROX NS protocols
#define AF_IPX          AF_NS           // IPX protocols: IPX, SPX, etc.
#define AF_ISO          7               // ISO protocols
#define AF_OSI          AF_ISO          // OSI is ISO
#define AF_ECMA         8               // european computer manufacturers
#define AF_DATAKIT      9               // datakit protocols
#define AF_CCITT        10              // CCITT protocols, X.25 etc
#define AF_SNA          11              // IBM SNA
#define AF_DECnet       12              // DECnet
#define AF_DLI          13              // Direct data link interface
#define AF_LAT          14              // LAT
#define AF_HYLINK       15              // NSC Hyperchannel
#define AF_APPLETALK    16              // AppleTalk
#define AF_NETBIOS      17              // NetBios-style addresses
#define AF_VOICEVIEW    18              // VoiceView
#define AF_FIREFOX      19              // Protocols from Firefox
#define AF_UNKNOWN1     20              // Somebody is using this!
#define AF_BAN          21              // Banyan
#define AF_ATM          22              // Native ATM Services
#define AF_INET6        23              // Internetwork Version 6
#define AF_CLUSTER      24              // Microsoft Wolfpack
#define AF_12844        25              // IEEE 1284.4 WG AF
#define AF_IRDA         26              // IrDA
#define AF_NETDES       28              // Network Designers OSI & gateway

#if(_WIN32_WINNT < 0x0501)
#define AF_MAX          29
#else //(_WIN32_WINNT < 0x0501)

#define AF_TCNPROCESS   29
#define AF_TCNMESSAGE   30
#define AF_ICLFXBM      31

#if(_WIN32_WINNT < 0x0600)
#define AF_MAX          32
#else //(_WIN32_WINNT < 0x0600)
#define AF_BTH          32              // Bluetooth RFCOMM/L2CAP protocols
#define AF_MAX          33
#endif //(_WIN32_WINNT < 0x0600)

#endif //(_WIN32_WINNT < 0x0501)

//
// Socket types.
//

#define SOCK_STREAM     1
#define SOCK_DGRAM      2
#define SOCK_RAW        3
#define SOCK_RDM        4
#define SOCK_SEQPACKET  5

//
// Define a level for socket I/O controls in the same numbering space as
// IPPROTO_TCP, IPPROTO_IP, etc.
//

#define SOL_SOCKET 0xffff

//
// Define socket-level options.
//

#define SO_DEBUG        0x0001      // turn on debugging info recording 
#define SO_ACCEPTCONN   0x0002      // socket has had listen()
#define SO_REUSEADDR    0x0004      // allow local address reuse
#define SO_KEEPALIVE    0x0008      // keep connections alive
#define SO_DONTROUTE    0x0010      // just use interface addresses
#define SO_BROADCAST    0x0020      // permit sending of broadcast msgs
#define SO_USELOOPBACK  0x0040      // bypass hardware when possible
#define SO_LINGER       0x0080      // linger on close if data present
#define SO_OOBINLINE    0x0100      // leave received OOB data in line

#define SO_DONTLINGER   (int)(~SO_LINGER)
#define SO_EXCLUSIVEADDRUSE \
    ((int)(~SO_REUSEADDR))          // disallow local address reuse

#define SO_SNDBUF       0x1001      // send buffer size
#define SO_RCVBUF       0x1002      // receive buffer size
#define SO_SNDLOWAT     0x1003      // send low-water mark
#define SO_RCVLOWAT     0x1004      // receive low-water mark
#define SO_SNDTIMEO     0x1005      // send timeout
#define SO_RCVTIMEO     0x1006      // receive timeout
#define SO_ERROR        0x1007      // get error status and clear
#define SO_TYPE         0x1008      // get socket type
#define SO_BSP_STATE    0x1009      // get socket 5-tuple state

#define SO_GROUP_ID     0x2001      // ID of a socket group
#define SO_GROUP_PRIORITY 0x2002    // the relative priority within a group
#define SO_MAX_MSG_SIZE 0x2003      // maximum message size

#define SO_CONDITIONAL_ACCEPT 0x3002 // enable true conditional accept:
                                    // connection is not ack-ed to the
                                    // other side until conditional
                                    // function returns CF_ACCEPT
#define SO_PAUSE_ACCEPT 0x3003      // pause accepting new connections
#define SO_COMPARTMENT_ID 0x3004    // get/set the compartment for a socket
#if (_WIN32_WINNT >= 0x0600)
#define SO_RANDOMIZE_PORT 0x3005    // randomize assignment of wildcard ports
#define SO_PORT_SCALABILITY 0x3006  // enable port scalability
#endif //(_WIN32_WINNT >= 0x0600)

//
// Base constant used for defining WSK-specific options.
//

#define WSK_SO_BASE  0x4000

//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
//

#define TCP_NODELAY         0x0001

//
// Structure used to store most addresses.
//
typedef struct sockaddr {

#if (_WIN32_WINNT < 0x0600)
    u_short sa_family;
#else 
    ADDRESS_FAMILY sa_family;           // Address family.
#endif //(_WIN32_WINNT < 0x0600)

    CHAR sa_data[14];                   // Up to 14 bytes of direct address.
} SOCKADDR, *PSOCKADDR, FAR *LPSOCKADDR;

#ifndef __CSADDR_DEFINED__
#define __CSADDR_DEFINED__


/*
 * SockAddr Information
 */
typedef struct _SOCKET_ADDRESS {
    __field_bcount(iSockaddrLength) LPSOCKADDR lpSockaddr;
    INT iSockaddrLength;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, *LPSOCKET_ADDRESS;

/*
 * Address list returned via SIO_ADDRESS_LIST_QUERY
 */
typedef struct _SOCKET_ADDRESS_LIST {
    INT             iAddressCount;
    SOCKET_ADDRESS  Address[1];
} SOCKET_ADDRESS_LIST, *PSOCKET_ADDRESS_LIST, FAR *LPSOCKET_ADDRESS_LIST;

#if (_WIN32_WINNT >= 0x0600)

#define SIZEOF_SOCKET_ADDRESS_LIST(AddressCount) \
    (FIELD_OFFSET(SOCKET_ADDRESS_LIST, Address) + \
     AddressCount * sizeof(SOCKET_ADDRESS))

#endif //(_WIN32_WINNT >= 0x0600)

/*
 * CSAddr Information
 */
typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO, FAR * LPCSADDR_INFO ;
#endif /* __CSADDR_DEFINED__ */

//
// Portable socket structure (RFC 2553).
//

//
// Desired design of maximum size and alignment.
// These are implementation specific.
//
#define _SS_MAXSIZE 128                 // Maximum size
#define _SS_ALIGNSIZE (sizeof(__int64)) // Desired alignment

//
// Definitions used for sockaddr_storage structure paddings design.
//

#if(_WIN32_WINNT >= 0x0600)
#define _SS_PAD1SIZE (_SS_ALIGNSIZE - sizeof(USHORT))
#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof(USHORT) + _SS_PAD1SIZE + _SS_ALIGNSIZE))
#else 
#define _SS_PAD1SIZE (_SS_ALIGNSIZE - sizeof (short))
#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof (short) + _SS_PAD1SIZE \
                                                    + _SS_ALIGNSIZE))
#endif //(_WIN32_WINNT >= 0x0600)

typedef struct sockaddr_storage {
    ADDRESS_FAMILY ss_family;      // address family

    CHAR __ss_pad1[_SS_PAD1SIZE];  // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align;            // Field to force desired structure
    CHAR __ss_pad2[_SS_PAD2SIZE];  // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_LH, *PSOCKADDR_STORAGE_LH, FAR *LPSOCKADDR_STORAGE_LH;

typedef struct sockaddr_storage_xp {
    short ss_family;               // Address family.

    CHAR __ss_pad1[_SS_PAD1SIZE];  // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align;            // Field to force desired structure
    CHAR __ss_pad2[_SS_PAD2SIZE];  // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_XP, *PSOCKADDR_STORAGE_XP, FAR *LPSOCKADDR_STORAGE_XP;


#if(_WIN32_WINNT >= 0x0600)
typedef SOCKADDR_STORAGE_LH SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, FAR *LPSOCKADDR_STORAGE;
#elif (_WIN32_WINNT >= 0x0501)
typedef SOCKADDR_STORAGE_XP SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, FAR *LPSOCKADDR_STORAGE;
#endif


/*
 * WinSock 2 extension -- manifest constants for WSAIoctl()
 */
#define IOC_UNIX                      0x00000000
#define IOC_WS2                       0x08000000
#define IOC_PROTOCOL                  0x10000000
#define IOC_VENDOR                    0x18000000

#if (_WIN32_WINNT >= 0x0600)
/*
 * WSK-specific IO control codes are Winsock2 codes with the highest-order
 * 3 bits of the Vendor/AddressFamily-specific field set to 1.
 */
#define IOC_WSK                       (IOC_WS2|0x07000000)
#endif //(_WIN32_WINNT >= 0x0600)

#define _WSAIO(x,y)                   (IOC_VOID|(x)|(y))
#define _WSAIOR(x,y)                  (IOC_OUT|(x)|(y))
#define _WSAIOW(x,y)                  (IOC_IN|(x)|(y))
#define _WSAIORW(x,y)                 (IOC_INOUT|(x)|(y))

#define SIO_ASSOCIATE_HANDLE          _WSAIOW(IOC_WS2,1)
#define SIO_ENABLE_CIRCULAR_QUEUEING  _WSAIO(IOC_WS2,2)
#define SIO_FIND_ROUTE                _WSAIOR(IOC_WS2,3)
#define SIO_FLUSH                     _WSAIO(IOC_WS2,4)
#define SIO_GET_BROADCAST_ADDRESS     _WSAIOR(IOC_WS2,5)
#define SIO_GET_EXTENSION_FUNCTION_POINTER  _WSAIORW(IOC_WS2,6)
#define SIO_GET_QOS                   _WSAIORW(IOC_WS2,7)
#define SIO_GET_GROUP_QOS             _WSAIORW(IOC_WS2,8)
#define SIO_MULTIPOINT_LOOPBACK       _WSAIOW(IOC_WS2,9)
#define SIO_MULTICAST_SCOPE           _WSAIOW(IOC_WS2,10)
#define SIO_SET_QOS                   _WSAIOW(IOC_WS2,11)
#define SIO_SET_GROUP_QOS             _WSAIOW(IOC_WS2,12)
#define SIO_TRANSLATE_HANDLE          _WSAIORW(IOC_WS2,13)
#define SIO_ROUTING_INTERFACE_QUERY   _WSAIORW(IOC_WS2,20)
#define SIO_ROUTING_INTERFACE_CHANGE  _WSAIOW(IOC_WS2,21)
#define SIO_ADDRESS_LIST_QUERY        _WSAIOR(IOC_WS2,22)
#define SIO_ADDRESS_LIST_CHANGE       _WSAIO(IOC_WS2,23)
#define SIO_QUERY_TARGET_PNP_HANDLE   _WSAIOR(IOC_WS2,24)

#if(_WIN32_WINNT >= 0x0501)
#define SIO_ADDRESS_LIST_SORT         _WSAIORW(IOC_WS2,25)
#endif //(_WIN32_WINNT >= 0x0501)

#if (_WIN32_WINNT >= 0x0600)
#define SIO_RESERVED_1                _WSAIOW(IOC_WS2,26)
#define SIO_RESERVED_2                _WSAIOW(IOC_WS2,33)
#endif //(_WIN32_WINNT >= 0x0600)

//
// Constants and structures defined by the internet system (RFC 790)
//

//
// N.B. required for backwards compatability to support 0 = IP for the
// level argument to get/setsockopt.
//
#define IPPROTO_IP              0

//
// Protocols.  The IPv6 defines are specified in RFC 2292.
//
typedef enum {
#if(_WIN32_WINNT >= 0x0501)
    IPPROTO_HOPOPTS       = 0,  // IPv6 Hop-by-Hop options
#endif//(_WIN32_WINNT >= 0x0501)
    IPPROTO_ICMP          = 1,
    IPPROTO_IGMP          = 2,
    IPPROTO_GGP           = 3,
#if(_WIN32_WINNT >= 0x0501)
    IPPROTO_IPV4          = 4,
#endif//(_WIN32_WINNT >= 0x0501)
#if(_WIN32_WINNT >= 0x0600)
    IPPROTO_ST            = 5,
#endif//(_WIN32_WINNT >= 0x0600)
    IPPROTO_TCP           = 6,
#if(_WIN32_WINNT >= 0x0600)
    IPPROTO_CBT           = 7,
    IPPROTO_EGP           = 8,
    IPPROTO_IGP           = 9,
#endif//(_WIN32_WINNT >= 0x0600)    
    IPPROTO_PUP           = 12,
    IPPROTO_UDP           = 17,
    IPPROTO_IDP           = 22,
#if(_WIN32_WINNT >= 0x0600)    
    IPPROTO_RDP           = 27,
#endif//(_WIN32_WINNT >= 0x0600)    

#if(_WIN32_WINNT >= 0x0501)
    IPPROTO_IPV6          = 41, // IPv6 header
    IPPROTO_ROUTING       = 43, // IPv6 Routing header
    IPPROTO_FRAGMENT      = 44, // IPv6 fragmentation header
    IPPROTO_ESP           = 50, // encapsulating security payload
    IPPROTO_AH            = 51, // authentication header
    IPPROTO_ICMPV6        = 58, // ICMPv6
    IPPROTO_NONE          = 59, // IPv6 no next header
    IPPROTO_DSTOPTS       = 60, // IPv6 Destination options
#endif//(_WIN32_WINNT >= 0x0501)

    IPPROTO_ND            = 77,
#if(_WIN32_WINNT >= 0x0501)
    IPPROTO_ICLFXBM       = 78,
#endif//(_WIN32_WINNT >= 0x0501)
#if(_WIN32_WINNT >= 0x0600)    
    IPPROTO_PIM           = 103,
    IPPROTO_PGM           = 113,
    IPPROTO_L2TP          = 115,
    IPPROTO_SCTP          = 132,
#endif//(_WIN32_WINNT >= 0x0600)    
    IPPROTO_RAW           = 255,

    IPPROTO_MAX           = 256,
//
//  These are reserved for internal use by Windows.
//
    IPPROTO_RESERVED_RAW  = 257,
    IPPROTO_RESERVED_IPSEC  = 258,
    IPPROTO_RESERVED_IPSECOFFLOAD  = 259,
    IPPROTO_RESERVED_MAX  = 260
} IPPROTO, *PIPROTO;

//
// Port/socket numbers: network standard functions
//
#define IPPORT_TCPMUX           1
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_QOTD             17
#define IPPORT_MSP              18
#define IPPORT_CHARGEN          19
#define IPPORT_FTP_DATA         20
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_POP3             110
#define IPPORT_NTP              123
#define IPPORT_EPMAP            135
#define IPPORT_NETBIOS_NS       137
#define IPPORT_NETBIOS_DGM      138
#define IPPORT_NETBIOS_SSN      139
#define IPPORT_IMAP             143
#define IPPORT_SNMP             161
#define IPPORT_SNMP_TRAP        162
#define IPPORT_IMAP3            220
#define IPPORT_LDAP             389
#define IPPORT_HTTPS            443
#define IPPORT_MICROSOFT_DS     445
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024
#if (_WIN32_WINNT >= 0x0600)
#define IPPORT_REGISTERED_MIN   IPPORT_RESERVED
#define IPPORT_REGISTERED_MAX   0xbfff
#define IPPORT_DYNAMIC_MIN      0xc000
#define IPPORT_DYNAMIC_MAX      0xffff
#endif //(_WIN32_WINNT >= 0x0600)

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *
 * N.B. RFC-compliant definitions for host-order elements are named IN_xxx,
 * while network-order elements are named IN4_xxx.
 */
#define IN_CLASSA(i)            (((LONG)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((LONG)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((LONG)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define IN_CLASSD(i)            (((long)(i) & 0xf0000000) == 0xe0000000)
#define IN_CLASSD_NET           0xf0000000       /* These ones aren't really */
#define IN_CLASSD_NSHIFT        28               /* net and host fields, but */
#define IN_CLASSD_HOST          0x0fffffff       /* routing needn't know.    */
#define IN_MULTICAST(i)         IN_CLASSD(i)

#define INADDR_ANY              (ULONG)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (ULONG)0xffffffff
#define INADDR_NONE             0xffffffff


//
// Scope ID definition
//
typedef enum {
    ScopeLevelInterface    = 1,
    ScopeLevelLink         = 2,
    ScopeLevelSubnet       = 3,
    ScopeLevelAdmin        = 4,
    ScopeLevelSite         = 5,
    ScopeLevelOrganization = 8,
    ScopeLevelGlobal       = 14,
    ScopeLevelCount        = 16
} SCOPE_LEVEL;

typedef struct {
    union {
        struct {
            ULONG Zone : 28;
            ULONG Level : 4;
        };
        ULONG Value;
    };
} SCOPE_ID, *PSCOPE_ID;

#define SCOPEID_UNSPECIFIED_INIT    { 0 }

//
// IPv4 Socket address, Internet style
//

typedef struct sockaddr_in {

#if(_WIN32_WINNT < 0x0600)
    short   sin_family;    
#else //(_WIN32_WINNT < 0x0600)
    ADDRESS_FAMILY sin_family;
#endif //(_WIN32_WINNT < 0x0600)

    USHORT sin_port;
    IN_ADDR sin_addr;
    CHAR sin_zero[8];
} SOCKADDR_IN, *PSOCKADDR_IN;

#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

/*
 * WinSock 2 extension -- WSABUF and QOS struct, include qos.h
 * to pull in FLOWSPEC and related definitions
 */

typedef struct _WSABUF {
    ULONG len;     /* the length of the buffer */
    __field_bcount(len) CHAR FAR *buf; /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

/*
 * WSAMSG -- for WSASendMsg 
 */

typedef struct _WSAMSG {
    __field_bcount(namelen) LPSOCKADDR       name;              /* Remote address */
    INT              namelen;           /* Remote address length */
    LPWSABUF         lpBuffers;         /* Data buffer array */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwBufferCount;     /* Number of elements in the array */
#else
    DWORD            dwBufferCount;     /* Number of elements in the array */
#endif //(_WIN32_WINNT>=0x0600)

    WSABUF           Control;           /* Control buffer */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwFlags;           /* Flags */
#else
    DWORD            dwFlags;           /* Flags */
#endif //(_WIN32_WINNT>=0x0600)

} WSAMSG, *PWSAMSG, * FAR LPWSAMSG;

/*
 * Layout of ancillary data objects in the control buffer (RFC 2292).
 */
#if(_WIN32_WINNT >= 0x0600) 
#define _WSACMSGHDR cmsghdr
#endif //(_WIN32_WINNT>=0x0600)

typedef struct _WSACMSGHDR {
    SIZE_T      cmsg_len;
    INT         cmsg_level;
    INT         cmsg_type;
    /* followed by UCHAR cmsg_data[] */
} WSACMSGHDR, *PWSACMSGHDR, FAR *LPWSACMSGHDR;

#if(_WIN32_WINNT >= 0x0600)
typedef WSACMSGHDR CMSGHDR, *PCMSGHDR;
#endif //(_WIN32_WINNT>=0x0600)

/*
 * Alignment macros for header and data members of
 * the control buffer.
 */
#define WSA_CMSGHDR_ALIGN(length)                           \
            ( ((length) + TYPE_ALIGNMENT(WSACMSGHDR)-1) &   \
                (~(TYPE_ALIGNMENT(WSACMSGHDR)-1)) )         \

#define WSA_CMSGDATA_ALIGN(length)                          \
            ( ((length) + MAX_NATURAL_ALIGNMENT-1) &        \
                (~(MAX_NATURAL_ALIGNMENT-1)) )

#if(_WIN32_WINNT >= 0x0600)
#define CMSGHDR_ALIGN WSA_CMSGHDR_ALIGN
#define CMSGDATA_ALIGN WSA_CMSGDATA_ALIGN
#endif //(_WIN32_WINNT>=0x0600)

/*
 *  WSA_CMSG_FIRSTHDR
 *
 *  Returns a pointer to the first ancillary data object, 
 *  or a null pointer if there is no ancillary data in the 
 *  control buffer of the WSAMSG structure.
 *
 *  LPCMSGHDR 
 *  WSA_CMSG_FIRSTHDR (
 *      LPWSAMSG    msg
 *      );
 */
#define WSA_CMSG_FIRSTHDR(msg) \
    ( ((msg)->Control.len >= sizeof(WSACMSGHDR))            \
        ? (LPWSACMSGHDR)(msg)->Control.buf                  \
        : (LPWSACMSGHDR)NULL )

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_FIRSTHDR WSA_CMSG_FIRSTHDR
#endif //(_WIN32_WINNT>=0x0600)

/* 
 *  WSA_CMSG_NXTHDR
 *
 *  Returns a pointer to the next ancillary data object,
 *  or a null if there are no more data objects.
 *
 *  LPCMSGHDR 
 *  WSA_CMSG_NEXTHDR (
 *      LPWSAMSG        msg,
 *      LPWSACMSGHDR    cmsg
 *      );
 */
#define WSA_CMSG_NXTHDR(msg, cmsg)                          \
    ( ((cmsg) == NULL)                                      \
        ? WSA_CMSG_FIRSTHDR(msg)                            \
        : ( ( ((PUCHAR)(cmsg) +                             \
                    WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len) +   \
                    sizeof(WSACMSGHDR) ) >                  \
                (PUCHAR)((msg)->Control.buf) +              \
                    (msg)->Control.len )                    \
            ? (LPWSACMSGHDR)NULL                            \
            : (LPWSACMSGHDR)((PUCHAR)(cmsg) +               \
                WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len)) ) )

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_NXTHDR WSA_CMSG_NXTHDR
#endif //(_WIN32_WINNT>=0x0600)

/* 
 *  WSA_CMSG_DATA
 *
 *  Returns a pointer to the first byte of data (what is referred 
 *  to as the cmsg_data member though it is not defined in 
 *  the structure).
 *
 *  Note that RFC 2292 defines this as CMSG_DATA, but that name
 *  is already used by wincrypt.h, and so Windows has used WSA_CMSG_DATA.
 *
 *  PUCHAR
 *  WSA_CMSG_DATA (
 *      LPWSACMSGHDR   pcmsg
 *      );
 */
#define WSA_CMSG_DATA(cmsg)             \
            ( (PUCHAR)(cmsg) + WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) )

/*
 *  WSA_CMSG_SPACE
 *
 *  Returns total size of an ancillary data object given 
 *  the amount of data. Used to allocate the correct amount 
 *  of space.
 *
 *  SIZE_T
 *  WSA_CMSG_SPACE (
 *      SIZE_T length
 *      );
 */
#define WSA_CMSG_SPACE(length)  \
        (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR) + WSA_CMSGHDR_ALIGN(length)))

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_SPACE WSA_CMSG_SPACE
#endif //(_WIN32_WINNT>=0x0600)

/*
 *  WSA_CMSG_LEN
 *
 *  Returns the value to store in cmsg_len given the amount of data.
 *
 *  SIZE_T
 *  WSA_CMSG_LEN (
 *      SIZE_T length
 *  );
 */
#define WSA_CMSG_LEN(length)    \
         (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) + length)

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_LEN WSA_CMSG_LEN
#endif //(_WIN32_WINNT>=0x0600)

/*
 * Definition for flags member of the WSAMSG structure
 * This is in addition to other MSG_xxx flags defined
 * for recv/recvfrom/send/sendto.
 */
#define MSG_TRUNC       0x0100
#define MSG_CTRUNC      0x0200
#define MSG_BCAST       0x0400
#define MSG_MCAST       0x0800

#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Wscapi.h ===
#pragma once

typedef enum _WSC_SECURITY_PROVIDER
{
    // Represents the aggregation of all firewalls for this computer.
    WSC_SECURITY_PROVIDER_FIREWALL =                   0x1,
    // Represents the Automatic updating settings for this computer.
    WSC_SECURITY_PROVIDER_AUTOUPDATE_SETTINGS  =       0x2,
    // Represents the aggregation of all antivirus products for this comptuer.
    WSC_SECURITY_PROVIDER_ANTIVIRUS =                  0x4,
    // Represents the aggregation of all antispyware products for this comptuer.
    WSC_SECURITY_PROVIDER_ANTISPYWARE =                0x8,
    // Represents the settings that restrict the access of web sites in each of the internet zones.
    WSC_SECURITY_PROVIDER_INTERNET_SETTINGS =          0x10,
    // Represents the User Account Control settings on this machine.
    WSC_SECURITY_PROVIDER_USER_ACCOUNT_CONTROL =       0x20,
    // Represents the running state of the Security Center service on this machine.
    WSC_SECURITY_PROVIDER_SERVICE =                    0x40,

    WSC_SECURITY_PROVIDER_NONE =                       0,

    // Aggregates all of the items that Security Center monitors.
    WSC_SECURITY_PROVIDER_ALL =                             WSC_SECURITY_PROVIDER_FIREWALL | 
                                                            WSC_SECURITY_PROVIDER_AUTOUPDATE_SETTINGS | 
                                                            WSC_SECURITY_PROVIDER_ANTIVIRUS | 
                                                            WSC_SECURITY_PROVIDER_ANTISPYWARE | 
                                                            WSC_SECURITY_PROVIDER_INTERNET_SETTINGS | 
                                                            WSC_SECURITY_PROVIDER_USER_ACCOUNT_CONTROL | 
                                                            WSC_SECURITY_PROVIDER_SERVICE
} WSC_SECURITY_PROVIDER, *PWSC_SECURITY_PROVIDER;

typedef enum _WSC_SECURITY_PROVIDER_HEALTH
{
    WSC_SECURITY_PROVIDER_HEALTH_GOOD, // Green pillar in English locales
    WSC_SECURITY_PROVIDER_HEALTH_NOTMONITORED, // Yellow pillar in English locales
    WSC_SECURITY_PROVIDER_HEALTH_POOR,  // Red pillar in English locales
    WSC_SECURITY_PROVIDER_HEALTH_SNOOZE, // Yellow pillar in English locales
} WSC_SECURITY_PROVIDER_HEALTH, *PWSC_SECURITY_PROVIDER_HEALTH;


// The WscRegisterForChanges function registers a callback function to be run when Windows Security Center (WSC) detects 
// a change that could affect the health of one of the security providers.
// 
// Parameters:
// Reserved [in]: Reserved. Must be NULL.
// phCallbackRegistration [out]: A pointer to a handle to the callback registration. When you are finished using 
//                               the callback function, unregister it by calling the WscUnRegisterChanges function.
// lpCallbackAddress [in]: A pointer to the application-defined function to be called when a change to the WSC 
//                         service occurs. This function is also called when the WSC service is started or stopped.
// pContext [in]: A pointer to a variable to be passed as the lpParameter parameter to the function pointed to by the 
//                lpCallbackAddress parameter.
//
// Return Values:
// Returns S_OK if the function succeeds, otherwise returns an error code.
//
// Remarks:
// When you want to cease receiving notification to your callback method, you can unregister it by calling the 
// WscUnRegisterChanges function.




STDAPI WscRegisterForChanges(LPVOID Reserved, 
                             PHANDLE phCallbackRegistration,
                             LPTHREAD_START_ROUTINE lpCallbackAddress, 
                             PVOID pContext);

// The WscUnRegisterChanges function cancels a callback registration that was made by a call to the WscRegisterForChanges 
// function.
// 
// Parameters:
// hRegistrationHandle [in]: The handle to the registration context returned as the phCallbackRegistration of the 
//                           WscRegisterForChanges function. 
//
// Return Values:
// Returns S_OK if the function succeeds, otherwise returns an error code.

STDAPI WscUnRegisterChanges(HANDLE hRegistrationHandle);

// The WscGetSecurityProviderHealth function gets the aggregate health state of the security provider categories represented 
// by the specified WSC_SECURITY_PROVIDER enumeration values.
// 
// Parameters:
// Providers [in]: One or more of the values in the WSC_SECURITY_PROVIDER enumeration. To specify more than one value, 
//                 combine the individual values by performing a bitwise OR operation.
// pHealth [out]: A pointer to a variable that takes the value of one of the members of the WSC_SECURITY_PROVIDER_HEALTH 
//                enumeration. If more than one provider is specified in the Providers parameter, the value of this parameter 
//                is the health of the least healthy of the specified provider categories. 
//
// Return values:  
// Returns S_OK if the function succeeds, otherwise returns an error code. If the WSC service is not running, the return value 
// is always S_FALSE and the pHealth out parameter is always set to WSC_SECURITY_PROVIDER_HEALTH_POOR.
// 

STDAPI WscGetSecurityProviderHealth(DWORD Providers,
                                    PWSC_SECURITY_PROVIDER_HEALTH pHealth);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ws2ipdef.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ws2ipdef.h

Abstract:

    This file contains TCP/IP specific information for use
    by WinSock2 compatible applications.
  
   Copyright (c) Microsoft Corporation. All rights reserved.
  
    To provide the backward compatibility, all the TCP/IP
    specific definitions that were included in the WINSOCK.H
    file are now included in WINSOCK2.H file. WS2TCPIP.H
    file includes only the definitions  introduced in the
    "WinSock 2 Protocol-Specific Annex" document.
  
    Rev 0.3 Nov 13, 1995
        Rev 0.4 Dec 15, 1996

Environment:

    user mode or kernel mode

--*/

#ifndef _WS2IPDEF_
#define _WS2IPDEF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4127) // conditional expression is constant

#ifdef _PREFAST_    
#pragma prefast(push)
#pragma prefast(disable: 24002, "This code requires explicit usage of IPv4 address types.")
#endif    
    
#ifndef WS2IPDEF_ASSERT
#define WS2IPDEF_ASSERT(exp) ((VOID) 0)
#endif

#ifdef _MSC_VER
#define WS2TCPIP_INLINE __inline
#else
#define WS2TCPIP_INLINE extern inline /* GNU style */
#endif
    
#include <in6addr.h>

//
// Old IPv6 socket address structure (retained for sockaddr_gen definition).
//

struct sockaddr_in6_old {
    SHORT sin6_family;          // AF_INET6.
    USHORT sin6_port;           // Transport level port number.
    ULONG sin6_flowinfo;        // IPv6 flow information.
    IN6_ADDR sin6_addr;         // IPv6 address.
};

typedef union sockaddr_gen {
    struct sockaddr Address;
    struct sockaddr_in AddressIn;
    struct sockaddr_in6_old AddressIn6;
} sockaddr_gen;

//
// Structure to keep interface specific information
//
    
typedef struct _INTERFACE_INFO {
    ULONG iiFlags;              // Interface flags.
    sockaddr_gen iiAddress;     // Interface address.
    sockaddr_gen iiBroadcastAddress; // Broadcast address.
    sockaddr_gen iiNetmask;     // Network mask.
} INTERFACE_INFO, FAR *LPINTERFACE_INFO;

//
// New structure that does not have dependency on the address size.
//

typedef struct _INTERFACE_INFO_EX {
    ULONG iiFlags;              // Interface flags.
    SOCKET_ADDRESS iiAddress;   // Interface address.
    SOCKET_ADDRESS iiBroadcastAddress; // Broadcast address.
    SOCKET_ADDRESS iiNetmask;   // Network mask.
} INTERFACE_INFO_EX, FAR *LPINTERFACE_INFO_EX;

//
// Possible flags for the  iiFlags - bitmask.
//
    
#define IFF_UP              0x00000001 // Interface is up.
#define IFF_BROADCAST       0x00000002 // Broadcast is  supported.
#define IFF_LOOPBACK        0x00000004 // This is loopback interface.
#define IFF_POINTTOPOINT    0x00000008 // This is point-to-point interface.
#define IFF_MULTICAST       0x00000010 // Multicast is supported.

    
//
// Options to use with [gs]etsockopt at the IPPROTO_IP level.
// The values should be consistent with the IPv6 equivalents.
//
#define IP_OPTIONS                 1 // Set/get IP options.
#define IP_HDRINCL                 2 // Header is included with data.
#define IP_TOS                     3 // IP type of service.
#define IP_TTL                     4 // IP TTL (hop limit).
#define IP_MULTICAST_IF            9 // IP multicast interface.
#define IP_MULTICAST_TTL          10 // IP multicast TTL (hop limit).
#define IP_MULTICAST_LOOP         11 // IP multicast loopback.
#define IP_ADD_MEMBERSHIP         12 // Add an IP group membership.
#define IP_DROP_MEMBERSHIP        13 // Drop an IP group membership.
#define IP_DONTFRAGMENT           14 // Don't fragment IP datagrams.
#define IP_ADD_SOURCE_MEMBERSHIP  15 // Join IP group/source.
#define IP_DROP_SOURCE_MEMBERSHIP 16 // Leave IP group/source.
#define IP_BLOCK_SOURCE           17 // Block IP group/source.
#define IP_UNBLOCK_SOURCE         18 // Unblock IP group/source.
#define IP_PKTINFO                19 // Receive packet information.
#define IP_HOPLIMIT               21 // Receive packet hop limit.
#define IP_RECEIVE_BROADCAST      22 // Allow/block broadcast reception.
#define IP_RECVIF                 24 // Receive arrival interface.
#define IP_RECVDSTADDR            25 // Receive destination address.
#define IP_IFLIST                 28 // Enable/Disable an interface list.
#define IP_ADD_IFLIST             29 // Add an interface list entry.
#define IP_DEL_IFLIST             30 // Delete an interface list entry.
#define IP_UNICAST_IF             31 // IP unicast interface.
#define IP_RTHDR                  32 // Set/get IPv6 routing header.
#define IP_RECVRTHDR              38 // Receive the routing header.

#define IP_UNSPECIFIED_TYPE_OF_SERVICE -1

#define IPV6_ADDRESS_BITS RTL_BITS_OF(IN6_ADDR)

//
// IPv6 socket address structure, RFC 3493.
//

//
// NB: The LH version of sockaddr_in6 has the struct tag sockaddr_in6 rather
// than sockaddr_in6_lh.  This is to make sure that standard sockets apps
// that conform to RFC 2553 (Basic Socket Interface Extensions for IPv6).
//
typedef struct sockaddr_in6 {
    ADDRESS_FAMILY sin6_family; // AF_INET6.
    USHORT sin6_port;           // Transport level port number.
    ULONG  sin6_flowinfo;       // IPv6 flow information.
    IN6_ADDR sin6_addr;         // IPv6 address.
    union {
        ULONG sin6_scope_id;     // Set of interfaces for a scope.
        SCOPE_ID sin6_scope_struct; 
    };
} SOCKADDR_IN6_LH, *PSOCKADDR_IN6_LH, FAR *LPSOCKADDR_IN6_LH;

typedef struct sockaddr_in6_w2ksp1 {
    short   sin6_family;        /* AF_INET6 */
    USHORT sin6_port;          /* Transport level port number */
    ULONG  sin6_flowinfo;      /* IPv6 flow information */
    struct in6_addr sin6_addr;  /* IPv6 address */
    ULONG sin6_scope_id;       /* set of interfaces for a scope */
} SOCKADDR_IN6_W2KSP1, *PSOCKADDR_IN6_W2KSP1, FAR *LPSOCKADDR_IN6_W2KSP1;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef SOCKADDR_IN6_LH SOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_LH FAR *LPSOCKADDR_IN6;
#elif(NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef SOCKADDR_IN6_W2KSP1 SOCKADDR_IN6;
typedef SOCKADDR_IN6_W2KSP1 *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_W2KSP1 FAR *LPSOCKADDR_IN6;
#else
typedef SOCKADDR_IN6_LH SOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_LH FAR *LPSOCKADDR_IN6;
#endif

typedef union _SOCKADDR_INET {
    SOCKADDR_IN Ipv4;
    SOCKADDR_IN6 Ipv6;
    ADDRESS_FAMILY si_family;    
} SOCKADDR_INET, *PSOCKADDR_INET;

//
// Structure to hold a pair of source, destination addresses.
//
typedef struct _sockaddr_in6_pair
{
    PSOCKADDR_IN6 SourceAddress;
    PSOCKADDR_IN6 DestinationAddress;
} SOCKADDR_IN6_PAIR, *PSOCKADDR_IN6_PAIR;

//
// Macro that works for both IPv4 and IPv6
//
#define SS_PORT(ssp) (((PSOCKADDR_IN)(ssp))->sin_port)

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
//
// N.B. These addresses are in network byte order.
//

#define IN6ADDR_ANY_INIT { 0 }

#define IN6ADDR_LOOPBACK_INIT { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }

#define IN6ADDR_ALLNODESONNODE_INIT { \
    0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 \
}

#define IN6ADDR_ALLNODESONLINK_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 \
}

#define IN6ADDR_ALLROUTERSONLINK_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 \
}

#define IN6ADDR_ALLMLDV2ROUTERSONLINK_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16 \
}

#define IN6ADDR_TEREDOINITIALLINKLOCALADDRESS_INIT { \
    0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe \
}

#define IN6ADDR_LINKLOCALPREFIX_INIT { 0xfe, 0x80, }

#define IN6ADDR_MULTICASTPREFIX_INIT { 0xff, 0x00, }

#define IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x01, 0xff, \
}

#define IN6ADDR_V4MAPPEDPREFIX_INIT { \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0xff, 0xff, \
}

#define IN6ADDR_6TO4PREFIX_INIT { 0x20, 0x02, }

#define IN6ADDR_TEREDOPREFIX_INIT { 0x20, 0x01, 0x00, 0x00, }

#define IN6ADDR_LINKLOCALPREFIX_LENGTH 64

#define IN6ADDR_MULTICASTPREFIX_LENGTH 8

#define IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH 104

#define IN6ADDR_V4MAPPEDPREFIX_LENGTH 96

#define IN6ADDR_6TO4PREFIX_LENGTH 16

#define IN6ADDR_TEREDOPREFIX_LENGTH 32

#ifdef __cplusplus
extern "C" {
#endif

//
// N.B. These addresses are in network byte order.
//
extern CONST SCOPE_ID scopeid_unspecified;

extern CONST IN_ADDR in4addr_any;
extern CONST IN_ADDR in4addr_loopback;
extern CONST IN_ADDR in4addr_broadcast;
extern CONST IN_ADDR in4addr_allnodesonlink;
extern CONST IN_ADDR in4addr_allroutersonlink;
extern CONST IN_ADDR in4addr_alligmpv3routersonlink;
extern CONST IN_ADDR in4addr_allteredohostsonlink;
extern CONST IN_ADDR in4addr_linklocalprefix;
extern CONST IN_ADDR in4addr_multicastprefix;

extern CONST IN6_ADDR in6addr_any;
extern CONST IN6_ADDR in6addr_loopback;
extern CONST IN6_ADDR in6addr_allnodesonnode;
extern CONST IN6_ADDR in6addr_allnodesonlink;
extern CONST IN6_ADDR in6addr_allroutersonlink;
extern CONST IN6_ADDR in6addr_allmldv2routersonlink;
extern CONST IN6_ADDR in6addr_teredoinitiallinklocaladdress;
extern CONST IN6_ADDR in6addr_linklocalprefix;
extern CONST IN6_ADDR in6addr_multicastprefix;
extern CONST IN6_ADDR in6addr_solicitednodemulticastprefix;
extern CONST IN6_ADDR in6addr_v4mappedprefix;
extern CONST IN6_ADDR in6addr_6to4prefix;
extern CONST IN6_ADDR in6addr_teredoprefix;

    

#ifdef __cplusplus
}
#endif

#ifndef __midl

WS2TCPIP_INLINE
BOOLEAN
IN6_ADDR_EQUAL(CONST IN6_ADDR *x, CONST IN6_ADDR *y)
{
    __int64 UNALIGNED *a;
    __int64 UNALIGNED *b;

    a = (__int64 UNALIGNED *)x;
    b = (__int64 UNALIGNED *)y;

    return (BOOLEAN)((a[1] == b[1]) && (a[0] == b[0]));
}

//
// RFC 3542 uses IN6_ARE_ADDR_EQUAL().
//
#define IN6_ARE_ADDR_EQUAL IN6_ADDR_EQUAL

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_UNSPECIFIED(CONST IN6_ADDR *a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     (a->s6_words[6] == 0) &&
                     (a->s6_words[7] == 0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_LOOPBACK(CONST IN6_ADDR *a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     (a->s6_words[6] == 0) &&
                     (a->s6_words[7] == 0x0100));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MULTICAST(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(a->s6_bytes[0] == 0xff);
}

//
//  Does the address have a format prefix
//  that indicates it uses EUI-64 interface identifiers?
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_EUI64(CONST IN6_ADDR *a)
{
    //
    // Format prefixes 001 through 111, except for multicast.
    //
    return (BOOLEAN)(((a->s6_bytes[0] & 0xe0) != 0) &&
                     !IN6_IS_ADDR_MULTICAST(a));
}

//
//  Is this the subnet router anycast address?
//  See RFC 2373.
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     (a->s6_words[6] == 0) &&
                     (a->s6_words[7] == 0));
}

//
//  Is this a subnet reserved anycast address?
//  See RFC 2526. It talks about non-EUI-64
//  addresses as well, but IMHO that part
//  of the RFC doesn't make sense. For example,
//  it shouldn't apply to multicast or v4-compatible
//  addresses.
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->s6_words[4] == 0xfffd) &&
                     (a->s6_words[5] == 0xffff) &&
                     (a->s6_words[6] == 0xffff) &&
                     ((a->s6_words[7] & 0x80ff) == 0x80ff));
}

//
//  As best we can tell from simple inspection,
//  is this an anycast address?
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_ANYCAST(CONST IN6_ADDR *a)
{
    return (IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(a) || 
            IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(a));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_LINKLOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_bytes[0] == 0xfe) && 
                     ((a->s6_bytes[1] & 0xc0) == 0x80));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_SITELOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_bytes[0] == 0xfe) && 
                     ((a->s6_bytes[1] & 0xc0) == 0xc0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_GLOBAL(CONST IN6_ADDR *a)
{
    //
    // Check the format prefix and exclude addresses
    // whose high 4 bits are all zero or all one.
    // This is a cheap way of excluding v4-compatible,
    // v4-mapped, loopback, multicast, link-local, site-local.
    //
    ULONG High = (a->s6_bytes[0] & 0xf0);
    return (BOOLEAN)((High != 0) && (High != 0xf0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_V4MAPPED(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0xffff));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_V4COMPAT(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     !((a->s6_words[6] == 0) &&
                       (a->s6_addr[14] == 0) &&
                       ((a->s6_addr[15] == 0) || (a->s6_addr[15] == 1))));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_V4TRANSLATED(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0xffff) &&
                     (a->s6_words[5] == 0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_NODELOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 1));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_LINKLOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 2));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_SITELOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 5));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_ORGLOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 8));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_GLOBAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 0xe));
}

WS2TCPIP_INLINE 
VOID
IN6_SET_ADDR_UNSPECIFIED(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->s6_bytes, 0, sizeof(IN6_ADDR));
}

WS2TCPIP_INLINE 
VOID
IN6_SET_ADDR_LOOPBACK(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->s6_bytes, 0, sizeof(IN6_ADDR));
    a->s6_bytes[15] = 1;
}

WS2TCPIP_INLINE
VOID
IN6ADDR_SETANY(PSOCKADDR_IN6 a)
{
    a->sin6_family = AF_INET6;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_UNSPECIFIED(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

WS2TCPIP_INLINE
VOID
IN6ADDR_SETLOOPBACK(PSOCKADDR_IN6 a)
{
    a->sin6_family = AF_INET6;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_LOOPBACK(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISANY(CONST SOCKADDR_IN6 *a)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr);
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISLOOPBACK(CONST SOCKADDR_IN6 *a)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return IN6_IS_ADDR_LOOPBACK(&a->sin6_addr);
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISEQUAL(CONST SOCKADDR_IN6 *a, CONST SOCKADDR_IN6 *b)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return (BOOLEAN)(a->sin6_scope_id == b->sin6_scope_id &&
                     IN6_ADDR_EQUAL(&a->sin6_addr, &b->sin6_addr));
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISUNSPECIFIED(CONST SOCKADDR_IN6 *a)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return (BOOLEAN)(a->sin6_scope_id == 0 &&
                     IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr));
}

#endif // __midl

#endif // (NTDDI_VERSION >= NTDDI_WIN2KSP1) 

//
// TCP/IP specific Ioctl codes.
//
#define SIO_GET_INTERFACE_LIST     _IOR('t', 127, ULONG)
#define SIO_GET_INTERFACE_LIST_EX  _IOR('t', 126, ULONG)
#define SIO_SET_MULTICAST_FILTER   _IOW('t', 125, ULONG)
#define SIO_GET_MULTICAST_FILTER   _IOW('t', 124 | IOC_IN, ULONG)
#define SIOCSIPMSFILTER            SIO_SET_MULTICAST_FILTER
#define SIOCGIPMSFILTER            SIO_GET_MULTICAST_FILTER

//
// Protocol independent ioctls for setting and retrieving multicast filters. 
//
#define SIOCSMSFILTER     _IOW('t', 126, ULONG)
#define SIOCGMSFILTER     _IOW('t', 127 | IOC_IN, ULONG)

#if (NTDDI_VERSION >= NTDDI_VISTASP1)

#define IDEAL_SEND_BACKLOG_IOCTLS

//
// Query and change notification ioctls for the ideal send backlog size
// for a given connection. Clients should use the wrappers defined in 
// ws2tcpip.h rather than using these ioctls directly.
//

#define SIO_IDEAL_SEND_BACKLOG_QUERY   _IOR('t', 123, ULONG)
#define SIO_IDEAL_SEND_BACKLOG_CHANGE   _IO('t', 122)

#endif

//
// Protocol independent multicast source filter options.
//
#define MCAST_JOIN_GROUP            41	// Join all sources for a group.
#define MCAST_LEAVE_GROUP           42  // Drop all sources for a group.
#define MCAST_BLOCK_SOURCE          43	// Block IP group/source.
#define MCAST_UNBLOCK_SOURCE        44	// Unblock IP group/source.
#define MCAST_JOIN_SOURCE_GROUP     45	// Join IP group/source.
#define MCAST_LEAVE_SOURCE_GROUP    46	// Leave IP group/source.

//
// Definitions of MCAST_INCLUDE and MCAST_EXCLUDE for multicast source filter. 
//
typedef enum {
    MCAST_INCLUDE = 0,
    MCAST_EXCLUDE 
} MULTICAST_MODE_TYPE;

//
// Structure for IP_MREQ (used by IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP). 
//
typedef struct ip_mreq {
    IN_ADDR imr_multiaddr;  // IP multicast address of group.
    IN_ADDR imr_interface;  // Local IP address of interface.
} IP_MREQ, *PIP_MREQ;

//
// Structure for IP_MREQ_SOURCE (used by IP_BLOCK_SOURCE, IP_UNBLOCK_SOURCE
// etc.). 
//
typedef struct ip_mreq_source {
    IN_ADDR imr_multiaddr;  // IP multicast address of group.
    IN_ADDR imr_sourceaddr; // IP address of source.
    IN_ADDR imr_interface;  // Local IP address of interface.
} IP_MREQ_SOURCE, *PIP_MREQ_SOURCE;

//
// Structure for IP_MSFILTER (used by SIOCSIPMSFILTER and SIOCGIPMSFILTER). 
// 
typedef struct ip_msfilter {
    IN_ADDR imsf_multiaddr;  // IP multicast address of group.
    IN_ADDR imsf_interface;  // Local IP address of interface.
    MULTICAST_MODE_TYPE imsf_fmode;        // Filter mode.
    ULONG imsf_numsrc;       // Number of sources in src_list.
    IN_ADDR imsf_slist[1];   // Start of source list.
} IP_MSFILTER, *PIP_MSFILTER;

#define IP_MSFILTER_SIZE(NumSources) \
    (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (NumSources) * sizeof(IN_ADDR))

//
// Options to use with [gs]etsockopt at the IPPROTO_IPV6 level.
// These are specified in RFCs 3493 and 3542.
// The values should be consistent with the IPv6 equivalents.
//
#define IPV6_HOPOPTS           1 // Set/get IPv6 hop-by-hop options.
#define IPV6_HDRINCL           2 // Header is included with data.
#define IPV6_UNICAST_HOPS      4 // IP unicast hop limit.
#define IPV6_MULTICAST_IF      9 // IP multicast interface.
#define IPV6_MULTICAST_HOPS   10 // IP multicast hop limit.
#define IPV6_MULTICAST_LOOP   11 // IP multicast loopback.
#define IPV6_ADD_MEMBERSHIP   12 // Add an IP group membership.
#define IPV6_JOIN_GROUP       IPV6_ADD_MEMBERSHIP
#define IPV6_DROP_MEMBERSHIP  13 // Drop an IP group membership.
#define IPV6_LEAVE_GROUP      IPV6_DROP_MEMBERSHIP
#define IPV6_DONTFRAG         14 // Don't fragment IP datagrams.
#define IPV6_PKTINFO          19 // Receive packet information.
#define IPV6_HOPLIMIT         21 // Receive packet hop limit.
#define IPV6_PROTECTION_LEVEL 23 // Set/get IPv6 protection level.
#define IPV6_RECVIF           24 // Receive arrival interface.
#define IPV6_RECVDSTADDR      25 // Receive destination address.
#define IPV6_CHECKSUM         26 // Offset to checksum for raw IP socket send.
#define IPV6_V6ONLY           27 // Treat wildcard bind as AF_INET6-only.
#define IPV6_IFLIST           28 // Enable/Disable an interface list.
#define IPV6_ADD_IFLIST       29 // Add an interface list entry.
#define IPV6_DEL_IFLIST       30 // Delete an interface list entry.
#define IPV6_UNICAST_IF       31 // IP unicast interface.
#define IPV6_RTHDR            32 // Set/get IPv6 routing header.
#define IPV6_RECVRTHDR        38 // Receive the routing header.

#define IP_UNSPECIFIED_HOP_LIMIT -1

//
// Values of IPV6_PROTECTION_LEVEL.
//
#define PROTECTION_LEVEL_UNRESTRICTED   10 // For peer-to-peer apps. 
#define PROTECTION_LEVEL_EDGERESTRICTED 20 // Same as unrestricted. Except for
                                           // Teredo.
#define PROTECTION_LEVEL_RESTRICTED     30 // For Intranet apps.

#if (NTDDI_VERSION < NTDDI_VISTA)
#define PROTECTION_LEVEL_DEFAULT        PROTECTION_LEVEL_EDGERESTRICTED
#else
#define PROTECTION_LEVEL_DEFAULT        ((UINT)-1)
#endif
//
// Structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP (also,
// IPV6_ADD_MEMBERSHIP and IPV6_DROP_MEMBERSHIP).
//
typedef struct ipv6_mreq {
    IN6_ADDR ipv6mr_multiaddr;  // IPv6 multicast address.
    ULONG ipv6mr_interface;     // Interface index.
} IPV6_MREQ, *PIPV6_MREQ;

#if (NTDDI_VERSION >= NTDDI_WINXP)
//
// Structure for GROUP_REQ used by protocol independent source filters
// (MCAST_JOIN_GROUP and MCAST_LEAVE_GROUP). 
//
typedef struct group_req {
    ULONG gr_interface;         // Interface index.
    SOCKADDR_STORAGE gr_group;  // Multicast address.
} GROUP_REQ, *PGROUP_REQ;

//
// Structure for GROUP_SOURCE_REQ used by protocol independent source filters
// (MCAST_JOIN_SOURCE_GROUP, MCAST_LEAVE_SOURCE_GROUP etc.).
//
typedef struct group_source_req {
    ULONG gsr_interface;        // Interface index.
    SOCKADDR_STORAGE gsr_group; // Group address.
    SOCKADDR_STORAGE gsr_source; // Source address.
} GROUP_SOURCE_REQ, *PGROUP_SOURCE_REQ;

//
// Structure for GROUP_FILTER used by protocol independent source filters
// (SIOCSMSFILTER and SIOCGMSFILTER).
//
typedef struct group_filter {
    ULONG gf_interface;         // Interface index.
    SOCKADDR_STORAGE gf_group;  // Multicast address.
    MULTICAST_MODE_TYPE gf_fmode; // Filter mode.
    ULONG gf_numsrc;            // Number of sources.
    SOCKADDR_STORAGE gf_slist[1]; // Source address.
} GROUP_FILTER, *PGROUP_FILTER;

#define GROUP_FILTER_SIZE(numsrc) \
   (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) \
   + (numsrc) * sizeof(SOCKADDR_STORAGE))
#endif

//
// Structure for IP_PKTINFO option.
//
typedef struct in_pktinfo {
    IN_ADDR ipi_addr;     // Source/destination IPv4 address.
    ULONG ipi_ifindex;    // Send/receive interface index.
} IN_PKTINFO, *PIN_PKTINFO;

C_ASSERT(sizeof(IN_PKTINFO) == 8);

//
// Structure for IPV6_PKTINFO option.
//
typedef struct in6_pktinfo {
    IN6_ADDR ipi6_addr;    // Source/destination IPv6 address.
    ULONG ipi6_ifindex;    // Send/receive interface index.
} IN6_PKTINFO, *PIN6_PKTINFO;

C_ASSERT(sizeof(IN6_PKTINFO) == 20);

//
// Maximum length of address literals (potentially including a port number)
// generated by any address-to-string conversion routine.  This length can
// be used when declaring buffers used with getnameinfo, WSAAddressToString,
// inet_ntoa, etc.  We just provide one define, rather than one per api,
// to avoid confusion.
//
// The totals are derived from the following data:
//  15: IPv4 address
//  45: IPv6 address including embedded IPv4 address
//  11: Scope Id
//   2: Brackets around IPv6 address when port is present
//   6: Port (including colon)
//   1: Terminating null byte
//
#define INET_ADDRSTRLEN  22
#define INET6_ADDRSTRLEN 65



//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
// TCP_NODELAY is defined in ws2def.h for historical reasons.
//

//
// Offload preferences supported.
//
#define TCP_OFFLOAD_NO_PREFERENCE	0
#define	TCP_OFFLOAD_NOT_PREFERRED	1
#define TCP_OFFLOAD_PREFERRED		2

//      TCP_NODELAY         	 0x0001
#define TCP_EXPEDITED_1122  	 0x0002
#define TCP_KEEPALIVE       	 3
#define TCP_MAXSEG          	 4
#define TCP_MAXRT           	 5
#define TCP_STDURG          	 6
#define TCP_NOURG           	 7
#define TCP_ATMARK          	 8
#define TCP_NOSYNRETRIES    	 9
#define TCP_TIMESTAMPS      	 10
#define TCP_OFFLOAD_PREFERENCE	 11
#define TCP_CONGESTION_ALGORITHM 12
#define TCP_DELAY_FIN_ACK        13

#ifdef _PREFAST_
#pragma prefast(pop)
#endif

#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Component: WSDAPI - Microsoft Web Services for Devices API
// 
//  File: wsdapi.h
//
//  Abstract: Top-level header file
//
//  Notes: If using winsock, winsock2.h should be included before this file
//
//--------------------------------------------------------------------------
#pragma once

#include <wsdbase.h>
#include <wsdattachment.h>
#include <wsdxml.h>
#include <wsddisco.h>
#include <wsdclient.h>
#include <wsdhost.h>
#include <wsdtypes.h>
#include <wsdutil.h>
#include <wsdns.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdattachment.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wsdattachment.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsdattachment_h__
#define __wsdattachment_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSDAttachment_FWD_DEFINED__
#define __IWSDAttachment_FWD_DEFINED__
typedef interface IWSDAttachment IWSDAttachment;
#endif 	/* __IWSDAttachment_FWD_DEFINED__ */


#ifndef __IWSDOutboundAttachment_FWD_DEFINED__
#define __IWSDOutboundAttachment_FWD_DEFINED__
typedef interface IWSDOutboundAttachment IWSDOutboundAttachment;
#endif 	/* __IWSDOutboundAttachment_FWD_DEFINED__ */


#ifndef __IWSDInboundAttachment_FWD_DEFINED__
#define __IWSDInboundAttachment_FWD_DEFINED__
typedef interface IWSDInboundAttachment IWSDInboundAttachment;
#endif 	/* __IWSDInboundAttachment_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsdattachment_0000_0000 */
/* [local] */ 




HRESULT WINAPI
WSDCreateOutboundAttachment(
    IWSDOutboundAttachment** ppAttachment);


extern RPC_IF_HANDLE __MIDL_itf_wsdattachment_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdattachment_0000_0000_v0_0_s_ifspec;

#ifndef __IWSDAttachment_INTERFACE_DEFINED__
#define __IWSDAttachment_INTERFACE_DEFINED__

/* interface IWSDAttachment */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWSDAttachment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5d55a616-9df8-4b09-b156-9ba351a48b76")
    IWSDAttachment : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWSDAttachmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDAttachment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDAttachment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDAttachment * This);
        
        END_INTERFACE
    } IWSDAttachmentVtbl;

    interface IWSDAttachment
    {
        CONST_VTBL struct IWSDAttachmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDAttachment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDAttachment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDAttachment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDAttachment_INTERFACE_DEFINED__ */


#ifndef __IWSDOutboundAttachment_INTERFACE_DEFINED__
#define __IWSDOutboundAttachment_INTERFACE_DEFINED__

/* interface IWSDOutboundAttachment */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IWSDOutboundAttachment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa302f8d-5a22-4ba5-b392-aa8486f4c15d")
    IWSDOutboundAttachment : public IWSDAttachment
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [size_is][in] */ const BYTE *pBuffer,
            /* [in] */ DWORD dwBytesToWrite,
            /* [out] */ LPDWORD pdwNumberOfBytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDOutboundAttachmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDOutboundAttachment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDOutboundAttachment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDOutboundAttachment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IWSDOutboundAttachment * This,
            /* [size_is][in] */ const BYTE *pBuffer,
            /* [in] */ DWORD dwBytesToWrite,
            /* [out] */ LPDWORD pdwNumberOfBytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWSDOutboundAttachment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IWSDOutboundAttachment * This);
        
        END_INTERFACE
    } IWSDOutboundAttachmentVtbl;

    interface IWSDOutboundAttachment
    {
        CONST_VTBL struct IWSDOutboundAttachmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDOutboundAttachment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDOutboundAttachment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDOutboundAttachment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 



#define IWSDOutboundAttachment_Write(This,pBuffer,dwBytesToWrite,pdwNumberOfBytesWritten)	\
    ( (This)->lpVtbl -> Write(This,pBuffer,dwBytesToWrite,pdwNumberOfBytesWritten) ) 

#define IWSDOutboundAttachment_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IWSDOutboundAttachment_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDOutboundAttachment_INTERFACE_DEFINED__ */


#ifndef __IWSDInboundAttachment_INTERFACE_DEFINED__
#define __IWSDInboundAttachment_INTERFACE_DEFINED__

/* interface IWSDInboundAttachment */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IWSDInboundAttachment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5bd6ca65-233c-4fb8-9f7a-2641619655c9")
    IWSDInboundAttachment : public IWSDAttachment
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out] */ BYTE *pBuffer,
            /* [in] */ DWORD dwBytesToRead,
            /* [out] */ LPDWORD pdwNumberOfBytesRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDInboundAttachmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDInboundAttachment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDInboundAttachment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDInboundAttachment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IWSDInboundAttachment * This,
            /* [length_is][size_is][out] */ BYTE *pBuffer,
            /* [in] */ DWORD dwBytesToRead,
            /* [out] */ LPDWORD pdwNumberOfBytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWSDInboundAttachment * This);
        
        END_INTERFACE
    } IWSDInboundAttachmentVtbl;

    interface IWSDInboundAttachment
    {
        CONST_VTBL struct IWSDInboundAttachmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDInboundAttachment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDInboundAttachment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDInboundAttachment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 



#define IWSDInboundAttachment_Read(This,pBuffer,dwBytesToRead,pdwNumberOfBytesRead)	\
    ( (This)->lpVtbl -> Read(This,pBuffer,dwBytesToRead,pdwNumberOfBytesRead) ) 

#define IWSDInboundAttachment_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDInboundAttachment_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WS2tcpip.h ===
/*
**  WS2TCPIP.H - WinSock2 Extension for TCP/IP protocols
**
**  This file contains TCP/IP specific information for use
**  by WinSock2 compatible applications.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**  To provide the backward compatibility, all the TCP/IP
**  specific definitions that were included in the WINSOCK.H
**   file are now included in WINSOCK2.H file. WS2TCPIP.H
**  file includes only the definitions  introduced in the
**  "WinSock 2 Protocol-Specific Annex" document.
**
**  Rev 0.3 Nov 13, 1995
**      Rev 0.4 Dec 15, 1996
*/

#ifndef _WS2TCPIP_H_
#define _WS2TCPIP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <winsock2.h>
#include <ws2ipdef.h>
#include <limits.h>

/* Option to use with [gs]etsockopt at the IPPROTO_UDP level */

#define UDP_NOCHECKSUM  1
#define UDP_CHECKSUM_COVERAGE   20  /* Set/get UDP-Lite checksum coverage */

#ifdef _MSC_VER
#define WS2TCPIP_INLINE __inline
#else
#define WS2TCPIP_INLINE extern inline /* GNU style */
#endif

/* Error codes from getaddrinfo() */

#define EAI_AGAIN       WSATRY_AGAIN
#define EAI_BADFLAGS    WSAEINVAL
#define EAI_FAIL        WSANO_RECOVERY
#define EAI_FAMILY      WSAEAFNOSUPPORT
#define EAI_MEMORY      WSA_NOT_ENOUGH_MEMORY
//#define EAI_NODATA      WSANO_DATA
#define EAI_NONAME      WSAHOST_NOT_FOUND
#define EAI_SERVICE     WSATYPE_NOT_FOUND
#define EAI_SOCKTYPE    WSAESOCKTNOSUPPORT

//
//  DCR_FIX:  EAI_NODATA remove or fix
//
//  EAI_NODATA was removed from rfc2553bis
//  need to find out from the authors why and
//  determine the error for "no records of this type"
//  temporarily, we'll keep #define to avoid changing
//  code that could change back;  use NONAME
//

#define EAI_NODATA      EAI_NONAME


/* Structure used in getaddrinfo() call */

typedef struct addrinfo
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char *              ai_canonname;   // Canonical name for nodename
    __field_bcount(ai_addrlen) struct sockaddr *   ai_addr;        // Binary address
    struct addrinfo *   ai_next;        // Next structure in linked list
}
ADDRINFOA, *PADDRINFOA;

typedef struct addrinfoW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    __field_bcount(ai_addrlen) struct sockaddr *   ai_addr;        // Binary address
    struct addrinfoW *  ai_next;        // Next structure in linked list
}
ADDRINFOW, *PADDRINFOW;

//  Switchable definition for GetAddrInfo()

#ifdef UNICODE
typedef ADDRINFOW       ADDRINFOT, *PADDRINFOT;
#else
typedef ADDRINFOA       ADDRINFOT, *PADDRINFOT;
#endif

//  RFC standard definition for getaddrinfo()

typedef ADDRINFOA       ADDRINFO, FAR * LPADDRINFO;

#if (_WIN32_WINNT >= 0x0600)

typedef struct addrinfoexA
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char               *ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexA *ai_next;        // Next structure in linked list
} ADDRINFOEXA, *PADDRINFOEXA, *LPADDRINFOEXA;

typedef struct addrinfoexW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    __field_bcount(ai_addrlen) struct sockaddr    *ai_addr;        // Binary address
    __field_ecount(ai_bloblen) void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexW *ai_next;        // Next structure in linked list
} ADDRINFOEXW, *PADDRINFOEXW, *LPADDRINFOEXW;

#ifdef UNICODE
typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
#else
typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
#endif

#endif


//
//  Flags used in "hints" argument to getaddrinfo()
//      - AI_ADDRCONFIG is supported starting with Vista
//      - default is AI_ADDRCONFIG ON whether the flag is set or not
//        because the performance penalty in not having ADDRCONFIG in
//        the multi-protocol stack environment is severe;
//        this defaulting may be disabled by specifying the AI_ALL flag,
//        in that case AI_ADDRCONFIG must be EXPLICITLY specified to
//        enable ADDRCONFIG behavior
//

#define AI_PASSIVE      0x00000001  // Socket address will be used in bind() call
#define AI_CANONNAME    0x00000002  // Return canonical name in first ai_canonname
#define AI_NUMERICHOST  0x00000004  // Nodename must be a numeric address string
#define AI_NUMERICSERV  0x00000008  // Servicename must be a numeric port number

#define AI_ALL          0x00000100  // Query both IP6 and IP4 with AI_V4MAPPED
#define AI_ADDRCONFIG   0x00000400  // Resolution only if global address configured
#define AI_V4MAPPED     0x00000800  // On v6 failure, query v4 and convert to V4MAPPED format


#define AI_NON_AUTHORITATIVE        LUP_NON_AUTHORITATIVE       // 0x4000
#define AI_SECURE                   LUP_SECURE                  // 0x8000
#define AI_RETURN_PREFERRED_NAMES   LUP_RETURN_PREFERRED_NAMES  // 0x10000

#ifdef __cplusplus
extern "C" {
#endif

WINSOCK_API_LINKAGE
INT
WSAAPI
getaddrinfo(
    __in_opt        PCSTR               pNodeName,
    __in_opt        PCSTR               pServiceName,
    __in_opt        const ADDRINFOA *   pHints,
    __deref_out     PADDRINFOA *        ppResult
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
INT
WSAAPI
GetAddrInfoW(
    __in_opt        PCWSTR              pNodeName,
    __in_opt        PCWSTR              pServiceName,
    __in_opt        const ADDRINFOW *   pHints,
    __deref_out     PADDRINFOW *        ppResult
    );

#define GetAddrInfoA    getaddrinfo

#ifdef UNICODE
#define GetAddrInfo     GetAddrInfoW
#else
#define GetAddrInfo     GetAddrInfoA
#endif
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_GETADDRINFO)(
    __in_opt        PCSTR               pNodeName,
    __in_opt        PCSTR               pServiceName,
    __in_opt        const ADDRINFOA *   pHints,
    __deref_out     PADDRINFOA *        ppResult
    );

typedef
INT
(WSAAPI * LPFN_GETADDRINFOW)(
    __in_opt        PCWSTR              pNodeName,
    __in_opt        PCWSTR              pServiceName,
    __in_opt        const ADDRINFOW *   pHints,
    __deref_out     PADDRINFOW *        ppResult
    );

#define LPFN_GETADDRINFOA      LPFN_GETADDRINFO

#ifdef UNICODE
#define LPFN_GETADDRINFOT      LPFN_GETADDRINFOW
#else
#define LPFN_GETADDRINFOT      LPFN_GETADDRINFOA
#endif
#endif

#if (_WIN32_WINNT >= 0x0600)

typedef
void
(CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(
    IN      DWORD    dwError,
    IN      DWORD    dwBytes,
    __in    LPWSAOVERLAPPED lpOverlapped
    );

WINSOCK_API_LINKAGE
INT
WSAAPI
GetAddrInfoExA(
    __in_opt    PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXA *hints,
    __deref_out PADDRINFOEXA *  ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

WINSOCK_API_LINKAGE
INT
WSAAPI
GetAddrInfoExW(
    __in_opt    PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXW *hints,
    __deref_out PADDRINFOEXW *  ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpHandle
    );

#ifdef UNICODE
#define GetAddrInfoEx       GetAddrInfoExW
#else
#define GetAddrInfoEx       GetAddrInfoExA
#endif

#if INCL_WINSOCK_API_TYPEDEFS

typedef
INT
(WSAAPI *LPFN_GETADDRINFOEXA)(
    __in        PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXA *hints,
    __deref_out PADDRINFOEXA   *ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

typedef
INT
(WSAAPI *LPFN_GETADDRINFOEXW)(
    __in        PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXW *hints,
    __deref_out PADDRINFOEXW   *ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpHandle
    );

#ifdef UNICODE
#define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXW
#else
#define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXA
#endif
#endif

#endif

#if (_WIN32_WINNT >= 0x0600)

WINSOCK_API_LINKAGE
INT
WSAAPI
SetAddrInfoExA(
    __in        PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

WINSOCK_API_LINKAGE
INT
WSAAPI
SetAddrInfoExW(
    __in        PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

#ifdef UNICODE
#define SetAddrInfoEx       SetAddrInfoExW
#else
#define SetAddrInfoEx       SetAddrInfoExA
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI *LPFN_SETADDRINFOEXA)(
    __in        PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

typedef
INT
(WSAAPI *LPFN_SETADDRINFOEXW)(
    __in        PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

#ifdef UNICODE
#define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXW
#else
#define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXA
#endif
#endif

#endif

WINSOCK_API_LINKAGE
VOID
WSAAPI
freeaddrinfo(
    __in_opt        PADDRINFOA      pAddrInfo
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
VOID
WSAAPI
FreeAddrInfoW(
    __in_opt        PADDRINFOW      pAddrInfo
    );

#define FreeAddrInfoA   freeaddrinfo

#ifdef UNICODE
#define FreeAddrInfo    FreeAddrInfoW
#else
#define FreeAddrInfo    FreeAddrInfoA
#endif
#endif


#if INCL_WINSOCK_API_TYPEDEFS
typedef
VOID
(WSAAPI * LPFN_FREEADDRINFO)(
    __in_opt        PADDRINFOA      pAddrInfo
    );
typedef
VOID
(WSAAPI * LPFN_FREEADDRINFOW)(
    __in_opt        PADDRINFOW      pAddrInfo
    );

#define LPFN_FREEADDRINFOA      LPFN_FREEADDRINFO

#ifdef UNICODE
#define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOW
#else
#define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOA
#endif
#endif

#if (_WIN32_WINNT >= 0x0600)

WINSOCK_API_LINKAGE
void
WSAAPI
FreeAddrInfoEx(
    __in_opt  PADDRINFOEXA    pAddrInfoEx
    );

WINSOCK_API_LINKAGE
void
WSAAPI
FreeAddrInfoExW(
    __in_opt  PADDRINFOEXW    pAddrInfoEx
    );

#define FreeAddrInfoExA     FreeAddrInfoEx

#ifdef UNICODE
#define FreeAddrInfoEx      FreeAddrInfoExW
#endif

#ifdef INCL_WINSOCK_API_TYPEDEFS
typedef
void
(WSAAPI *LPFN_FREEADDRINFOEXA)(
    __in    PADDRINFOEXA    pAddrInfoEx
    );

typedef
void
(WSAAPI *LPFN_FREEADDRINFOEXW)(
    __in    PADDRINFOEXW    pAddrInfoEx
    );


#ifdef UNICODE
#define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXW
#else
#define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXA
#endif

#endif
#endif

typedef int socklen_t;

WINSOCK_API_LINKAGE
INT
WSAAPI
getnameinfo(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PCHAR               pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PCHAR               pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
INT
WSAAPI
GetNameInfoW(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PWCHAR              pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PWCHAR              pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

#define GetNameInfoA    getnameinfo

#ifdef UNICODE
#define GetNameInfo     GetNameInfoW
#else
#define GetNameInfo     GetNameInfoA
#endif
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETNAMEINFO)(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PCHAR               pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PCHAR               pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

typedef
INT
(WSAAPI * LPFN_GETNAMEINFOW)(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PWCHAR              pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PWCHAR              pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

#define LPFN_GETNAMEINFOA      LPFN_GETNAMEINFO

#ifdef UNICODE
#define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOW
#else
#define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOA
#endif
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
WINSOCK_API_LINKAGE
INT
WSAAPI
inet_pton(
    __in                                INT             Family,
    __in                                PCSTR           pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

INT
WSAAPI
InetPtonW(
    __in                                INT             Family,
    __in                                PCWSTR          pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

PCSTR
WSAAPI
inet_ntop(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PSTR            pStringBuf,
    __in                                size_t          StringBufSize
    );

PCWSTR
WSAAPI
InetNtopW(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PWSTR           pStringBuf,
    __in                                size_t          StringBufSize
    );

#define InetPtonA       inet_pton
#define InetNtopA       inet_ntop

#ifdef UNICODE
#define InetPton        InetPtonW
#define InetNtop        InetNtopW
#else
#define InetPton        InetPtonA
#define InetNtop        InetNtopA
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_INET_PTONA)(
    __in                                INT             Family,
    __in                                PCSTR           pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

typedef
INT
(WSAAPI * LPFN_INET_PTONW)(
    __in                                INT             Family,
    __in                                PCWSTR          pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

typedef
PCSTR
(WSAAPI * LPFN_INET_NTOPA)(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PSTR            pStringBuf,
    __in                                size_t          StringBufSize
    );

typedef
PCWSTR
(WSAAPI * LPFN_INET_NTOPW)(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PWSTR           pStringBuf,
    __in                                size_t          StringBufSize
    );

#ifdef UNICODE
#define LPFN_INET_PTON          LPFN_INET_PTONW
#define LPFN_INET_NTOP          LPFN_INET_NTOPW
#else
#define LPFN_INET_PTON          LPFN_INET_PTONA
#define LPFN_INET_NTOP          LPFN_INET_NTOPA
#endif

#endif  //  TYPEDEFS
#endif  //  LONGHORN



#if INCL_WINSOCK_API_PROTOTYPES
#ifdef UNICODE
#define gai_strerror   gai_strerrorW
#else
#define gai_strerror   gai_strerrorA
#endif  /* UNICODE */

// WARNING: The gai_strerror inline functions below use static buffers,
// and hence are not thread-safe.  We'll use buffers long enough to hold
// 1k characters.  Any system error messages longer than this will be
// returned as empty strings.  However 1k should work for the error codes
// used by getaddrinfo().
#define GAI_STRERROR_BUFFER_SIZE 1024

WS2TCPIP_INLINE
char *
gai_strerrorA(
    IN int ecode)
{
    DWORD dwMsgLen;
    static char buff[GAI_STRERROR_BUFFER_SIZE + 1];

    dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
                             |FORMAT_MESSAGE_IGNORE_INSERTS
                             |FORMAT_MESSAGE_MAX_WIDTH_MASK,
                              NULL,
                              ecode,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPSTR)buff,
                              GAI_STRERROR_BUFFER_SIZE,
                              NULL);

    return buff;
}

WS2TCPIP_INLINE
WCHAR *
gai_strerrorW(
    IN int ecode
    )
{
    DWORD dwMsgLen;
    static WCHAR buff[GAI_STRERROR_BUFFER_SIZE + 1];

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
                             |FORMAT_MESSAGE_IGNORE_INSERTS
                             |FORMAT_MESSAGE_MAX_WIDTH_MASK,
                              NULL,
                              ecode,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPWSTR)buff,
                              GAI_STRERROR_BUFFER_SIZE,
                              NULL);

    return buff;
}
#endif /* INCL_WINSOCK_API_PROTOTYPES */




#define NI_MAXHOST  1025  /* Max size of a fully-qualified domain name */
#define NI_MAXSERV    32  /* Max size of a service name */

/* Flags for getnameinfo() */

#define NI_NOFQDN       0x01  /* Only return nodename portion for local hosts */
#define NI_NUMERICHOST  0x02  /* Return numeric form of the host's address */
#define NI_NAMEREQD     0x04  /* Error if the host's name not in DNS */
#define NI_NUMERICSERV  0x08  /* Return numeric form of the service (port #) */
#define NI_DGRAM        0x10  /* Service is a datagram service */

/* Multicast source filter APIs from RFC 3678. */

WS2TCPIP_INLINE
int
setipv4sourcefilter(
    IN SOCKET Socket,
    IN IN_ADDR Interface,
    IN IN_ADDR Group,
    IN MULTICAST_MODE_TYPE FilterMode,
    IN ULONG SourceCount,
    IN CONST IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;

    if (SourceCount >
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = IP_MSFILTER_SIZE(SourceCount);
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_fmode = FilterMode;
    Filter->imsf_numsrc = SourceCount;
    if (SourceCount > 0) {
        CopyMemory(Filter->imsf_slist, SourceList,
                   SourceCount * sizeof(*SourceList));
    }

    Error = WSAIoctl(Socket, SIOCSIPMSFILTER, Filter, Size, NULL, 0,
                     &Returned, NULL, NULL);

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

WS2TCPIP_INLINE
int
getipv4sourcefilter(
    IN SOCKET Socket,
    IN IN_ADDR Interface,
    IN IN_ADDR Group,
    OUT MULTICAST_MODE_TYPE *FilterMode,
    IN OUT ULONG *SourceCount,
    OUT IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;

    if (*SourceCount >
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = IP_MSFILTER_SIZE(*SourceCount);
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_numsrc = *SourceCount;

    Error = WSAIoctl(Socket, SIOCGIPMSFILTER, Filter, Size, Filter, Size,
                     &Returned, NULL, NULL);

    if (Error == 0) {
        if (*SourceCount > 0) {
            CopyMemory(SourceList, Filter->imsf_slist,
                       *SourceCount * sizeof(*SourceList));
            *SourceCount = Filter->imsf_numsrc;
        }
        *FilterMode = Filter->imsf_fmode;
    }

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

#if (NTDDI_VERSION >= NTDDI_WINXP)
WS2TCPIP_INLINE
int
setsourcefilter(
    IN SOCKET Socket,
    IN ULONG Interface,
    IN CONST SOCKADDR *Group,
    IN int GroupLength,
    IN MULTICAST_MODE_TYPE FilterMode,
    IN ULONG SourceCount,
    IN CONST SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;

    if (SourceCount >=
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = GROUP_FILTER_SIZE(SourceCount);
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->gf_interface = Interface;
    ZeroMemory(&Filter->gf_group, sizeof(Filter->gf_group));
    CopyMemory(&Filter->gf_group, Group, GroupLength);
    Filter->gf_fmode = FilterMode;
    Filter->gf_numsrc = SourceCount;
    if (SourceCount > 0) {
        CopyMemory(Filter->gf_slist, SourceList,
                   SourceCount * sizeof(*SourceList));
    }

    Error = WSAIoctl(Socket, SIOCSMSFILTER, Filter, Size, NULL, 0,
                     &Returned, NULL, NULL);

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

WS2TCPIP_INLINE
int
getsourcefilter(
    IN SOCKET Socket,
    IN ULONG Interface,
    IN CONST SOCKADDR *Group,
    IN int GroupLength,
    OUT MULTICAST_MODE_TYPE *FilterMode,
    IN OUT ULONG *SourceCount,
    OUT SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;

    if (*SourceCount >
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = GROUP_FILTER_SIZE(*SourceCount);
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->gf_interface = Interface;
    ZeroMemory(&Filter->gf_group, sizeof(Filter->gf_group));
    CopyMemory(&Filter->gf_group, Group, GroupLength);
    Filter->gf_numsrc = *SourceCount;

    Error = WSAIoctl(Socket, SIOCGMSFILTER, Filter, Size, Filter, Size,
                     &Returned, NULL, NULL);

    if (Error == 0) {
        if (*SourceCount > 0) {
            CopyMemory(SourceList, Filter->gf_slist,
                       *SourceCount * sizeof(*SourceList));
            *SourceCount = Filter->gf_numsrc;
        }
        *FilterMode = Filter->gf_fmode;
    }

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}
#endif

#ifdef IDEAL_SEND_BACKLOG_IOCTLS

//
// Wrapper functions for the ideal send backlog query and change notification
// ioctls
//

WS2TCPIP_INLINE 
int  
idealsendbacklogquery(
    __in SOCKET s,
    __out ULONG *pISB
    )
{
    DWORD bytes;

    return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_QUERY, 
                    NULL, 0, pISB, sizeof(*pISB), &bytes, NULL, NULL);
}


WS2TCPIP_INLINE 
int  
idealsendbacklognotify(
    __in SOCKET s,
    __in_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    DWORD bytes;

    return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_CHANGE, 
                    NULL, 0, NULL, 0, &bytes, 
                    lpOverlapped, lpCompletionRoutine);
}

#endif

#if (_WIN32_WINNT >= 0x0600)
#ifdef _SECURE_SOCKET_TYPES_DEFINED_

//
// Secure socket API definitions
//

WINSOCK_API_LINKAGE
INT
WSAAPI
WSASetSocketSecurity (
   __in SOCKET Socket,
   __in_bcount_opt(SecuritySettingsLen) const SOCKET_SECURITY_SETTINGS* SecuritySettings,
   __in ULONG SecuritySettingsLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSAQuerySocketSecurity (
   __in SOCKET Socket,
   __in_bcount_opt(SecurityQueryTemplateLen) const SOCKET_SECURITY_QUERY_TEMPLATE* SecurityQueryTemplate,
   __in ULONG SecurityQueryTemplateLen,
   __out_bcount_part_opt(*SecurityQueryInfoLen, *SecurityQueryInfoLen) SOCKET_SECURITY_QUERY_INFO* SecurityQueryInfo,
   __inout ULONG* SecurityQueryInfoLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSASetSocketPeerTargetName (
   __in SOCKET Socket,
   __in_bcount(PeerTargetNameLen) const SOCKET_PEER_TARGET_NAME* PeerTargetName,
   __in ULONG PeerTargetNameLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSADeleteSocketPeerTargetName (
   __in SOCKET Socket,
   __in_bcount(PeerAddrLen) const struct sockaddr* PeerAddr,
   __in ULONG PeerAddrLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSAImpersonateSocketPeer (
   __in SOCKET Socket,
   __in_bcount_opt(PeerAddrLen) const struct sockaddr* PeerAddr,
   __in ULONG PeerAddrLen
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSARevertImpersonation ();

#endif //_SECURE_SOCKET_TYPES_DEFINED_
#endif //(_WIN32_WINNT >= 0x0600)

#ifdef __cplusplus
}
#endif

//
// Unless the build environment is explicitly targeting only
// platforms that include built-in getaddrinfo() support, include
// the backwards-compatibility version of the relevant APIs.
//
#if !defined(_WIN32_WINNT) || (_WIN32_WINNT <= 0x0500)
#include <wspiapi.h>
#endif

#endif  /* _WS2TCPIP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WS2spi.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    118736
//  $AgreementName:  berkeley software distribution license
//  $AgreementType:  oss license
//  $ExternalOrigin: regents of the university of california
//$ENDTAG

//$TAG ENGR 
//  $Owner:    vadime
//  $Module:   published_inc
//
//$ENDTAG

/* WS2SPI.H -- definitions to be used with the WinSock service provider.
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * This header file corresponds to version 2.2.x of the WinSock SPI
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 */

#ifndef _WINSOCK2SPI_
#define _WINSOCK2SPI_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Pull in WINSOCK2.H if necessary
 */

#ifndef _WINSOCK2API_
#include <winsock2.h>
#endif /* _WINSOCK2API_ */

/*
 * Ensure structures are packed consistently.
 */

#if !defined(_WIN64)
#include <pshpack4.h>
#endif

#define WSPDESCRIPTION_LEN 255

#define WSS_OPERATION_IN_PROGRESS 0x00000103L

typedef struct WSPData {
    WORD         wVersion;
    WORD         wHighVersion;
    WCHAR        szDescription[WSPDESCRIPTION_LEN+1];
} WSPDATA, FAR * LPWSPDATA;

typedef struct _WSATHREADID {
    HANDLE      ThreadHandle;
    DWORD_PTR    Reserved;
} WSATHREADID, FAR * LPWSATHREADID;

/*
 * SPI function linkage.
 */

#define WSPAPI WSAAPI


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Pointer to a blocking callback. A pointer to a blocking callback is
 * returned from the WPUQueryBlockingCallback() upcall. Note that this
 * function's signature is not identical to an application's blocking
 * hook function.
 */

typedef
BOOL
(CALLBACK FAR * LPBLOCKINGCALLBACK)(
    DWORD_PTR dwContext
    );

/*
 * Pointer to a user APC function. This is used as a parameter to the
 * WPUQueueUserApc() upcall. Note that this function's signature is not
 * identical to an application's completion routine.
 */

typedef
VOID
(CALLBACK FAR * LPWSAUSERAPC)(
    DWORD_PTR dwContext
    );

/*
 * Pointers to the individual entries in a service provider's proc table.
 */

typedef
SOCKET
(WSPAPI * LPWSPACCEPT)(
    SOCKET s,
    struct sockaddr FAR * addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD_PTR dwCallbackData,
    LPINT lpErrno
    );

typedef
INT
(WSPAPI * LPWSPADDRESSTOSTRING)(
    LPSOCKADDR lpsaAddress,
    DWORD dwAddressLength,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPWSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPASYNCSELECT)(
    SOCKET s,
    HWND hWnd,
    unsigned int wMsg,
    long lEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPBIND)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCANCELBLOCKINGCALL)(
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCLEANUP)(
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCLOSESOCKET)(
    SOCKET s,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCONNECT)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPDUPLICATESOCKET)(
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPENUMNETWORKEVENTS)(
    SOCKET s,
    WSAEVENT hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPEVENTSELECT)(
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWSPGETOVERLAPPEDRESULT)(
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETPEERNAME)(
    SOCKET s,
    struct sockaddr FAR * name,
    LPINT namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETSOCKNAME)(
    SOCKET s,
    struct sockaddr FAR * name,
    LPINT namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETSOCKOPT)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    LPINT optlen,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWSPGETQOSBYNAME)(
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPIOCTL)(
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWSPJOINLEAF)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPLISTEN)(
    SOCKET s,
    int backlog,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECV)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECVDISCONNECT)(
    SOCKET s,
    LPWSABUF lpInboundDisconnectData,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECVFROM)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSELECT)(
    int nfds,
    fd_set FAR * readfds,
    fd_set FAR * writefds,
    fd_set FAR * exceptfds,
    const struct timeval FAR * timeout,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSEND)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSENDDISCONNECT)(
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSENDTO)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSETSOCKOPT)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSHUTDOWN)(
    SOCKET s,
    int how,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWSPSOCKET)(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags,
    LPINT lpErrno
    );

typedef
INT
(WSPAPI * LPWSPSTRINGTOADDRESS)(
    LPWSTR AddressString,
    INT AddressFamily,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPSOCKADDR lpAddress,
    LPINT lpAddressLength,
    LPINT lpErrno
    );

/*
 * A service provider proc table. This structure is returned by value
 * from the service provider's WSPStartup() entrypoint.
 */

typedef struct _WSPPROC_TABLE {

    LPWSPACCEPT              lpWSPAccept;
    LPWSPADDRESSTOSTRING     lpWSPAddressToString;
    LPWSPASYNCSELECT         lpWSPAsyncSelect;
    LPWSPBIND                lpWSPBind;
    LPWSPCANCELBLOCKINGCALL  lpWSPCancelBlockingCall;
    LPWSPCLEANUP             lpWSPCleanup;
    LPWSPCLOSESOCKET         lpWSPCloseSocket;
    LPWSPCONNECT             lpWSPConnect;
    LPWSPDUPLICATESOCKET     lpWSPDuplicateSocket;
    LPWSPENUMNETWORKEVENTS   lpWSPEnumNetworkEvents;
    LPWSPEVENTSELECT         lpWSPEventSelect;
    LPWSPGETOVERLAPPEDRESULT lpWSPGetOverlappedResult;
    LPWSPGETPEERNAME         lpWSPGetPeerName;
    LPWSPGETSOCKNAME         lpWSPGetSockName;
    LPWSPGETSOCKOPT          lpWSPGetSockOpt;
    LPWSPGETQOSBYNAME        lpWSPGetQOSByName;
    LPWSPIOCTL               lpWSPIoctl;
    LPWSPJOINLEAF            lpWSPJoinLeaf;
    LPWSPLISTEN              lpWSPListen;
    LPWSPRECV                lpWSPRecv;
    LPWSPRECVDISCONNECT      lpWSPRecvDisconnect;
    LPWSPRECVFROM            lpWSPRecvFrom;
    LPWSPSELECT              lpWSPSelect;
    LPWSPSEND                lpWSPSend;
    LPWSPSENDDISCONNECT      lpWSPSendDisconnect;
    LPWSPSENDTO              lpWSPSendTo;
    LPWSPSETSOCKOPT          lpWSPSetSockOpt;
    LPWSPSHUTDOWN            lpWSPShutdown;
    LPWSPSOCKET              lpWSPSocket;
    LPWSPSTRINGTOADDRESS     lpWSPStringToAddress;

} WSPPROC_TABLE, FAR * LPWSPPROC_TABLE;

/*
 * Pointers to the individual entries in the upcall table.
 */

typedef
BOOL
(WSPAPI * LPWPUCLOSEEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUCLOSESOCKETHANDLE)(
    SOCKET s,
    LPINT lpErrno
    );

typedef
WSAEVENT
(WSPAPI * LPWPUCREATEEVENT)(
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWPUCREATESOCKETHANDLE)(
    DWORD dwCatalogEntryId,
    DWORD_PTR dwContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUFDISSET)(
    SOCKET s,
    fd_set FAR * fdset
    );

typedef
int
(WSPAPI * LPWPUGETPROVIDERPATH)(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWPUMODIFYIFSHANDLE)(
    DWORD dwCatalogEntryId,
    SOCKET ProposedHandle,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPUPOSTMESSAGE)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

typedef
int
(WSPAPI * LPWPUQUERYBLOCKINGCALLBACK)(
    DWORD dwCatalogEntryId,
    LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    PDWORD_PTR lpdwContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUQUERYSOCKETHANDLECONTEXT)(
    SOCKET s,
    PDWORD_PTR lpContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUQUEUEAPC)(
    LPWSATHREADID lpThreadId,
    LPWSAUSERAPC lpfnUserApc,
    DWORD_PTR dwContext,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPURESETEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPUSETEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUOPENCURRENTTHREAD)(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUCLOSETHREAD)(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );


// Available only directly from ws2_32.dll
typedef
int
(WSPAPI * LPWPUCOMPLETEOVERLAPPEDREQUEST) (
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwError,
    DWORD cbTransferred,
    LPINT lpErrno
);

/*
 * The upcall table. This structure is passed by value to the service
 * provider's WSPStartup() entrypoint.
 */

typedef struct _WSPUPCALLTABLE {

    LPWPUCLOSEEVENT               lpWPUCloseEvent;
    LPWPUCLOSESOCKETHANDLE        lpWPUCloseSocketHandle;
    LPWPUCREATEEVENT              lpWPUCreateEvent;
    LPWPUCREATESOCKETHANDLE       lpWPUCreateSocketHandle;
    LPWPUFDISSET                  lpWPUFDIsSet;
    LPWPUGETPROVIDERPATH          lpWPUGetProviderPath;
    LPWPUMODIFYIFSHANDLE          lpWPUModifyIFSHandle;
    LPWPUPOSTMESSAGE              lpWPUPostMessage;
    LPWPUQUERYBLOCKINGCALLBACK    lpWPUQueryBlockingCallback;
    LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
    LPWPUQUEUEAPC                 lpWPUQueueApc;
    LPWPURESETEVENT               lpWPUResetEvent;
    LPWPUSETEVENT                 lpWPUSetEvent;
    LPWPUOPENCURRENTTHREAD        lpWPUOpenCurrentThread;
    LPWPUCLOSETHREAD              lpWPUCloseThread;

} WSPUPCALLTABLE, FAR * LPWSPUPCALLTABLE;

/*
 *  WinSock 2 SPI socket function prototypes
 */

__control_entrypoint(DllExport)
int
WSPAPI
WSPStartup(
    IN WORD wVersionRequested,
    __in OUT LPWSPDATA lpWSPData,
    __in IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    __in IN WSPUPCALLTABLE UpcallTable,
    __inout OUT LPWSPPROC_TABLE lpProcTable
    );

typedef
int
(WSPAPI * LPWSPSTARTUP)(
    WORD wVersionRequested,
    LPWSPDATA lpWSPData,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    WSPUPCALLTABLE UpcallTable,
    LPWSPPROC_TABLE lpProcTable
    );

/*
 * Installation and configuration entrypoints.
 */

__control_entrypoint(DllExport)
int
WSPAPI
WSCEnumProtocols(
    IN LPINT lpiProtocols,
    __out_bcount_opt(*lpdwBufferLength) LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCENUMPROTOCOLS)(
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength,
    LPINT lpErrno
    );

#if(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))

/*
 * 64-bit architectures capable of running 32-bit code have
 * separate 64-bit and 32-bit catalogs.  API with '32' prefix
 * allow 32 bit catalog manipulations by 64 bit process.
 */
__control_entrypoint(DllExport)
int
WSPAPI
WSCEnumProtocols32(
    IN LPINT lpiProtocols,
    __out_bcount(*lpdwBufferLength) LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPINT lpErrno
    );
#endif //(defined(_WIN64) && _WIN32_WINNT >= 0x0501)

__control_entrypoint(DllExport)
int
WSPAPI
WSCDeinstallProvider(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCDEINSTALLPROVIDER)(
    LPGUID lpProviderId,
    LPINT lpErrno
    );

#if(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))

__control_entrypoint(DllExport)
int
WSPAPI
WSCDeinstallProvider32(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    );
#endif //(defined(_WIN64) && _WIN32_WINNT >= 0x0501)

__control_entrypoint(DllExport)
int
WSPAPI
WSCInstallProvider(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    __in_ecount(dwNumberOfEntries) const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCINSTALLPROVIDER)(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno
    );

#if(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))

/*
 * This API manipulates 64-bit and 32-bit catalogs simulteneously.
 * It is needed to guarantee the same catalog IDs for provider catalog
 * entries in both 64-bit and 32-bit catalogs.
 */
__control_entrypoint(DllExport)
int
WSPAPI
WSCInstallProvider64_32(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    __in_ecount(dwNumberOfEntries) const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );
#endif //(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))

__control_entrypoint(DllExport)
int
WSPAPI
WSCGetProviderPath(
    IN LPGUID lpProviderId,
    __out_ecount(*lpProviderDllPathLen) WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCGETPROVIDERPATH)(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno
    );

#if(_WIN32_WINNT >= 0x0501)
#if defined(_WIN64)
__control_entrypoint(DllExport)
int
WSPAPI
WSCGetProviderPath32(
    IN LPGUID lpProviderId,
    __out_ecount(*lpProviderDllPathLen) WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );
#endif

__control_entrypoint(DllExport)
int
WSPAPI
WSCUpdateProvider(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    __in_ecount(dwNumberOfEntries) const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCUPDATEPROVIDER)(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno
    );

#if defined(_WIN64)
__control_entrypoint(DllExport)
int
WSPAPI
WSCUpdateProvider32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    __in_ecount(dwNumberOfEntries) const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );
#endif
#endif //(_WIN32_WINNT >= 0x0501)

#if (_WIN32_WINNT < 0x0600)
int
WSPAPI
WSCInstallQOSTemplate (
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName,
    IN  LPQOS           Qos
    );

typedef
int
(WSPAPI * LPWSCINSTALLQOSTEMPLATE)(
    const LPGUID    Guid,
    LPWSABUF        QosName,
    LPQOS           Qos
    );

int
WSPAPI
WSCRemoveQOSTemplate (
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName
    );

typedef
int
(WSPAPI * LPWSCREMOVEQOSTEMPLATE)(
    const LPGUID    Guid,
    LPWSABUF        QosName
    );

#endif //(_WIN32_WINNT < 0x0600)

#if(_WIN32_WINNT >= 0x0600)

//
// LSP Categorization
//

#define LSP_SYSTEM             0x80000000
#define LSP_INSPECTOR          0x00000001
#define LSP_REDIRECTOR         0x00000002
#define LSP_PROXY              0x00000004
#define LSP_FIREWALL           0x00000008
#define LSP_INBOUND_MODIFY     0x00000010
#define LSP_OUTBOUND_MODIFY    0x00000020
#define LSP_CRYPTO_COMPRESS    0x00000040
#define LSP_LOCAL_CACHE        0x00000080

//
// Provider Information APIs
//

typedef enum _WSC_PROVIDER_INFO_TYPE {
//  InfoType is:                  Info points to:
    ProviderInfoLspCategories, // DWORD (LspCategories)
    ProviderInfoAudit,         // struct WSC_PROVIDER_AUDIT_INFO
} WSC_PROVIDER_INFO_TYPE ;

typedef struct _WSC_PROVIDER_AUDIT_INFO {
    DWORD   RecordSize;     // Size of this audit record, in bytes (includes this field)
    PVOID   Reserved;       // Reserved
    // Install Time (GMT)
    // User SID of account performing install
    // Length (in characters) of Full Path
    // Full Path of EXE performing install
} WSC_PROVIDER_AUDIT_INFO;

__control_entrypoint(DllExport)
int
WSPAPI
WSCSetProviderInfo( 
    __in LPGUID lpProviderId,
    __in WSC_PROVIDER_INFO_TYPE InfoType,
    __in_bcount(InfoSize) PBYTE Info,
    __in size_t InfoSize,
    __in DWORD Flags,
    __out LPINT lpErrno
    );

__control_entrypoint(DllExport)
int
WSPAPI
WSCGetProviderInfo( 
    __in LPGUID lpProviderId,
    __in WSC_PROVIDER_INFO_TYPE InfoType,
    __out_bcount_part(*InfoSize, *InfoSize) PBYTE Info,
    __inout size_t *InfoSize,
    __in DWORD Flags,
    __out LPINT lpErrno
    );

#if defined(_WIN64)

__control_entrypoint(DllExport)
int
WSPAPI
WSCSetProviderInfo32( 
    __in LPGUID lpProviderId,
    __in WSC_PROVIDER_INFO_TYPE InfoType,
    __in_bcount(InfoSize) PBYTE Info,
    __in size_t InfoSize,
    __in DWORD Flags,
    __out LPINT lpErrno
    );

__control_entrypoint(DllExport)
int
WSPAPI
WSCGetProviderInfo32( 
    __in LPGUID lpProviderId,
    __in WSC_PROVIDER_INFO_TYPE InfoType,
    __out_bcount_part(*InfoSize, *InfoSize) PBYTE Info,
    __inout size_t *InfoSize,
    __in DWORD Flags,
    __out LPINT lpErrno
    );

#endif // (_WIN64)

//
// App Permitted LSP Categorization APIs
//

__control_entrypoint(DllExport)
int
WSPAPI
WSCSetApplicationCategory(
    __in_ecount(PathLength) LPCWSTR Path,
    __in DWORD PathLength,
    __in_ecount_opt(ExtraLength) LPCWSTR Extra,
    __in DWORD ExtraLength,
    __in DWORD PermittedLspCategories,
    __out_opt DWORD * pPrevPermLspCat,
    __out LPINT lpErrno
    );

__control_entrypoint(DllExport)
int
WSPAPI
WSCGetApplicationCategory(
    __in_ecount(PathLength) LPCWSTR Path,
    __in DWORD PathLength,
    __in_ecount_opt(ExtraLength) LPCWSTR Extra,
    __in DWORD ExtraLength,
    __out DWORD * pPermittedLspCategories,
    __out LPINT lpErrno
    );

#endif //(_WIN32_WINNT >= 0x0600)


/*
 *  The following upcall function prototypes are only used by WinSock 2 DLL and
 *  should not be used by any service providers.
 */

BOOL
WSPAPI
WPUCloseEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUCloseSocketHandle(
    IN SOCKET s,
    OUT LPINT lpErrno
    );

WSAEVENT
WSPAPI
WPUCreateEvent(
    OUT LPINT lpErrno
    );

SOCKET
WSPAPI
WPUCreateSocketHandle(
    IN DWORD dwCatalogEntryId,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    );

__control_entrypoint(DispatchTable)
int
WSPAPI
WPUFDIsSet(
    IN SOCKET s,
    IN fd_set FAR * fdset
    );

int
WSPAPI
WPUGetProviderPath(
    IN LPGUID lpProviderId,
    __out_ecount(*lpProviderDllPathLen) WCHAR FAR * lpszProviderDllPath,
    __inout LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );

SOCKET
WSPAPI
WPUModifyIFSHandle(
    IN DWORD dwCatalogEntryId,
    IN SOCKET ProposedHandle,
    OUT LPINT lpErrno
    );

__control_entrypoint(DispatchTable)
BOOL
WSPAPI
WPUPostMessage(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

int
WSPAPI
WPUQueryBlockingCallback(
    IN DWORD dwCatalogEntryId,
    OUT LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    OUT PDWORD_PTR lpdwContext,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUQuerySocketHandleContext(
    IN SOCKET s,
    OUT PDWORD_PTR lpContext,
    OUT LPINT lpErrno
    );

__control_entrypoint(DispatchTable)
int
WSPAPI
WPUQueueApc(
    IN LPWSATHREADID lpThreadId,
    IN LPWSAUSERAPC lpfnUserApc,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUResetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUSetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

__control_entrypoint(DispatchTable)
int
WSPAPI
WPUCompleteOverlappedRequest (
    SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
);

#if(_WIN32_WINNT >= 0x0501)
__control_entrypoint(DispatchTable)
int
WSPAPI
WPUOpenCurrentThread(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

__control_entrypoint(DispatchTable)
int
WSPAPI
WPUCloseThread(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );
#endif //(_WIN32_WINNT >= 0x0501)

/*
 * Installing and uninstalling name space providers.
 */

#if(_WIN32_WINNT >= 0x0501)
/*
 * SPI and API for enumerating name space providers are
 * currently equivalent since there is no concept of a hidden
 * name space provider
 */
#define WSCEnumNameSpaceProviders WSAEnumNameSpaceProvidersW
#define LPFN_WSCENUMNAMESPACEPROVIDERS LPFN_WSAENUMNAMESPACEPROVIDERSW

#if defined(_WIN64)
INT
WSAAPI
WSCEnumNameSpaceProviders32(
    __inout LPDWORD             lpdwBufferLength,
    __out_bcount(*lpdwBufferLength) LPWSANAMESPACE_INFOW lpnspBuffer
    );
#endif
#endif //(_WIN32_WINNT >= 0x0501)

#if(_WIN32_WINNT >= 0x0600)
#define WSCEnumNameSpaceProvidersEx WSAEnumNameSpaceProvidersExW
#define LPFN_WSCENUMNAMESPACEPROVIDERSEX LPFN_WSAENUMNAMESPACEPROVIDERSEXW

#if defined(_WIN64)
INT
WSAAPI
WSCEnumNameSpaceProvidersEx32(
    __inout LPDWORD     lpdwBufferLength,
    __out_bcount(*lpdwBufferLength) LPWSANAMESPACE_INFOEXW lpnspBuffer
    );
#endif //(_WIN64)
#endif //(_WIN32_WINNT >= 0x0600)

INT
WSPAPI
WSCInstallNameSpace (
    __in LPWSTR lpszIdentifier,
    __in LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    __in IN LPGUID lpProviderId
    );

typedef
INT
(WSPAPI * LPWSCINSTALLNAMESPACE)(
    LPWSTR lpszIdentifier,
    LPWSTR lpszPathName,
    DWORD dwNameSpace,
    DWORD dwVersion,
    LPGUID lpProviderId
    );

#if(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))
INT
WSPAPI
WSCInstallNameSpace32 (
    __in LPWSTR lpszIdentifier,
    __in LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    );
#endif //(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))

INT
WSPAPI
WSCUnInstallNameSpace (
    IN LPGUID lpProviderId
    );

typedef
INT
(WSPAPI * LPWSCUNINSTALLNAMESPACE)(
    LPGUID lpProviderId
    );

#if (_WIN32_WINNT >= 0x0600 )
INT
WSPAPI
WSCInstallNameSpaceEx(
    __in LPWSTR lpszIdentifier,
    __in LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    __in LPGUID lpProviderId,
    __in LPBLOB lpProviderSpecific
    );
#endif //(defined(_WIN32_WINNT >= 0x0600)

#if(defined(_WIN64) && (_WIN32_WINNT >= 0x0600))
INT
WSPAPI
WSCInstallNameSpaceEx32(
    __in LPWSTR lpszIdentifier,
    __in LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId,
    IN LPBLOB lpProviderSpecific
    );
#endif //(defined(_WIN64) && (_WIN32_WINNT >= 0x0600))

#if(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))
INT
WSPAPI
WSCUnInstallNameSpace32 (
    IN LPGUID lpProviderId
    );
#endif //(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))

INT
WSPAPI
WSCEnableNSProvider (
    IN LPGUID lpProviderId,
    IN BOOL fEnable
    );

typedef
INT
(WSPAPI * LPWSCENABLENSPROVIDER)(
    LPGUID lpProviderId,
    BOOL fEnable
    );

#if(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))
INT
WSPAPI
WSCEnableNSProvider32 (
    IN LPGUID lpProviderId,
    IN BOOL fEnable
    );
#endif //(defined(_WIN64) && (_WIN32_WINNT >= 0x0501))

#if (_WIN32_WINNT >= 0x0600)

#if defined(_WIN64)
int WSPAPI WSCInstallProviderAndChains64_32(
#else
int WSPAPI WSCInstallProviderAndChains(
#endif
    IN LPGUID lpProviderId,
    __in const LPWSTR lpszProviderDllPath,
#if defined(_WIN64)
    __in const LPWSTR lpszProviderDllPath32,
#endif
    __in const LPWSTR lpszLspName,
    IN DWORD dwServiceFlags,
    __inout_ecount(dwNumberOfEntries) LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPDWORD lpdwCatalogEntryId OPTIONAL,
    OUT LPINT lpErrno);

#endif //(_WIN32_WINNT >= 0x0600)


/*
 * Pointers to the individual entries in the namespace proc table.
 */

typedef
INT
(WSAAPI * LPNSPCLEANUP)(
    LPGUID lpProviderId
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICEBEGIN)(
    LPGUID lpProviderId,
    LPWSAQUERYSETW lpqsRestrictions,
    LPWSASERVICECLASSINFOW lpServiceClassInfo,
    DWORD dwControlFlags,
    LPHANDLE lphLookup
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICENEXT)(
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSETW lpqsResults
    );

#if(_WIN32_WINNT >= 0x0501)
typedef
INT
(WSAAPI * LPNSPIOCTL)(
    HANDLE          hLookup,
    DWORD           dwControlCode,
    LPVOID          lpvInBuffer,
    DWORD           cbInBuffer,
    LPVOID          lpvOutBuffer,
    DWORD           cbOutBuffer,
    LPDWORD         lpcbBytesReturned,
    LPWSACOMPLETION lpCompletion,
    LPWSATHREADID   lpThreadId
    );
#endif //(_WIN32_WINNT >= 0x0501)

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICEEND)(
    HANDLE hLookup
    );

typedef
INT
(WSAAPI * LPNSPSETSERVICE)(
    LPGUID lpProviderId,
    LPWSASERVICECLASSINFOW lpServiceClassInfo,
    LPWSAQUERYSETW lpqsRegInfo,
    WSAESETSERVICEOP essOperation,
    DWORD dwControlFlags
    );

typedef
INT
(WSAAPI * LPNSPINSTALLSERVICECLASS)(
    LPGUID lpProviderId,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );

typedef
INT
(WSAAPI * LPNSPREMOVESERVICECLASS)(
    LPGUID lpProviderId,
    LPGUID lpServiceClassId
    );

typedef
INT
(WSAAPI * LPNSPGETSERVICECLASSINFO)(
    LPGUID lpProviderId,
    LPDWORD lpdwBufSize,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );

/*
 * The name space service provider procedure table.
 */

typedef struct _NSP_ROUTINE {

    /* Structure version information: */
    DWORD           cbSize;
    DWORD           dwMajorVersion;
    DWORD           dwMinorVersion;

    /* Procedure-pointer table: */

    LPNSPCLEANUP             NSPCleanup;
    LPNSPLOOKUPSERVICEBEGIN  NSPLookupServiceBegin;
    LPNSPLOOKUPSERVICENEXT   NSPLookupServiceNext;
    LPNSPLOOKUPSERVICEEND    NSPLookupServiceEnd;
    LPNSPSETSERVICE          NSPSetService;
    LPNSPINSTALLSERVICECLASS NSPInstallServiceClass;
    LPNSPREMOVESERVICECLASS  NSPRemoveServiceClass;
    LPNSPGETSERVICECLASSINFO NSPGetServiceClassInfo;

#if(_WIN32_WINNT >= 0x0501)
    // These APIs were added later, so must appear here
    // to keep the pointers in the structure in order.
    // Namespaces unaware of these APIs will set cbSize
    // to match the size of FIELD_OFFSET(NSP_ROUTINE, NSPIoctl).
    LPNSPIOCTL               NSPIoctl;
#endif //(_WIN32_WINNT >= 0x0501)

} NSP_ROUTINE, FAR * LPNSP_ROUTINE;

/*
 * Startup procedures.
 */

INT
WSAAPI
NSPStartup(
    __in LPGUID lpProviderId,
    __inout LPNSP_ROUTINE lpnspRoutines
    );

typedef
INT
(WSAAPI * LPNSPSTARTUP)(
    LPGUID lpProviderId,
    LPNSP_ROUTINE lpnspRoutines
    );

typedef
INT
(WSAAPI * LPNSPV2STARTUP)(
    LPGUID lpProviderId,
    LPVOID * ppvClientSessionArg
    );

typedef
INT
(WSAAPI * LPNSPV2CLEANUP)(
    LPGUID lpProviderId,
    LPVOID pvClientSessionArg
    );

typedef
INT
(WSAAPI * LPNSPV2LOOKUPSERVICEBEGIN)(
    LPGUID lpProviderId,
    LPWSAQUERYSET2W lpqsRestrictions,
    DWORD dwControlFlags,
    LPVOID lpvClientSessionArg,
    LPHANDLE lphLookup
    );

typedef
VOID
(WSAAPI * LPNSPV2LOOKUPSERVICENEXTEX)(
    HANDLE hAsyncCall,
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSET2W lpqsResults
    );

typedef
INT
(WSAAPI * LPNSPV2LOOKUPSERVICEEND)(
    HANDLE hLookup
    );

typedef
VOID
(WSAAPI * LPNSPV2SETSERVICEEX)(
    HANDLE hAsyncCall,
    LPGUID lpProviderId,
    LPWSAQUERYSET2W lpqsRegInfo,
    WSAESETSERVICEOP essOperation,
    DWORD dwControlFlags,
    LPVOID lpvClientSessionArg 
    );

typedef
VOID
(WSAAPI * LPNSPV2CLIENTSESSIONRUNDOWN)(
    LPGUID lpProviderId,
    LPVOID pvClientSessionArg
    );

typedef struct _NSPV2_ROUTINE {  
    DWORD cbSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    LPNSPV2STARTUP NSPv2Startup;
    LPNSPV2CLEANUP NSPv2Cleanup;
    LPNSPV2LOOKUPSERVICEBEGIN NSPv2LookupServiceBegin;  
    LPNSPV2LOOKUPSERVICENEXTEX NSPv2LookupServiceNextEx;
    LPNSPV2LOOKUPSERVICEEND NSPv2LookupServiceEnd;  
    LPNSPV2SETSERVICEEX NSPv2SetServiceEx;
    LPNSPV2CLIENTSESSIONRUNDOWN NSPv2ClientSessionRundown;
} NSPV2_ROUTINE, *PNSPV2_ROUTINE, *LPNSPV2_ROUTINE;
typedef const NSPV2_ROUTINE * PCNSPV2_ROUTINE, * LPCNSPV2_ROUTINE;

#if(_WIN32_WINNT >= 0x0600)

INT WSAAPI WSAAdvertiseProvider(
        __in                const GUID *                    puuidProviderId,
        __in                const LPCNSPV2_ROUTINE          pNSPv2Routine);

INT WSAAPI WSAUnadvertiseProvider(
        __in                const GUID *                    puuidProviderId);

INT WSAAPI WSAProviderCompleteAsyncCall(
        __in                HANDLE                          hAsyncCall,
        __in                INT                             iRetCode);

#endif //(_WIN32_WINNT >= 0x0600)

#ifdef __cplusplus
}
#endif

#if !defined(_WIN64)
#include <poppack.h>
#endif

#endif  /* _WINSOCK2SPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsddisco.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wsddisco.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsddisco_h__
#define __wsddisco_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSDiscoveryProvider_FWD_DEFINED__
#define __IWSDiscoveryProvider_FWD_DEFINED__
typedef interface IWSDiscoveryProvider IWSDiscoveryProvider;
#endif 	/* __IWSDiscoveryProvider_FWD_DEFINED__ */


#ifndef __IWSDiscoveryProviderNotify_FWD_DEFINED__
#define __IWSDiscoveryProviderNotify_FWD_DEFINED__
typedef interface IWSDiscoveryProviderNotify IWSDiscoveryProviderNotify;
#endif 	/* __IWSDiscoveryProviderNotify_FWD_DEFINED__ */


#ifndef __IWSDiscoveredService_FWD_DEFINED__
#define __IWSDiscoveredService_FWD_DEFINED__
typedef interface IWSDiscoveredService IWSDiscoveredService;
#endif 	/* __IWSDiscoveredService_FWD_DEFINED__ */


#ifndef __IWSDiscoveryPublisher_FWD_DEFINED__
#define __IWSDiscoveryPublisher_FWD_DEFINED__
typedef interface IWSDiscoveryPublisher IWSDiscoveryPublisher;
#endif 	/* __IWSDiscoveryPublisher_FWD_DEFINED__ */


#ifndef __IWSDiscoveryPublisherNotify_FWD_DEFINED__
#define __IWSDiscoveryPublisherNotify_FWD_DEFINED__
typedef interface IWSDiscoveryPublisherNotify IWSDiscoveryPublisherNotify;
#endif 	/* __IWSDiscoveryPublisherNotify_FWD_DEFINED__ */


#ifndef __IWSDScopeMatchingRule_FWD_DEFINED__
#define __IWSDScopeMatchingRule_FWD_DEFINED__
typedef interface IWSDScopeMatchingRule IWSDScopeMatchingRule;
#endif 	/* __IWSDScopeMatchingRule_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "wsdxmldom.h"
#include "wsdtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsddisco_0000_0000 */
/* [local] */ 








HRESULT WINAPI
WSDCreateDiscoveryProvider(
    IWSDXMLContext* pContext,
    IWSDiscoveryProvider** ppProvider);


extern RPC_IF_HANDLE __MIDL_itf_wsddisco_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsddisco_0000_0000_v0_0_s_ifspec;

#ifndef __IWSDiscoveryProvider_INTERFACE_DEFINED__
#define __IWSDiscoveryProvider_INTERFACE_DEFINED__

/* interface IWSDiscoveryProvider */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDiscoveryProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8FFC8E55-F0EB-480F-88B7-B435DD281D45")
    IWSDiscoveryProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAddressFamily( 
            /* [in] */ DWORD dwAddressFamily) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ IWSDiscoveryProviderNotify *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SearchById( 
            /* [in] */ LPCWSTR pszId,
            /* [optional][in] */ LPCWSTR pszTag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SearchByAddress( 
            /* [in] */ LPCWSTR pszAddress,
            /* [optional][in] */ LPCWSTR pszTag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SearchByType( 
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ LPCWSTR pszMatchBy,
            /* [optional][in] */ LPCWSTR pszTag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXMLContext( 
            /* [out] */ IWSDXMLContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDiscoveryProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDiscoveryProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDiscoveryProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDiscoveryProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAddressFamily )( 
            IWSDiscoveryProvider * This,
            /* [in] */ DWORD dwAddressFamily);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IWSDiscoveryProvider * This,
            /* [in] */ IWSDiscoveryProviderNotify *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IWSDiscoveryProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SearchById )( 
            IWSDiscoveryProvider * This,
            /* [in] */ LPCWSTR pszId,
            /* [optional][in] */ LPCWSTR pszTag);
        
        HRESULT ( STDMETHODCALLTYPE *SearchByAddress )( 
            IWSDiscoveryProvider * This,
            /* [in] */ LPCWSTR pszAddress,
            /* [optional][in] */ LPCWSTR pszTag);
        
        HRESULT ( STDMETHODCALLTYPE *SearchByType )( 
            IWSDiscoveryProvider * This,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ LPCWSTR pszMatchBy,
            /* [optional][in] */ LPCWSTR pszTag);
        
        HRESULT ( STDMETHODCALLTYPE *GetXMLContext )( 
            IWSDiscoveryProvider * This,
            /* [out] */ IWSDXMLContext **ppContext);
        
        END_INTERFACE
    } IWSDiscoveryProviderVtbl;

    interface IWSDiscoveryProvider
    {
        CONST_VTBL struct IWSDiscoveryProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDiscoveryProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDiscoveryProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDiscoveryProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDiscoveryProvider_SetAddressFamily(This,dwAddressFamily)	\
    ( (This)->lpVtbl -> SetAddressFamily(This,dwAddressFamily) ) 

#define IWSDiscoveryProvider_Attach(This,pSink)	\
    ( (This)->lpVtbl -> Attach(This,pSink) ) 

#define IWSDiscoveryProvider_Detach(This)	\
    ( (This)->lpVtbl -> Detach(This) ) 

#define IWSDiscoveryProvider_SearchById(This,pszId,pszTag)	\
    ( (This)->lpVtbl -> SearchById(This,pszId,pszTag) ) 

#define IWSDiscoveryProvider_SearchByAddress(This,pszAddress,pszTag)	\
    ( (This)->lpVtbl -> SearchByAddress(This,pszAddress,pszTag) ) 

#define IWSDiscoveryProvider_SearchByType(This,pTypesList,pScopesList,pszMatchBy,pszTag)	\
    ( (This)->lpVtbl -> SearchByType(This,pTypesList,pScopesList,pszMatchBy,pszTag) ) 

#define IWSDiscoveryProvider_GetXMLContext(This,ppContext)	\
    ( (This)->lpVtbl -> GetXMLContext(This,ppContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDiscoveryProvider_INTERFACE_DEFINED__ */


#ifndef __IWSDiscoveryProviderNotify_INTERFACE_DEFINED__
#define __IWSDiscoveryProviderNotify_INTERFACE_DEFINED__

/* interface IWSDiscoveryProviderNotify */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDiscoveryProviderNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73ee3ced-b6e6-4329-a546-3e8ad46563d2")
    IWSDiscoveryProviderNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IWSDiscoveredService *pService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ IWSDiscoveredService *pService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SearchFailed( 
            /* [in] */ HRESULT hr,
            /* [optional][in] */ LPCWSTR pszTag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SearchComplete( 
            /* [optional][in] */ LPCWSTR pszTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDiscoveryProviderNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDiscoveryProviderNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDiscoveryProviderNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDiscoveryProviderNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IWSDiscoveryProviderNotify * This,
            /* [in] */ IWSDiscoveredService *pService);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWSDiscoveryProviderNotify * This,
            /* [in] */ IWSDiscoveredService *pService);
        
        HRESULT ( STDMETHODCALLTYPE *SearchFailed )( 
            IWSDiscoveryProviderNotify * This,
            /* [in] */ HRESULT hr,
            /* [optional][in] */ LPCWSTR pszTag);
        
        HRESULT ( STDMETHODCALLTYPE *SearchComplete )( 
            IWSDiscoveryProviderNotify * This,
            /* [optional][in] */ LPCWSTR pszTag);
        
        END_INTERFACE
    } IWSDiscoveryProviderNotifyVtbl;

    interface IWSDiscoveryProviderNotify
    {
        CONST_VTBL struct IWSDiscoveryProviderNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDiscoveryProviderNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDiscoveryProviderNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDiscoveryProviderNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDiscoveryProviderNotify_Add(This,pService)	\
    ( (This)->lpVtbl -> Add(This,pService) ) 

#define IWSDiscoveryProviderNotify_Remove(This,pService)	\
    ( (This)->lpVtbl -> Remove(This,pService) ) 

#define IWSDiscoveryProviderNotify_SearchFailed(This,hr,pszTag)	\
    ( (This)->lpVtbl -> SearchFailed(This,hr,pszTag) ) 

#define IWSDiscoveryProviderNotify_SearchComplete(This,pszTag)	\
    ( (This)->lpVtbl -> SearchComplete(This,pszTag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDiscoveryProviderNotify_INTERFACE_DEFINED__ */


#ifndef __IWSDiscoveredService_INTERFACE_DEFINED__
#define __IWSDiscoveredService_INTERFACE_DEFINED__

/* interface IWSDiscoveredService */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDiscoveredService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4BAD8A3B-B374-4420-9632-AAC945B374AA")
    IWSDiscoveredService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEndpointReference( 
            /* [out] */ WSD_ENDPOINT_REFERENCE **ppEndpointReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypes( 
            /* [out] */ WSD_NAME_LIST **ppTypesList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopes( 
            /* [out] */ WSD_URI_LIST **ppScopesList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXAddrs( 
            /* [out] */ WSD_URI_LIST **ppXAddrsList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetadataVersion( 
            /* [out] */ ULONGLONG *pullMetadataVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedDiscoXML( 
            /* [out] */ WSDXML_ELEMENT **ppHeaderAny,
            /* [out] */ WSDXML_ELEMENT **ppBodyAny) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProbeResolveTag( 
            /* [out] */ LPCWSTR *ppszTag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteTransportAddress( 
            /* [out] */ LPCWSTR *ppszRemoteTransportAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalTransportAddress( 
            /* [out] */ LPCWSTR *ppszLocalTransportAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalInterfaceGUID( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInstanceId( 
            /* [out] */ ULONGLONG *pullInstanceId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDiscoveredServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDiscoveredService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDiscoveredService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDiscoveredService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpointReference )( 
            IWSDiscoveredService * This,
            /* [out] */ WSD_ENDPOINT_REFERENCE **ppEndpointReference);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypes )( 
            IWSDiscoveredService * This,
            /* [out] */ WSD_NAME_LIST **ppTypesList);
        
        HRESULT ( STDMETHODCALLTYPE *GetScopes )( 
            IWSDiscoveredService * This,
            /* [out] */ WSD_URI_LIST **ppScopesList);
        
        HRESULT ( STDMETHODCALLTYPE *GetXAddrs )( 
            IWSDiscoveredService * This,
            /* [out] */ WSD_URI_LIST **ppXAddrsList);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataVersion )( 
            IWSDiscoveredService * This,
            /* [out] */ ULONGLONG *pullMetadataVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedDiscoXML )( 
            IWSDiscoveredService * This,
            /* [out] */ WSDXML_ELEMENT **ppHeaderAny,
            /* [out] */ WSDXML_ELEMENT **ppBodyAny);
        
        HRESULT ( STDMETHODCALLTYPE *GetProbeResolveTag )( 
            IWSDiscoveredService * This,
            /* [out] */ LPCWSTR *ppszTag);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteTransportAddress )( 
            IWSDiscoveredService * This,
            /* [out] */ LPCWSTR *ppszRemoteTransportAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalTransportAddress )( 
            IWSDiscoveredService * This,
            /* [out] */ LPCWSTR *ppszLocalTransportAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalInterfaceGUID )( 
            IWSDiscoveredService * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetInstanceId )( 
            IWSDiscoveredService * This,
            /* [out] */ ULONGLONG *pullInstanceId);
        
        END_INTERFACE
    } IWSDiscoveredServiceVtbl;

    interface IWSDiscoveredService
    {
        CONST_VTBL struct IWSDiscoveredServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDiscoveredService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDiscoveredService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDiscoveredService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDiscoveredService_GetEndpointReference(This,ppEndpointReference)	\
    ( (This)->lpVtbl -> GetEndpointReference(This,ppEndpointReference) ) 

#define IWSDiscoveredService_GetTypes(This,ppTypesList)	\
    ( (This)->lpVtbl -> GetTypes(This,ppTypesList) ) 

#define IWSDiscoveredService_GetScopes(This,ppScopesList)	\
    ( (This)->lpVtbl -> GetScopes(This,ppScopesList) ) 

#define IWSDiscoveredService_GetXAddrs(This,ppXAddrsList)	\
    ( (This)->lpVtbl -> GetXAddrs(This,ppXAddrsList) ) 

#define IWSDiscoveredService_GetMetadataVersion(This,pullMetadataVersion)	\
    ( (This)->lpVtbl -> GetMetadataVersion(This,pullMetadataVersion) ) 

#define IWSDiscoveredService_GetExtendedDiscoXML(This,ppHeaderAny,ppBodyAny)	\
    ( (This)->lpVtbl -> GetExtendedDiscoXML(This,ppHeaderAny,ppBodyAny) ) 

#define IWSDiscoveredService_GetProbeResolveTag(This,ppszTag)	\
    ( (This)->lpVtbl -> GetProbeResolveTag(This,ppszTag) ) 

#define IWSDiscoveredService_GetRemoteTransportAddress(This,ppszRemoteTransportAddress)	\
    ( (This)->lpVtbl -> GetRemoteTransportAddress(This,ppszRemoteTransportAddress) ) 

#define IWSDiscoveredService_GetLocalTransportAddress(This,ppszLocalTransportAddress)	\
    ( (This)->lpVtbl -> GetLocalTransportAddress(This,ppszLocalTransportAddress) ) 

#define IWSDiscoveredService_GetLocalInterfaceGUID(This,pGuid)	\
    ( (This)->lpVtbl -> GetLocalInterfaceGUID(This,pGuid) ) 

#define IWSDiscoveredService_GetInstanceId(This,pullInstanceId)	\
    ( (This)->lpVtbl -> GetInstanceId(This,pullInstanceId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDiscoveredService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wsddisco_0000_0003 */
/* [local] */ 

HRESULT WINAPI
WSDCreateDiscoveryPublisher(
    IWSDXMLContext* pContext,
    IWSDiscoveryPublisher** ppPublisher);


extern RPC_IF_HANDLE __MIDL_itf_wsddisco_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsddisco_0000_0003_v0_0_s_ifspec;

#ifndef __IWSDiscoveryPublisher_INTERFACE_DEFINED__
#define __IWSDiscoveryPublisher_INTERFACE_DEFINED__

/* interface IWSDiscoveryPublisher */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDiscoveryPublisher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE01E1A8-3FF9-4148-8116-057CC616FE13")
    IWSDiscoveryPublisher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAddressFamily( 
            /* [in] */ DWORD dwAddressFamily) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterNotificationSink( 
            /* [in] */ IWSDiscoveryPublisherNotify *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterNotificationSink( 
            /* [in] */ IWSDiscoveryPublisherNotify *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Publish( 
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnPublish( 
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchProbe( 
            /* [in] */ const WSD_SOAP_MESSAGE *pProbeMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchResolve( 
            /* [in] */ const WSD_SOAP_MESSAGE *pResolveMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PublishEx( 
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList,
            /* [optional][in] */ const WSDXML_ELEMENT *pHeaderAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pReferenceParameterAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pPolicyAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pEndpointReferenceAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchProbeEx( 
            /* [in] */ const WSD_SOAP_MESSAGE *pProbeMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList,
            /* [optional][in] */ const WSDXML_ELEMENT *pHeaderAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pReferenceParameterAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pPolicyAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pEndpointReferenceAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchResolveEx( 
            /* [in] */ const WSD_SOAP_MESSAGE *pResolveMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList,
            /* [optional][in] */ const WSDXML_ELEMENT *pHeaderAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pReferenceParameterAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pPolicyAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pEndpointReferenceAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterScopeMatchingRule( 
            /* [in] */ IWSDScopeMatchingRule *pScopeMatchingRule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterScopeMatchingRule( 
            /* [in] */ IWSDScopeMatchingRule *pScopeMatchingRule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXMLContext( 
            /* [out] */ IWSDXMLContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDiscoveryPublisherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDiscoveryPublisher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDiscoveryPublisher * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAddressFamily )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ DWORD dwAddressFamily);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNotificationSink )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ IWSDiscoveryPublisherNotify *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterNotificationSink )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ IWSDiscoveryPublisherNotify *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *Publish )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList);
        
        HRESULT ( STDMETHODCALLTYPE *UnPublish )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny);
        
        HRESULT ( STDMETHODCALLTYPE *MatchProbe )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ const WSD_SOAP_MESSAGE *pProbeMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList);
        
        HRESULT ( STDMETHODCALLTYPE *MatchResolve )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ const WSD_SOAP_MESSAGE *pResolveMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList);
        
        HRESULT ( STDMETHODCALLTYPE *PublishEx )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList,
            /* [optional][in] */ const WSDXML_ELEMENT *pHeaderAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pReferenceParameterAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pPolicyAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pEndpointReferenceAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny);
        
        HRESULT ( STDMETHODCALLTYPE *MatchProbeEx )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ const WSD_SOAP_MESSAGE *pProbeMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList,
            /* [optional][in] */ const WSDXML_ELEMENT *pHeaderAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pReferenceParameterAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pPolicyAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pEndpointReferenceAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny);
        
        HRESULT ( STDMETHODCALLTYPE *MatchResolveEx )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ const WSD_SOAP_MESSAGE *pResolveMessage,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [in] */ LPCWSTR pszId,
            /* [in] */ ULONGLONG ullMetadataVersion,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ ULONGLONG ullMessageNumber,
            /* [optional][in] */ LPCWSTR pszSessionId,
            /* [optional][in] */ const WSD_NAME_LIST *pTypesList,
            /* [optional][in] */ const WSD_URI_LIST *pScopesList,
            /* [optional][in] */ const WSD_URI_LIST *pXAddrsList,
            /* [optional][in] */ const WSDXML_ELEMENT *pHeaderAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pReferenceParameterAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pPolicyAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pEndpointReferenceAny,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterScopeMatchingRule )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ IWSDScopeMatchingRule *pScopeMatchingRule);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterScopeMatchingRule )( 
            IWSDiscoveryPublisher * This,
            /* [in] */ IWSDScopeMatchingRule *pScopeMatchingRule);
        
        HRESULT ( STDMETHODCALLTYPE *GetXMLContext )( 
            IWSDiscoveryPublisher * This,
            /* [out] */ IWSDXMLContext **ppContext);
        
        END_INTERFACE
    } IWSDiscoveryPublisherVtbl;

    interface IWSDiscoveryPublisher
    {
        CONST_VTBL struct IWSDiscoveryPublisherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDiscoveryPublisher_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDiscoveryPublisher_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDiscoveryPublisher_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDiscoveryPublisher_SetAddressFamily(This,dwAddressFamily)	\
    ( (This)->lpVtbl -> SetAddressFamily(This,dwAddressFamily) ) 

#define IWSDiscoveryPublisher_RegisterNotificationSink(This,pSink)	\
    ( (This)->lpVtbl -> RegisterNotificationSink(This,pSink) ) 

#define IWSDiscoveryPublisher_UnRegisterNotificationSink(This,pSink)	\
    ( (This)->lpVtbl -> UnRegisterNotificationSink(This,pSink) ) 

#define IWSDiscoveryPublisher_Publish(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList)	\
    ( (This)->lpVtbl -> Publish(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList) ) 

#define IWSDiscoveryPublisher_UnPublish(This,pszId,ullInstanceId,ullMessageNumber,pszSessionId,pAny)	\
    ( (This)->lpVtbl -> UnPublish(This,pszId,ullInstanceId,ullMessageNumber,pszSessionId,pAny) ) 

#define IWSDiscoveryPublisher_MatchProbe(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList)	\
    ( (This)->lpVtbl -> MatchProbe(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList) ) 

#define IWSDiscoveryPublisher_MatchResolve(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList)	\
    ( (This)->lpVtbl -> MatchResolve(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList) ) 

#define IWSDiscoveryPublisher_PublishEx(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList,pHeaderAny,pReferenceParameterAny,pPolicyAny,pEndpointReferenceAny,pAny)	\
    ( (This)->lpVtbl -> PublishEx(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList,pHeaderAny,pReferenceParameterAny,pPolicyAny,pEndpointReferenceAny,pAny) ) 

#define IWSDiscoveryPublisher_MatchProbeEx(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList,pHeaderAny,pReferenceParameterAny,pPolicyAny,pEndpointReferenceAny,pAny)	\
    ( (This)->lpVtbl -> MatchProbeEx(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList,pHeaderAny,pReferenceParameterAny,pPolicyAny,pEndpointReferenceAny,pAny) ) 

#define IWSDiscoveryPublisher_MatchResolveEx(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList,pHeaderAny,pReferenceParameterAny,pPolicyAny,pEndpointReferenceAny,pAny)	\
    ( (This)->lpVtbl -> MatchResolveEx(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pszSessionId,pTypesList,pScopesList,pXAddrsList,pHeaderAny,pReferenceParameterAny,pPolicyAny,pEndpointReferenceAny,pAny) ) 

#define IWSDiscoveryPublisher_RegisterScopeMatchingRule(This,pScopeMatchingRule)	\
    ( (This)->lpVtbl -> RegisterScopeMatchingRule(This,pScopeMatchingRule) ) 

#define IWSDiscoveryPublisher_UnRegisterScopeMatchingRule(This,pScopeMatchingRule)	\
    ( (This)->lpVtbl -> UnRegisterScopeMatchingRule(This,pScopeMatchingRule) ) 

#define IWSDiscoveryPublisher_GetXMLContext(This,ppContext)	\
    ( (This)->lpVtbl -> GetXMLContext(This,ppContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDiscoveryPublisher_INTERFACE_DEFINED__ */


#ifndef __IWSDiscoveryPublisherNotify_INTERFACE_DEFINED__
#define __IWSDiscoveryPublisherNotify_INTERFACE_DEFINED__

/* interface IWSDiscoveryPublisherNotify */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDiscoveryPublisherNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e67651b0-337a-4b3c-9758-733388568251")
    IWSDiscoveryPublisherNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProbeHandler( 
            /* [in] */ const WSD_SOAP_MESSAGE *pSoap,
            /* [in] */ IWSDMessageParameters *pMessageParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveHandler( 
            /* [in] */ const WSD_SOAP_MESSAGE *pSoap,
            /* [in] */ IWSDMessageParameters *pMessageParameters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDiscoveryPublisherNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDiscoveryPublisherNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDiscoveryPublisherNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDiscoveryPublisherNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProbeHandler )( 
            IWSDiscoveryPublisherNotify * This,
            /* [in] */ const WSD_SOAP_MESSAGE *pSoap,
            /* [in] */ IWSDMessageParameters *pMessageParameters);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveHandler )( 
            IWSDiscoveryPublisherNotify * This,
            /* [in] */ const WSD_SOAP_MESSAGE *pSoap,
            /* [in] */ IWSDMessageParameters *pMessageParameters);
        
        END_INTERFACE
    } IWSDiscoveryPublisherNotifyVtbl;

    interface IWSDiscoveryPublisherNotify
    {
        CONST_VTBL struct IWSDiscoveryPublisherNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDiscoveryPublisherNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDiscoveryPublisherNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDiscoveryPublisherNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDiscoveryPublisherNotify_ProbeHandler(This,pSoap,pMessageParameters)	\
    ( (This)->lpVtbl -> ProbeHandler(This,pSoap,pMessageParameters) ) 

#define IWSDiscoveryPublisherNotify_ResolveHandler(This,pSoap,pMessageParameters)	\
    ( (This)->lpVtbl -> ResolveHandler(This,pSoap,pMessageParameters) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDiscoveryPublisherNotify_INTERFACE_DEFINED__ */


#ifndef __IWSDScopeMatchingRule_INTERFACE_DEFINED__
#define __IWSDScopeMatchingRule_INTERFACE_DEFINED__

/* interface IWSDScopeMatchingRule */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDScopeMatchingRule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fcafe424-fef5-481a-bd9f-33ce0574256f")
    IWSDScopeMatchingRule : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetScopeRule( 
            /* [out] */ LPCWSTR *ppszScopeMatchingRule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchScopes( 
            /* [in] */ LPCWSTR pszScope1,
            /* [in] */ LPCWSTR pszScope2,
            /* [out] */ BOOL *pfMatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDScopeMatchingRuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDScopeMatchingRule * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDScopeMatchingRule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDScopeMatchingRule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetScopeRule )( 
            IWSDScopeMatchingRule * This,
            /* [out] */ LPCWSTR *ppszScopeMatchingRule);
        
        HRESULT ( STDMETHODCALLTYPE *MatchScopes )( 
            IWSDScopeMatchingRule * This,
            /* [in] */ LPCWSTR pszScope1,
            /* [in] */ LPCWSTR pszScope2,
            /* [out] */ BOOL *pfMatch);
        
        END_INTERFACE
    } IWSDScopeMatchingRuleVtbl;

    interface IWSDScopeMatchingRule
    {
        CONST_VTBL struct IWSDScopeMatchingRuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDScopeMatchingRule_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDScopeMatchingRule_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDScopeMatchingRule_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDScopeMatchingRule_GetScopeRule(This,ppszScopeMatchingRule)	\
    ( (This)->lpVtbl -> GetScopeRule(This,ppszScopeMatchingRule) ) 

#define IWSDScopeMatchingRule_MatchScopes(This,pszScope1,pszScope2,pfMatch)	\
    ( (This)->lpVtbl -> MatchScopes(This,pszScope1,pszScope2,pfMatch) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDScopeMatchingRule_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdclient.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wsdclient.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsdclient_h__
#define __wsdclient_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSDEndpointProxy_FWD_DEFINED__
#define __IWSDEndpointProxy_FWD_DEFINED__
typedef interface IWSDEndpointProxy IWSDEndpointProxy;
#endif 	/* __IWSDEndpointProxy_FWD_DEFINED__ */


#ifndef __IWSDMetadataExchange_FWD_DEFINED__
#define __IWSDMetadataExchange_FWD_DEFINED__
typedef interface IWSDMetadataExchange IWSDMetadataExchange;
#endif 	/* __IWSDMetadataExchange_FWD_DEFINED__ */


#ifndef __IWSDServiceProxy_FWD_DEFINED__
#define __IWSDServiceProxy_FWD_DEFINED__
typedef interface IWSDServiceProxy IWSDServiceProxy;
#endif 	/* __IWSDServiceProxy_FWD_DEFINED__ */


#ifndef __IWSDDeviceProxy_FWD_DEFINED__
#define __IWSDDeviceProxy_FWD_DEFINED__
typedef interface IWSDDeviceProxy IWSDDeviceProxy;
#endif 	/* __IWSDDeviceProxy_FWD_DEFINED__ */


#ifndef __IWSDAsyncResult_FWD_DEFINED__
#define __IWSDAsyncResult_FWD_DEFINED__
typedef interface IWSDAsyncResult IWSDAsyncResult;
#endif 	/* __IWSDAsyncResult_FWD_DEFINED__ */


#ifndef __IWSDAsyncCallback_FWD_DEFINED__
#define __IWSDAsyncCallback_FWD_DEFINED__
typedef interface IWSDAsyncCallback IWSDAsyncCallback;
#endif 	/* __IWSDAsyncCallback_FWD_DEFINED__ */


#ifndef __IWSDEventingStatus_FWD_DEFINED__
#define __IWSDEventingStatus_FWD_DEFINED__
typedef interface IWSDEventingStatus IWSDEventingStatus;
#endif 	/* __IWSDEventingStatus_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wsdxmldom.h"
#include "wsdtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsdclient_0000_0000 */
/* [local] */ 











HRESULT WINAPI
WSDCreateDeviceProxy(
    __in LPCWSTR pszDeviceId,
    __in LPCWSTR pszLocalId,
    IWSDXMLContext* pContext,
    IWSDDeviceProxy** ppDeviceProxy);
HRESULT WINAPI
WSDCreateDeviceProxyAdvanced(
    __in LPCWSTR pszDeviceId,
    IWSDAddress* pDeviceAddress,
    __in LPCWSTR pszLocalId,
    IWSDXMLContext* pContext,
    IWSDDeviceProxy** ppDeviceProxy);


extern RPC_IF_HANDLE __MIDL_itf_wsdclient_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdclient_0000_0000_v0_0_s_ifspec;

#ifndef __IWSDEndpointProxy_INTERFACE_DEFINED__
#define __IWSDEndpointProxy_INTERFACE_DEFINED__

/* interface IWSDEndpointProxy */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDEndpointProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1860d430-b24c-4975-9f90-dbb39baa24ec")
    IWSDEndpointProxy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendOneWayRequest( 
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendTwoWayRequest( 
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation,
            /* [optional][in] */ const WSD_SYNCHRONOUS_RESPONSE_CONTEXT *pResponseContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendTwoWayRequestAsync( 
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation,
            /* [in] */ IUnknown *pAsyncState,
            /* [in] */ IWSDAsyncCallback *pCallback,
            /* [out] */ IWSDAsyncResult **pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortAsyncOperation( 
            /* [in] */ IWSDAsyncResult *pAsyncResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessFault( 
            /* [in] */ const WSD_SOAP_FAULT *pFault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ LPCWSTR *ppszErrorInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFaultInfo( 
            /* [out] */ WSD_SOAP_FAULT **ppFault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDEndpointProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDEndpointProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDEndpointProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDEndpointProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendOneWayRequest )( 
            IWSDEndpointProxy * This,
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation);
        
        HRESULT ( STDMETHODCALLTYPE *SendTwoWayRequest )( 
            IWSDEndpointProxy * This,
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation,
            /* [optional][in] */ const WSD_SYNCHRONOUS_RESPONSE_CONTEXT *pResponseContext);
        
        HRESULT ( STDMETHODCALLTYPE *SendTwoWayRequestAsync )( 
            IWSDEndpointProxy * This,
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation,
            /* [in] */ IUnknown *pAsyncState,
            /* [in] */ IWSDAsyncCallback *pCallback,
            /* [out] */ IWSDAsyncResult **pResult);
        
        HRESULT ( STDMETHODCALLTYPE *AbortAsyncOperation )( 
            IWSDEndpointProxy * This,
            /* [in] */ IWSDAsyncResult *pAsyncResult);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessFault )( 
            IWSDEndpointProxy * This,
            /* [in] */ const WSD_SOAP_FAULT *pFault);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IWSDEndpointProxy * This,
            /* [out] */ LPCWSTR *ppszErrorInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetFaultInfo )( 
            IWSDEndpointProxy * This,
            /* [out] */ WSD_SOAP_FAULT **ppFault);
        
        END_INTERFACE
    } IWSDEndpointProxyVtbl;

    interface IWSDEndpointProxy
    {
        CONST_VTBL struct IWSDEndpointProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDEndpointProxy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDEndpointProxy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDEndpointProxy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDEndpointProxy_SendOneWayRequest(This,pBody,pOperation)	\
    ( (This)->lpVtbl -> SendOneWayRequest(This,pBody,pOperation) ) 

#define IWSDEndpointProxy_SendTwoWayRequest(This,pBody,pOperation,pResponseContext)	\
    ( (This)->lpVtbl -> SendTwoWayRequest(This,pBody,pOperation,pResponseContext) ) 

#define IWSDEndpointProxy_SendTwoWayRequestAsync(This,pBody,pOperation,pAsyncState,pCallback,pResult)	\
    ( (This)->lpVtbl -> SendTwoWayRequestAsync(This,pBody,pOperation,pAsyncState,pCallback,pResult) ) 

#define IWSDEndpointProxy_AbortAsyncOperation(This,pAsyncResult)	\
    ( (This)->lpVtbl -> AbortAsyncOperation(This,pAsyncResult) ) 

#define IWSDEndpointProxy_ProcessFault(This,pFault)	\
    ( (This)->lpVtbl -> ProcessFault(This,pFault) ) 

#define IWSDEndpointProxy_GetErrorInfo(This,ppszErrorInfo)	\
    ( (This)->lpVtbl -> GetErrorInfo(This,ppszErrorInfo) ) 

#define IWSDEndpointProxy_GetFaultInfo(This,ppFault)	\
    ( (This)->lpVtbl -> GetFaultInfo(This,ppFault) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDEndpointProxy_INTERFACE_DEFINED__ */


#ifndef __IWSDMetadataExchange_INTERFACE_DEFINED__
#define __IWSDMetadataExchange_INTERFACE_DEFINED__

/* interface IWSDMetadataExchange */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDMetadataExchange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06996d57-1d67-4928-9307-3d7833fdb846")
    IWSDMetadataExchange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadata( 
            /* [out] */ WSD_METADATA_SECTION_LIST **MetadataOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDMetadataExchangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDMetadataExchange * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDMetadataExchange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDMetadataExchange * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadata )( 
            IWSDMetadataExchange * This,
            /* [out] */ WSD_METADATA_SECTION_LIST **MetadataOut);
        
        END_INTERFACE
    } IWSDMetadataExchangeVtbl;

    interface IWSDMetadataExchange
    {
        CONST_VTBL struct IWSDMetadataExchangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDMetadataExchange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDMetadataExchange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDMetadataExchange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDMetadataExchange_GetMetadata(This,MetadataOut)	\
    ( (This)->lpVtbl -> GetMetadata(This,MetadataOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDMetadataExchange_INTERFACE_DEFINED__ */


#ifndef __IWSDServiceProxy_INTERFACE_DEFINED__
#define __IWSDServiceProxy_INTERFACE_DEFINED__

/* interface IWSDServiceProxy */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDServiceProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d4c7fb9c-03ab-4175-9d67-094fafebf487")
    IWSDServiceProxy : public IWSDMetadataExchange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginGetMetadata( 
            /* [out] */ IWSDAsyncResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndGetMetadata( 
            /* [in] */ IWSDAsyncResult *pResult,
            /* [out] */ WSD_METADATA_SECTION_LIST **ppMetadata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceMetadata( 
            /* [out] */ WSD_SERVICE_METADATA **ppServiceMetadata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubscribeToOperation( 
            /* [in] */ const WSD_OPERATION *pOperation,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ const WSDXML_ELEMENT *pAny,
            /* [out] */ WSDXML_ELEMENT **ppAny) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnsubscribeToOperation( 
            /* [in] */ const WSD_OPERATION *pOperation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventingStatusCallback( 
            /* [optional][in] */ IWSDEventingStatus *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndpointProxy( 
            /* [out] */ IWSDEndpointProxy **ppProxy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDServiceProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDServiceProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDServiceProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDServiceProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadata )( 
            IWSDServiceProxy * This,
            /* [out] */ WSD_METADATA_SECTION_LIST **MetadataOut);
        
        HRESULT ( STDMETHODCALLTYPE *BeginGetMetadata )( 
            IWSDServiceProxy * This,
            /* [out] */ IWSDAsyncResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *EndGetMetadata )( 
            IWSDServiceProxy * This,
            /* [in] */ IWSDAsyncResult *pResult,
            /* [out] */ WSD_METADATA_SECTION_LIST **ppMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceMetadata )( 
            IWSDServiceProxy * This,
            /* [out] */ WSD_SERVICE_METADATA **ppServiceMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *SubscribeToOperation )( 
            IWSDServiceProxy * This,
            /* [in] */ const WSD_OPERATION *pOperation,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ const WSDXML_ELEMENT *pAny,
            /* [out] */ WSDXML_ELEMENT **ppAny);
        
        HRESULT ( STDMETHODCALLTYPE *UnsubscribeToOperation )( 
            IWSDServiceProxy * This,
            /* [in] */ const WSD_OPERATION *pOperation);
        
        HRESULT ( STDMETHODCALLTYPE *SetEventingStatusCallback )( 
            IWSDServiceProxy * This,
            /* [optional][in] */ IWSDEventingStatus *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpointProxy )( 
            IWSDServiceProxy * This,
            /* [out] */ IWSDEndpointProxy **ppProxy);
        
        END_INTERFACE
    } IWSDServiceProxyVtbl;

    interface IWSDServiceProxy
    {
        CONST_VTBL struct IWSDServiceProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDServiceProxy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDServiceProxy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDServiceProxy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDServiceProxy_GetMetadata(This,MetadataOut)	\
    ( (This)->lpVtbl -> GetMetadata(This,MetadataOut) ) 


#define IWSDServiceProxy_BeginGetMetadata(This,ppResult)	\
    ( (This)->lpVtbl -> BeginGetMetadata(This,ppResult) ) 

#define IWSDServiceProxy_EndGetMetadata(This,pResult,ppMetadata)	\
    ( (This)->lpVtbl -> EndGetMetadata(This,pResult,ppMetadata) ) 

#define IWSDServiceProxy_GetServiceMetadata(This,ppServiceMetadata)	\
    ( (This)->lpVtbl -> GetServiceMetadata(This,ppServiceMetadata) ) 

#define IWSDServiceProxy_SubscribeToOperation(This,pOperation,pUnknown,pAny,ppAny)	\
    ( (This)->lpVtbl -> SubscribeToOperation(This,pOperation,pUnknown,pAny,ppAny) ) 

#define IWSDServiceProxy_UnsubscribeToOperation(This,pOperation)	\
    ( (This)->lpVtbl -> UnsubscribeToOperation(This,pOperation) ) 

#define IWSDServiceProxy_SetEventingStatusCallback(This,pStatus)	\
    ( (This)->lpVtbl -> SetEventingStatusCallback(This,pStatus) ) 

#define IWSDServiceProxy_GetEndpointProxy(This,ppProxy)	\
    ( (This)->lpVtbl -> GetEndpointProxy(This,ppProxy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDServiceProxy_INTERFACE_DEFINED__ */


#ifndef __IWSDDeviceProxy_INTERFACE_DEFINED__
#define __IWSDDeviceProxy_INTERFACE_DEFINED__

/* interface IWSDDeviceProxy */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDDeviceProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eee0c031-c578-4c0e-9a3b-973c35f409db")
    IWSDDeviceProxy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ 
            __in  LPCWSTR pszDeviceId,
            /* [in] */ IWSDAddress *pDeviceAddress,
            /* [in] */ 
            __in  LPCWSTR pszLocalId,
            /* [optional][in] */ IWSDXMLContext *pContext,
            /* [optional][in] */ IWSDDeviceProxy *pSponsor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginGetMetadata( 
            /* [out] */ IWSDAsyncResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndGetMetadata( 
            /* [in] */ IWSDAsyncResult *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostMetadata( 
            /* [out] */ WSD_HOST_METADATA **ppHostMetadata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThisModelMetadata( 
            /* [out] */ WSD_THIS_MODEL_METADATA **ppManufacturerMetadata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThisDeviceMetadata( 
            /* [out] */ WSD_THIS_DEVICE_METADATA **ppThisDeviceMetadata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllMetadata( 
            /* [out] */ WSD_METADATA_SECTION_LIST **ppMetadata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceProxyById( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [out] */ IWSDServiceProxy **ppServiceProxy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceProxyByType( 
            /* [in] */ const WSDXML_NAME *pType,
            /* [out] */ IWSDServiceProxy **ppServiceProxy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndpointProxy( 
            /* [out] */ IWSDEndpointProxy **ppProxy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDDeviceProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDDeviceProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDDeviceProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDDeviceProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IWSDDeviceProxy * This,
            /* [in] */ 
            __in  LPCWSTR pszDeviceId,
            /* [in] */ IWSDAddress *pDeviceAddress,
            /* [in] */ 
            __in  LPCWSTR pszLocalId,
            /* [optional][in] */ IWSDXMLContext *pContext,
            /* [optional][in] */ IWSDDeviceProxy *pSponsor);
        
        HRESULT ( STDMETHODCALLTYPE *BeginGetMetadata )( 
            IWSDDeviceProxy * This,
            /* [out] */ IWSDAsyncResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *EndGetMetadata )( 
            IWSDDeviceProxy * This,
            /* [in] */ IWSDAsyncResult *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostMetadata )( 
            IWSDDeviceProxy * This,
            /* [out] */ WSD_HOST_METADATA **ppHostMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *GetThisModelMetadata )( 
            IWSDDeviceProxy * This,
            /* [out] */ WSD_THIS_MODEL_METADATA **ppManufacturerMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *GetThisDeviceMetadata )( 
            IWSDDeviceProxy * This,
            /* [out] */ WSD_THIS_DEVICE_METADATA **ppThisDeviceMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllMetadata )( 
            IWSDDeviceProxy * This,
            /* [out] */ WSD_METADATA_SECTION_LIST **ppMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProxyById )( 
            IWSDDeviceProxy * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [out] */ IWSDServiceProxy **ppServiceProxy);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProxyByType )( 
            IWSDDeviceProxy * This,
            /* [in] */ const WSDXML_NAME *pType,
            /* [out] */ IWSDServiceProxy **ppServiceProxy);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpointProxy )( 
            IWSDDeviceProxy * This,
            /* [out] */ IWSDEndpointProxy **ppProxy);
        
        END_INTERFACE
    } IWSDDeviceProxyVtbl;

    interface IWSDDeviceProxy
    {
        CONST_VTBL struct IWSDDeviceProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDDeviceProxy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDDeviceProxy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDDeviceProxy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDDeviceProxy_Init(This,pszDeviceId,pDeviceAddress,pszLocalId,pContext,pSponsor)	\
    ( (This)->lpVtbl -> Init(This,pszDeviceId,pDeviceAddress,pszLocalId,pContext,pSponsor) ) 

#define IWSDDeviceProxy_BeginGetMetadata(This,ppResult)	\
    ( (This)->lpVtbl -> BeginGetMetadata(This,ppResult) ) 

#define IWSDDeviceProxy_EndGetMetadata(This,pResult)	\
    ( (This)->lpVtbl -> EndGetMetadata(This,pResult) ) 

#define IWSDDeviceProxy_GetHostMetadata(This,ppHostMetadata)	\
    ( (This)->lpVtbl -> GetHostMetadata(This,ppHostMetadata) ) 

#define IWSDDeviceProxy_GetThisModelMetadata(This,ppManufacturerMetadata)	\
    ( (This)->lpVtbl -> GetThisModelMetadata(This,ppManufacturerMetadata) ) 

#define IWSDDeviceProxy_GetThisDeviceMetadata(This,ppThisDeviceMetadata)	\
    ( (This)->lpVtbl -> GetThisDeviceMetadata(This,ppThisDeviceMetadata) ) 

#define IWSDDeviceProxy_GetAllMetadata(This,ppMetadata)	\
    ( (This)->lpVtbl -> GetAllMetadata(This,ppMetadata) ) 

#define IWSDDeviceProxy_GetServiceProxyById(This,pszServiceId,ppServiceProxy)	\
    ( (This)->lpVtbl -> GetServiceProxyById(This,pszServiceId,ppServiceProxy) ) 

#define IWSDDeviceProxy_GetServiceProxyByType(This,pType,ppServiceProxy)	\
    ( (This)->lpVtbl -> GetServiceProxyByType(This,pType,ppServiceProxy) ) 

#define IWSDDeviceProxy_GetEndpointProxy(This,ppProxy)	\
    ( (This)->lpVtbl -> GetEndpointProxy(This,ppProxy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDDeviceProxy_INTERFACE_DEFINED__ */


#ifndef __IWSDAsyncResult_INTERFACE_DEFINED__
#define __IWSDAsyncResult_INTERFACE_DEFINED__

/* interface IWSDAsyncResult */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDAsyncResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11a9852a-8dd8-423e-b537-9356db4fbfb8")
    IWSDAsyncResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [in] */ IWSDAsyncCallback *pCallback,
            /* [in] */ IUnknown *pAsyncState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWaitHandle( 
            /* [in] */ HANDLE hWaitHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasCompleted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAsyncState( 
            /* [out] */ IUnknown **ppAsyncState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [out] */ WSD_EVENT *pEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndpointProxy( 
            /* [out] */ IWSDEndpointProxy **ppEndpoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDAsyncResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDAsyncResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDAsyncResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDAsyncResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IWSDAsyncResult * This,
            /* [in] */ IWSDAsyncCallback *pCallback,
            /* [in] */ IUnknown *pAsyncState);
        
        HRESULT ( STDMETHODCALLTYPE *SetWaitHandle )( 
            IWSDAsyncResult * This,
            /* [in] */ HANDLE hWaitHandle);
        
        HRESULT ( STDMETHODCALLTYPE *HasCompleted )( 
            IWSDAsyncResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAsyncState )( 
            IWSDAsyncResult * This,
            /* [out] */ IUnknown **ppAsyncState);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IWSDAsyncResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IWSDAsyncResult * This,
            /* [out] */ WSD_EVENT *pEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpointProxy )( 
            IWSDAsyncResult * This,
            /* [out] */ IWSDEndpointProxy **ppEndpoint);
        
        END_INTERFACE
    } IWSDAsyncResultVtbl;

    interface IWSDAsyncResult
    {
        CONST_VTBL struct IWSDAsyncResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDAsyncResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDAsyncResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDAsyncResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDAsyncResult_SetCallback(This,pCallback,pAsyncState)	\
    ( (This)->lpVtbl -> SetCallback(This,pCallback,pAsyncState) ) 

#define IWSDAsyncResult_SetWaitHandle(This,hWaitHandle)	\
    ( (This)->lpVtbl -> SetWaitHandle(This,hWaitHandle) ) 

#define IWSDAsyncResult_HasCompleted(This)	\
    ( (This)->lpVtbl -> HasCompleted(This) ) 

#define IWSDAsyncResult_GetAsyncState(This,ppAsyncState)	\
    ( (This)->lpVtbl -> GetAsyncState(This,ppAsyncState) ) 

#define IWSDAsyncResult_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IWSDAsyncResult_GetEvent(This,pEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,pEvent) ) 

#define IWSDAsyncResult_GetEndpointProxy(This,ppEndpoint)	\
    ( (This)->lpVtbl -> GetEndpointProxy(This,ppEndpoint) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDAsyncResult_INTERFACE_DEFINED__ */


#ifndef __IWSDAsyncCallback_INTERFACE_DEFINED__
#define __IWSDAsyncCallback_INTERFACE_DEFINED__

/* interface IWSDAsyncCallback */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDAsyncCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a63e109d-ce72-49e2-ba98-e845f5ee1666")
    IWSDAsyncCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AsyncOperationComplete( 
            /* [in] */ IWSDAsyncResult *pAsyncResult,
            /* [in] */ IUnknown *pAsyncState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDAsyncCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDAsyncCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDAsyncCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDAsyncCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AsyncOperationComplete )( 
            IWSDAsyncCallback * This,
            /* [in] */ IWSDAsyncResult *pAsyncResult,
            /* [in] */ IUnknown *pAsyncState);
        
        END_INTERFACE
    } IWSDAsyncCallbackVtbl;

    interface IWSDAsyncCallback
    {
        CONST_VTBL struct IWSDAsyncCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDAsyncCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDAsyncCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDAsyncCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDAsyncCallback_AsyncOperationComplete(This,pAsyncResult,pAsyncState)	\
    ( (This)->lpVtbl -> AsyncOperationComplete(This,pAsyncResult,pAsyncState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDAsyncCallback_INTERFACE_DEFINED__ */


#ifndef __IWSDEventingStatus_INTERFACE_DEFINED__
#define __IWSDEventingStatus_INTERFACE_DEFINED__

/* interface IWSDEventingStatus */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDEventingStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49b17f52-637a-407a-ae99-fbe82a4d38c0")
    IWSDEventingStatus : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE SubscriptionRenewed( 
            /* [in] */ LPCWSTR pszSubscriptionAction) = 0;
        
        virtual void STDMETHODCALLTYPE SubscriptionRenewalFailed( 
            /* [in] */ LPCWSTR pszSubscriptionAction,
            /* [in] */ HRESULT hr) = 0;
        
        virtual void STDMETHODCALLTYPE SubscriptionEnded( 
            /* [in] */ LPCWSTR pszSubscriptionAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDEventingStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDEventingStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDEventingStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDEventingStatus * This);
        
        void ( STDMETHODCALLTYPE *SubscriptionRenewed )( 
            IWSDEventingStatus * This,
            /* [in] */ LPCWSTR pszSubscriptionAction);
        
        void ( STDMETHODCALLTYPE *SubscriptionRenewalFailed )( 
            IWSDEventingStatus * This,
            /* [in] */ LPCWSTR pszSubscriptionAction,
            /* [in] */ HRESULT hr);
        
        void ( STDMETHODCALLTYPE *SubscriptionEnded )( 
            IWSDEventingStatus * This,
            /* [in] */ LPCWSTR pszSubscriptionAction);
        
        END_INTERFACE
    } IWSDEventingStatusVtbl;

    interface IWSDEventingStatus
    {
        CONST_VTBL struct IWSDEventingStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDEventingStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDEventingStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDEventingStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDEventingStatus_SubscriptionRenewed(This,pszSubscriptionAction)	\
    ( (This)->lpVtbl -> SubscriptionRenewed(This,pszSubscriptionAction) ) 

#define IWSDEventingStatus_SubscriptionRenewalFailed(This,pszSubscriptionAction,hr)	\
    ( (This)->lpVtbl -> SubscriptionRenewalFailed(This,pszSubscriptionAction,hr) ) 

#define IWSDEventingStatus_SubscriptionEnded(This,pszSubscriptionAction)	\
    ( (This)->lpVtbl -> SubscriptionEnded(This,pszSubscriptionAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDEventingStatus_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdbase.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wsdbase.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsdbase_h__
#define __wsdbase_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSDAddress_FWD_DEFINED__
#define __IWSDAddress_FWD_DEFINED__
typedef interface IWSDAddress IWSDAddress;
#endif 	/* __IWSDAddress_FWD_DEFINED__ */


#ifndef __IWSDTransportAddress_FWD_DEFINED__
#define __IWSDTransportAddress_FWD_DEFINED__
typedef interface IWSDTransportAddress IWSDTransportAddress;
#endif 	/* __IWSDTransportAddress_FWD_DEFINED__ */


#ifndef __IWSDMessageParameters_FWD_DEFINED__
#define __IWSDMessageParameters_FWD_DEFINED__
typedef interface IWSDMessageParameters IWSDMessageParameters;
#endif 	/* __IWSDMessageParameters_FWD_DEFINED__ */


#ifndef __IWSDUdpMessageParameters_FWD_DEFINED__
#define __IWSDUdpMessageParameters_FWD_DEFINED__
typedef interface IWSDUdpMessageParameters IWSDUdpMessageParameters;
#endif 	/* __IWSDUdpMessageParameters_FWD_DEFINED__ */


#ifndef __IWSDUdpAddress_FWD_DEFINED__
#define __IWSDUdpAddress_FWD_DEFINED__
typedef interface IWSDUdpAddress IWSDUdpAddress;
#endif 	/* __IWSDUdpAddress_FWD_DEFINED__ */


#ifndef __IWSDHttpMessageParameters_FWD_DEFINED__
#define __IWSDHttpMessageParameters_FWD_DEFINED__
typedef interface IWSDHttpMessageParameters IWSDHttpMessageParameters;
#endif 	/* __IWSDHttpMessageParameters_FWD_DEFINED__ */


#ifndef __IWSDHttpAddress_FWD_DEFINED__
#define __IWSDHttpAddress_FWD_DEFINED__
typedef interface IWSDHttpAddress IWSDHttpAddress;
#endif 	/* __IWSDHttpAddress_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsdbase_0000_0000 */
/* [local] */ 







#define WSDAPI_ADDRESSFAMILY_IPV4 1
#define WSDAPI_ADDRESSFAMILY_IPV6 2


extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0000_v0_0_s_ifspec;

#ifndef __IWSDAddress_INTERFACE_DEFINED__
#define __IWSDAddress_INTERFACE_DEFINED__

/* interface IWSDAddress */
/* [local][uuid][object] */ 




EXTERN_C const IID IID_IWSDAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9574c6c-12a6-4f74-93a1-3318ff605759")
    IWSDAddress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [size_is][out] */ 
            __out_ecount(cchLength)  LPWSTR pszBuffer,
            /* [in] */ DWORD cchLength,
            /* [in] */ BOOL fSafe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deserialize( 
            /* [in] */ LPCWSTR pszBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDAddress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IWSDAddress * This,
            /* [size_is][out] */ 
            __out_ecount(cchLength)  LPWSTR pszBuffer,
            /* [in] */ DWORD cchLength,
            /* [in] */ BOOL fSafe);
        
        HRESULT ( STDMETHODCALLTYPE *Deserialize )( 
            IWSDAddress * This,
            /* [in] */ LPCWSTR pszBuffer);
        
        END_INTERFACE
    } IWSDAddressVtbl;

    interface IWSDAddress
    {
        CONST_VTBL struct IWSDAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDAddress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDAddress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDAddress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDAddress_Serialize(This,pszBuffer,cchLength,fSafe)	\
    ( (This)->lpVtbl -> Serialize(This,pszBuffer,cchLength,fSafe) ) 

#define IWSDAddress_Deserialize(This,pszBuffer)	\
    ( (This)->lpVtbl -> Deserialize(This,pszBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDAddress_INTERFACE_DEFINED__ */


#ifndef __IWSDTransportAddress_INTERFACE_DEFINED__
#define __IWSDTransportAddress_INTERFACE_DEFINED__

/* interface IWSDTransportAddress */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IWSDTransportAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70d23498-4ee6-4340-a3df-d845d2235467")
    IWSDTransportAddress : public IWSDAddress
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ WORD *pwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPort( 
            /* [in] */ WORD wPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportAddress( 
            /* [out] */ LPCWSTR *ppszAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportAddressEx( 
            /* [in] */ BOOL fSafe,
            /* [out] */ LPCWSTR *ppszAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportAddress( 
            /* [in] */ LPCWSTR pszAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDTransportAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDTransportAddress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDTransportAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDTransportAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IWSDTransportAddress * This,
            /* [size_is][out] */ 
            __out_ecount(cchLength)  LPWSTR pszBuffer,
            /* [in] */ DWORD cchLength,
            /* [in] */ BOOL fSafe);
        
        HRESULT ( STDMETHODCALLTYPE *Deserialize )( 
            IWSDTransportAddress * This,
            /* [in] */ LPCWSTR pszBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IWSDTransportAddress * This,
            /* [out] */ WORD *pwPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IWSDTransportAddress * This,
            /* [in] */ WORD wPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAddress )( 
            IWSDTransportAddress * This,
            /* [out] */ LPCWSTR *ppszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAddressEx )( 
            IWSDTransportAddress * This,
            /* [in] */ BOOL fSafe,
            /* [out] */ LPCWSTR *ppszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportAddress )( 
            IWSDTransportAddress * This,
            /* [in] */ LPCWSTR pszAddress);
        
        END_INTERFACE
    } IWSDTransportAddressVtbl;

    interface IWSDTransportAddress
    {
        CONST_VTBL struct IWSDTransportAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDTransportAddress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDTransportAddress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDTransportAddress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDTransportAddress_Serialize(This,pszBuffer,cchLength,fSafe)	\
    ( (This)->lpVtbl -> Serialize(This,pszBuffer,cchLength,fSafe) ) 

#define IWSDTransportAddress_Deserialize(This,pszBuffer)	\
    ( (This)->lpVtbl -> Deserialize(This,pszBuffer) ) 


#define IWSDTransportAddress_GetPort(This,pwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pwPort) ) 

#define IWSDTransportAddress_SetPort(This,wPort)	\
    ( (This)->lpVtbl -> SetPort(This,wPort) ) 

#define IWSDTransportAddress_GetTransportAddress(This,ppszAddress)	\
    ( (This)->lpVtbl -> GetTransportAddress(This,ppszAddress) ) 

#define IWSDTransportAddress_GetTransportAddressEx(This,fSafe,ppszAddress)	\
    ( (This)->lpVtbl -> GetTransportAddressEx(This,fSafe,ppszAddress) ) 

#define IWSDTransportAddress_SetTransportAddress(This,pszAddress)	\
    ( (This)->lpVtbl -> SetTransportAddress(This,pszAddress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDTransportAddress_INTERFACE_DEFINED__ */


#ifndef __IWSDMessageParameters_INTERFACE_DEFINED__
#define __IWSDMessageParameters_INTERFACE_DEFINED__

/* interface IWSDMessageParameters */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWSDMessageParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1fafe8a2-e6fc-4b80-b6cf-b7d45c416d7c")
    IWSDMessageParameters : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLocalAddress( 
            /* [out] */ __RPC__deref_out_opt IWSDAddress **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocalAddress( 
            /* [in] */ __RPC__in_opt IWSDAddress *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteAddress( 
            /* [out] */ __RPC__deref_out_opt IWSDAddress **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRemoteAddress( 
            /* [in] */ __RPC__in_opt IWSDAddress *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLowerParameters( 
            /* [out] */ __RPC__deref_out_opt IWSDMessageParameters **ppTxParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDMessageParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDMessageParameters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDMessageParameters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDMessageParameters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalAddress )( 
            IWSDMessageParameters * This,
            /* [out] */ __RPC__deref_out_opt IWSDAddress **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalAddress )( 
            IWSDMessageParameters * This,
            /* [in] */ __RPC__in_opt IWSDAddress *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteAddress )( 
            IWSDMessageParameters * This,
            /* [out] */ __RPC__deref_out_opt IWSDAddress **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteAddress )( 
            IWSDMessageParameters * This,
            /* [in] */ __RPC__in_opt IWSDAddress *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetLowerParameters )( 
            IWSDMessageParameters * This,
            /* [out] */ __RPC__deref_out_opt IWSDMessageParameters **ppTxParams);
        
        END_INTERFACE
    } IWSDMessageParametersVtbl;

    interface IWSDMessageParameters
    {
        CONST_VTBL struct IWSDMessageParametersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDMessageParameters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDMessageParameters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDMessageParameters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDMessageParameters_GetLocalAddress(This,ppAddress)	\
    ( (This)->lpVtbl -> GetLocalAddress(This,ppAddress) ) 

#define IWSDMessageParameters_SetLocalAddress(This,pAddress)	\
    ( (This)->lpVtbl -> SetLocalAddress(This,pAddress) ) 

#define IWSDMessageParameters_GetRemoteAddress(This,ppAddress)	\
    ( (This)->lpVtbl -> GetRemoteAddress(This,ppAddress) ) 

#define IWSDMessageParameters_SetRemoteAddress(This,pAddress)	\
    ( (This)->lpVtbl -> SetRemoteAddress(This,pAddress) ) 

#define IWSDMessageParameters_GetLowerParameters(This,ppTxParams)	\
    ( (This)->lpVtbl -> GetLowerParameters(This,ppTxParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDMessageParameters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wsdbase_0000_0003 */
/* [local] */ 

HRESULT WINAPI
WSDCreateUdpMessageParameters(
    IWSDUdpMessageParameters** ppTxParams);
typedef struct _WSDUdpRetransmitParams
    {
    ULONG ulSendDelay;
    ULONG ulRepeat;
    ULONG ulRepeatMinDelay;
    ULONG ulRepeatMaxDelay;
    ULONG ulRepeatUpperDelay;
    } 	WSDUdpRetransmitParams;



extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0003_v0_0_s_ifspec;

#ifndef __IWSDUdpMessageParameters_INTERFACE_DEFINED__
#define __IWSDUdpMessageParameters_INTERFACE_DEFINED__

/* interface IWSDUdpMessageParameters */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWSDUdpMessageParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9934149f-8f0c-447b-aa0b-73124b0ca7f0")
    IWSDUdpMessageParameters : public IWSDMessageParameters
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRetransmitParams( 
            /* [in] */ __RPC__in const WSDUdpRetransmitParams *pParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRetransmitParams( 
            /* [out] */ __RPC__out WSDUdpRetransmitParams *pParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDUdpMessageParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDUdpMessageParameters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDUdpMessageParameters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDUdpMessageParameters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalAddress )( 
            IWSDUdpMessageParameters * This,
            /* [out] */ __RPC__deref_out_opt IWSDAddress **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalAddress )( 
            IWSDUdpMessageParameters * This,
            /* [in] */ __RPC__in_opt IWSDAddress *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteAddress )( 
            IWSDUdpMessageParameters * This,
            /* [out] */ __RPC__deref_out_opt IWSDAddress **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteAddress )( 
            IWSDUdpMessageParameters * This,
            /* [in] */ __RPC__in_opt IWSDAddress *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetLowerParameters )( 
            IWSDUdpMessageParameters * This,
            /* [out] */ __RPC__deref_out_opt IWSDMessageParameters **ppTxParams);
        
        HRESULT ( STDMETHODCALLTYPE *SetRetransmitParams )( 
            IWSDUdpMessageParameters * This,
            /* [in] */ __RPC__in const WSDUdpRetransmitParams *pParams);
        
        HRESULT ( STDMETHODCALLTYPE *GetRetransmitParams )( 
            IWSDUdpMessageParameters * This,
            /* [out] */ __RPC__out WSDUdpRetransmitParams *pParams);
        
        END_INTERFACE
    } IWSDUdpMessageParametersVtbl;

    interface IWSDUdpMessageParameters
    {
        CONST_VTBL struct IWSDUdpMessageParametersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDUdpMessageParameters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDUdpMessageParameters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDUdpMessageParameters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDUdpMessageParameters_GetLocalAddress(This,ppAddress)	\
    ( (This)->lpVtbl -> GetLocalAddress(This,ppAddress) ) 

#define IWSDUdpMessageParameters_SetLocalAddress(This,pAddress)	\
    ( (This)->lpVtbl -> SetLocalAddress(This,pAddress) ) 

#define IWSDUdpMessageParameters_GetRemoteAddress(This,ppAddress)	\
    ( (This)->lpVtbl -> GetRemoteAddress(This,ppAddress) ) 

#define IWSDUdpMessageParameters_SetRemoteAddress(This,pAddress)	\
    ( (This)->lpVtbl -> SetRemoteAddress(This,pAddress) ) 

#define IWSDUdpMessageParameters_GetLowerParameters(This,ppTxParams)	\
    ( (This)->lpVtbl -> GetLowerParameters(This,ppTxParams) ) 


#define IWSDUdpMessageParameters_SetRetransmitParams(This,pParams)	\
    ( (This)->lpVtbl -> SetRetransmitParams(This,pParams) ) 

#define IWSDUdpMessageParameters_GetRetransmitParams(This,pParams)	\
    ( (This)->lpVtbl -> GetRetransmitParams(This,pParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDUdpMessageParameters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wsdbase_0000_0004 */
/* [local] */ 

HRESULT WINAPI
WSDCreateUdpAddress(
    IWSDUdpAddress** ppAddress);
#if 1
// Forward declaration to avoid winsock2.h inclusion
#ifndef __CSADDR_DEFINED__
struct SOCKADDR_STORAGE;
#endif // __CSADDR_DEFINED__
#else  // 1
// Bogus definition used to make MIDL compiler happy
typedef void SOCKADDR_STORAGE;

#endif // 1
typedef 
enum _WSDUdpMessageType
    {	ONE_WAY	= 0,
	TWO_WAY	= ( ONE_WAY + 1 ) 
    } 	WSDUdpMessageType;



extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0004_v0_0_s_ifspec;

#ifndef __IWSDUdpAddress_INTERFACE_DEFINED__
#define __IWSDUdpAddress_INTERFACE_DEFINED__

/* interface IWSDUdpAddress */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IWSDUdpAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74d6124a-a441-4f78-a1eb-97a8d1996893")
    IWSDUdpAddress : public IWSDTransportAddress
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSockaddr( 
            /* [in] */ const SOCKADDR_STORAGE *pSockAddr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSockaddr( 
            /* [out] */ SOCKADDR_STORAGE *pSockAddr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExclusive( 
            /* [in] */ BOOL fExclusive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExclusive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMessageType( 
            /* [in] */ WSDUdpMessageType messageType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMessageType( 
            /* [out] */ WSDUdpMessageType *pMessageType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTTL( 
            /* [in] */ DWORD dwTTL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTTL( 
            /* [out] */ DWORD *pdwTTL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAlias( 
            /* [in] */ const GUID *pAlias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlias( 
            /* [out] */ GUID *pAlias) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDUdpAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDUdpAddress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDUdpAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDUdpAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IWSDUdpAddress * This,
            /* [size_is][out] */ 
            __out_ecount(cchLength)  LPWSTR pszBuffer,
            /* [in] */ DWORD cchLength,
            /* [in] */ BOOL fSafe);
        
        HRESULT ( STDMETHODCALLTYPE *Deserialize )( 
            IWSDUdpAddress * This,
            /* [in] */ LPCWSTR pszBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IWSDUdpAddress * This,
            /* [out] */ WORD *pwPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IWSDUdpAddress * This,
            /* [in] */ WORD wPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAddress )( 
            IWSDUdpAddress * This,
            /* [out] */ LPCWSTR *ppszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAddressEx )( 
            IWSDUdpAddress * This,
            /* [in] */ BOOL fSafe,
            /* [out] */ LPCWSTR *ppszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportAddress )( 
            IWSDUdpAddress * This,
            /* [in] */ LPCWSTR pszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetSockaddr )( 
            IWSDUdpAddress * This,
            /* [in] */ const SOCKADDR_STORAGE *pSockAddr);
        
        HRESULT ( STDMETHODCALLTYPE *GetSockaddr )( 
            IWSDUdpAddress * This,
            /* [out] */ SOCKADDR_STORAGE *pSockAddr);
        
        HRESULT ( STDMETHODCALLTYPE *SetExclusive )( 
            IWSDUdpAddress * This,
            /* [in] */ BOOL fExclusive);
        
        HRESULT ( STDMETHODCALLTYPE *GetExclusive )( 
            IWSDUdpAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMessageType )( 
            IWSDUdpAddress * This,
            /* [in] */ WSDUdpMessageType messageType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessageType )( 
            IWSDUdpAddress * This,
            /* [out] */ WSDUdpMessageType *pMessageType);
        
        HRESULT ( STDMETHODCALLTYPE *SetTTL )( 
            IWSDUdpAddress * This,
            /* [in] */ DWORD dwTTL);
        
        HRESULT ( STDMETHODCALLTYPE *GetTTL )( 
            IWSDUdpAddress * This,
            /* [out] */ DWORD *pdwTTL);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlias )( 
            IWSDUdpAddress * This,
            /* [in] */ const GUID *pAlias);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlias )( 
            IWSDUdpAddress * This,
            /* [out] */ GUID *pAlias);
        
        END_INTERFACE
    } IWSDUdpAddressVtbl;

    interface IWSDUdpAddress
    {
        CONST_VTBL struct IWSDUdpAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDUdpAddress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDUdpAddress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDUdpAddress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDUdpAddress_Serialize(This,pszBuffer,cchLength,fSafe)	\
    ( (This)->lpVtbl -> Serialize(This,pszBuffer,cchLength,fSafe) ) 

#define IWSDUdpAddress_Deserialize(This,pszBuffer)	\
    ( (This)->lpVtbl -> Deserialize(This,pszBuffer) ) 


#define IWSDUdpAddress_GetPort(This,pwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pwPort) ) 

#define IWSDUdpAddress_SetPort(This,wPort)	\
    ( (This)->lpVtbl -> SetPort(This,wPort) ) 

#define IWSDUdpAddress_GetTransportAddress(This,ppszAddress)	\
    ( (This)->lpVtbl -> GetTransportAddress(This,ppszAddress) ) 

#define IWSDUdpAddress_GetTransportAddressEx(This,fSafe,ppszAddress)	\
    ( (This)->lpVtbl -> GetTransportAddressEx(This,fSafe,ppszAddress) ) 

#define IWSDUdpAddress_SetTransportAddress(This,pszAddress)	\
    ( (This)->lpVtbl -> SetTransportAddress(This,pszAddress) ) 


#define IWSDUdpAddress_SetSockaddr(This,pSockAddr)	\
    ( (This)->lpVtbl -> SetSockaddr(This,pSockAddr) ) 

#define IWSDUdpAddress_GetSockaddr(This,pSockAddr)	\
    ( (This)->lpVtbl -> GetSockaddr(This,pSockAddr) ) 

#define IWSDUdpAddress_SetExclusive(This,fExclusive)	\
    ( (This)->lpVtbl -> SetExclusive(This,fExclusive) ) 

#define IWSDUdpAddress_GetExclusive(This)	\
    ( (This)->lpVtbl -> GetExclusive(This) ) 

#define IWSDUdpAddress_SetMessageType(This,messageType)	\
    ( (This)->lpVtbl -> SetMessageType(This,messageType) ) 

#define IWSDUdpAddress_GetMessageType(This,pMessageType)	\
    ( (This)->lpVtbl -> GetMessageType(This,pMessageType) ) 

#define IWSDUdpAddress_SetTTL(This,dwTTL)	\
    ( (This)->lpVtbl -> SetTTL(This,dwTTL) ) 

#define IWSDUdpAddress_GetTTL(This,pdwTTL)	\
    ( (This)->lpVtbl -> GetTTL(This,pdwTTL) ) 

#define IWSDUdpAddress_SetAlias(This,pAlias)	\
    ( (This)->lpVtbl -> SetAlias(This,pAlias) ) 

#define IWSDUdpAddress_GetAlias(This,pAlias)	\
    ( (This)->lpVtbl -> GetAlias(This,pAlias) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDUdpAddress_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wsdbase_0000_0005 */
/* [local] */ 

HRESULT WINAPI
WSDCreateHttpMessageParameters(
    IWSDHttpMessageParameters** ppTxParams);


extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0005_v0_0_s_ifspec;

#ifndef __IWSDHttpMessageParameters_INTERFACE_DEFINED__
#define __IWSDHttpMessageParameters_INTERFACE_DEFINED__

/* interface IWSDHttpMessageParameters */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IWSDHttpMessageParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("540bd122-5c83-4dec-b396-ea62a2697fdf")
    IWSDHttpMessageParameters : public IWSDMessageParameters
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInboundHttpHeaders( 
            /* [in] */ LPCWSTR pszHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInboundHttpHeaders( 
            /* [out] */ LPCWSTR *ppszHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutboundHttpHeaders( 
            /* [in] */ LPCWSTR pszHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutboundHttpHeaders( 
            /* [out] */ LPCWSTR *ppszHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetID( 
            /* [in] */ LPCWSTR pszId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ LPCWSTR *ppszId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ IUnknown *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ IUnknown **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDHttpMessageParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDHttpMessageParameters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDHttpMessageParameters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDHttpMessageParameters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalAddress )( 
            IWSDHttpMessageParameters * This,
            /* [out] */ IWSDAddress **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalAddress )( 
            IWSDHttpMessageParameters * This,
            /* [in] */ IWSDAddress *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteAddress )( 
            IWSDHttpMessageParameters * This,
            /* [out] */ IWSDAddress **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteAddress )( 
            IWSDHttpMessageParameters * This,
            /* [in] */ IWSDAddress *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetLowerParameters )( 
            IWSDHttpMessageParameters * This,
            /* [out] */ IWSDMessageParameters **ppTxParams);
        
        HRESULT ( STDMETHODCALLTYPE *SetInboundHttpHeaders )( 
            IWSDHttpMessageParameters * This,
            /* [in] */ LPCWSTR pszHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetInboundHttpHeaders )( 
            IWSDHttpMessageParameters * This,
            /* [out] */ LPCWSTR *ppszHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutboundHttpHeaders )( 
            IWSDHttpMessageParameters * This,
            /* [in] */ LPCWSTR pszHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutboundHttpHeaders )( 
            IWSDHttpMessageParameters * This,
            /* [out] */ LPCWSTR *ppszHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *SetID )( 
            IWSDHttpMessageParameters * This,
            /* [in] */ LPCWSTR pszId);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            IWSDHttpMessageParameters * This,
            /* [out] */ LPCWSTR *ppszId);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IWSDHttpMessageParameters * This,
            /* [in] */ IUnknown *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IWSDHttpMessageParameters * This,
            /* [out] */ IUnknown **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IWSDHttpMessageParameters * This);
        
        END_INTERFACE
    } IWSDHttpMessageParametersVtbl;

    interface IWSDHttpMessageParameters
    {
        CONST_VTBL struct IWSDHttpMessageParametersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDHttpMessageParameters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDHttpMessageParameters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDHttpMessageParameters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDHttpMessageParameters_GetLocalAddress(This,ppAddress)	\
    ( (This)->lpVtbl -> GetLocalAddress(This,ppAddress) ) 

#define IWSDHttpMessageParameters_SetLocalAddress(This,pAddress)	\
    ( (This)->lpVtbl -> SetLocalAddress(This,pAddress) ) 

#define IWSDHttpMessageParameters_GetRemoteAddress(This,ppAddress)	\
    ( (This)->lpVtbl -> GetRemoteAddress(This,ppAddress) ) 

#define IWSDHttpMessageParameters_SetRemoteAddress(This,pAddress)	\
    ( (This)->lpVtbl -> SetRemoteAddress(This,pAddress) ) 

#define IWSDHttpMessageParameters_GetLowerParameters(This,ppTxParams)	\
    ( (This)->lpVtbl -> GetLowerParameters(This,ppTxParams) ) 


#define IWSDHttpMessageParameters_SetInboundHttpHeaders(This,pszHeaders)	\
    ( (This)->lpVtbl -> SetInboundHttpHeaders(This,pszHeaders) ) 

#define IWSDHttpMessageParameters_GetInboundHttpHeaders(This,ppszHeaders)	\
    ( (This)->lpVtbl -> GetInboundHttpHeaders(This,ppszHeaders) ) 

#define IWSDHttpMessageParameters_SetOutboundHttpHeaders(This,pszHeaders)	\
    ( (This)->lpVtbl -> SetOutboundHttpHeaders(This,pszHeaders) ) 

#define IWSDHttpMessageParameters_GetOutboundHttpHeaders(This,ppszHeaders)	\
    ( (This)->lpVtbl -> GetOutboundHttpHeaders(This,ppszHeaders) ) 

#define IWSDHttpMessageParameters_SetID(This,pszId)	\
    ( (This)->lpVtbl -> SetID(This,pszId) ) 

#define IWSDHttpMessageParameters_GetID(This,ppszId)	\
    ( (This)->lpVtbl -> GetID(This,ppszId) ) 

#define IWSDHttpMessageParameters_SetContext(This,pContext)	\
    ( (This)->lpVtbl -> SetContext(This,pContext) ) 

#define IWSDHttpMessageParameters_GetContext(This,ppContext)	\
    ( (This)->lpVtbl -> GetContext(This,ppContext) ) 

#define IWSDHttpMessageParameters_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDHttpMessageParameters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wsdbase_0000_0006 */
/* [local] */ 

HRESULT WINAPI
WSDCreateHttpAddress(
    IWSDHttpAddress** ppAdress);


extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdbase_0000_0006_v0_0_s_ifspec;

#ifndef __IWSDHttpAddress_INTERFACE_DEFINED__
#define __IWSDHttpAddress_INTERFACE_DEFINED__

/* interface IWSDHttpAddress */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IWSDHttpAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d09ac7bd-2a3e-4b85-8605-2737ff3e4ea0")
    IWSDHttpAddress : public IWSDTransportAddress
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSecure( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecure( 
            /* [in] */ BOOL fSecure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ LPCWSTR *ppszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ LPCWSTR pszPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDHttpAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDHttpAddress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDHttpAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDHttpAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IWSDHttpAddress * This,
            /* [size_is][out] */ 
            __out_ecount(cchLength)  LPWSTR pszBuffer,
            /* [in] */ DWORD cchLength,
            /* [in] */ BOOL fSafe);
        
        HRESULT ( STDMETHODCALLTYPE *Deserialize )( 
            IWSDHttpAddress * This,
            /* [in] */ LPCWSTR pszBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IWSDHttpAddress * This,
            /* [out] */ WORD *pwPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IWSDHttpAddress * This,
            /* [in] */ WORD wPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAddress )( 
            IWSDHttpAddress * This,
            /* [out] */ LPCWSTR *ppszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAddressEx )( 
            IWSDHttpAddress * This,
            /* [in] */ BOOL fSafe,
            /* [out] */ LPCWSTR *ppszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportAddress )( 
            IWSDHttpAddress * This,
            /* [in] */ LPCWSTR pszAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecure )( 
            IWSDHttpAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecure )( 
            IWSDHttpAddress * This,
            /* [in] */ BOOL fSecure);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IWSDHttpAddress * This,
            /* [out] */ LPCWSTR *ppszPath);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IWSDHttpAddress * This,
            /* [in] */ LPCWSTR pszPath);
        
        END_INTERFACE
    } IWSDHttpAddressVtbl;

    interface IWSDHttpAddress
    {
        CONST_VTBL struct IWSDHttpAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDHttpAddress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDHttpAddress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDHttpAddress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDHttpAddress_Serialize(This,pszBuffer,cchLength,fSafe)	\
    ( (This)->lpVtbl -> Serialize(This,pszBuffer,cchLength,fSafe) ) 

#define IWSDHttpAddress_Deserialize(This,pszBuffer)	\
    ( (This)->lpVtbl -> Deserialize(This,pszBuffer) ) 


#define IWSDHttpAddress_GetPort(This,pwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pwPort) ) 

#define IWSDHttpAddress_SetPort(This,wPort)	\
    ( (This)->lpVtbl -> SetPort(This,wPort) ) 

#define IWSDHttpAddress_GetTransportAddress(This,ppszAddress)	\
    ( (This)->lpVtbl -> GetTransportAddress(This,ppszAddress) ) 

#define IWSDHttpAddress_GetTransportAddressEx(This,fSafe,ppszAddress)	\
    ( (This)->lpVtbl -> GetTransportAddressEx(This,fSafe,ppszAddress) ) 

#define IWSDHttpAddress_SetTransportAddress(This,pszAddress)	\
    ( (This)->lpVtbl -> SetTransportAddress(This,pszAddress) ) 


#define IWSDHttpAddress_GetSecure(This)	\
    ( (This)->lpVtbl -> GetSecure(This) ) 

#define IWSDHttpAddress_SetSecure(This,fSecure)	\
    ( (This)->lpVtbl -> SetSecure(This,fSecure) ) 

#define IWSDHttpAddress_GetPath(This,ppszPath)	\
    ( (This)->lpVtbl -> GetPath(This,ppszPath) ) 

#define IWSDHttpAddress_SetPath(This,pszPath)	\
    ( (This)->lpVtbl -> SetPath(This,pszPath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDHttpAddress_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Component: WSDAPI - Microsoft Web Services for Devices API
// 
//  File: wsdutil.h
//
//  Abstract: WSDAPI Utilities
//
//--------------------------------------------------------------------------
#pragma once

//
// Helpful macros
//
#define WSD_DEFAULT_HOSTING_ADDRESS L"http://*:5357/"
#define WSD_DEFAULT_SECURE_HOSTING_ADDRESS L"https://*:5358/"
#define WSD_DEFAULT_EVENTING_ADDRESS L"http://*:5357/"

#ifdef __cplusplus
extern "C" {
#endif

//
// Configuration
//

// MessageSize: DWORD value between 32768 and 1048576
#define WSDAPI_OPTION_MAX_INBOUND_MESSAGE_SIZE 0x0001

HRESULT WINAPI
WSDSetConfigurationOption(
    DWORD dwOption,
    __in_bcount(cbInBuffer) LPVOID pVoid,
    DWORD cbInBuffer);

HRESULT WINAPI
WSDGetConfigurationOption(
    DWORD dwOption,
    __out_bcount(cbOutBuffer) LPVOID pVoid,
    DWORD cbOutBuffer);
    
//
// Linked memory
//

void * WINAPI 
WSDAllocateLinkedMemory(
    void* pParent, 
    size_t cbSize);

void WINAPI
WSDFreeLinkedMemory(
    void *pVoid);

void WINAPI
WSDAttachLinkedMemory(
    void* pParent,
    void* pChild);

void WINAPI
WSDDetachLinkedMemory(
    void* pVoid);

//
// XML helpers 
//

typedef struct _WSDXML_ELEMENT WSDXML_ELEMENT; 

HRESULT WINAPI
WSDXMLBuildAnyForSingleElement(
    WSDXML_NAME* pElementName, 
    __in_opt LPCWSTR pszText, 
    WSDXML_ELEMENT** ppAny);

HRESULT WINAPI
WSDXMLGetValueFromAny(
    __in LPCWSTR pszNamespace,
    __in LPCWSTR pszName, 
    WSDXML_ELEMENT* pAny, 
    LPCWSTR* ppszValue);

HRESULT WINAPI
WSDXMLAddSibling(
    WSDXML_ELEMENT* pFirst,
    WSDXML_ELEMENT* pSecond);

HRESULT WINAPI
WSDXMLAddChild(
    WSDXML_ELEMENT* pParent,
    WSDXML_ELEMENT* pChild);

HRESULT WINAPI
WSDXMLCleanupElement(
    WSDXML_ELEMENT* pAny);    

HRESULT WINAPI
WSDGenerateFault(
    __in LPCWSTR pszCode,
    __in LPCWSTR pszSubCode,
    __in LPCWSTR pszReason,
    __in LPCWSTR pszDetail,
    IWSDXMLContext* pContext,
    WSD_SOAP_FAULT** ppFault);

HRESULT WINAPI
WSDGenerateFaultEx(
    WSDXML_NAME* pCode, 
    WSDXML_NAME* pSubCode, 
    WSD_LOCALIZED_STRING_LIST* pReasons, 
    __in_opt LPCWSTR pszDetail, 
    WSD_SOAP_FAULT** ppFault);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdhost.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wsdhost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsdhost_h__
#define __wsdhost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSDDeviceHost_FWD_DEFINED__
#define __IWSDDeviceHost_FWD_DEFINED__
typedef interface IWSDDeviceHost IWSDDeviceHost;
#endif 	/* __IWSDDeviceHost_FWD_DEFINED__ */


#ifndef __IWSDDeviceHostNotify_FWD_DEFINED__
#define __IWSDDeviceHostNotify_FWD_DEFINED__
typedef interface IWSDDeviceHostNotify IWSDDeviceHostNotify;
#endif 	/* __IWSDDeviceHostNotify_FWD_DEFINED__ */


#ifndef __IWSDServiceMessaging_FWD_DEFINED__
#define __IWSDServiceMessaging_FWD_DEFINED__
typedef interface IWSDServiceMessaging IWSDServiceMessaging;
#endif 	/* __IWSDServiceMessaging_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wsdxmldom.h"
#include "wsdtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsdhost_0000_0000 */
/* [local] */ 






HRESULT WINAPI
WSDCreateDeviceHost(
    __in LPCWSTR pszLocalId,
    IWSDXMLContext* pContext,
    IWSDDeviceHost** ppDeviceHost);
HRESULT WINAPI
WSDCreateDeviceHostAdvanced(
    __in LPCWSTR pszLocalId,
    IWSDXMLContext* pContext,
    IWSDAddress** ppHostAddresses,
    DWORD dwHostAddressCount,
    IWSDDeviceHost** ppDeviceHost);


extern RPC_IF_HANDLE __MIDL_itf_wsdhost_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdhost_0000_0000_v0_0_s_ifspec;

#ifndef __IWSDDeviceHost_INTERFACE_DEFINED__
#define __IWSDDeviceHost_INTERFACE_DEFINED__

/* interface IWSDDeviceHost */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDDeviceHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("917fe891-3d13-4138-9809-934c8abeb12c")
    IWSDDeviceHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ 
            __in  LPCWSTR pszLocalId,
            /* [optional][in] */ IWSDXMLContext *pContext,
            /* [optional][in] */ IWSDAddress **ppHostAddresses,
            /* [optional][in] */ DWORD dwHostAddressCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ const WSD_URI_LIST *pScopeList,
            /* [optional][in] */ IWSDDeviceHostNotify *pNotificationSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPortType( 
            /* [in] */ const WSD_PORT_TYPE *pPortType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMetadata( 
            /* [in] */ const WSD_THIS_MODEL_METADATA *pThisModelMetadata,
            /* [in] */ const WSD_THIS_DEVICE_METADATA *pThisDeviceMetadata,
            /* [optional][in] */ const WSD_HOST_METADATA *pHostMetadata,
            /* [optional][in] */ const WSD_METADATA_SECTION_LIST *pCustomMetadata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterService( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [in] */ IUnknown *pService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetireService( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDynamicService( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [optional][in] */ 
            __in_opt  LPCWSTR pszEndpointAddress,
            /* [optional][in] */ const WSD_PORT_TYPE *pPortType,
            /* [optional][in] */ const WSDXML_NAME *pPortName,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny,
            /* [optional][in] */ IUnknown *pService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveDynamicService( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServiceDiscoverable( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [in] */ BOOL fDiscoverable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalEvent( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDDeviceHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDDeviceHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDDeviceHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDDeviceHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IWSDDeviceHost * This,
            /* [in] */ 
            __in  LPCWSTR pszLocalId,
            /* [optional][in] */ IWSDXMLContext *pContext,
            /* [optional][in] */ IWSDAddress **ppHostAddresses,
            /* [optional][in] */ DWORD dwHostAddressCount);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWSDDeviceHost * This,
            /* [in] */ ULONGLONG ullInstanceId,
            /* [in] */ const WSD_URI_LIST *pScopeList,
            /* [optional][in] */ IWSDDeviceHostNotify *pNotificationSink);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWSDDeviceHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IWSDDeviceHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPortType )( 
            IWSDDeviceHost * This,
            /* [in] */ const WSD_PORT_TYPE *pPortType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMetadata )( 
            IWSDDeviceHost * This,
            /* [in] */ const WSD_THIS_MODEL_METADATA *pThisModelMetadata,
            /* [in] */ const WSD_THIS_DEVICE_METADATA *pThisDeviceMetadata,
            /* [optional][in] */ const WSD_HOST_METADATA *pHostMetadata,
            /* [optional][in] */ const WSD_METADATA_SECTION_LIST *pCustomMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterService )( 
            IWSDDeviceHost * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [in] */ IUnknown *pService);
        
        HRESULT ( STDMETHODCALLTYPE *RetireService )( 
            IWSDDeviceHost * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId);
        
        HRESULT ( STDMETHODCALLTYPE *AddDynamicService )( 
            IWSDDeviceHost * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [optional][in] */ 
            __in_opt  LPCWSTR pszEndpointAddress,
            /* [optional][in] */ const WSD_PORT_TYPE *pPortType,
            /* [optional][in] */ const WSDXML_NAME *pPortName,
            /* [optional][in] */ const WSDXML_ELEMENT *pAny,
            /* [optional][in] */ IUnknown *pService);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveDynamicService )( 
            IWSDDeviceHost * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId);
        
        HRESULT ( STDMETHODCALLTYPE *SetServiceDiscoverable )( 
            IWSDDeviceHost * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [in] */ BOOL fDiscoverable);
        
        HRESULT ( STDMETHODCALLTYPE *SignalEvent )( 
            IWSDDeviceHost * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [in] */ const void *pBody,
            /* [in] */ const WSD_OPERATION *pOperation);
        
        END_INTERFACE
    } IWSDDeviceHostVtbl;

    interface IWSDDeviceHost
    {
        CONST_VTBL struct IWSDDeviceHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDDeviceHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDDeviceHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDDeviceHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDDeviceHost_Init(This,pszLocalId,pContext,ppHostAddresses,dwHostAddressCount)	\
    ( (This)->lpVtbl -> Init(This,pszLocalId,pContext,ppHostAddresses,dwHostAddressCount) ) 

#define IWSDDeviceHost_Start(This,ullInstanceId,pScopeList,pNotificationSink)	\
    ( (This)->lpVtbl -> Start(This,ullInstanceId,pScopeList,pNotificationSink) ) 

#define IWSDDeviceHost_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IWSDDeviceHost_Terminate(This)	\
    ( (This)->lpVtbl -> Terminate(This) ) 

#define IWSDDeviceHost_RegisterPortType(This,pPortType)	\
    ( (This)->lpVtbl -> RegisterPortType(This,pPortType) ) 

#define IWSDDeviceHost_SetMetadata(This,pThisModelMetadata,pThisDeviceMetadata,pHostMetadata,pCustomMetadata)	\
    ( (This)->lpVtbl -> SetMetadata(This,pThisModelMetadata,pThisDeviceMetadata,pHostMetadata,pCustomMetadata) ) 

#define IWSDDeviceHost_RegisterService(This,pszServiceId,pService)	\
    ( (This)->lpVtbl -> RegisterService(This,pszServiceId,pService) ) 

#define IWSDDeviceHost_RetireService(This,pszServiceId)	\
    ( (This)->lpVtbl -> RetireService(This,pszServiceId) ) 

#define IWSDDeviceHost_AddDynamicService(This,pszServiceId,pszEndpointAddress,pPortType,pPortName,pAny,pService)	\
    ( (This)->lpVtbl -> AddDynamicService(This,pszServiceId,pszEndpointAddress,pPortType,pPortName,pAny,pService) ) 

#define IWSDDeviceHost_RemoveDynamicService(This,pszServiceId)	\
    ( (This)->lpVtbl -> RemoveDynamicService(This,pszServiceId) ) 

#define IWSDDeviceHost_SetServiceDiscoverable(This,pszServiceId,fDiscoverable)	\
    ( (This)->lpVtbl -> SetServiceDiscoverable(This,pszServiceId,fDiscoverable) ) 

#define IWSDDeviceHost_SignalEvent(This,pszServiceId,pBody,pOperation)	\
    ( (This)->lpVtbl -> SignalEvent(This,pszServiceId,pBody,pOperation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDDeviceHost_INTERFACE_DEFINED__ */


#ifndef __IWSDDeviceHostNotify_INTERFACE_DEFINED__
#define __IWSDDeviceHostNotify_INTERFACE_DEFINED__

/* interface IWSDDeviceHostNotify */
/* [restricted][unique][helpstring][uuid][object] */ 




EXTERN_C const IID IID_IWSDDeviceHostNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5bee9f9-eeda-41fe-96f7-f45e14990fb0")
    IWSDDeviceHostNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDDeviceHostNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDDeviceHostNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDDeviceHostNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDDeviceHostNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            IWSDDeviceHostNotify * This,
            /* [in] */ 
            __in  LPCWSTR pszServiceId,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppService);
        
        END_INTERFACE
    } IWSDDeviceHostNotifyVtbl;

    interface IWSDDeviceHostNotify
    {
        CONST_VTBL struct IWSDDeviceHostNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDDeviceHostNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDDeviceHostNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDDeviceHostNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDDeviceHostNotify_GetService(This,pszServiceId,ppService)	\
    ( (This)->lpVtbl -> GetService(This,pszServiceId,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDDeviceHostNotify_INTERFACE_DEFINED__ */


#ifndef __IWSDServiceMessaging_INTERFACE_DEFINED__
#define __IWSDServiceMessaging_INTERFACE_DEFINED__

/* interface IWSDServiceMessaging */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDServiceMessaging;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94974cf4-0cab-460d-a3f6-7a0ad623c0e6")
    IWSDServiceMessaging : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendResponse( 
            /* [in] */ void *pBody,
            /* [in] */ WSD_OPERATION *pOperation,
            /* [in] */ IWSDMessageParameters *pMessageParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FaultRequest( 
            /* [in] */ WSD_SOAP_HEADER *pRequestHeader,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [optional][in] */ WSD_SOAP_FAULT *pFault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDServiceMessagingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDServiceMessaging * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDServiceMessaging * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDServiceMessaging * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendResponse )( 
            IWSDServiceMessaging * This,
            /* [in] */ void *pBody,
            /* [in] */ WSD_OPERATION *pOperation,
            /* [in] */ IWSDMessageParameters *pMessageParameters);
        
        HRESULT ( STDMETHODCALLTYPE *FaultRequest )( 
            IWSDServiceMessaging * This,
            /* [in] */ WSD_SOAP_HEADER *pRequestHeader,
            /* [in] */ IWSDMessageParameters *pMessageParameters,
            /* [optional][in] */ WSD_SOAP_FAULT *pFault);
        
        END_INTERFACE
    } IWSDServiceMessagingVtbl;

    interface IWSDServiceMessaging
    {
        CONST_VTBL struct IWSDServiceMessagingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDServiceMessaging_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDServiceMessaging_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDServiceMessaging_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDServiceMessaging_SendResponse(This,pBody,pOperation,pMessageParameters)	\
    ( (This)->lpVtbl -> SendResponse(This,pBody,pOperation,pMessageParameters) ) 

#define IWSDServiceMessaging_FaultRequest(This,pRequestHeader,pMessageParameters,pFault)	\
    ( (This)->lpVtbl -> FaultRequest(This,pRequestHeader,pMessageParameters,pFault) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDServiceMessaging_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdtypes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Component: WSDAPI - Microsoft Web Services for Devices API
// 
//  File: wsdtypes.h
//
//  Abstract: WSDAPI Built-in Type Definitions
//
//  THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT MODIFY IT BY HAND.
//
//--------------------------------------------------------------------------
#pragma once

//
// Forward definitions
//
interface IWSDMessageParameters;   // wsdbase.idl
interface IWSDServiceMessaging;    // wsdhost.idl

// decl referenced base types
typedef struct _WSD_DURATION WSD_DURATION;
typedef struct _WSD_DATETIME WSD_DATETIME;

typedef struct _WSD_HANDLER_CONTEXT WSD_HANDLER_CONTEXT;
typedef struct _WSD_EVENT WSD_EVENT;

typedef HRESULT (*WSD_STUB_FUNCTION) (   
    IUnknown* server,
    IWSDServiceMessaging* session,
    WSD_EVENT* event
);

typedef enum _WSD_PROTOCOL_TYPE
{
    WSD_PT_NONE  = 0x00,
    WSD_PT_UDP   = 0x01,
    WSD_PT_HTTP  = 0x02,
    WSD_PT_HTTPS = 0x04,
    WSD_PT_ALL   = 0xff,
} WSD_PROTOCOL_TYPE;

typedef struct _WSD_OPERATION
{
    WSDXML_TYPE* RequestType;
    WSDXML_TYPE* ResponseType;
    WSD_STUB_FUNCTION RequestStubFunction;
} WSD_OPERATION;

//
// Context for handling incoming messages.
//
typedef 
HRESULT (*PWSD_SOAP_MESSAGE_HANDLER)(
    IUnknown* thisUnknown,
    WSD_EVENT* event);

//
// Context for handling incoming messages.
//
struct _WSD_HANDLER_CONTEXT
{
    PWSD_SOAP_MESSAGE_HANDLER Handler;
    void* PVoid;
    IUnknown* Unknown;
};

//
// WSDEventType distinguishes types of events produced by the session layer.
//
typedef enum _WSDEventType
{
    WSDET_NONE                 = 0,
    WSDET_INCOMING_MESSAGE     = 1,
    WSDET_INCOMING_FAULT       = 2,
    WSDET_TRANSMISSION_FAILURE = 3,
    WSDET_RESPONSE_TIMEOUT     = 4,
} WSDEventType;

typedef struct _WSD_SYNCHRONOUS_RESPONSE_CONTEXT
{
    HRESULT hr;
    HANDLE eventHandle;
    IWSDMessageParameters* messageParameters;
    void* results;
} WSD_SYNCHRONOUS_RESPONSE_CONTEXT;

typedef struct _WSD_PORT_TYPE
{
    DWORD EncodedName;
    DWORD OperationCount;
    WSD_OPERATION* Operations;
    WSD_PROTOCOL_TYPE ProtocolType;
} WSD_PORT_TYPE;

        
typedef struct _WSD_RELATIONSHIP_METADATA WSD_RELATIONSHIP_METADATA;
typedef struct _WSD_SERVICE_METADATA_LIST WSD_SERVICE_METADATA_LIST;
typedef struct _WSD_HOST_METADATA WSD_HOST_METADATA;
typedef struct _WSD_ENDPOINT_REFERENCE_LIST WSD_ENDPOINT_REFERENCE_LIST;
typedef struct _WSD_SERVICE_METADATA WSD_SERVICE_METADATA;
typedef struct _WSD_THIS_DEVICE_METADATA WSD_THIS_DEVICE_METADATA;
typedef struct _WSD_THIS_MODEL_METADATA WSD_THIS_MODEL_METADATA;
typedef struct _WSD_LOCALIZED_STRING_LIST WSD_LOCALIZED_STRING_LIST;
typedef struct _WSD_SOAP_FAULT_REASON WSD_SOAP_FAULT_REASON;
typedef struct _WSD_SOAP_FAULT_SUBCODE WSD_SOAP_FAULT_SUBCODE;
typedef struct _WSD_SOAP_FAULT_CODE WSD_SOAP_FAULT_CODE;
typedef struct _WSD_SOAP_FAULT WSD_SOAP_FAULT;
typedef struct _WSD_APP_SEQUENCE WSD_APP_SEQUENCE;
typedef struct _WSD_HEADER_RELATESTO WSD_HEADER_RELATESTO;
typedef struct _WSD_SOAP_HEADER WSD_SOAP_HEADER;
typedef struct _WSD_SOAP_MESSAGE WSD_SOAP_MESSAGE;
typedef struct _WSD_RESOLVE_MATCHES WSD_RESOLVE_MATCHES;
typedef struct _WSD_RESOLVE_MATCH WSD_RESOLVE_MATCH;
typedef struct _WSD_RESOLVE WSD_RESOLVE;
typedef struct _WSD_PROBE_MATCH WSD_PROBE_MATCH;
typedef struct _WSD_PROBE_MATCH_LIST WSD_PROBE_MATCH_LIST;
typedef struct _WSD_PROBE_MATCHES WSD_PROBE_MATCHES;
typedef struct _WSD_PROBE WSD_PROBE;
typedef struct _WSD_BYE WSD_BYE;
typedef struct _WSD_SCOPES WSD_SCOPES;
typedef struct _WSD_NAME_LIST WSD_NAME_LIST;
typedef struct _WSD_HELLO WSD_HELLO;
typedef struct _WSD_REFERENCE_PARAMETERS WSD_REFERENCE_PARAMETERS;
typedef struct _WSD_REFERENCE_PROPERTIES WSD_REFERENCE_PROPERTIES;
typedef struct _WSD_ENDPOINT_REFERENCE WSD_ENDPOINT_REFERENCE;
typedef struct _WSD_METADATA_SECTION WSD_METADATA_SECTION;
typedef struct _WSD_METADATA_SECTION_LIST WSD_METADATA_SECTION_LIST;
typedef struct _WSD_URI_LIST WSD_URI_LIST;
typedef struct _WSD_EVENTING_FILTER_ACTION WSD_EVENTING_FILTER_ACTION;
typedef struct _WSD_EVENTING_FILTER WSD_EVENTING_FILTER;
typedef struct _WSD_EVENTING_EXPIRES WSD_EVENTING_EXPIRES;
typedef struct _WSD_EVENTING_DELIVERY_MODE_PUSH WSD_EVENTING_DELIVERY_MODE_PUSH;
typedef struct _WSD_EVENTING_DELIVERY_MODE WSD_EVENTING_DELIVERY_MODE;
typedef struct _WSD_LOCALIZED_STRING WSD_LOCALIZED_STRING;

// 
// Structure definition WSD_RELATIONSHIP_METADATA
// 
struct _WSD_RELATIONSHIP_METADATA
{
    const WCHAR* Type;
    WSD_HOST_METADATA* Data;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_SERVICE_METADATA_LIST
// 
struct _WSD_SERVICE_METADATA_LIST
{
    WSD_SERVICE_METADATA_LIST* Next;
    WSD_SERVICE_METADATA* Element;
};

// 
// Structure definition WSD_HOST_METADATA
// 
struct _WSD_HOST_METADATA
{
    WSD_SERVICE_METADATA* Host; // optional
    WSD_SERVICE_METADATA_LIST* Hosted; // optional
};

// 
// Structure definition WSD_ENDPOINT_REFERENCE_LIST
// 
struct _WSD_ENDPOINT_REFERENCE_LIST
{
    WSD_ENDPOINT_REFERENCE_LIST* Next;
    WSD_ENDPOINT_REFERENCE* Element;
};

// 
// Structure definition WSD_SERVICE_METADATA
// 
struct _WSD_SERVICE_METADATA
{
    WSD_ENDPOINT_REFERENCE_LIST* EndpointReference;
    WSD_NAME_LIST* Types; // optional
    const WCHAR* ServiceId;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_THIS_DEVICE_METADATA
// 
struct _WSD_THIS_DEVICE_METADATA
{
    WSD_LOCALIZED_STRING_LIST* FriendlyName;
    const WCHAR* FirmwareVersion; // optional
    const WCHAR* SerialNumber; // optional
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_THIS_MODEL_METADATA
// 
struct _WSD_THIS_MODEL_METADATA
{
    WSD_LOCALIZED_STRING_LIST* Manufacturer;
    const WCHAR* ManufacturerUrl; // optional
    WSD_LOCALIZED_STRING_LIST* ModelName;
    const WCHAR* ModelNumber; // optional
    const WCHAR* ModelUrl; // optional
    const WCHAR* PresentationUrl; // optional
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_LOCALIZED_STRING_LIST
// 
struct _WSD_LOCALIZED_STRING_LIST
{
    WSD_LOCALIZED_STRING_LIST* Next;
    WSD_LOCALIZED_STRING* Element;
};

// 
// Structure definition WSD_SOAP_FAULT_REASON
// 
struct _WSD_SOAP_FAULT_REASON
{
    WSD_LOCALIZED_STRING_LIST* Text;
};

// 
// Structure definition WSD_SOAP_FAULT_SUBCODE
// 
struct _WSD_SOAP_FAULT_SUBCODE
{
    WSDXML_NAME* Value;
    WSD_SOAP_FAULT_SUBCODE* Subcode; // optional
};

// 
// Structure definition WSD_SOAP_FAULT_CODE
// 
struct _WSD_SOAP_FAULT_CODE
{
    WSDXML_NAME* Value;
    WSD_SOAP_FAULT_SUBCODE* Subcode; // optional
};

// 
// Structure definition WSD_SOAP_FAULT
// 
struct _WSD_SOAP_FAULT
{
    WSD_SOAP_FAULT_CODE* Code;
    WSD_SOAP_FAULT_REASON* Reason;
    const WCHAR* Node; // optional
    const WCHAR* Role; // optional
    WSDXML_ELEMENT* Detail; // optional
};

// 
// Structure definition WSD_APP_SEQUENCE
// 
struct _WSD_APP_SEQUENCE
{
    ULONGLONG InstanceId;
    const WCHAR* SequenceId; // optional
    ULONGLONG MessageNumber;
};

// 
// Structure definition WSD_HEADER_RELATESTO
// 
struct _WSD_HEADER_RELATESTO
{
    WSDXML_NAME* RelationshipType; // optional
    const WCHAR* MessageID;
};

// 
// Structure definition WSD_SOAP_HEADER
// 
struct _WSD_SOAP_HEADER
{
    const WCHAR* To;
    const WCHAR* Action;
    const WCHAR* MessageID; // optional
    WSD_HEADER_RELATESTO RelatesTo; // optional
    WSD_ENDPOINT_REFERENCE* ReplyTo; // optional
    WSD_ENDPOINT_REFERENCE* From; // optional
    WSD_ENDPOINT_REFERENCE* FaultTo; // optional
    WSD_APP_SEQUENCE* AppSequence; // optional
    WSDXML_ELEMENT* AnyHeaders;
};

// 
// Structure definition WSD_SOAP_MESSAGE
// 
struct _WSD_SOAP_MESSAGE
{
    WSD_SOAP_HEADER Header;
    void* Body;
    WSDXML_TYPE* BodyType;
};

// 
// Structure definition WSD_RESOLVE_MATCHES
// 
struct _WSD_RESOLVE_MATCHES
{
    WSD_RESOLVE_MATCH* ResolveMatch; // optional
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_RESOLVE_MATCH
// 
struct _WSD_RESOLVE_MATCH
{
    WSD_ENDPOINT_REFERENCE* EndpointReference;
    WSD_NAME_LIST* Types; // optional
    WSD_SCOPES* Scopes; // optional
    WSD_URI_LIST* XAddrs;
    ULONGLONG MetadataVersion;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_RESOLVE
// 
struct _WSD_RESOLVE
{
    WSD_ENDPOINT_REFERENCE* EndpointReference;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_PROBE_MATCH
// 
struct _WSD_PROBE_MATCH
{
    WSD_ENDPOINT_REFERENCE* EndpointReference;
    WSD_NAME_LIST* Types; // optional
    WSD_SCOPES* Scopes; // optional
    WSD_URI_LIST* XAddrs; // optional
    ULONGLONG MetadataVersion;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_PROBE_MATCH_LIST
// 
struct _WSD_PROBE_MATCH_LIST
{
    WSD_PROBE_MATCH_LIST* Next;
    WSD_PROBE_MATCH* Element;
};

// 
// Structure definition WSD_PROBE_MATCHES
// 
struct _WSD_PROBE_MATCHES
{
    WSD_PROBE_MATCH_LIST* ProbeMatch;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_PROBE
// 
struct _WSD_PROBE
{
    WSD_NAME_LIST* Types; // optional
    WSD_SCOPES* Scopes; // optional
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_BYE
// 
struct _WSD_BYE
{
    WSD_ENDPOINT_REFERENCE* EndpointReference;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_SCOPES
// 
struct _WSD_SCOPES
{
    const WCHAR* MatchBy; // optional
    WSD_URI_LIST* Scopes; // optional
};

// 
// Structure definition WSD_NAME_LIST
// 
struct _WSD_NAME_LIST
{
    WSD_NAME_LIST* Next;
    WSDXML_NAME* Element;
};

// 
// Structure definition WSD_HELLO
// 
struct _WSD_HELLO
{
    WSD_ENDPOINT_REFERENCE* EndpointReference;
    WSD_NAME_LIST* Types; // optional
    WSD_SCOPES* Scopes; // optional
    WSD_URI_LIST* XAddrs; // optional
    ULONGLONG MetadataVersion;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_REFERENCE_PARAMETERS
// 
struct _WSD_REFERENCE_PARAMETERS
{
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_REFERENCE_PROPERTIES
// 
struct _WSD_REFERENCE_PROPERTIES
{
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_ENDPOINT_REFERENCE
// 
struct _WSD_ENDPOINT_REFERENCE
{
    const WCHAR* Address;
    WSD_REFERENCE_PROPERTIES ReferenceProperties; // optional
    WSD_REFERENCE_PARAMETERS ReferenceParameters; // optional
    WSDXML_NAME* PortType; // optional
    WSDXML_NAME* ServiceName; // optional
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_METADATA_SECTION
// 
struct _WSD_METADATA_SECTION
{
    const WCHAR* Dialect;
    const WCHAR* Identifier; // optional
    void* Data;
    WSD_ENDPOINT_REFERENCE* MetadataReference;
    const WCHAR* Location;
    WSDXML_ELEMENT* Any; // optional
};

// 
// Structure definition WSD_METADATA_SECTION_LIST
// 
struct _WSD_METADATA_SECTION_LIST
{
    WSD_METADATA_SECTION_LIST* Next;
    WSD_METADATA_SECTION* Element;
};

// 
// Structure definition WSD_URI_LIST
// 
struct _WSD_URI_LIST
{
    WSD_URI_LIST* Next;
    const WCHAR* Element;
};

// 
// Structure definition WSD_EVENTING_FILTER_ACTION
// 
struct _WSD_EVENTING_FILTER_ACTION
{
    WSD_URI_LIST* Actions;
};

// 
// Structure definition WSD_EVENTING_FILTER
// 
struct _WSD_EVENTING_FILTER
{
    const WCHAR* Dialect; // optional
    WSD_EVENTING_FILTER_ACTION* FilterAction;
    void* Data;
};

// 
// Structure definition WSD_EVENTING_EXPIRES
// 
struct _WSD_EVENTING_EXPIRES
{
    WSD_DURATION* Duration;
    WSD_DATETIME* DateTime;
};

// 
// Structure definition WSD_EVENTING_DELIVERY_MODE_PUSH
// 
struct _WSD_EVENTING_DELIVERY_MODE_PUSH
{
    WSD_ENDPOINT_REFERENCE* NotifyTo;
};

// 
// Structure definition WSD_EVENTING_DELIVERY_MODE
// 
struct _WSD_EVENTING_DELIVERY_MODE
{
    const WCHAR* Mode; // optional
    WSD_EVENTING_DELIVERY_MODE_PUSH* Push;
    void* Data;
};

// 
// Structure definition WSD_LOCALIZED_STRING
// 
struct _WSD_LOCALIZED_STRING
{
    const WCHAR* lang; // optional
    const WCHAR* String;
};

#define TYPE_ENCODING_WSD_RELATIONSHIP_METADATA WSDXML_TYPE_ENCODING(0,0)
extern WSDXML_TYPE Type_WSD_RELATIONSHIP_METADATA;

#define TYPE_ENCODING_WSD_HOST_METADATA WSDXML_TYPE_ENCODING(1,0)
extern WSDXML_TYPE Type_WSD_HOST_METADATA;

#define TYPE_ENCODING_WSD_SERVICE_METADATA WSDXML_TYPE_ENCODING(2,0)
extern WSDXML_TYPE Type_WSD_SERVICE_METADATA;

#define TYPE_ENCODING_WSD_THIS_DEVICE_METADATA WSDXML_TYPE_ENCODING(3,0)
extern WSDXML_TYPE Type_WSD_THIS_DEVICE_METADATA;

#define TYPE_ENCODING_WSD_THIS_MODEL_METADATA WSDXML_TYPE_ENCODING(4,0)
extern WSDXML_TYPE Type_WSD_THIS_MODEL_METADATA;

#define TYPE_ENCODING_WSD_SOAP_FAULT_REASON WSDXML_TYPE_ENCODING(5,0)
extern WSDXML_TYPE Type_WSD_SOAP_FAULT_REASON;

#define TYPE_ENCODING_WSD_SOAP_FAULT_SUBCODE WSDXML_TYPE_ENCODING(6,0)
extern WSDXML_TYPE Type_WSD_SOAP_FAULT_SUBCODE;

#define TYPE_ENCODING_WSD_SOAP_FAULT_CODE WSDXML_TYPE_ENCODING(7,0)
extern WSDXML_TYPE Type_WSD_SOAP_FAULT_CODE;

#define TYPE_ENCODING_WSD_SOAP_FAULT WSDXML_TYPE_ENCODING(8,0)
extern WSDXML_TYPE Type_WSD_SOAP_FAULT;

#define TYPE_ENCODING_WSD_APP_SEQUENCE WSDXML_TYPE_ENCODING(9,0)
extern WSDXML_TYPE Type_WSD_APP_SEQUENCE;

#define TYPE_ENCODING_WSD_HEADER_RELATESTO WSDXML_TYPE_ENCODING(10,0)
extern WSDXML_TYPE Type_WSD_HEADER_RELATESTO;

#define TYPE_ENCODING_WSD_SOAP_HEADER WSDXML_TYPE_ENCODING(11,0)
extern WSDXML_TYPE Type_WSD_SOAP_HEADER;

#define TYPE_ENCODING_WSD_SOAP_MESSAGE WSDXML_TYPE_ENCODING(12,0)
extern WSDXML_TYPE Type_WSD_SOAP_MESSAGE;

#define TYPE_ENCODING_WSD_RESOLVE_MATCHES WSDXML_TYPE_ENCODING(13,0)
extern WSDXML_TYPE Type_WSD_RESOLVE_MATCHES;

#define TYPE_ENCODING_WSD_RESOLVE_MATCH WSDXML_TYPE_ENCODING(14,0)
extern WSDXML_TYPE Type_WSD_RESOLVE_MATCH;

#define TYPE_ENCODING_WSD_RESOLVE WSDXML_TYPE_ENCODING(15,0)
extern WSDXML_TYPE Type_WSD_RESOLVE;

#define TYPE_ENCODING_WSD_PROBE_MATCH WSDXML_TYPE_ENCODING(16,0)
extern WSDXML_TYPE Type_WSD_PROBE_MATCH;

#define TYPE_ENCODING_WSD_PROBE_MATCHES WSDXML_TYPE_ENCODING(17,0)
extern WSDXML_TYPE Type_WSD_PROBE_MATCHES;

#define TYPE_ENCODING_WSD_PROBE WSDXML_TYPE_ENCODING(18,0)
extern WSDXML_TYPE Type_WSD_PROBE;

#define TYPE_ENCODING_WSD_BYE WSDXML_TYPE_ENCODING(19,0)
extern WSDXML_TYPE Type_WSD_BYE;

#define TYPE_ENCODING_WSD_SCOPES WSDXML_TYPE_ENCODING(20,0)
extern WSDXML_TYPE Type_WSD_SCOPES;

#define TYPE_ENCODING_WSD_HELLO WSDXML_TYPE_ENCODING(21,0)
extern WSDXML_TYPE Type_WSD_HELLO;

#define TYPE_ENCODING_WSD_REFERENCE_PARAMETERS WSDXML_TYPE_ENCODING(22,0)
extern WSDXML_TYPE Type_WSD_REFERENCE_PARAMETERS;

#define TYPE_ENCODING_WSD_REFERENCE_PROPERTIES WSDXML_TYPE_ENCODING(23,0)
extern WSDXML_TYPE Type_WSD_REFERENCE_PROPERTIES;

#define TYPE_ENCODING_WSD_ENDPOINT_REFERENCE WSDXML_TYPE_ENCODING(24,0)
extern WSDXML_TYPE Type_WSD_ENDPOINT_REFERENCE;

#define TYPE_ENCODING_WSD_METADATA_SECTION WSDXML_TYPE_ENCODING(25,0)
extern WSDXML_TYPE Type_WSD_METADATA_SECTION;

#define TYPE_ENCODING_WSD_EVENTING_FILTER_ACTION WSDXML_TYPE_ENCODING(26,0)
extern WSDXML_TYPE Type_WSD_EVENTING_FILTER_ACTION;

#define TYPE_ENCODING_WSD_EVENTING_FILTER WSDXML_TYPE_ENCODING(27,0)
extern WSDXML_TYPE Type_WSD_EVENTING_FILTER;

#define TYPE_ENCODING_WSD_EVENTING_EXPIRES WSDXML_TYPE_ENCODING(28,0)
extern WSDXML_TYPE Type_WSD_EVENTING_EXPIRES;

#define TYPE_ENCODING_WSD_EVENTING_DELIVERY_MODE_PUSH WSDXML_TYPE_ENCODING(29,0)
extern WSDXML_TYPE Type_WSD_EVENTING_DELIVERY_MODE_PUSH;

#define TYPE_ENCODING_WSD_EVENTING_DELIVERY_MODE WSDXML_TYPE_ENCODING(30,0)
extern WSDXML_TYPE Type_WSD_EVENTING_DELIVERY_MODE;

#define TYPE_ENCODING_WSD_LOCALIZED_STRING WSDXML_TYPE_ENCODING(31,0)
extern WSDXML_TYPE Type_WSD_LOCALIZED_STRING;


extern WSDXML_TYPE* WSDTypes[32];
#define WSDRegisterTypes(pContext) pContext->SetTypes(WSDTypes,(sizeof(WSDTypes) / sizeof(WSDTypes[0])),0)

//
// Port type http://schemas.xmlsoap.org/ws/2004/09/mex/mex
// Message structure definitions
//
typedef struct
{
    WSD_METADATA_SECTION_LIST* Metadata;
}
RESPONSEBODY_GetMetadata;

//
// Port type http://schemas.xmlsoap.org/ws/2004/08/eventing/Eventing
// Message structure definitions
//
typedef struct
{
    WSD_ENDPOINT_REFERENCE* EndTo;
    WSD_EVENTING_DELIVERY_MODE* Delivery;
    WSD_EVENTING_EXPIRES* Expires;
    WSD_EVENTING_FILTER* Filter;
    WSDXML_ELEMENT* Any;
}
REQUESTBODY_Subscribe;

typedef struct
{
    WSD_ENDPOINT_REFERENCE* SubscriptionManager;
    WSD_EVENTING_EXPIRES* expires;
    WSDXML_ELEMENT* any;
}
RESPONSEBODY_Subscribe;

typedef struct
{
    WSD_EVENTING_EXPIRES* Expires;
    WSDXML_ELEMENT* Any;
}
REQUESTBODY_Renew;

typedef struct
{
    WSD_EVENTING_EXPIRES* expires;
    WSDXML_ELEMENT* any;
}
RESPONSEBODY_Renew;

typedef struct
{
    WSDXML_ELEMENT* Any;
}
REQUESTBODY_GetStatus;

typedef struct
{
    WSD_EVENTING_EXPIRES* expires;
    WSDXML_ELEMENT* any;
}
RESPONSEBODY_GetStatus;

typedef struct
{
    WSDXML_ELEMENT* any;
}
REQUESTBODY_Unsubscribe;

//
// Port type http://schemas.xmlsoap.org/ws/2004/08/eventing/EventSink
// Message structure definitions
//
typedef struct
{
    WSD_ENDPOINT_REFERENCE* SubscriptionManager;
    const WCHAR* Status;
    WSD_LOCALIZED_STRING* Reason;
    WSDXML_ELEMENT* Any;
}
RESPONSEBODY_SubscriptionEnd;

 

typedef struct _WSD_UNKNOWN_LOOKUP
{
    WSDXML_ELEMENT* Any;
} WSD_UNKNOWN_LOOKUP;

struct _WSD_EVENT
{
    HRESULT Hr;
    DWORD EventType;
    WCHAR* DispatchTag;
    WSD_HANDLER_CONTEXT HandlerContext;
    WSD_SOAP_MESSAGE* Soap;
    WSD_OPERATION* Operation;
    IWSDMessageParameters* MessageParameters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdxmldom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Component: WSDAPI - Microsoft Web Services for Devices API
// 
//  File: wsdxmldom.h
//
//  Abstract: WSDAPI XML Type Definitions
//
//--------------------------------------------------------------------------
#pragma once

// pragma once does not guard properly when included into .idl
#ifndef __WSDXMLDOM_H__
#define __WSDXMLDOM_H__

typedef struct _WSDXML_NAMESPACE WSDXML_NAMESPACE;
typedef struct _WSDXML_NAME WSDXML_NAME;
typedef struct _WSDXML_TYPE WSDXML_TYPE;
typedef struct _WSDXML_PREFIX_MAPPING WSDXML_PREFIX_MAPPING;
typedef struct _WSDXML_ATTRIBUTE WSDXML_ATTRIBUTE;
typedef struct _WSDXML_NODE WSDXML_NODE;
typedef struct _WSDXML_ELEMENT WSDXML_ELEMENT;
typedef struct _WSDXML_TEXT WSDXML_TEXT;
typedef struct _WSDXML_ELEMENT_LIST WSDXML_ELEMENT_LIST;

struct _WSDXML_NAMESPACE
{
    const WCHAR* Uri;
    const WCHAR* PreferredPrefix;
    WSDXML_NAME* Names;
    WORD NamesCount;
    WORD Encoding;
};

struct _WSDXML_NAME
{
    WSDXML_NAMESPACE* Space;
    WCHAR* LocalName;
};

struct _WSDXML_TYPE
{
    const WCHAR* Uri;
    const BYTE* Table;
};

struct _WSDXML_PREFIX_MAPPING
{
    DWORD Refs;
    WSDXML_PREFIX_MAPPING* Next;
    WSDXML_NAMESPACE* Space;
    WCHAR* Prefix;
};

struct _WSDXML_ATTRIBUTE
{
    WSDXML_ELEMENT* Element;
    WSDXML_ATTRIBUTE* Next;
    WSDXML_NAME* Name;
    WCHAR* Value;
};

struct _WSDXML_NODE
{
    enum
    {   
        ElementType,
        TextType
    } Type;
    WSDXML_ELEMENT* Parent;
    WSDXML_NODE* Next;
};

struct _WSDXML_ELEMENT
{
    WSDXML_NODE Node;
    WSDXML_NAME* Name;
    WSDXML_ATTRIBUTE* FirstAttribute;
    WSDXML_NODE* FirstChild;
    WSDXML_PREFIX_MAPPING* PrefixMappings;
};

struct _WSDXML_TEXT
{
	WSDXML_NODE Node;
    WCHAR* Text;
};

struct _WSDXML_ELEMENT_LIST
{
    WSDXML_ELEMENT_LIST* Next;
    WSDXML_ELEMENT* Element;
};

#endif //  __WSDXMLDOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdns.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Component: WSDAPI - Microsoft Web Services for Devices API
// 
//  File: wsdns.h
//
//  Abstract: WSDAPI Namespace Definitions
//
//  THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT MODIFY IT BY HAND.
//
//--------------------------------------------------------------------------
#pragma once

    
// 
// Namespace http://schemas.xmlsoap.org/ws/2004/08/eventing
// 
#define NAMESPACE_ENCODING_EVENTING WSDXML_NAMESPACE_ENCODING(0,0)
extern WSDXML_NAME Names_Eventing[];
extern WSDXML_NAMESPACE Namespace_Eventing;


#define WSE_Identifier                         WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_EVENTING)
#define WSE_DeliveryModeRequestedUnavailable   WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_EVENTING)
#define WSE_InvalidExpirationTime              WSDXML_NAME_ENCODING(2,NAMESPACE_ENCODING_EVENTING)
#define WSE_UnsupportedExpirationTime          WSDXML_NAME_ENCODING(3,NAMESPACE_ENCODING_EVENTING)
#define WSE_FilteringNotSupported              WSDXML_NAME_ENCODING(4,NAMESPACE_ENCODING_EVENTING)
#define WSE_FilteringRequestedUnavailable      WSDXML_NAME_ENCODING(5,NAMESPACE_ENCODING_EVENTING)
#define WSE_EventSourceUnableToProcess         WSDXML_NAME_ENCODING(6,NAMESPACE_ENCODING_EVENTING)
#define WSE_UnableToRenew                      WSDXML_NAME_ENCODING(7,NAMESPACE_ENCODING_EVENTING)
#define WSE_InvalidMessage                     WSDXML_NAME_ENCODING(8,NAMESPACE_ENCODING_EVENTING)
#define WSE_SupportedDialect                   WSDXML_NAME_ENCODING(9,NAMESPACE_ENCODING_EVENTING)
#define WSE_SupportedDeliveryMode              WSDXML_NAME_ENCODING(10,NAMESPACE_ENCODING_EVENTING)
#define WSE_Eventing                           WSDXML_NAME_ENCODING(11,NAMESPACE_ENCODING_EVENTING)
#define WSE_Subscribe                          WSDXML_NAME_ENCODING(12,NAMESPACE_ENCODING_EVENTING)
#define WSE_SubscribeResponse                  WSDXML_NAME_ENCODING(13,NAMESPACE_ENCODING_EVENTING)
#define WSE_ReturnValue                        WSDXML_NAME_ENCODING(14,NAMESPACE_ENCODING_EVENTING)
#define WSE_EndTo                              WSDXML_NAME_ENCODING(15,NAMESPACE_ENCODING_EVENTING)
#define WSE_Mode                               WSDXML_NAME_ENCODING(16,NAMESPACE_ENCODING_EVENTING)
#define WSE_Push                               WSDXML_NAME_ENCODING(17,NAMESPACE_ENCODING_EVENTING)
#define WSE_NotifyTo                           WSDXML_NAME_ENCODING(18,NAMESPACE_ENCODING_EVENTING)
#define WSE_Data                               WSDXML_NAME_ENCODING(19,NAMESPACE_ENCODING_EVENTING)
#define WSE_Delivery                           WSDXML_NAME_ENCODING(20,NAMESPACE_ENCODING_EVENTING)
#define WSE_Duration                           WSDXML_NAME_ENCODING(21,NAMESPACE_ENCODING_EVENTING)
#define WSE_DateTime                           WSDXML_NAME_ENCODING(22,NAMESPACE_ENCODING_EVENTING)
#define WSE_Expires                            WSDXML_NAME_ENCODING(23,NAMESPACE_ENCODING_EVENTING)
#define WSE_Dialect                            WSDXML_NAME_ENCODING(24,NAMESPACE_ENCODING_EVENTING)
#define WSE_FilterAction                       WSDXML_NAME_ENCODING(25,NAMESPACE_ENCODING_EVENTING)
#define WSE_Filter                             WSDXML_NAME_ENCODING(26,NAMESPACE_ENCODING_EVENTING)
#define WSE_Any                                WSDXML_NAME_ENCODING(27,NAMESPACE_ENCODING_EVENTING)
#define WSE_SubscriptionManager                WSDXML_NAME_ENCODING(28,NAMESPACE_ENCODING_EVENTING)
#define WSE_Any1                               WSDXML_NAME_ENCODING(29,NAMESPACE_ENCODING_EVENTING)
#define WSE_Renew                              WSDXML_NAME_ENCODING(30,NAMESPACE_ENCODING_EVENTING)
#define WSE_RenewResponse                      WSDXML_NAME_ENCODING(31,NAMESPACE_ENCODING_EVENTING)
#define WSE_GetStatus                          WSDXML_NAME_ENCODING(32,NAMESPACE_ENCODING_EVENTING)
#define WSE_GetStatusResponse                  WSDXML_NAME_ENCODING(33,NAMESPACE_ENCODING_EVENTING)
#define WSE_Unsubscribe                        WSDXML_NAME_ENCODING(34,NAMESPACE_ENCODING_EVENTING)
#define WSE_UnsubscribeResponse                WSDXML_NAME_ENCODING(35,NAMESPACE_ENCODING_EVENTING)
#define WSE_EventSink                          WSDXML_NAME_ENCODING(36,NAMESPACE_ENCODING_EVENTING)
#define WSE_SubscriptionEnd                    WSDXML_NAME_ENCODING(37,NAMESPACE_ENCODING_EVENTING)
#define WSE_Status                             WSDXML_NAME_ENCODING(38,NAMESPACE_ENCODING_EVENTING)
#define WSE_String                             WSDXML_NAME_ENCODING(39,NAMESPACE_ENCODING_EVENTING)
#define WSE_Reason                             WSDXML_NAME_ENCODING(40,NAMESPACE_ENCODING_EVENTING)

// 
// Namespace http://schemas.xmlsoap.org/ws/2004/08/addressing
// 
#define NAMESPACE_ENCODING_ADDRESSING WSDXML_NAMESPACE_ENCODING(1,0)
extern WSDXML_NAME Names_Addressing[];
extern WSDXML_NAMESPACE Namespace_Addressing;


#define WSA_EndpointReference                  WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_Address                            WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_ReferenceParameters                WSDXML_NAME_ENCODING(2,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_PortType                           WSDXML_NAME_ENCODING(3,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_ServiceName                        WSDXML_NAME_ENCODING(4,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_PortName                           WSDXML_NAME_ENCODING(5,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_MessageID                          WSDXML_NAME_ENCODING(6,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_RelatesTo                          WSDXML_NAME_ENCODING(7,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_RelationshipType                   WSDXML_NAME_ENCODING(8,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_Reply                              WSDXML_NAME_ENCODING(9,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_ReplyTo                            WSDXML_NAME_ENCODING(10,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_From                               WSDXML_NAME_ENCODING(11,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_FaultTo                            WSDXML_NAME_ENCODING(12,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_To                                 WSDXML_NAME_ENCODING(13,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_Action                             WSDXML_NAME_ENCODING(14,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_Recipient                          WSDXML_NAME_ENCODING(15,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_InvalidMessageInformationHeader    WSDXML_NAME_ENCODING(16,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_MessageInformationHeaderRequired   WSDXML_NAME_ENCODING(17,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_DestinationUnreachable             WSDXML_NAME_ENCODING(18,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_ActionNotSupported                 WSDXML_NAME_ENCODING(19,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_EndpointUnavailable                WSDXML_NAME_ENCODING(20,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_ReferenceProperties                WSDXML_NAME_ENCODING(21,NAMESPACE_ENCODING_ADDRESSING)
#define WSA_Element                            WSDXML_NAME_ENCODING(22,NAMESPACE_ENCODING_ADDRESSING)

// 
// Namespace http://schemas.xmlsoap.org/ws/2005/04/discovery
// 
#define NAMESPACE_ENCODING_DISCOVERY WSDXML_NAMESPACE_ENCODING(2,0)
extern WSDXML_NAME Names_Discovery[];
extern WSDXML_NAMESPACE Namespace_Discovery;


#define WSDISCO_Hello             WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_Bye               WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_Probe             WSDXML_NAME_ENCODING(2,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_ProbeMatches      WSDXML_NAME_ENCODING(3,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_ProbeMatch        WSDXML_NAME_ENCODING(4,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_Resolve           WSDXML_NAME_ENCODING(5,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_ResolveMatch      WSDXML_NAME_ENCODING(6,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_Types             WSDXML_NAME_ENCODING(7,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_Scopes            WSDXML_NAME_ENCODING(8,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_MetadataVersion   WSDXML_NAME_ENCODING(9,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_Transport         WSDXML_NAME_ENCODING(10,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_AppSequence       WSDXML_NAME_ENCODING(11,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_InstanceId        WSDXML_NAME_ENCODING(12,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_SequenceId        WSDXML_NAME_ENCODING(13,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_MessageNumber     WSDXML_NAME_ENCODING(14,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_MatchBy           WSDXML_NAME_ENCODING(15,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_XAddrs            WSDXML_NAME_ENCODING(16,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_DiscoveryProxy    WSDXML_NAME_ENCODING(17,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_TargetService     WSDXML_NAME_ENCODING(18,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_Element           WSDXML_NAME_ENCODING(19,NAMESPACE_ENCODING_DISCOVERY)
#define WSDISCO_ResolveMatches    WSDXML_NAME_ENCODING(20,NAMESPACE_ENCODING_DISCOVERY)

// 
// Namespace http://www.w3.org/2004/08/xop/include
// 
#define NAMESPACE_ENCODING_INCLUDE WSDXML_NAMESPACE_ENCODING(3,0)
extern WSDXML_NAME Names_Include[];
extern WSDXML_NAMESPACE Namespace_Include;


#define XOP_Include   WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_INCLUDE)
#define XOP_Href      WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_INCLUDE)

// 
// Namespace http://www.w3.org/XML/1998/namespace
// 
#define NAMESPACE_ENCODING_XML WSDXML_NAMESPACE_ENCODING(4,0)
extern WSDXML_NAME Names_XML[];
extern WSDXML_NAMESPACE Namespace_XML;


#define XML_Lang    WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_XML)
#define XML_Space   WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_XML)

// 
// Namespace http://schemas.xmlsoap.org/ws/2006/02/devprof
// 
#define NAMESPACE_ENCODING_DEVPROF WSDXML_NAMESPACE_ENCODING(5,0)
extern WSDXML_NAME Names_Devprof[];
extern WSDXML_NAMESPACE Namespace_Devprof;


#define WSD_Device                     WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_DEVPROF)
#define WSD_FilterActionNotSupported   WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Actions                    WSDXML_NAME_ENCODING(2,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Element                    WSDXML_NAME_ENCODING(3,NAMESPACE_ENCODING_DEVPROF)
#define WSD_ThisModel                  WSDXML_NAME_ENCODING(4,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Manufacturer               WSDXML_NAME_ENCODING(5,NAMESPACE_ENCODING_DEVPROF)
#define WSD_ManufacturerUrl            WSDXML_NAME_ENCODING(6,NAMESPACE_ENCODING_DEVPROF)
#define WSD_ModelName                  WSDXML_NAME_ENCODING(7,NAMESPACE_ENCODING_DEVPROF)
#define WSD_ModelNumber                WSDXML_NAME_ENCODING(8,NAMESPACE_ENCODING_DEVPROF)
#define WSD_ModelUrl                   WSDXML_NAME_ENCODING(9,NAMESPACE_ENCODING_DEVPROF)
#define WSD_PresentationUrl            WSDXML_NAME_ENCODING(10,NAMESPACE_ENCODING_DEVPROF)
#define WSD_ThisDevice                 WSDXML_NAME_ENCODING(11,NAMESPACE_ENCODING_DEVPROF)
#define WSD_FriendlyName               WSDXML_NAME_ENCODING(12,NAMESPACE_ENCODING_DEVPROF)
#define WSD_FirmwareVersion            WSDXML_NAME_ENCODING(13,NAMESPACE_ENCODING_DEVPROF)
#define WSD_SerialNumber               WSDXML_NAME_ENCODING(14,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Types                      WSDXML_NAME_ENCODING(15,NAMESPACE_ENCODING_DEVPROF)
#define WSD_ServiceId                  WSDXML_NAME_ENCODING(16,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Host                       WSDXML_NAME_ENCODING(17,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Hosted                     WSDXML_NAME_ENCODING(18,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Relationship               WSDXML_NAME_ENCODING(19,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Type                       WSDXML_NAME_ENCODING(20,NAMESPACE_ENCODING_DEVPROF)
#define WSD_Data                       WSDXML_NAME_ENCODING(21,NAMESPACE_ENCODING_DEVPROF)

// 
// Namespace http://schemas.xmlsoap.org/ws/2004/09/mex
// 
#define NAMESPACE_ENCODING_MEX WSDXML_NAMESPACE_ENCODING(6,0)
extern WSDXML_NAME Names_Mex[];
extern WSDXML_NAMESPACE Namespace_Mex;


#define WSX_Mex                   WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_MEX)
#define WSX_GetMetadata           WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_MEX)
#define WSX_GetMetadataResponse   WSDXML_NAME_ENCODING(2,NAMESPACE_ENCODING_MEX)
#define WSX_ReturnValue           WSDXML_NAME_ENCODING(3,NAMESPACE_ENCODING_MEX)
#define WSX_MetadataSection       WSDXML_NAME_ENCODING(4,NAMESPACE_ENCODING_MEX)
#define WSX_Dialect               WSDXML_NAME_ENCODING(5,NAMESPACE_ENCODING_MEX)
#define WSX_Identifier            WSDXML_NAME_ENCODING(6,NAMESPACE_ENCODING_MEX)
#define WSX_Data                  WSDXML_NAME_ENCODING(7,NAMESPACE_ENCODING_MEX)
#define WSX_MetadataReference     WSDXML_NAME_ENCODING(8,NAMESPACE_ENCODING_MEX)
#define WSX_Location              WSDXML_NAME_ENCODING(9,NAMESPACE_ENCODING_MEX)
#define WSX_Element               WSDXML_NAME_ENCODING(10,NAMESPACE_ENCODING_MEX)
#define WSX_Metadata              WSDXML_NAME_ENCODING(11,NAMESPACE_ENCODING_MEX)

// 
// Namespace http://www.w3.org/2003/05/soap-envelope
// 
#define NAMESPACE_ENCODING_ENVELOPE WSDXML_NAMESPACE_ENCODING(7,0)
extern WSDXML_NAME Names_Envelope[];
extern WSDXML_NAMESPACE Namespace_Envelope;


#define SOAP_Envelope              WSDXML_NAME_ENCODING(0,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Header                WSDXML_NAME_ENCODING(1,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Body                  WSDXML_NAME_ENCODING(2,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_MustUnderstand        WSDXML_NAME_ENCODING(3,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Role                  WSDXML_NAME_ENCODING(4,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Actor                 WSDXML_NAME_ENCODING(5,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Fault                 WSDXML_NAME_ENCODING(6,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Code                  WSDXML_NAME_ENCODING(7,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Subcode               WSDXML_NAME_ENCODING(8,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Value                 WSDXML_NAME_ENCODING(9,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Reason                WSDXML_NAME_ENCODING(10,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Text                  WSDXML_NAME_ENCODING(11,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Node                  WSDXML_NAME_ENCODING(12,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Role1                 WSDXML_NAME_ENCODING(13,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Detail                WSDXML_NAME_ENCODING(14,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Upgrade               WSDXML_NAME_ENCODING(15,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_SupportedEnvelope     WSDXML_NAME_ENCODING(16,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_NotUnderstood         WSDXML_NAME_ENCODING(17,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_VersionMismatch       WSDXML_NAME_ENCODING(18,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_MustUnderstand1       WSDXML_NAME_ENCODING(19,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_DataEncodingUnknown   WSDXML_NAME_ENCODING(20,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Sender                WSDXML_NAME_ENCODING(21,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Receiver              WSDXML_NAME_ENCODING(22,NAMESPACE_ENCODING_ENVELOPE)
#define SOAP_Element               WSDXML_NAME_ENCODING(23,NAMESPACE_ENCODING_ENVELOPE)

extern WSDXML_NAMESPACE* WSDNamespaces[8];
#define WSDRegisterNamespaces(pContext) pContext->SetNamespaces(WSDNamespaces,(sizeof(WSDNamespaces) / sizeof(WSDNamespaces[0])),0)

// 
// Port type http://schemas.xmlsoap.org/ws/2004/09/mex/mex
// 
extern WSD_OPERATION Operations_mex[];
extern WSD_PORT_TYPE PortType_mex;

// 
// Port type http://schemas.xmlsoap.org/ws/2004/08/eventing/Eventing
// 
extern WSD_OPERATION Operations_Eventing[];
extern WSD_PORT_TYPE PortType_Eventing;

// 
// Port type http://schemas.xmlsoap.org/ws/2004/08/eventing/EventSink
// 
extern WSD_OPERATION Operations_EventSink[];
extern WSD_PORT_TYPE PortType_EventSink;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsdxml.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wsdxml.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsdxml_h__
#define __wsdxml_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSDXMLContext_FWD_DEFINED__
#define __IWSDXMLContext_FWD_DEFINED__
typedef interface IWSDXMLContext IWSDXMLContext;
#endif 	/* __IWSDXMLContext_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsdxml_0000_0000 */
/* [local] */ 


typedef struct _WSDXML_NAMESPACE WSDXML_NAMESPACE;

typedef struct _WSDXML_NAME WSDXML_NAME;

typedef struct _WSDXML_TYPE WSDXML_TYPE;

typedef struct _WSDXML_PREFIX_MAPPING WSDXML_PREFIX_MAPPING;

typedef struct _WSDXML_ATTRIBUTE WSDXML_ATTRIBUTE;

typedef struct _WSDXML_NODE WSDXML_NODE;

typedef struct _WSDXML_ELEMENT WSDXML_ELEMENT;

typedef struct _WSDXML_TEXT WSDXML_TEXT;

typedef struct _WSDXML_ELEMENT_LIST WSDXML_ELEMENT_LIST;

typedef const WSDXML_NAMESPACE *PCWSDXML_NAMESPACE;

typedef const WSDXML_TYPE *PCWSDXML_TYPE;

typedef struct _WSD_DATETIME
    {
    BOOL isPositive;
    ULONG year;
    UCHAR month;
    UCHAR day;
    UCHAR hour;
    UCHAR minute;
    UCHAR second;
    UINT millisecond;
    BOOL TZIsLocal;
    BOOL TZIsPositive;
    UCHAR TZHour;
    UCHAR TZMinute;
    } 	WSD_DATETIME;

typedef struct _WSD_DURATION
    {
    BOOL isPositive;
    ULONG year;
    ULONG month;
    ULONG day;
    ULONG hour;
    ULONG minute;
    ULONG second;
    ULONG millisecond;
    } 	WSD_DURATION;


enum __MIDL___MIDL_itf_wsdxml_0000_0000_0001
    {	OpNone	= 0,
	OpEndOfTable	= ( OpNone + 1 ) ,
	OpBeginElement_	= ( OpEndOfTable + 1 ) ,
	OpBeginAnyElement	= ( OpBeginElement_ + 1 ) ,
	OpEndElement	= ( OpBeginAnyElement + 1 ) ,
	OpElement_	= ( OpEndElement + 1 ) ,
	OpAnyElement	= ( OpElement_ + 1 ) ,
	OpAnyElements	= ( OpAnyElement + 1 ) ,
	OpAnyText	= ( OpAnyElements + 1 ) ,
	OpAttribute_	= ( OpAnyText + 1 ) ,
	OpBeginChoice	= ( OpAttribute_ + 1 ) ,
	OpEndChoice	= ( OpBeginChoice + 1 ) ,
	OpBeginSequence	= ( OpEndChoice + 1 ) ,
	OpEndSequence	= ( OpBeginSequence + 1 ) ,
	OpBeginAll	= ( OpEndSequence + 1 ) ,
	OpEndAll	= ( OpBeginAll + 1 ) ,
	OpAnything	= ( OpEndAll + 1 ) ,
	OpAnyNumber	= ( OpAnything + 1 ) ,
	OpOneOrMore	= ( OpAnyNumber + 1 ) ,
	OpOptional	= ( OpOneOrMore + 1 ) ,
	OpFormatBool_	= ( OpOptional + 1 ) ,
	OpFormatInt8_	= ( OpFormatBool_ + 1 ) ,
	OpFormatInt16_	= ( OpFormatInt8_ + 1 ) ,
	OpFormatInt32_	= ( OpFormatInt16_ + 1 ) ,
	OpFormatInt64_	= ( OpFormatInt32_ + 1 ) ,
	OpFormatUInt8_	= ( OpFormatInt64_ + 1 ) ,
	OpFormatUInt16_	= ( OpFormatUInt8_ + 1 ) ,
	OpFormatUInt32_	= ( OpFormatUInt16_ + 1 ) ,
	OpFormatUInt64_	= ( OpFormatUInt32_ + 1 ) ,
	OpFormatUnicodeString_	= ( OpFormatUInt64_ + 1 ) ,
	OpFormatDom_	= ( OpFormatUnicodeString_ + 1 ) ,
	OpFormatStruct_	= ( OpFormatDom_ + 1 ) ,
	OpFormatUri_	= ( OpFormatStruct_ + 1 ) ,
	OpFormatUuidUri_	= ( OpFormatUri_ + 1 ) ,
	OpFormatName_	= ( OpFormatUuidUri_ + 1 ) ,
	OpFormatListInsertTail_	= ( OpFormatName_ + 1 ) ,
	OpFormatType_	= ( OpFormatListInsertTail_ + 1 ) ,
	OpFormatDynamicType_	= ( OpFormatType_ + 1 ) ,
	OpFormatLookupType_	= ( OpFormatDynamicType_ + 1 ) ,
	OpFormatDuration_	= ( OpFormatLookupType_ + 1 ) ,
	OpFormatDateTime_	= ( OpFormatDuration_ + 1 ) ,
	OpFormatFloat_	= ( OpFormatDateTime_ + 1 ) ,
	OpFormatDouble_	= ( OpFormatFloat_ + 1 ) ,
	OpProcess_	= ( OpFormatDouble_ + 1 ) ,
	OpQualifiedAttribute_	= ( OpProcess_ + 1 ) ,
	OpFormatXMLDeclaration_	= ( OpQualifiedAttribute_ + 1 ) ,
	OpFormatMax	= ( OpFormatXMLDeclaration_ + 1 ) 
    } ;
#define OFFSET(type,field) ((DWORD_PTR)(&((type*)0)->field))
#define BYTE0(n) (BYTE)(((DWORD)n)>>0)
#define BYTE1(n) (BYTE)(((DWORD)n)>>8)
#define BYTE2(n) (BYTE)(((DWORD)n)>>16)
#define BYTE3(n) (BYTE)(((DWORD)n)>>24)
#define BYTES(n) BYTE0(n), BYTE1(n), BYTE2(n), BYTE3(n)
#define OpBeginElement(name)                    OpBeginElement_,        BYTES(name)
#define OpElement(name)                         OpElement_,             BYTES(name)
#define OpAttribute(name)                       OpAttribute_,           BYTES(name)
#define OpFormatBool(type,field,isptr)          OpFormatBool_,          BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatInt8(type,field,isptr)          OpFormatInt8_,          BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatInt16(type,field,isptr)         OpFormatInt16_,         BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatInt32(type,field,isptr)         OpFormatInt32_,         BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatInt64(type,field,isptr)         OpFormatInt64_,         BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatUInt8(type,field,isptr)         OpFormatUInt8_,         BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatUInt16(type,field,isptr)        OpFormatUInt16_,        BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatUInt32(type,field,isptr)        OpFormatUInt32_,        BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatUInt64(type,field,isptr)        OpFormatUInt64_,        BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatUnicodeString(type,field)       OpFormatUnicodeString_, BYTES(OFFSET(type,field))
#define OpFormatDom(type,field)                 OpFormatDom_,           BYTES(OFFSET(type,field))
#define OpFormatStruct(sType,type,field)        OpFormatStruct_,        BYTES(sizeof(sType)),BYTES(OFFSET(type,field))
#define OpFormatPointerToStruct(sType)          OpFormatStruct_,        BYTES(sizeof(sType)),BYTES(0)
#define OpFormatUri(type,field)                 OpFormatUri_,           BYTES(OFFSET(type,field))
#define OpFormatUuidUri(type,field,isptr)       OpFormatUuidUri_,       BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatName(type,field)                OpFormatName_,          BYTES(OFFSET(type,field))
#define OpFormatListInsertTail(s,type,field)    OpFormatListInsertTail_,BYTES(sizeof(s)),BYTES(OFFSET(type,field))
#define OpFormatType(table,type,field)          OpFormatType_,          BYTES(table),BYTES(OFFSET(type,field))
#define OpFormatDynamicType(name,type,field)    OpFormatDynamicType_,   BYTES(name),BYTES(OFFSET(type,field))
#define OpFormatLookupType(uriField,type,field) OpFormatLookupType_, BYTES(OFFSET(type,uriField)),BYTES(OFFSET(type,field))
#define OpFormatDuration(type,field)            OpFormatDuration_,      BYTES(OFFSET(type,field))
#define OpFormatDateTime(type,field)            OpFormatDateTime_,      BYTES(OFFSET(type,field))
#define OpFormatFloat(type,field,isptr)         OpFormatFloat_,         BYTES(isptr),BYTES(OFFSET(type,field))
#define OpFormatDouble(type,field,isptr)        OpFormatDouble_,        BYTES(isptr),BYTES(OFFSET(type,field))
#define OpProcess(type,field)                   OpProcess_,             BYTES(OFFSET(type,field))
#define OpQualifiedAttribute(name)              OpQualifiedAttribute_,  BYTES(name)
#define OpFormatXMLDeclaration(type,field)      OpFormatXMLDeclaration_,BYTES(OFFSET(type,field))
#define WSDXML_TYPE_ENCODING(typeIndex,layerNumber) ((((DWORD)layerNumber) << 28) | typeIndex)
#define WSDXML_NAMESPACE_ENCODING(namespaceIndex,layerNumber) ((((WORD)layerNumber) << 12) | namespaceIndex)
#define WSDXML_NAME_ENCODING(nameIndex,nameSpaceEncoding) ((((DWORD)nameSpaceEncoding) << 16) | nameIndex)
HRESULT WINAPI
WSDXMLGetNameFromBuiltinNamespace(
    __in LPCWSTR pszNamespace,
    __in LPCWSTR pszName,
    WSDXML_NAME** ppName);
HRESULT WINAPI
WSDXMLCreateContext(
    IWSDXMLContext** ppContext);


extern RPC_IF_HANDLE __MIDL_itf_wsdxml_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsdxml_0000_0000_v0_0_s_ifspec;

#ifndef __IWSDXMLContext_INTERFACE_DEFINED__
#define __IWSDXMLContext_INTERFACE_DEFINED__

/* interface IWSDXMLContext */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSDXMLContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75d8f3ee-3e5a-43b4-a15a-bcf6887460c0")
    IWSDXMLContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddNamespace( 
            /* [in] */ LPCWSTR pszUri,
            /* [in] */ LPCWSTR pszSuggestedPrefix,
            /* [out] */ WSDXML_NAMESPACE **ppNamespace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddNameToNamespace( 
            /* [in] */ LPCWSTR pszUri,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WSDXML_NAME **ppName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamespaces( 
            /* [size_is][in] */ const PCWSDXML_NAMESPACE *pNamespaces,
            /* [in] */ WORD wNamespacesCount,
            /* [in] */ BYTE bLayerNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTypes( 
            /* [size_is][in] */ const PCWSDXML_TYPE *pTypes,
            /* [in] */ DWORD dwTypesCount,
            /* [in] */ BYTE bLayerNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDXMLContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDXMLContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDXMLContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDXMLContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddNamespace )( 
            IWSDXMLContext * This,
            /* [in] */ LPCWSTR pszUri,
            /* [in] */ LPCWSTR pszSuggestedPrefix,
            /* [out] */ WSDXML_NAMESPACE **ppNamespace);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameToNamespace )( 
            IWSDXMLContext * This,
            /* [in] */ LPCWSTR pszUri,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WSDXML_NAME **ppName);
        
        HRESULT ( STDMETHODCALLTYPE *SetNamespaces )( 
            IWSDXMLContext * This,
            /* [size_is][in] */ const PCWSDXML_NAMESPACE *pNamespaces,
            /* [in] */ WORD wNamespacesCount,
            /* [in] */ BYTE bLayerNumber);
        
        HRESULT ( STDMETHODCALLTYPE *SetTypes )( 
            IWSDXMLContext * This,
            /* [size_is][in] */ const PCWSDXML_TYPE *pTypes,
            /* [in] */ DWORD dwTypesCount,
            /* [in] */ BYTE bLayerNumber);
        
        END_INTERFACE
    } IWSDXMLContextVtbl;

    interface IWSDXMLContext
    {
        CONST_VTBL struct IWSDXMLContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDXMLContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDXMLContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDXMLContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDXMLContext_AddNamespace(This,pszUri,pszSuggestedPrefix,ppNamespace)	\
    ( (This)->lpVtbl -> AddNamespace(This,pszUri,pszSuggestedPrefix,ppNamespace) ) 

#define IWSDXMLContext_AddNameToNamespace(This,pszUri,pszName,ppName)	\
    ( (This)->lpVtbl -> AddNameToNamespace(This,pszUri,pszName,ppName) ) 

#define IWSDXMLContext_SetNamespaces(This,pNamespaces,wNamespacesCount,bLayerNumber)	\
    ( (This)->lpVtbl -> SetNamespaces(This,pNamespaces,wNamespacesCount,bLayerNumber) ) 

#define IWSDXMLContext_SetTypes(This,pTypes,dwTypesCount,bLayerNumber)	\
    ( (This)->lpVtbl -> SetTypes(This,pTypes,dwTypesCount,bLayerNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDXMLContext_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WShisotp.h ===
/* File: .streams.include.src/mod  wshisotp.h            Version: Initial */
/*
 *   wshisotp.h
 *   Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
 *
 *   Windows Sockets include file for ISO TP4.  This file contains all
 *   standardized ISO TP4 information.  Include this header file after
 *   winsock.h.
 *
 *   The information contained in this header file was originally
 *   created by Alcatel TITN Inc.
 */

#ifndef _WSHISOTP_
#define _WSHISOTP_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Protocol values for ISO transport protocols.
 */

#define ISOPROTO_TP0       25      /* connection orientated transport protocol */
#define ISOPROTO_TP1       26      /* not implemented */
#define ISOPROTO_TP2       27      /* not implemented */
#define ISOPROTO_TP3       28      /* not implemented */
#define ISOPROTO_TP4       29      /* connection orientated transport protocol */
#define ISOPROTO_TP        ISOPROTO_TP4
#define ISOPROTO_CLTP      30      /* connectionless transport */
#define ISOPROTO_CLNP      31      /* connectionless internetworking protocol */
#define ISOPROTO_X25       32      /* cons */
#define ISOPROTO_INACT_NL  33      /* inactive network layer */
#define ISOPROTO_ESIS      34      /* ES-IS protocol */
#define ISOPROTO_INTRAISIS 35      /* IS-IS protocol */

#define IPPROTO_RAW        255     /* raw clnp */
#define IPPROTO_MAX        256

/*
 *   The maximum size of the tranport address (tp_addr field of a
 *   sockaddr_tp structure) is 64.
 */

#define ISO_MAX_ADDR_LENGTH 64

/*
 *   There are two types of ISO addresses, hierarchical and
 *   non-hierarchical.  For hierarchical addresses, the tp_addr
 *   field contains both the transport selector and the network
 *   address.  For non-hierarchical addresses, tp_addr contains only
 *   the transport address, which must be translated by the ISO TP4
 *   transport provider into the transport selector and network address.
 */

#define ISO_HIERARCHICAL            0
#define ISO_NON_HIERARCHICAL        1

/*
 *   The format of the address structure (sockaddr) to pass to Windows
 *   Sockets APIs.
 *
 */

typedef struct sockaddr_tp {
   u_short tp_family;          /* Always AF_ISO */
   u_short tp_addr_type;       /* ISO_HIERARCHICAL or ISO_NON_HIERARCHICAL
*/
   u_short tp_taddr_len;       /* Length of transport address, <= 52 */
   u_short tp_tsel_len;        /* Length of transport selector, <= 32 */
                               /* 0 if ISO_NON_HIERARCHICAL */
   u_char tp_addr[ISO_MAX_ADDR_LENGTH];
} SOCKADDR_TP, *PSOCKADDR_TP, *LPSOCKADDR_TP;

#define ISO_SET_TP_ADDR(sa_tp, port, portlen, node, nodelen)              \
            (sa_tp)->tp_family = AF_ISO;                         \
            (sa_tp)->tp_addr_type = ISO_HIERARCHICAL;            \
            (sa_tp)->tp_tsel_len = (portlen);              \
            (sa_tp)->tp_taddr_len = (portlen) + (nodelen); \
            memcpy(&(sa_tp)->tp_addr, (port), (portlen)); \
            memcpy(&(sa_tp)->tp_addr[portlen], (node), (nodelen));


/*
 *   Expedited Data Usage Negotiation option.
 *   Default when the option is not present is be EXP_DATA_USE
 *   as per ISO 8073
 */

#define ISO_EXP_DATA_USE  00    /* Use of Expedited Data */
#define ISO_EXP_DATA_NUSE 01    /* Non-use of Expedited Data */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WSipx.h ===
/*
 *   wsipx.h
 *
 *   Microsoft Windows
 *   Copyright (C) Microsoft Corporation, 1992-1999.
 *
 *   Windows Sockets include file for IPX/SPX.  This file contains all
 *   standardized IPX/SPX information.  Include this header file after
 *   winsock.h.
 *
 *   To open an IPX socket, call socket() with an address family of
 *   AF_IPX, a socket type of SOCK_DGRAM, and protocol NSPROTO_IPX.
 *   Note that the protocol value must be specified, it cannot be 0.
 *   All IPX packets are sent with the packet type field of the IPX
 *   header set to 0.
 *
 *   To open an SPX or SPXII socket, call socket() with an address
 *   family of AF_IPX, socket type of SOCK_SEQPACKET or SOCK_STREAM,
 *   and protocol of NSPROTO_SPX or NSPROTO_SPXII.  If SOCK_SEQPACKET
 *   is specified, then the end of message bit is respected, and
 *   recv() calls are not completed until a packet is received with
 *   the end of message bit set.  If SOCK_STREAM is specified, then
 *   the end of message bit is not respected, and recv() completes
 *   as soon as any data is received, regardless of the setting of the
 *   end of message bit.  Send coalescing is never performed, and sends
 *   smaller than a single packet are always sent with the end of
 *   message bit set.  Sends larger than a single packet are packetized
 *   with the end of message bit set on only the last packet of the
 *   send.
 *
 */

#ifndef _WSIPX_
#define _WSIPX_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *   This is the structure of the SOCKADDR structure for IPX and SPX.
 *
 */

typedef struct sockaddr_ipx {
    short sa_family;
    char  sa_netnum[4];
    char  sa_nodenum[6];
    unsigned short sa_socket;
} SOCKADDR_IPX, *PSOCKADDR_IPX,FAR *LPSOCKADDR_IPX;

/*
 *   Protocol families used in the "protocol" parameter of the socket() API.
 *
 */

#define NSPROTO_IPX      1000
#define NSPROTO_SPX      1256
#define NSPROTO_SPXII    1257

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsipv6ok.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wsipv6ok.h
    
Abstract:

    This module contains defines used to flag usage of IPv6 incompatible
    defines, stuctures and functions.  They cause *cryptic* compile time
    error messages to be generated.  Currently, this header is only
    included from winsock2.h.

    NOTE: The compile time flag, IPV6STRICT, must be defined.

--*/

#ifndef _WSIPV6OK_
#define _WSIPV6OK_

#pragma once

#ifdef IPV6STRICT

//
// prevent substitutions in these headers by including them first.
//
#include <ws2tcpip.h>
#include <wspiapi.h>

#undef AF_INET
#define AF_INET AF_INET_IPV6INCOMPATIBLE
#undef PF_INET
#define PF_INET PF_INET_IPV6INCOMPATIBLE
#undef in_addr
#define in_addr in_addr_IPV6INCOMPATIBLE
#undef IN_ADDR
#define IN_ADDR IN_ADDR_IPV6INCOMPATIBLE
#undef PIN_ADDR
#define PIN_ADDR PIN_ADDR_IPV6INCOMPATIBLE
#undef LPIN_ADDR
#define LPIN_ADDR LPIN_ADDR_IPV6INCOMPATIBLE
#undef IPAddr
#define IPAddr IPAddr_IPV6INCOMPATIBLE
#undef sockaddr_in
#define sockaddr_in sockaddr_in_IPV6INCOMPATIBLE
#undef SOCKADDR_IN
#define SOCKADDR_IN SOCKADDR_IN_IPV6INCOMPATIBLE
#undef PSOCKADDR_IN
#define PSOCKADDR_IN PSOCKADDR_IN_IPV6INCOMPATIBLE
#undef LPSOCKADDR_IN
#define LPSOCKADDR_IN LPSOCKADDR_IN_IPV6INCOMPATIBLE
#undef INADDR_ANY
#define INADDR_ANY INADDR_ANY_IPV6INCOMPATIBLE
#undef INADDR_LOOPBACK
#define INADDR_LOOPBACK INADDR_LOOPBACK_IPV6INCOMPATIBLE
#undef IPPROTO_IP
#define IPPROTO_IP IPPROTO_IP_IPV6INCOMPATIBLE
#undef IP_MULTICAST_IF
#define IP_MULTICAST_IF IP_MULTICAST_IF_IPV6INCOMPATIBLE
#undef IP_MULTICAST_TTL
#define IP_MULTICAST_TTL IP_MULTICAST_TTL_IPV6INCOMPATIBLE
#undef IP_MULTICAST_LOOP
#define IP_MULTICAST_LOOP IP_MULTICAST_LOOP_IPV6INCOMPATIBLE
#undef IP_ADD_MEMBERSHIP
#define IP_ADD_MEMBERSHIP IP_ADD_MEMBERSHIP_IPV6INCOMPATIBLE
#undef IP_DROP_MEMBERSHIP
#define IP_DROP_MEMBERSHIP IP_DROP_MEMBERSHIP_IPV6INCOMPATIBLE
#undef ip_mreq
#define ip_mreq ip_mreq_IPV6INCOMPATIBLE
#undef gethostbyname
#define gethostbyname(a) gethostbyname_IPV6INCOMPATIBLE
#undef hostent
#define hostent hostent_IPV6INCOMPATIBLE
#undef HOSTENT
#define HOSTENT HOSTENT_IPV6INCOMPATIBLE
#undef PHOSTENT
#define PHOSTENT PHOSTENT_IPV6INCOMPATIBLE
#undef LPHOSTENT
#define LPHOSTENT LPHOSTENT_IPV6INCOMPATIBLE
#undef inet_addr
#define inet_addr(a) inet_addr_IPV6INCOMPATIBLE
#undef gethostbyaddr
#define gethostbyaddr(a,b,c) gethostbyaddr_IPV6INCOMPATIBLE
#undef inet_ntoa
#define inet_ntoa(a) inet_ntoa_IPV6INCOMPATIBLE
#undef IN_MULTICAST
#define IN_MULTICAST(a) IN_MULTICAST_IPV6INCOMPATIBLE
#undef IN_CLASSD
#define IN_CLASSD(a) IN_CLASSD_IPV6INCOMPATIBLE
#undef IP_TTL
#define IP_TTL IP_TTL_IPV6INCOMPATIBLE
#undef IN_CLASSA
#define IN_CLASSA(a) IN_CLASSA_IPV6INCOMPATIBLE
#undef IN_CLASSB
#define IN_CLASSB(a) IN_CLASSB_IPV6INCOMPATIBLE
#undef IN_CLASSC
#define IN_CLASSC(a) IN_CLASSC_IPV6INCOMPATIBLE
#undef INADDR_BROADCAST
#define INADDR_BROADCAST(a) INADDR_BROADCAST_IPV6INCOMPATIBLE
#undef WSAAsyncGetHostByAddr
#define WSAAsyncGetHostByAddr(a,b,c,d,e,f,g) WSAAsyncGetHostByAddr_IPV6INCOMPATIBLE
#undef WSAAsyncGetHostByName
#define WSAAsyncGetHostByName(a,b,c,d,e) WSAAsyncGetHostByName_IPV6INCOMPATIBLE

#endif // IPV6STRICT

#endif // _WSIPV6OK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WSnetbs.h ===
/*
 *   wsnetbs.h
 *   Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
 *
 *   Windows Sockets include file for NETBIOS.  This file contains all
 *   standardized NETBIOS information.  Include this header file after
 *   winsock.h.
 *
 */

#ifndef _WSNETBS_
#define _WSNETBS_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *   This is the structure of the SOCKADDR structure for NETBIOS.
 *
 */

#define NETBIOS_NAME_LENGTH 16

typedef struct sockaddr_nb {
    short   snb_family;
    u_short snb_type;
    char    snb_name[NETBIOS_NAME_LENGTH];
} SOCKADDR_NB, *PSOCKADDR_NB,FAR *LPSOCKADDR_NB;

/*
 * Bit values for the snb_type field of SOCKADDR_NB.
 *
 */

#define NETBIOS_UNIQUE_NAME         (0x0000)
#define NETBIOS_GROUP_NAME          (0x0001)
#define NETBIOS_TYPE_QUICK_UNIQUE   (0x0002)
#define NETBIOS_TYPE_QUICK_GROUP    (0x0003)

/*
 * A macro convenient for setting up NETBIOS SOCKADDRs.
 *
 */

#define SET_NETBIOS_SOCKADDR(_snb,_type,_name,_port)                          \
    {                                                                         \
        int _i;                                                               \
        (_snb)->snb_family = AF_NETBIOS;                                      \
        (_snb)->snb_type = (_type);                                           \
        for (_i=0; _i<NETBIOS_NAME_LENGTH-1; _i++) {                          \
            (_snb)->snb_name[_i] = ' ';                                       \
        }                                                                     \
        for (_i=0; *((_name)+_i) != '\0' && _i<NETBIOS_NAME_LENGTH-1; _i++) { \
            (_snb)->snb_name[_i] = *((_name)+_i);                             \
        }                                                                     \
        (_snb)->snb_name[NETBIOS_NAME_LENGTH-1] = (_port);                    \
    }

/*
 *   To open a NetBIOS socket, call the socket() function as follows:
 *
 *       s = socket( AF_NETBIOS, {SOCK_SEQPACKET|SOCK_DGRAM}, -Lana );
 *
 *   where Lana is the NetBIOS Lana number of interest.  For example, to
 *   open a socket for Lana 2, specify -2 as the "protocol" parameter
 *   to the socket() function.
 *
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wsrm.h ===
/*	
**	wsrm.h - winsock extension for Reliable Multicast (RMCast) Transport
**
**	This file contains PGM specific information for use by WinSock2 compatible
**  applications that need Reliable Multicast Transport.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**	Created: Mar 12, 2000
**
*/

#ifndef _WSRM_H_
#define _WSRM_H_

#pragma once

#define IPPROTO_RM      113
#define MAX_MCAST_TTL   255

//
// options for setsockopt, getsockopt
//
#define RM_OPTIONSBASE      1000

// Set/Query rate (Kb/Sec) + window size (Kb and/or MSec) -- described by RM_SEND_WINDOW below
#define RM_RATE_WINDOW_SIZE             (RM_OPTIONSBASE + 1)

// Set the size of the next message -- (ULONG)
#define RM_SET_MESSAGE_BOUNDARY         (RM_OPTIONSBASE + 2)

// flush the entire data (window) right now -- not implemented
#define RM_FLUSHCACHE                   (RM_OPTIONSBASE + 3)

// Set or Query the window advance method on the sender -- methods enumerated in eWINDOW_ADVANCE_METHOD
#define RM_SENDER_WINDOW_ADVANCE_METHOD (RM_OPTIONSBASE + 4)

// get sender statistics
#define RM_SENDER_STATISTICS            (RM_OPTIONSBASE + 5)

// allow a late-joiner to NAK any packet upto the lowest sequence Id
#define RM_LATEJOIN                     (RM_OPTIONSBASE + 6)

// set IP multicast outgoing interface
#define RM_SET_SEND_IF                  (RM_OPTIONSBASE + 7)

// add IP multicast incoming interface
#define RM_ADD_RECEIVE_IF               (RM_OPTIONSBASE + 8)

// delete IP multicast incoming interface
#define RM_DEL_RECEIVE_IF               (RM_OPTIONSBASE + 9)

// Set/Query the Window's Advance rate (has to be less that MAX_WINDOW_INCREMENT_PERCENTAGE)
#define RM_SEND_WINDOW_ADV_RATE         (RM_OPTIONSBASE + 10)

// Instruct to use parity-based forward error correction schemes
#define RM_USE_FEC                      (RM_OPTIONSBASE + 11)

// Set the Ttl of the MCast packets -- (ULONG)
#define RM_SET_MCAST_TTL                (RM_OPTIONSBASE + 12)

// get receiver statistics
#define RM_RECEIVER_STATISTICS          (RM_OPTIONSBASE + 13)

// get receiver statistics
#define RM_HIGH_SPEED_INTRANET_OPT      (RM_OPTIONSBASE + 14)

//==============================================================
//
// Definitions
//
#define     SENDER_DEFAULT_RATE_KBITS_PER_SEC        56             // 56 Kbits/Sec
#define     SENDER_DEFAULT_WINDOW_SIZE_BYTES         10 *1000*1000  // 10 Megs

#define     SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE     15             // 15%
#define     MAX_WINDOW_INCREMENT_PERCENTAGE          25             // 25%

#define     SENDER_DEFAULT_LATE_JOINER_PERCENTAGE    0              // 0%
#define     SENDER_MAX_LATE_JOINER_PERCENTAGE        75             // 75%

#define     BITS_PER_BYTE                             8
#define     LOG2_BITS_PER_BYTE                        3

enum eWINDOW_ADVANCE_METHOD
{
    E_WINDOW_ADVANCE_BY_TIME = 1,       // Default mode
    E_WINDOW_USE_AS_DATA_CACHE
};

//==============================================================
//
// Structures
//
typedef struct _RM_SEND_WINDOW
{
    ULONG   RateKbitsPerSec;            // Send rate
    ULONG   WindowSizeInMSecs;
    ULONG   WindowSizeInBytes;
} RM_SEND_WINDOW;

typedef struct _RM_SENDER_STATS
{
    ULONGLONG   DataBytesSent;          // # client data bytes sent out so far
    ULONGLONG   TotalBytesSent;         // SPM, OData and RData bytes
    ULONGLONG   NaksReceived;           // # NAKs received so far
    ULONGLONG   NaksReceivedTooLate;    // # NAKs recvd after window advanced
    ULONGLONG   NumOutstandingNaks;     // # NAKs yet to be responded to
    ULONGLONG   NumNaksAfterRData;      // # NAKs yet to be responded to
    ULONGLONG   RepairPacketsSent;      // # Repairs (RDATA) sent so far
    ULONGLONG   BufferSpaceAvailable;   // # partial messages dropped
    ULONGLONG   TrailingEdgeSeqId;      // smallest (oldest) Sequence Id in the window
    ULONGLONG   LeadingEdgeSeqId;       // largest (newest) Sequence Id in the window
    ULONGLONG   RateKBitsPerSecOverall; // Internally calculated send-rate from the beginning
    ULONGLONG   RateKBitsPerSecLast;    // Send-rate calculated every INTERNAL_RATE_CALCULATION_FREQUENCY
    ULONGLONG   TotalODataPacketsSent;  // # ODATA packets sent so far
} RM_SENDER_STATS;


typedef struct _RM_RECEIVER_STATS
{
    ULONGLONG   NumODataPacketsReceived;// # OData sequences received
    ULONGLONG   NumRDataPacketsReceived;// # RData sequences received
    ULONGLONG   NumDuplicateDataPackets;// # RData sequences received

    ULONGLONG   DataBytesReceived;      // # client data bytes received out so far
    ULONGLONG   TotalBytesReceived;     // SPM, OData and RData bytes
    ULONGLONG   RateKBitsPerSecOverall; // Internally calculated Receive-rate from the beginning
    ULONGLONG   RateKBitsPerSecLast;    // Receive-rate calculated every INTERNAL_RATE_CALCULATION_FREQUENCY

    ULONGLONG   TrailingEdgeSeqId;      // smallest (oldest) Sequence Id in the window
    ULONGLONG   LeadingEdgeSeqId;       // largest (newest) Sequence Id in the window
    ULONGLONG   AverageSequencesInWindow;
    ULONGLONG   MinSequencesInWindow;
    ULONGLONG   MaxSequencesInWindow;

    ULONGLONG   FirstNakSequenceNumber; // # First Outstanding Nak
    ULONGLONG   NumPendingNaks;         // # Sequences waiting for Ncfs
    ULONGLONG   NumOutstandingNaks;     // # Sequences for which Ncfs have been received, but no data
    ULONGLONG   NumDataPacketsBuffered; // # Data packets currently buffered by transport
    ULONGLONG   TotalSelectiveNaksSent; // # Selective NAKs sent so far
    ULONGLONG   TotalParityNaksSent;    // # Parity NAKs sent so far
} RM_RECEIVER_STATS;


typedef struct _RM_FEC_INFO
{
    USHORT              FECBlockSize;
    USHORT              FECProActivePackets;
    UCHAR               FECGroupSize;
    BOOLEAN             fFECOnDemandParityEnabled;
} RM_FEC_INFO;

#endif  /* _WSRM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WSvns.h ===
/*******************************************************************************
 *
 *   wsvns.h
 *
 *  Copyright (C) Microsoft Corporation, 1992-1999.
 *
 *   Windows Sockets include file for VINES IP.  This file contains all
 *   standardized VINES IP information.  Include this header file after
 *   winsock.h.
 *
 *   To open an VINES IP socket, call socket() with an address family of
 *   AF_BAN, a socket type of SOCK_DGRAM, SOCK_STREAM, or SOCK_SEQPACKET,
 *   and protocol of 0.
 *
 ******************************************************************************/

#ifndef _WSVNS_
#define _WSVNS_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Socket address, VINES IP style.  Address fields and port field are defined
 * as a sequence of bytes.  This is done because they are byte ordered
 * BIG ENDIAN, ala most significant byte first.
 */
typedef struct sockaddr_vns {
    u_short sin_family;			// = AF_BAN
    u_char  net_address[4];		// network address
    u_char  subnet_addr[2];		// subnet address
    u_char  port[2];			// msb=port[0], lsb=port[1]
    u_char  hops;			// # hops for broadcasts
    u_char  filler[5];			// filler, zeros
} SOCKADDR_VNS, *PSOCKADDR_VNS, FAR *LPSOCKADDR_VNS;

#define VNSPROTO_IPC		1
#define VNSPROTO_RELIABLE_IPC	2
#define VNSPROTO_SPP		3


#endif _WSVNS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WSNwLink.h ===
/*
 *   wsnwlink.h
 *
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992-1999.
 *   Microsoft-specific extensions to the Windows NT IPX/SPX Windows
 *   Sockets interface.  These extensions are provided for use as
 *   necessary for compatibility with existing applications.  They are
 *   otherwise not recommended for use, as they are only guaranteed to
 *   work *   over the Microsoft IPX/SPX stack.  An application which
 *   uses these *   extensions may not work over other IPX/SPX
 *   implementations.  Include this header file after winsock.h and
 *   wsipx.h.
 *
 *   To open an IPX socket where a particular packet type is sent in
 *   the IPX header, specify NSPROTO_IPX + n as the protocol parameter
 *   of the socket() API.  For example, to open an IPX socket that
 *   sets the packet type to 34, use the following socket() call:
 *
 *       s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX + 34);
 *
 *   Below are socket option that may be set or retrieved by specifying
 *   the appropriate manifest in the "optname" parameter of getsockopt()
 *   or setsockopt().  Use NSPROTO_IPX as the "level" argument for the
 *   call.
 *
 */

#ifndef _WSNWLINK_
#define _WSNWLINK_

#if _MSC_VER > 1000
#pragma once
#endif


/*
 *   Set/get the IPX packet type.  The value specified in the
 *   optval argument will be set as the packet type on every IPX
 *   packet sent from this socket.  The optval parameter of
 *   getsockopt()/setsockopt() points to an int.
 *
 */

#define IPX_PTYPE               0x4000


/*
 *   Set/get the receive filter packet type.  Only IPX packets with
 *   a packet type equal to the value specified in the optval
 *   argument will be returned; packets with a packet type that
 *   does not match are discarded.  optval points to an int.
 *
 */

#define IPX_FILTERPTYPE         0x4001


/*
 *   Stop filtering on packet type set with IPX_FILTERPTYPE.
 *
 */

#define IPX_STOPFILTERPTYPE     0x4003


/*
 *   Set/get the value of the datastream field in the SPX header on
 *   every packet sent.  optval points to an int.
 *
 */

#define IPX_DSTYPE              0x4002


/*
 *   Enable extended addressing.  On sends, adds the element
 *   "unsigned char sa_ptype" to the SOCKADDR_IPX structure,
 *   making the total length 15 bytes.  On receives, add both
 *   the sa_ptype and "unsigned char sa_flags" to the SOCKADDR_IPX
 *   structure, making the total length 16 bytes.  The current
 *   bits defined in sa_flags are:
 *
 *   0x01 - the received frame was sent as a broadcast
 *   0x02 - the received frame was sent from this machine
 *
 *   optval points to a BOOL.
 *
 */

#define IPX_EXTENDED_ADDRESS    0x4004


/*
 *   Send protocol header up on all receive packets.  optval points
 *   to a BOOL.
 *
 */

#define IPX_RECVHDR             0x4005


/*
 *   Get the maximum data size that can be sent.  Not valid with
 *   setsockopt().  optval points to an int where the value is
 *   returned.
 *
 */

#define IPX_MAXSIZE             0x4006


/*
 *   Query information about a specific adapter that IPX is bound
 *   to.  In a system with n adapters they are numbered 0 through n-1.
 *   Callers can issue the IPX_MAX_ADAPTER_NUM getsockopt() to find
 *   out the number of adapters present, or call IPX_ADDRESS with
 *   increasing values of adapternum until it fails.  Not valid
 *   with setsockopt().  optval points to an instance of the
 *   IPX_ADDRESS_DATA structure with the adapternum filled in.
 *
 */

#define IPX_ADDRESS             0x4007

typedef struct _IPX_ADDRESS_DATA {
    INT   adapternum;  /* input: 0-based adapter number */
    UCHAR netnum[4];   /* output: IPX network number */
    UCHAR nodenum[6];  /* output: IPX node address */
    BOOLEAN wan;       /* output: TRUE = adapter is on a wan link */
    BOOLEAN status;    /* output: TRUE = wan link is up (or adapter is not wan) */
    INT   maxpkt;      /* output: max packet size, not including IPX header */
    ULONG linkspeed;   /* output: link speed in 100 bytes/sec (i.e. 96 == 9600 bps) */
} IPX_ADDRESS_DATA, *PIPX_ADDRESS_DATA;


/*
 *   Query information about a specific IPX network number.  If the
 *   network is in IPX's cache it will return the information directly,
 *   otherwise it will issue RIP requests to find it.  Not valid with
 *   setsockopt().  optval points to an instance of the IPX_NETNUM_DATA
 *   structure with the netnum filled in.
 *
 */

#define IPX_GETNETINFO          0x4008

typedef struct _IPX_NETNUM_DATA {
    UCHAR  netnum[4];  /* input: IPX network number */
    USHORT hopcount;   /* output: hop count to this network, in machine order */
    USHORT netdelay;   /* output: tick count to this network, in machine order */
    INT    cardnum;    /* output: 0-based adapter number used to route to this net;
                       /*         can be used as adapternum input to IPX_ADDRESS */
    UCHAR  router[6];  /* output: MAC address of the next hop router, zeroed if
                       /*         the network is directly attached */
} IPX_NETNUM_DATA, *PIPX_NETNUM_DATA;


/*
 *   Like IPX_GETNETINFO except it *does not* issue RIP requests. If the
 *   network is in IPX's cache it will return the information, otherwise
 *   it will fail (see also IPX_RERIPNETNUMBER which *always* forces a
 *   re-RIP). Not valid with setsockopt().  optval points to an instance of
 *   the IPX_NETNUM_DATA structure with the netnum filled in.
 *
 */

#define IPX_GETNETINFO_NORIP    0x4009


/*
 *   Get information on a connected SPX socket.  optval points
 *   to an instance of the IPX_SPXCONNSTATUS_DATA structure.
 *
 *   All numbers are in Novell (high-low) order.
 *
 */

#define IPX_SPXGETCONNECTIONSTATUS 0x400B

typedef struct _IPX_SPXCONNSTATUS_DATA {
    UCHAR  ConnectionState;
    UCHAR  WatchDogActive;
    USHORT LocalConnectionId;
    USHORT RemoteConnectionId;
    USHORT LocalSequenceNumber;
    USHORT LocalAckNumber;
    USHORT LocalAllocNumber;
    USHORT RemoteAckNumber;
    USHORT RemoteAllocNumber;
    USHORT LocalSocket;
    UCHAR  ImmediateAddress[6];
    UCHAR  RemoteNetwork[4];
    UCHAR  RemoteNode[6];
    USHORT RemoteSocket;
    USHORT RetransmissionCount;
    USHORT EstimatedRoundTripDelay; /* In milliseconds */
    USHORT RetransmittedPackets;
    USHORT SuppressedPacket;
} IPX_SPXCONNSTATUS_DATA, *PIPX_SPXCONNSTATUS_DATA;


/*
 *   Get notification when the status of an adapter that IPX is
 *   bound to changes.  Typically this will happen when a wan line
 *   goes up or down.  Not valid with setsockopt().  optval points
 *   to a buffer which contains an IPX_ADDRESS_DATA structure
 *   followed immediately by a HANDLE to an unsignaled event.
 *
 *   When the getsockopt() query is submitted, it will complete
 *   successfully.  However, the IPX_ADDRESS_DATA pointed to by
 *   optval will not be updated at that point.  Instead the
 *   request is queued internally inside the transport.
 *
 *   When the status of an adapter changes, IPX will locate a
 *   queued getsockopt() query and fill in all the fields in the
 *   IPX_ADDRESS_DATA structure.  It will then signal the event
 *   pointed to by the HANDLE in the optval buffer.  This handle
 *   should be obtained before calling getsockopt() by calling
 *   CreateEvent().  If multiple getsockopts() are submitted at
 *   once, different events must be used.
 *
 *   The event is used because the call needs to be asynchronous
 *   but currently getsockopt() does not support this.
 *
 *   WARNING: In the current implementation, the transport will
 *   only signal one queued query for each status change.  Therefore
 *   only one service which uses this query should be running at
 *   once.
 *
 */

#define IPX_ADDRESS_NOTIFY      0x400C


/*
 *   Get the maximum number of adapters present.  If this call returns
 *   n then the adapters are numbered 0 through n-1.  Not valid
 *   with setsockopt().  optval points to an int where the value
 *   is returned.
 *
 */

#define IPX_MAX_ADAPTER_NUM     0x400D


/*
 *   Like IPX_GETNETINFO except it forces IPX to re-RIP even if the
 *   network is in its cache (but not if it is directly attached to).
 *   Not valid with setsockopt().  optval points to an instance of
 *   the IPX_NETNUM_DATA structure with the netnum filled in.
 *
 */

#define IPX_RERIPNETNUMBER      0x400E


/*
 *   A hint that broadcast packets may be received.  The default is
 *   TRUE.  Applications that do not need to receive broadcast packets
 *   should set this sockopt to FALSE which may cause better system
 *   performance (note that it does not necessarily cause broadcasts
 *   to be filtered for the application).  Not valid with getsockopt().
 *   optval points to a BOOL.
 *
 */

#define IPX_RECEIVE_BROADCAST   0x400F


/*
 *   On SPX connections, don't delay before sending ack.  Applications
 *   that do not tend to have back-and-forth traffic over SPX should
 *   set this; it will increase the number of acks sent but will remove
 *   delays in sending acks.  optval points to a BOOL.
 *
 */

#define IPX_IMMEDIATESPXACK     0x4010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\XCMC.h ===
/*BEGIN CMC INTERFACE */

#ifndef _XCMC_H
#define _XCMC_H

#ifdef __cplusplus
extern "C" {
#endif

/*BASIC DATA TYPES*/
#ifndef DIFFERENT_PLATFORM
typedef char                CMC_sint8;
typedef short               CMC_sint16;
typedef long int            CMC_sint32;
typedef unsigned short int  CMC_uint16;
typedef unsigned long int   CMC_uint32;
typedef void far *          CMC_buffer;
typedef char far *          CMC_string;
#endif

typedef CMC_uint16          CMC_boolean;
typedef CMC_sint32          CMC_enum;
typedef CMC_uint32          CMC_return_code;
typedef CMC_uint32          CMC_flags;
typedef CMC_string          CMC_object_identifier;

#define CMC_FALSE   ((CMC_boolean)0)
#define CMC_TRUE    ((CMC_boolean)1)

/*DATA STRUCTURES*/

/*COUNTED STRING*/
typedef struct {
    CMC_uint32          length;
    char                string[1];
} CMC_counted_string;

/*SESSION ID*/
typedef CMC_uint32      CMC_session_id;

/*TIME*/
/* unusedX fields needed to align struct on 4-byte boundary */
typedef struct {
    CMC_sint8           second;
    CMC_sint8           minute;
    CMC_sint8           hour;
    CMC_sint8           day;
    CMC_sint8           month;
    CMC_sint8           year;
    CMC_sint8           isdst;
    CMC_sint8           unused1;
    CMC_sint16          tmzone;
    CMC_sint16          unused2;
} CMC_time;

#define CMC_NO_TIMEZONE                     ((CMC_sint16) 0x8000)

typedef CMC_uint32          CMC_ui_id;

/*EXTENSION*/
typedef struct {
    CMC_uint32              item_code;
    CMC_uint32              item_data;
    CMC_buffer              item_reference;
    CMC_flags               extension_flags;
} CMC_extension;

/* EXTENSION FLAGS */
#define CMC_EXT_REQUIRED                    ((CMC_flags) 0x00010000)
#define CMC_EXT_OUTPUT                      ((CMC_flags) 0x00020000)
#define CMC_EXT_LAST_ELEMENT                ((CMC_flags) 0x80000000)
#define CMC_EXT_RSV_FLAG_MASK               ((CMC_flags) 0xFFFF0000)
#define CMC_EXT_ITEM_FLAG_MASK              ((CMC_flags) 0x0000FFFF)

/*ATTACHMENT*/
typedef struct {
    CMC_string              attach_title;
    CMC_object_identifier   attach_type;
    CMC_string              attach_filename;
    CMC_flags               attach_flags;
    CMC_extension FAR       *attach_extensions;
} CMC_attachment;

/* ATTACHMENT FLAGS */
#define CMC_ATT_APP_OWNS_FILE               ((CMC_flags) 1)
#define CMC_ATT_LAST_ELEMENT                ((CMC_flags) 0x80000000)

#define CMC_ATT_OID_BINARY                  "? ? ? ? ? ?"
#define CMC_ATT_OID_TEXT                    "? ? ? ? ? ?"

/*MESSAGE REFERENCE*/
typedef CMC_counted_string  CMC_message_reference;

/*RECIPIENT*/
typedef struct {
    CMC_string              name;
    CMC_enum                name_type;
    CMC_string              address;
    CMC_enum                role;
    CMC_flags               recip_flags;
    CMC_extension FAR       *recip_extensions;
} CMC_recipient;

/* NAME TYPES */
#define CMC_TYPE_UNKNOWN                    ((CMC_enum) 0)
#define CMC_TYPE_INDIVIDUAL                 ((CMC_enum) 1)
#define CMC_TYPE_GROUP                      ((CMC_enum) 2)

/* ROLES */
#define CMC_ROLE_TO                         ((CMC_enum) 0)
#define CMC_ROLE_CC                         ((CMC_enum) 1)
#define CMC_ROLE_BCC                        ((CMC_enum) 2)
#define CMC_ROLE_ORIGINATOR                 ((CMC_enum) 3)
#define CMC_ROLE_AUTHORIZING_USER           ((CMC_enum) 4)

/* RECIPIENT FLAGS */
#define CMC_RECIP_IGNORE                    ((CMC_flags) 1)
#define CMC_RECIP_LIST_TRUNCATED            ((CMC_flags) 2)
#define CMC_RECIP_LAST_ELEMENT              ((CMC_flags) 0x80000000)

/*MESSAGE*/
typedef struct {
    CMC_message_reference FAR   *message_reference;
    CMC_string              message_type;
    CMC_string              subject;
    CMC_time                time_sent;
    CMC_string              text_note;
    CMC_recipient FAR       *recipients;
    CMC_attachment FAR      *attachments;
    CMC_flags               message_flags;
    CMC_extension FAR       *message_extensions;
} CMC_message;

/* MESSAGE FLAGS */
#define CMC_MSG_READ                        ((CMC_flags) 1)
#define CMC_MSG_TEXT_NOTE_AS_FILE           ((CMC_flags) 2)
#define CMC_MSG_UNSENT                      ((CMC_flags) 4)
#define CMC_MSG_LAST_ELEMENT                ((CMC_flags) 0x80000000)

/*MESSAGE SUMMARY*/
typedef struct {
    CMC_message_reference FAR   *message_reference;
    CMC_string              message_type;
    CMC_string              subject;
    CMC_time                time_sent;
    CMC_uint32              byte_length;
    CMC_recipient FAR       *originator;
    CMC_flags               summary_flags;
    CMC_extension FAR       *message_summary_extensions;
} CMC_message_summary;

/* MESSAGE SUMMARY FLAGS */
#define CMC_SUM_READ                        ((CMC_flags) 1)
#define CMC_SUM_UNSENT                      ((CMC_flags) 2)
#define CMC_SUM_LAST_ELEMENT                ((CMC_flags) 0x80000000)

/*CMC FUNCTIONS */

/*CROSS FUNCTION FLAGS */
#define CMC_ERROR_UI_ALLOWED                ((CMC_flags) 0x01000000)
#define CMC_LOGON_UI_ALLOWED                ((CMC_flags) 0x02000000)
#define CMC_COUNTED_STRING_TYPE             ((CMC_flags) 0x04000000)

/*SEND*/
CMC_return_code FAR PASCAL
cmc_send(
    CMC_session_id          session,
    CMC_message FAR         *message,
    CMC_flags               send_flags,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *send_extensions
);

#define CMC_SEND_UI_REQUESTED               ((CMC_flags) 1)

/*SEND DOCUMENT*/
CMC_return_code FAR PASCAL
cmc_send_documents(
    CMC_string              recipient_addresses,
    CMC_string              subject,
    CMC_string              text_note,
    CMC_flags               send_doc_flags,
    CMC_string              file_paths,
    CMC_string              file_names,
    CMC_string              delimiter,
    CMC_ui_id               ui_id
);

#define CMC_FIRST_ATTACH_AS_TEXT_NOTE       ((CMC_flags) 2)

/*ACT ON*/
CMC_return_code FAR PASCAL
cmc_act_on(
    CMC_session_id          session,
    CMC_message_reference FAR   *message_reference,
    CMC_enum                operation,
    CMC_flags               act_on_flags,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *act_on_extensions
);

#define CMC_ACT_ON_EXTENDED                 ((CMC_enum) 0)
#define CMC_ACT_ON_DELETE                   ((CMC_enum) 1)

/*LIST*/
CMC_return_code FAR PASCAL
cmc_list(
    CMC_session_id          session,
    CMC_string              message_type,
    CMC_flags               list_flags,
    CMC_message_reference FAR   *seed,
    CMC_uint32 FAR          *count,
    CMC_ui_id               ui_id,
    CMC_message_summary FAR * FAR *result,
    CMC_extension FAR       *list_extensions
);

#define CMC_LIST_UNREAD_ONLY                ((CMC_flags) 1)
#define CMC_LIST_MSG_REFS_ONLY              ((CMC_flags) 2)
#define CMC_LIST_COUNT_ONLY                 ((CMC_flags) 4)

#define CMC_LENGTH_UNKNOWN          0xFFFFFFFF

/*READ*/
CMC_return_code FAR PASCAL
cmc_read(
    CMC_session_id          session,
    CMC_message_reference FAR   *message_reference,
    CMC_flags               read_flags,
    CMC_message FAR * FAR   *message,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *read_extensions
);

#define CMC_DO_NOT_MARK_AS_READ             ((CMC_flags) 1)
#define CMC_MSG_AND_ATT_HDRS_ONLY           ((CMC_flags) 2)
#define CMC_READ_FIRST_UNREAD_MESSAGE       ((CMC_flags) 4)

/*LOOK UP*/
CMC_return_code FAR PASCAL
cmc_look_up(
    CMC_session_id          session,
    CMC_recipient FAR       *recipient_in,
    CMC_flags               look_up_flags,
    CMC_ui_id               ui_id,
    CMC_uint32 FAR          *count,
    CMC_recipient FAR * FAR *recipient_out,
    CMC_extension FAR       *look_up_extensions
);

#define CMC_LOOKUP_RESOLVE_PREFIX_SEARCH    ((CMC_flags) 1)
#define CMC_LOOKUP_RESOLVE_IDENTITY         ((CMC_flags) 2)
#define CMC_LOOKUP_RESOLVE_UI               ((CMC_flags) 4)
#define CMC_LOOKUP_DETAILS_UI               ((CMC_flags) 8)
#define CMC_LOOKUP_ADDRESSING_UI            ((CMC_flags) 16)

/*FREE*/
CMC_return_code FAR PASCAL
cmc_free(
    CMC_buffer              memory
);

/* LOGOFF */
CMC_return_code FAR PASCAL
cmc_logoff(
    CMC_session_id          session,
    CMC_ui_id               ui_id,
    CMC_flags               logoff_flags,
    CMC_extension FAR       *logoff_extensions
);

#define CMC_LOGOFF_UI_ALLOWED               ((CMC_flags) 1)

/* LOGON */
CMC_return_code FAR PASCAL
cmc_logon(
    CMC_string              service,
    CMC_string              user,
    CMC_string              password,
    CMC_object_identifier   character_set,
    CMC_ui_id               ui_id,
    CMC_uint16              caller_cmc_version,
    CMC_flags               logon_flags,
    CMC_session_id FAR      *session,
    CMC_extension FAR       *logon_extensions
);

#define CMC_VERSION         ((CMC_uint16) 100)

/* QUERY CONFIGURATION */
CMC_return_code FAR PASCAL
cmc_query_configuration(
    CMC_session_id          session,
    CMC_enum                item,
    CMC_buffer              reference,
    CMC_extension FAR       *config_extensions
);

/*QUERY CONFIGURATION ENUMS */
#define CMC_CONFIG_CHARACTER_SET            ((CMC_enum) 1)
#define CMC_CONFIG_LINE_TERM                ((CMC_enum) 2)
#define CMC_CONFIG_DEFAULT_SERVICE          ((CMC_enum) 3)
#define CMC_CONFIG_DEFAULT_USER             ((CMC_enum) 4)
#define CMC_CONFIG_REQ_PASSWORD             ((CMC_enum) 5)
#define CMC_CONFIG_REQ_SERVICE              ((CMC_enum) 6)
#define CMC_CONFIG_REQ_USER                 ((CMC_enum) 7)
#define CMC_CONFIG_UI_AVAIL                 ((CMC_enum) 8)
#define CMC_CONFIG_SUP_NOMKMSGREAD          ((CMC_enum) 9)
#define CMC_CONFIG_SUP_COUNTED_STR          ((CMC_enum) 10)
#define CMC_CONFIG_VER_IMPLEM               ((CMC_enum) 11)
#define CMC_CONFIG_VER_SPEC                 ((CMC_enum) 12)

/* CONFIG LINE TERM ENUM */
#define CMC_LINE_TERM_CRLF                  ((CMC_enum) 0)
#define CMC_LINE_TERM_CR                    ((CMC_enum) 1)
#define CMC_LINE_TERM_LF                    ((CMC_enum) 2)

/* CONFIG REQUIRED LOGON PARAMETER ENUM */
#define CMC_REQUIRED_NO                     ((CMC_enum) 0)
#define CMC_REQUIRED_YES                    ((CMC_enum) 1)
#define CMC_REQUIRED_OPT                    ((CMC_enum) 2)

/* DEFINED OBJECT ID'S FOR CHARACTER SETS */
#define CMC_CHAR_CP437                      "1 2 840 113556 3 2 437"
#define CMC_CHAR_CP850                      "1 2 840 113556 3 2 850"
#define CMC_CHAR_CP1252                     "1 2 840 113556 3 2 1252"
#define CMC_CHAR_ISTRING                    "1 2 840 113556 3 2 0"
#define CMC_CHAR_UNICODE                    "1 2 840 113556 3 2 1"

/* RETURN CODE FLAGS */
#define CMC_ERROR_DISPLAYED                 ((CMC_return_code) 0x00008000)
#define CMC_ERROR_RSV_MASK                  ((CMC_return_code) 0x0000FFFF)
#define CMC_ERROR_IMPL_MASK                 ((CMC_return_code) 0xFFFF0000)

/* RETURN CODES */
#define CMC_SUCCESS                         ((CMC_return_code) 0)

#define CMC_E_AMBIGUOUS_RECIPIENT           ((CMC_return_code) 1)
#define CMC_E_ATTACHMENT_NOT_FOUND          ((CMC_return_code) 2)
#define CMC_E_ATTACHMENT_OPEN_FAILURE       ((CMC_return_code) 3)
#define CMC_E_ATTACHMENT_READ_FAILURE       ((CMC_return_code) 4)
#define CMC_E_ATTACHMENT_WRITE_FAILURE      ((CMC_return_code) 5)
#define CMC_E_COUNTED_STRING_UNSUPPORTED    ((CMC_return_code) 6)
#define CMC_E_DISK_FULL                     ((CMC_return_code) 7)
#define CMC_E_FAILURE                       ((CMC_return_code) 8)
#define CMC_E_INSUFFICIENT_MEMORY           ((CMC_return_code) 9)
#define CMC_E_INVALID_CONFIGURATION         ((CMC_return_code) 10)
#define CMC_E_INVALID_ENUM                  ((CMC_return_code) 11)
#define CMC_E_INVALID_FLAG                  ((CMC_return_code) 12)
#define CMC_E_INVALID_MEMORY                ((CMC_return_code) 13)
#define CMC_E_INVALID_MESSAGE_PARAMETER     ((CMC_return_code) 14)
#define CMC_E_INVALID_MESSAGE_REFERENCE     ((CMC_return_code) 15)
#define CMC_E_INVALID_PARAMETER             ((CMC_return_code) 16)
#define CMC_E_INVALID_SESSION_ID            ((CMC_return_code) 17)
#define CMC_E_INVALID_UI_ID                 ((CMC_return_code) 18)
#define CMC_E_LOGON_FAILURE                 ((CMC_return_code) 19)
#define CMC_E_MESSAGE_IN_USE                ((CMC_return_code) 20)
#define CMC_E_NOT_SUPPORTED                 ((CMC_return_code) 21)
#define CMC_E_PASSWORD_REQUIRED             ((CMC_return_code) 22)
#define CMC_E_RECIPIENT_NOT_FOUND           ((CMC_return_code) 23)
#define CMC_E_SERVICE_UNAVAILABLE           ((CMC_return_code) 24)
#define CMC_E_TEXT_TOO_LARGE                ((CMC_return_code) 25)
#define CMC_E_TOO_MANY_FILES                ((CMC_return_code) 26)
#define CMC_E_TOO_MANY_RECIPIENTS           ((CMC_return_code) 27)
#define CMC_E_UNABLE_TO_NOT_MARK_AS_READ    ((CMC_return_code) 28)
#define CMC_E_UNRECOGNIZED_MESSAGE_TYPE     ((CMC_return_code) 29)
#define CMC_E_UNSUPPORTED_ACTION            ((CMC_return_code) 30)
#define CMC_E_UNSUPPORTED_CHARACTER_SET     ((CMC_return_code) 31)
#define CMC_E_UNSUPPORTED_DATA_EXT          ((CMC_return_code) 32)
#define CMC_E_UNSUPPORTED_FLAG              ((CMC_return_code) 33)
#define CMC_E_UNSUPPORTED_FUNCTION_EXT      ((CMC_return_code) 34)
#define CMC_E_UNSUPPORTED_VERSION           ((CMC_return_code) 35)
#define CMC_E_USER_CANCEL                   ((CMC_return_code) 36)
#define CMC_E_USER_NOT_LOGGED_ON            ((CMC_return_code) 37)

#ifdef __cplusplus
}       /* extern "C" */
#endif

#endif  /* _XCMC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\xa.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* -----------------------------------------------------------------
 * Microsoft Distributed Transaction Coordinator
 * Microsoft Corporation, 1995.
 *
 * File : xa.h 
 * 
 * Contents : This file is derived from xa.h as it appears in 
 * "Distributed Transaction Processing: The XA Specification", 
 * November 93, X/Open Company Limited.
 *
 */

/*
 * Start of xa.h header
 *
 * Define a symbol to prevent multiple inclusion of this header file
 */

#ifndef XA_H
#define XA_H
/*
 * Transaction branch identification: XID and NULLXID:
 */
#define XIDDATASIZE		128			/* size in bytes */
#define MAXGTRIDSIZE    64  		/* maximum size in bytes of gtrid */
#define MAXBQUALSIZE    64  		/* maximum size in bytes of bqual */

#ifndef _XID_T_DEFINED
#define _XID_T_DEFINED
struct xid_t
{
	long formatID;					/* format identifier */
	long gtrid_length;				/* value not to exceed 64 */
	long bqual_length;				/* value not to exceed 64 */
	char data[XIDDATASIZE];
};
#endif

typedef struct xid_t XID;
/*
 * A value of -1 in formatID means that the XID is null.
 */
/*
 * Declarations of routines by which RMs call TMs:
 */

int __cdecl ax_reg(int, XID *, long);
int __cdecl ax_unreg(int, long);


/*
 * XA Switch Data Structure
 */
#define RMNAMESZ	32									/* length of resource manager name, */
														/* including the null terminator */
#define MAXINFOSIZE 256									/* maximum size in bytes of xa_info strings, */
														/* including the null terminator */

#ifndef _XA_SWITCH_T_DEFINED
#define _XA_SWITCH_T_DEFINED
struct xa_switch_t
{
  char name[RMNAMESZ];									/* name of resource manager */
  long flags;											/* resource manager specific options */
  long version;											/* must be 0 */
  int (__cdecl *xa_open_entry)(char *, int, long);		/* xa_open function pointer */
  int (__cdecl *xa_close_entry)(char *, int, long);		/* xa_close function pointer*/
  int (__cdecl *xa_start_entry)(XID *, int, long);		/* xa_start function pointer */
  int (__cdecl *xa_end_entry)(XID *, int, long);		/* xa_end function pointer */
  int (__cdecl *xa_rollback_entry)(XID *, int, long);	/* xa_rollback function pointer */
  int (__cdecl *xa_prepare_entry)(XID *, int, long);	/* xa_prepare function pointer */
  int (__cdecl *xa_commit_entry)(XID *, int, long);		/* xa_commit function pointer */
  int (__cdecl *xa_recover_entry)(XID *, long, int, long);
														/* xa_recover function pointer*/
  int (__cdecl *xa_forget_entry)(XID *, int, long);		/* xa_forget function pointer */
  int (__cdecl *xa_complete_entry)(int *, int *, int, long);
														/* xa_complete function pointer */
};

typedef struct xa_switch_t xa_switch_t;
#endif

/*
 * Flag definitions for the RM switch
 */
#define TMNOFLAGS		0x00000000L						/* no resource manager features selected */
#define TMREGISTER		0x00000001L						/* resource manager dynamically registers */
#define TMNOMIGRATE		0x00000002L						/* resource manager does not support association migration */
#define TMUSEASYNC		0x00000004L						/* resource manager supports asynchronous operations */
/*
 * Flag definitions for xa_ and ax_ routines
 */
/* use TMNOFLAGS, defined above, when not specifying other flags */
#define TMASYNC			0x80000000L						/* perform routine asynchronously */
#define TMONEPHASE		0x40000000L						/* caller is using one-phase commit optimisation */
#define TMFAIL			0x20000000L						/* dissociates caller and marks transaction branch rollback-only */
#define TMNOWAIT		0x10000000L						/* return if blocking condition exists */
#define TMRESUME		0x08000000L						/* caller is resuming association with suspended transaction branch */
#define TMSUCCESS		0x04000000L						/* dissociate caller from transaction branch */
#define TMSUSPEND		0x02000000L						/* caller is suspending, not ending, association */
#define TMSTARTRSCAN	0x01000000L						/* start a recovery scan */
#define TMENDRSCAN		0x00800000L						/* end a recovery scan */
#define TMMULTIPLE		0x00400000L						/* wait for any asynchronous operation */
#define TMJOIN			0x00200000L						/* caller is joining existing transaction branch */
#define TMMIGRATE		0x00100000L						/* caller intends to perform migration */
/*
 * ax_() return codes (transaction manager reports to resource manager)
 */
#define TM_JOIN			2								/* caller is joining existing transaction branch */
#define TM_RESUME		1								/* caller is resuming association with suspended transaction branch */
#define TM_OK			0								/* normal execution */
#define TMER_TMERR		(-1)							/* an error occurred in the transaction manager */
#define TMER_INVAL		(-2)							/* invalid arguments were given */
#define TMER_PROTO		(-3)							/* routine invoked in an improper context */
/*
 * xa_() return codes (resource manager reports to transaction manager)
 */
#define XA_RBBASE		100								/* The inclusive lower bound of the rollback codes */
#define XA_RBROLLBACK	XA_RBBASE						/* The rollback was caused by an unspecified reason */
#define XA_RBCOMMFAIL	XA_RBBASE+1						/* The rollback was caused by a communication failure */
#define XA_RBDEADLOCK	XA_RBBASE+2						/* A deadlock was detected */
#define XA_RBINTEGRITY	XA_RBBASE+3						/* A condition that violates the integrity of the resources was detected */
#define XA_RBOTHER		XA_RBBASE+4						/* The resource manager rolled back the transaction branch for a reason not on this list */
#define XA_RBPROTO		XA_RBBASE+5						/* A protocol error occurred in the resource manager */
#define XA_RBTIMEOUT	XA_RBBASE+6						/* A transaction branch took too long */
#define XA_RBTRANSIENT	XA_RBBASE+7						/* May retry the transaction branch */
#define XA_RBEND		XA_RBTRANSIENT					/* The inclusive upper bound of the rollback codes */

#define XA_NOMIGRATE	9								/* resumption must occur where suspension occurred */
#define XA_HEURHAZ		8								/* the transaction branch may have been heuristically completed */
#define XA_HEURCOM		7								/* the transaction branch has been heuristically committed */
#define XA_HEURRB		6								/* the transaction branch has been heuristically rolled back */
#define XA_HEURMIX		5								/* the transaction branch has been heuristically committed and rolled back */
#define XA_RETRY		4								/* routine returned with no effect and may be re-issued */
#define XA_RDONLY		3								/* the transaction branch was read-only and has been committed */
#define XA_OK			0								/* normal execution */
#define XAER_ASYNC		(-2)							/* asynchronous operation already outstanding */
#define XAER_RMERR		(-3)							/* a resource manager error occurred in the transaction branch */
#define XAER_NOTA		(-4)							/* the XID is not valid */
#define XAER_INVAL		(-5)							/* invalid arguments were given */
#define XAER_PROTO		(-6)							/* routine invoked in an improper context */
#define XAER_RMFAIL		(-7)							/* resource manager unavailable */
#define XAER_DUPID		(-8)							/* the XID already exists */
#define XAER_OUTSIDE	(-9)							/* resource manager doing work outside */
														/* global transaction */
/*
 * XA entry point type definitions:
 */

typedef int (__cdecl *XA_OPEN_EPT)(char *, int, long);	/* xa_open entry point */
typedef int (__cdecl *XA_CLOSE_EPT)(char *, int, long);	/* xa_close entry point*/
typedef int (__cdecl *XA_START_EPT)(XID *, int, long);	/* xa_start entry point */
typedef int (__cdecl *XA_END_EPT)(XID *, int, long);	/* xa_end entry point */
typedef int (__cdecl *XA_ROLLBACK_EPT)(XID *, int, long);
														/* xa_rollback entry point */
typedef int (__cdecl *XA_PREPARE_EPT)(XID *, int, long);/* xa_prepare entry point */
typedef int (__cdecl *XA_COMMIT_EPT)(XID *, int, long);	/* xa_commit entry point */
typedef int (__cdecl *XA_RECOVER_EPT)(XID *, long, int, long);
														/* xa_recover entry point*/
typedef int (__cdecl *XA_FORGET_EPT)(XID *, int, long);	/* xa_forget entry point */
typedef int (__cdecl *XA_COMPLETE_EPT)(int *, int *, int, long);
														/* xa_complete entry point */

#endif /* ifndef XA_H */
/*
 * End of xa.h header
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WtsApi32.h ===
/*********************************************************************
*
* WTSAPI32.H
*
*   Windows Terminal Server public APIs
*
*   Copyright (c) 1997-2001 Microsoft Corporation
*
**********************************************************************/

#ifndef _INC_WTSAPI
#define _INC_WTSAPI

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


/*===================================================================
==   Defines
=====================================================================*/

/*
 *  Specifies the current server
 */
#define WTS_CURRENT_SERVER         ((HANDLE)NULL)
#define WTS_CURRENT_SERVER_HANDLE  ((HANDLE)NULL)
#define WTS_CURRENT_SERVER_NAME    (NULL)

/*
 *  Specifies the current session (SessionId)
 */
#define WTS_CURRENT_SESSION ((DWORD)-1)

/*
 *  Possible pResponse values from WTSSendMessage()
 */
#ifndef IDTIMEOUT
#define IDTIMEOUT 32000
#endif
#ifndef IDASYNC
#define IDASYNC   32001
#endif

#ifndef __HYDRIX_H__
#define USERNAME_LENGTH          20
#define CLIENTNAME_LENGTH        20
#define CLIENTADDRESS_LENGTH     30
#endif
/*
 *  Shutdown flags
 */
#define WTS_WSD_LOGOFF      0x00000001  // log off all users except
                                        // current user; deletes
                                        // WinStations (a reboot is
                                        // required to recreate the
                                        // WinStations)
#define WTS_WSD_SHUTDOWN    0x00000002  // shutdown system
#define WTS_WSD_REBOOT      0x00000004  // shutdown and reboot
#define WTS_WSD_POWEROFF    0x00000008  // shutdown and power off (on
                                        // machines that support power
                                        // off through software)
#define WTS_WSD_FASTREBOOT  0x00000010  // reboot without logging users
                                        // off or shutting down
#define MAX_ELAPSED_TIME_LENGTH         15
#define MAX_DATE_TIME_LENGTH            56
#define WINSTATIONNAME_LENGTH    32
#define DOMAIN_LENGTH            17

/*===================================================================
==   WTS_CONNECTSTATE_CLASS - Session connect state
=====================================================================*/

typedef enum _WTS_CONNECTSTATE_CLASS {
    WTSActive,              // User logged on to WinStation
    WTSConnected,           // WinStation connected to client
    WTSConnectQuery,        // In the process of connecting to client
    WTSShadow,              // Shadowing another WinStation
    WTSDisconnected,        // WinStation logged on without client
    WTSIdle,                // Waiting for client to connect
    WTSListen,              // WinStation is listening for connection
    WTSReset,               // WinStation is being reset
    WTSDown,                // WinStation is down due to error
    WTSInit,                // WinStation in initialization
} WTS_CONNECTSTATE_CLASS;


/*=====================================================================
==   WTS_SERVER_INFO - returned by WTSEnumerateServers (version 1)
=====================================================================*/

/*
 *  WTSEnumerateServers() returns two variables: pServerInfo and Count.
 *  The latter is the number of WTS_SERVER_INFO structures contained in
 *  the former.  In order to read each server, iterate i from 0 to
 *  Count-1 and reference the server name as
 *  pServerInfo[i].pServerName; for example:
 *
 *  for ( i=0; i < Count; i++ ) {
 *      _tprintf( TEXT("%s "), pServerInfo[i].pServerName );
 *  }
 *
 *  The memory returned looks like the following.  P is a pServerInfo
 *  pointer, and D is the string data for that pServerInfo:
 *
 *  P1 P2 P3 P4 ... Pn D1 D2 D3 D4 ... Dn
 *
 *  This makes it easier to iterate the servers, using code similar to
 *  the above.
 */

typedef struct _WTS_SERVER_INFOW {
    LPWSTR pServerName;    // server name
} WTS_SERVER_INFOW, * PWTS_SERVER_INFOW;

typedef struct _WTS_SERVER_INFOA {
    LPSTR pServerName;     // server name
} WTS_SERVER_INFOA, * PWTS_SERVER_INFOA;

#ifdef UNICODE
#define WTS_SERVER_INFO  WTS_SERVER_INFOW
#define PWTS_SERVER_INFO PWTS_SERVER_INFOW
#else
#define WTS_SERVER_INFO  WTS_SERVER_INFOA
#define PWTS_SERVER_INFO PWTS_SERVER_INFOA
#endif


/*=====================================================================
==   WTS_SESSION_INFO - returned by WTSEnumerateSessions (version 1)
=====================================================================*/

/*
 *  WTSEnumerateSessions() returns data in a similar format to the above
 *  WTSEnumerateServers().  It returns two variables: pSessionInfo and
 *  Count.  The latter is the number of WTS_SESSION_INFO structures
 *  contained in the former.  Iteration is similar, except that there
 *  are three parts to each entry, so it would look like this:
 *
 *  for ( i=0; i < Count; i++ ) {
 *      _tprintf( TEXT("%-5u  %-20s  %u\n"),
                  pSessionInfo[i].SessionId,
 *                pSessionInfo[i].pWinStationName,
 *                pSessionInfo[i].State );
 *  }
 *
 *  The memory returned is also segmented as the above, with all the
 *  structures allocated at the start and the string data at the end.
 *  We'll use S for the SessionId, P for the pWinStationName pointer
 *  and D for the string data, and C for the connect State:
 *
 *  S1 P1 C1 S2 P2 C2 S3 P3 C3 S4 P4 C4 ... Sn Pn Cn D1 D2 D3 D4 ... Dn
 *
 *  As above, this makes it easier to iterate the sessions.
 */

typedef struct _WTS_SESSION_INFOW {
    DWORD SessionId;             // session id
    LPWSTR pWinStationName;      // name of WinStation this session is
                                 // connected to
    WTS_CONNECTSTATE_CLASS State; // connection state (see enum)
} WTS_SESSION_INFOW, * PWTS_SESSION_INFOW;

typedef struct _WTS_SESSION_INFOA {
    DWORD SessionId;             // session id
    LPSTR pWinStationName;       // name of WinStation this session is
                                 // connected to
    WTS_CONNECTSTATE_CLASS State; // connection state (see enum)
} WTS_SESSION_INFOA, * PWTS_SESSION_INFOA;


#ifdef UNICODE
#define WTS_SESSION_INFO  WTS_SESSION_INFOW
#define PWTS_SESSION_INFO PWTS_SESSION_INFOW
#else
#define WTS_SESSION_INFO  WTS_SESSION_INFOA
#define PWTS_SESSION_INFO PWTS_SESSION_INFOA
#endif


/*=====================================================================
==   WTS_PROCESS_INFO - returned by WTSEnumerateProcesses (version 1)
=====================================================================*/

/*
 *  WTSEnumerateProcesses() also returns data similar to
 *  WTSEnumerateServers().  It returns two variables: pProcessInfo and
 *  Count.  The latter is the number of WTS_PROCESS_INFO structures
 *  contained in the former.  Iteration is similar, except that there
 *  are four parts to each entry, so it would look like this:
 *
 *  for ( i=0; i < Count; i++ ) {
 *      GetUserNameFromSid( pProcessInfo[i].pUserSid, UserName,
 *                          sizeof(UserName) );
 *      _tprintf( TEXT("%-5u  %-20s  %-5u  %s\n"),
 *              pProcessInfo[i].SessionId,
 *              UserName,
 *              pProcessInfo[i].ProcessId,
 *              pProcessInfo[i].pProcessName );
 *  }
 *
 *  The memory returned is also segmented as the above, with all the
 *  structures allocated at the start and the string data at the end.
 *  We'll use S for the SessionId, R for the ProcessId, P for the
 *  pProcessName pointer and D for the string data, and U for pUserSid:
 *
 *  S1 R1 P1 U1 S2 R2 P2 U2 S3 R3 P3 U3 ... Sn Rn Pn Un D1 D2 D3 ... Dn
 *
 *  As above, this makes it easier to iterate the processes.
 */

typedef struct _WTS_PROCESS_INFOW {
    DWORD SessionId;     // session id
    DWORD ProcessId;     // process id
    LPWSTR pProcessName; // name of process
    PSID pUserSid;       // user's SID
} WTS_PROCESS_INFOW, * PWTS_PROCESS_INFOW;

typedef struct _WTS_PROCESS_INFOA {
    DWORD SessionId;     // session id
    DWORD ProcessId;     // process id
    LPSTR pProcessName;  // name of process
    PSID pUserSid;       // user's SID
} WTS_PROCESS_INFOA, * PWTS_PROCESS_INFOA;

#ifdef UNICODE
#define WTS_PROCESS_INFO  WTS_PROCESS_INFOW
#define PWTS_PROCESS_INFO PWTS_PROCESS_INFOW
#else
#define WTS_PROCESS_INFO  WTS_PROCESS_INFOA
#define PWTS_PROCESS_INFO PWTS_PROCESS_INFOA
#endif


/*=====================================================================
==   WTS_INFO_CLASS - WTSQuerySessionInformation
==    (See additional typedefs for more info on structures)
=====================================================================*/

#define WTS_PROTOCOL_TYPE_CONSOLE         0    // Console
#define WTS_PROTOCOL_TYPE_ICA             1    // ICA Protocol
#define WTS_PROTOCOL_TYPE_RDP             2    // RDP Protocol

typedef enum _WTS_INFO_CLASS {
    WTSInitialProgram,
    WTSApplicationName,
    WTSWorkingDirectory,
    WTSOEMId,
    WTSSessionId,
    WTSUserName,
    WTSWinStationName,
    WTSDomainName,
    WTSConnectState,
    WTSClientBuildNumber,
    WTSClientName,
    WTSClientDirectory,
    WTSClientProductId,
    WTSClientHardwareId,
    WTSClientAddress,
    WTSClientDisplay,
    WTSClientProtocolType,
    WTSIdleTime,
    WTSLogonTime,
    WTSIncomingBytes,
    WTSOutgoingBytes,
    WTSIncomingFrames,
    WTSOutgoingFrames,
    WTSClientInfo,
    WTSSessionInfo 
} WTS_INFO_CLASS;



/*=====================================================================
==   WTS Session Information
=====================================================================*/
typedef struct _WTSINFOW {    
    WTS_CONNECTSTATE_CLASS State; // connection state (see enum)
    DWORD SessionId;             // session id
    DWORD IncomingBytes;
    DWORD OutgoingBytes;
    DWORD IncomingFrames;
    DWORD OutgoingFrames;
    DWORD IncomingCompressedBytes;
    DWORD OutgoingCompressedBytes;
    WCHAR WinStationName[WINSTATIONNAME_LENGTH]; 
    WCHAR Domain[DOMAIN_LENGTH];
    WCHAR UserName[USERNAME_LENGTH+1];// name of WinStation this session is
                                 // connected to    
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER CurrentTime;

        
} WTSINFOW, * PWTSINFOW;


/*=====================================================================
==   WTS Session Information
=====================================================================*/
typedef struct _WTSINFOA {    
    WTS_CONNECTSTATE_CLASS State; // connection state (see enum)
    DWORD SessionId;             // session id
    DWORD IncomingBytes;
    DWORD OutgoingBytes;
    DWORD IncomingFrames;
    DWORD OutgoingFrames;
    DWORD IncomingCompressedBytes;
    DWORD OutgoingCompressedBy;
    CHAR WinStationName[WINSTATIONNAME_LENGTH]; 
    CHAR Domain[DOMAIN_LENGTH];
    CHAR UserName[USERNAME_LENGTH+1];// name of WinStation this session is
                                 // connected to    
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER CurrentTime;
        
} WTSINFOA, * PWTSINFOA;

/*=====================================================================
==   WTS Client Information
=====================================================================*/
typedef struct _WTSCLIENTW {    
    WCHAR ClientName[ CLIENTNAME_LENGTH + 1 ];
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
    WCHAR UserName[ USERNAME_LENGTH + 1 ];
    WCHAR WorkDirectory[ MAX_PATH + 1];
    WCHAR InitialProgram[ MAX_PATH + 1];
    BYTE EncryptionLevel;       // security level of encryption pd
    ULONG ClientAddressFamily;
    USHORT ClientAddress[ CLIENTADDRESS_LENGTH + 1 ];
    USHORT HRes;
    USHORT VRes;
    USHORT ColorDepth;
    WCHAR ClientDirectory[ MAX_PATH + 1 ];
    ULONG ClientBuildNumber;
    ULONG ClientHardwareId;    // client software serial number
    USHORT ClientProductId;     // client software product id
    USHORT OutBufCountHost;     // number of outbufs on host
    USHORT OutBufCountClient;   // number of outbufs on client
    USHORT OutBufLength;        // length of outbufs in bytes
    WCHAR  DeviceId[ MAX_PATH + 1];
} WTSCLIENTW, * PWTSCLIENTW;


/*=====================================================================
==   WTS Client Information
=====================================================================*/
typedef struct _WTSCLIENTA {    
    CHAR ClientName[ CLIENTNAME_LENGTH + 1 ];
    CHAR Domain[ DOMAIN_LENGTH + 1 ];
    CHAR UserName[ USERNAME_LENGTH + 1 ];
    CHAR WorkDirectory[ MAX_PATH + 1];
    CHAR InitialProgram[ MAX_PATH + 1 ];
    BYTE EncryptionLevel;       // security level of encryption pd
    ULONG ClientAddressFamily;
    USHORT ClientAddress[ CLIENTADDRESS_LENGTH + 1 ];
    USHORT HRes;
    USHORT VRes;
    USHORT ColorDepth;
    CHAR ClientDirectory[ MAX_PATH + 1 ];
    ULONG ClientBuildNumber;
    ULONG ClientHardwareId;    // client software serial number
    USHORT ClientProductId;     // client software product id
    USHORT OutBufCountHost;     // number of outbufs on host
    USHORT OutBufCountClient;   // number of outbufs on client
    USHORT OutBufLength;        // length of outbufs in bytes
    CHAR  DeviceId[ MAX_PATH + 1];
} WTSCLIENTA, * PWTSCLIENTA;
	

#ifdef UNICODE
#define WTSINFO  WTSINFOW
#define PWTSINFO PWTSINFOW
#define WTSCLIENT WTSCLIENTW
#define PWTSCLIENT PWTSCLIENTW
#else
#define WTSINFO  WTSINFOA
#define PWTSINFO PWTSINFOA
#define WTSCLIENT WTSCLIENTA
#define PWTSCLIENT PWTSCLIENTA

#endif


/*=====================================================================
==   WTSQuerySessionInformation - (WTSClientAddress)
=====================================================================*/

typedef struct _WTS_CLIENT_ADDRESS {
    DWORD AddressFamily;  // AF_INET, AF_INET6, AF_IPX, AF_NETBIOS, AF_UNSPEC
    BYTE  Address[20];    // client network address
} WTS_CLIENT_ADDRESS, * PWTS_CLIENT_ADDRESS;


/*=====================================================================
==   WTSQuerySessionInformation - (WTSClientDisplay)
=====================================================================*/

typedef struct _WTS_CLIENT_DISPLAY {
    DWORD HorizontalResolution; // horizontal dimensions, in pixels
    DWORD VerticalResolution;   // vertical dimensions, in pixels
    DWORD ColorDepth;           // 1=16, 2=256, 4=64K, 8=16M
} WTS_CLIENT_DISPLAY, * PWTS_CLIENT_DISPLAY;


/*=====================================================================
==   WTS_CONFIG_CLASS - WTSQueryUserConfig/WTSSetUserConfig
=====================================================================*/


typedef enum _WTS_CONFIG_CLASS {
    //Initial program settings
    WTSUserConfigInitialProgram,            // string returned/expected
    WTSUserConfigWorkingDirectory,          // string returned/expected
    WTSUserConfigfInheritInitialProgram,    // DWORD returned/expected
    //
    WTSUserConfigfAllowLogonTerminalServer,     //DWORD returned/expected
    //Timeout settings
    WTSUserConfigTimeoutSettingsConnections,    //DWORD returned/expected
    WTSUserConfigTimeoutSettingsDisconnections, //DWORD returned/expected
    WTSUserConfigTimeoutSettingsIdle,           //DWORD returned/expected
    //Client device settings
    WTSUserConfigfDeviceClientDrives,       //DWORD returned/expected
    WTSUserConfigfDeviceClientPrinters,         //DWORD returned/expected
    WTSUserConfigfDeviceClientDefaultPrinter,   //DWORD returned/expected
    //Connection settings
    WTSUserConfigBrokenTimeoutSettings,         //DWORD returned/expected
    WTSUserConfigReconnectSettings,             //DWORD returned/expected
    //Modem settings
    WTSUserConfigModemCallbackSettings,         //DWORD returned/expected
    WTSUserConfigModemCallbackPhoneNumber,      // string returned/expected
    //Shadow settings
    WTSUserConfigShadowingSettings,             //DWORD returned/expected
    //User Profile settings
    WTSUserConfigTerminalServerProfilePath,     // string returned/expected
    //Terminal Server home directory
    WTSUserConfigTerminalServerHomeDir,       // string returned/expected
    WTSUserConfigTerminalServerHomeDirDrive,    // string returned/expected
    WTSUserConfigfTerminalServerRemoteHomeDir,  // DWORD 0:LOCAL 1:REMOTE

} WTS_CONFIG_CLASS;


/*=====================================================================
==   WTS_EVENT - Event flags for WTSWaitSystemEvent
=====================================================================*/

#define WTS_EVENT_NONE         0x00000000 // return no event
#define WTS_EVENT_CREATE       0x00000001 // new WinStation created
#define WTS_EVENT_DELETE       0x00000002 // existing WinStation deleted
#define WTS_EVENT_RENAME       0x00000004 // existing WinStation renamed
#define WTS_EVENT_CONNECT      0x00000008 // WinStation connect to client
#define WTS_EVENT_DISCONNECT   0x00000010 // WinStation logged on without
                                          //     client
#define WTS_EVENT_LOGON        0x00000020 // user logged on to existing
                                          //     WinStation
#define WTS_EVENT_LOGOFF       0x00000040 // user logged off from
                                          //     existing WinStation
#define WTS_EVENT_STATECHANGE  0x00000080 // WinStation state change
#define WTS_EVENT_LICENSE      0x00000100 // license state change
#define WTS_EVENT_ALL          0x7fffffff // wait for all event types
#define WTS_EVENT_FLUSH        0x80000000 // unblock all waiters

/*=====================================================================
==   Flags for HotkeyModifiers in WTSStartRemoteControlSession
=====================================================================*/

#define REMOTECONTROL_KBDSHIFT_HOTKEY              0x1    // Shift key
#define REMOTECONTROL_KBDCTRL_HOTKEY               0x2    // Ctrl key
#define REMOTECONTROL_KBDALT_HOTKEY                0x4    // Alt key

/*=====================================================================
==   WTS_VIRTUAL_CLASS - WTSVirtualChannelQuery
=====================================================================*/
typedef enum _WTS_VIRTUAL_CLASS {
    WTSVirtualClientData,  // Virtual channel client module data
                           //     (C2H data)
    WTSVirtualFileHandle
} WTS_VIRTUAL_CLASS;


/*=====================================================================
==   Windows Terminal Server public APIs
=====================================================================*/

BOOL WINAPI
WTSStopRemoteControlSession(
    IN ULONG   LogonId
    );

BOOL WINAPI
WTSStartRemoteControlSessionW(
    __in LPWSTR  pTargetServerName,
    IN ULONG   TargetLogonId,
    IN BYTE    HotkeyVk,
    IN USHORT  HotkeyModifiers
    );

BOOL WINAPI
WTSStartRemoteControlSessionA(
    __in LPSTR  pTargetServerName,
    IN ULONG   TargetLogonId,
    IN BYTE    HotkeyVk,
    IN USHORT  HotkeyModifiers
    );

#ifdef UNICODE
#define WTSStartRemoteControlSession WTSStartRemoteControlSessionW
#else
#define WTSStartRemoteControlSession WTSStartRemoteControlSessionA
#endif /* UNICODE */

BOOL
WINAPI
WTSConnectSessionA(
    IN ULONG LogonId,
    IN ULONG TargetLogonId,
    __in PSTR pPassword,
    IN BOOL bWait
    );

BOOL
WINAPI
WTSConnectSessionW(
    IN ULONG LogonId,
    IN ULONG TargetLogonId,
    __in PWSTR pPassword,
    IN BOOL bWait
    );

#ifdef UNICODE
#define WTSConnectSession WTSConnectSessionW
#else
#define WTSConnectSession WTSConnectSessionA
#endif

BOOL
WINAPI
WTSEnumerateServersW(
    __in LPWSTR pDomainName,
    IN DWORD Reserved,
    IN DWORD Version,
    __deref_out_ecount(*pCount) PWTS_SERVER_INFOW * ppServerInfo,
    __out DWORD * pCount
    );

BOOL
WINAPI
WTSEnumerateServersA(
    __in LPSTR pDomainName,
    IN DWORD Reserved,
    IN DWORD Version,
    __deref_out_ecount(*pCount)  PWTS_SERVER_INFOA * ppServerInfo,
    __out DWORD * pCount
    );

#ifdef UNICODE
#define WTSEnumerateServers WTSEnumerateServersW
#else
#define WTSEnumerateServers WTSEnumerateServersA
#endif

/*------------------------------------------------*/

HANDLE
WINAPI
WTSOpenServerW(
    __in LPWSTR pServerName
    );

HANDLE
WINAPI
WTSOpenServerA(
    __in LPSTR pServerName
    );

#ifdef UNICODE
#define WTSOpenServer WTSOpenServerW
#else
#define WTSOpenServer WTSOpenServerA
#endif

/*------------------------------------------------*/

VOID
WINAPI
WTSCloseServer(
    IN HANDLE hServer
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSEnumerateSessionsW(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    __deref_out_ecount(*pCount) PWTS_SESSION_INFOW * ppSessionInfo,
    __out DWORD * pCount
    );

BOOL
WINAPI
WTSEnumerateSessionsA(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    __deref_out_ecount(*pCount)  PWTS_SESSION_INFOA * ppSessionInfo,
    __out DWORD * pCount
    );

#ifdef UNICODE
#define WTSEnumerateSessions WTSEnumerateSessionsW
#else
#define WTSEnumerateSessions WTSEnumerateSessionsA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSEnumerateProcessesW(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_PROCESS_INFOW * ppProcessInfo,
    OUT DWORD * pCount
    );

BOOL
WINAPI
WTSEnumerateProcessesA(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_PROCESS_INFOA * ppProcessInfo,
    OUT DWORD * pCount
    );

#ifdef UNICODE
#define WTSEnumerateProcesses WTSEnumerateProcessesW
#else
#define WTSEnumerateProcesses WTSEnumerateProcessesA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSTerminateProcess(
    IN HANDLE hServer,
    IN DWORD ProcessId,
    IN DWORD ExitCode
    );


/*------------------------------------------------*/

BOOL
WINAPI
WTSQuerySessionInformationW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    __deref_out_bcount(*pBytesReturned) LPWSTR * ppBuffer,
    __out DWORD * pBytesReturned
    );

BOOL
WINAPI
WTSQuerySessionInformationA(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    __deref_out_bcount(*pBytesReturned) LPSTR * ppBuffer,
    __out DWORD * pBytesReturned
    );

#ifdef UNICODE
#define WTSQuerySessionInformation WTSQuerySessionInformationW
#else
#define WTSQuerySessionInformation WTSQuerySessionInformationA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSQueryUserConfigW(
    __in LPWSTR pServerName,
    __in LPWSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    __deref_out_bcount(*pBytesReturned) LPWSTR * ppBuffer,
    __out DWORD * pBytesReturned
    );

BOOL
WINAPI
WTSQueryUserConfigA(
    __in LPSTR pServerName,
    __in LPSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    __deref_out_bcount(*pBytesReturned) LPSTR * ppBuffer,
    __out DWORD * pBytesReturned
    );

#ifdef UNICODE
#define WTSQueryUserConfig WTSQueryUserConfigW
#else
#define WTSQueryUserConfig WTSQueryUserConfigA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSSetUserConfigW(
    __in LPWSTR pServerName,
    __in LPWSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    __in_bcount(DataLength) LPWSTR pBuffer,
    IN DWORD DataLength
    );

BOOL
WINAPI
WTSSetUserConfigA(
    __in LPSTR pServerName,
    __in LPSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    __in_bcount(DataLength) LPSTR pBuffer,
    IN DWORD DataLength
    );

#ifdef UNICODE
#define WTSSetUserConfig WTSSetUserConfigW
#else
#define WTSSetUserConfig WTSSetUserConfigA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSSendMessageW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    __in_bcount(TitleLength) LPWSTR pTitle,
    IN DWORD TitleLength,
    __in_bcount(MessageLength) LPWSTR pMessage,
    IN DWORD MessageLength,
    IN DWORD Style,
    IN DWORD Timeout,
    __out DWORD * pResponse,
    IN BOOL bWait
    );

BOOL
WINAPI
WTSSendMessageA(
    IN HANDLE hServer,
    IN DWORD SessionId,
    __in_bcount(TitleLength) LPSTR pTitle,
    IN DWORD TitleLength,
    __in_bcount(MessageLength) LPSTR pMessage,
    IN DWORD MessageLength,
    IN DWORD Style,
    IN DWORD Timeout,
    __out DWORD * pResponse,
    IN BOOL bWait
    );

#ifdef UNICODE
#define WTSSendMessage WTSSendMessageW
#else
#define WTSSendMessage WTSSendMessageA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSDisconnectSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSLogoffSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSShutdownSystem(
    IN HANDLE hServer,
    IN DWORD ShutdownFlag
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSWaitSystemEvent(
    IN HANDLE hServer,
    IN DWORD EventMask,
    OUT DWORD * pEventFlags
    );

/*------------------------------------------------*/

HANDLE
WINAPI
WTSVirtualChannelOpen(
    IN HANDLE hServer,
    IN DWORD SessionId,
    __in LPSTR pVirtualName   /* ascii name */
    );

#define WTS_CHANNEL_OPTION_DYNAMIC          0x00000001       // dynamic channel
#define WTS_CHANNEL_OPTION_DYNAMIC_PRI_LOW  0x00000000   // priorities
#define WTS_CHANNEL_OPTION_DYNAMIC_PRI_MED  0x00000002
#define WTS_CHANNEL_OPTION_DYNAMIC_PRI_HIGH 0x00000004
#define WTS_CHANNEL_OPTION_DYNAMIC_PRI_REAL 0x00000006

HANDLE
WINAPI
WTSVirtualChannelOpenEx(
                     IN DWORD SessionId,
                     __in LPSTR pVirtualName,   /* ascii name */
                     IN DWORD flags
                     );

BOOL
WINAPI
WTSVirtualChannelClose(
    IN HANDLE hChannelHandle
    );

BOOL
WINAPI
WTSVirtualChannelRead(
    IN HANDLE hChannelHandle,
    IN ULONG TimeOut,
    __out_bcount_part(BufferSize, *pBytesRead) PCHAR Buffer,
    IN ULONG BufferSize,
    __out PULONG pBytesRead
    );

BOOL
WINAPI
WTSVirtualChannelWrite(
    IN HANDLE hChannelHandle,
    __in_bcount(Length) PCHAR Buffer,
    IN ULONG Length,
    __out PULONG pBytesWritten
    );

BOOL
WINAPI
WTSVirtualChannelPurgeInput(
    IN HANDLE hChannelHandle
    );

BOOL
WINAPI
WTSVirtualChannelPurgeOutput(
    IN HANDLE hChannelHandle
    );


BOOL
WINAPI
WTSVirtualChannelQuery(
    IN HANDLE hChannelHandle,
    IN WTS_VIRTUAL_CLASS,
    OUT PVOID *ppBuffer,
    OUT DWORD *pBytesReturned
    );

/*------------------------------------------------*/


VOID
WINAPI
WTSFreeMemory(
    IN PVOID pMemory
    );

/* Flags for Console Notification */

#define NOTIFY_FOR_ALL_SESSIONS     1
#define NOTIFY_FOR_THIS_SESSION     0


BOOL
WINAPI
WTSRegisterSessionNotification(
    HWND hWnd,
    DWORD dwFlags
    );

BOOL
WINAPI
WTSUnRegisterSessionNotification(
    HWND hWnd
    );


BOOL
WINAPI
WTSRegisterSessionNotificationEx(
    IN HANDLE hServer,
    IN HWND hWnd,
    IN DWORD dwFlags
    );

BOOL
WINAPI
WTSUnRegisterSessionNotificationEx(
    IN HANDLE hServer,
    IN HWND hWnd
    );

BOOL
WINAPI
WTSQueryUserToken(
    ULONG SessionId,
    PHANDLE phToken
    );



#ifdef __cplusplus
}
#endif

#endif  /* !_INC_WTSAPI */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\XCMCMSX2.h ===
/*
 *  XCMCMSX2.H
 *  
 *  Purpose:
 *  Specifies constants and data structures for Microsoft CMC extensions
 *  set update (forms extensions)
 *  
 */

#ifndef _XCMCMSX2_H
#define _XCMCMSX2_H

#ifndef XCMCMSXT_H
#   include <xcmcmsxt.h>
#endif

#ifndef MAPIDEFS_H
#   include <mapidefs.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Get an extended MAPI session from a CMC session */
#ifdef MAPIX_H

STDMETHODIMP_(SCODE)
ScMAPIXFromCMC(CMC_session_id cmc_session,
                ULONG ulFlags,
                LPCIID lpInterface,
                LPMAPISESSION FAR * lppMAPISession);

#endif /* MAPIX_H */

/* Extra flag for CMC_X_MS_ATTACH_DATA */
#define CMC_X_MS_ATTACH_MESSAGE         ((CMC_flags) 4)

/* Attachment descriptor for CMC_X_ATTACH_DATA */
typedef struct {
    CMC_message_reference FAR *message;
    CMC_uint32              id;
    CMC_buffer              object;
} CMC_X_MS_ATTACH;  

#ifdef __cplusplus
}      /* extern "C" */
#endif

#endif /* _XCMCMSX2_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\XCMCMSXT.h ===
/*
 *  XCMCMSXT.H
 *  
 *  Purpose:
 *  Specifies constants and data structures for Microsoft CMC extension set
 *  
 */

#ifndef XCMCMSXT_H
#define XCMCMSXT_H

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************
 Warning: Value for MS_EXT_SET_ID has not been finalized yet.
 ***********************************************************************/
#define MS_EXT_SET_ID                   (512)

#define CMC_XS_MS                       ((CMC_uint32) MS_EXT_SET_ID)

/*** FUNCTION EXTENSIONS ***/

/* Describes extra flags used for logging on/off a session */
#define CMC_X_MS_SESSION_FLAGS          ((CMC_uint32) MS_EXT_SET_ID + 16)
#define CMC_X_MS_NEW_SESSION            ((CMC_flags) 1)
#define CMC_X_MS_FORCE_DOWNLOAD         ((CMC_flags) 4)

/* Flags used by various functions */
#define CMC_X_MS_FUNCTION_FLAGS         ((CMC_uint32) MS_EXT_SET_ID + 17)
#define CMC_X_MS_READ_ENV_ONLY          ((CMC_flags) 1)
#define CMC_X_MS_READ_BODY_AS_FILE      ((CMC_flags) 2)
#define CMC_X_MS_LIST_GUARANTEE_FIFO    ((CMC_flags) 4)
#define CMC_X_MS_AB_NO_MODIFY           ((CMC_flags) 8)

/* Extra options when displaying the Address Book UI */
#define CMC_X_MS_ADDRESS_UI             ((CMC_uint32) MS_EXT_SET_ID + 18)

/*** DATA EXTENSIONS ***/

/* Extra flags for attachments */
#define CMC_X_MS_ATTACH_DATA            ((CMC_uint32) MS_EXT_SET_ID + 128)
#define CMC_X_MS_ATTACH_OLE             ((CMC_flags) 1)
#define CMC_X_MS_ATTACH_OLE_STATIC      ((CMC_flags) 2)

/* Extra data for messages */
#define CMC_X_MS_MESSAGE_DATA           ((CMC_uint32) MS_EXT_SET_ID + 129)
#define CMC_X_MS_MSG_RECEIPT_REQ        ((CMC_flags) 1)

#ifdef __cplusplus
}      /* extern "C" */
#endif

#endif /* XCMCMSXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WSPiApi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:
    wspiapi.h

Abstract:
    The file contains protocol independent API functions.

Revision History:
    Wed Jul 12 10:50:31 2000, Created

--*/

#ifndef _WSPIAPI_H_
#define _WSPIAPI_H_

#pragma once

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#include <stdio.h>              // sprintf()
#include <stdlib.h>             // calloc(), strtoul()
#include <malloc.h>             // calloc()
#include <string.h>             // strlen(), strcmp(), strstr()

#if defined(__GOT_SECURE_LIB__) && __GOT_SECURE_LIB__ >= 200402L

#define _WSPIAPI_STRCPY_S strcpy_s
#define _WSPIAPI_STRCAT_S strcat_s
#define _WSPIAPI_STRNCPY_S strncpy_s
#define _WSPIAPI_SPRINTF_S_1 sprintf_s

#else

#define _WSPIAPI_STRCPY_S(_Dst, _Size, _Src) strcpy((_Dst), (_Src))
#define _WSPIAPI_STRCAT_S(_Dst, _Size, _Src) strcat((_Dst), (_Src))
#define _WSPIAPI_STRNCPY_S(_Dst, _Size, _Src, _Count) strncpy((_Dst), (_Src), (_Count)); (_Dst)[(_Size) - 1] = 0
#define _WSPIAPI_SPRINTF_S_1(_Dst, _Size, _Format, _Arg1) sprintf((_Dst), (_Format), (_Arg1))

#endif // defined(__GOT_SECURE_LIB__) && __GOT_SECURE_LIB__ >= 200402L

#if !defined(_WSPIAPI_COUNTOF)
#if !defined(__cplusplus)
#define _WSPIAPI_COUNTOF(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
template <typename __CountofType, size_t _N>
char (&__wspiapi_countof_helper(__CountofType (&_Array)[_N]))[_N];
#define _WSPIAPI_COUNTOF(_Array) sizeof(__wspiapi_countof_helper(_Array))
#endif
#endif

#define WspiapiMalloc(tSize)    calloc(1, (tSize))
#define WspiapiFree(p)          free(p)
#define WspiapiSwap(a, b, c)    { (c) = (a); (a) = (b); (b) = (c); }
#define getaddrinfo             WspiapiGetAddrInfo
#define getnameinfo             WspiapiGetNameInfo
#define freeaddrinfo            WspiapiFreeAddrInfo

//
// These function pointers are also within the #if (NTDDI_VERSION >= WIN2K)
// because they are used by the other functions defined in this file available
// only on win2k and above.
//
typedef int (WINAPI *WSPIAPI_PGETADDRINFO) (
    IN  const char                      *nodename,
    IN  const char                      *servname,
    IN  const struct addrinfo           *hints,
    OUT struct addrinfo                 **res);

typedef int (WINAPI *WSPIAPI_PGETNAMEINFO) (
    IN  const struct sockaddr           *sa,
    IN  socklen_t                       salen,
    OUT char                            *host,
    IN  size_t                          hostlen,
    OUT char                            *serv,
    IN  size_t                          servlen,
    IN  int                             flags);

typedef void (WINAPI *WSPIAPI_PFREEADDRINFO) (
    IN  struct addrinfo                 *ai);



#ifdef __cplusplus
extern "C" {
#endif
    
////////////////////////////////////////////////////////////
// v4 only versions of getaddrinfo and friends.
// NOTE: gai_strerror is inlined in ws2tcpip.h
////////////////////////////////////////////////////////////

_inline    
char *
WINAPI
WspiapiStrdup (
        IN  const char *                    pszString)
/*++

Routine Description
    allocates enough storage via calloc() for a copy of the string,
    copies the string into the new memory, and returns a pointer to it.

Arguments
    pszString       string to copy into new memory

Return Value
    a pointer to the newly allocated storage with the string in it.
    NULL if enough memory could not be allocated, or string was NULL.

--*/    
{
    char    *pszMemory;
    size_t  cchMemory;

    if (!pszString)
        return(NULL);

    cchMemory = strlen(pszString) + 1;
    pszMemory = (char *) WspiapiMalloc(cchMemory);
    if (!pszMemory)
        return(NULL);

    _WSPIAPI_STRCPY_S(pszMemory, cchMemory, pszString);
    return pszMemory;
}

    
    
__inline
BOOL
WINAPI
WspiapiParseV4Address (
    IN  const char *                    pszAddress,
    OUT PDWORD                          pdwAddress)
/*++

Routine Description
    get the IPv4 address (in network byte order) from its string
    representation.  the syntax should be a.b.c.d.
    
Arguments
    pszArgument         string representation of the IPv4 address
    ptAddress           pointer to the resulting IPv4 address

Return Value
    Returns FALSE if there is an error, TRUE for success.
    
--*/
{
    DWORD       dwAddress   = 0;
    const char  *pcNext     = NULL;
    int         iCount      = 0;

    // ensure there are 3 '.' (periods)
    for (pcNext = pszAddress; *pcNext != '\0'; pcNext++)
        if (*pcNext == '.')
            iCount++;
    if (iCount != 3)
        return FALSE;

    // return an error if dwAddress is INADDR_NONE (255.255.255.255)
    // since this is never a valid argument to getaddrinfo.
    dwAddress = inet_addr(pszAddress);
    if (dwAddress == INADDR_NONE)
        return FALSE;

    *pdwAddress = dwAddress;
    return TRUE;
}



__inline
struct addrinfo *
WINAPI
WspiapiNewAddrInfo (
    IN  int                             iSocketType,
    IN  int                             iProtocol,
    IN  WORD                            wPort,
    IN  DWORD                           dwAddress)
/*++

Routine Description
    allocate an addrinfo structure and populate fields.
    IPv4 specific internal function, not exported.
    
Arguments
    iSocketType         SOCK_*.  can be wildcarded (zero).
    iProtocol           IPPROTO_*.  can be wildcarded (zero).
    wPort               port number of service (in network order).
    dwAddress           IPv4 address (in network order).
    
Return Value
    returns an addrinfo struct, or NULL if out of memory.

--*/    
{
    struct addrinfo     *ptNew;
    struct sockaddr_in  *ptAddress;

    // allocate a new addrinfo structure.
    ptNew       =
        (struct addrinfo *) WspiapiMalloc(sizeof(struct addrinfo));
    if (!ptNew)
        return NULL;

    ptAddress   =
        (struct sockaddr_in *) WspiapiMalloc(sizeof(struct sockaddr_in));
    if (!ptAddress)
    {
        WspiapiFree(ptNew);
        return NULL;
    }
    ptAddress->sin_family       = AF_INET;
    ptAddress->sin_port         = wPort;
    ptAddress->sin_addr.s_addr  = dwAddress;
    
    // fill in the fields...
    ptNew->ai_family            = PF_INET;
    ptNew->ai_socktype          = iSocketType;
    ptNew->ai_protocol          = iProtocol;
    ptNew->ai_addrlen           = sizeof(struct sockaddr_in);
    ptNew->ai_addr              = (struct sockaddr *) ptAddress;

    return ptNew;
}



__inline
int
WINAPI
WspiapiQueryDNS(
    IN  const char                      *pszNodeName,
    IN  int                             iSocketType,
    IN  int                             iProtocol,  
    IN  WORD                            wPort,      
    OUT char                            pszAlias[NI_MAXHOST],
    OUT struct addrinfo                 **pptResult)
/*++

Routine Description
    helper routine for WspiapiLookupNode.
    performs name resolution by querying the DNS for A records.
    *pptResult would need to be freed if an error is returned.
    
Arguments
    pszNodeName         name of node to resolve.
    iSocketType         SOCK_*.  can be wildcarded (zero).
    iProtocol           IPPROTO_*.  can be wildcarded (zero).
    wPort               port number of service (in network order).
    pszAlias            where to return the alias.  must be of size NI_MAXHOST.
    pptResult           where to return the result.
    
Return Value
    Returns 0 on success, an EAI_* style error value otherwise.

--*/    
{
    struct addrinfo **pptNext   = pptResult;
    struct hostent  *ptHost     = NULL;
    char            **ppAddresses;

    *pptNext    = NULL;
    pszAlias[0] = '\0';

    ptHost = gethostbyname(pszNodeName);
    if (ptHost)
    {
        if ((ptHost->h_addrtype == AF_INET)     &&
            (ptHost->h_length   == sizeof(struct in_addr)))
        {
            for (ppAddresses    = ptHost->h_addr_list;
                 *ppAddresses   != NULL;
                 ppAddresses++)
            {
                // create an addrinfo structure...
                *pptNext = WspiapiNewAddrInfo(
                    iSocketType,
                    iProtocol,
                    wPort,
                    ((struct in_addr *) *ppAddresses)->s_addr);
                if (!*pptNext)
                    return EAI_MEMORY;

                pptNext = &((*pptNext)->ai_next);
            }
        }

        // pick up the canonical name.
        _WSPIAPI_STRNCPY_S(pszAlias, NI_MAXHOST, ptHost->h_name, NI_MAXHOST - 1);
        
        return 0;
    }
    
    switch (WSAGetLastError())
    {
        case WSAHOST_NOT_FOUND: return EAI_NONAME;
        case WSATRY_AGAIN:      return EAI_AGAIN;
        case WSANO_RECOVERY:    return EAI_FAIL;
        case WSANO_DATA:        return EAI_NODATA;
        default:                return EAI_NONAME;
    }
}



__inline
int
WINAPI
WspiapiLookupNode(
    IN  const char                      *pszNodeName,
    IN  int                             iSocketType,
    IN  int                             iProtocol,  
    IN  WORD                            wPort,      
    IN  BOOL                            bAI_CANONNAME,
    OUT struct addrinfo                 **pptResult)
/*++

Routine Description
    resolve a nodename and return a list of addrinfo structures.
    IPv4 specific internal function, not exported.
    *pptResult would need to be freed if an error is returned.
    
    NOTE: if bAI_CANONNAME is true, the canonical name should be
          returned in the first addrinfo structure.
    
Arguments
    pszNodeName         name of node to resolve.
    iSocketType         SOCK_*.  can be wildcarded (zero).
    iProtocol           IPPROTO_*.  can be wildcarded (zero).
    wPort               port number of service (in network order).
    bAI_CANONNAME       whether the AI_CANONNAME flag is set.
    pptResult           where to return result.
    
Return Value
    Returns 0 on success, an EAI_* style error value otherwise.

--*/
{
    int     iError              = 0;
    int     iAliasCount         = 0;

    char    szFQDN1[NI_MAXHOST] = "";
    char    szFQDN2[NI_MAXHOST] = "";
    char    *pszName            = szFQDN1;
    char    *pszAlias           = szFQDN2;
    char    *pszScratch         = NULL;
    _WSPIAPI_STRNCPY_S(pszName, NI_MAXHOST, pszNodeName, NI_MAXHOST - 1);
    
    for (;;)
    {
        iError = WspiapiQueryDNS(pszNodeName,
                                 iSocketType,
                                 iProtocol,
                                 wPort,
                                 pszAlias,
                                 pptResult);
        if (iError)
            break;

        // if we found addresses, then we are done.
        if (*pptResult)
            break;

        // stop infinite loops due to DNS misconfiguration.  there appears
        // to be no particular recommended limit in RFCs 1034 and 1035.
        if ((!strlen(pszAlias))             ||
            (!strcmp(pszName, pszAlias))    ||
            (++iAliasCount == 16))
        {
            iError = EAI_FAIL;
            break;
        }

        // there was a new CNAME, look again.
        WspiapiSwap(pszName, pszAlias, pszScratch);
    }

    if (!iError && bAI_CANONNAME)
    {
        (*pptResult)->ai_canonname = WspiapiStrdup(pszAlias);
        if (!(*pptResult)->ai_canonname)
            iError = EAI_MEMORY;
    }

    return iError;
}



__inline
int
WINAPI
WspiapiClone (
    IN  WORD                            wPort,      
    IN  struct addrinfo                 *ptResult)
/*++

Routine Description
    clone every addrinfo structure in ptResult for the UDP service.
    ptResult would need to be freed if an error is returned.
    
Arguments
    wPort               port number of UDP service.
    ptResult            list of addrinfo structures, each
                        of whose node needs to be cloned.

Return Value
    Returns 0 on success, an EAI_MEMORY on allocation failure.

--*/
{
    struct addrinfo *ptNext = NULL;
    struct addrinfo *ptNew  = NULL;

    for (ptNext = ptResult; ptNext != NULL; )
    {
        // create an addrinfo structure...
        ptNew = WspiapiNewAddrInfo(
            SOCK_DGRAM,
            ptNext->ai_protocol,
            wPort,
            ((struct sockaddr_in *) ptNext->ai_addr)->sin_addr.s_addr);
        if (!ptNew)
            break;

        // link the cloned addrinfo
        ptNew->ai_next  = ptNext->ai_next;
        ptNext->ai_next = ptNew;
        ptNext          = ptNew->ai_next;
    }

    if (ptNext != NULL)
        return EAI_MEMORY;
    
    return 0;
}



__inline
void
WINAPI
WspiapiLegacyFreeAddrInfo (
    IN  struct addrinfo                 *ptHead)
/*++

Routine Description
    Free an addrinfo structure (or chain of structures).
    As specified in RFC 2553, Section 6.4.
    
Arguments
    ptHead              structure (chain) to free
    
--*/    
{
    struct addrinfo *ptNext;    // next strcture to free

    for (ptNext = ptHead; ptNext != NULL; ptNext = ptHead)
    {
        if (ptNext->ai_canonname)
            WspiapiFree(ptNext->ai_canonname);
        
        if (ptNext->ai_addr)
            WspiapiFree(ptNext->ai_addr);

        ptHead = ptNext->ai_next;
        WspiapiFree(ptNext);
    }
}



__inline
int
WINAPI
WspiapiLegacyGetAddrInfo(
    IN const char                       *pszNodeName,
    IN const char                       *pszServiceName,
    IN const struct addrinfo            *ptHints,
    OUT struct addrinfo                 **pptResult)
/*++

Routine Description
    Protocol-independent name-to-address translation.
    As specified in RFC 2553, Section 6.4.
    This is the hacked version that only supports IPv4.
    
Arguments
    pszNodeName         node name to lookup.
    pszServiceName      service name to lookup.
    ptHints             hints about how to process request.
    pptResult           where to return result.
    
Return Value
    returns zero if successful, an EAI_* error code if not.

--*/    
{
    int                 iError      = 0;
    int                 iFlags      = 0;
    int                 iFamily     = PF_UNSPEC;
    int                 iSocketType = 0;
    int                 iProtocol   = 0;
    WORD                wPort       = 0;
    DWORD               dwAddress   = 0;

    struct servent      *ptService  = NULL;
    char                *pc         = NULL;
    BOOL                bClone      = FALSE;
    WORD                wTcpPort    = 0;
    WORD                wUdpPort    = 0;
    
    
    // initialize pptResult with default return value.
    *pptResult  = NULL;


    ////////////////////////////////////////
    // validate arguments...
    //
    
    // both the node name and the service name can't be NULL.
    if ((!pszNodeName) && (!pszServiceName))
        return EAI_NONAME;

    // validate hints.
    if (ptHints)
    {
        // all members other than ai_flags, ai_family, ai_socktype
        // and ai_protocol must be zero or a null pointer.
        if ((ptHints->ai_addrlen    != 0)       ||
            (ptHints->ai_canonname  != NULL)    ||
            (ptHints->ai_addr       != NULL)    ||
            (ptHints->ai_next       != NULL))
        {
            return EAI_FAIL;
        }
        
        // the spec has the "bad flags" error code, so presumably we
        // should check something here.  insisting that there aren't
        // any unspecified flags set would break forward compatibility,
        // however.  so we just check for non-sensical combinations.
        //
        // we cannot come up with a canonical name given a null node name.
        iFlags      = ptHints->ai_flags;
        if ((iFlags & AI_CANONNAME) && !pszNodeName)
            return EAI_BADFLAGS;

        // we only support a limited number of protocol families.
        iFamily     = ptHints->ai_family;
        if ((iFamily != PF_UNSPEC) && (iFamily != PF_INET))
            return EAI_FAMILY;

        // we only support only these socket types.
        iSocketType = ptHints->ai_socktype;
        if ((iSocketType != 0)                  &&
            (iSocketType != SOCK_STREAM)        &&
            (iSocketType != SOCK_DGRAM)         &&
            (iSocketType != SOCK_RAW))
            return EAI_SOCKTYPE;

        // REVIEW: What if ai_socktype and ai_protocol are at odds?
        iProtocol   = ptHints->ai_protocol;
    }


    ////////////////////////////////////////
    // do service lookup...

    if (pszServiceName)
    {
        wPort = (WORD) strtoul(pszServiceName, &pc, 10);
        if (*pc == '\0')        // numeric port string
        {
            wPort = wTcpPort = wUdpPort = htons(wPort);
            if (iSocketType == 0)
            {
                bClone      = TRUE;
                iSocketType = SOCK_STREAM;
            }
        }
        else                    // non numeric port string
        {
            if ((iSocketType == 0) || (iSocketType == SOCK_DGRAM))
            {
                ptService = getservbyname(pszServiceName, "udp");
                if (ptService)
                    wPort = wUdpPort = ptService->s_port;
            }

            if ((iSocketType == 0) || (iSocketType == SOCK_STREAM))
            {
                ptService = getservbyname(pszServiceName, "tcp");
                if (ptService)
                    wPort = wTcpPort = ptService->s_port;
            }
            
            // assumes 0 is an invalid service port...
            if (wPort == 0)     // no service exists
                return (iSocketType ? EAI_SERVICE : EAI_NONAME);

            if (iSocketType == 0)
            {
                // if both tcp and udp, process tcp now & clone udp later.
                iSocketType = (wTcpPort) ? SOCK_STREAM : SOCK_DGRAM;
                bClone      = (wTcpPort && wUdpPort); 
            }
        }
    }
    


    ////////////////////////////////////////
    // do node name lookup...

    // if we weren't given a node name,
    // return the wildcard or loopback address (depending on AI_PASSIVE).
    //
    // if we have a numeric host address string,
    // return the binary address.
    //
    if ((!pszNodeName) || (WspiapiParseV4Address(pszNodeName, &dwAddress)))
    {
        if (!pszNodeName)
        {
            dwAddress = htonl((iFlags & AI_PASSIVE)
                              ? INADDR_ANY
                              : INADDR_LOOPBACK);
        }
        
        // create an addrinfo structure...
        *pptResult =
            WspiapiNewAddrInfo(iSocketType, iProtocol, wPort, dwAddress);
        if (!(*pptResult))
            iError = EAI_MEMORY;
        
        if (!iError && pszNodeName)
        {
            // implementation specific behavior: set AI_NUMERICHOST
            // to indicate that we got a numeric host address string.
            (*pptResult)->ai_flags |= AI_NUMERICHOST;
            
            // return the numeric address string as the canonical name
            if (iFlags & AI_CANONNAME)
            {
                (*pptResult)->ai_canonname =
                    WspiapiStrdup(inet_ntoa(*((struct in_addr *) &dwAddress)));
                if (!(*pptResult)->ai_canonname)        
                    iError = EAI_MEMORY;
            }
        }
    }


    // if we do not have a numeric host address string and
    // AI_NUMERICHOST flag is set, return an error!
    else if (iFlags & AI_NUMERICHOST)
    {
        iError = EAI_NONAME;
    }
    

    // since we have a non-numeric node name,
    // we have to do a regular node name lookup.
    else
    {
        iError = WspiapiLookupNode(pszNodeName,
                                   iSocketType,
                                   iProtocol,
                                   wPort,
                                   (iFlags & AI_CANONNAME),
                                   pptResult);
    }

    if (!iError && bClone)
    {
        iError = WspiapiClone(wUdpPort, *pptResult);
    }

    if (iError)
    {
        WspiapiLegacyFreeAddrInfo(*pptResult);
        *pptResult  = NULL;        
    }

    return (iError);
}



__inline
int
WINAPI
WspiapiLegacyGetNameInfo(
    IN  const struct sockaddr           *ptSocketAddress,
    IN  socklen_t                       tSocketLength,
    OUT char                            *pszNodeName,
    IN  size_t                          tNodeLength,
    OUT char                            *pszServiceName,
    IN  size_t                          tServiceLength,
    IN  int                             iFlags)
/*++

Routine Description
    protocol-independent address-to-name translation.
    as specified in RFC 2553, Section 6.5.
    this is the hacked version that only supports IPv4.
    
Arguments
    ptSocketAddress     socket address to translate.
    tSocketLength       length of above socket address.
    pszNodeName         where to return the node name.
    tNodeLength         size of above buffer.
    pszServiceName      where to return the service name.
    tServiceLength      size of above buffer.
    iFlags              flags of type NI_*.
    
Return Value
    returns zero if successful, an EAI_* error code if not.

--*/    
{
    struct servent  *ptService;
    WORD            wPort;    
    char            szBuffer[]  = "65535";
    char            *pszService = szBuffer;

    struct hostent  *ptHost;
    struct in_addr  tAddress;
    char            *pszNode    = NULL;
    char            *pc         = NULL;
    

    // sanity check ptSocketAddress and tSocketLength.
    if ((!ptSocketAddress) || (tSocketLength < sizeof(struct sockaddr)))
        return EAI_FAIL;
    
    if (ptSocketAddress->sa_family != AF_INET)
        return EAI_FAMILY;

    if (tSocketLength < sizeof(struct sockaddr_in))
        return EAI_FAIL;
    
    if (!(pszNodeName && tNodeLength) &&
        !(pszServiceName && tServiceLength))
    {
        return EAI_NONAME;    
    }

    // the draft has the "bad flags" error code, so presumably we
    // should check something here.  insisting that there aren't
    // any unspecified flags set would break forward compatibility,
    // however.  so we just check for non-sensical combinations.
    if ((iFlags & NI_NUMERICHOST) && (iFlags & NI_NAMEREQD))
    {                                                                       
        return EAI_BADFLAGS;
    }
        
    // translate the port to a service name (if requested).
    if (pszServiceName && tServiceLength)
    {
        wPort = ((struct sockaddr_in *) ptSocketAddress)->sin_port;
        
        if (iFlags & NI_NUMERICSERV)
        {
            // return numeric form of the address.
            _WSPIAPI_SPRINTF_S_1(szBuffer, _WSPIAPI_COUNTOF(szBuffer), "%u", ntohs(wPort));
        }
        else
        {
            // return service name corresponding to port.
            ptService = getservbyport(wPort,
                                      (iFlags & NI_DGRAM) ? "udp" : NULL);
            if (ptService && ptService->s_name)
            {
                // lookup successful.
                pszService = ptService->s_name;
            }
            else
            {
                // DRAFT: return numeric form of the port!
                _WSPIAPI_SPRINTF_S_1(szBuffer, _WSPIAPI_COUNTOF(szBuffer), "%u", ntohs(wPort));
            }
        }
        
        
        if (tServiceLength > strlen(pszService))
            _WSPIAPI_STRCPY_S(pszServiceName, tServiceLength, pszService);
        else
            return EAI_FAIL;
    }

    
    // translate the address to a node name (if requested).
    if (pszNodeName && tNodeLength)
    {    
        // this is the IPv4-only version, so we have an IPv4 address.
        tAddress = ((struct sockaddr_in *) ptSocketAddress)->sin_addr;

        if (iFlags & NI_NUMERICHOST)
        {
            // return numeric form of the address.
            pszNode  = inet_ntoa(tAddress);
        }
        else
        {
            // return node name corresponding to address.
            ptHost = gethostbyaddr((char *) &tAddress,
                                   sizeof(struct in_addr),
                                   AF_INET);
            if (ptHost && ptHost->h_name)
            {
                // DNS lookup successful.
                // stop copying at a "." if NI_NOFQDN is specified.
                pszNode = ptHost->h_name;
                if ((iFlags & NI_NOFQDN) &&
                    ((pc = strchr(pszNode, '.')) != NULL))
                    *pc = '\0';
            }
            else
            {
                // DNS lookup failed.  return numeric form of the address.
                if (iFlags & NI_NAMEREQD)
                {
                    switch (WSAGetLastError())
                    {
                        case WSAHOST_NOT_FOUND: return EAI_NONAME;
                        case WSATRY_AGAIN:      return EAI_AGAIN;
                        case WSANO_RECOVERY:    return EAI_FAIL;
                        default:                return EAI_NONAME;
                    }
                }
                else
                    pszNode  = inet_ntoa(tAddress);
            }
        }

        if (tNodeLength > strlen(pszNode))
            _WSPIAPI_STRCPY_S(pszNodeName, tNodeLength, pszNode);
        else
            return EAI_FAIL;
    }

    return 0;
}



typedef struct 
{
    char const          *pszName;
    FARPROC             pfAddress;
} WSPIAPI_FUNCTION;

#define WSPIAPI_FUNCTION_ARRAY                                  \
{                                                               \
    "getaddrinfo",      (FARPROC) WspiapiLegacyGetAddrInfo,     \
    "getnameinfo",      (FARPROC) WspiapiLegacyGetNameInfo,     \
    "freeaddrinfo",     (FARPROC) WspiapiLegacyFreeAddrInfo,    \
}



__inline
FARPROC
WINAPI
WspiapiLoad(
    IN  WORD                            wFunction)
/*++

Routine Description
    try to locate the address family independent name resolution routines
    (i.e. getaddrinfo, getnameinfo, freeaddrinfo, gai_strerror).
    
Locks
    this function call is not synchronized.  hence the library containing
    the routines might be loaded multiple times.  another option is to
    synchronize through a spin lock using a static local variable and the
    InterlockedExchange operation.  

    
Arguments
    wFunction           ordinal # of the function to get the pointer to
                        0   getaddrinfo
                        1   getnameinfo
                        2   freeaddrinfo
    
Return Value
    address of the library/legacy routine

--*/
{
    HMODULE                 hLibrary        = NULL;

    // these static variables store state across calls, across threads.
    static BOOL             bInitialized    = FALSE;
    static WSPIAPI_FUNCTION rgtGlobal[]     = WSPIAPI_FUNCTION_ARRAY;
    static const int        iNumGlobal      = (sizeof(rgtGlobal) /
                                               sizeof(WSPIAPI_FUNCTION));
    
    // we overwrite rgtGlobal only if all routines exist in library.
    WSPIAPI_FUNCTION        rgtLocal[]      = WSPIAPI_FUNCTION_ARRAY;
    FARPROC                 fScratch        = NULL;
    int                     i               = 0;
    
    
    if (bInitialized)           // WspiapiLoad has already been called once
        return (rgtGlobal[wFunction].pfAddress);

    for (;;)                    // breakout loop
    {
        CHAR SystemDir[MAX_PATH + 1];
        CHAR Path[MAX_PATH + 8];

        if (GetSystemDirectoryA(SystemDir, MAX_PATH) == 0) 
        {
            break;
        }

        // in Whistler and beyond...
        // the routines are present in the WinSock 2 library (ws2_32.dll).
        // printf("Looking in ws2_32 for getaddrinfo...\n");
        _WSPIAPI_STRCPY_S(Path, _WSPIAPI_COUNTOF(Path), SystemDir);
        _WSPIAPI_STRCAT_S(Path, _WSPIAPI_COUNTOF(Path), "\\ws2_32");
        hLibrary = LoadLibraryA(Path);
        if (hLibrary != NULL)
        {
            fScratch = GetProcAddress(hLibrary, "getaddrinfo");
            if (fScratch == NULL)
            {
                FreeLibrary(hLibrary);
                hLibrary = NULL;
            }
        }
        if (hLibrary != NULL)
            break;
        

        // in the IPv6 Technology Preview...        
        // the routines are present in the IPv6 WinSock library (wship6.dll).
        // printf("Looking in wship6 for getaddrinfo...\n");
        _WSPIAPI_STRCPY_S(Path, _WSPIAPI_COUNTOF(Path), SystemDir);
        _WSPIAPI_STRCAT_S(Path, _WSPIAPI_COUNTOF(Path), "\\wship6");
        hLibrary = LoadLibraryA(Path);
        if (hLibrary != NULL)
        {
            fScratch = GetProcAddress(hLibrary, "getaddrinfo");
            if (fScratch == NULL)
            {
                FreeLibrary(hLibrary);
                hLibrary = NULL;
            }
        }

        break;
    }


    if (hLibrary != NULL)
    {
        // use routines from this library...
        // since getaddrinfo is here, we expect all routines to be here,
        // but will fall back to IPv4-only if any of them is missing.
        for (i = 0; i < iNumGlobal; i++)
        {
            rgtLocal[i].pfAddress
                = GetProcAddress(hLibrary, rgtLocal[i].pszName);
            if (rgtLocal[i].pfAddress == NULL)
            {
                FreeLibrary(hLibrary);
                hLibrary = NULL;
                break;
            }
        }

        if (hLibrary != NULL)
        {
            // printf("found!\n");
            for (i = 0; i < iNumGlobal; i++)
                rgtGlobal[i].pfAddress = rgtLocal[i].pfAddress;
        }
    }
    
    bInitialized = TRUE;
    return (rgtGlobal[wFunction].pfAddress);
}



__inline
int
WINAPI
WspiapiGetAddrInfo(
    IN const char                       *nodename,
    IN const char                       *servname,
    IN const struct addrinfo            *hints,
    OUT struct addrinfo                 **res)
{
    int                             iError;
    static WSPIAPI_PGETADDRINFO     pfGetAddrInfo   = NULL;
    
    if (!pfGetAddrInfo)
        pfGetAddrInfo   = (WSPIAPI_PGETADDRINFO) WspiapiLoad(0);

    iError = (*pfGetAddrInfo)(nodename, servname, hints, res);
    WSASetLastError(iError);
    return iError;
}



__inline
int
WINAPI
WspiapiGetNameInfo (
    IN  const struct sockaddr           *sa,
    IN  socklen_t                       salen,
    OUT char                            *host,
    IN  size_t                          hostlen,
    OUT char                            *serv,
    IN  size_t                          servlen,
    IN  int                             flags)
{
    int                             iError;
    static WSPIAPI_PGETNAMEINFO     pfGetNameInfo   = NULL;
    
    if (!pfGetNameInfo)
        pfGetNameInfo   = (WSPIAPI_PGETNAMEINFO) WspiapiLoad(1);

    iError = (*pfGetNameInfo)(sa, salen, host, hostlen, serv, servlen, flags);
    WSASetLastError(iError);
    return iError;
}



__inline
void
WINAPI
WspiapiFreeAddrInfo (
    IN  struct addrinfo                 *ai)
{
    static WSPIAPI_PFREEADDRINFO    pfFreeAddrInfo   = NULL;

    if (!pfFreeAddrInfo)
        pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);
    (*pfFreeAddrInfo)(ai);
}

#ifdef  __cplusplus
}
#endif

#endif // if (NTDDI_VERSION >= WIN2K)
#endif // _WSPIAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Xinput.h ===
/***************************************************************************
*                                                                          *
*   XInput.h -- This module defines XBOX controller APIs                   *
*               and constansts for the Windows platform.                   *
*                                                                          *
*   Copyright (c) Microsoft Corp. All rights reserved.                     *
*                                                                          *
***************************************************************************/
#ifndef _XINPUT_H_
#define _XINPUT_H_

#include <windef.h>

// Current name of the DLL shipped in the same SDK as this header.
// The name reflects the current version
#define XINPUT_DLL_A  "xinput9_1_0.dll"
#define XINPUT_DLL_W L"xinput9_1_0.dll"
#ifdef UNICODE
    #define XINPUT_DLL XINPUT_DLL_W
#else
    #define XINPUT_DLL XINPUT_DLL_A
#endif 

//
// Device types available in XINPUT_CAPABILITIES
//
#define XINPUT_DEVTYPE_GAMEPAD          0x01

//
// Device subtypes available in XINPUT_CAPABILITIES
//
#define XINPUT_DEVSUBTYPE_GAMEPAD       0x01

//
// Flags for XINPUT_CAPABILITIES
//
#define XINPUT_CAPS_VOICE_SUPPORTED     0x0004

//
// Constants for gamepad buttons
//
#define XINPUT_GAMEPAD_DPAD_UP          0x0001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x0002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x0004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x0008
#define XINPUT_GAMEPAD_START            0x0010
#define XINPUT_GAMEPAD_BACK             0x0020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x0040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x0080
#define XINPUT_GAMEPAD_LEFT_SHOULDER    0x0100
#define XINPUT_GAMEPAD_RIGHT_SHOULDER   0x0200
#define XINPUT_GAMEPAD_A                0x1000
#define XINPUT_GAMEPAD_B                0x2000
#define XINPUT_GAMEPAD_X                0x4000
#define XINPUT_GAMEPAD_Y                0x8000

//
// Gamepad thresholds
//
#define XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE  7849
#define XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE 8689
#define XINPUT_GAMEPAD_TRIGGER_THRESHOLD    30

//
// Flags to pass to XInputGetCapabilities
//
#define XINPUT_FLAG_GAMEPAD             0x00000001


//
// Structures used by XInput APIs
//
typedef struct _XINPUT_GAMEPAD
{
    WORD                                wButtons;
    BYTE                                bLeftTrigger;
    BYTE                                bRightTrigger;
    SHORT                               sThumbLX;
    SHORT                               sThumbLY;
    SHORT                               sThumbRX;
    SHORT                               sThumbRY;
} XINPUT_GAMEPAD, *PXINPUT_GAMEPAD;

typedef struct _XINPUT_STATE
{
    DWORD                               dwPacketNumber;
    XINPUT_GAMEPAD                      Gamepad;
} XINPUT_STATE, *PXINPUT_STATE;

typedef struct _XINPUT_VIBRATION
{
    WORD                                wLeftMotorSpeed;
    WORD                                wRightMotorSpeed;
} XINPUT_VIBRATION, *PXINPUT_VIBRATION;

typedef struct _XINPUT_CAPABILITIES
{
    BYTE                                Type;
    BYTE                                SubType;
    WORD                                Flags;
    XINPUT_GAMEPAD                      Gamepad;
    XINPUT_VIBRATION                    Vibration;
} XINPUT_CAPABILITIES, *PXINPUT_CAPABILITIES;


//
// XInput APIs
//
#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI XInputGetState
(
    DWORD         dwUserIndex,  // [in] Index of the gamer associated with the device
    XINPUT_STATE* pState        // [out] Receives the current state
);

DWORD WINAPI XInputSetState
(
    DWORD             dwUserIndex,  // [in] Index of the gamer associated with the device
    XINPUT_VIBRATION* pVibration    // [in, out] The vibration information to send to the controller
);

DWORD WINAPI XInputGetCapabilities
(
    DWORD                dwUserIndex,   // [in] Index of the gamer associated with the device
    DWORD                dwFlags,       // [in] Input flags that identify the device type
    XINPUT_CAPABILITIES* pCapabilities  // [out] Receives the capabilities
);

DWORD WINAPI XInputGetDSoundAudioDeviceGuids
(
    DWORD dwUserIndex,          // [in] Index of the gamer associated with the device
    GUID* pDSoundRenderGuid,    // [out] DSound device ID for render
    GUID* pDSoundCaptureGuid    // [out] DSound device ID for capture
);

#ifdef __cplusplus
}
#endif

#endif  //_XINPUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\WTypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __wtypes_h__
#define __wtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "basetsd.h"
#include "guiddef.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wtypes_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif


extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec;

#ifndef __IWinTypes_INTERFACE_DEFINED__
#define __IWinTypes_INTERFACE_DEFINED__

/* interface IWinTypes */
/* [unique][version][uuid] */ 

typedef struct tagRemHGLOBAL
    {
    long fNullHGlobal;
    unsigned long cbData;
    byte data[ 1 ];
    } 	RemHGLOBAL;

typedef struct tagRemHMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    unsigned long cbData;
    byte data[ 1 ];
    } 	RemHMETAFILEPICT;

typedef struct tagRemHENHMETAFILE
    {
    unsigned long cbData;
    byte data[ 1 ];
    } 	RemHENHMETAFILE;

typedef struct tagRemHBITMAP
    {
    unsigned long cbData;
    byte data[ 1 ];
    } 	RemHBITMAP;

typedef struct tagRemHPALETTE
    {
    unsigned long cbData;
    byte data[ 1 ];
    } 	RemHPALETTE;

typedef struct tagRemBRUSH
    {
    unsigned long cbData;
    byte data[ 1 ];
    } 	RemHBRUSH;

#if !defined(_WIN32) && !defined(_MPPC_)
// The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef byte BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
typedef unsigned int UINT;

typedef int INT;

typedef long BOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
typedef UINT_PTR WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
typedef LONG_PTR LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
typedef LONG_PTR LRESULT;

#endif // !_LRESULT_DEFINED
typedef void *HANDLE;

typedef void *HMODULE;

typedef void *HINSTANCE;

typedef void *HTASK;

typedef void *HKEY;

typedef void *HDESK;

typedef void *HMF;

typedef void *HEMF;

typedef void *HPEN;

typedef void *HRSRC;

typedef void *HSTR;

typedef void *HWINSTA;

typedef void *HKL;

typedef void *HGDIOBJ;

typedef HANDLE HDWP;

#ifndef _HFILE_DEFINED
#define _HFILE_DEFINED
typedef INT HFILE;

#endif // !_HFILE_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
typedef WORD *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
typedef DWORD *LPDWORD;

#endif // !_LPDWORD_DEFINED
typedef char CHAR;

typedef /* [string] */  __RPC_string CHAR *LPSTR;

typedef /* [string] */  __RPC_string const CHAR *LPCSTR;

#ifndef _WCHAR_DEFINED
#define _WCHAR_DEFINED
typedef wchar_t WCHAR;

typedef WCHAR TCHAR;

#endif // !_WCHAR_DEFINED
typedef /* [string] */  __RPC_string WCHAR *LPWSTR;

typedef /* [string] */  __RPC_string TCHAR *LPTSTR;

typedef /* [string] */  __RPC_string const WCHAR *LPCWSTR;

typedef /* [string] */  __RPC_string const TCHAR *LPCTSTR;

#ifndef _COLORREF_DEFINED
#define _COLORREF_DEFINED
typedef DWORD COLORREF;

#endif // !_COLORREF_DEFINED
#ifndef _LPCOLORREF_DEFINED
#define _LPCOLORREF_DEFINED
typedef DWORD *LPCOLORREF;

#endif // !_LPCOLORREF_DEFINED
typedef HANDLE *LPHANDLE;

typedef struct _RECTL
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    } 	RECTL;

typedef struct _RECTL *PRECTL;

typedef struct _RECTL *LPRECTL;

typedef struct tagPOINT
    {
    LONG x;
    LONG y;
    } 	POINT;

typedef struct tagPOINT *PPOINT;

typedef struct tagPOINT *LPPOINT;

typedef struct _POINTL
    {
    LONG x;
    LONG y;
    } 	POINTL;

typedef struct _POINTL *PPOINTL;

#ifndef WIN16
typedef struct tagSIZE
    {
    LONG cx;
    LONG cy;
    } 	SIZE;

typedef struct tagSIZE *PSIZE;

typedef struct tagSIZE *LPSIZE;

#else // WIN16
typedef struct tagSIZE
{
    INT cx;
    INT cy;
} SIZE, *PSIZE, *LPSIZE;
#endif // WIN16
typedef struct tagSIZEL
    {
    LONG cx;
    LONG cy;
    } 	SIZEL;

typedef struct tagSIZEL *PSIZEL;

typedef struct tagSIZEL *LPSIZEL;

#endif  //WINAPI
#endif  //!WIN32 && !MPPC
#ifndef _PALETTEENTRY_DEFINED
#define _PALETTEENTRY_DEFINED
typedef struct tagPALETTEENTRY
    {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
    } 	PALETTEENTRY;

typedef struct tagPALETTEENTRY *PPALETTEENTRY;

typedef struct tagPALETTEENTRY *LPPALETTEENTRY;

#endif // !_PALETTEENTRY_DEFINED
#ifndef _LOGPALETTE_DEFINED
#define _LOGPALETTE_DEFINED
typedef struct tagLOGPALETTE
    {
    WORD palVersion;
    WORD palNumEntries;
    PALETTEENTRY palPalEntry[ 1 ];
    } 	LOGPALETTE;

typedef struct tagLOGPALETTE *PLOGPALETTE;

typedef struct tagLOGPALETTE *LPLOGPALETTE;

#endif // !_LOGPALETTE_DEFINED
#if defined(_WIN32) && !defined(OLE2ANSI)
typedef WCHAR OLECHAR;

typedef /* [string] */  __RPC_string OLECHAR *LPOLESTR;

typedef /* [string] */  __RPC_string const OLECHAR *LPCOLESTR;

#define OLESTR(str) L##str

#else

typedef char      OLECHAR;
typedef LPSTR     LPOLESTR;
typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str
#endif
#ifndef _WINDEF_
typedef const RECTL *LPCRECTL;

typedef void *PVOID;

typedef void *LPVOID;

typedef float FLOAT;

typedef struct tagRECT
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    } 	RECT;

typedef struct tagRECT *PRECT;

typedef struct tagRECT *LPRECT;

typedef const RECT *LPCRECT;

#endif  //_WINDEF_
typedef unsigned char UCHAR;

typedef short SHORT;

typedef unsigned short USHORT;

typedef DWORD ULONG;

typedef double DOUBLE;

#ifndef _DWORDLONG_
typedef unsigned __int64 DWORDLONG;

typedef DWORDLONG *PDWORDLONG;

#endif // !_DWORDLONG_
#ifndef _ULONGLONG_
typedef __int64 LONGLONG;

typedef unsigned __int64 ULONGLONG;

typedef LONGLONG *PLONGLONG;

typedef ULONGLONG *PULONGLONG;

#endif // _ULONGLONG_
#if 0
typedef struct _LARGE_INTEGER
    {
    LONGLONG QuadPart;
    } 	LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

typedef struct _ULARGE_INTEGER
    {
    ULONGLONG QuadPart;
    } 	ULARGE_INTEGER;

#endif // 0
#ifndef _WINBASE_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME
    {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    } 	FILETIME;

typedef struct _FILETIME *PFILETIME;

typedef struct _FILETIME *LPFILETIME;

#endif // !_FILETIME
#ifndef _SYSTEMTIME_
#define _SYSTEMTIME_
typedef struct _SYSTEMTIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    } 	SYSTEMTIME;

typedef struct _SYSTEMTIME *PSYSTEMTIME;

typedef struct _SYSTEMTIME *LPSYSTEMTIME;

#endif // !_SYSTEMTIME
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
typedef struct _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    } 	SECURITY_ATTRIBUTES;

typedef struct _SECURITY_ATTRIBUTES *PSECURITY_ATTRIBUTES;

typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;

#endif // !_SECURITY_ATTRIBUTES_
#ifndef SECURITY_DESCRIPTOR_REVISION
typedef USHORT SECURITY_DESCRIPTOR_CONTROL;

typedef USHORT *PSECURITY_DESCRIPTOR_CONTROL;

typedef PVOID PSID;

typedef struct _ACL
    {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
    } 	ACL;

typedef ACL *PACL;

typedef struct _SECURITY_DESCRIPTOR
    {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
    } 	SECURITY_DESCRIPTOR;

typedef struct _SECURITY_DESCRIPTOR *PISECURITY_DESCRIPTOR;

#endif // !SECURITY_DESCRIPTOR_REVISION
#endif //_WINBASE_
typedef struct _COAUTHIDENTITY
    {
    USHORT *User;
    ULONG UserLength;
    USHORT *Domain;
    ULONG DomainLength;
    USHORT *Password;
    ULONG PasswordLength;
    ULONG Flags;
    } 	COAUTHIDENTITY;

typedef struct _COAUTHINFO
    {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    LPWSTR pwszServerPrincName;
    DWORD dwAuthnLevel;
    DWORD dwImpersonationLevel;
    COAUTHIDENTITY *pAuthIdentityData;
    DWORD dwCapabilities;
    } 	COAUTHINFO;

typedef LONG SCODE;

typedef SCODE *PSCODE;

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
#ifdef __midl
typedef LONG HRESULT;

#else // __midl
typedef __success(return >= 0) long HRESULT;
#endif // __midl
#endif // !_HRESULT_DEFINED

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
typedef struct _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    } 	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if 0
typedef GUID *REFGUID;

typedef IID *REFIID;

typedef CLSID *REFCLSID;

typedef FMTID *REFFMTID;

#endif // 0
typedef 
enum tagMEMCTX
    {	MEMCTX_TASK	= 1,
	MEMCTX_SHARED	= 2,
	MEMCTX_MACSYSTEM	= 3,
	MEMCTX_UNKNOWN	= -1,
	MEMCTX_SAME	= -2
    } 	MEMCTX;

#ifndef _ROTFLAGS_DEFINED
#define _ROTFLAGS_DEFINED
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 0x1
#define ROTFLAGS_ALLOWANYCLIENT 0x2
#endif // !_ROTFLAGS_DEFINED
#ifndef _ROTREGFLAGS_DEFINED
#define _ROTREGFLAGS_DEFINED
#define ROTREGFLAGS_ALLOWANYCLIENT 0x1
#endif // !_ROTREGFLAGS_DEFINED
#ifndef _APPIDREGFLAGS_DEFINED
#define _APPIDREGFLAGS_DEFINED
#define APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP 0x1
#endif // !_APPIDREGFLAGS_DEFINED
#ifndef _ROT_COMPARE_MAX_DEFINED
#define _ROT_COMPARE_MAX_DEFINED
#define ROT_COMPARE_MAX 2048
#endif // !_ROT_COMPARE_MAX_DEFINED
#ifndef _DCOMSCM_REMOTECALL_FLAGS_DEFINED
#define _DCOMSCM_REMOTECALL_FLAGS_DEFINED
#define DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES 0x1
#define DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL 0x2
#define DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES 0x4
#define DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL 0x8
#define DCOMSCM_PING_USE_MID_AUTHNSERVICE 0x10
#define DCOMSCM_PING_DISALLOW_UNSECURE_CALL 0x20
#endif // !_DCOMSCM_REMOTECALL_FLAGS_DEFINED
typedef 
enum tagCLSCTX
    {	CLSCTX_INPROC_SERVER	= 0x1,
	CLSCTX_INPROC_HANDLER	= 0x2,
	CLSCTX_LOCAL_SERVER	= 0x4,
	CLSCTX_INPROC_SERVER16	= 0x8,
	CLSCTX_REMOTE_SERVER	= 0x10,
	CLSCTX_INPROC_HANDLER16	= 0x20,
	CLSCTX_RESERVED1	= 0x40,
	CLSCTX_RESERVED2	= 0x80,
	CLSCTX_RESERVED3	= 0x100,
	CLSCTX_RESERVED4	= 0x200,
	CLSCTX_NO_CODE_DOWNLOAD	= 0x400,
	CLSCTX_RESERVED5	= 0x800,
	CLSCTX_NO_CUSTOM_MARSHAL	= 0x1000,
	CLSCTX_ENABLE_CODE_DOWNLOAD	= 0x2000,
	CLSCTX_NO_FAILURE_LOG	= 0x4000,
	CLSCTX_DISABLE_AAA	= 0x8000,
	CLSCTX_ENABLE_AAA	= 0x10000,
	CLSCTX_FROM_DEFAULT_CONTEXT	= 0x20000,
	CLSCTX_ACTIVATE_32_BIT_SERVER	= 0x40000,
	CLSCTX_ACTIVATE_64_BIT_SERVER	= 0x80000,
	CLSCTX_ENABLE_CLOAKING	= 0x100000,
	CLSCTX_PS_DLL	= ( int  )0x80000000
    } 	CLSCTX;

#define CLSCTX_VALID_MASK \
   (CLSCTX_INPROC_SERVER | \
    CLSCTX_INPROC_HANDLER | \
    CLSCTX_LOCAL_SERVER | \
    CLSCTX_INPROC_SERVER16 | \
    CLSCTX_REMOTE_SERVER | \
    CLSCTX_NO_CODE_DOWNLOAD | \
    CLSCTX_NO_CUSTOM_MARSHAL | \
    CLSCTX_ENABLE_CODE_DOWNLOAD | \
    CLSCTX_NO_FAILURE_LOG | \
    CLSCTX_DISABLE_AAA | \
    CLSCTX_ENABLE_AAA | \
    CLSCTX_FROM_DEFAULT_CONTEXT | \
    CLSCTX_ACTIVATE_32_BIT_SERVER | \
    CLSCTX_ACTIVATE_64_BIT_SERVER | \
    CLSCTX_ENABLE_CLOAKING | \
    CLSCTX_PS_DLL)
typedef 
enum tagMSHLFLAGS
    {	MSHLFLAGS_NORMAL	= 0,
	MSHLFLAGS_TABLESTRONG	= 1,
	MSHLFLAGS_TABLEWEAK	= 2,
	MSHLFLAGS_NOPING	= 4,
	MSHLFLAGS_RESERVED1	= 8,
	MSHLFLAGS_RESERVED2	= 16,
	MSHLFLAGS_RESERVED3	= 32,
	MSHLFLAGS_RESERVED4	= 64
    } 	MSHLFLAGS;

typedef 
enum tagMSHCTX
    {	MSHCTX_LOCAL	= 0,
	MSHCTX_NOSHAREDMEM	= 1,
	MSHCTX_DIFFERENTMACHINE	= 2,
	MSHCTX_INPROC	= 3,
	MSHCTX_CROSSCTX	= 4
    } 	MSHCTX;

typedef 
enum tagDVASPECT
    {	DVASPECT_CONTENT	= 1,
	DVASPECT_THUMBNAIL	= 2,
	DVASPECT_ICON	= 4,
	DVASPECT_DOCPRINT	= 8
    } 	DVASPECT;

typedef 
enum tagSTGC
    {	STGC_DEFAULT	= 0,
	STGC_OVERWRITE	= 1,
	STGC_ONLYIFCURRENT	= 2,
	STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE	= 4,
	STGC_CONSOLIDATE	= 8
    } 	STGC;

typedef 
enum tagSTGMOVE
    {	STGMOVE_MOVE	= 0,
	STGMOVE_COPY	= 1,
	STGMOVE_SHALLOWCOPY	= 2
    } 	STGMOVE;

typedef 
enum tagSTATFLAG
    {	STATFLAG_DEFAULT	= 0,
	STATFLAG_NONAME	= 1,
	STATFLAG_NOOPEN	= 2
    } 	STATFLAG;

typedef /* [context_handle] */ void *HCONTEXT;

#ifndef _LCID_DEFINED
#define _LCID_DEFINED
typedef DWORD LCID;

#endif // !_LCID_DEFINED
#ifndef _LANGID_DEFINED
#define _LANGID_DEFINED
typedef USHORT LANGID;

#endif // !_LANGID_DEFINED
typedef struct _BYTE_BLOB
    {
    unsigned long clSize;
    byte abData[ 1 ];
    } 	BYTE_BLOB;

typedef /* [unique] */  __RPC_unique_pointer BYTE_BLOB *UP_BYTE_BLOB;

typedef struct _WORD_BLOB
    {
    unsigned long clSize;
    unsigned short asData[ 1 ];
    } 	WORD_BLOB;

typedef /* [unique] */  __RPC_unique_pointer WORD_BLOB *UP_WORD_BLOB;

typedef struct _DWORD_BLOB
    {
    unsigned long clSize;
    unsigned long alData[ 1 ];
    } 	DWORD_BLOB;

typedef /* [unique] */  __RPC_unique_pointer DWORD_BLOB *UP_DWORD_BLOB;

typedef struct _FLAGGED_BYTE_BLOB
    {
    unsigned long fFlags;
    unsigned long clSize;
    byte abData[ 1 ];
    } 	FLAGGED_BYTE_BLOB;

typedef /* [unique] */  __RPC_unique_pointer FLAGGED_BYTE_BLOB *UP_FLAGGED_BYTE_BLOB;

typedef struct _FLAGGED_WORD_BLOB
    {
    unsigned long fFlags;
    unsigned long clSize;
    unsigned short asData[ 1 ];
    } 	FLAGGED_WORD_BLOB;

typedef /* [unique] */  __RPC_unique_pointer FLAGGED_WORD_BLOB *UP_FLAGGED_WORD_BLOB;

typedef struct _BYTE_SIZEDARR
    {
    unsigned long clSize;
    byte *pData;
    } 	BYTE_SIZEDARR;

typedef struct _SHORT_SIZEDARR
    {
    unsigned long clSize;
    unsigned short *pData;
    } 	WORD_SIZEDARR;

typedef struct _LONG_SIZEDARR
    {
    unsigned long clSize;
    unsigned long *pData;
    } 	DWORD_SIZEDARR;

typedef struct _HYPER_SIZEDARR
    {
    unsigned long clSize;
    hyper *pData;
    } 	HYPER_SIZEDARR;

#define	WDT_INPROC_CALL	( 0x48746457 )

#define	WDT_REMOTE_CALL	( 0x52746457 )

#define	WDT_INPROC64_CALL	( 0x50746457 )

typedef struct _userCLIPFORMAT
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0001
        {
        DWORD dwValue;
        wchar_t *pwszName;
        } 	u;
    } 	userCLIPFORMAT;

typedef /* [unique] */  __RPC_unique_pointer userCLIPFORMAT *wireCLIPFORMAT;

typedef /* [wire_marshal] */ WORD CLIPFORMAT;

typedef struct _GDI_NONREMOTE
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0002
        {
        long hInproc;
        DWORD_BLOB *hRemote;
        } 	u;
    } 	GDI_NONREMOTE;

typedef struct _userHGLOBAL
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0003
        {
        long hInproc;
        FLAGGED_BYTE_BLOB *hRemote;
        __int64 hInproc64;
        } 	u;
    } 	userHGLOBAL;

typedef /* [unique] */  __RPC_unique_pointer userHGLOBAL *wireHGLOBAL;

typedef struct _userHMETAFILE
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0004
        {
        long hInproc;
        BYTE_BLOB *hRemote;
        __int64 hInproc64;
        } 	u;
    } 	userHMETAFILE;

typedef struct _remoteMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    userHMETAFILE *hMF;
    } 	remoteMETAFILEPICT;

typedef struct _userHMETAFILEPICT
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0005
        {
        long hInproc;
        remoteMETAFILEPICT *hRemote;
        __int64 hInproc64;
        } 	u;
    } 	userHMETAFILEPICT;

typedef struct _userHENHMETAFILE
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0006
        {
        long hInproc;
        BYTE_BLOB *hRemote;
        __int64 hInproc64;
        } 	u;
    } 	userHENHMETAFILE;

typedef struct _userBITMAP
    {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    ULONG cbSize;
    byte pBuffer[ 1 ];
    } 	userBITMAP;

typedef struct _userHBITMAP
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0007
        {
        long hInproc;
        userBITMAP *hRemote;
        __int64 hInproc64;
        } 	u;
    } 	userHBITMAP;

typedef struct _userHPALETTE
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0008
        {
        long hInproc;
        LOGPALETTE *hRemote;
        __int64 hInproc64;
        } 	u;
    } 	userHPALETTE;

typedef struct _RemotableHandle
    {
    long fContext;
    /* [switch_type] */ union __MIDL_IWinTypes_0009
        {
        long hInproc;
        long hRemote;
        } 	u;
    } 	RemotableHandle;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHWND;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHMENU;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHACCEL;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHBRUSH;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHFONT;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHDC;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHICON;

typedef /* [unique] */  __RPC_unique_pointer RemotableHandle *wireHRGN;

#if 0
typedef /* [wire_marshal] */ void *HWND;

typedef /* [wire_marshal] */ void *HMENU;

typedef /* [wire_marshal] */ void *HACCEL;

typedef /* [wire_marshal] */ void *HBRUSH;

typedef /* [wire_marshal] */ void *HFONT;

typedef /* [wire_marshal] */ void *HDC;

typedef /* [wire_marshal] */ void *HICON;

typedef /* [wire_marshal] */ void *HRGN;

#ifndef _HCURSOR_DEFINED
#define _HCURSOR_DEFINED
typedef HICON HCURSOR;

#endif // !_HCURSOR_DEFINED
#endif //0
#ifndef _TEXTMETRIC_DEFINED
#define _TEXTMETRIC_DEFINED
typedef struct tagTEXTMETRICW
    {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    } 	TEXTMETRICW;

typedef struct tagTEXTMETRICW *PTEXTMETRICW;

typedef struct tagTEXTMETRICW *LPTEXTMETRICW;

#endif // !_TEXTMETRIC_DEFINED
#ifndef _WIN32           // The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
typedef struct tagMSG
    {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
    } 	MSG;

typedef struct tagMSG *PMSG;

typedef struct tagMSG *NPMSG;

typedef struct tagMSG *LPMSG;

#endif // _WIN32
#endif // WINAPI
typedef /* [unique] */  __RPC_unique_pointer userHBITMAP *wireHBITMAP;

typedef /* [unique] */  __RPC_unique_pointer userHPALETTE *wireHPALETTE;

typedef /* [unique] */  __RPC_unique_pointer userHENHMETAFILE *wireHENHMETAFILE;

typedef /* [unique] */  __RPC_unique_pointer userHMETAFILE *wireHMETAFILE;

typedef /* [unique] */  __RPC_unique_pointer userHMETAFILEPICT *wireHMETAFILEPICT;

#if 0
typedef /* [wire_marshal] */ void *HGLOBAL;

typedef HGLOBAL HLOCAL;

typedef /* [wire_marshal] */ void *HBITMAP;

typedef /* [wire_marshal] */ void *HPALETTE;

typedef /* [wire_marshal] */ void *HENHMETAFILE;

typedef /* [wire_marshal] */ void *HMETAFILE;

#endif //0
typedef /* [wire_marshal] */ void *HMETAFILEPICT;



extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
#endif /* __IWinTypes_INTERFACE_DEFINED__ */

/* interface __MIDL_itf_wtypes_0000_0001 */
/* [local] */ 

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef double DATE;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if 0
/* the following isn't the real definition of CY, but it is */
/* what RPC knows how to remote */
typedef struct tagCY
    {
    LONGLONG int64;
    } 	CY;

#else /* 0 */
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    } DUMMYSTRUCTNAME;
    LONGLONG int64;
} CY;
#endif /* 0 */
#endif /* _tagCY_DEFINED */
typedef CY *LPCY;

#if 0 /* _tagDEC_DEFINED */
/* The following isn't the real definition of Decimal type, */
/* but it is what RPC knows how to remote */
typedef struct tagDEC
    {
    USHORT wReserved;
    BYTE scale;
    BYTE sign;
    ULONG Hi32;
    ULONGLONG Lo64;
    } 	DECIMAL;

#else /* _tagDEC_DEFINED */
/* real definition that makes the C++ compiler happy */
typedef struct tagDEC {
    USHORT wReserved;
    union {
        struct {
            BYTE scale;
            BYTE sign;
        } DUMMYSTRUCTNAME;
        USHORT signscale;
    } DUMMYUNIONNAME;
    ULONG Hi32;
    union {
        struct {
#ifdef _MAC
            ULONG Mid32;
            ULONG Lo32;
#else
            ULONG Lo32;
            ULONG Mid32;
#endif
        } DUMMYSTRUCTNAME2;
        ULONGLONG Lo64;
    } DUMMYUNIONNAME2;
} DECIMAL;
#define DECIMAL_NEG ((BYTE)0x80)
#define DECIMAL_SETZERO(dec) \
        {(dec).Lo64 = 0; (dec).Hi32 = 0; (dec).signscale = 0;}
#endif /* _tagDEC_DEFINED */
typedef DECIMAL *LPDECIMAL;

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif
typedef /* [unique] */  __RPC_unique_pointer FLAGGED_WORD_BLOB *wireBSTR;

typedef /* [wire_marshal] */ OLECHAR *BSTR;

typedef BSTR *LPBSTR;

/* 0 == FALSE, -1 == TRUE */
typedef short VARIANT_BOOL;

#if !__STDC__ && (_MSC_VER <= 1000)
/* For backward compatibility */
typedef VARIANT_BOOL _VARIANT_BOOL;

#else
/* ANSI C/C++ reserve bool as keyword */
#define _VARIANT_BOOL    /##/
#endif
typedef boolean BOOLEAN;

/* The BSTRBLOB structure is used by some implementations */
/* of the IPropertyStorage interface when marshaling BSTRs */
/* on systems which don't support BSTR marshaling. */
#ifndef _tagBSTRBLOB_DEFINED
#define _tagBSTRBLOB_DEFINED
typedef struct tagBSTRBLOB
    {
    ULONG cbSize;
    BYTE *pData;
    } 	BSTRBLOB;

typedef struct tagBSTRBLOB *LPBSTRBLOB;

#endif
#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct tagBLOB
    {
    ULONG cbSize;
    BYTE *pBlobData;
    } 	BLOB;

typedef struct tagBLOB *LPBLOB;

#endif
typedef struct tagCLIPDATA
    {
    ULONG cbSize;
    long ulClipFmt;
    BYTE *pClipData;
    } 	CLIPDATA;

// Macro to calculate the size of the above pClipData
#define CBPCLIPDATA(clipdata)    ( (clipdata).cbSize - sizeof((clipdata).ulClipFmt) )
typedef unsigned short VARTYPE;

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing
 *  VT_NULL             [V]   [P]     SQL style Null
 *  VT_I2               [V][T][P][S]  2 byte signed int
 *  VT_I4               [V][T][P][S]  4 byte signed int
 *  VT_R4               [V][T][P][S]  4 byte real
 *  VT_R8               [V][T][P][S]  8 byte real
 *  VT_CY               [V][T][P][S]  currency
 *  VT_DATE             [V][T][P][S]  date
 *  VT_BSTR             [V][T][P][S]  OLE Automation string
 *  VT_DISPATCH         [V][T]   [S]  IDispatch *
 *  VT_ERROR            [V][T][P][S]  SCODE
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]  VARIANT *
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
 *  VT_RECORD           [V]   [P][S]  user defined type
 *  VT_I1               [V][T][P][s]  signed char
 *  VT_UI1              [V][T][P][S]  unsigned char
 *  VT_UI2              [V][T][P][S]  unsigned short
 *  VT_UI4              [V][T][P][S]  unsigned long
 *  VT_I8                  [T][P]     signed 64-bit int
 *  VT_UI8                 [T][P]     unsigned 64-bit int
 *  VT_INT              [V][T][P][S]  signed machine int
 *  VT_UINT             [V][T]   [S]  unsigned machine int
 *  VT_INT_PTR             [T]        signed machine register size width
 *  VT_UINT_PTR            [T]        unsigned machine register size width
 *  VT_VOID                [T]        C style void
 *  VT_HRESULT             [T]        Standard return type
 *  VT_PTR                 [T]        pointer type
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]        C style array
 *  VT_USERDEFINED         [T]        user defined type
 *  VT_LPSTR               [T][P]     null terminated string
 *  VT_LPWSTR              [T][P]     wide null terminated string
 *  VT_FILETIME               [P]     FILETIME
 *  VT_BLOB                   [P]     Length prefixed bytes
 *  VT_STREAM                 [P]     Name of the stream follows
 *  VT_STORAGE                [P]     Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
 *  VT_STORED_OBJECT          [P]     Storage contains an object
 *  VT_VERSIONED_STREAM       [P]     Stream with a GUID version
 *  VT_BLOB_OBJECT            [P]     Blob contains an object 
 *  VT_CF                     [P]     Clipboard format
 *  VT_CLSID                  [P]     A Class ID
 *  VT_VECTOR                 [P]     simple counted array
 *  VT_ARRAY            [V]           SAFEARRAY*
 *  VT_BYREF            [V]           void* for local use
 *  VT_BSTR_BLOB                      Reserved for system use
 */

enum VARENUM
    {	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_DECIMAL	= 14,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_RECORD	= 36,
	VT_INT_PTR	= 37,
	VT_UINT_PTR	= 38,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72,
	VT_VERSIONED_STREAM	= 73,
	VT_BSTR_BLOB	= 0xfff,
	VT_VECTOR	= 0x1000,
	VT_ARRAY	= 0x2000,
	VT_BYREF	= 0x4000,
	VT_RESERVED	= 0x8000,
	VT_ILLEGAL	= 0xffff,
	VT_ILLEGALMASKED	= 0xfff,
	VT_TYPEMASK	= 0xfff
    } ;
typedef ULONG PROPID;

#ifndef PROPERTYKEY_DEFINED
#define PROPERTYKEY_DEFINED
typedef struct _tagpropertykey
    {
    GUID fmtid;
    DWORD pid;
    } 	PROPERTYKEY;

#endif
#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
typedef struct _SID_IDENTIFIER_AUTHORITY
    {
    UCHAR Value[ 6 ];
    } 	SID_IDENTIFIER_AUTHORITY;

typedef struct _SID_IDENTIFIER_AUTHORITY *PSID_IDENTIFIER_AUTHORITY;

#endif
#ifndef SID_DEFINED
#define SID_DEFINED
typedef struct _SID
    {
    BYTE Revision;
    BYTE SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG SubAuthority[ 1 ];
    } 	SID;

typedef struct _SID *PISID;

typedef struct _SID_AND_ATTRIBUTES
    {
    SID *Sid;
    DWORD Attributes;
    } 	SID_AND_ATTRIBUTES;

typedef struct _SID_AND_ATTRIBUTES *PSID_AND_ATTRIBUTES;

#endif
typedef struct tagCSPLATFORM
    {
    DWORD dwPlatformId;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwProcessorArch;
    } 	CSPLATFORM;

typedef struct tagQUERYCONTEXT
    {
    DWORD dwContext;
    CSPLATFORM Platform;
    LCID Locale;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    } 	QUERYCONTEXT;

typedef /* [v1_enum] */ 
enum tagTYSPEC
    {	TYSPEC_CLSID	= 0,
	TYSPEC_FILEEXT	= ( TYSPEC_CLSID + 1 ) ,
	TYSPEC_MIMETYPE	= ( TYSPEC_FILEEXT + 1 ) ,
	TYSPEC_FILENAME	= ( TYSPEC_MIMETYPE + 1 ) ,
	TYSPEC_PROGID	= ( TYSPEC_FILENAME + 1 ) ,
	TYSPEC_PACKAGENAME	= ( TYSPEC_PROGID + 1 ) ,
	TYSPEC_OBJECTID	= ( TYSPEC_PACKAGENAME + 1 ) 
    } 	TYSPEC;

typedef /* [public] */ struct __MIDL___MIDL_itf_wtypes_0000_0001_0001
    {
    DWORD tyspec;
    /* [switch_type] */ union __MIDL___MIDL_itf_wtypes_0000_0001_0005
        {
        CLSID clsid;
        LPOLESTR pFileExt;
        LPOLESTR pMimeType;
        LPOLESTR pProgId;
        LPOLESTR pFileName;
        struct 
            {
            LPOLESTR pPackageName;
            GUID PolicyId;
            } 	ByName;
        struct 
            {
            GUID ObjectId;
            GUID PolicyId;
            } 	ByObjectId;
        } 	tagged_union;
    } 	uCLSSPEC;



extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\wuapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wuapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wuapi_h__
#define __wuapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUpdateLockdown_FWD_DEFINED__
#define __IUpdateLockdown_FWD_DEFINED__
typedef interface IUpdateLockdown IUpdateLockdown;
#endif 	/* __IUpdateLockdown_FWD_DEFINED__ */


#ifndef __IStringCollection_FWD_DEFINED__
#define __IStringCollection_FWD_DEFINED__
typedef interface IStringCollection IStringCollection;
#endif 	/* __IStringCollection_FWD_DEFINED__ */


#ifndef __IWebProxy_FWD_DEFINED__
#define __IWebProxy_FWD_DEFINED__
typedef interface IWebProxy IWebProxy;
#endif 	/* __IWebProxy_FWD_DEFINED__ */


#ifndef __ISystemInformation_FWD_DEFINED__
#define __ISystemInformation_FWD_DEFINED__
typedef interface ISystemInformation ISystemInformation;
#endif 	/* __ISystemInformation_FWD_DEFINED__ */


#ifndef __IWindowsUpdateAgentInfo_FWD_DEFINED__
#define __IWindowsUpdateAgentInfo_FWD_DEFINED__
typedef interface IWindowsUpdateAgentInfo IWindowsUpdateAgentInfo;
#endif 	/* __IWindowsUpdateAgentInfo_FWD_DEFINED__ */


#ifndef __IAutomaticUpdatesResults_FWD_DEFINED__
#define __IAutomaticUpdatesResults_FWD_DEFINED__
typedef interface IAutomaticUpdatesResults IAutomaticUpdatesResults;
#endif 	/* __IAutomaticUpdatesResults_FWD_DEFINED__ */


#ifndef __IAutomaticUpdatesSettings_FWD_DEFINED__
#define __IAutomaticUpdatesSettings_FWD_DEFINED__
typedef interface IAutomaticUpdatesSettings IAutomaticUpdatesSettings;
#endif 	/* __IAutomaticUpdatesSettings_FWD_DEFINED__ */


#ifndef __IAutomaticUpdatesSettings2_FWD_DEFINED__
#define __IAutomaticUpdatesSettings2_FWD_DEFINED__
typedef interface IAutomaticUpdatesSettings2 IAutomaticUpdatesSettings2;
#endif 	/* __IAutomaticUpdatesSettings2_FWD_DEFINED__ */


#ifndef __IAutomaticUpdates_FWD_DEFINED__
#define __IAutomaticUpdates_FWD_DEFINED__
typedef interface IAutomaticUpdates IAutomaticUpdates;
#endif 	/* __IAutomaticUpdates_FWD_DEFINED__ */


#ifndef __IAutomaticUpdates2_FWD_DEFINED__
#define __IAutomaticUpdates2_FWD_DEFINED__
typedef interface IAutomaticUpdates2 IAutomaticUpdates2;
#endif 	/* __IAutomaticUpdates2_FWD_DEFINED__ */


#ifndef __IUpdateIdentity_FWD_DEFINED__
#define __IUpdateIdentity_FWD_DEFINED__
typedef interface IUpdateIdentity IUpdateIdentity;
#endif 	/* __IUpdateIdentity_FWD_DEFINED__ */


#ifndef __IImageInformation_FWD_DEFINED__
#define __IImageInformation_FWD_DEFINED__
typedef interface IImageInformation IImageInformation;
#endif 	/* __IImageInformation_FWD_DEFINED__ */


#ifndef __ICategory_FWD_DEFINED__
#define __ICategory_FWD_DEFINED__
typedef interface ICategory ICategory;
#endif 	/* __ICategory_FWD_DEFINED__ */


#ifndef __ICategoryCollection_FWD_DEFINED__
#define __ICategoryCollection_FWD_DEFINED__
typedef interface ICategoryCollection ICategoryCollection;
#endif 	/* __ICategoryCollection_FWD_DEFINED__ */


#ifndef __IInstallationBehavior_FWD_DEFINED__
#define __IInstallationBehavior_FWD_DEFINED__
typedef interface IInstallationBehavior IInstallationBehavior;
#endif 	/* __IInstallationBehavior_FWD_DEFINED__ */


#ifndef __IUpdateDownloadContent_FWD_DEFINED__
#define __IUpdateDownloadContent_FWD_DEFINED__
typedef interface IUpdateDownloadContent IUpdateDownloadContent;
#endif 	/* __IUpdateDownloadContent_FWD_DEFINED__ */


#ifndef __IUpdateDownloadContent2_FWD_DEFINED__
#define __IUpdateDownloadContent2_FWD_DEFINED__
typedef interface IUpdateDownloadContent2 IUpdateDownloadContent2;
#endif 	/* __IUpdateDownloadContent2_FWD_DEFINED__ */


#ifndef __IUpdateDownloadContentCollection_FWD_DEFINED__
#define __IUpdateDownloadContentCollection_FWD_DEFINED__
typedef interface IUpdateDownloadContentCollection IUpdateDownloadContentCollection;
#endif 	/* __IUpdateDownloadContentCollection_FWD_DEFINED__ */


#ifndef __IUpdate_FWD_DEFINED__
#define __IUpdate_FWD_DEFINED__
typedef interface IUpdate IUpdate;
#endif 	/* __IUpdate_FWD_DEFINED__ */


#ifndef __IWindowsDriverUpdate_FWD_DEFINED__
#define __IWindowsDriverUpdate_FWD_DEFINED__
typedef interface IWindowsDriverUpdate IWindowsDriverUpdate;
#endif 	/* __IWindowsDriverUpdate_FWD_DEFINED__ */


#ifndef __IUpdate2_FWD_DEFINED__
#define __IUpdate2_FWD_DEFINED__
typedef interface IUpdate2 IUpdate2;
#endif 	/* __IUpdate2_FWD_DEFINED__ */


#ifndef __IUpdate3_FWD_DEFINED__
#define __IUpdate3_FWD_DEFINED__
typedef interface IUpdate3 IUpdate3;
#endif 	/* __IUpdate3_FWD_DEFINED__ */


#ifndef __IWindowsDriverUpdate2_FWD_DEFINED__
#define __IWindowsDriverUpdate2_FWD_DEFINED__
typedef interface IWindowsDriverUpdate2 IWindowsDriverUpdate2;
#endif 	/* __IWindowsDriverUpdate2_FWD_DEFINED__ */


#ifndef __IWindowsDriverUpdate3_FWD_DEFINED__
#define __IWindowsDriverUpdate3_FWD_DEFINED__
typedef interface IWindowsDriverUpdate3 IWindowsDriverUpdate3;
#endif 	/* __IWindowsDriverUpdate3_FWD_DEFINED__ */


#ifndef __IUpdateCollection_FWD_DEFINED__
#define __IUpdateCollection_FWD_DEFINED__
typedef interface IUpdateCollection IUpdateCollection;
#endif 	/* __IUpdateCollection_FWD_DEFINED__ */


#ifndef __IUpdateException_FWD_DEFINED__
#define __IUpdateException_FWD_DEFINED__
typedef interface IUpdateException IUpdateException;
#endif 	/* __IUpdateException_FWD_DEFINED__ */


#ifndef __IInvalidProductLicenseException_FWD_DEFINED__
#define __IInvalidProductLicenseException_FWD_DEFINED__
typedef interface IInvalidProductLicenseException IInvalidProductLicenseException;
#endif 	/* __IInvalidProductLicenseException_FWD_DEFINED__ */


#ifndef __IUpdateExceptionCollection_FWD_DEFINED__
#define __IUpdateExceptionCollection_FWD_DEFINED__
typedef interface IUpdateExceptionCollection IUpdateExceptionCollection;
#endif 	/* __IUpdateExceptionCollection_FWD_DEFINED__ */


#ifndef __ISearchResult_FWD_DEFINED__
#define __ISearchResult_FWD_DEFINED__
typedef interface ISearchResult ISearchResult;
#endif 	/* __ISearchResult_FWD_DEFINED__ */


#ifndef __ISearchJob_FWD_DEFINED__
#define __ISearchJob_FWD_DEFINED__
typedef interface ISearchJob ISearchJob;
#endif 	/* __ISearchJob_FWD_DEFINED__ */


#ifndef __ISearchCompletedCallbackArgs_FWD_DEFINED__
#define __ISearchCompletedCallbackArgs_FWD_DEFINED__
typedef interface ISearchCompletedCallbackArgs ISearchCompletedCallbackArgs;
#endif 	/* __ISearchCompletedCallbackArgs_FWD_DEFINED__ */


#ifndef __ISearchCompletedCallback_FWD_DEFINED__
#define __ISearchCompletedCallback_FWD_DEFINED__
typedef interface ISearchCompletedCallback ISearchCompletedCallback;
#endif 	/* __ISearchCompletedCallback_FWD_DEFINED__ */


#ifndef __IUpdateHistoryEntry_FWD_DEFINED__
#define __IUpdateHistoryEntry_FWD_DEFINED__
typedef interface IUpdateHistoryEntry IUpdateHistoryEntry;
#endif 	/* __IUpdateHistoryEntry_FWD_DEFINED__ */


#ifndef __IUpdateHistoryEntry2_FWD_DEFINED__
#define __IUpdateHistoryEntry2_FWD_DEFINED__
typedef interface IUpdateHistoryEntry2 IUpdateHistoryEntry2;
#endif 	/* __IUpdateHistoryEntry2_FWD_DEFINED__ */


#ifndef __IUpdateHistoryEntryCollection_FWD_DEFINED__
#define __IUpdateHistoryEntryCollection_FWD_DEFINED__
typedef interface IUpdateHistoryEntryCollection IUpdateHistoryEntryCollection;
#endif 	/* __IUpdateHistoryEntryCollection_FWD_DEFINED__ */


#ifndef __IUpdateSearcher_FWD_DEFINED__
#define __IUpdateSearcher_FWD_DEFINED__
typedef interface IUpdateSearcher IUpdateSearcher;
#endif 	/* __IUpdateSearcher_FWD_DEFINED__ */


#ifndef __IUpdateSearcher2_FWD_DEFINED__
#define __IUpdateSearcher2_FWD_DEFINED__
typedef interface IUpdateSearcher2 IUpdateSearcher2;
#endif 	/* __IUpdateSearcher2_FWD_DEFINED__ */


#ifndef __IUpdateDownloadResult_FWD_DEFINED__
#define __IUpdateDownloadResult_FWD_DEFINED__
typedef interface IUpdateDownloadResult IUpdateDownloadResult;
#endif 	/* __IUpdateDownloadResult_FWD_DEFINED__ */


#ifndef __IDownloadResult_FWD_DEFINED__
#define __IDownloadResult_FWD_DEFINED__
typedef interface IDownloadResult IDownloadResult;
#endif 	/* __IDownloadResult_FWD_DEFINED__ */


#ifndef __IDownloadProgress_FWD_DEFINED__
#define __IDownloadProgress_FWD_DEFINED__
typedef interface IDownloadProgress IDownloadProgress;
#endif 	/* __IDownloadProgress_FWD_DEFINED__ */


#ifndef __IDownloadJob_FWD_DEFINED__
#define __IDownloadJob_FWD_DEFINED__
typedef interface IDownloadJob IDownloadJob;
#endif 	/* __IDownloadJob_FWD_DEFINED__ */


#ifndef __IDownloadCompletedCallbackArgs_FWD_DEFINED__
#define __IDownloadCompletedCallbackArgs_FWD_DEFINED__
typedef interface IDownloadCompletedCallbackArgs IDownloadCompletedCallbackArgs;
#endif 	/* __IDownloadCompletedCallbackArgs_FWD_DEFINED__ */


#ifndef __IDownloadCompletedCallback_FWD_DEFINED__
#define __IDownloadCompletedCallback_FWD_DEFINED__
typedef interface IDownloadCompletedCallback IDownloadCompletedCallback;
#endif 	/* __IDownloadCompletedCallback_FWD_DEFINED__ */


#ifndef __IDownloadProgressChangedCallbackArgs_FWD_DEFINED__
#define __IDownloadProgressChangedCallbackArgs_FWD_DEFINED__
typedef interface IDownloadProgressChangedCallbackArgs IDownloadProgressChangedCallbackArgs;
#endif 	/* __IDownloadProgressChangedCallbackArgs_FWD_DEFINED__ */


#ifndef __IDownloadProgressChangedCallback_FWD_DEFINED__
#define __IDownloadProgressChangedCallback_FWD_DEFINED__
typedef interface IDownloadProgressChangedCallback IDownloadProgressChangedCallback;
#endif 	/* __IDownloadProgressChangedCallback_FWD_DEFINED__ */


#ifndef __IUpdateDownloader_FWD_DEFINED__
#define __IUpdateDownloader_FWD_DEFINED__
typedef interface IUpdateDownloader IUpdateDownloader;
#endif 	/* __IUpdateDownloader_FWD_DEFINED__ */


#ifndef __IUpdateInstallationResult_FWD_DEFINED__
#define __IUpdateInstallationResult_FWD_DEFINED__
typedef interface IUpdateInstallationResult IUpdateInstallationResult;
#endif 	/* __IUpdateInstallationResult_FWD_DEFINED__ */


#ifndef __IInstallationResult_FWD_DEFINED__
#define __IInstallationResult_FWD_DEFINED__
typedef interface IInstallationResult IInstallationResult;
#endif 	/* __IInstallationResult_FWD_DEFINED__ */


#ifndef __IInstallationProgress_FWD_DEFINED__
#define __IInstallationProgress_FWD_DEFINED__
typedef interface IInstallationProgress IInstallationProgress;
#endif 	/* __IInstallationProgress_FWD_DEFINED__ */


#ifndef __IInstallationJob_FWD_DEFINED__
#define __IInstallationJob_FWD_DEFINED__
typedef interface IInstallationJob IInstallationJob;
#endif 	/* __IInstallationJob_FWD_DEFINED__ */


#ifndef __IInstallationCompletedCallbackArgs_FWD_DEFINED__
#define __IInstallationCompletedCallbackArgs_FWD_DEFINED__
typedef interface IInstallationCompletedCallbackArgs IInstallationCompletedCallbackArgs;
#endif 	/* __IInstallationCompletedCallbackArgs_FWD_DEFINED__ */


#ifndef __IInstallationCompletedCallback_FWD_DEFINED__
#define __IInstallationCompletedCallback_FWD_DEFINED__
typedef interface IInstallationCompletedCallback IInstallationCompletedCallback;
#endif 	/* __IInstallationCompletedCallback_FWD_DEFINED__ */


#ifndef __IInstallationProgressChangedCallbackArgs_FWD_DEFINED__
#define __IInstallationProgressChangedCallbackArgs_FWD_DEFINED__
typedef interface IInstallationProgressChangedCallbackArgs IInstallationProgressChangedCallbackArgs;
#endif 	/* __IInstallationProgressChangedCallbackArgs_FWD_DEFINED__ */


#ifndef __IInstallationProgressChangedCallback_FWD_DEFINED__
#define __IInstallationProgressChangedCallback_FWD_DEFINED__
typedef interface IInstallationProgressChangedCallback IInstallationProgressChangedCallback;
#endif 	/* __IInstallationProgressChangedCallback_FWD_DEFINED__ */


#ifndef __IUpdateInstaller_FWD_DEFINED__
#define __IUpdateInstaller_FWD_DEFINED__
typedef interface IUpdateInstaller IUpdateInstaller;
#endif 	/* __IUpdateInstaller_FWD_DEFINED__ */


#ifndef __IUpdateInstaller2_FWD_DEFINED__
#define __IUpdateInstaller2_FWD_DEFINED__
typedef interface IUpdateInstaller2 IUpdateInstaller2;
#endif 	/* __IUpdateInstaller2_FWD_DEFINED__ */


#ifndef __IUpdateSession_FWD_DEFINED__
#define __IUpdateSession_FWD_DEFINED__
typedef interface IUpdateSession IUpdateSession;
#endif 	/* __IUpdateSession_FWD_DEFINED__ */


#ifndef __IUpdateSession2_FWD_DEFINED__
#define __IUpdateSession2_FWD_DEFINED__
typedef interface IUpdateSession2 IUpdateSession2;
#endif 	/* __IUpdateSession2_FWD_DEFINED__ */


#ifndef __IUpdateSession3_FWD_DEFINED__
#define __IUpdateSession3_FWD_DEFINED__
typedef interface IUpdateSession3 IUpdateSession3;
#endif 	/* __IUpdateSession3_FWD_DEFINED__ */


#ifndef __IUpdateService_FWD_DEFINED__
#define __IUpdateService_FWD_DEFINED__
typedef interface IUpdateService IUpdateService;
#endif 	/* __IUpdateService_FWD_DEFINED__ */


#ifndef __IUpdateService2_FWD_DEFINED__
#define __IUpdateService2_FWD_DEFINED__
typedef interface IUpdateService2 IUpdateService2;
#endif 	/* __IUpdateService2_FWD_DEFINED__ */


#ifndef __IUpdateServiceCollection_FWD_DEFINED__
#define __IUpdateServiceCollection_FWD_DEFINED__
typedef interface IUpdateServiceCollection IUpdateServiceCollection;
#endif 	/* __IUpdateServiceCollection_FWD_DEFINED__ */


#ifndef __IUpdateServiceRegistration_FWD_DEFINED__
#define __IUpdateServiceRegistration_FWD_DEFINED__
typedef interface IUpdateServiceRegistration IUpdateServiceRegistration;
#endif 	/* __IUpdateServiceRegistration_FWD_DEFINED__ */


#ifndef __IUpdateServiceManager_FWD_DEFINED__
#define __IUpdateServiceManager_FWD_DEFINED__
typedef interface IUpdateServiceManager IUpdateServiceManager;
#endif 	/* __IUpdateServiceManager_FWD_DEFINED__ */


#ifndef __IUpdateServiceManager2_FWD_DEFINED__
#define __IUpdateServiceManager2_FWD_DEFINED__
typedef interface IUpdateServiceManager2 IUpdateServiceManager2;
#endif 	/* __IUpdateServiceManager2_FWD_DEFINED__ */


#ifndef __IUpdateLockdown_FWD_DEFINED__
#define __IUpdateLockdown_FWD_DEFINED__
typedef interface IUpdateLockdown IUpdateLockdown;
#endif 	/* __IUpdateLockdown_FWD_DEFINED__ */


#ifndef __IUpdateException_FWD_DEFINED__
#define __IUpdateException_FWD_DEFINED__
typedef interface IUpdateException IUpdateException;
#endif 	/* __IUpdateException_FWD_DEFINED__ */


#ifndef __IInvalidProductLicenseException_FWD_DEFINED__
#define __IInvalidProductLicenseException_FWD_DEFINED__
typedef interface IInvalidProductLicenseException IInvalidProductLicenseException;
#endif 	/* __IInvalidProductLicenseException_FWD_DEFINED__ */


#ifndef __IAutomaticUpdatesSettings_FWD_DEFINED__
#define __IAutomaticUpdatesSettings_FWD_DEFINED__
typedef interface IAutomaticUpdatesSettings IAutomaticUpdatesSettings;
#endif 	/* __IAutomaticUpdatesSettings_FWD_DEFINED__ */


#ifndef __IAutomaticUpdatesSettings2_FWD_DEFINED__
#define __IAutomaticUpdatesSettings2_FWD_DEFINED__
typedef interface IAutomaticUpdatesSettings2 IAutomaticUpdatesSettings2;
#endif 	/* __IAutomaticUpdatesSettings2_FWD_DEFINED__ */


#ifndef __IUpdate_FWD_DEFINED__
#define __IUpdate_FWD_DEFINED__
typedef interface IUpdate IUpdate;
#endif 	/* __IUpdate_FWD_DEFINED__ */


#ifndef __IUpdate2_FWD_DEFINED__
#define __IUpdate2_FWD_DEFINED__
typedef interface IUpdate2 IUpdate2;
#endif 	/* __IUpdate2_FWD_DEFINED__ */


#ifndef __IUpdate3_FWD_DEFINED__
#define __IUpdate3_FWD_DEFINED__
typedef interface IUpdate3 IUpdate3;
#endif 	/* __IUpdate3_FWD_DEFINED__ */


#ifndef __IWindowsDriverUpdate_FWD_DEFINED__
#define __IWindowsDriverUpdate_FWD_DEFINED__
typedef interface IWindowsDriverUpdate IWindowsDriverUpdate;
#endif 	/* __IWindowsDriverUpdate_FWD_DEFINED__ */


#ifndef __IWindowsDriverUpdate2_FWD_DEFINED__
#define __IWindowsDriverUpdate2_FWD_DEFINED__
typedef interface IWindowsDriverUpdate2 IWindowsDriverUpdate2;
#endif 	/* __IWindowsDriverUpdate2_FWD_DEFINED__ */


#ifndef __IWindowsDriverUpdate3_FWD_DEFINED__
#define __IWindowsDriverUpdate3_FWD_DEFINED__
typedef interface IWindowsDriverUpdate3 IWindowsDriverUpdate3;
#endif 	/* __IWindowsDriverUpdate3_FWD_DEFINED__ */


#ifndef __ISearchCompletedCallback_FWD_DEFINED__
#define __ISearchCompletedCallback_FWD_DEFINED__
typedef interface ISearchCompletedCallback ISearchCompletedCallback;
#endif 	/* __ISearchCompletedCallback_FWD_DEFINED__ */


#ifndef __IDownloadCompletedCallback_FWD_DEFINED__
#define __IDownloadCompletedCallback_FWD_DEFINED__
typedef interface IDownloadCompletedCallback IDownloadCompletedCallback;
#endif 	/* __IDownloadCompletedCallback_FWD_DEFINED__ */


#ifndef __IDownloadProgressChangedCallback_FWD_DEFINED__
#define __IDownloadProgressChangedCallback_FWD_DEFINED__
typedef interface IDownloadProgressChangedCallback IDownloadProgressChangedCallback;
#endif 	/* __IDownloadProgressChangedCallback_FWD_DEFINED__ */


#ifndef __IInstallationCompletedCallback_FWD_DEFINED__
#define __IInstallationCompletedCallback_FWD_DEFINED__
typedef interface IInstallationCompletedCallback IInstallationCompletedCallback;
#endif 	/* __IInstallationCompletedCallback_FWD_DEFINED__ */


#ifndef __IInstallationProgressChangedCallback_FWD_DEFINED__
#define __IInstallationProgressChangedCallback_FWD_DEFINED__
typedef interface IInstallationProgressChangedCallback IInstallationProgressChangedCallback;
#endif 	/* __IInstallationProgressChangedCallback_FWD_DEFINED__ */


#ifndef __IUpdateHistoryEntry_FWD_DEFINED__
#define __IUpdateHistoryEntry_FWD_DEFINED__
typedef interface IUpdateHistoryEntry IUpdateHistoryEntry;
#endif 	/* __IUpdateHistoryEntry_FWD_DEFINED__ */


#ifndef __IUpdateHistoryEntry2_FWD_DEFINED__
#define __IUpdateHistoryEntry2_FWD_DEFINED__
typedef interface IUpdateHistoryEntry2 IUpdateHistoryEntry2;
#endif 	/* __IUpdateHistoryEntry2_FWD_DEFINED__ */


#ifndef __IUpdateDownloadContent_FWD_DEFINED__
#define __IUpdateDownloadContent_FWD_DEFINED__
typedef interface IUpdateDownloadContent IUpdateDownloadContent;
#endif 	/* __IUpdateDownloadContent_FWD_DEFINED__ */


#ifndef __IUpdateDownloadContent2_FWD_DEFINED__
#define __IUpdateDownloadContent2_FWD_DEFINED__
typedef interface IUpdateDownloadContent2 IUpdateDownloadContent2;
#endif 	/* __IUpdateDownloadContent2_FWD_DEFINED__ */


#ifndef __StringCollection_FWD_DEFINED__
#define __StringCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class StringCollection StringCollection;
#else
typedef struct StringCollection StringCollection;
#endif /* __cplusplus */

#endif 	/* __StringCollection_FWD_DEFINED__ */


#ifndef __UpdateSearcher_FWD_DEFINED__
#define __UpdateSearcher_FWD_DEFINED__

#ifdef __cplusplus
typedef class UpdateSearcher UpdateSearcher;
#else
typedef struct UpdateSearcher UpdateSearcher;
#endif /* __cplusplus */

#endif 	/* __UpdateSearcher_FWD_DEFINED__ */


#ifndef __WebProxy_FWD_DEFINED__
#define __WebProxy_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebProxy WebProxy;
#else
typedef struct WebProxy WebProxy;
#endif /* __cplusplus */

#endif 	/* __WebProxy_FWD_DEFINED__ */


#ifndef __SystemInformation_FWD_DEFINED__
#define __SystemInformation_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemInformation SystemInformation;
#else
typedef struct SystemInformation SystemInformation;
#endif /* __cplusplus */

#endif 	/* __SystemInformation_FWD_DEFINED__ */


#ifndef __WindowsUpdateAgentInfo_FWD_DEFINED__
#define __WindowsUpdateAgentInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class WindowsUpdateAgentInfo WindowsUpdateAgentInfo;
#else
typedef struct WindowsUpdateAgentInfo WindowsUpdateAgentInfo;
#endif /* __cplusplus */

#endif 	/* __WindowsUpdateAgentInfo_FWD_DEFINED__ */


#ifndef __AutomaticUpdates_FWD_DEFINED__
#define __AutomaticUpdates_FWD_DEFINED__

#ifdef __cplusplus
typedef class AutomaticUpdates AutomaticUpdates;
#else
typedef struct AutomaticUpdates AutomaticUpdates;
#endif /* __cplusplus */

#endif 	/* __AutomaticUpdates_FWD_DEFINED__ */


#ifndef __UpdateCollection_FWD_DEFINED__
#define __UpdateCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class UpdateCollection UpdateCollection;
#else
typedef struct UpdateCollection UpdateCollection;
#endif /* __cplusplus */

#endif 	/* __UpdateCollection_FWD_DEFINED__ */


#ifndef __UpdateDownloader_FWD_DEFINED__
#define __UpdateDownloader_FWD_DEFINED__

#ifdef __cplusplus
typedef class UpdateDownloader UpdateDownloader;
#else
typedef struct UpdateDownloader UpdateDownloader;
#endif /* __cplusplus */

#endif 	/* __UpdateDownloader_FWD_DEFINED__ */


#ifndef __UpdateInstaller_FWD_DEFINED__
#define __UpdateInstaller_FWD_DEFINED__

#ifdef __cplusplus
typedef class UpdateInstaller UpdateInstaller;
#else
typedef struct UpdateInstaller UpdateInstaller;
#endif /* __cplusplus */

#endif 	/* __UpdateInstaller_FWD_DEFINED__ */


#ifndef __UpdateSession_FWD_DEFINED__
#define __UpdateSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class UpdateSession UpdateSession;
#else
typedef struct UpdateSession UpdateSession;
#endif /* __cplusplus */

#endif 	/* __UpdateSession_FWD_DEFINED__ */


#ifndef __UpdateServiceManager_FWD_DEFINED__
#define __UpdateServiceManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class UpdateServiceManager UpdateServiceManager;
#else
typedef struct UpdateServiceManager UpdateServiceManager;
#endif /* __cplusplus */

#endif 	/* __UpdateServiceManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wuapi_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// wuapi.h
//=--------------------------------------------------------------------------=
// (C) Copyright 2003-2004 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib, "wuguid.lib")

//--------------------------------------------------------------------------
// Windows Update Services Client Interfaces.
// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {B596CC9F-56E5-419E-A622-E01BB457431E}
DEFINE_GUID(LIBID_WUApiLib,0xB596CC9F,0x56E5,0x419E,0xA6,0x22,0xE0,0x1B,0xB4,0x57,0x43,0x1E);

// {A976C28D-75A1-42AA-94AE-8AF8B872089A}
DEFINE_GUID(IID_IUpdateLockdown,0xa976c28d,0x75a1,0x42aa,0x94,0xae,0x8a,0xf8,0xb8,0x72,0x08,0x9a);

// {EFF90582-2DDC-480F-A06D-60F3FBC362C3}
DEFINE_GUID(IID_IStringCollection,0xeff90582,0x2ddc,0x480f,0xa0,0x6d,0x60,0xf3,0xfb,0xc3,0x62,0xc3);

// {174C81FE-AECD-4DAE-B8A0-2C6318DD86A8}
DEFINE_GUID(IID_IWebProxy,0x174c81fe,0xaecd,0x4dae,0xb8,0xa0,0x2c,0x63,0x18,0xdd,0x86,0xa8);

// {ADE87BF7-7B56-4275-8FAB-B9B0E591844B}
DEFINE_GUID(IID_ISystemInformation,0xade87bf7,0x7b56,0x4275,0x8f,0xab,0xb9,0xb0,0xe5,0x91,0x84,0x4b);

// {85713FA1-7796-4FA2-BE3B-E2D6124DD373}
DEFINE_GUID(IID_IWindowsUpdateAgentInfo,0x85713FA1,0x7796,0x4FA2,0xBE,0x3B,0xE2,0xD6,0x12,0x4D,0xD3,0x73);

// {E7A4D634-7942-4DD9-A111-82228BA33901}
DEFINE_GUID(IID_IAutomaticUpdatesResults,0xe7a4d634,0x7942,0x4DD9,0xA1,0x11,0x82,0x22,0x8b,0xa3,0x39,0x1);

// {2EE48F22-AF3C-405F-8970-F71BE12EE9A2}
DEFINE_GUID(IID_IAutomaticUpdatesSettings,0x2ee48f22,0xaf3c,0x405f,0x89,0x70,0xf7,0x1b,0xe1,0x2e,0xe9,0xa2);

// {6ABC136A-C3CA-4384-8171-CB2B1E59B8DC}
DEFINE_GUID(IID_IAutomaticUpdatesSettings2,0x6abc136a,0xc3ca,0x4384,0x81,0x71,0xcb,0x2b,0x1e,0x59,0xb8,0xdc);

// {673425BF-C082-4C7C-BDFD-569464B8E0CE}
DEFINE_GUID(IID_IAutomaticUpdates,0x673425bf,0xc082,0x4c7c,0xbd,0xfd,0x56,0x94,0x64,0xb8,0xe0,0xce);

// {4A2F5C31-CFD9-410E-B7FB-29A653973A0F}
DEFINE_GUID(IID_IAutomaticUpdates2,0x4A2f5C31,0xCFD9,0x410E,0xB7,0xFB,0x29,0xA6,0x53,0x97,0x3A,0xF);

// {46297823-9940-4C09-AED9-CD3EA6D05968}
DEFINE_GUID(IID_IUpdateIdentity,0x46297823,0x9940,0x4c09,0xae,0xd9,0xcd,0x3e,0xa6,0xd0,0x59,0x68);

// {7C907864-346C-4AEB-8F3F-57DA289F969F}
DEFINE_GUID(IID_IImageInformation,0x7c907864,0x346c,0x4aeb,0x8f,0x3f,0x57,0xda,0x28,0x9f,0x96,0x9f);

// {81DDC1B8-9D35-47A6-B471-5B80F519223B}
DEFINE_GUID(IID_ICategory,0x81ddc1b8,0x9d35,0x47a6,0xb4,0x71,0x5b,0x80,0xf5,0x19,0x22,0x3b);

// {3A56BFB8-576C-43F7-9335-FE4838FD7E37}
DEFINE_GUID(IID_ICategoryCollection,0x3a56bfb8,0x576c,0x43f7,0x93,0x35,0xfe,0x48,0x38,0xfd,0x7e,0x37);

// {D9A59339-E245-4DBD-9686-4D5763E39624}
DEFINE_GUID(IID_IInstallationBehavior,0xd9a59339,0xe245,0x4dbd,0x96,0x86,0x4d,0x57,0x63,0xe3,0x96,0x24);

// {54A2CB2D-9A0C-48B6-8A50-9ABB69EE2D02}
DEFINE_GUID(IID_IUpdateDownloadContent,0x54a2cb2d,0x9a0c,0x48b6,0x8a,0x50,0x9a,0xbb,0x69,0xee,0x2d,0x02);

// {C97AD11B-F257-420B-9D9F-377F733F6F68}
DEFINE_GUID(IID_IUpdateDownloadContent2,0xc97ad11b,0xf257,0x420b,0x9d,0x9f,0x37,0x7f,0x73,0x3f,0x6f,0x68);

// {BC5513C8-B3B8-4BF7-A4D4-361C0D8C88BA}
DEFINE_GUID(IID_IUpdateDownloadContentCollection,0xbc5513c8,0xb3b8,0x4bf7,0xa4,0xd4,0x36,0x1c,0x0d,0x8c,0x88,0xba);

// {6A92B07A-D821-4682-B423-5C805022CC4D}
DEFINE_GUID(IID_IUpdate,0x6a92b07a,0xd821,0x4682,0xb4,0x23,0x5c,0x80,0x50,0x22,0xcc,0x4d);

// {144fe9b0-d23d-4a8b-8634-fb4457533b7a}
DEFINE_GUID(IID_IUpdate2,0x144fe9b0,0xd23d,0x4a8b,0x86,0x34,0xfb,0x44,0x57,0x53,0x3b,0x7a);

// {112EDA6B-95B3-476F-9D90-AEE82C6B8181}
DEFINE_GUID(IID_IUpdate3,0x112EDA6B,0x95B3,0x476F,0x9D,0x90,0xAE,0xE8,0x2C,0x6B,0x81,0x81);

// {B383CD1A-5CE9-4504-9F63-764B1236F191}
DEFINE_GUID(IID_IWindowsDriverUpdate,0xb383cd1a,0x5ce9,0x4504,0x9f,0x63,0x76,0x4b,0x12,0x36,0xf1,0x91);

// {615c4269-7a48-43bd-96b7-bf6ca27d6c3e}
DEFINE_GUID(IID_IWindowsDriverUpdate2,0x615c4269,0x7a48,0x43bd,0x96,0xb7,0xbf,0x6c,0xa2,0x7d,0x6c,0x3e);

// {49EBD502-4A96-41BD-9E3E-4C5057F4250C}
DEFINE_GUID(IID_IWindowsDriverUpdate3,0x49EBD502,0x4A96,0x41BD,0x9E,0x3E,0x4C,0x50,0x57,0xF4,0x25,0x0C);

// {07F7438C-7709-4CA5-B518-91279288134E}
DEFINE_GUID(IID_IUpdateCollection,0x07f7438c,0x7709,0x4ca5,0xb5,0x18,0x91,0x27,0x92,0x88,0x13,0x4e);

// {A376DD5E-09D4-427F-AF7C-FED5B6E1C1D6}
DEFINE_GUID(IID_IUpdateException,0xa376dd5e,0x09d4,0x427f,0xaf,0x7c,0xfe,0xd5,0xb6,0xe1,0xc1,0xd6);

// {A37D00F5-7BB0-4953-B414-F9E98326F2E8}
DEFINE_GUID(IID_IInvalidProductLicenseException,0xa37d00f5,0x7bb0,0x4953,0xb4,0x14,0xf9,0xe9,0x83,0x26,0xf2,0xe8);

// {A37D00F5-7BB0-4953-B414-F9E98326F2E8}
DEFINE_GUID(IID_IUpdateExceptionCollection,0x503626a3,0x8e14,0x4729,0x93,0x55,0x0f,0xe6,0x64,0xbd,0x23,0x21);

// {D40CFF62-E08C-4498-941A-01E25F0FD33C}
DEFINE_GUID(IID_ISearchResult,0xd40cff62,0xe08c,0x4498,0x94,0x1a,0x01,0xe2,0x5f,0x0f,0xd3,0x3c);

// {7366EA16-7A1A-4EA2-B042-973D3E9CD99B}
DEFINE_GUID(IID_ISearchJob,0x7366ea16,0x7a1a,0x4ea2,0xb0,0x42,0x97,0x3d,0x3e,0x9c,0xd9,0x9b);

// {A700A634-2850-4C47-938A-9E4B6E5AF9A6}
DEFINE_GUID(IID_ISearchCompletedCallbackArgs,0xa700a634,0x2850,0x4c47,0x93,0x8a,0x9e,0x4b,0x6e,0x5a,0xf9,0xa6);

// {88AEE058-D4B0-4725-A2F1-814A67AE964C}
DEFINE_GUID(IID_ISearchCompletedCallback,0x88aee058,0xd4b0,0x4725,0xa2,0xf1,0x81,0x4a,0x67,0xae,0x96,0x4c);

// {BE56A644-AF0E-4E0E-A311-C1D8E695CBFF}
DEFINE_GUID(IID_IUpdateHistoryEntry,0xbe56a644,0xaf0e,0x4e0e,0xa3,0x11,0xc1,0xd8,0xe6,0x95,0xcb,0xff);

// {C2BFB780-4539-4132-AB8C-0A8772013AB6}
DEFINE_GUID(IID_IUpdateHistoryEntry2,0xc2bfb780,0x4539,0x4132,0xab,0x8c,0x0a,0x87,0x72,0x01,0x3a,0xb6);

// {A7F04F3C-A290-435B-AADF-A116C3357A5C}
DEFINE_GUID(IID_IUpdateHistoryEntryCollection,0xa7f04f3c,0xa290,0x435b,0xaa,0xdf,0xa1,0x16,0xc3,0x35,0x7a,0x5c);

// {8F45ABF1-F9AE-4B95-A933-F0F66E5056EA}
DEFINE_GUID(IID_IUpdateSearcher,0x8f45abf1,0xf9ae,0x4b95,0xa9,0x33,0xf0,0xf6,0x6e,0x50,0x56,0xea);

// {4CBDCB2D-1589-4BEB-BD1C-3E582FF0ADD0}
DEFINE_GUID(IID_IUpdateSearcher2,0x4cbdcb2d,0x1589,0x4beb,0xbd,0x1c,0x3e,0x58,0x2f,0xf0,0xad,0xd0);

// {BF99AF76-B575-42AD-8AA4-33CBB5477AF1}
DEFINE_GUID(IID_IUpdateDownloadResult,0xbf99af76,0xb575,0x42ad,0x8a,0xa4,0x33,0xcb,0xb5,0x47,0x7a,0xf1);

// {DAA4FDD0-4727-4DBE-A1E7-745DCA317144}
DEFINE_GUID(IID_IDownloadResult,0xdaa4fdd0,0x4727,0x4dbe,0xa1,0xe7,0x74,0x5d,0xca,0x31,0x71,0x44);

// {D31A5BAC-F719-4178-9DBB-5E2CB47FD18A}
DEFINE_GUID(IID_IDownloadProgress,0xd31a5bac,0xf719,0x4178,0x9d,0xbb,0x5e,0x2c,0xb4,0x7f,0xd1,0x8a);

// {C574DE85-7358-43F6-AAE8-8697E62D8BA7}
DEFINE_GUID(IID_IDownloadJob,0xc574de85,0x7358,0x43f6,0xaa,0xe8,0x86,0x97,0xe6,0x2d,0x8b,0xa7);

// {FA565B23-498C-47A0-979D-E7D5B1813360}
DEFINE_GUID(IID_IDownloadCompletedCallbackArgs,0xfa565b23,0x498c,0x47a0,0x97,0x9d,0xe7,0xd5,0xb1,0x81,0x33,0x60);

// {77254866-9F5B-4C8E-B9E2-C77A8530D64B}
DEFINE_GUID(IID_IDownloadCompletedCallback,0x77254866,0x9f5b,0x4c8e,0xb9,0xe2,0xc7,0x7a,0x85,0x30,0xd6,0x4b);

// {324FF2C6-4981-4B04-9412-57481745AB24}
DEFINE_GUID(IID_IDownloadProgressChangedCallbackArgs,0x324ff2c6,0x4981,0x4b04,0x94,0x12,0x57,0x48,0x17,0x45,0xab,0x24);

// {8C3F1CDD-6173-4591-AEBD-A56A53CA77C1}
DEFINE_GUID(IID_IDownloadProgressChangedCallback,0x8c3f1cdd,0x6173,0x4591,0xae,0xbd,0xa5,0x6a,0x53,0xca,0x77,0xc1);

// {68F1C6F9-7ECC-4666-A464-247FE12496C3}
DEFINE_GUID(IID_IUpdateDownloader,0x68f1c6f9,0x7ecc,0x4666,0xa4,0x64,0x24,0x7f,0xe1,0x24,0x96,0xc3);

// {D940F0F8-3CBB-4FD0-993F-471E7F2328AD}
DEFINE_GUID(IID_IUpdateInstallationResult,0xd940f0f8,0x3cbb,0x4fd0,0x99,0x3f,0x47,0x1e,0x7f,0x23,0x28,0xad);

// {A43C56D6-7451-48D4-AF96-B6CD2D0D9B7A}
DEFINE_GUID(IID_IInstallationResult,0xa43c56d6,0x7451,0x48d4,0xaf,0x96,0xb6,0xcd,0x2d,0x0d,0x9b,0x7a);

// {345C8244-43A3-4E32-A368-65F073B76F36}
DEFINE_GUID(IID_IInstallationProgress,0x345c8244,0x43a3,0x4e32,0xa3,0x68,0x65,0xf0,0x73,0xb7,0x6f,0x36);

// {5C209F0B-BAD5-432A-9556-4699BED2638A}
DEFINE_GUID(IID_IInstallationJob,0x5c209f0b,0xbad5,0x432a,0x95,0x56,0x46,0x99,0xbe,0xd2,0x63,0x8a);

// {250E2106-8EFB-4705-9653-EF13C581B6A1}
DEFINE_GUID(IID_IInstallationCompletedCallbackArgs,0x250e2106,0x8efb,0x4705,0x96,0x53,0xef,0x13,0xc5,0x81,0xb6,0xa1);

// {45F4F6F3-D602-4F98-9A8A-3EFA152AD2D3}
DEFINE_GUID(IID_IInstallationCompletedCallback,0x45f4f6f3,0xd602,0x4f98,0x9a,0x8a,0x3e,0xfa,0x15,0x2a,0xd2,0xd3);

// {E4F14E1E-689D-4218-A0B9-BC189C484A01}
DEFINE_GUID(IID_IInstallationProgressChangedCallbackArgs,0xe4f14e1e,0x689d,0x4218,0xa0,0xb9,0xbc,0x18,0x9c,0x48,0x4a,0x01);

// {E01402D5-F8DA-43BA-A012-38894BD048F1}
DEFINE_GUID(IID_IInstallationProgressChangedCallback,0xe01402d5,0xf8da,0x43ba,0xa0,0x12,0x38,0x89,0x4b,0xd0,0x48,0xf1);

// {7B929C68-CCDC-4226-96B1-8724600B54C2}
DEFINE_GUID(IID_IUpdateInstaller,0x7b929c68,0xccdc,0x4226,0x96,0xb1,0x87,0x24,0x60,0x0b,0x54,0xc2);

// {3442d4fe-224d-4cee-98cf-30e0c4d229e6}
DEFINE_GUID(IID_IUpdateInstaller2,0x3442d4fe,0x224d,0x4cee,0x98,0xcf,0x30,0xe0,0xc4,0xd2,0x29,0xe6);

// {816858A4-260D-4260-933A-2585F1ABC76B}
DEFINE_GUID(IID_IUpdateSession,0x816858a4,0x260d,0x4260,0x93,0x3a,0x25,0x85,0xf1,0xab,0xc7,0x6b);

// {91CAF7B0-EB23-49ED-9937-C52D817F46F7}
DEFINE_GUID(IID_IUpdateSession2,0x91caf7b0,0xeb23,0x49ed,0x99,0x37,0xc5,0x2d,0x81,0x7f,0x46,0xf7);

// {918EFD1E-B5D8-4c90-8540-AEB9BDC56F9D}
DEFINE_GUID(IID_IUpdateSession3,0x918efd1e,0xb5d8,0x4c90,0x85,0x40,0xae,0xb9,0xbd,0xc5,0x6f,0x9d);

// {76B3B17E-AED6-4DA5-85F0-83587F81ABE3}
DEFINE_GUID(IID_IUpdateService,0x76b3b17e,0xaed6,0x4da5,0x85,0xf0,0x83,0x58,0x7f,0x81,0xab,0xe3);

// {1518B460-6518-4172-940F-C75883B24CEB}
DEFINE_GUID(IID_IUpdateService2,0x1518b460,0x6518,0x4172,0x94,0x0f,0xc7,0x58,0x83,0xb2,0x4c,0xeb);

// {9B0353AA-0E52-44FF-B8B0-1F7FA0437F88}
DEFINE_GUID(IID_IUpdateServiceCollection,0x9b0353aa,0x0e52,0x44ff,0xb8,0xb0,0x1f,0x7f,0xa0,0x43,0x7f,0x88);

// {DDE02280-12B3-4E0B-937B-6747F6ACB286}
DEFINE_GUID(IID_IUpdateServiceRegistration,0xdde02280,0x12b3,0x4e0b,0x93,0x7b,0x67,0x47,0xf6,0xac,0xb2,0x86);

// {23857E3C-02BA-44A3-9423-B1C900805F37}
DEFINE_GUID(IID_IUpdateServiceManager,0x23857E3C,0x02BA,0x44A3,0x94,0x23,0xB1,0xC9,0x00,0x80,0x5F,0x37);

// {0BB8531D-7E8D-424F-986C-A0B8F60A3E7B}
DEFINE_GUID(IID_IUpdateServiceManager2,0x0BB8531D,0x7E8D,0x424F,0x98,0x6C,0xA0,0xB8,0xF6,0x0A,0x3E,0x7B);

// {72C97D74-7C3B-40AE-B77D-ABDB22EBA6FB}
DEFINE_GUID(CLSID_StringCollection,0x72C97D74,0x7C3B,0x40AE,0xB7,0x7D,0xAB,0xDB,0x22,0xEB,0xA6,0xFB);

// {B699E5E8-67FF-4177-88B0-3684A3388BFB}
DEFINE_GUID(CLSID_UpdateSearcher,0xB699E5E8,0x67FF,0x4177,0x88,0xB0,0x36,0x84,0xA3,0x38,0x8B,0xFB);

// {650503cf-9108-4ddc-a2ce-6c2341e1c582}
DEFINE_GUID(CLSID_WebProxy,0x650503cf,0x9108,0x4ddc,0xa2,0xce,0x6c,0x23,0x41,0xe1,0xc5,0x82);

// {C01B9BA0-BEA7-41BA-B604-D0A36F469133}
DEFINE_GUID(CLSID_SystemInformation,0xC01B9BA0,0xBEA7,0x41BA,0xB6,0x04,0xD0,0xA3,0x6F,0x46,0x91,0x33);

// {C2E88C2F-6F5B-4AAA-894B-55C847AD3A2D}
DEFINE_GUID(CLSID_WindowsUpdateAgentInfo,0xC2E88C2F,0x6F5B,0x4AAA,0x89,0x4B,0x55,0xC8,0x47,0xAD,0x3A,0x2D);

// {BFE18E9C-6D87-4450-B37C-E02F0B373803}
DEFINE_GUID(CLSID_AutomaticUpdates,0xBFE18E9C,0x6D87,0x4450,0xB3,0x7C,0xE0,0x2F,0x0B,0x37,0x38,0x03);

// {13639463-00DB-4646-803D-528026140D88}
DEFINE_GUID(CLSID_UpdateCollection,0x13639463,0x00DB,0x4646,0x80,0x3D,0x52,0x80,0x26,0x14,0x0D,0x88);

// {5BAF654A-5A07-4264-A255-9FF54C7151E7}
DEFINE_GUID(CLSID_UpdateDownloader,0x5BAF654A,0x5A07,0x4264,0xA2,0x55,0x9F,0xF5,0x4C,0x71,0x51,0xE7);

// {D2E0FE7F-D23E-48E1-93C0-6FA8CC346474}
DEFINE_GUID(CLSID_UpdateInstaller,0xD2E0FE7F,0xD23E,0x48E1,0x93,0xC0,0x6F,0xA8,0xCC,0x34,0x64,0x74);

// {4CB43D7F-7EEE-4906-8698-60DA1C38F2FE}
DEFINE_GUID(CLSID_UpdateSession,0x4CB43D7F,0x7EEE,0x4906,0x86,0x98,0x60,0xDA,0x1C,0x38,0xF2,0xFE);

// {F8D253D9-89A4-4DAA-87B6-1168369F0B21}
DEFINE_GUID(CLSID_UpdateServiceManager,0xF8D253D9,0x89A4,0x4DAA,0x87,0xB6,0x11,0x68,0x36,0x9F,0x0B,0x21);

typedef /* [v1_enum][helpstring][public] */ 
enum tagAutomaticUpdatesNotificationLevel
    {	aunlNotConfigured	= 0,
	aunlDisabled	= 1,
	aunlNotifyBeforeDownload	= 2,
	aunlNotifyBeforeInstallation	= 3,
	aunlScheduledInstallation	= 4
    } 	AutomaticUpdatesNotificationLevel;

typedef /* [v1_enum][helpstring][public] */ 
enum tagAutomaticUpdatesScheduledInstallationDay
    {	ausidEveryDay	= 0,
	ausidEverySunday	= 1,
	ausidEveryMonday	= 2,
	ausidEveryTuesday	= 3,
	ausidEveryWednesday	= 4,
	ausidEveryThursday	= 5,
	ausidEveryFriday	= 6,
	ausidEverySaturday	= 7
    } 	AutomaticUpdatesScheduledInstallationDay;

typedef /* [v1_enum][helpstring][public] */ 
enum tagDownloadPhase
    {	dphInitializing	= 1,
	dphDownloading	= 2,
	dphVerifying	= 3
    } 	DownloadPhase;

typedef /* [v1_enum][helpstring][public] */ 
enum tagDownloadPriority
    {	dpLow	= 1,
	dpNormal	= 2,
	dpHigh	= 3
    } 	DownloadPriority;

typedef /* [v1_enum][helpstring][public] */ 
enum tagInstallationImpact
    {	iiNormal	= 0,
	iiMinor	= 1,
	iiRequiresExclusiveHandling	= 2
    } 	InstallationImpact;

typedef /* [v1_enum][helpstring][public] */ 
enum tagInstallationRebootBehavior
    {	irbNeverReboots	= 0,
	irbAlwaysRequiresReboot	= 1,
	irbCanRequestReboot	= 2
    } 	InstallationRebootBehavior;

typedef /* [v1_enum][helpstring][public] */ 
enum tagOperationResultCode
    {	orcNotStarted	= 0,
	orcInProgress	= 1,
	orcSucceeded	= 2,
	orcSucceededWithErrors	= 3,
	orcFailed	= 4,
	orcAborted	= 5
    } 	OperationResultCode;

typedef /* [v1_enum][helpstring][public] */ 
enum tagServerSelection
    {	ssDefault	= 0,
	ssManagedServer	= 1,
	ssWindowsUpdate	= 2,
	ssOthers	= 3
    } 	ServerSelection;

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateType
    {	utSoftware	= 1,
	utDriver	= 2
    } 	UpdateType;

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateOperation
    {	uoInstallation	= 1,
	uoUninstallation	= 2
    } 	UpdateOperation;

typedef /* [v1_enum][helpstring][public] */ 
enum tagDeploymentAction
    {	daNone	= 0,
	daInstallation	= 1,
	daUninstallation	= 2,
	daDetection	= 3
    } 	DeploymentAction;

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateExceptionContext
    {	uecGeneral	= 1,
	uecWindowsDriver	= 2,
	uecWindowsInstaller	= 3
    } 	UpdateExceptionContext;

typedef /* [v1_enum][helpstring][public] */ 
enum tagAutomaticUpdatesUserType
    {	auutCurrentUser	= 1,
	auutLocalAdministrator	= 2
    } 	AutomaticUpdatesUserType;

typedef /* [v1_enum][helpstring][public] */ 
enum tagAutomaticUpdatesPermissionType
    {	auptSetNotificationLevel	= 1,
	auptDisableAutomaticUpdates	= 2,
	auptSetIncludeRecommendedUpdates	= 3
    } 	AutomaticUpdatesPermissionType;

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateServiceRegistrationState
    {	usrsNotRegistered	= 1,
	usrsRegistrationPending	= 2,
	usrsRegistered	= 3
    } 	UpdateServiceRegistrationState;

#define	UPDATE_LOCKDOWN_WEBSITE_ACCESS	( 0x1 )







extern RPC_IF_HANDLE __MIDL_itf_wuapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wuapi_0000_0000_v0_0_s_ifspec;

#ifndef __IUpdateLockdown_INTERFACE_DEFINED__
#define __IUpdateLockdown_INTERFACE_DEFINED__

/* interface IUpdateLockdown */
/* [unique][uuid][nonextensible][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateLockdown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a976c28d-75a1-42aa-94ae-8af8b872089a")
    IUpdateLockdown : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LockDown( 
            /* [in] */ LONG flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateLockdownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateLockdown * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateLockdown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateLockdown * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LockDown )( 
            IUpdateLockdown * This,
            /* [in] */ LONG flags);
        
        END_INTERFACE
    } IUpdateLockdownVtbl;

    interface IUpdateLockdown
    {
        CONST_VTBL struct IUpdateLockdownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateLockdown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateLockdown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateLockdown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateLockdown_LockDown(This,flags)	\
    ( (This)->lpVtbl -> LockDown(This,flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateLockdown_INTERFACE_DEFINED__ */


#ifndef __IStringCollection_INTERFACE_DEFINED__
#define __IStringCollection_INTERFACE_DEFINED__

/* interface IStringCollection */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IStringCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eff90582-2ddc-480f-a06d-60f3fbc362c3")
    IStringCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ LONG index,
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in BSTR value,
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Copy( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Insert( 
            /* [in] */ LONG index,
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ LONG index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStringCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStringCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStringCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IStringCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IStringCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IStringCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IStringCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IStringCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Item )( 
            IStringCollection * This,
            /* [in] */ LONG index,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IStringCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IStringCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IStringCollection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IStringCollection * This,
            /* [in] */ __RPC__in BSTR value,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IStringCollection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            IStringCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Insert )( 
            IStringCollection * This,
            /* [in] */ LONG index,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IStringCollection * This,
            /* [in] */ LONG index);
        
        END_INTERFACE
    } IStringCollectionVtbl;

    interface IStringCollection
    {
        CONST_VTBL struct IStringCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStringCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStringCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStringCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IStringCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IStringCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IStringCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IStringCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define IStringCollection_put_Item(This,index,value)	\
    ( (This)->lpVtbl -> put_Item(This,index,value) ) 

#define IStringCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IStringCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#define IStringCollection_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IStringCollection_Add(This,value,retval)	\
    ( (This)->lpVtbl -> Add(This,value,retval) ) 

#define IStringCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IStringCollection_Copy(This,retval)	\
    ( (This)->lpVtbl -> Copy(This,retval) ) 

#define IStringCollection_Insert(This,index,value)	\
    ( (This)->lpVtbl -> Insert(This,index,value) ) 

#define IStringCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStringCollection_INTERFACE_DEFINED__ */


#ifndef __IWebProxy_INTERFACE_DEFINED__
#define __IWebProxy_INTERFACE_DEFINED__

/* interface IWebProxy */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IWebProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("174c81fe-aecd-4dae-b8a0-2c6318dd86a8")
    IWebProxy : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Address( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BypassList( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BypassList( 
            /* [in] */ __RPC__in_opt IStringCollection *value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BypassProxyOnLocal( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BypassProxyOnLocal( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UserName( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PromptForCredentials( 
            /* [unique][in] */ __RPC__in_opt IUnknown *parentWindow,
            /* [in] */ __RPC__in BSTR title) = 0;
        
        virtual /* [helpstring][restricted][id] */ HRESULT STDMETHODCALLTYPE PromptForCredentialsFromHwnd( 
            /* [unique][in] */ __RPC__in_opt HWND parentWindow,
            /* [in] */ __RPC__in BSTR title) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoDetect( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoDetect( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebProxy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWebProxy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWebProxy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWebProxy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWebProxy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            IWebProxy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Address )( 
            IWebProxy * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BypassList )( 
            IWebProxy * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BypassList )( 
            IWebProxy * This,
            /* [in] */ __RPC__in_opt IStringCollection *value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BypassProxyOnLocal )( 
            IWebProxy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BypassProxyOnLocal )( 
            IWebProxy * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IWebProxy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            IWebProxy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UserName )( 
            IWebProxy * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IWebProxy * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PromptForCredentials )( 
            IWebProxy * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *parentWindow,
            /* [in] */ __RPC__in BSTR title);
        
        /* [helpstring][restricted][id] */ HRESULT ( STDMETHODCALLTYPE *PromptForCredentialsFromHwnd )( 
            IWebProxy * This,
            /* [unique][in] */ __RPC__in_opt HWND parentWindow,
            /* [in] */ __RPC__in BSTR title);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoDetect )( 
            IWebProxy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoDetect )( 
            IWebProxy * This,
            /* [in] */ VARIANT_BOOL value);
        
        END_INTERFACE
    } IWebProxyVtbl;

    interface IWebProxy
    {
        CONST_VTBL struct IWebProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebProxy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWebProxy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWebProxy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWebProxy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWebProxy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWebProxy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWebProxy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWebProxy_get_Address(This,retval)	\
    ( (This)->lpVtbl -> get_Address(This,retval) ) 

#define IWebProxy_put_Address(This,value)	\
    ( (This)->lpVtbl -> put_Address(This,value) ) 

#define IWebProxy_get_BypassList(This,retval)	\
    ( (This)->lpVtbl -> get_BypassList(This,retval) ) 

#define IWebProxy_put_BypassList(This,value)	\
    ( (This)->lpVtbl -> put_BypassList(This,value) ) 

#define IWebProxy_get_BypassProxyOnLocal(This,retval)	\
    ( (This)->lpVtbl -> get_BypassProxyOnLocal(This,retval) ) 

#define IWebProxy_put_BypassProxyOnLocal(This,value)	\
    ( (This)->lpVtbl -> put_BypassProxyOnLocal(This,value) ) 

#define IWebProxy_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IWebProxy_get_UserName(This,retval)	\
    ( (This)->lpVtbl -> get_UserName(This,retval) ) 

#define IWebProxy_put_UserName(This,value)	\
    ( (This)->lpVtbl -> put_UserName(This,value) ) 

#define IWebProxy_SetPassword(This,value)	\
    ( (This)->lpVtbl -> SetPassword(This,value) ) 

#define IWebProxy_PromptForCredentials(This,parentWindow,title)	\
    ( (This)->lpVtbl -> PromptForCredentials(This,parentWindow,title) ) 

#define IWebProxy_PromptForCredentialsFromHwnd(This,parentWindow,title)	\
    ( (This)->lpVtbl -> PromptForCredentialsFromHwnd(This,parentWindow,title) ) 

#define IWebProxy_get_AutoDetect(This,retval)	\
    ( (This)->lpVtbl -> get_AutoDetect(This,retval) ) 

#define IWebProxy_put_AutoDetect(This,value)	\
    ( (This)->lpVtbl -> put_AutoDetect(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWebProxy_INTERFACE_DEFINED__ */


#ifndef __ISystemInformation_INTERFACE_DEFINED__
#define __ISystemInformation_INTERFACE_DEFINED__

/* interface ISystemInformation */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_ISystemInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ade87bf7-7b56-4275-8fab-b9b0e591844b")
    ISystemInformation : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OemHardwareSupportLink( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RebootRequired( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISystemInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISystemInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISystemInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISystemInformation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISystemInformation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISystemInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISystemInformation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OemHardwareSupportLink )( 
            ISystemInformation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequired )( 
            ISystemInformation * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } ISystemInformationVtbl;

    interface ISystemInformation
    {
        CONST_VTBL struct ISystemInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemInformation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISystemInformation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISystemInformation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISystemInformation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISystemInformation_get_OemHardwareSupportLink(This,retval)	\
    ( (This)->lpVtbl -> get_OemHardwareSupportLink(This,retval) ) 

#define ISystemInformation_get_RebootRequired(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequired(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemInformation_INTERFACE_DEFINED__ */


#ifndef __IWindowsUpdateAgentInfo_INTERFACE_DEFINED__
#define __IWindowsUpdateAgentInfo_INTERFACE_DEFINED__

/* interface IWindowsUpdateAgentInfo */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IWindowsUpdateAgentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85713fa1-7796-4fa2-be3b-e2d6124dd373")
    IWindowsUpdateAgentInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ VARIANT varInfoIdentifier,
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowsUpdateAgentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowsUpdateAgentInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowsUpdateAgentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowsUpdateAgentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWindowsUpdateAgentInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWindowsUpdateAgentInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWindowsUpdateAgentInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWindowsUpdateAgentInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IWindowsUpdateAgentInfo * This,
            /* [in] */ VARIANT varInfoIdentifier,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        END_INTERFACE
    } IWindowsUpdateAgentInfoVtbl;

    interface IWindowsUpdateAgentInfo
    {
        CONST_VTBL struct IWindowsUpdateAgentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowsUpdateAgentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowsUpdateAgentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowsUpdateAgentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowsUpdateAgentInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWindowsUpdateAgentInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWindowsUpdateAgentInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWindowsUpdateAgentInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWindowsUpdateAgentInfo_GetInfo(This,varInfoIdentifier,retval)	\
    ( (This)->lpVtbl -> GetInfo(This,varInfoIdentifier,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowsUpdateAgentInfo_INTERFACE_DEFINED__ */


#ifndef __IAutomaticUpdatesResults_INTERFACE_DEFINED__
#define __IAutomaticUpdatesResults_INTERFACE_DEFINED__

/* interface IAutomaticUpdatesResults */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IAutomaticUpdatesResults;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7A4D634-7942-4DD9-A111-82228BA33901")
    IAutomaticUpdatesResults : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LastSearchSuccessDate( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LastInstallationSuccessDate( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutomaticUpdatesResultsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutomaticUpdatesResults * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutomaticUpdatesResults * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutomaticUpdatesResults * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAutomaticUpdatesResults * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAutomaticUpdatesResults * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAutomaticUpdatesResults * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAutomaticUpdatesResults * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastSearchSuccessDate )( 
            IAutomaticUpdatesResults * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastInstallationSuccessDate )( 
            IAutomaticUpdatesResults * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        END_INTERFACE
    } IAutomaticUpdatesResultsVtbl;

    interface IAutomaticUpdatesResults
    {
        CONST_VTBL struct IAutomaticUpdatesResultsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutomaticUpdatesResults_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutomaticUpdatesResults_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutomaticUpdatesResults_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutomaticUpdatesResults_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAutomaticUpdatesResults_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAutomaticUpdatesResults_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAutomaticUpdatesResults_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAutomaticUpdatesResults_get_LastSearchSuccessDate(This,retval)	\
    ( (This)->lpVtbl -> get_LastSearchSuccessDate(This,retval) ) 

#define IAutomaticUpdatesResults_get_LastInstallationSuccessDate(This,retval)	\
    ( (This)->lpVtbl -> get_LastInstallationSuccessDate(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutomaticUpdatesResults_INTERFACE_DEFINED__ */


#ifndef __IAutomaticUpdatesSettings_INTERFACE_DEFINED__
#define __IAutomaticUpdatesSettings_INTERFACE_DEFINED__

/* interface IAutomaticUpdatesSettings */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IAutomaticUpdatesSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2ee48f22-af3c-405f-8970-f71be12ee9a2")
    IAutomaticUpdatesSettings : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_NotificationLevel( 
            /* [retval][out] */ __RPC__out AutomaticUpdatesNotificationLevel *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_NotificationLevel( 
            /* [in] */ AutomaticUpdatesNotificationLevel value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Required( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ScheduledInstallationDay( 
            /* [retval][out] */ __RPC__out AutomaticUpdatesScheduledInstallationDay *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ScheduledInstallationDay( 
            /* [in] */ AutomaticUpdatesScheduledInstallationDay value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ScheduledInstallationTime( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ScheduledInstallationTime( 
            /* [in] */ LONG value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutomaticUpdatesSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutomaticUpdatesSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutomaticUpdatesSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutomaticUpdatesSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAutomaticUpdatesSettings * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAutomaticUpdatesSettings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAutomaticUpdatesSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAutomaticUpdatesSettings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_NotificationLevel )( 
            IAutomaticUpdatesSettings * This,
            /* [retval][out] */ __RPC__out AutomaticUpdatesNotificationLevel *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_NotificationLevel )( 
            IAutomaticUpdatesSettings * This,
            /* [in] */ AutomaticUpdatesNotificationLevel value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IAutomaticUpdatesSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Required )( 
            IAutomaticUpdatesSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledInstallationDay )( 
            IAutomaticUpdatesSettings * This,
            /* [retval][out] */ __RPC__out AutomaticUpdatesScheduledInstallationDay *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduledInstallationDay )( 
            IAutomaticUpdatesSettings * This,
            /* [in] */ AutomaticUpdatesScheduledInstallationDay value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledInstallationTime )( 
            IAutomaticUpdatesSettings * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduledInstallationTime )( 
            IAutomaticUpdatesSettings * This,
            /* [in] */ LONG value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IAutomaticUpdatesSettings * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IAutomaticUpdatesSettings * This);
        
        END_INTERFACE
    } IAutomaticUpdatesSettingsVtbl;

    interface IAutomaticUpdatesSettings
    {
        CONST_VTBL struct IAutomaticUpdatesSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutomaticUpdatesSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutomaticUpdatesSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutomaticUpdatesSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutomaticUpdatesSettings_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAutomaticUpdatesSettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAutomaticUpdatesSettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAutomaticUpdatesSettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAutomaticUpdatesSettings_get_NotificationLevel(This,retval)	\
    ( (This)->lpVtbl -> get_NotificationLevel(This,retval) ) 

#define IAutomaticUpdatesSettings_put_NotificationLevel(This,value)	\
    ( (This)->lpVtbl -> put_NotificationLevel(This,value) ) 

#define IAutomaticUpdatesSettings_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IAutomaticUpdatesSettings_get_Required(This,retval)	\
    ( (This)->lpVtbl -> get_Required(This,retval) ) 

#define IAutomaticUpdatesSettings_get_ScheduledInstallationDay(This,retval)	\
    ( (This)->lpVtbl -> get_ScheduledInstallationDay(This,retval) ) 

#define IAutomaticUpdatesSettings_put_ScheduledInstallationDay(This,value)	\
    ( (This)->lpVtbl -> put_ScheduledInstallationDay(This,value) ) 

#define IAutomaticUpdatesSettings_get_ScheduledInstallationTime(This,retval)	\
    ( (This)->lpVtbl -> get_ScheduledInstallationTime(This,retval) ) 

#define IAutomaticUpdatesSettings_put_ScheduledInstallationTime(This,value)	\
    ( (This)->lpVtbl -> put_ScheduledInstallationTime(This,value) ) 

#define IAutomaticUpdatesSettings_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IAutomaticUpdatesSettings_Save(This)	\
    ( (This)->lpVtbl -> Save(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutomaticUpdatesSettings_INTERFACE_DEFINED__ */


#ifndef __IAutomaticUpdatesSettings2_INTERFACE_DEFINED__
#define __IAutomaticUpdatesSettings2_INTERFACE_DEFINED__

/* interface IAutomaticUpdatesSettings2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IAutomaticUpdatesSettings2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6abc136a-c3ca-4384-8171-cb2b1e59b8dc")
    IAutomaticUpdatesSettings2 : public IAutomaticUpdatesSettings
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IncludeRecommendedUpdates( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IncludeRecommendedUpdates( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckPermission( 
            /* [in] */ AutomaticUpdatesUserType userType,
            /* [in] */ AutomaticUpdatesPermissionType permissionType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *userHasPermission) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutomaticUpdatesSettings2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutomaticUpdatesSettings2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutomaticUpdatesSettings2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAutomaticUpdatesSettings2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_NotificationLevel )( 
            IAutomaticUpdatesSettings2 * This,
            /* [retval][out] */ __RPC__out AutomaticUpdatesNotificationLevel *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_NotificationLevel )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ AutomaticUpdatesNotificationLevel value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IAutomaticUpdatesSettings2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Required )( 
            IAutomaticUpdatesSettings2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledInstallationDay )( 
            IAutomaticUpdatesSettings2 * This,
            /* [retval][out] */ __RPC__out AutomaticUpdatesScheduledInstallationDay *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduledInstallationDay )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ AutomaticUpdatesScheduledInstallationDay value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledInstallationTime )( 
            IAutomaticUpdatesSettings2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduledInstallationTime )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ LONG value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IAutomaticUpdatesSettings2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IAutomaticUpdatesSettings2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeRecommendedUpdates )( 
            IAutomaticUpdatesSettings2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeRecommendedUpdates )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CheckPermission )( 
            IAutomaticUpdatesSettings2 * This,
            /* [in] */ AutomaticUpdatesUserType userType,
            /* [in] */ AutomaticUpdatesPermissionType permissionType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *userHasPermission);
        
        END_INTERFACE
    } IAutomaticUpdatesSettings2Vtbl;

    interface IAutomaticUpdatesSettings2
    {
        CONST_VTBL struct IAutomaticUpdatesSettings2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutomaticUpdatesSettings2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutomaticUpdatesSettings2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutomaticUpdatesSettings2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutomaticUpdatesSettings2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAutomaticUpdatesSettings2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAutomaticUpdatesSettings2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAutomaticUpdatesSettings2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAutomaticUpdatesSettings2_get_NotificationLevel(This,retval)	\
    ( (This)->lpVtbl -> get_NotificationLevel(This,retval) ) 

#define IAutomaticUpdatesSettings2_put_NotificationLevel(This,value)	\
    ( (This)->lpVtbl -> put_NotificationLevel(This,value) ) 

#define IAutomaticUpdatesSettings2_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IAutomaticUpdatesSettings2_get_Required(This,retval)	\
    ( (This)->lpVtbl -> get_Required(This,retval) ) 

#define IAutomaticUpdatesSettings2_get_ScheduledInstallationDay(This,retval)	\
    ( (This)->lpVtbl -> get_ScheduledInstallationDay(This,retval) ) 

#define IAutomaticUpdatesSettings2_put_ScheduledInstallationDay(This,value)	\
    ( (This)->lpVtbl -> put_ScheduledInstallationDay(This,value) ) 

#define IAutomaticUpdatesSettings2_get_ScheduledInstallationTime(This,retval)	\
    ( (This)->lpVtbl -> get_ScheduledInstallationTime(This,retval) ) 

#define IAutomaticUpdatesSettings2_put_ScheduledInstallationTime(This,value)	\
    ( (This)->lpVtbl -> put_ScheduledInstallationTime(This,value) ) 

#define IAutomaticUpdatesSettings2_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IAutomaticUpdatesSettings2_Save(This)	\
    ( (This)->lpVtbl -> Save(This) ) 


#define IAutomaticUpdatesSettings2_get_IncludeRecommendedUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_IncludeRecommendedUpdates(This,retval) ) 

#define IAutomaticUpdatesSettings2_put_IncludeRecommendedUpdates(This,value)	\
    ( (This)->lpVtbl -> put_IncludeRecommendedUpdates(This,value) ) 

#define IAutomaticUpdatesSettings2_CheckPermission(This,userType,permissionType,userHasPermission)	\
    ( (This)->lpVtbl -> CheckPermission(This,userType,permissionType,userHasPermission) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutomaticUpdatesSettings2_INTERFACE_DEFINED__ */


#ifndef __IAutomaticUpdates_INTERFACE_DEFINED__
#define __IAutomaticUpdates_INTERFACE_DEFINED__

/* interface IAutomaticUpdates */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IAutomaticUpdates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("673425bf-c082-4c7c-bdfd-569464b8e0ce")
    IAutomaticUpdates : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DetectNow( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowSettingsDialog( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Settings( 
            /* [retval][out] */ __RPC__deref_out_opt IAutomaticUpdatesSettings **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableService( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutomaticUpdatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutomaticUpdates * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutomaticUpdates * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutomaticUpdates * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAutomaticUpdates * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAutomaticUpdates * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAutomaticUpdates * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAutomaticUpdates * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DetectNow )( 
            IAutomaticUpdates * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IAutomaticUpdates * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IAutomaticUpdates * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShowSettingsDialog )( 
            IAutomaticUpdates * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Settings )( 
            IAutomaticUpdates * This,
            /* [retval][out] */ __RPC__deref_out_opt IAutomaticUpdatesSettings **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceEnabled )( 
            IAutomaticUpdates * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableService )( 
            IAutomaticUpdates * This);
        
        END_INTERFACE
    } IAutomaticUpdatesVtbl;

    interface IAutomaticUpdates
    {
        CONST_VTBL struct IAutomaticUpdatesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutomaticUpdates_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutomaticUpdates_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutomaticUpdates_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutomaticUpdates_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAutomaticUpdates_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAutomaticUpdates_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAutomaticUpdates_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAutomaticUpdates_DetectNow(This)	\
    ( (This)->lpVtbl -> DetectNow(This) ) 

#define IAutomaticUpdates_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IAutomaticUpdates_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IAutomaticUpdates_ShowSettingsDialog(This)	\
    ( (This)->lpVtbl -> ShowSettingsDialog(This) ) 

#define IAutomaticUpdates_get_Settings(This,retval)	\
    ( (This)->lpVtbl -> get_Settings(This,retval) ) 

#define IAutomaticUpdates_get_ServiceEnabled(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceEnabled(This,retval) ) 

#define IAutomaticUpdates_EnableService(This)	\
    ( (This)->lpVtbl -> EnableService(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutomaticUpdates_INTERFACE_DEFINED__ */


#ifndef __IAutomaticUpdates2_INTERFACE_DEFINED__
#define __IAutomaticUpdates2_INTERFACE_DEFINED__

/* interface IAutomaticUpdates2 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IAutomaticUpdates2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A2F5C31-CFD9-410E-B7FB-29A653973A0F")
    IAutomaticUpdates2 : public IAutomaticUpdates
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Results( 
            /* [retval][out] */ __RPC__deref_out_opt IAutomaticUpdatesResults **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutomaticUpdates2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutomaticUpdates2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutomaticUpdates2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutomaticUpdates2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAutomaticUpdates2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAutomaticUpdates2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAutomaticUpdates2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAutomaticUpdates2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DetectNow )( 
            IAutomaticUpdates2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IAutomaticUpdates2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IAutomaticUpdates2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShowSettingsDialog )( 
            IAutomaticUpdates2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Settings )( 
            IAutomaticUpdates2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IAutomaticUpdatesSettings **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceEnabled )( 
            IAutomaticUpdates2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableService )( 
            IAutomaticUpdates2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Results )( 
            IAutomaticUpdates2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IAutomaticUpdatesResults **retval);
        
        END_INTERFACE
    } IAutomaticUpdates2Vtbl;

    interface IAutomaticUpdates2
    {
        CONST_VTBL struct IAutomaticUpdates2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutomaticUpdates2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutomaticUpdates2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutomaticUpdates2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutomaticUpdates2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAutomaticUpdates2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAutomaticUpdates2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAutomaticUpdates2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAutomaticUpdates2_DetectNow(This)	\
    ( (This)->lpVtbl -> DetectNow(This) ) 

#define IAutomaticUpdates2_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IAutomaticUpdates2_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IAutomaticUpdates2_ShowSettingsDialog(This)	\
    ( (This)->lpVtbl -> ShowSettingsDialog(This) ) 

#define IAutomaticUpdates2_get_Settings(This,retval)	\
    ( (This)->lpVtbl -> get_Settings(This,retval) ) 

#define IAutomaticUpdates2_get_ServiceEnabled(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceEnabled(This,retval) ) 

#define IAutomaticUpdates2_EnableService(This)	\
    ( (This)->lpVtbl -> EnableService(This) ) 


#define IAutomaticUpdates2_get_Results(This,retval)	\
    ( (This)->lpVtbl -> get_Results(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutomaticUpdates2_INTERFACE_DEFINED__ */


#ifndef __IUpdateIdentity_INTERFACE_DEFINED__
#define __IUpdateIdentity_INTERFACE_DEFINED__

/* interface IUpdateIdentity */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46297823-9940-4c09-aed9-cd3ea6d05968")
    IUpdateIdentity : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RevisionNumber( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UpdateID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateIdentity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateIdentity * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateIdentity * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateIdentity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateIdentity * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RevisionNumber )( 
            IUpdateIdentity * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateID )( 
            IUpdateIdentity * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        END_INTERFACE
    } IUpdateIdentityVtbl;

    interface IUpdateIdentity
    {
        CONST_VTBL struct IUpdateIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateIdentity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateIdentity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateIdentity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateIdentity_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateIdentity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateIdentity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateIdentity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateIdentity_get_RevisionNumber(This,retval)	\
    ( (This)->lpVtbl -> get_RevisionNumber(This,retval) ) 

#define IUpdateIdentity_get_UpdateID(This,retval)	\
    ( (This)->lpVtbl -> get_UpdateID(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateIdentity_INTERFACE_DEFINED__ */


#ifndef __IImageInformation_INTERFACE_DEFINED__
#define __IImageInformation_INTERFACE_DEFINED__

/* interface IImageInformation */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IImageInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c907864-346c-4aeb-8f3f-57da289f969f")
    IImageInformation : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AltText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IImageInformation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IImageInformation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IImageInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IImageInformation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AltText )( 
            IImageInformation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IImageInformation * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Source )( 
            IImageInformation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IImageInformation * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IImageInformationVtbl;

    interface IImageInformation
    {
        CONST_VTBL struct IImageInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImageInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImageInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImageInformation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IImageInformation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IImageInformation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IImageInformation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IImageInformation_get_AltText(This,retval)	\
    ( (This)->lpVtbl -> get_AltText(This,retval) ) 

#define IImageInformation_get_Height(This,retval)	\
    ( (This)->lpVtbl -> get_Height(This,retval) ) 

#define IImageInformation_get_Source(This,retval)	\
    ( (This)->lpVtbl -> get_Source(This,retval) ) 

#define IImageInformation_get_Width(This,retval)	\
    ( (This)->lpVtbl -> get_Width(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImageInformation_INTERFACE_DEFINED__ */


#ifndef __ICategory_INTERFACE_DEFINED__
#define __ICategory_INTERFACE_DEFINED__

/* interface ICategory */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_ICategory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81ddc1b8-9d35-47a6-b471-5b80f519223b")
    ICategory : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CategoryID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Children( 
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Order( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt ICategory **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Updates( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICategory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICategory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICategory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICategory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CategoryID )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Children )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Order )( 
            ICategory * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategory **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            ICategory * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        END_INTERFACE
    } ICategoryVtbl;

    interface ICategory
    {
        CONST_VTBL struct ICategoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICategory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICategory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICategory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICategory_get_Name(This,retval)	\
    ( (This)->lpVtbl -> get_Name(This,retval) ) 

#define ICategory_get_CategoryID(This,retval)	\
    ( (This)->lpVtbl -> get_CategoryID(This,retval) ) 

#define ICategory_get_Children(This,retval)	\
    ( (This)->lpVtbl -> get_Children(This,retval) ) 

#define ICategory_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define ICategory_get_Image(This,retval)	\
    ( (This)->lpVtbl -> get_Image(This,retval) ) 

#define ICategory_get_Order(This,retval)	\
    ( (This)->lpVtbl -> get_Order(This,retval) ) 

#define ICategory_get_Parent(This,retval)	\
    ( (This)->lpVtbl -> get_Parent(This,retval) ) 

#define ICategory_get_Type(This,retval)	\
    ( (This)->lpVtbl -> get_Type(This,retval) ) 

#define ICategory_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategory_INTERFACE_DEFINED__ */


#ifndef __ICategoryCollection_INTERFACE_DEFINED__
#define __ICategoryCollection_INTERFACE_DEFINED__

/* interface ICategoryCollection */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_ICategoryCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3a56bfb8-576c-43f7-9335-fe4838fd7e37")
    ICategoryCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt ICategory **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategoryCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategoryCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategoryCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategoryCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICategoryCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICategoryCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICategoryCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICategoryCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ICategoryCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt ICategory **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ICategoryCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICategoryCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } ICategoryCollectionVtbl;

    interface ICategoryCollection
    {
        CONST_VTBL struct ICategoryCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategoryCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategoryCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategoryCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategoryCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICategoryCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICategoryCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICategoryCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICategoryCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define ICategoryCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define ICategoryCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategoryCollection_INTERFACE_DEFINED__ */


#ifndef __IInstallationBehavior_INTERFACE_DEFINED__
#define __IInstallationBehavior_INTERFACE_DEFINED__

/* interface IInstallationBehavior */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationBehavior;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d9a59339-e245-4dbd-9686-4d5763e39624")
    IInstallationBehavior : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanRequestUserInput( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Impact( 
            /* [retval][out] */ __RPC__out InstallationImpact *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RebootBehavior( 
            /* [retval][out] */ __RPC__out InstallationRebootBehavior *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RequiresNetworkConnectivity( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationBehaviorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationBehavior * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationBehavior * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationBehavior * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IInstallationBehavior * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInstallationBehavior * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IInstallationBehavior * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationBehavior * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRequestUserInput )( 
            IInstallationBehavior * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Impact )( 
            IInstallationBehavior * This,
            /* [retval][out] */ __RPC__out InstallationImpact *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootBehavior )( 
            IInstallationBehavior * This,
            /* [retval][out] */ __RPC__out InstallationRebootBehavior *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RequiresNetworkConnectivity )( 
            IInstallationBehavior * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IInstallationBehaviorVtbl;

    interface IInstallationBehavior
    {
        CONST_VTBL struct IInstallationBehaviorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationBehavior_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationBehavior_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationBehavior_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationBehavior_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInstallationBehavior_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInstallationBehavior_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInstallationBehavior_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInstallationBehavior_get_CanRequestUserInput(This,retval)	\
    ( (This)->lpVtbl -> get_CanRequestUserInput(This,retval) ) 

#define IInstallationBehavior_get_Impact(This,retval)	\
    ( (This)->lpVtbl -> get_Impact(This,retval) ) 

#define IInstallationBehavior_get_RebootBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_RebootBehavior(This,retval) ) 

#define IInstallationBehavior_get_RequiresNetworkConnectivity(This,retval)	\
    ( (This)->lpVtbl -> get_RequiresNetworkConnectivity(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationBehavior_INTERFACE_DEFINED__ */


#ifndef __IUpdateDownloadContent_INTERFACE_DEFINED__
#define __IUpdateDownloadContent_INTERFACE_DEFINED__

/* interface IUpdateDownloadContent */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateDownloadContent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54a2cb2d-9a0c-48b6-8a50-9abb69ee2d02")
    IUpdateDownloadContent : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DownloadUrl( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateDownloadContentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateDownloadContent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateDownloadContent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateDownloadContent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateDownloadContent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateDownloadContent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateDownloadContent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateDownloadContent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadUrl )( 
            IUpdateDownloadContent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        END_INTERFACE
    } IUpdateDownloadContentVtbl;

    interface IUpdateDownloadContent
    {
        CONST_VTBL struct IUpdateDownloadContentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateDownloadContent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateDownloadContent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateDownloadContent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateDownloadContent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateDownloadContent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateDownloadContent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateDownloadContent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateDownloadContent_get_DownloadUrl(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadUrl(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateDownloadContent_INTERFACE_DEFINED__ */


#ifndef __IUpdateDownloadContent2_INTERFACE_DEFINED__
#define __IUpdateDownloadContent2_INTERFACE_DEFINED__

/* interface IUpdateDownloadContent2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateDownloadContent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c97ad11b-f257-420b-9d9f-377f733f6f68")
    IUpdateDownloadContent2 : public IUpdateDownloadContent
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDeltaCompressedContent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateDownloadContent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateDownloadContent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateDownloadContent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateDownloadContent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateDownloadContent2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateDownloadContent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateDownloadContent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateDownloadContent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadUrl )( 
            IUpdateDownloadContent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDeltaCompressedContent )( 
            IUpdateDownloadContent2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IUpdateDownloadContent2Vtbl;

    interface IUpdateDownloadContent2
    {
        CONST_VTBL struct IUpdateDownloadContent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateDownloadContent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateDownloadContent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateDownloadContent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateDownloadContent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateDownloadContent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateDownloadContent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateDownloadContent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateDownloadContent2_get_DownloadUrl(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadUrl(This,retval) ) 


#define IUpdateDownloadContent2_get_IsDeltaCompressedContent(This,retval)	\
    ( (This)->lpVtbl -> get_IsDeltaCompressedContent(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateDownloadContent2_INTERFACE_DEFINED__ */


#ifndef __IUpdateDownloadContentCollection_INTERFACE_DEFINED__
#define __IUpdateDownloadContentCollection_INTERFACE_DEFINED__

/* interface IUpdateDownloadContentCollection */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateDownloadContentCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc5513c8-b3b8-4bf7-a4d4-361c0d8c88ba")
    IUpdateDownloadContentCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContent **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateDownloadContentCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateDownloadContentCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateDownloadContentCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateDownloadContentCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateDownloadContentCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateDownloadContentCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateDownloadContentCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateDownloadContentCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IUpdateDownloadContentCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContent **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IUpdateDownloadContentCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IUpdateDownloadContentCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IUpdateDownloadContentCollectionVtbl;

    interface IUpdateDownloadContentCollection
    {
        CONST_VTBL struct IUpdateDownloadContentCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateDownloadContentCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateDownloadContentCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateDownloadContentCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateDownloadContentCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateDownloadContentCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateDownloadContentCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateDownloadContentCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateDownloadContentCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define IUpdateDownloadContentCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IUpdateDownloadContentCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateDownloadContentCollection_INTERFACE_DEFINED__ */


#ifndef __IUpdate_INTERFACE_DEFINED__
#define __IUpdate_INTERFACE_DEFINED__

/* interface IUpdate */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6a92b07a-d821-4682-b423-5c805022cc4d")
    IUpdate : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoSelectOnWebSites( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BundledUpdates( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanRequireSource( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Categories( 
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Deadline( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DeltaCompressedContentAvailable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DeltaCompressedContentPreferred( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EulaAccepted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EulaText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HandlerID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Identity( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InstallationBehavior( 
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsBeta( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDownloaded( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsHidden( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsHidden( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsInstalled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsMandatory( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsUninstallable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Languages( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LastDeploymentChangeTime( 
            /* [retval][out] */ __RPC__out DATE *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MaxDownloadSize( 
            /* [retval][out] */ __RPC__out DECIMAL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MinDownloadSize( 
            /* [retval][out] */ __RPC__out DECIMAL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MoreInfoUrls( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MsrcSeverity( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecommendedCpuSpeed( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecommendedHardDiskSpace( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecommendedMemory( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReleaseNotes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SecurityBulletinIDs( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SupersededUpdateIDs( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SupportUrl( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out UpdateType *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UninstallationNotes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UninstallationBehavior( 
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UninstallationSteps( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_KBArticleIDs( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptEula( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DeploymentAction( 
            /* [retval][out] */ __RPC__out DeploymentAction *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyFromCache( 
            /* [ref][in] */ __RPC__in BSTR path,
            /* [in] */ VARIANT_BOOL toExtractCabFiles) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DownloadPriority( 
            /* [retval][out] */ __RPC__out DownloadPriority *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DownloadContents( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContentCollection **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdate * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSelectOnWebSites )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BundledUpdates )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRequireSource )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Categories )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Deadline )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentAvailable )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentPreferred )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaAccepted )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaText )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HandlerID )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InstallationBehavior )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBeta )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDownloaded )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            IUpdate * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsInstalled )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsMandatory )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsUninstallable )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Languages )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastDeploymentChangeTime )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaxDownloadSize )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinDownloadSize )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoUrls )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MsrcSeverity )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedCpuSpeed )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedHardDiskSpace )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedMemory )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReleaseNotes )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityBulletinIDs )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupersededUpdateIDs )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out UpdateType *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationBehavior )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_KBArticleIDs )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptEula )( 
            IUpdate * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeploymentAction )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out DeploymentAction *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyFromCache )( 
            IUpdate * This,
            /* [ref][in] */ __RPC__in BSTR path,
            /* [in] */ VARIANT_BOOL toExtractCabFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadPriority )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__out DownloadPriority *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadContents )( 
            IUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContentCollection **retval);
        
        END_INTERFACE
    } IUpdateVtbl;

    interface IUpdate
    {
        CONST_VTBL struct IUpdateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdate_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdate_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IUpdate_get_AutoSelectOnWebSites(This,retval)	\
    ( (This)->lpVtbl -> get_AutoSelectOnWebSites(This,retval) ) 

#define IUpdate_get_BundledUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_BundledUpdates(This,retval) ) 

#define IUpdate_get_CanRequireSource(This,retval)	\
    ( (This)->lpVtbl -> get_CanRequireSource(This,retval) ) 

#define IUpdate_get_Categories(This,retval)	\
    ( (This)->lpVtbl -> get_Categories(This,retval) ) 

#define IUpdate_get_Deadline(This,retval)	\
    ( (This)->lpVtbl -> get_Deadline(This,retval) ) 

#define IUpdate_get_DeltaCompressedContentAvailable(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentAvailable(This,retval) ) 

#define IUpdate_get_DeltaCompressedContentPreferred(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentPreferred(This,retval) ) 

#define IUpdate_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IUpdate_get_EulaAccepted(This,retval)	\
    ( (This)->lpVtbl -> get_EulaAccepted(This,retval) ) 

#define IUpdate_get_EulaText(This,retval)	\
    ( (This)->lpVtbl -> get_EulaText(This,retval) ) 

#define IUpdate_get_HandlerID(This,retval)	\
    ( (This)->lpVtbl -> get_HandlerID(This,retval) ) 

#define IUpdate_get_Identity(This,retval)	\
    ( (This)->lpVtbl -> get_Identity(This,retval) ) 

#define IUpdate_get_Image(This,retval)	\
    ( (This)->lpVtbl -> get_Image(This,retval) ) 

#define IUpdate_get_InstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_InstallationBehavior(This,retval) ) 

#define IUpdate_get_IsBeta(This,retval)	\
    ( (This)->lpVtbl -> get_IsBeta(This,retval) ) 

#define IUpdate_get_IsDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_IsDownloaded(This,retval) ) 

#define IUpdate_get_IsHidden(This,retval)	\
    ( (This)->lpVtbl -> get_IsHidden(This,retval) ) 

#define IUpdate_put_IsHidden(This,value)	\
    ( (This)->lpVtbl -> put_IsHidden(This,value) ) 

#define IUpdate_get_IsInstalled(This,retval)	\
    ( (This)->lpVtbl -> get_IsInstalled(This,retval) ) 

#define IUpdate_get_IsMandatory(This,retval)	\
    ( (This)->lpVtbl -> get_IsMandatory(This,retval) ) 

#define IUpdate_get_IsUninstallable(This,retval)	\
    ( (This)->lpVtbl -> get_IsUninstallable(This,retval) ) 

#define IUpdate_get_Languages(This,retval)	\
    ( (This)->lpVtbl -> get_Languages(This,retval) ) 

#define IUpdate_get_LastDeploymentChangeTime(This,retval)	\
    ( (This)->lpVtbl -> get_LastDeploymentChangeTime(This,retval) ) 

#define IUpdate_get_MaxDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MaxDownloadSize(This,retval) ) 

#define IUpdate_get_MinDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MinDownloadSize(This,retval) ) 

#define IUpdate_get_MoreInfoUrls(This,retval)	\
    ( (This)->lpVtbl -> get_MoreInfoUrls(This,retval) ) 

#define IUpdate_get_MsrcSeverity(This,retval)	\
    ( (This)->lpVtbl -> get_MsrcSeverity(This,retval) ) 

#define IUpdate_get_RecommendedCpuSpeed(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedCpuSpeed(This,retval) ) 

#define IUpdate_get_RecommendedHardDiskSpace(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedHardDiskSpace(This,retval) ) 

#define IUpdate_get_RecommendedMemory(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedMemory(This,retval) ) 

#define IUpdate_get_ReleaseNotes(This,retval)	\
    ( (This)->lpVtbl -> get_ReleaseNotes(This,retval) ) 

#define IUpdate_get_SecurityBulletinIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SecurityBulletinIDs(This,retval) ) 

#define IUpdate_get_SupersededUpdateIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SupersededUpdateIDs(This,retval) ) 

#define IUpdate_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 

#define IUpdate_get_Type(This,retval)	\
    ( (This)->lpVtbl -> get_Type(This,retval) ) 

#define IUpdate_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IUpdate_get_UninstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationBehavior(This,retval) ) 

#define IUpdate_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IUpdate_get_KBArticleIDs(This,retval)	\
    ( (This)->lpVtbl -> get_KBArticleIDs(This,retval) ) 

#define IUpdate_AcceptEula(This)	\
    ( (This)->lpVtbl -> AcceptEula(This) ) 

#define IUpdate_get_DeploymentAction(This,retval)	\
    ( (This)->lpVtbl -> get_DeploymentAction(This,retval) ) 

#define IUpdate_CopyFromCache(This,path,toExtractCabFiles)	\
    ( (This)->lpVtbl -> CopyFromCache(This,path,toExtractCabFiles) ) 

#define IUpdate_get_DownloadPriority(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadPriority(This,retval) ) 

#define IUpdate_get_DownloadContents(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadContents(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdate_INTERFACE_DEFINED__ */


#ifndef __IWindowsDriverUpdate_INTERFACE_DEFINED__
#define __IWindowsDriverUpdate_INTERFACE_DEFINED__

/* interface IWindowsDriverUpdate */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IWindowsDriverUpdate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b383cd1a-5ce9-4504-9f63-764b1236f191")
    IWindowsDriverUpdate : public IUpdate
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DriverClass( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DriverHardwareID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DriverManufacturer( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DriverModel( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DriverProvider( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DriverVerDate( 
            /* [retval][out] */ __RPC__out DATE *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DeviceProblemNumber( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DeviceStatus( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowsDriverUpdateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowsDriverUpdate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowsDriverUpdate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowsDriverUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWindowsDriverUpdate * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWindowsDriverUpdate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWindowsDriverUpdate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWindowsDriverUpdate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSelectOnWebSites )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BundledUpdates )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRequireSource )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Categories )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Deadline )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentAvailable )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentPreferred )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaAccepted )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaText )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HandlerID )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InstallationBehavior )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBeta )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDownloaded )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            IWindowsDriverUpdate * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsInstalled )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsMandatory )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsUninstallable )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Languages )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastDeploymentChangeTime )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaxDownloadSize )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinDownloadSize )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoUrls )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MsrcSeverity )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedCpuSpeed )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedHardDiskSpace )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedMemory )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReleaseNotes )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityBulletinIDs )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupersededUpdateIDs )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out UpdateType *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationBehavior )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_KBArticleIDs )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptEula )( 
            IWindowsDriverUpdate * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeploymentAction )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out DeploymentAction *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyFromCache )( 
            IWindowsDriverUpdate * This,
            /* [ref][in] */ __RPC__in BSTR path,
            /* [in] */ VARIANT_BOOL toExtractCabFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadPriority )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out DownloadPriority *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadContents )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContentCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverClass )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverHardwareID )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverManufacturer )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverModel )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverProvider )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverVerDate )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceProblemNumber )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceStatus )( 
            IWindowsDriverUpdate * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IWindowsDriverUpdateVtbl;

    interface IWindowsDriverUpdate
    {
        CONST_VTBL struct IWindowsDriverUpdateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowsDriverUpdate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowsDriverUpdate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowsDriverUpdate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowsDriverUpdate_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWindowsDriverUpdate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWindowsDriverUpdate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWindowsDriverUpdate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWindowsDriverUpdate_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IWindowsDriverUpdate_get_AutoSelectOnWebSites(This,retval)	\
    ( (This)->lpVtbl -> get_AutoSelectOnWebSites(This,retval) ) 

#define IWindowsDriverUpdate_get_BundledUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_BundledUpdates(This,retval) ) 

#define IWindowsDriverUpdate_get_CanRequireSource(This,retval)	\
    ( (This)->lpVtbl -> get_CanRequireSource(This,retval) ) 

#define IWindowsDriverUpdate_get_Categories(This,retval)	\
    ( (This)->lpVtbl -> get_Categories(This,retval) ) 

#define IWindowsDriverUpdate_get_Deadline(This,retval)	\
    ( (This)->lpVtbl -> get_Deadline(This,retval) ) 

#define IWindowsDriverUpdate_get_DeltaCompressedContentAvailable(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentAvailable(This,retval) ) 

#define IWindowsDriverUpdate_get_DeltaCompressedContentPreferred(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentPreferred(This,retval) ) 

#define IWindowsDriverUpdate_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IWindowsDriverUpdate_get_EulaAccepted(This,retval)	\
    ( (This)->lpVtbl -> get_EulaAccepted(This,retval) ) 

#define IWindowsDriverUpdate_get_EulaText(This,retval)	\
    ( (This)->lpVtbl -> get_EulaText(This,retval) ) 

#define IWindowsDriverUpdate_get_HandlerID(This,retval)	\
    ( (This)->lpVtbl -> get_HandlerID(This,retval) ) 

#define IWindowsDriverUpdate_get_Identity(This,retval)	\
    ( (This)->lpVtbl -> get_Identity(This,retval) ) 

#define IWindowsDriverUpdate_get_Image(This,retval)	\
    ( (This)->lpVtbl -> get_Image(This,retval) ) 

#define IWindowsDriverUpdate_get_InstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_InstallationBehavior(This,retval) ) 

#define IWindowsDriverUpdate_get_IsBeta(This,retval)	\
    ( (This)->lpVtbl -> get_IsBeta(This,retval) ) 

#define IWindowsDriverUpdate_get_IsDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_IsDownloaded(This,retval) ) 

#define IWindowsDriverUpdate_get_IsHidden(This,retval)	\
    ( (This)->lpVtbl -> get_IsHidden(This,retval) ) 

#define IWindowsDriverUpdate_put_IsHidden(This,value)	\
    ( (This)->lpVtbl -> put_IsHidden(This,value) ) 

#define IWindowsDriverUpdate_get_IsInstalled(This,retval)	\
    ( (This)->lpVtbl -> get_IsInstalled(This,retval) ) 

#define IWindowsDriverUpdate_get_IsMandatory(This,retval)	\
    ( (This)->lpVtbl -> get_IsMandatory(This,retval) ) 

#define IWindowsDriverUpdate_get_IsUninstallable(This,retval)	\
    ( (This)->lpVtbl -> get_IsUninstallable(This,retval) ) 

#define IWindowsDriverUpdate_get_Languages(This,retval)	\
    ( (This)->lpVtbl -> get_Languages(This,retval) ) 

#define IWindowsDriverUpdate_get_LastDeploymentChangeTime(This,retval)	\
    ( (This)->lpVtbl -> get_LastDeploymentChangeTime(This,retval) ) 

#define IWindowsDriverUpdate_get_MaxDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MaxDownloadSize(This,retval) ) 

#define IWindowsDriverUpdate_get_MinDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MinDownloadSize(This,retval) ) 

#define IWindowsDriverUpdate_get_MoreInfoUrls(This,retval)	\
    ( (This)->lpVtbl -> get_MoreInfoUrls(This,retval) ) 

#define IWindowsDriverUpdate_get_MsrcSeverity(This,retval)	\
    ( (This)->lpVtbl -> get_MsrcSeverity(This,retval) ) 

#define IWindowsDriverUpdate_get_RecommendedCpuSpeed(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedCpuSpeed(This,retval) ) 

#define IWindowsDriverUpdate_get_RecommendedHardDiskSpace(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedHardDiskSpace(This,retval) ) 

#define IWindowsDriverUpdate_get_RecommendedMemory(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedMemory(This,retval) ) 

#define IWindowsDriverUpdate_get_ReleaseNotes(This,retval)	\
    ( (This)->lpVtbl -> get_ReleaseNotes(This,retval) ) 

#define IWindowsDriverUpdate_get_SecurityBulletinIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SecurityBulletinIDs(This,retval) ) 

#define IWindowsDriverUpdate_get_SupersededUpdateIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SupersededUpdateIDs(This,retval) ) 

#define IWindowsDriverUpdate_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 

#define IWindowsDriverUpdate_get_Type(This,retval)	\
    ( (This)->lpVtbl -> get_Type(This,retval) ) 

#define IWindowsDriverUpdate_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IWindowsDriverUpdate_get_UninstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationBehavior(This,retval) ) 

#define IWindowsDriverUpdate_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IWindowsDriverUpdate_get_KBArticleIDs(This,retval)	\
    ( (This)->lpVtbl -> get_KBArticleIDs(This,retval) ) 

#define IWindowsDriverUpdate_AcceptEula(This)	\
    ( (This)->lpVtbl -> AcceptEula(This) ) 

#define IWindowsDriverUpdate_get_DeploymentAction(This,retval)	\
    ( (This)->lpVtbl -> get_DeploymentAction(This,retval) ) 

#define IWindowsDriverUpdate_CopyFromCache(This,path,toExtractCabFiles)	\
    ( (This)->lpVtbl -> CopyFromCache(This,path,toExtractCabFiles) ) 

#define IWindowsDriverUpdate_get_DownloadPriority(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadPriority(This,retval) ) 

#define IWindowsDriverUpdate_get_DownloadContents(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadContents(This,retval) ) 


#define IWindowsDriverUpdate_get_DriverClass(This,retval)	\
    ( (This)->lpVtbl -> get_DriverClass(This,retval) ) 

#define IWindowsDriverUpdate_get_DriverHardwareID(This,retval)	\
    ( (This)->lpVtbl -> get_DriverHardwareID(This,retval) ) 

#define IWindowsDriverUpdate_get_DriverManufacturer(This,retval)	\
    ( (This)->lpVtbl -> get_DriverManufacturer(This,retval) ) 

#define IWindowsDriverUpdate_get_DriverModel(This,retval)	\
    ( (This)->lpVtbl -> get_DriverModel(This,retval) ) 

#define IWindowsDriverUpdate_get_DriverProvider(This,retval)	\
    ( (This)->lpVtbl -> get_DriverProvider(This,retval) ) 

#define IWindowsDriverUpdate_get_DriverVerDate(This,retval)	\
    ( (This)->lpVtbl -> get_DriverVerDate(This,retval) ) 

#define IWindowsDriverUpdate_get_DeviceProblemNumber(This,retval)	\
    ( (This)->lpVtbl -> get_DeviceProblemNumber(This,retval) ) 

#define IWindowsDriverUpdate_get_DeviceStatus(This,retval)	\
    ( (This)->lpVtbl -> get_DeviceStatus(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowsDriverUpdate_INTERFACE_DEFINED__ */


#ifndef __IUpdate2_INTERFACE_DEFINED__
#define __IUpdate2_INTERFACE_DEFINED__

/* interface IUpdate2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdate2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("144fe9b0-d23d-4a8b-8634-fb4457533b7a")
    IUpdate2 : public IUpdate
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RebootRequired( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsPresent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CveIDs( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyToCache( 
            /* [in] */ __RPC__in_opt IStringCollection *pFiles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdate2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdate2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdate2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdate2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdate2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdate2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdate2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdate2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSelectOnWebSites )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BundledUpdates )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRequireSource )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Categories )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Deadline )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentAvailable )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentPreferred )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaAccepted )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaText )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HandlerID )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InstallationBehavior )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBeta )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDownloaded )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            IUpdate2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsInstalled )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsMandatory )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsUninstallable )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Languages )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastDeploymentChangeTime )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaxDownloadSize )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinDownloadSize )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoUrls )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MsrcSeverity )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedCpuSpeed )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedHardDiskSpace )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedMemory )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReleaseNotes )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityBulletinIDs )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupersededUpdateIDs )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out UpdateType *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationBehavior )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_KBArticleIDs )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptEula )( 
            IUpdate2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeploymentAction )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out DeploymentAction *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyFromCache )( 
            IUpdate2 * This,
            /* [ref][in] */ __RPC__in BSTR path,
            /* [in] */ VARIANT_BOOL toExtractCabFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadPriority )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out DownloadPriority *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadContents )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContentCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequired )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CveIDs )( 
            IUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyToCache )( 
            IUpdate2 * This,
            /* [in] */ __RPC__in_opt IStringCollection *pFiles);
        
        END_INTERFACE
    } IUpdate2Vtbl;

    interface IUpdate2
    {
        CONST_VTBL struct IUpdate2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdate2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdate2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdate2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdate2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdate2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdate2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdate2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdate2_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IUpdate2_get_AutoSelectOnWebSites(This,retval)	\
    ( (This)->lpVtbl -> get_AutoSelectOnWebSites(This,retval) ) 

#define IUpdate2_get_BundledUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_BundledUpdates(This,retval) ) 

#define IUpdate2_get_CanRequireSource(This,retval)	\
    ( (This)->lpVtbl -> get_CanRequireSource(This,retval) ) 

#define IUpdate2_get_Categories(This,retval)	\
    ( (This)->lpVtbl -> get_Categories(This,retval) ) 

#define IUpdate2_get_Deadline(This,retval)	\
    ( (This)->lpVtbl -> get_Deadline(This,retval) ) 

#define IUpdate2_get_DeltaCompressedContentAvailable(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentAvailable(This,retval) ) 

#define IUpdate2_get_DeltaCompressedContentPreferred(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentPreferred(This,retval) ) 

#define IUpdate2_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IUpdate2_get_EulaAccepted(This,retval)	\
    ( (This)->lpVtbl -> get_EulaAccepted(This,retval) ) 

#define IUpdate2_get_EulaText(This,retval)	\
    ( (This)->lpVtbl -> get_EulaText(This,retval) ) 

#define IUpdate2_get_HandlerID(This,retval)	\
    ( (This)->lpVtbl -> get_HandlerID(This,retval) ) 

#define IUpdate2_get_Identity(This,retval)	\
    ( (This)->lpVtbl -> get_Identity(This,retval) ) 

#define IUpdate2_get_Image(This,retval)	\
    ( (This)->lpVtbl -> get_Image(This,retval) ) 

#define IUpdate2_get_InstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_InstallationBehavior(This,retval) ) 

#define IUpdate2_get_IsBeta(This,retval)	\
    ( (This)->lpVtbl -> get_IsBeta(This,retval) ) 

#define IUpdate2_get_IsDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_IsDownloaded(This,retval) ) 

#define IUpdate2_get_IsHidden(This,retval)	\
    ( (This)->lpVtbl -> get_IsHidden(This,retval) ) 

#define IUpdate2_put_IsHidden(This,value)	\
    ( (This)->lpVtbl -> put_IsHidden(This,value) ) 

#define IUpdate2_get_IsInstalled(This,retval)	\
    ( (This)->lpVtbl -> get_IsInstalled(This,retval) ) 

#define IUpdate2_get_IsMandatory(This,retval)	\
    ( (This)->lpVtbl -> get_IsMandatory(This,retval) ) 

#define IUpdate2_get_IsUninstallable(This,retval)	\
    ( (This)->lpVtbl -> get_IsUninstallable(This,retval) ) 

#define IUpdate2_get_Languages(This,retval)	\
    ( (This)->lpVtbl -> get_Languages(This,retval) ) 

#define IUpdate2_get_LastDeploymentChangeTime(This,retval)	\
    ( (This)->lpVtbl -> get_LastDeploymentChangeTime(This,retval) ) 

#define IUpdate2_get_MaxDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MaxDownloadSize(This,retval) ) 

#define IUpdate2_get_MinDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MinDownloadSize(This,retval) ) 

#define IUpdate2_get_MoreInfoUrls(This,retval)	\
    ( (This)->lpVtbl -> get_MoreInfoUrls(This,retval) ) 

#define IUpdate2_get_MsrcSeverity(This,retval)	\
    ( (This)->lpVtbl -> get_MsrcSeverity(This,retval) ) 

#define IUpdate2_get_RecommendedCpuSpeed(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedCpuSpeed(This,retval) ) 

#define IUpdate2_get_RecommendedHardDiskSpace(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedHardDiskSpace(This,retval) ) 

#define IUpdate2_get_RecommendedMemory(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedMemory(This,retval) ) 

#define IUpdate2_get_ReleaseNotes(This,retval)	\
    ( (This)->lpVtbl -> get_ReleaseNotes(This,retval) ) 

#define IUpdate2_get_SecurityBulletinIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SecurityBulletinIDs(This,retval) ) 

#define IUpdate2_get_SupersededUpdateIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SupersededUpdateIDs(This,retval) ) 

#define IUpdate2_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 

#define IUpdate2_get_Type(This,retval)	\
    ( (This)->lpVtbl -> get_Type(This,retval) ) 

#define IUpdate2_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IUpdate2_get_UninstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationBehavior(This,retval) ) 

#define IUpdate2_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IUpdate2_get_KBArticleIDs(This,retval)	\
    ( (This)->lpVtbl -> get_KBArticleIDs(This,retval) ) 

#define IUpdate2_AcceptEula(This)	\
    ( (This)->lpVtbl -> AcceptEula(This) ) 

#define IUpdate2_get_DeploymentAction(This,retval)	\
    ( (This)->lpVtbl -> get_DeploymentAction(This,retval) ) 

#define IUpdate2_CopyFromCache(This,path,toExtractCabFiles)	\
    ( (This)->lpVtbl -> CopyFromCache(This,path,toExtractCabFiles) ) 

#define IUpdate2_get_DownloadPriority(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadPriority(This,retval) ) 

#define IUpdate2_get_DownloadContents(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadContents(This,retval) ) 


#define IUpdate2_get_RebootRequired(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequired(This,retval) ) 

#define IUpdate2_get_IsPresent(This,retval)	\
    ( (This)->lpVtbl -> get_IsPresent(This,retval) ) 

#define IUpdate2_get_CveIDs(This,retval)	\
    ( (This)->lpVtbl -> get_CveIDs(This,retval) ) 

#define IUpdate2_CopyToCache(This,pFiles)	\
    ( (This)->lpVtbl -> CopyToCache(This,pFiles) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdate2_INTERFACE_DEFINED__ */


#ifndef __IUpdate3_INTERFACE_DEFINED__
#define __IUpdate3_INTERFACE_DEFINED__

/* interface IUpdate3 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdate3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("112EDA6B-95B3-476F-9D90-AEE82C6B8181")
    IUpdate3 : public IUpdate2
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BrowseOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdate3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdate3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdate3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdate3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdate3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdate3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdate3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdate3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSelectOnWebSites )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BundledUpdates )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRequireSource )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Categories )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Deadline )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentAvailable )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentPreferred )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaAccepted )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaText )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HandlerID )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InstallationBehavior )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBeta )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDownloaded )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            IUpdate3 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsInstalled )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsMandatory )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsUninstallable )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Languages )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastDeploymentChangeTime )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaxDownloadSize )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinDownloadSize )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoUrls )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MsrcSeverity )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedCpuSpeed )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedHardDiskSpace )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedMemory )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReleaseNotes )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityBulletinIDs )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupersededUpdateIDs )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out UpdateType *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationBehavior )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_KBArticleIDs )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptEula )( 
            IUpdate3 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeploymentAction )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out DeploymentAction *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyFromCache )( 
            IUpdate3 * This,
            /* [ref][in] */ __RPC__in BSTR path,
            /* [in] */ VARIANT_BOOL toExtractCabFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadPriority )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out DownloadPriority *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadContents )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContentCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequired )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CveIDs )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyToCache )( 
            IUpdate3 * This,
            /* [in] */ __RPC__in_opt IStringCollection *pFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BrowseOnly )( 
            IUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IUpdate3Vtbl;

    interface IUpdate3
    {
        CONST_VTBL struct IUpdate3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdate3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdate3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdate3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdate3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdate3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdate3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdate3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdate3_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IUpdate3_get_AutoSelectOnWebSites(This,retval)	\
    ( (This)->lpVtbl -> get_AutoSelectOnWebSites(This,retval) ) 

#define IUpdate3_get_BundledUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_BundledUpdates(This,retval) ) 

#define IUpdate3_get_CanRequireSource(This,retval)	\
    ( (This)->lpVtbl -> get_CanRequireSource(This,retval) ) 

#define IUpdate3_get_Categories(This,retval)	\
    ( (This)->lpVtbl -> get_Categories(This,retval) ) 

#define IUpdate3_get_Deadline(This,retval)	\
    ( (This)->lpVtbl -> get_Deadline(This,retval) ) 

#define IUpdate3_get_DeltaCompressedContentAvailable(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentAvailable(This,retval) ) 

#define IUpdate3_get_DeltaCompressedContentPreferred(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentPreferred(This,retval) ) 

#define IUpdate3_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IUpdate3_get_EulaAccepted(This,retval)	\
    ( (This)->lpVtbl -> get_EulaAccepted(This,retval) ) 

#define IUpdate3_get_EulaText(This,retval)	\
    ( (This)->lpVtbl -> get_EulaText(This,retval) ) 

#define IUpdate3_get_HandlerID(This,retval)	\
    ( (This)->lpVtbl -> get_HandlerID(This,retval) ) 

#define IUpdate3_get_Identity(This,retval)	\
    ( (This)->lpVtbl -> get_Identity(This,retval) ) 

#define IUpdate3_get_Image(This,retval)	\
    ( (This)->lpVtbl -> get_Image(This,retval) ) 

#define IUpdate3_get_InstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_InstallationBehavior(This,retval) ) 

#define IUpdate3_get_IsBeta(This,retval)	\
    ( (This)->lpVtbl -> get_IsBeta(This,retval) ) 

#define IUpdate3_get_IsDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_IsDownloaded(This,retval) ) 

#define IUpdate3_get_IsHidden(This,retval)	\
    ( (This)->lpVtbl -> get_IsHidden(This,retval) ) 

#define IUpdate3_put_IsHidden(This,value)	\
    ( (This)->lpVtbl -> put_IsHidden(This,value) ) 

#define IUpdate3_get_IsInstalled(This,retval)	\
    ( (This)->lpVtbl -> get_IsInstalled(This,retval) ) 

#define IUpdate3_get_IsMandatory(This,retval)	\
    ( (This)->lpVtbl -> get_IsMandatory(This,retval) ) 

#define IUpdate3_get_IsUninstallable(This,retval)	\
    ( (This)->lpVtbl -> get_IsUninstallable(This,retval) ) 

#define IUpdate3_get_Languages(This,retval)	\
    ( (This)->lpVtbl -> get_Languages(This,retval) ) 

#define IUpdate3_get_LastDeploymentChangeTime(This,retval)	\
    ( (This)->lpVtbl -> get_LastDeploymentChangeTime(This,retval) ) 

#define IUpdate3_get_MaxDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MaxDownloadSize(This,retval) ) 

#define IUpdate3_get_MinDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MinDownloadSize(This,retval) ) 

#define IUpdate3_get_MoreInfoUrls(This,retval)	\
    ( (This)->lpVtbl -> get_MoreInfoUrls(This,retval) ) 

#define IUpdate3_get_MsrcSeverity(This,retval)	\
    ( (This)->lpVtbl -> get_MsrcSeverity(This,retval) ) 

#define IUpdate3_get_RecommendedCpuSpeed(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedCpuSpeed(This,retval) ) 

#define IUpdate3_get_RecommendedHardDiskSpace(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedHardDiskSpace(This,retval) ) 

#define IUpdate3_get_RecommendedMemory(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedMemory(This,retval) ) 

#define IUpdate3_get_ReleaseNotes(This,retval)	\
    ( (This)->lpVtbl -> get_ReleaseNotes(This,retval) ) 

#define IUpdate3_get_SecurityBulletinIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SecurityBulletinIDs(This,retval) ) 

#define IUpdate3_get_SupersededUpdateIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SupersededUpdateIDs(This,retval) ) 

#define IUpdate3_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 

#define IUpdate3_get_Type(This,retval)	\
    ( (This)->lpVtbl -> get_Type(This,retval) ) 

#define IUpdate3_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IUpdate3_get_UninstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationBehavior(This,retval) ) 

#define IUpdate3_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IUpdate3_get_KBArticleIDs(This,retval)	\
    ( (This)->lpVtbl -> get_KBArticleIDs(This,retval) ) 

#define IUpdate3_AcceptEula(This)	\
    ( (This)->lpVtbl -> AcceptEula(This) ) 

#define IUpdate3_get_DeploymentAction(This,retval)	\
    ( (This)->lpVtbl -> get_DeploymentAction(This,retval) ) 

#define IUpdate3_CopyFromCache(This,path,toExtractCabFiles)	\
    ( (This)->lpVtbl -> CopyFromCache(This,path,toExtractCabFiles) ) 

#define IUpdate3_get_DownloadPriority(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadPriority(This,retval) ) 

#define IUpdate3_get_DownloadContents(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadContents(This,retval) ) 


#define IUpdate3_get_RebootRequired(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequired(This,retval) ) 

#define IUpdate3_get_IsPresent(This,retval)	\
    ( (This)->lpVtbl -> get_IsPresent(This,retval) ) 

#define IUpdate3_get_CveIDs(This,retval)	\
    ( (This)->lpVtbl -> get_CveIDs(This,retval) ) 

#define IUpdate3_CopyToCache(This,pFiles)	\
    ( (This)->lpVtbl -> CopyToCache(This,pFiles) ) 


#define IUpdate3_get_BrowseOnly(This,retval)	\
    ( (This)->lpVtbl -> get_BrowseOnly(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdate3_INTERFACE_DEFINED__ */


#ifndef __IWindowsDriverUpdate2_INTERFACE_DEFINED__
#define __IWindowsDriverUpdate2_INTERFACE_DEFINED__

/* interface IWindowsDriverUpdate2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IWindowsDriverUpdate2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("615c4269-7a48-43bd-96b7-bf6ca27d6c3e")
    IWindowsDriverUpdate2 : public IWindowsDriverUpdate
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RebootRequired( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsPresent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CveIDs( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyToCache( 
            /* [in] */ __RPC__in_opt IStringCollection *pFiles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowsDriverUpdate2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowsDriverUpdate2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowsDriverUpdate2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowsDriverUpdate2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWindowsDriverUpdate2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWindowsDriverUpdate2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWindowsDriverUpdate2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWindowsDriverUpdate2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSelectOnWebSites )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BundledUpdates )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRequireSource )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Categories )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Deadline )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentAvailable )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentPreferred )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaAccepted )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaText )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HandlerID )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InstallationBehavior )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBeta )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDownloaded )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            IWindowsDriverUpdate2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsInstalled )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsMandatory )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsUninstallable )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Languages )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastDeploymentChangeTime )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaxDownloadSize )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinDownloadSize )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoUrls )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MsrcSeverity )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedCpuSpeed )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedHardDiskSpace )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedMemory )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReleaseNotes )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityBulletinIDs )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupersededUpdateIDs )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out UpdateType *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationBehavior )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_KBArticleIDs )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptEula )( 
            IWindowsDriverUpdate2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeploymentAction )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out DeploymentAction *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyFromCache )( 
            IWindowsDriverUpdate2 * This,
            /* [ref][in] */ __RPC__in BSTR path,
            /* [in] */ VARIANT_BOOL toExtractCabFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadPriority )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out DownloadPriority *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadContents )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContentCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverClass )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverHardwareID )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverManufacturer )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverModel )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverProvider )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverVerDate )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceProblemNumber )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceStatus )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequired )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CveIDs )( 
            IWindowsDriverUpdate2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyToCache )( 
            IWindowsDriverUpdate2 * This,
            /* [in] */ __RPC__in_opt IStringCollection *pFiles);
        
        END_INTERFACE
    } IWindowsDriverUpdate2Vtbl;

    interface IWindowsDriverUpdate2
    {
        CONST_VTBL struct IWindowsDriverUpdate2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowsDriverUpdate2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowsDriverUpdate2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowsDriverUpdate2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowsDriverUpdate2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWindowsDriverUpdate2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWindowsDriverUpdate2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWindowsDriverUpdate2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWindowsDriverUpdate2_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IWindowsDriverUpdate2_get_AutoSelectOnWebSites(This,retval)	\
    ( (This)->lpVtbl -> get_AutoSelectOnWebSites(This,retval) ) 

#define IWindowsDriverUpdate2_get_BundledUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_BundledUpdates(This,retval) ) 

#define IWindowsDriverUpdate2_get_CanRequireSource(This,retval)	\
    ( (This)->lpVtbl -> get_CanRequireSource(This,retval) ) 

#define IWindowsDriverUpdate2_get_Categories(This,retval)	\
    ( (This)->lpVtbl -> get_Categories(This,retval) ) 

#define IWindowsDriverUpdate2_get_Deadline(This,retval)	\
    ( (This)->lpVtbl -> get_Deadline(This,retval) ) 

#define IWindowsDriverUpdate2_get_DeltaCompressedContentAvailable(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentAvailable(This,retval) ) 

#define IWindowsDriverUpdate2_get_DeltaCompressedContentPreferred(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentPreferred(This,retval) ) 

#define IWindowsDriverUpdate2_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IWindowsDriverUpdate2_get_EulaAccepted(This,retval)	\
    ( (This)->lpVtbl -> get_EulaAccepted(This,retval) ) 

#define IWindowsDriverUpdate2_get_EulaText(This,retval)	\
    ( (This)->lpVtbl -> get_EulaText(This,retval) ) 

#define IWindowsDriverUpdate2_get_HandlerID(This,retval)	\
    ( (This)->lpVtbl -> get_HandlerID(This,retval) ) 

#define IWindowsDriverUpdate2_get_Identity(This,retval)	\
    ( (This)->lpVtbl -> get_Identity(This,retval) ) 

#define IWindowsDriverUpdate2_get_Image(This,retval)	\
    ( (This)->lpVtbl -> get_Image(This,retval) ) 

#define IWindowsDriverUpdate2_get_InstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_InstallationBehavior(This,retval) ) 

#define IWindowsDriverUpdate2_get_IsBeta(This,retval)	\
    ( (This)->lpVtbl -> get_IsBeta(This,retval) ) 

#define IWindowsDriverUpdate2_get_IsDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_IsDownloaded(This,retval) ) 

#define IWindowsDriverUpdate2_get_IsHidden(This,retval)	\
    ( (This)->lpVtbl -> get_IsHidden(This,retval) ) 

#define IWindowsDriverUpdate2_put_IsHidden(This,value)	\
    ( (This)->lpVtbl -> put_IsHidden(This,value) ) 

#define IWindowsDriverUpdate2_get_IsInstalled(This,retval)	\
    ( (This)->lpVtbl -> get_IsInstalled(This,retval) ) 

#define IWindowsDriverUpdate2_get_IsMandatory(This,retval)	\
    ( (This)->lpVtbl -> get_IsMandatory(This,retval) ) 

#define IWindowsDriverUpdate2_get_IsUninstallable(This,retval)	\
    ( (This)->lpVtbl -> get_IsUninstallable(This,retval) ) 

#define IWindowsDriverUpdate2_get_Languages(This,retval)	\
    ( (This)->lpVtbl -> get_Languages(This,retval) ) 

#define IWindowsDriverUpdate2_get_LastDeploymentChangeTime(This,retval)	\
    ( (This)->lpVtbl -> get_LastDeploymentChangeTime(This,retval) ) 

#define IWindowsDriverUpdate2_get_MaxDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MaxDownloadSize(This,retval) ) 

#define IWindowsDriverUpdate2_get_MinDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MinDownloadSize(This,retval) ) 

#define IWindowsDriverUpdate2_get_MoreInfoUrls(This,retval)	\
    ( (This)->lpVtbl -> get_MoreInfoUrls(This,retval) ) 

#define IWindowsDriverUpdate2_get_MsrcSeverity(This,retval)	\
    ( (This)->lpVtbl -> get_MsrcSeverity(This,retval) ) 

#define IWindowsDriverUpdate2_get_RecommendedCpuSpeed(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedCpuSpeed(This,retval) ) 

#define IWindowsDriverUpdate2_get_RecommendedHardDiskSpace(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedHardDiskSpace(This,retval) ) 

#define IWindowsDriverUpdate2_get_RecommendedMemory(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedMemory(This,retval) ) 

#define IWindowsDriverUpdate2_get_ReleaseNotes(This,retval)	\
    ( (This)->lpVtbl -> get_ReleaseNotes(This,retval) ) 

#define IWindowsDriverUpdate2_get_SecurityBulletinIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SecurityBulletinIDs(This,retval) ) 

#define IWindowsDriverUpdate2_get_SupersededUpdateIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SupersededUpdateIDs(This,retval) ) 

#define IWindowsDriverUpdate2_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 

#define IWindowsDriverUpdate2_get_Type(This,retval)	\
    ( (This)->lpVtbl -> get_Type(This,retval) ) 

#define IWindowsDriverUpdate2_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IWindowsDriverUpdate2_get_UninstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationBehavior(This,retval) ) 

#define IWindowsDriverUpdate2_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IWindowsDriverUpdate2_get_KBArticleIDs(This,retval)	\
    ( (This)->lpVtbl -> get_KBArticleIDs(This,retval) ) 

#define IWindowsDriverUpdate2_AcceptEula(This)	\
    ( (This)->lpVtbl -> AcceptEula(This) ) 

#define IWindowsDriverUpdate2_get_DeploymentAction(This,retval)	\
    ( (This)->lpVtbl -> get_DeploymentAction(This,retval) ) 

#define IWindowsDriverUpdate2_CopyFromCache(This,path,toExtractCabFiles)	\
    ( (This)->lpVtbl -> CopyFromCache(This,path,toExtractCabFiles) ) 

#define IWindowsDriverUpdate2_get_DownloadPriority(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadPriority(This,retval) ) 

#define IWindowsDriverUpdate2_get_DownloadContents(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadContents(This,retval) ) 


#define IWindowsDriverUpdate2_get_DriverClass(This,retval)	\
    ( (This)->lpVtbl -> get_DriverClass(This,retval) ) 

#define IWindowsDriverUpdate2_get_DriverHardwareID(This,retval)	\
    ( (This)->lpVtbl -> get_DriverHardwareID(This,retval) ) 

#define IWindowsDriverUpdate2_get_DriverManufacturer(This,retval)	\
    ( (This)->lpVtbl -> get_DriverManufacturer(This,retval) ) 

#define IWindowsDriverUpdate2_get_DriverModel(This,retval)	\
    ( (This)->lpVtbl -> get_DriverModel(This,retval) ) 

#define IWindowsDriverUpdate2_get_DriverProvider(This,retval)	\
    ( (This)->lpVtbl -> get_DriverProvider(This,retval) ) 

#define IWindowsDriverUpdate2_get_DriverVerDate(This,retval)	\
    ( (This)->lpVtbl -> get_DriverVerDate(This,retval) ) 

#define IWindowsDriverUpdate2_get_DeviceProblemNumber(This,retval)	\
    ( (This)->lpVtbl -> get_DeviceProblemNumber(This,retval) ) 

#define IWindowsDriverUpdate2_get_DeviceStatus(This,retval)	\
    ( (This)->lpVtbl -> get_DeviceStatus(This,retval) ) 


#define IWindowsDriverUpdate2_get_RebootRequired(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequired(This,retval) ) 

#define IWindowsDriverUpdate2_get_IsPresent(This,retval)	\
    ( (This)->lpVtbl -> get_IsPresent(This,retval) ) 

#define IWindowsDriverUpdate2_get_CveIDs(This,retval)	\
    ( (This)->lpVtbl -> get_CveIDs(This,retval) ) 

#define IWindowsDriverUpdate2_CopyToCache(This,pFiles)	\
    ( (This)->lpVtbl -> CopyToCache(This,pFiles) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowsDriverUpdate2_INTERFACE_DEFINED__ */


#ifndef __IWindowsDriverUpdate3_INTERFACE_DEFINED__
#define __IWindowsDriverUpdate3_INTERFACE_DEFINED__

/* interface IWindowsDriverUpdate3 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IWindowsDriverUpdate3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49EBD502-4A96-41BD-9E3E-4C5057F4250C")
    IWindowsDriverUpdate3 : public IWindowsDriverUpdate2
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BrowseOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowsDriverUpdate3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowsDriverUpdate3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowsDriverUpdate3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowsDriverUpdate3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWindowsDriverUpdate3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWindowsDriverUpdate3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWindowsDriverUpdate3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWindowsDriverUpdate3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSelectOnWebSites )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BundledUpdates )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRequireSource )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Categories )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Deadline )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentAvailable )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeltaCompressedContentPreferred )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaAccepted )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EulaText )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HandlerID )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IImageInformation **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InstallationBehavior )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBeta )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDownloaded )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            IWindowsDriverUpdate3 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsInstalled )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsMandatory )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsUninstallable )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Languages )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastDeploymentChangeTime )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaxDownloadSize )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinDownloadSize )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoUrls )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MsrcSeverity )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedCpuSpeed )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedHardDiskSpace )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecommendedMemory )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReleaseNotes )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityBulletinIDs )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupersededUpdateIDs )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out UpdateType *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationBehavior )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationBehavior **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_KBArticleIDs )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptEula )( 
            IWindowsDriverUpdate3 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeploymentAction )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out DeploymentAction *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyFromCache )( 
            IWindowsDriverUpdate3 * This,
            /* [ref][in] */ __RPC__in BSTR path,
            /* [in] */ VARIANT_BOOL toExtractCabFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadPriority )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out DownloadPriority *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadContents )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadContentCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverClass )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverHardwareID )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverManufacturer )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverModel )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverProvider )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DriverVerDate )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceProblemNumber )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceStatus )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequired )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CveIDs )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyToCache )( 
            IWindowsDriverUpdate3 * This,
            /* [in] */ __RPC__in_opt IStringCollection *pFiles);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BrowseOnly )( 
            IWindowsDriverUpdate3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IWindowsDriverUpdate3Vtbl;

    interface IWindowsDriverUpdate3
    {
        CONST_VTBL struct IWindowsDriverUpdate3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowsDriverUpdate3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowsDriverUpdate3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowsDriverUpdate3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowsDriverUpdate3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWindowsDriverUpdate3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWindowsDriverUpdate3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWindowsDriverUpdate3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWindowsDriverUpdate3_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IWindowsDriverUpdate3_get_AutoSelectOnWebSites(This,retval)	\
    ( (This)->lpVtbl -> get_AutoSelectOnWebSites(This,retval) ) 

#define IWindowsDriverUpdate3_get_BundledUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_BundledUpdates(This,retval) ) 

#define IWindowsDriverUpdate3_get_CanRequireSource(This,retval)	\
    ( (This)->lpVtbl -> get_CanRequireSource(This,retval) ) 

#define IWindowsDriverUpdate3_get_Categories(This,retval)	\
    ( (This)->lpVtbl -> get_Categories(This,retval) ) 

#define IWindowsDriverUpdate3_get_Deadline(This,retval)	\
    ( (This)->lpVtbl -> get_Deadline(This,retval) ) 

#define IWindowsDriverUpdate3_get_DeltaCompressedContentAvailable(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentAvailable(This,retval) ) 

#define IWindowsDriverUpdate3_get_DeltaCompressedContentPreferred(This,retval)	\
    ( (This)->lpVtbl -> get_DeltaCompressedContentPreferred(This,retval) ) 

#define IWindowsDriverUpdate3_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IWindowsDriverUpdate3_get_EulaAccepted(This,retval)	\
    ( (This)->lpVtbl -> get_EulaAccepted(This,retval) ) 

#define IWindowsDriverUpdate3_get_EulaText(This,retval)	\
    ( (This)->lpVtbl -> get_EulaText(This,retval) ) 

#define IWindowsDriverUpdate3_get_HandlerID(This,retval)	\
    ( (This)->lpVtbl -> get_HandlerID(This,retval) ) 

#define IWindowsDriverUpdate3_get_Identity(This,retval)	\
    ( (This)->lpVtbl -> get_Identity(This,retval) ) 

#define IWindowsDriverUpdate3_get_Image(This,retval)	\
    ( (This)->lpVtbl -> get_Image(This,retval) ) 

#define IWindowsDriverUpdate3_get_InstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_InstallationBehavior(This,retval) ) 

#define IWindowsDriverUpdate3_get_IsBeta(This,retval)	\
    ( (This)->lpVtbl -> get_IsBeta(This,retval) ) 

#define IWindowsDriverUpdate3_get_IsDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_IsDownloaded(This,retval) ) 

#define IWindowsDriverUpdate3_get_IsHidden(This,retval)	\
    ( (This)->lpVtbl -> get_IsHidden(This,retval) ) 

#define IWindowsDriverUpdate3_put_IsHidden(This,value)	\
    ( (This)->lpVtbl -> put_IsHidden(This,value) ) 

#define IWindowsDriverUpdate3_get_IsInstalled(This,retval)	\
    ( (This)->lpVtbl -> get_IsInstalled(This,retval) ) 

#define IWindowsDriverUpdate3_get_IsMandatory(This,retval)	\
    ( (This)->lpVtbl -> get_IsMandatory(This,retval) ) 

#define IWindowsDriverUpdate3_get_IsUninstallable(This,retval)	\
    ( (This)->lpVtbl -> get_IsUninstallable(This,retval) ) 

#define IWindowsDriverUpdate3_get_Languages(This,retval)	\
    ( (This)->lpVtbl -> get_Languages(This,retval) ) 

#define IWindowsDriverUpdate3_get_LastDeploymentChangeTime(This,retval)	\
    ( (This)->lpVtbl -> get_LastDeploymentChangeTime(This,retval) ) 

#define IWindowsDriverUpdate3_get_MaxDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MaxDownloadSize(This,retval) ) 

#define IWindowsDriverUpdate3_get_MinDownloadSize(This,retval)	\
    ( (This)->lpVtbl -> get_MinDownloadSize(This,retval) ) 

#define IWindowsDriverUpdate3_get_MoreInfoUrls(This,retval)	\
    ( (This)->lpVtbl -> get_MoreInfoUrls(This,retval) ) 

#define IWindowsDriverUpdate3_get_MsrcSeverity(This,retval)	\
    ( (This)->lpVtbl -> get_MsrcSeverity(This,retval) ) 

#define IWindowsDriverUpdate3_get_RecommendedCpuSpeed(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedCpuSpeed(This,retval) ) 

#define IWindowsDriverUpdate3_get_RecommendedHardDiskSpace(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedHardDiskSpace(This,retval) ) 

#define IWindowsDriverUpdate3_get_RecommendedMemory(This,retval)	\
    ( (This)->lpVtbl -> get_RecommendedMemory(This,retval) ) 

#define IWindowsDriverUpdate3_get_ReleaseNotes(This,retval)	\
    ( (This)->lpVtbl -> get_ReleaseNotes(This,retval) ) 

#define IWindowsDriverUpdate3_get_SecurityBulletinIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SecurityBulletinIDs(This,retval) ) 

#define IWindowsDriverUpdate3_get_SupersededUpdateIDs(This,retval)	\
    ( (This)->lpVtbl -> get_SupersededUpdateIDs(This,retval) ) 

#define IWindowsDriverUpdate3_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 

#define IWindowsDriverUpdate3_get_Type(This,retval)	\
    ( (This)->lpVtbl -> get_Type(This,retval) ) 

#define IWindowsDriverUpdate3_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IWindowsDriverUpdate3_get_UninstallationBehavior(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationBehavior(This,retval) ) 

#define IWindowsDriverUpdate3_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IWindowsDriverUpdate3_get_KBArticleIDs(This,retval)	\
    ( (This)->lpVtbl -> get_KBArticleIDs(This,retval) ) 

#define IWindowsDriverUpdate3_AcceptEula(This)	\
    ( (This)->lpVtbl -> AcceptEula(This) ) 

#define IWindowsDriverUpdate3_get_DeploymentAction(This,retval)	\
    ( (This)->lpVtbl -> get_DeploymentAction(This,retval) ) 

#define IWindowsDriverUpdate3_CopyFromCache(This,path,toExtractCabFiles)	\
    ( (This)->lpVtbl -> CopyFromCache(This,path,toExtractCabFiles) ) 

#define IWindowsDriverUpdate3_get_DownloadPriority(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadPriority(This,retval) ) 

#define IWindowsDriverUpdate3_get_DownloadContents(This,retval)	\
    ( (This)->lpVtbl -> get_DownloadContents(This,retval) ) 


#define IWindowsDriverUpdate3_get_DriverClass(This,retval)	\
    ( (This)->lpVtbl -> get_DriverClass(This,retval) ) 

#define IWindowsDriverUpdate3_get_DriverHardwareID(This,retval)	\
    ( (This)->lpVtbl -> get_DriverHardwareID(This,retval) ) 

#define IWindowsDriverUpdate3_get_DriverManufacturer(This,retval)	\
    ( (This)->lpVtbl -> get_DriverManufacturer(This,retval) ) 

#define IWindowsDriverUpdate3_get_DriverModel(This,retval)	\
    ( (This)->lpVtbl -> get_DriverModel(This,retval) ) 

#define IWindowsDriverUpdate3_get_DriverProvider(This,retval)	\
    ( (This)->lpVtbl -> get_DriverProvider(This,retval) ) 

#define IWindowsDriverUpdate3_get_DriverVerDate(This,retval)	\
    ( (This)->lpVtbl -> get_DriverVerDate(This,retval) ) 

#define IWindowsDriverUpdate3_get_DeviceProblemNumber(This,retval)	\
    ( (This)->lpVtbl -> get_DeviceProblemNumber(This,retval) ) 

#define IWindowsDriverUpdate3_get_DeviceStatus(This,retval)	\
    ( (This)->lpVtbl -> get_DeviceStatus(This,retval) ) 


#define IWindowsDriverUpdate3_get_RebootRequired(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequired(This,retval) ) 

#define IWindowsDriverUpdate3_get_IsPresent(This,retval)	\
    ( (This)->lpVtbl -> get_IsPresent(This,retval) ) 

#define IWindowsDriverUpdate3_get_CveIDs(This,retval)	\
    ( (This)->lpVtbl -> get_CveIDs(This,retval) ) 

#define IWindowsDriverUpdate3_CopyToCache(This,pFiles)	\
    ( (This)->lpVtbl -> CopyToCache(This,pFiles) ) 


#define IWindowsDriverUpdate3_get_BrowseOnly(This,retval)	\
    ( (This)->lpVtbl -> get_BrowseOnly(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowsDriverUpdate3_INTERFACE_DEFINED__ */


#ifndef __IUpdateCollection_INTERFACE_DEFINED__
#define __IUpdateCollection_INTERFACE_DEFINED__

/* interface IUpdateCollection */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07f7438c-7709-4ca5-b518-91279288134e")
    IUpdateCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdate **retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ LONG index,
            /* [in] */ __RPC__in_opt IUpdate *value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IUpdate *value,
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Copy( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Insert( 
            /* [in] */ LONG index,
            /* [in] */ __RPC__in_opt IUpdate *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ LONG index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IUpdateCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdate **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Item )( 
            IUpdateCollection * This,
            /* [in] */ LONG index,
            /* [in] */ __RPC__in_opt IUpdate *value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IUpdateCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IUpdateCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IUpdateCollection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IUpdateCollection * This,
            /* [in] */ __RPC__in_opt IUpdate *value,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IUpdateCollection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            IUpdateCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Insert )( 
            IUpdateCollection * This,
            /* [in] */ LONG index,
            /* [in] */ __RPC__in_opt IUpdate *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IUpdateCollection * This,
            /* [in] */ LONG index);
        
        END_INTERFACE
    } IUpdateCollectionVtbl;

    interface IUpdateCollection
    {
        CONST_VTBL struct IUpdateCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define IUpdateCollection_put_Item(This,index,value)	\
    ( (This)->lpVtbl -> put_Item(This,index,value) ) 

#define IUpdateCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IUpdateCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#define IUpdateCollection_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IUpdateCollection_Add(This,value,retval)	\
    ( (This)->lpVtbl -> Add(This,value,retval) ) 

#define IUpdateCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IUpdateCollection_Copy(This,retval)	\
    ( (This)->lpVtbl -> Copy(This,retval) ) 

#define IUpdateCollection_Insert(This,index,value)	\
    ( (This)->lpVtbl -> Insert(This,index,value) ) 

#define IUpdateCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateCollection_INTERFACE_DEFINED__ */


#ifndef __IUpdateException_INTERFACE_DEFINED__
#define __IUpdateException_INTERFACE_DEFINED__

/* interface IUpdateException */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateException;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a376dd5e-09d4-427f-af7c-fed5b6e1c1d6")
    IUpdateException : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HResult( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Context( 
            /* [retval][out] */ __RPC__out UpdateExceptionContext *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateExceptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateException * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateException * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateException * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateException * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateException * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateException * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateException * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IUpdateException * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IUpdateException * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Context )( 
            IUpdateException * This,
            /* [retval][out] */ __RPC__out UpdateExceptionContext *retval);
        
        END_INTERFACE
    } IUpdateExceptionVtbl;

    interface IUpdateException
    {
        CONST_VTBL struct IUpdateExceptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateException_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateException_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateException_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateException_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateException_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateException_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateException_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateException_get_Message(This,retval)	\
    ( (This)->lpVtbl -> get_Message(This,retval) ) 

#define IUpdateException_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IUpdateException_get_Context(This,retval)	\
    ( (This)->lpVtbl -> get_Context(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateException_INTERFACE_DEFINED__ */


#ifndef __IInvalidProductLicenseException_INTERFACE_DEFINED__
#define __IInvalidProductLicenseException_INTERFACE_DEFINED__

/* interface IInvalidProductLicenseException */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInvalidProductLicenseException;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a37d00f5-7bb0-4953-b414-f9e98326f2e8")
    IInvalidProductLicenseException : public IUpdateException
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Product( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInvalidProductLicenseExceptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInvalidProductLicenseException * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInvalidProductLicenseException * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInvalidProductLicenseException * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IInvalidProductLicenseException * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInvalidProductLicenseException * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IInvalidProductLicenseException * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInvalidProductLicenseException * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IInvalidProductLicenseException * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IInvalidProductLicenseException * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Context )( 
            IInvalidProductLicenseException * This,
            /* [retval][out] */ __RPC__out UpdateExceptionContext *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Product )( 
            IInvalidProductLicenseException * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        END_INTERFACE
    } IInvalidProductLicenseExceptionVtbl;

    interface IInvalidProductLicenseException
    {
        CONST_VTBL struct IInvalidProductLicenseExceptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInvalidProductLicenseException_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInvalidProductLicenseException_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInvalidProductLicenseException_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInvalidProductLicenseException_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInvalidProductLicenseException_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInvalidProductLicenseException_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInvalidProductLicenseException_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInvalidProductLicenseException_get_Message(This,retval)	\
    ( (This)->lpVtbl -> get_Message(This,retval) ) 

#define IInvalidProductLicenseException_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IInvalidProductLicenseException_get_Context(This,retval)	\
    ( (This)->lpVtbl -> get_Context(This,retval) ) 


#define IInvalidProductLicenseException_get_Product(This,retval)	\
    ( (This)->lpVtbl -> get_Product(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInvalidProductLicenseException_INTERFACE_DEFINED__ */


#ifndef __IUpdateExceptionCollection_INTERFACE_DEFINED__
#define __IUpdateExceptionCollection_INTERFACE_DEFINED__

/* interface IUpdateExceptionCollection */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateExceptionCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("503626a3-8e14-4729-9355-0fe664bd2321")
    IUpdateExceptionCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateException **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateExceptionCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateExceptionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateExceptionCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateExceptionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateExceptionCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateExceptionCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateExceptionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateExceptionCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IUpdateExceptionCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateException **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IUpdateExceptionCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IUpdateExceptionCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IUpdateExceptionCollectionVtbl;

    interface IUpdateExceptionCollection
    {
        CONST_VTBL struct IUpdateExceptionCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateExceptionCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateExceptionCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateExceptionCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateExceptionCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateExceptionCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateExceptionCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateExceptionCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateExceptionCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define IUpdateExceptionCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IUpdateExceptionCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateExceptionCollection_INTERFACE_DEFINED__ */


#ifndef __ISearchResult_INTERFACE_DEFINED__
#define __ISearchResult_INTERFACE_DEFINED__

/* interface ISearchResult */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_ISearchResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d40cff62-e08c-4498-941a-01e25f0fd33c")
    ISearchResult : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResultCode( 
            /* [retval][out] */ __RPC__out OperationResultCode *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RootCategories( 
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Updates( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Warnings( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateExceptionCollection **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISearchResult * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISearchResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISearchResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISearchResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ResultCode )( 
            ISearchResult * This,
            /* [retval][out] */ __RPC__out OperationResultCode *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RootCategories )( 
            ISearchResult * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            ISearchResult * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Warnings )( 
            ISearchResult * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateExceptionCollection **retval);
        
        END_INTERFACE
    } ISearchResultVtbl;

    interface ISearchResult
    {
        CONST_VTBL struct ISearchResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchResult_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISearchResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISearchResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISearchResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISearchResult_get_ResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_ResultCode(This,retval) ) 

#define ISearchResult_get_RootCategories(This,retval)	\
    ( (This)->lpVtbl -> get_RootCategories(This,retval) ) 

#define ISearchResult_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define ISearchResult_get_Warnings(This,retval)	\
    ( (This)->lpVtbl -> get_Warnings(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchResult_INTERFACE_DEFINED__ */


#ifndef __ISearchJob_INTERFACE_DEFINED__
#define __ISearchJob_INTERFACE_DEFINED__

/* interface ISearchJob */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_ISearchJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7366ea16-7a1a-4ea2-b042-973d3e9cd99b")
    ISearchJob : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AsyncState( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsCompleted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanUp( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISearchJob * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISearchJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISearchJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISearchJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AsyncState )( 
            ISearchJob * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsCompleted )( 
            ISearchJob * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CleanUp )( 
            ISearchJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestAbort )( 
            ISearchJob * This);
        
        END_INTERFACE
    } ISearchJobVtbl;

    interface ISearchJob
    {
        CONST_VTBL struct ISearchJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchJob_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchJob_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchJob_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchJob_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISearchJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISearchJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISearchJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISearchJob_get_AsyncState(This,retval)	\
    ( (This)->lpVtbl -> get_AsyncState(This,retval) ) 

#define ISearchJob_get_IsCompleted(This,retval)	\
    ( (This)->lpVtbl -> get_IsCompleted(This,retval) ) 

#define ISearchJob_CleanUp(This)	\
    ( (This)->lpVtbl -> CleanUp(This) ) 

#define ISearchJob_RequestAbort(This)	\
    ( (This)->lpVtbl -> RequestAbort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchJob_INTERFACE_DEFINED__ */


#ifndef __ISearchCompletedCallbackArgs_INTERFACE_DEFINED__
#define __ISearchCompletedCallbackArgs_INTERFACE_DEFINED__

/* interface ISearchCompletedCallbackArgs */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_ISearchCompletedCallbackArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a700a634-2850-4c47-938a-9e4b6e5af9a6")
    ISearchCompletedCallbackArgs : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ISearchCompletedCallbackArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchCompletedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchCompletedCallbackArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchCompletedCallbackArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISearchCompletedCallbackArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISearchCompletedCallbackArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISearchCompletedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISearchCompletedCallbackArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } ISearchCompletedCallbackArgsVtbl;

    interface ISearchCompletedCallbackArgs
    {
        CONST_VTBL struct ISearchCompletedCallbackArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchCompletedCallbackArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchCompletedCallbackArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchCompletedCallbackArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchCompletedCallbackArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISearchCompletedCallbackArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISearchCompletedCallbackArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISearchCompletedCallbackArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchCompletedCallbackArgs_INTERFACE_DEFINED__ */


#ifndef __ISearchCompletedCallback_INTERFACE_DEFINED__
#define __ISearchCompletedCallback_INTERFACE_DEFINED__

/* interface ISearchCompletedCallback */
/* [unique][uuid][nonextensible][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_ISearchCompletedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88aee058-d4b0-4725-a2f1-814a67ae964c")
    ISearchCompletedCallback : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ __RPC__in_opt ISearchJob *searchJob,
            /* [in] */ __RPC__in_opt ISearchCompletedCallbackArgs *callbackArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchCompletedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchCompletedCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchCompletedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchCompletedCallback * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISearchCompletedCallback * This,
            /* [in] */ __RPC__in_opt ISearchJob *searchJob,
            /* [in] */ __RPC__in_opt ISearchCompletedCallbackArgs *callbackArgs);
        
        END_INTERFACE
    } ISearchCompletedCallbackVtbl;

    interface ISearchCompletedCallback
    {
        CONST_VTBL struct ISearchCompletedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchCompletedCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchCompletedCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchCompletedCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchCompletedCallback_Invoke(This,searchJob,callbackArgs)	\
    ( (This)->lpVtbl -> Invoke(This,searchJob,callbackArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchCompletedCallback_INTERFACE_DEFINED__ */


#ifndef __IUpdateHistoryEntry_INTERFACE_DEFINED__
#define __IUpdateHistoryEntry_INTERFACE_DEFINED__

/* interface IUpdateHistoryEntry */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateHistoryEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("be56a644-af0e-4e0e-a311-c1d8e695cbff")
    IUpdateHistoryEntry : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Operation( 
            /* [retval][out] */ __RPC__out UpdateOperation *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResultCode( 
            /* [retval][out] */ __RPC__out OperationResultCode *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HResult( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Date( 
            /* [retval][out] */ __RPC__out DATE *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UpdateIdentity( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UnmappedResultCode( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerSelection( 
            /* [retval][out] */ __RPC__out ServerSelection *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UninstallationSteps( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UninstallationNotes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SupportUrl( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateHistoryEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateHistoryEntry * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateHistoryEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateHistoryEntry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateHistoryEntry * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateHistoryEntry * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateHistoryEntry * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateHistoryEntry * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Operation )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__out UpdateOperation *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ResultCode )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__out OperationResultCode *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Date )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateIdentity )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UnmappedResultCode )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServerSelection )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__out ServerSelection *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IUpdateHistoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        END_INTERFACE
    } IUpdateHistoryEntryVtbl;

    interface IUpdateHistoryEntry
    {
        CONST_VTBL struct IUpdateHistoryEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateHistoryEntry_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateHistoryEntry_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateHistoryEntry_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateHistoryEntry_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateHistoryEntry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateHistoryEntry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateHistoryEntry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateHistoryEntry_get_Operation(This,retval)	\
    ( (This)->lpVtbl -> get_Operation(This,retval) ) 

#define IUpdateHistoryEntry_get_ResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_ResultCode(This,retval) ) 

#define IUpdateHistoryEntry_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IUpdateHistoryEntry_get_Date(This,retval)	\
    ( (This)->lpVtbl -> get_Date(This,retval) ) 

#define IUpdateHistoryEntry_get_UpdateIdentity(This,retval)	\
    ( (This)->lpVtbl -> get_UpdateIdentity(This,retval) ) 

#define IUpdateHistoryEntry_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IUpdateHistoryEntry_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IUpdateHistoryEntry_get_UnmappedResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_UnmappedResultCode(This,retval) ) 

#define IUpdateHistoryEntry_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateHistoryEntry_get_ServerSelection(This,retval)	\
    ( (This)->lpVtbl -> get_ServerSelection(This,retval) ) 

#define IUpdateHistoryEntry_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateHistoryEntry_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IUpdateHistoryEntry_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IUpdateHistoryEntry_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateHistoryEntry_INTERFACE_DEFINED__ */


#ifndef __IUpdateHistoryEntry2_INTERFACE_DEFINED__
#define __IUpdateHistoryEntry2_INTERFACE_DEFINED__

/* interface IUpdateHistoryEntry2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateHistoryEntry2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c2bfb780-4539-4132-ab8c-0a8772013ab6")
    IUpdateHistoryEntry2 : public IUpdateHistoryEntry
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Categories( 
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateHistoryEntry2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateHistoryEntry2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateHistoryEntry2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateHistoryEntry2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateHistoryEntry2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateHistoryEntry2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateHistoryEntry2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateHistoryEntry2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Operation )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__out UpdateOperation *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ResultCode )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__out OperationResultCode *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Date )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateIdentity )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateIdentity **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UnmappedResultCode )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServerSelection )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__out ServerSelection *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationSteps )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UninstallationNotes )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SupportUrl )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Categories )( 
            IUpdateHistoryEntry2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICategoryCollection **retval);
        
        END_INTERFACE
    } IUpdateHistoryEntry2Vtbl;

    interface IUpdateHistoryEntry2
    {
        CONST_VTBL struct IUpdateHistoryEntry2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateHistoryEntry2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateHistoryEntry2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateHistoryEntry2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateHistoryEntry2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateHistoryEntry2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateHistoryEntry2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateHistoryEntry2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateHistoryEntry2_get_Operation(This,retval)	\
    ( (This)->lpVtbl -> get_Operation(This,retval) ) 

#define IUpdateHistoryEntry2_get_ResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_ResultCode(This,retval) ) 

#define IUpdateHistoryEntry2_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IUpdateHistoryEntry2_get_Date(This,retval)	\
    ( (This)->lpVtbl -> get_Date(This,retval) ) 

#define IUpdateHistoryEntry2_get_UpdateIdentity(This,retval)	\
    ( (This)->lpVtbl -> get_UpdateIdentity(This,retval) ) 

#define IUpdateHistoryEntry2_get_Title(This,retval)	\
    ( (This)->lpVtbl -> get_Title(This,retval) ) 

#define IUpdateHistoryEntry2_get_Description(This,retval)	\
    ( (This)->lpVtbl -> get_Description(This,retval) ) 

#define IUpdateHistoryEntry2_get_UnmappedResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_UnmappedResultCode(This,retval) ) 

#define IUpdateHistoryEntry2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateHistoryEntry2_get_ServerSelection(This,retval)	\
    ( (This)->lpVtbl -> get_ServerSelection(This,retval) ) 

#define IUpdateHistoryEntry2_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateHistoryEntry2_get_UninstallationSteps(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationSteps(This,retval) ) 

#define IUpdateHistoryEntry2_get_UninstallationNotes(This,retval)	\
    ( (This)->lpVtbl -> get_UninstallationNotes(This,retval) ) 

#define IUpdateHistoryEntry2_get_SupportUrl(This,retval)	\
    ( (This)->lpVtbl -> get_SupportUrl(This,retval) ) 


#define IUpdateHistoryEntry2_get_Categories(This,retval)	\
    ( (This)->lpVtbl -> get_Categories(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateHistoryEntry2_INTERFACE_DEFINED__ */


#ifndef __IUpdateHistoryEntryCollection_INTERFACE_DEFINED__
#define __IUpdateHistoryEntryCollection_INTERFACE_DEFINED__

/* interface IUpdateHistoryEntryCollection */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateHistoryEntryCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7f04f3c-a290-435b-aadf-a116c3357a5c")
    IUpdateHistoryEntryCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntry **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateHistoryEntryCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateHistoryEntryCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateHistoryEntryCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateHistoryEntryCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateHistoryEntryCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateHistoryEntryCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateHistoryEntryCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateHistoryEntryCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IUpdateHistoryEntryCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntry **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IUpdateHistoryEntryCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IUpdateHistoryEntryCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IUpdateHistoryEntryCollectionVtbl;

    interface IUpdateHistoryEntryCollection
    {
        CONST_VTBL struct IUpdateHistoryEntryCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateHistoryEntryCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateHistoryEntryCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateHistoryEntryCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateHistoryEntryCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateHistoryEntryCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateHistoryEntryCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateHistoryEntryCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateHistoryEntryCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define IUpdateHistoryEntryCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IUpdateHistoryEntryCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateHistoryEntryCollection_INTERFACE_DEFINED__ */


#ifndef __IUpdateSearcher_INTERFACE_DEFINED__
#define __IUpdateSearcher_INTERFACE_DEFINED__

/* interface IUpdateSearcher */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSearcher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f45abf1-f9ae-4b95-a933-f0f66e5056ea")
    IUpdateSearcher : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanAutomaticallyUpgradeService( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_CanAutomaticallyUpgradeService( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientApplicationID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IncludePotentiallySupersededUpdates( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IncludePotentiallySupersededUpdates( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerSelection( 
            /* [retval][out] */ __RPC__out ServerSelection *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ServerSelection( 
            /* [in] */ ServerSelection value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginSearch( 
            /* [in] */ __RPC__in BSTR criteria,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt ISearchJob **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndSearch( 
            /* [in] */ __RPC__in_opt ISearchJob *searchJob,
            /* [retval][out] */ __RPC__deref_out_opt ISearchResult **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EscapeString( 
            /* [in] */ __RPC__in BSTR unescaped,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryHistory( 
            /* [in] */ LONG startIndex,
            /* [in] */ LONG count,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntryCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Search( 
            /* [in] */ __RPC__in BSTR criteria,
            /* [retval][out] */ __RPC__deref_out_opt ISearchResult **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Online( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Online( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTotalHistoryCount( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ServiceID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSearcherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateSearcher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateSearcher * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateSearcher * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateSearcher * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSearcher * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanAutomaticallyUpgradeService )( 
            IUpdateSearcher * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CanAutomaticallyUpgradeService )( 
            IUpdateSearcher * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateSearcher * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IncludePotentiallySupersededUpdates )( 
            IUpdateSearcher * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IncludePotentiallySupersededUpdates )( 
            IUpdateSearcher * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServerSelection )( 
            IUpdateSearcher * This,
            /* [retval][out] */ __RPC__out ServerSelection *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ServerSelection )( 
            IUpdateSearcher * This,
            /* [in] */ ServerSelection value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginSearch )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in BSTR criteria,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt ISearchJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndSearch )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in_opt ISearchJob *searchJob,
            /* [retval][out] */ __RPC__deref_out_opt ISearchResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EscapeString )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in BSTR unescaped,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryHistory )( 
            IUpdateSearcher * This,
            /* [in] */ LONG startIndex,
            /* [in] */ LONG count,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntryCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Search )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in BSTR criteria,
            /* [retval][out] */ __RPC__deref_out_opt ISearchResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Online )( 
            IUpdateSearcher * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Online )( 
            IUpdateSearcher * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTotalHistoryCount )( 
            IUpdateSearcher * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            IUpdateSearcher * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceID )( 
            IUpdateSearcher * This,
            /* [in] */ __RPC__in BSTR value);
        
        END_INTERFACE
    } IUpdateSearcherVtbl;

    interface IUpdateSearcher
    {
        CONST_VTBL struct IUpdateSearcherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSearcher_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSearcher_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSearcher_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSearcher_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSearcher_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSearcher_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSearcher_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSearcher_get_CanAutomaticallyUpgradeService(This,retval)	\
    ( (This)->lpVtbl -> get_CanAutomaticallyUpgradeService(This,retval) ) 

#define IUpdateSearcher_put_CanAutomaticallyUpgradeService(This,value)	\
    ( (This)->lpVtbl -> put_CanAutomaticallyUpgradeService(This,value) ) 

#define IUpdateSearcher_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSearcher_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSearcher_get_IncludePotentiallySupersededUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_IncludePotentiallySupersededUpdates(This,retval) ) 

#define IUpdateSearcher_put_IncludePotentiallySupersededUpdates(This,value)	\
    ( (This)->lpVtbl -> put_IncludePotentiallySupersededUpdates(This,value) ) 

#define IUpdateSearcher_get_ServerSelection(This,retval)	\
    ( (This)->lpVtbl -> get_ServerSelection(This,retval) ) 

#define IUpdateSearcher_put_ServerSelection(This,value)	\
    ( (This)->lpVtbl -> put_ServerSelection(This,value) ) 

#define IUpdateSearcher_BeginSearch(This,criteria,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginSearch(This,criteria,onCompleted,state,retval) ) 

#define IUpdateSearcher_EndSearch(This,searchJob,retval)	\
    ( (This)->lpVtbl -> EndSearch(This,searchJob,retval) ) 

#define IUpdateSearcher_EscapeString(This,unescaped,retval)	\
    ( (This)->lpVtbl -> EscapeString(This,unescaped,retval) ) 

#define IUpdateSearcher_QueryHistory(This,startIndex,count,retval)	\
    ( (This)->lpVtbl -> QueryHistory(This,startIndex,count,retval) ) 

#define IUpdateSearcher_Search(This,criteria,retval)	\
    ( (This)->lpVtbl -> Search(This,criteria,retval) ) 

#define IUpdateSearcher_get_Online(This,retval)	\
    ( (This)->lpVtbl -> get_Online(This,retval) ) 

#define IUpdateSearcher_put_Online(This,value)	\
    ( (This)->lpVtbl -> put_Online(This,value) ) 

#define IUpdateSearcher_GetTotalHistoryCount(This,retval)	\
    ( (This)->lpVtbl -> GetTotalHistoryCount(This,retval) ) 

#define IUpdateSearcher_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateSearcher_put_ServiceID(This,value)	\
    ( (This)->lpVtbl -> put_ServiceID(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSearcher_INTERFACE_DEFINED__ */


#ifndef __IUpdateSearcher2_INTERFACE_DEFINED__
#define __IUpdateSearcher2_INTERFACE_DEFINED__

/* interface IUpdateSearcher2 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSearcher2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4cbdcb2d-1589-4beb-bd1c-3e582ff0add0")
    IUpdateSearcher2 : public IUpdateSearcher
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IgnoreDownloadPriority( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IgnoreDownloadPriority( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSearcher2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateSearcher2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateSearcher2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateSearcher2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateSearcher2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSearcher2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanAutomaticallyUpgradeService )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CanAutomaticallyUpgradeService )( 
            IUpdateSearcher2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IncludePotentiallySupersededUpdates )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IncludePotentiallySupersededUpdates )( 
            IUpdateSearcher2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServerSelection )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__out ServerSelection *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ServerSelection )( 
            IUpdateSearcher2 * This,
            /* [in] */ ServerSelection value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginSearch )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in BSTR criteria,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt ISearchJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndSearch )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in_opt ISearchJob *searchJob,
            /* [retval][out] */ __RPC__deref_out_opt ISearchResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EscapeString )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in BSTR unescaped,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryHistory )( 
            IUpdateSearcher2 * This,
            /* [in] */ LONG startIndex,
            /* [in] */ LONG count,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntryCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Search )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in BSTR criteria,
            /* [retval][out] */ __RPC__deref_out_opt ISearchResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Online )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Online )( 
            IUpdateSearcher2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTotalHistoryCount )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceID )( 
            IUpdateSearcher2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IgnoreDownloadPriority )( 
            IUpdateSearcher2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IgnoreDownloadPriority )( 
            IUpdateSearcher2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        END_INTERFACE
    } IUpdateSearcher2Vtbl;

    interface IUpdateSearcher2
    {
        CONST_VTBL struct IUpdateSearcher2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSearcher2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSearcher2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSearcher2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSearcher2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSearcher2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSearcher2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSearcher2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSearcher2_get_CanAutomaticallyUpgradeService(This,retval)	\
    ( (This)->lpVtbl -> get_CanAutomaticallyUpgradeService(This,retval) ) 

#define IUpdateSearcher2_put_CanAutomaticallyUpgradeService(This,value)	\
    ( (This)->lpVtbl -> put_CanAutomaticallyUpgradeService(This,value) ) 

#define IUpdateSearcher2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSearcher2_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSearcher2_get_IncludePotentiallySupersededUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_IncludePotentiallySupersededUpdates(This,retval) ) 

#define IUpdateSearcher2_put_IncludePotentiallySupersededUpdates(This,value)	\
    ( (This)->lpVtbl -> put_IncludePotentiallySupersededUpdates(This,value) ) 

#define IUpdateSearcher2_get_ServerSelection(This,retval)	\
    ( (This)->lpVtbl -> get_ServerSelection(This,retval) ) 

#define IUpdateSearcher2_put_ServerSelection(This,value)	\
    ( (This)->lpVtbl -> put_ServerSelection(This,value) ) 

#define IUpdateSearcher2_BeginSearch(This,criteria,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginSearch(This,criteria,onCompleted,state,retval) ) 

#define IUpdateSearcher2_EndSearch(This,searchJob,retval)	\
    ( (This)->lpVtbl -> EndSearch(This,searchJob,retval) ) 

#define IUpdateSearcher2_EscapeString(This,unescaped,retval)	\
    ( (This)->lpVtbl -> EscapeString(This,unescaped,retval) ) 

#define IUpdateSearcher2_QueryHistory(This,startIndex,count,retval)	\
    ( (This)->lpVtbl -> QueryHistory(This,startIndex,count,retval) ) 

#define IUpdateSearcher2_Search(This,criteria,retval)	\
    ( (This)->lpVtbl -> Search(This,criteria,retval) ) 

#define IUpdateSearcher2_get_Online(This,retval)	\
    ( (This)->lpVtbl -> get_Online(This,retval) ) 

#define IUpdateSearcher2_put_Online(This,value)	\
    ( (This)->lpVtbl -> put_Online(This,value) ) 

#define IUpdateSearcher2_GetTotalHistoryCount(This,retval)	\
    ( (This)->lpVtbl -> GetTotalHistoryCount(This,retval) ) 

#define IUpdateSearcher2_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateSearcher2_put_ServiceID(This,value)	\
    ( (This)->lpVtbl -> put_ServiceID(This,value) ) 


#define IUpdateSearcher2_get_IgnoreDownloadPriority(This,retval)	\
    ( (This)->lpVtbl -> get_IgnoreDownloadPriority(This,retval) ) 

#define IUpdateSearcher2_put_IgnoreDownloadPriority(This,value)	\
    ( (This)->lpVtbl -> put_IgnoreDownloadPriority(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSearcher2_INTERFACE_DEFINED__ */


#ifndef __IUpdateDownloadResult_INTERFACE_DEFINED__
#define __IUpdateDownloadResult_INTERFACE_DEFINED__

/* interface IUpdateDownloadResult */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateDownloadResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bf99af76-b575-42ad-8aa4-33cbb5477af1")
    IUpdateDownloadResult : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HResult( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResultCode( 
            /* [retval][out] */ __RPC__out OperationResultCode *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateDownloadResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateDownloadResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateDownloadResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateDownloadResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateDownloadResult * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateDownloadResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateDownloadResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateDownloadResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IUpdateDownloadResult * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ResultCode )( 
            IUpdateDownloadResult * This,
            /* [retval][out] */ __RPC__out OperationResultCode *retval);
        
        END_INTERFACE
    } IUpdateDownloadResultVtbl;

    interface IUpdateDownloadResult
    {
        CONST_VTBL struct IUpdateDownloadResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateDownloadResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateDownloadResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateDownloadResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateDownloadResult_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateDownloadResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateDownloadResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateDownloadResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateDownloadResult_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IUpdateDownloadResult_get_ResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_ResultCode(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateDownloadResult_INTERFACE_DEFINED__ */


#ifndef __IDownloadResult_INTERFACE_DEFINED__
#define __IDownloadResult_INTERFACE_DEFINED__

/* interface IDownloadResult */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("daa4fdd0-4727-4dbe-a1e7-745dca317144")
    IDownloadResult : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HResult( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResultCode( 
            /* [retval][out] */ __RPC__out OperationResultCode *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUpdateResult( 
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadResult **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDownloadResult * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDownloadResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDownloadResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDownloadResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IDownloadResult * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ResultCode )( 
            IDownloadResult * This,
            /* [retval][out] */ __RPC__out OperationResultCode *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetUpdateResult )( 
            IDownloadResult * This,
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadResult **retval);
        
        END_INTERFACE
    } IDownloadResultVtbl;

    interface IDownloadResult
    {
        CONST_VTBL struct IDownloadResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadResult_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDownloadResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDownloadResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDownloadResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDownloadResult_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IDownloadResult_get_ResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_ResultCode(This,retval) ) 

#define IDownloadResult_GetUpdateResult(This,updateIndex,retval)	\
    ( (This)->lpVtbl -> GetUpdateResult(This,updateIndex,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadResult_INTERFACE_DEFINED__ */


#ifndef __IDownloadProgress_INTERFACE_DEFINED__
#define __IDownloadProgress_INTERFACE_DEFINED__

/* interface IDownloadProgress */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d31a5bac-f719-4178-9dbb-5e2cb47fd18a")
    IDownloadProgress : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentUpdateBytesDownloaded( 
            /* [retval][out] */ __RPC__out DECIMAL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentUpdateBytesToDownload( 
            /* [retval][out] */ __RPC__out DECIMAL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentUpdateIndex( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PercentComplete( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TotalBytesDownloaded( 
            /* [retval][out] */ __RPC__out DECIMAL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TotalBytesToDownload( 
            /* [retval][out] */ __RPC__out DECIMAL *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUpdateResult( 
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadResult **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentUpdateDownloadPhase( 
            /* [retval][out] */ __RPC__out DownloadPhase *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentUpdatePercentComplete( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadProgress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDownloadProgress * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDownloadProgress * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDownloadProgress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDownloadProgress * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUpdateBytesDownloaded )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUpdateBytesToDownload )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUpdateIndex )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PercentComplete )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TotalBytesDownloaded )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TotalBytesToDownload )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out DECIMAL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetUpdateResult )( 
            IDownloadProgress * This,
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloadResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUpdateDownloadPhase )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out DownloadPhase *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUpdatePercentComplete )( 
            IDownloadProgress * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IDownloadProgressVtbl;

    interface IDownloadProgress
    {
        CONST_VTBL struct IDownloadProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadProgress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadProgress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadProgress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadProgress_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDownloadProgress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDownloadProgress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDownloadProgress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDownloadProgress_get_CurrentUpdateBytesDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_CurrentUpdateBytesDownloaded(This,retval) ) 

#define IDownloadProgress_get_CurrentUpdateBytesToDownload(This,retval)	\
    ( (This)->lpVtbl -> get_CurrentUpdateBytesToDownload(This,retval) ) 

#define IDownloadProgress_get_CurrentUpdateIndex(This,retval)	\
    ( (This)->lpVtbl -> get_CurrentUpdateIndex(This,retval) ) 

#define IDownloadProgress_get_PercentComplete(This,retval)	\
    ( (This)->lpVtbl -> get_PercentComplete(This,retval) ) 

#define IDownloadProgress_get_TotalBytesDownloaded(This,retval)	\
    ( (This)->lpVtbl -> get_TotalBytesDownloaded(This,retval) ) 

#define IDownloadProgress_get_TotalBytesToDownload(This,retval)	\
    ( (This)->lpVtbl -> get_TotalBytesToDownload(This,retval) ) 

#define IDownloadProgress_GetUpdateResult(This,updateIndex,retval)	\
    ( (This)->lpVtbl -> GetUpdateResult(This,updateIndex,retval) ) 

#define IDownloadProgress_get_CurrentUpdateDownloadPhase(This,retval)	\
    ( (This)->lpVtbl -> get_CurrentUpdateDownloadPhase(This,retval) ) 

#define IDownloadProgress_get_CurrentUpdatePercentComplete(This,retval)	\
    ( (This)->lpVtbl -> get_CurrentUpdatePercentComplete(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadProgress_INTERFACE_DEFINED__ */


#ifndef __IDownloadJob_INTERFACE_DEFINED__
#define __IDownloadJob_INTERFACE_DEFINED__

/* interface IDownloadJob */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c574de85-7358-43f6-aae8-8697e62d8ba7")
    IDownloadJob : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AsyncState( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsCompleted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Updates( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanUp( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [retval][out] */ __RPC__deref_out_opt IDownloadProgress **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDownloadJob * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDownloadJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDownloadJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDownloadJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AsyncState )( 
            IDownloadJob * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsCompleted )( 
            IDownloadJob * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            IDownloadJob * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CleanUp )( 
            IDownloadJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IDownloadJob * This,
            /* [retval][out] */ __RPC__deref_out_opt IDownloadProgress **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestAbort )( 
            IDownloadJob * This);
        
        END_INTERFACE
    } IDownloadJobVtbl;

    interface IDownloadJob
    {
        CONST_VTBL struct IDownloadJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadJob_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadJob_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadJob_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadJob_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDownloadJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDownloadJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDownloadJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDownloadJob_get_AsyncState(This,retval)	\
    ( (This)->lpVtbl -> get_AsyncState(This,retval) ) 

#define IDownloadJob_get_IsCompleted(This,retval)	\
    ( (This)->lpVtbl -> get_IsCompleted(This,retval) ) 

#define IDownloadJob_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define IDownloadJob_CleanUp(This)	\
    ( (This)->lpVtbl -> CleanUp(This) ) 

#define IDownloadJob_GetProgress(This,retval)	\
    ( (This)->lpVtbl -> GetProgress(This,retval) ) 

#define IDownloadJob_RequestAbort(This)	\
    ( (This)->lpVtbl -> RequestAbort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadJob_INTERFACE_DEFINED__ */


#ifndef __IDownloadCompletedCallbackArgs_INTERFACE_DEFINED__
#define __IDownloadCompletedCallbackArgs_INTERFACE_DEFINED__

/* interface IDownloadCompletedCallbackArgs */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadCompletedCallbackArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa565b23-498c-47a0-979d-e7d5b1813360")
    IDownloadCompletedCallbackArgs : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDownloadCompletedCallbackArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadCompletedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadCompletedCallbackArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadCompletedCallbackArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDownloadCompletedCallbackArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDownloadCompletedCallbackArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDownloadCompletedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDownloadCompletedCallbackArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IDownloadCompletedCallbackArgsVtbl;

    interface IDownloadCompletedCallbackArgs
    {
        CONST_VTBL struct IDownloadCompletedCallbackArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadCompletedCallbackArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadCompletedCallbackArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadCompletedCallbackArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadCompletedCallbackArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDownloadCompletedCallbackArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDownloadCompletedCallbackArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDownloadCompletedCallbackArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadCompletedCallbackArgs_INTERFACE_DEFINED__ */


#ifndef __IDownloadCompletedCallback_INTERFACE_DEFINED__
#define __IDownloadCompletedCallback_INTERFACE_DEFINED__

/* interface IDownloadCompletedCallback */
/* [unique][uuid][nonextensible][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadCompletedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77254866-9f5b-4c8e-b9e2-c77a8530d64b")
    IDownloadCompletedCallback : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ __RPC__in_opt IDownloadJob *downloadJob,
            /* [in] */ __RPC__in_opt IDownloadCompletedCallbackArgs *callbackArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadCompletedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadCompletedCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadCompletedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadCompletedCallback * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDownloadCompletedCallback * This,
            /* [in] */ __RPC__in_opt IDownloadJob *downloadJob,
            /* [in] */ __RPC__in_opt IDownloadCompletedCallbackArgs *callbackArgs);
        
        END_INTERFACE
    } IDownloadCompletedCallbackVtbl;

    interface IDownloadCompletedCallback
    {
        CONST_VTBL struct IDownloadCompletedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadCompletedCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadCompletedCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadCompletedCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadCompletedCallback_Invoke(This,downloadJob,callbackArgs)	\
    ( (This)->lpVtbl -> Invoke(This,downloadJob,callbackArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadCompletedCallback_INTERFACE_DEFINED__ */


#ifndef __IDownloadProgressChangedCallbackArgs_INTERFACE_DEFINED__
#define __IDownloadProgressChangedCallbackArgs_INTERFACE_DEFINED__

/* interface IDownloadProgressChangedCallbackArgs */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadProgressChangedCallbackArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("324ff2c6-4981-4b04-9412-57481745ab24")
    IDownloadProgressChangedCallbackArgs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Progress( 
            /* [retval][out] */ __RPC__deref_out_opt IDownloadProgress **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadProgressChangedCallbackArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadProgressChangedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadProgressChangedCallbackArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadProgressChangedCallbackArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDownloadProgressChangedCallbackArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDownloadProgressChangedCallbackArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDownloadProgressChangedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDownloadProgressChangedCallbackArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDownloadProgressChangedCallbackArgs * This,
            /* [retval][out] */ __RPC__deref_out_opt IDownloadProgress **retval);
        
        END_INTERFACE
    } IDownloadProgressChangedCallbackArgsVtbl;

    interface IDownloadProgressChangedCallbackArgs
    {
        CONST_VTBL struct IDownloadProgressChangedCallbackArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadProgressChangedCallbackArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadProgressChangedCallbackArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadProgressChangedCallbackArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadProgressChangedCallbackArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDownloadProgressChangedCallbackArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDownloadProgressChangedCallbackArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDownloadProgressChangedCallbackArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDownloadProgressChangedCallbackArgs_get_Progress(This,retval)	\
    ( (This)->lpVtbl -> get_Progress(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadProgressChangedCallbackArgs_INTERFACE_DEFINED__ */


#ifndef __IDownloadProgressChangedCallback_INTERFACE_DEFINED__
#define __IDownloadProgressChangedCallback_INTERFACE_DEFINED__

/* interface IDownloadProgressChangedCallback */
/* [unique][uuid][nonextensible][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadProgressChangedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c3f1cdd-6173-4591-aebd-a56a53ca77c1")
    IDownloadProgressChangedCallback : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ __RPC__in_opt IDownloadJob *downloadJob,
            /* [in] */ __RPC__in_opt IDownloadProgressChangedCallbackArgs *callbackArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadProgressChangedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadProgressChangedCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadProgressChangedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadProgressChangedCallback * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDownloadProgressChangedCallback * This,
            /* [in] */ __RPC__in_opt IDownloadJob *downloadJob,
            /* [in] */ __RPC__in_opt IDownloadProgressChangedCallbackArgs *callbackArgs);
        
        END_INTERFACE
    } IDownloadProgressChangedCallbackVtbl;

    interface IDownloadProgressChangedCallback
    {
        CONST_VTBL struct IDownloadProgressChangedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadProgressChangedCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadProgressChangedCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadProgressChangedCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadProgressChangedCallback_Invoke(This,downloadJob,callbackArgs)	\
    ( (This)->lpVtbl -> Invoke(This,downloadJob,callbackArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadProgressChangedCallback_INTERFACE_DEFINED__ */


#ifndef __IUpdateDownloader_INTERFACE_DEFINED__
#define __IUpdateDownloader_INTERFACE_DEFINED__

/* interface IUpdateDownloader */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateDownloader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68f1c6f9-7ecc-4666-a464-247fe12496c3")
    IUpdateDownloader : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientApplicationID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsForced( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsForced( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ __RPC__out DownloadPriority *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ DownloadPriority value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Updates( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Updates( 
            /* [in] */ __RPC__in_opt IUpdateCollection *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginDownload( 
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IDownloadJob **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Download( 
            /* [retval][out] */ __RPC__deref_out_opt IDownloadResult **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndDownload( 
            /* [in] */ __RPC__in_opt IDownloadJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IDownloadResult **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateDownloaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateDownloader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateDownloader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateDownloader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateDownloader * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateDownloader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateDownloader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateDownloader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateDownloader * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateDownloader * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsForced )( 
            IUpdateDownloader * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsForced )( 
            IUpdateDownloader * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IUpdateDownloader * This,
            /* [retval][out] */ __RPC__out DownloadPriority *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IUpdateDownloader * This,
            /* [in] */ DownloadPriority value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            IUpdateDownloader * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Updates )( 
            IUpdateDownloader * This,
            /* [in] */ __RPC__in_opt IUpdateCollection *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginDownload )( 
            IUpdateDownloader * This,
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IDownloadJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Download )( 
            IUpdateDownloader * This,
            /* [retval][out] */ __RPC__deref_out_opt IDownloadResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndDownload )( 
            IUpdateDownloader * This,
            /* [in] */ __RPC__in_opt IDownloadJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IDownloadResult **retval);
        
        END_INTERFACE
    } IUpdateDownloaderVtbl;

    interface IUpdateDownloader
    {
        CONST_VTBL struct IUpdateDownloaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateDownloader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateDownloader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateDownloader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateDownloader_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateDownloader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateDownloader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateDownloader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateDownloader_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateDownloader_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateDownloader_get_IsForced(This,retval)	\
    ( (This)->lpVtbl -> get_IsForced(This,retval) ) 

#define IUpdateDownloader_put_IsForced(This,value)	\
    ( (This)->lpVtbl -> put_IsForced(This,value) ) 

#define IUpdateDownloader_get_Priority(This,retval)	\
    ( (This)->lpVtbl -> get_Priority(This,retval) ) 

#define IUpdateDownloader_put_Priority(This,value)	\
    ( (This)->lpVtbl -> put_Priority(This,value) ) 

#define IUpdateDownloader_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define IUpdateDownloader_put_Updates(This,value)	\
    ( (This)->lpVtbl -> put_Updates(This,value) ) 

#define IUpdateDownloader_BeginDownload(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginDownload(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateDownloader_Download(This,retval)	\
    ( (This)->lpVtbl -> Download(This,retval) ) 

#define IUpdateDownloader_EndDownload(This,value,retval)	\
    ( (This)->lpVtbl -> EndDownload(This,value,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateDownloader_INTERFACE_DEFINED__ */


#ifndef __IUpdateInstallationResult_INTERFACE_DEFINED__
#define __IUpdateInstallationResult_INTERFACE_DEFINED__

/* interface IUpdateInstallationResult */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateInstallationResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d940f0f8-3cbb-4fd0-993f-471e7f2328ad")
    IUpdateInstallationResult : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HResult( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RebootRequired( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResultCode( 
            /* [retval][out] */ __RPC__out OperationResultCode *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateInstallationResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateInstallationResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateInstallationResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateInstallationResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateInstallationResult * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateInstallationResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateInstallationResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateInstallationResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IUpdateInstallationResult * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequired )( 
            IUpdateInstallationResult * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ResultCode )( 
            IUpdateInstallationResult * This,
            /* [retval][out] */ __RPC__out OperationResultCode *retval);
        
        END_INTERFACE
    } IUpdateInstallationResultVtbl;

    interface IUpdateInstallationResult
    {
        CONST_VTBL struct IUpdateInstallationResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateInstallationResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateInstallationResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateInstallationResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateInstallationResult_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateInstallationResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateInstallationResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateInstallationResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateInstallationResult_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IUpdateInstallationResult_get_RebootRequired(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequired(This,retval) ) 

#define IUpdateInstallationResult_get_ResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_ResultCode(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateInstallationResult_INTERFACE_DEFINED__ */


#ifndef __IInstallationResult_INTERFACE_DEFINED__
#define __IInstallationResult_INTERFACE_DEFINED__

/* interface IInstallationResult */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a43c56d6-7451-48d4-af96-b6cd2d0d9b7a")
    IInstallationResult : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HResult( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RebootRequired( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ResultCode( 
            /* [retval][out] */ __RPC__out OperationResultCode *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUpdateResult( 
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstallationResult **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IInstallationResult * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInstallationResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IInstallationResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HResult )( 
            IInstallationResult * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequired )( 
            IInstallationResult * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ResultCode )( 
            IInstallationResult * This,
            /* [retval][out] */ __RPC__out OperationResultCode *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetUpdateResult )( 
            IInstallationResult * This,
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstallationResult **retval);
        
        END_INTERFACE
    } IInstallationResultVtbl;

    interface IInstallationResult
    {
        CONST_VTBL struct IInstallationResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationResult_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInstallationResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInstallationResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInstallationResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInstallationResult_get_HResult(This,retval)	\
    ( (This)->lpVtbl -> get_HResult(This,retval) ) 

#define IInstallationResult_get_RebootRequired(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequired(This,retval) ) 

#define IInstallationResult_get_ResultCode(This,retval)	\
    ( (This)->lpVtbl -> get_ResultCode(This,retval) ) 

#define IInstallationResult_GetUpdateResult(This,updateIndex,retval)	\
    ( (This)->lpVtbl -> GetUpdateResult(This,updateIndex,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationResult_INTERFACE_DEFINED__ */


#ifndef __IInstallationProgress_INTERFACE_DEFINED__
#define __IInstallationProgress_INTERFACE_DEFINED__

/* interface IInstallationProgress */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("345c8244-43a3-4e32-a368-65f073b76f36")
    IInstallationProgress : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentUpdateIndex( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentUpdatePercentComplete( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PercentComplete( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUpdateResult( 
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstallationResult **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationProgress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IInstallationProgress * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInstallationProgress * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IInstallationProgress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationProgress * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUpdateIndex )( 
            IInstallationProgress * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUpdatePercentComplete )( 
            IInstallationProgress * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PercentComplete )( 
            IInstallationProgress * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetUpdateResult )( 
            IInstallationProgress * This,
            /* [in] */ LONG updateIndex,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstallationResult **retval);
        
        END_INTERFACE
    } IInstallationProgressVtbl;

    interface IInstallationProgress
    {
        CONST_VTBL struct IInstallationProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationProgress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationProgress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationProgress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationProgress_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInstallationProgress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInstallationProgress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInstallationProgress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInstallationProgress_get_CurrentUpdateIndex(This,retval)	\
    ( (This)->lpVtbl -> get_CurrentUpdateIndex(This,retval) ) 

#define IInstallationProgress_get_CurrentUpdatePercentComplete(This,retval)	\
    ( (This)->lpVtbl -> get_CurrentUpdatePercentComplete(This,retval) ) 

#define IInstallationProgress_get_PercentComplete(This,retval)	\
    ( (This)->lpVtbl -> get_PercentComplete(This,retval) ) 

#define IInstallationProgress_GetUpdateResult(This,updateIndex,retval)	\
    ( (This)->lpVtbl -> GetUpdateResult(This,updateIndex,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationProgress_INTERFACE_DEFINED__ */


#ifndef __IInstallationJob_INTERFACE_DEFINED__
#define __IInstallationJob_INTERFACE_DEFINED__

/* interface IInstallationJob */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5c209f0b-bad5-432a-9556-4699bed2638a")
    IInstallationJob : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AsyncState( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsCompleted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Updates( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanUp( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [retval][out] */ __RPC__deref_out_opt IInstallationProgress **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IInstallationJob * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInstallationJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IInstallationJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AsyncState )( 
            IInstallationJob * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsCompleted )( 
            IInstallationJob * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            IInstallationJob * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CleanUp )( 
            IInstallationJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IInstallationJob * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationProgress **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestAbort )( 
            IInstallationJob * This);
        
        END_INTERFACE
    } IInstallationJobVtbl;

    interface IInstallationJob
    {
        CONST_VTBL struct IInstallationJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationJob_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationJob_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationJob_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationJob_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInstallationJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInstallationJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInstallationJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInstallationJob_get_AsyncState(This,retval)	\
    ( (This)->lpVtbl -> get_AsyncState(This,retval) ) 

#define IInstallationJob_get_IsCompleted(This,retval)	\
    ( (This)->lpVtbl -> get_IsCompleted(This,retval) ) 

#define IInstallationJob_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define IInstallationJob_CleanUp(This)	\
    ( (This)->lpVtbl -> CleanUp(This) ) 

#define IInstallationJob_GetProgress(This,retval)	\
    ( (This)->lpVtbl -> GetProgress(This,retval) ) 

#define IInstallationJob_RequestAbort(This)	\
    ( (This)->lpVtbl -> RequestAbort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationJob_INTERFACE_DEFINED__ */


#ifndef __IInstallationCompletedCallbackArgs_INTERFACE_DEFINED__
#define __IInstallationCompletedCallbackArgs_INTERFACE_DEFINED__

/* interface IInstallationCompletedCallbackArgs */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationCompletedCallbackArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("250e2106-8efb-4705-9653-ef13c581b6a1")
    IInstallationCompletedCallbackArgs : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInstallationCompletedCallbackArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationCompletedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationCompletedCallbackArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationCompletedCallbackArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IInstallationCompletedCallbackArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInstallationCompletedCallbackArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IInstallationCompletedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationCompletedCallbackArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IInstallationCompletedCallbackArgsVtbl;

    interface IInstallationCompletedCallbackArgs
    {
        CONST_VTBL struct IInstallationCompletedCallbackArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationCompletedCallbackArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationCompletedCallbackArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationCompletedCallbackArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationCompletedCallbackArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInstallationCompletedCallbackArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInstallationCompletedCallbackArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInstallationCompletedCallbackArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationCompletedCallbackArgs_INTERFACE_DEFINED__ */


#ifndef __IInstallationCompletedCallback_INTERFACE_DEFINED__
#define __IInstallationCompletedCallback_INTERFACE_DEFINED__

/* interface IInstallationCompletedCallback */
/* [unique][uuid][nonextensible][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationCompletedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45f4f6f3-d602-4f98-9a8a-3efa152ad2d3")
    IInstallationCompletedCallback : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ __RPC__in_opt IInstallationJob *installationJob,
            /* [in] */ __RPC__in_opt IInstallationCompletedCallbackArgs *callbackArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationCompletedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationCompletedCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationCompletedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationCompletedCallback * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationCompletedCallback * This,
            /* [in] */ __RPC__in_opt IInstallationJob *installationJob,
            /* [in] */ __RPC__in_opt IInstallationCompletedCallbackArgs *callbackArgs);
        
        END_INTERFACE
    } IInstallationCompletedCallbackVtbl;

    interface IInstallationCompletedCallback
    {
        CONST_VTBL struct IInstallationCompletedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationCompletedCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationCompletedCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationCompletedCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationCompletedCallback_Invoke(This,installationJob,callbackArgs)	\
    ( (This)->lpVtbl -> Invoke(This,installationJob,callbackArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationCompletedCallback_INTERFACE_DEFINED__ */


#ifndef __IInstallationProgressChangedCallbackArgs_INTERFACE_DEFINED__
#define __IInstallationProgressChangedCallbackArgs_INTERFACE_DEFINED__

/* interface IInstallationProgressChangedCallbackArgs */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationProgressChangedCallbackArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e4f14e1e-689d-4218-a0b9-bc189c484a01")
    IInstallationProgressChangedCallbackArgs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Progress( 
            /* [retval][out] */ __RPC__deref_out_opt IInstallationProgress **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationProgressChangedCallbackArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationProgressChangedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationProgressChangedCallbackArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationProgressChangedCallbackArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IInstallationProgressChangedCallbackArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInstallationProgressChangedCallbackArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IInstallationProgressChangedCallbackArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationProgressChangedCallbackArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IInstallationProgressChangedCallbackArgs * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationProgress **retval);
        
        END_INTERFACE
    } IInstallationProgressChangedCallbackArgsVtbl;

    interface IInstallationProgressChangedCallbackArgs
    {
        CONST_VTBL struct IInstallationProgressChangedCallbackArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationProgressChangedCallbackArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationProgressChangedCallbackArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationProgressChangedCallbackArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationProgressChangedCallbackArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInstallationProgressChangedCallbackArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInstallationProgressChangedCallbackArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInstallationProgressChangedCallbackArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInstallationProgressChangedCallbackArgs_get_Progress(This,retval)	\
    ( (This)->lpVtbl -> get_Progress(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationProgressChangedCallbackArgs_INTERFACE_DEFINED__ */


#ifndef __IInstallationProgressChangedCallback_INTERFACE_DEFINED__
#define __IInstallationProgressChangedCallback_INTERFACE_DEFINED__

/* interface IInstallationProgressChangedCallback */
/* [unique][uuid][nonextensible][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationProgressChangedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e01402d5-f8da-43ba-a012-38894bd048f1")
    IInstallationProgressChangedCallback : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ __RPC__in_opt IInstallationJob *installationJob,
            /* [in] */ __RPC__in_opt IInstallationProgressChangedCallbackArgs *callbackArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationProgressChangedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallationProgressChangedCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallationProgressChangedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallationProgressChangedCallback * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationProgressChangedCallback * This,
            /* [in] */ __RPC__in_opt IInstallationJob *installationJob,
            /* [in] */ __RPC__in_opt IInstallationProgressChangedCallbackArgs *callbackArgs);
        
        END_INTERFACE
    } IInstallationProgressChangedCallbackVtbl;

    interface IInstallationProgressChangedCallback
    {
        CONST_VTBL struct IInstallationProgressChangedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationProgressChangedCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationProgressChangedCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationProgressChangedCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationProgressChangedCallback_Invoke(This,installationJob,callbackArgs)	\
    ( (This)->lpVtbl -> Invoke(This,installationJob,callbackArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationProgressChangedCallback_INTERFACE_DEFINED__ */


#ifndef __IUpdateInstaller_INTERFACE_DEFINED__
#define __IUpdateInstaller_INTERFACE_DEFINED__

/* interface IUpdateInstaller */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateInstaller;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7b929c68-ccdc-4226-96b1-8724600b54c2")
    IUpdateInstaller : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientApplicationID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsForced( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsForced( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get_ParentHwnd( 
            /* [retval][out] */ __RPC__deref_out_opt HWND *retval) = 0;
        
        virtual /* [helpstring][restricted][propput][id] */ HRESULT STDMETHODCALLTYPE put_ParentHwnd( 
            /* [unique][in] */ __RPC__in_opt HWND value) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ParentWindow( 
            /* [unique][in] */ __RPC__in_opt IUnknown *value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ParentWindow( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Updates( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Updates( 
            /* [in] */ __RPC__in_opt IUpdateCollection *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginInstall( 
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginUninstall( 
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndInstall( 
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndUninstall( 
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Install( 
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RunWizard( 
            /* [defaultvalue][in] */ __RPC__in BSTR dialogTitle,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsBusy( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Uninstall( 
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowSourcePrompts( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowSourcePrompts( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RebootRequiredBeforeInstallation( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateInstallerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateInstaller * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateInstaller * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateInstaller * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateInstaller * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateInstaller * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsForced )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsForced )( 
            IUpdateInstaller * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ParentHwnd )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt HWND *retval);
        
        /* [helpstring][restricted][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ParentHwnd )( 
            IUpdateInstaller * This,
            /* [unique][in] */ __RPC__in_opt HWND value);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IUpdateInstaller * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Updates )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in_opt IUpdateCollection *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginInstall )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginUninstall )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndInstall )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndUninstall )( 
            IUpdateInstaller * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Install )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RunWizard )( 
            IUpdateInstaller * This,
            /* [defaultvalue][in] */ __RPC__in BSTR dialogTitle,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBusy )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Uninstall )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowSourcePrompts )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowSourcePrompts )( 
            IUpdateInstaller * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequiredBeforeInstallation )( 
            IUpdateInstaller * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IUpdateInstallerVtbl;

    interface IUpdateInstaller
    {
        CONST_VTBL struct IUpdateInstallerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateInstaller_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateInstaller_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateInstaller_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateInstaller_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateInstaller_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateInstaller_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateInstaller_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateInstaller_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateInstaller_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateInstaller_get_IsForced(This,retval)	\
    ( (This)->lpVtbl -> get_IsForced(This,retval) ) 

#define IUpdateInstaller_put_IsForced(This,value)	\
    ( (This)->lpVtbl -> put_IsForced(This,value) ) 

#define IUpdateInstaller_get_ParentHwnd(This,retval)	\
    ( (This)->lpVtbl -> get_ParentHwnd(This,retval) ) 

#define IUpdateInstaller_put_ParentHwnd(This,value)	\
    ( (This)->lpVtbl -> put_ParentHwnd(This,value) ) 

#define IUpdateInstaller_put_ParentWindow(This,value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,value) ) 

#define IUpdateInstaller_get_ParentWindow(This,retval)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,retval) ) 

#define IUpdateInstaller_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define IUpdateInstaller_put_Updates(This,value)	\
    ( (This)->lpVtbl -> put_Updates(This,value) ) 

#define IUpdateInstaller_BeginInstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginInstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller_BeginUninstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginUninstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller_EndInstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndInstall(This,value,retval) ) 

#define IUpdateInstaller_EndUninstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndUninstall(This,value,retval) ) 

#define IUpdateInstaller_Install(This,retval)	\
    ( (This)->lpVtbl -> Install(This,retval) ) 

#define IUpdateInstaller_RunWizard(This,dialogTitle,retval)	\
    ( (This)->lpVtbl -> RunWizard(This,dialogTitle,retval) ) 

#define IUpdateInstaller_get_IsBusy(This,retval)	\
    ( (This)->lpVtbl -> get_IsBusy(This,retval) ) 

#define IUpdateInstaller_Uninstall(This,retval)	\
    ( (This)->lpVtbl -> Uninstall(This,retval) ) 

#define IUpdateInstaller_get_AllowSourcePrompts(This,retval)	\
    ( (This)->lpVtbl -> get_AllowSourcePrompts(This,retval) ) 

#define IUpdateInstaller_put_AllowSourcePrompts(This,value)	\
    ( (This)->lpVtbl -> put_AllowSourcePrompts(This,value) ) 

#define IUpdateInstaller_get_RebootRequiredBeforeInstallation(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequiredBeforeInstallation(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateInstaller_INTERFACE_DEFINED__ */


#ifndef __IUpdateInstaller2_INTERFACE_DEFINED__
#define __IUpdateInstaller2_INTERFACE_DEFINED__

/* interface IUpdateInstaller2 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateInstaller2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3442d4fe-224d-4cee-98cf-30e0c4d229e6")
    IUpdateInstaller2 : public IUpdateInstaller
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForceQuiet( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForceQuiet( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateInstaller2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateInstaller2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateInstaller2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateInstaller2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateInstaller2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateInstaller2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsForced )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsForced )( 
            IUpdateInstaller2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ParentHwnd )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt HWND *retval);
        
        /* [helpstring][restricted][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ParentHwnd )( 
            IUpdateInstaller2 * This,
            /* [unique][in] */ __RPC__in_opt HWND value);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IUpdateInstaller2 * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Updates )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IUpdateCollection *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginInstall )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginUninstall )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndInstall )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndUninstall )( 
            IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Install )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RunWizard )( 
            IUpdateInstaller2 * This,
            /* [defaultvalue][in] */ __RPC__in BSTR dialogTitle,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBusy )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Uninstall )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowSourcePrompts )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowSourcePrompts )( 
            IUpdateInstaller2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequiredBeforeInstallation )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForceQuiet )( 
            IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForceQuiet )( 
            IUpdateInstaller2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        END_INTERFACE
    } IUpdateInstaller2Vtbl;

    interface IUpdateInstaller2
    {
        CONST_VTBL struct IUpdateInstaller2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateInstaller2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateInstaller2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateInstaller2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateInstaller2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateInstaller2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateInstaller2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateInstaller2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateInstaller2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateInstaller2_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateInstaller2_get_IsForced(This,retval)	\
    ( (This)->lpVtbl -> get_IsForced(This,retval) ) 

#define IUpdateInstaller2_put_IsForced(This,value)	\
    ( (This)->lpVtbl -> put_IsForced(This,value) ) 

#define IUpdateInstaller2_get_ParentHwnd(This,retval)	\
    ( (This)->lpVtbl -> get_ParentHwnd(This,retval) ) 

#define IUpdateInstaller2_put_ParentHwnd(This,value)	\
    ( (This)->lpVtbl -> put_ParentHwnd(This,value) ) 

#define IUpdateInstaller2_put_ParentWindow(This,value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,value) ) 

#define IUpdateInstaller2_get_ParentWindow(This,retval)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,retval) ) 

#define IUpdateInstaller2_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define IUpdateInstaller2_put_Updates(This,value)	\
    ( (This)->lpVtbl -> put_Updates(This,value) ) 

#define IUpdateInstaller2_BeginInstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginInstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller2_BeginUninstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginUninstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller2_EndInstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndInstall(This,value,retval) ) 

#define IUpdateInstaller2_EndUninstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndUninstall(This,value,retval) ) 

#define IUpdateInstaller2_Install(This,retval)	\
    ( (This)->lpVtbl -> Install(This,retval) ) 

#define IUpdateInstaller2_RunWizard(This,dialogTitle,retval)	\
    ( (This)->lpVtbl -> RunWizard(This,dialogTitle,retval) ) 

#define IUpdateInstaller2_get_IsBusy(This,retval)	\
    ( (This)->lpVtbl -> get_IsBusy(This,retval) ) 

#define IUpdateInstaller2_Uninstall(This,retval)	\
    ( (This)->lpVtbl -> Uninstall(This,retval) ) 

#define IUpdateInstaller2_get_AllowSourcePrompts(This,retval)	\
    ( (This)->lpVtbl -> get_AllowSourcePrompts(This,retval) ) 

#define IUpdateInstaller2_put_AllowSourcePrompts(This,value)	\
    ( (This)->lpVtbl -> put_AllowSourcePrompts(This,value) ) 

#define IUpdateInstaller2_get_RebootRequiredBeforeInstallation(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequiredBeforeInstallation(This,retval) ) 


#define IUpdateInstaller2_get_ForceQuiet(This,retval)	\
    ( (This)->lpVtbl -> get_ForceQuiet(This,retval) ) 

#define IUpdateInstaller2_put_ForceQuiet(This,value)	\
    ( (This)->lpVtbl -> put_ForceQuiet(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateInstaller2_INTERFACE_DEFINED__ */


#ifndef __IUpdateSession_INTERFACE_DEFINED__
#define __IUpdateSession_INTERFACE_DEFINED__

/* interface IUpdateSession */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("816858a4-260d-4260-933a-2585f1abc76b")
    IUpdateSession : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientApplicationID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WebProxy( 
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WebProxy( 
            /* [unique][in] */ __RPC__in_opt IWebProxy *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateSearcher( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateDownloader( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateInstaller( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateSession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateSession * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IUpdateSession * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WebProxy )( 
            IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WebProxy )( 
            IUpdateSession * This,
            /* [unique][in] */ __RPC__in_opt IWebProxy *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateSearcher )( 
            IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateDownloader )( 
            IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateInstaller )( 
            IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval);
        
        END_INTERFACE
    } IUpdateSessionVtbl;

    interface IUpdateSession
    {
        CONST_VTBL struct IUpdateSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSession_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSession_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSession_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IUpdateSession_get_WebProxy(This,retval)	\
    ( (This)->lpVtbl -> get_WebProxy(This,retval) ) 

#define IUpdateSession_put_WebProxy(This,value)	\
    ( (This)->lpVtbl -> put_WebProxy(This,value) ) 

#define IUpdateSession_CreateUpdateSearcher(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateSearcher(This,retval) ) 

#define IUpdateSession_CreateUpdateDownloader(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateDownloader(This,retval) ) 

#define IUpdateSession_CreateUpdateInstaller(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateInstaller(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSession_INTERFACE_DEFINED__ */


#ifndef __IUpdateSession2_INTERFACE_DEFINED__
#define __IUpdateSession2_INTERFACE_DEFINED__

/* interface IUpdateSession2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSession2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91caf7b0-eb23-49ed-9937-c52d817f46f7")
    IUpdateSession2 : public IUpdateSession
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserLocale( 
            /* [retval][out] */ __RPC__out LCID *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UserLocale( 
            /* [in] */ LCID lcid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSession2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateSession2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateSession2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateSession2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateSession2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateSession2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSession2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateSession2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IUpdateSession2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WebProxy )( 
            IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WebProxy )( 
            IUpdateSession2 * This,
            /* [unique][in] */ __RPC__in_opt IWebProxy *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateSearcher )( 
            IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateDownloader )( 
            IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateInstaller )( 
            IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UserLocale )( 
            IUpdateSession2 * This,
            /* [retval][out] */ __RPC__out LCID *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UserLocale )( 
            IUpdateSession2 * This,
            /* [in] */ LCID lcid);
        
        END_INTERFACE
    } IUpdateSession2Vtbl;

    interface IUpdateSession2
    {
        CONST_VTBL struct IUpdateSession2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSession2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSession2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSession2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSession2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSession2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSession2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSession2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSession2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSession2_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSession2_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IUpdateSession2_get_WebProxy(This,retval)	\
    ( (This)->lpVtbl -> get_WebProxy(This,retval) ) 

#define IUpdateSession2_put_WebProxy(This,value)	\
    ( (This)->lpVtbl -> put_WebProxy(This,value) ) 

#define IUpdateSession2_CreateUpdateSearcher(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateSearcher(This,retval) ) 

#define IUpdateSession2_CreateUpdateDownloader(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateDownloader(This,retval) ) 

#define IUpdateSession2_CreateUpdateInstaller(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateInstaller(This,retval) ) 


#define IUpdateSession2_get_UserLocale(This,retval)	\
    ( (This)->lpVtbl -> get_UserLocale(This,retval) ) 

#define IUpdateSession2_put_UserLocale(This,lcid)	\
    ( (This)->lpVtbl -> put_UserLocale(This,lcid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSession2_INTERFACE_DEFINED__ */


#ifndef __IUpdateSession3_INTERFACE_DEFINED__
#define __IUpdateSession3_INTERFACE_DEFINED__

/* interface IUpdateSession3 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSession3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("918EFD1E-B5D8-4c90-8540-AEB9BDC56F9D")
    IUpdateSession3 : public IUpdateSession2
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateServiceManager( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceManager2 **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryHistory( 
            /* [in] */ __RPC__in BSTR criteria,
            /* [in] */ LONG startIndex,
            /* [in] */ LONG count,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntryCollection **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSession3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateSession3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateSession3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateSession3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateSession3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateSession3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateSession3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSession3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateSession3 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WebProxy )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WebProxy )( 
            IUpdateSession3 * This,
            /* [unique][in] */ __RPC__in_opt IWebProxy *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateSearcher )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateDownloader )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateInstaller )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UserLocale )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__out LCID *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UserLocale )( 
            IUpdateSession3 * This,
            /* [in] */ LCID lcid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateServiceManager )( 
            IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceManager2 **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryHistory )( 
            IUpdateSession3 * This,
            /* [in] */ __RPC__in BSTR criteria,
            /* [in] */ LONG startIndex,
            /* [in] */ LONG count,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntryCollection **retval);
        
        END_INTERFACE
    } IUpdateSession3Vtbl;

    interface IUpdateSession3
    {
        CONST_VTBL struct IUpdateSession3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSession3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSession3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSession3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSession3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSession3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSession3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSession3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSession3_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSession3_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSession3_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IUpdateSession3_get_WebProxy(This,retval)	\
    ( (This)->lpVtbl -> get_WebProxy(This,retval) ) 

#define IUpdateSession3_put_WebProxy(This,value)	\
    ( (This)->lpVtbl -> put_WebProxy(This,value) ) 

#define IUpdateSession3_CreateUpdateSearcher(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateSearcher(This,retval) ) 

#define IUpdateSession3_CreateUpdateDownloader(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateDownloader(This,retval) ) 

#define IUpdateSession3_CreateUpdateInstaller(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateInstaller(This,retval) ) 


#define IUpdateSession3_get_UserLocale(This,retval)	\
    ( (This)->lpVtbl -> get_UserLocale(This,retval) ) 

#define IUpdateSession3_put_UserLocale(This,lcid)	\
    ( (This)->lpVtbl -> put_UserLocale(This,lcid) ) 


#define IUpdateSession3_CreateUpdateServiceManager(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateServiceManager(This,retval) ) 

#define IUpdateSession3_QueryHistory(This,criteria,startIndex,count,retval)	\
    ( (This)->lpVtbl -> QueryHistory(This,criteria,startIndex,count,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSession3_INTERFACE_DEFINED__ */


#ifndef __IUpdateService_INTERFACE_DEFINED__
#define __IUpdateService_INTERFACE_DEFINED__

/* interface IUpdateService */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76b3b17e-aed6-4da5-85f0-83587f81abe3")
    IUpdateService : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentValidationCert( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExpirationDate( 
            /* [retval][out] */ __RPC__out DATE *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsManaged( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsRegisteredWithAU( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IssueDate( 
            /* [retval][out] */ __RPC__out DATE *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OffersWindowsUpdates( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RedirectUrls( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsScanPackageService( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanRegisterWithAU( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceUrl( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SetupPrefix( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateService * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContentValidationCert )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationDate )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsManaged )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsRegisteredWithAU )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IssueDate )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OffersWindowsUpdates )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectUrls )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsScanPackageService )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRegisterWithAU )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceUrl )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SetupPrefix )( 
            IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        END_INTERFACE
    } IUpdateServiceVtbl;

    interface IUpdateService
    {
        CONST_VTBL struct IUpdateServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateService_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateService_get_Name(This,retval)	\
    ( (This)->lpVtbl -> get_Name(This,retval) ) 

#define IUpdateService_get_ContentValidationCert(This,retval)	\
    ( (This)->lpVtbl -> get_ContentValidationCert(This,retval) ) 

#define IUpdateService_get_ExpirationDate(This,retval)	\
    ( (This)->lpVtbl -> get_ExpirationDate(This,retval) ) 

#define IUpdateService_get_IsManaged(This,retval)	\
    ( (This)->lpVtbl -> get_IsManaged(This,retval) ) 

#define IUpdateService_get_IsRegisteredWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_IsRegisteredWithAU(This,retval) ) 

#define IUpdateService_get_IssueDate(This,retval)	\
    ( (This)->lpVtbl -> get_IssueDate(This,retval) ) 

#define IUpdateService_get_OffersWindowsUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_OffersWindowsUpdates(This,retval) ) 

#define IUpdateService_get_RedirectUrls(This,retval)	\
    ( (This)->lpVtbl -> get_RedirectUrls(This,retval) ) 

#define IUpdateService_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateService_get_IsScanPackageService(This,retval)	\
    ( (This)->lpVtbl -> get_IsScanPackageService(This,retval) ) 

#define IUpdateService_get_CanRegisterWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_CanRegisterWithAU(This,retval) ) 

#define IUpdateService_get_ServiceUrl(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceUrl(This,retval) ) 

#define IUpdateService_get_SetupPrefix(This,retval)	\
    ( (This)->lpVtbl -> get_SetupPrefix(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateService_INTERFACE_DEFINED__ */


#ifndef __IUpdateService2_INTERFACE_DEFINED__
#define __IUpdateService2_INTERFACE_DEFINED__

/* interface IUpdateService2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateService2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1518b460-6518-4172-940f-c75883b24ceb")
    IUpdateService2 : public IUpdateService
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDefaultAUService( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateService2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateService2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateService2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateService2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateService2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateService2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateService2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContentValidationCert )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationDate )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsManaged )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsRegisteredWithAU )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IssueDate )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OffersWindowsUpdates )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectUrls )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsScanPackageService )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRegisterWithAU )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceUrl )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SetupPrefix )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDefaultAUService )( 
            IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IUpdateService2Vtbl;

    interface IUpdateService2
    {
        CONST_VTBL struct IUpdateService2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateService2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateService2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateService2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateService2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateService2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateService2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateService2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateService2_get_Name(This,retval)	\
    ( (This)->lpVtbl -> get_Name(This,retval) ) 

#define IUpdateService2_get_ContentValidationCert(This,retval)	\
    ( (This)->lpVtbl -> get_ContentValidationCert(This,retval) ) 

#define IUpdateService2_get_ExpirationDate(This,retval)	\
    ( (This)->lpVtbl -> get_ExpirationDate(This,retval) ) 

#define IUpdateService2_get_IsManaged(This,retval)	\
    ( (This)->lpVtbl -> get_IsManaged(This,retval) ) 

#define IUpdateService2_get_IsRegisteredWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_IsRegisteredWithAU(This,retval) ) 

#define IUpdateService2_get_IssueDate(This,retval)	\
    ( (This)->lpVtbl -> get_IssueDate(This,retval) ) 

#define IUpdateService2_get_OffersWindowsUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_OffersWindowsUpdates(This,retval) ) 

#define IUpdateService2_get_RedirectUrls(This,retval)	\
    ( (This)->lpVtbl -> get_RedirectUrls(This,retval) ) 

#define IUpdateService2_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateService2_get_IsScanPackageService(This,retval)	\
    ( (This)->lpVtbl -> get_IsScanPackageService(This,retval) ) 

#define IUpdateService2_get_CanRegisterWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_CanRegisterWithAU(This,retval) ) 

#define IUpdateService2_get_ServiceUrl(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceUrl(This,retval) ) 

#define IUpdateService2_get_SetupPrefix(This,retval)	\
    ( (This)->lpVtbl -> get_SetupPrefix(This,retval) ) 


#define IUpdateService2_get_IsDefaultAUService(This,retval)	\
    ( (This)->lpVtbl -> get_IsDefaultAUService(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateService2_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceCollection_INTERFACE_DEFINED__
#define __IUpdateServiceCollection_INTERFACE_DEFINED__

/* interface IUpdateServiceCollection */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b0353aa-0e52-44ff-b8b0-1f7fa0437f88")
    IUpdateServiceCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateServiceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateServiceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateServiceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateServiceCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateServiceCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateServiceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IUpdateServiceCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IUpdateServiceCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IUpdateServiceCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IUpdateServiceCollectionVtbl;

    interface IUpdateServiceCollection
    {
        CONST_VTBL struct IUpdateServiceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define IUpdateServiceCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IUpdateServiceCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceCollection_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceRegistration_INTERFACE_DEFINED__
#define __IUpdateServiceRegistration_INTERFACE_DEFINED__

/* interface IUpdateServiceRegistration */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceRegistration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dde02280-12b3-4e0b-937b-6747f6acb286")
    IUpdateServiceRegistration : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RegistrationState( 
            /* [retval][out] */ __RPC__out UpdateServiceRegistrationState *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsPendingRegistrationWithAU( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Service( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService2 **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceRegistrationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateServiceRegistration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateServiceRegistration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateServiceRegistration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateServiceRegistration * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateServiceRegistration * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateServiceRegistration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceRegistration * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RegistrationState )( 
            IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__out UpdateServiceRegistrationState *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsPendingRegistrationWithAU )( 
            IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Service )( 
            IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService2 **retval);
        
        END_INTERFACE
    } IUpdateServiceRegistrationVtbl;

    interface IUpdateServiceRegistration
    {
        CONST_VTBL struct IUpdateServiceRegistrationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceRegistration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceRegistration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceRegistration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceRegistration_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceRegistration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceRegistration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceRegistration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceRegistration_get_RegistrationState(This,retval)	\
    ( (This)->lpVtbl -> get_RegistrationState(This,retval) ) 

#define IUpdateServiceRegistration_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateServiceRegistration_get_IsPendingRegistrationWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_IsPendingRegistrationWithAU(This,retval) ) 

#define IUpdateServiceRegistration_get_Service(This,retval)	\
    ( (This)->lpVtbl -> get_Service(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceRegistration_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceManager_INTERFACE_DEFINED__
#define __IUpdateServiceManager_INTERFACE_DEFINED__

/* interface IUpdateServiceManager */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23857e3c-02ba-44a3-9423-b1c900805f37")
    IUpdateServiceManager : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Services( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddService( 
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterServiceWithAU( 
            /* [in] */ __RPC__in BSTR serviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveService( 
            /* [in] */ __RPC__in BSTR serviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterServiceWithAU( 
            /* [in] */ __RPC__in BSTR serviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddScanPackageService( 
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR scanFileLocation,
            /* [defaultvalue][in] */ LONG flags,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **ppService) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ __RPC__in BSTR optionName,
            /* [in] */ VARIANT optionValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateServiceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateServiceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateServiceManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateServiceManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            IUpdateServiceManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddService )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterServiceWithAU )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveService )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterServiceWithAU )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddScanPackageService )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR scanFileLocation,
            /* [defaultvalue][in] */ LONG flags,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **ppService);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR optionName,
            /* [in] */ VARIANT optionValue);
        
        END_INTERFACE
    } IUpdateServiceManagerVtbl;

    interface IUpdateServiceManager
    {
        CONST_VTBL struct IUpdateServiceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceManager_get_Services(This,retval)	\
    ( (This)->lpVtbl -> get_Services(This,retval) ) 

#define IUpdateServiceManager_AddService(This,serviceID,authorizationCabPath,retval)	\
    ( (This)->lpVtbl -> AddService(This,serviceID,authorizationCabPath,retval) ) 

#define IUpdateServiceManager_RegisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> RegisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager_RemoveService(This,serviceID)	\
    ( (This)->lpVtbl -> RemoveService(This,serviceID) ) 

#define IUpdateServiceManager_UnregisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> UnregisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager_AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService)	\
    ( (This)->lpVtbl -> AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService) ) 

#define IUpdateServiceManager_SetOption(This,optionName,optionValue)	\
    ( (This)->lpVtbl -> SetOption(This,optionName,optionValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceManager_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceManager2_INTERFACE_DEFINED__
#define __IUpdateServiceManager2_INTERFACE_DEFINED__

/* interface IUpdateServiceManager2 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0bb8531d-7e8d-424f-986c-a0b8f60a3e7b")
    IUpdateServiceManager2 : public IUpdateServiceManager
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientApplicationID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryServiceRegistration( 
            /* [in] */ __RPC__in BSTR serviceID,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddService2( 
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ LONG flags,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateServiceManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateServiceManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IUpdateServiceManager2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IUpdateServiceManager2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceManager2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            IUpdateServiceManager2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddService )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterServiceWithAU )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveService )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterServiceWithAU )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddScanPackageService )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR scanFileLocation,
            /* [defaultvalue][in] */ LONG flags,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **ppService);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR optionName,
            /* [in] */ VARIANT optionValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            IUpdateServiceManager2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryServiceRegistration )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddService2 )( 
            IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ LONG flags,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval);
        
        END_INTERFACE
    } IUpdateServiceManager2Vtbl;

    interface IUpdateServiceManager2
    {
        CONST_VTBL struct IUpdateServiceManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceManager2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceManager2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceManager2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceManager2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceManager2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceManager2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceManager2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceManager2_get_Services(This,retval)	\
    ( (This)->lpVtbl -> get_Services(This,retval) ) 

#define IUpdateServiceManager2_AddService(This,serviceID,authorizationCabPath,retval)	\
    ( (This)->lpVtbl -> AddService(This,serviceID,authorizationCabPath,retval) ) 

#define IUpdateServiceManager2_RegisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> RegisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager2_RemoveService(This,serviceID)	\
    ( (This)->lpVtbl -> RemoveService(This,serviceID) ) 

#define IUpdateServiceManager2_UnregisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> UnregisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager2_AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService)	\
    ( (This)->lpVtbl -> AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService) ) 

#define IUpdateServiceManager2_SetOption(This,optionName,optionValue)	\
    ( (This)->lpVtbl -> SetOption(This,optionName,optionValue) ) 


#define IUpdateServiceManager2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateServiceManager2_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateServiceManager2_QueryServiceRegistration(This,serviceID,retval)	\
    ( (This)->lpVtbl -> QueryServiceRegistration(This,serviceID,retval) ) 

#define IUpdateServiceManager2_AddService2(This,serviceID,flags,authorizationCabPath,retval)	\
    ( (This)->lpVtbl -> AddService2(This,serviceID,flags,authorizationCabPath,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceManager2_INTERFACE_DEFINED__ */



#ifndef __WUApiLib_LIBRARY_DEFINED__
#define __WUApiLib_LIBRARY_DEFINED__

/* library WUApiLib */
/* [helpstring][version][uuid] */ 

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateLockdownOption
    {	uloForWebsiteAccess	= 0x1
    } 	UpdateLockdownOption;

typedef /* [v1_enum][helpstring][public] */ 
enum tagAddServiceFlag
    {	asfAllowPendingRegistration	= 0x1,
	asfAllowOnlineRegistration	= 0x2,
	asfRegisterServiceWithAU	= 0x4
    } 	AddServiceFlag;

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateServiceOption
    {	usoNonVolatileService	= 0x1
    } 	UpdateServiceOption;

















EXTERN_C const IID LIBID_WUApiLib;

EXTERN_C const CLSID CLSID_StringCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("72C97D74-7C3B-40AE-B77D-ABDB22EBA6FB")
StringCollection;
#endif

EXTERN_C const CLSID CLSID_UpdateSearcher;

#ifdef __cplusplus

class DECLSPEC_UUID("B699E5E8-67FF-4177-88B0-3684A3388BFB")
UpdateSearcher;
#endif

EXTERN_C const CLSID CLSID_WebProxy;

#ifdef __cplusplus

class DECLSPEC_UUID("650503cf-9108-4ddc-a2ce-6c2341e1c582")
WebProxy;
#endif

EXTERN_C const CLSID CLSID_SystemInformation;

#ifdef __cplusplus

class DECLSPEC_UUID("C01B9BA0-BEA7-41BA-B604-D0A36F469133")
SystemInformation;
#endif

EXTERN_C const CLSID CLSID_WindowsUpdateAgentInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("C2E88C2F-6F5B-4AAA-894B-55C847AD3A2D")
WindowsUpdateAgentInfo;
#endif

EXTERN_C const CLSID CLSID_AutomaticUpdates;

#ifdef __cplusplus

class DECLSPEC_UUID("BFE18E9C-6D87-4450-B37C-E02F0B373803")
AutomaticUpdates;
#endif

EXTERN_C const CLSID CLSID_UpdateCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("13639463-00DB-4646-803D-528026140D88")
UpdateCollection;
#endif

EXTERN_C const CLSID CLSID_UpdateDownloader;

#ifdef __cplusplus

class DECLSPEC_UUID("5BAF654A-5A07-4264-A255-9FF54C7151E7")
UpdateDownloader;
#endif

EXTERN_C const CLSID CLSID_UpdateInstaller;

#ifdef __cplusplus

class DECLSPEC_UUID("D2E0FE7F-D23E-48E1-93C0-6FA8CC346474")
UpdateInstaller;
#endif

EXTERN_C const CLSID CLSID_UpdateSession;

#ifdef __cplusplus

class DECLSPEC_UUID("4CB43D7F-7EEE-4906-8698-60DA1C38F2FE")
UpdateSession;
#endif

EXTERN_C const CLSID CLSID_UpdateServiceManager;

#ifdef __cplusplus

class DECLSPEC_UUID("F8D253D9-89A4-4DAA-87B6-1168369F0B21")
UpdateServiceManager;
#endif
#endif /* __WUApiLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\XmlDsodid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDSODID_H__
#define __XMLDSODID_H__
//;end_internal

#define  DISPID_XMLDSO                       0x00010000
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1

//;begin_internal
#endif // __XMLDSODID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\XCMCExt.h ===
/*
 *  XCMCEXT.H
 *  
 *  Purpose:
 *  Specifies constants and data structures for CMC Common extensions
 *  
 */

#ifndef _XCMCEXT_H
#define _XCMCEXT_H

#ifdef __cplusplus
extern "C" {
#endif

/* COMMON EXTENSIONS DECLARATIONS */

#define CMC_XS_COM                  ((CMC_uint32) 0)

/* FUNCTION EXTENSIONS */

/* Query for extension support in implementation */
#define CMC_X_COM_SUPPORT_EXT       ((CMC_uint32) 16)

typedef struct {
    CMC_uint32  item_code;
    CMC_flags   flags;
} CMC_X_COM_support;

#define CMC_X_COM_SUPPORTED             ((CMC_flags) 1)
#define CMC_X_COM_NOT_SUPPORTED         ((CMC_flags) 2)
#define CMC_X_COM_DATA_EXT_SUPPORTED    ((CMC_flags) 4)
#define CMC_X_COM_FUNC_EXT_SUPPORTED    ((CMC_flags) 8)
#define CMC_X_COM_SUP_EXCLUDE           ((CMC_flags) 16)

/* Get back a structure with configuration data */

#define CMC_X_COM_CONFIG_DATA       ((CMC_uint32) 17)

typedef struct {
    CMC_uint16              ver_spec;
    CMC_uint16              ver_implem;
    CMC_object_identifier FAR *character_set;
    CMC_enum                line_term;
    CMC_string              default_service;
    CMC_string              default_user;
    CMC_enum                req_password;
    CMC_enum                req_service;
    CMC_enum                req_user;
    CMC_boolean             ui_avail;
    CMC_boolean             sup_nomkmsgread;
    CMC_boolean             sup_counted_str;
} CMC_X_COM_configuration;


/* Check to see if/when a recipient can be sent */
#define CMC_X_COM_CAN_SEND_RECIP    ((CMC_uint32) 18)

#define CMC_X_COM_READY             ((CMC_enum) 0)
#define CMC_X_COM_NOT_READY         ((CMC_enum) 1)
#define CMC_X_COM_DEFER             ((CMC_enum) 2)

/* Save a message to the inbox */

#define CMC_X_COM_SAVE_MESSAGE      ((CMC_uint32) 19)

/* Get back a message structure for the message just sent */

#define CMC_X_COM_SENT_MESSAGE      ((CMC_uint32) 20)

/* DATA EXTENSIONS */

/* attach a receive date to message and message summary structures */
#define CMC_X_COM_TIME_RECEIVED     ((CMC_uint32) 128)

/* attach a unique id to resolved recipient structures */
#define CMC_X_COM_RECIP_ID          ((CMC_uint32) 129)

/* set character position in the message text to display an icon
   associated with a particular attachment */

#define CMC_X_COM_ATTACH_CHARPOS    ((CMC_uint32) 130)

#define CMC_X_COM_PRIORITY          ((CMC_uint32) 131)

#define CMC_X_COM_NORMAL            ((CMC_enum) 0)
#define CMC_X_COM_URGENT            ((CMC_enum) 1)
#define CMC_X_COM_LOW               ((CMC_enum) 2)

#ifdef __cplusplus
}       /* extern "C" */
#endif

#endif  /* _XCMCEXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\xmldom.h ===
//***************************************************************************** 
// 
// Microsoft Windows Media 
// Copyright (C) Microsoft Corporation. All rights reserved. 
//
// FileName:            xmldom.h
//
// Abstract:
//
//*****************************************************************************

#pragma once

//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation
//
//  File:       XMLDom.h
//
//  Contents:
//
//--------------------------------------------------------------------------

//
// This file is needed because we need to import "xmldom.idl" in several
// of our idl files. Thus the .h files generated by MIDL includes "xmldom.h"
// But xmldom.h does not exist in the platform SDK. However, msxml.h exists
// in the SDK with all the definitions needed by xmldom.h. Thus, the work
// around is to simply create this xmldom.h file that merely includes msxml.h
//
#include "msxml.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\xenroll.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0494 */
/* Compiler settings for xenroll.idl:
    Oicf, W1, Zp8, env=Win64 (32b run)
    protocol : all , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xenroll_h__
#define __xenroll_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICEnroll_FWD_DEFINED__
#define __ICEnroll_FWD_DEFINED__
typedef interface ICEnroll ICEnroll;
#endif 	/* __ICEnroll_FWD_DEFINED__ */


#ifndef __ICEnroll2_FWD_DEFINED__
#define __ICEnroll2_FWD_DEFINED__
typedef interface ICEnroll2 ICEnroll2;
#endif 	/* __ICEnroll2_FWD_DEFINED__ */


#ifndef __ICEnroll3_FWD_DEFINED__
#define __ICEnroll3_FWD_DEFINED__
typedef interface ICEnroll3 ICEnroll3;
#endif 	/* __ICEnroll3_FWD_DEFINED__ */


#ifndef __ICEnroll4_FWD_DEFINED__
#define __ICEnroll4_FWD_DEFINED__
typedef interface ICEnroll4 ICEnroll4;
#endif 	/* __ICEnroll4_FWD_DEFINED__ */


#ifndef __IEnroll_FWD_DEFINED__
#define __IEnroll_FWD_DEFINED__
typedef interface IEnroll IEnroll;
#endif 	/* __IEnroll_FWD_DEFINED__ */


#ifndef __IEnroll2_FWD_DEFINED__
#define __IEnroll2_FWD_DEFINED__
typedef interface IEnroll2 IEnroll2;
#endif 	/* __IEnroll2_FWD_DEFINED__ */


#ifndef __IEnroll4_FWD_DEFINED__
#define __IEnroll4_FWD_DEFINED__
typedef interface IEnroll4 IEnroll4;
#endif 	/* __IEnroll4_FWD_DEFINED__ */


#ifndef __CEnroll2_FWD_DEFINED__
#define __CEnroll2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEnroll2 CEnroll2;
#else
typedef struct CEnroll2 CEnroll2;
#endif /* __cplusplus */

#endif 	/* __CEnroll2_FWD_DEFINED__ */


#ifndef __CEnroll_FWD_DEFINED__
#define __CEnroll_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEnroll CEnroll;
#else
typedef struct CEnroll CEnroll;
#endif /* __cplusplus */

#endif 	/* __CEnroll_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wincrypt.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ICEnroll_INTERFACE_DEFINED__
#define __ICEnroll_INTERFACE_DEFINED__

/* interface ICEnroll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43F8F288-7A20-11D0-8F06-00C04FC295E1")
    ICEnroll : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10( 
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7( 
            /* [in] */ __RPC__in BSTR wszPKCS7FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10( 
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7( 
            /* [in] */ __RPC__in BSTR PKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromPKCS7( 
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumProviders( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumContainers( 
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfo( 
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerName( 
            /* [in] */ __RPC__in BSTR bstrContainer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderName( 
            /* [in] */ __RPC__in BSTR bstrProvider) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [retval][out] */ __RPC__out LONG *pdwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [retval][out] */ __RPC__out LONG *pdw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [retval][out] */ __RPC__out BOOL *fDelete) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fDelete) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [retval][out] */ __RPC__out BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileName( 
            /* [in] */ __RPC__in BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileName( 
            /* [in] */ __RPC__in BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ __RPC__in BSTR bstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        END_INTERFACE
    } ICEnrollVtbl;

    interface ICEnroll
    {
        CONST_VTBL struct ICEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll_INTERFACE_DEFINED__ */


#ifndef __ICEnroll2_INTERFACE_DEFINED__
#define __ICEnroll2_INTERFACE_DEFINED__

/* interface ICEnroll2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("704ca730-c90b-11d1-9bec-00c04fc295e1")
    ICEnroll2 : public ICEnroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequest( 
            /* [in] */ __RPC__in BSTR CertType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToSignature( 
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [retval][out] */ __RPC__out BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [retval][out] */ __RPC__out BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll2 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        END_INTERFACE
    } ICEnroll2Vtbl;

    interface ICEnroll2
    {
        CONST_VTBL struct ICEnroll2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll2_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll2_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll2_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll2_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll2_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll2_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll2_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll2_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll2_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll2_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll2_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll2_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll2_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll2_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll2_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll2_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll2_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll2_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll2_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll2_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll2_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll2_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll2_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll2_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll2_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll2_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll2_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll2_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll2_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll2_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll2_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll2_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll2_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll2_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll2_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll2_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll2_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll2_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll2_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll2_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll2_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll2_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll2_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll2_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll2_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll2_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll2_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll2_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 


#define ICEnroll2_addCertTypeToRequest(This,CertType)	\
    ( (This)->lpVtbl -> addCertTypeToRequest(This,CertType) ) 

#define ICEnroll2_addNameValuePairToSignature(This,Name,Value)	\
    ( (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value) ) 

#define ICEnroll2_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll2_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll2_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define ICEnroll2_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll2_INTERFACE_DEFINED__ */


#ifndef __ICEnroll3_INTERFACE_DEFINED__
#define __ICEnroll3_INTERFACE_DEFINED__

/* interface ICEnroll3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c28c2d95-b7de-11d2-a421-00c04f79fe8e")
    ICEnroll3 : public ICEnroll2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7( 
            /* [in] */ __RPC__in BSTR PKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec( 
            /* [retval][out] */ __RPC__out LONG *pdwKeySpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLen( 
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAlgs( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ __RPC__out LONG *pdwAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlgName( 
            /* [in] */ LONG algID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            /* [retval][out] */ __RPC__out BOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgID( 
            /* [in] */ LONG hashAlgID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgID( 
            /* [retval][out] */ __RPC__out LONG *hashAlgID) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LimitExchangeKeyToEncipherment( 
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LimitExchangeKeyToEncipherment( 
            /* [retval][out] */ __RPC__out BOOL *fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableSMIMECapabilities( 
            /* [in] */ BOOL fEnableSMIMECapabilities) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableSMIMECapabilities( 
            /* [retval][out] */ __RPC__out BOOL *fEnableSMIMECapabilities) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll3 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICEnroll3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ __RPC__out LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgName )( 
            ICEnroll3 * This,
            /* [in] */ LONG algID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            ICEnroll3 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *hashAlgID);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fEnableSMIMECapabilities);
        
        END_INTERFACE
    } ICEnroll3Vtbl;

    interface ICEnroll3
    {
        CONST_VTBL struct ICEnroll3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll3_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll3_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll3_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll3_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll3_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll3_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll3_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll3_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll3_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll3_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll3_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll3_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll3_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll3_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll3_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll3_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll3_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll3_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll3_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll3_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll3_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll3_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll3_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll3_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll3_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll3_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll3_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll3_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll3_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll3_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll3_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll3_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll3_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll3_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll3_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll3_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll3_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll3_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll3_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll3_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll3_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll3_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll3_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll3_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll3_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll3_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll3_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll3_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 


#define ICEnroll3_addCertTypeToRequest(This,CertType)	\
    ( (This)->lpVtbl -> addCertTypeToRequest(This,CertType) ) 

#define ICEnroll3_addNameValuePairToSignature(This,Name,Value)	\
    ( (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value) ) 

#define ICEnroll3_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll3_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll3_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define ICEnroll3_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 


#define ICEnroll3_InstallPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7(This,PKCS7) ) 

#define ICEnroll3_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ICEnroll3_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define ICEnroll3_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define ICEnroll3_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define ICEnroll3_GetAlgName(This,algID,pbstr)	\
    ( (This)->lpVtbl -> GetAlgName(This,algID,pbstr) ) 

#define ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll3_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define ICEnroll3_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define ICEnroll3_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll3_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll3_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define ICEnroll3_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll3_INTERFACE_DEFINED__ */


#ifndef __ICEnroll4_INTERFACE_DEFINED__
#define __ICEnroll4_INTERFACE_DEFINED__

/* interface ICEnroll4 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1f1188a-2eb5-4a80-841b-7e729a356d90")
    ICEnroll4 : public ICEnroll3
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrivateKeyArchiveCertificate( 
            /* [in] */ __RPC__in BSTR bstrCert) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateKeyArchiveCertificate( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrint( 
            /* [in] */ __RPC__in BSTR bstrThumbPrint) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrint( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrThumbPrint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE binaryToString( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strBinary,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrEncoded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stringToBinary( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strEncoded,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrBinary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetAttributes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFileRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR strUsage,
            /* [in] */ __RPC__in BSTR strRequestFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptResponse( 
            /* [in] */ __RPC__in BSTR strResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFileResponse( 
            /* [in] */ __RPC__in BSTR strResponseFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromResponse( 
            /* [in] */ __RPC__in BSTR strResponse,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromFileResponse( 
            /* [in] */ __RPC__in BSTR strResponseFileName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPFX( 
            /* [in] */ __RPC__in BSTR strPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrPFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFilePFX( 
            /* [in] */ __RPC__in BSTR strPassword,
            /* [in] */ __RPC__in BSTR strPFXFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfo( 
            /* [in] */ LONG lRequestID,
            /* [in] */ __RPC__in BSTR strCADNS,
            /* [in] */ __RPC__in BSTR strCAName,
            /* [in] */ __RPC__in BSTR strFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumPendingRequest( 
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [retval][out] */ __RPC__out VARIANT *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removePendingRequest( 
            /* [in] */ __RPC__in BSTR strThumbprint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx( 
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Ex( 
            /* [in] */ __RPC__in BSTR PKCS7,
            /* [retval][out] */ __RPC__out LONG *plCertInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequestEx( 
            /* [in] */ LONG lType,
            /* [in] */ __RPC__in BSTR bstrOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProviderType( 
            /* [in] */ __RPC__in BSTR strProvName,
            /* [retval][out] */ __RPC__out LONG *plProvType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SignerCertificate( 
            /* [in] */ __RPC__in BSTR bstrCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientId( 
            /* [in] */ LONG lClientId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ __RPC__out LONG *plClientId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificate( 
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ __RPC__in BSTR bstrProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetBlobProperties( void) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            /* [in] */ BOOL fInclude) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            /* [retval][out] */ __RPC__out BOOL *pfInclude) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll4 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll4 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ __RPC__out LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgName )( 
            ICEnroll4 * This,
            /* [in] */ LONG algID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            ICEnroll4 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *hashAlgID);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fEnableSMIMECapabilities);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivateKeyArchiveCertificate )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrCert);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKeyArchiveCertificate )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ThumbPrint )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrThumbPrint);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThumbPrint )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrThumbPrint);
        
        HRESULT ( STDMETHODCALLTYPE *binaryToString )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strBinary,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrEncoded);
        
        HRESULT ( STDMETHODCALLTYPE *stringToBinary )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strEncoded,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrBinary);
        
        HRESULT ( STDMETHODCALLTYPE *addExtensionToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *addAttributeToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *resetExtensions )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *resetAttributes )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrRequest);
        
        HRESULT ( STDMETHODCALLTYPE *createFileRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR strUsage,
            /* [in] */ __RPC__in BSTR strRequestFileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponse);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFileResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponseFileName);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponse,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromFileResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponseFileName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *createPFX )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrPFX);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePFX )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strPassword,
            /* [in] */ __RPC__in BSTR strPFXFileName);
        
        HRESULT ( STDMETHODCALLTYPE *setPendingRequestInfo )( 
            ICEnroll4 * This,
            /* [in] */ LONG lRequestID,
            /* [in] */ __RPC__in BSTR strCADNS,
            /* [in] */ __RPC__in BSTR strCAName,
            /* [in] */ __RPC__in BSTR strFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *enumPendingRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [retval][out] */ __RPC__out VARIANT *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE *removePendingRequest )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strThumbprint);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLenEx )( 
            ICEnroll4 * This,
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Ex )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7,
            /* [retval][out] */ __RPC__out LONG *plCertInstalled);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequestEx )( 
            ICEnroll4 * This,
            /* [in] */ LONG lType,
            /* [in] */ __RPC__in BSTR bstrOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion);
        
        HRESULT ( STDMETHODCALLTYPE *getProviderType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strProvName,
            /* [retval][out] */ __RPC__out LONG *plProvType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SignerCertificate )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            ICEnroll4 * This,
            /* [in] */ LONG lClientId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *plClientId);
        
        HRESULT ( STDMETHODCALLTYPE *addBlobPropertyToCertificate )( 
            ICEnroll4 * This,
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ __RPC__in BSTR bstrProperty);
        
        HRESULT ( STDMETHODCALLTYPE *resetBlobProperties )( 
            ICEnroll4 * This);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeSubjectKeyID )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fInclude);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeSubjectKeyID )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *pfInclude);
        
        END_INTERFACE
    } ICEnroll4Vtbl;

    interface ICEnroll4
    {
        CONST_VTBL struct ICEnroll4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll4_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll4_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll4_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll4_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll4_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll4_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll4_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll4_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll4_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll4_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll4_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll4_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll4_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll4_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll4_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll4_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll4_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll4_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll4_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll4_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll4_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll4_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll4_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll4_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll4_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll4_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll4_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll4_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll4_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll4_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll4_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll4_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll4_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll4_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll4_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll4_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll4_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll4_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll4_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll4_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll4_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll4_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll4_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll4_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll4_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll4_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll4_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll4_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll4_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 


#define ICEnroll4_addCertTypeToRequest(This,CertType)	\
    ( (This)->lpVtbl -> addCertTypeToRequest(This,CertType) ) 

#define ICEnroll4_addNameValuePairToSignature(This,Name,Value)	\
    ( (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value) ) 

#define ICEnroll4_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll4_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll4_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define ICEnroll4_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 


#define ICEnroll4_InstallPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7(This,PKCS7) ) 

#define ICEnroll4_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ICEnroll4_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define ICEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define ICEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define ICEnroll4_GetAlgName(This,algID,pbstr)	\
    ( (This)->lpVtbl -> GetAlgName(This,algID,pbstr) ) 

#define ICEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll4_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define ICEnroll4_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define ICEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define ICEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 


#define ICEnroll4_put_PrivateKeyArchiveCertificate(This,bstrCert)	\
    ( (This)->lpVtbl -> put_PrivateKeyArchiveCertificate(This,bstrCert) ) 

#define ICEnroll4_get_PrivateKeyArchiveCertificate(This,pbstrCert)	\
    ( (This)->lpVtbl -> get_PrivateKeyArchiveCertificate(This,pbstrCert) ) 

#define ICEnroll4_put_ThumbPrint(This,bstrThumbPrint)	\
    ( (This)->lpVtbl -> put_ThumbPrint(This,bstrThumbPrint) ) 

#define ICEnroll4_get_ThumbPrint(This,pbstrThumbPrint)	\
    ( (This)->lpVtbl -> get_ThumbPrint(This,pbstrThumbPrint) ) 

#define ICEnroll4_binaryToString(This,Flags,strBinary,pstrEncoded)	\
    ( (This)->lpVtbl -> binaryToString(This,Flags,strBinary,pstrEncoded) ) 

#define ICEnroll4_stringToBinary(This,Flags,strEncoded,pstrBinary)	\
    ( (This)->lpVtbl -> stringToBinary(This,Flags,strEncoded,pstrBinary) ) 

#define ICEnroll4_addExtensionToRequest(This,Flags,strName,strValue)	\
    ( (This)->lpVtbl -> addExtensionToRequest(This,Flags,strName,strValue) ) 

#define ICEnroll4_addAttributeToRequest(This,Flags,strName,strValue)	\
    ( (This)->lpVtbl -> addAttributeToRequest(This,Flags,strName,strValue) ) 

#define ICEnroll4_addNameValuePairToRequest(This,Flags,strName,strValue)	\
    ( (This)->lpVtbl -> addNameValuePairToRequest(This,Flags,strName,strValue) ) 

#define ICEnroll4_resetExtensions(This)	\
    ( (This)->lpVtbl -> resetExtensions(This) ) 

#define ICEnroll4_resetAttributes(This)	\
    ( (This)->lpVtbl -> resetAttributes(This) ) 

#define ICEnroll4_createRequest(This,Flags,strDNName,Usage,pstrRequest)	\
    ( (This)->lpVtbl -> createRequest(This,Flags,strDNName,Usage,pstrRequest) ) 

#define ICEnroll4_createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName)	\
    ( (This)->lpVtbl -> createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName) ) 

#define ICEnroll4_acceptResponse(This,strResponse)	\
    ( (This)->lpVtbl -> acceptResponse(This,strResponse) ) 

#define ICEnroll4_acceptFileResponse(This,strResponseFileName)	\
    ( (This)->lpVtbl -> acceptFileResponse(This,strResponseFileName) ) 

#define ICEnroll4_getCertFromResponse(This,strResponse,pstrCert)	\
    ( (This)->lpVtbl -> getCertFromResponse(This,strResponse,pstrCert) ) 

#define ICEnroll4_getCertFromFileResponse(This,strResponseFileName,pstrCert)	\
    ( (This)->lpVtbl -> getCertFromFileResponse(This,strResponseFileName,pstrCert) ) 

#define ICEnroll4_createPFX(This,strPassword,pstrPFX)	\
    ( (This)->lpVtbl -> createPFX(This,strPassword,pstrPFX) ) 

#define ICEnroll4_createFilePFX(This,strPassword,strPFXFileName)	\
    ( (This)->lpVtbl -> createFilePFX(This,strPassword,strPFXFileName) ) 

#define ICEnroll4_setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName)	\
    ( (This)->lpVtbl -> setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName) ) 

#define ICEnroll4_enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty)	\
    ( (This)->lpVtbl -> enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty) ) 

#define ICEnroll4_removePendingRequest(This,strThumbprint)	\
    ( (This)->lpVtbl -> removePendingRequest(This,strThumbprint) ) 

#define ICEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize) ) 

#define ICEnroll4_InstallPKCS7Ex(This,PKCS7,plCertInstalled)	\
    ( (This)->lpVtbl -> InstallPKCS7Ex(This,PKCS7,plCertInstalled) ) 

#define ICEnroll4_addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)	\
    ( (This)->lpVtbl -> addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion) ) 

#define ICEnroll4_getProviderType(This,strProvName,plProvType)	\
    ( (This)->lpVtbl -> getProviderType(This,strProvName,plProvType) ) 

#define ICEnroll4_put_SignerCertificate(This,bstrCert)	\
    ( (This)->lpVtbl -> put_SignerCertificate(This,bstrCert) ) 

#define ICEnroll4_put_ClientId(This,lClientId)	\
    ( (This)->lpVtbl -> put_ClientId(This,lClientId) ) 

#define ICEnroll4_get_ClientId(This,plClientId)	\
    ( (This)->lpVtbl -> get_ClientId(This,plClientId) ) 

#define ICEnroll4_addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty)	\
    ( (This)->lpVtbl -> addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty) ) 

#define ICEnroll4_resetBlobProperties(This)	\
    ( (This)->lpVtbl -> resetBlobProperties(This) ) 

#define ICEnroll4_put_IncludeSubjectKeyID(This,fInclude)	\
    ( (This)->lpVtbl -> put_IncludeSubjectKeyID(This,fInclude) ) 

#define ICEnroll4_get_IncludeSubjectKeyID(This,pfInclude)	\
    ( (This)->lpVtbl -> get_IncludeSubjectKeyID(This,pfInclude) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll4_INTERFACE_DEFINED__ */


#ifndef __IEnroll_INTERFACE_DEFINED__
#define __IEnroll_INTERFACE_DEFINED__

/* interface IEnroll */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("acaa7838-4585-11d1-ab57-00c04fc295e1")
    IEnroll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7WStr( 
            /* [in] */ LPCWSTR wszPKCS7FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE getCertContextFromPKCS7( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getMyStore( void) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getCAStore( void) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getROOTHStore( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumProvidersWStr( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumContainersWStr( 
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfoBlob( 
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerNameWStr( 
            /* [out] */ LPWSTR *szwContainer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerNameWStr( 
            /* [in] */ LPWSTR szwContainer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderNameWStr( 
            /* [out] */ LPWSTR *szwProvider) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderNameWStr( 
            /* [in] */ LPWSTR szwProvider) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [out] */ LONG *pdwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [out] */ LONG *pdw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [out] */ BOOL *fUseExistingKeys) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [out] */ BOOL *fDelete) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fDelete) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileNameWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileNameWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileNameWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileNameWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithmWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithmWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RenewalCertificate( 
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RenewalCertificate( 
            /* [in] */ PCCERT_CONTEXT pCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddNameValuePairToSignatureWStr( 
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddExtensionsToRequest( 
            /* [in] */ PCERT_EXTENSIONS pCertExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAuthenticatedAttributesToPKCS7Request( 
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePKCS7RequestFromRequest( 
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        END_INTERFACE
    } IEnrollVtbl;

    interface IEnroll
    {
        CONST_VTBL struct IEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnroll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnroll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnroll_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) ) 

#define IEnroll_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName) ) 

#define IEnroll_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    ( (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) ) 

#define IEnroll_acceptPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7) ) 

#define IEnroll_getMyStore(This)	\
    ( (This)->lpVtbl -> getMyStore(This) ) 

#define IEnroll_getCAStore(This)	\
    ( (This)->lpVtbl -> getCAStore(This) ) 

#define IEnroll_getROOTHStore(This)	\
    ( (This)->lpVtbl -> getROOTHStore(This) ) 

#define IEnroll_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) ) 

#define IEnroll_enumContainersWStr(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr) ) 

#define IEnroll_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    ( (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10) ) 

#define IEnroll_get_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName) ) 

#define IEnroll_put_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName) ) 

#define IEnroll_get_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define IEnroll_get_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName) ) 

#define IEnroll_put_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName) ) 

#define IEnroll_get_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define IEnroll_get_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName) ) 

#define IEnroll_put_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName) ) 

#define IEnroll_get_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define IEnroll_get_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll_put_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll_get_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define IEnroll_get_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll_put_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll_get_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll_put_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define IEnroll_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define IEnroll_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define IEnroll_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define IEnroll_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define IEnroll_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define IEnroll_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define IEnroll_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define IEnroll_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define IEnroll_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define IEnroll_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define IEnroll_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define IEnroll_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define IEnroll_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define IEnroll_get_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_SPCFileNameWStr(This,szw) ) 

#define IEnroll_put_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_SPCFileNameWStr(This,szw) ) 

#define IEnroll_get_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_PVKFileNameWStr(This,szw) ) 

#define IEnroll_put_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_PVKFileNameWStr(This,szw) ) 

#define IEnroll_get_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw) ) 

#define IEnroll_put_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw) ) 

#define IEnroll_get_RenewalCertificate(This,ppCertContext)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext) ) 

#define IEnroll_put_RenewalCertificate(This,pCertContext)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext) ) 

#define IEnroll_AddCertTypeToRequestWStr(This,szw)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw) ) 

#define IEnroll_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    ( (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value) ) 

#define IEnroll_AddExtensionsToRequest(This,pCertExtensions)	\
    ( (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions) ) 

#define IEnroll_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    ( (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) ) 

#define IEnroll_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    ( (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnroll_INTERFACE_DEFINED__ */


#ifndef __IEnroll2_INTERFACE_DEFINED__
#define __IEnroll2_INTERFACE_DEFINED__

/* interface IEnroll2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c080e199-b7df-11d2-a421-00c04f79fe8e")
    IEnroll2 : public IEnroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec( 
            /* [out] */ LONG *pdwKeySpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLen( 
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAlgs( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlgNameWStr( 
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgID( 
            /* [in] */ LONG hashAlgID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgID( 
            /* [retval][out] */ LONG *hashAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreMy( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreCA( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreROOT( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreRequest( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LimitExchangeKeyToEncipherment( 
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LimitExchangeKeyToEncipherment( 
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableSMIMECapabilities( 
            /* [in] */ BOOL fEnableSMIMECapabilities) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableSMIMECapabilities( 
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnroll2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll2 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll2 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll2 * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll2 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll2 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll2 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll2 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll2 * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll2 * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll2 * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Blob )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            IEnroll2 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll2 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            IEnroll2 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            IEnroll2 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreMy )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreCA )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreROOT )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreRequest )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            IEnroll2 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            IEnroll2 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            IEnroll2 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            IEnroll2 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        END_INTERFACE
    } IEnroll2Vtbl;

    interface IEnroll2
    {
        CONST_VTBL struct IEnroll2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnroll2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnroll2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnroll2_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) ) 

#define IEnroll2_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName) ) 

#define IEnroll2_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    ( (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) ) 

#define IEnroll2_acceptPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll2_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7) ) 

#define IEnroll2_getMyStore(This)	\
    ( (This)->lpVtbl -> getMyStore(This) ) 

#define IEnroll2_getCAStore(This)	\
    ( (This)->lpVtbl -> getCAStore(This) ) 

#define IEnroll2_getROOTHStore(This)	\
    ( (This)->lpVtbl -> getROOTHStore(This) ) 

#define IEnroll2_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) ) 

#define IEnroll2_enumContainersWStr(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr) ) 

#define IEnroll2_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    ( (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10) ) 

#define IEnroll2_get_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll2_put_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll2_get_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll2_put_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll2_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define IEnroll2_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define IEnroll2_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define IEnroll2_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define IEnroll2_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define IEnroll2_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define IEnroll2_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll2_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll2_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define IEnroll2_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define IEnroll2_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define IEnroll2_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define IEnroll2_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define IEnroll2_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define IEnroll2_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll2_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll2_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define IEnroll2_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define IEnroll2_get_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_SPCFileNameWStr(This,szw) ) 

#define IEnroll2_put_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_SPCFileNameWStr(This,szw) ) 

#define IEnroll2_get_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_PVKFileNameWStr(This,szw) ) 

#define IEnroll2_put_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_PVKFileNameWStr(This,szw) ) 

#define IEnroll2_get_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw) ) 

#define IEnroll2_put_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw) ) 

#define IEnroll2_get_RenewalCertificate(This,ppCertContext)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext) ) 

#define IEnroll2_put_RenewalCertificate(This,pCertContext)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext) ) 

#define IEnroll2_AddCertTypeToRequestWStr(This,szw)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw) ) 

#define IEnroll2_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    ( (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value) ) 

#define IEnroll2_AddExtensionsToRequest(This,pCertExtensions)	\
    ( (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions) ) 

#define IEnroll2_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    ( (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) ) 

#define IEnroll2_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    ( (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) ) 


#define IEnroll2_InstallPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnroll2_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define IEnroll2_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define IEnroll2_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define IEnroll2_GetAlgNameWStr(This,algID,ppwsz)	\
    ( (This)->lpVtbl -> GetAlgNameWStr(This,algID,ppwsz) ) 

#define IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll2_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define IEnroll2_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define IEnroll2_SetHStoreMy(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreMy(This,hStore) ) 

#define IEnroll2_SetHStoreCA(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreCA(This,hStore) ) 

#define IEnroll2_SetHStoreROOT(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreROOT(This,hStore) ) 

#define IEnroll2_SetHStoreRequest(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreRequest(This,hStore) ) 

#define IEnroll2_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll2_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll2_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define IEnroll2_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnroll2_INTERFACE_DEFINED__ */


#ifndef __IEnroll4_INTERFACE_DEFINED__
#define __IEnroll4_INTERFACE_DEFINED__

/* interface IEnroll4 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f8053fe5-78f4-448f-a0db-41d61b73446b")
    IEnroll4 : public IEnroll2
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrintWStr( 
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrintWStr( 
            /* [retval][out] */ PCRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrivateKeyArchiveCertificate( 
            /* [in] */ PCCERT_CONTEXT pPrivateKeyArchiveCert) = 0;
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE GetPrivateKeyArchiveCertificate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE binaryBlobToString( 
            /* [in] */ LONG Flags,
            /* [in] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LPWSTR *ppwszString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stringToBinaryBlob( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszString,
            /* [out] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LONG *pdwSkip,
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetAttributes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [out] */ PCRYPT_DATA_BLOB pblobRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFileRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [in] */ LPCWSTR pwszRequestFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptResponseBlob( 
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFileResponseWStr( 
            /* [in] */ LPCWSTR pwszResponseFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertContextFromResponseBlob( 
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse,
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertContextFromFileResponseWStr( 
            /* [in] */ LPCWSTR pwszResponseFileName,
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPFXWStr( 
            /* [in] */ LPCWSTR pwszPassword,
            /* [out] */ PCRYPT_DATA_BLOB pblobPFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFilePFXWStr( 
            /* [in] */ LPCWSTR pwszPassword,
            /* [in] */ LPCWSTR pwszPFXFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfoWStr( 
            /* [in] */ LONG lRequestID,
            /* [in] */ LPCWSTR pwszCADNS,
            /* [in] */ LPCWSTR pwszCAName,
            /* [in] */ LPCWSTR pwszFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumPendingRequestWStr( 
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [out] */ LPVOID ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removePendingRequestWStr( 
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx( 
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7BlobEx( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
            /* [retval][out] */ LONG *plCertInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStrEx( 
            /* [in] */ LONG lType,
            /* [in] */ LPCWSTR pwszOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProviderTypeWStr( 
            /* [in] */ LPCWSTR pwszProvName,
            /* [retval][out] */ LONG *plProvType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificateWStr( 
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ PCRYPT_DATA_BLOB pBlobProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignerCertificate( 
            /* [in] */ PCCERT_CONTEXT pSignerCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientId( 
            /* [in] */ LONG lClientId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ LONG *plClientId) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            /* [in] */ BOOL fInclude) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            /* [retval][out] */ BOOL *pfInclude) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnroll4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll4 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll4 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll4 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll4 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll4 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll4 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll4 * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll4 * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Blob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            IEnroll4 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll4 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            IEnroll4 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            IEnroll4 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreMy )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreCA )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreROOT )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreRequest )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            IEnroll4 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            IEnroll4 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ThumbPrintWStr )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThumbPrintWStr )( 
            IEnroll4 * This,
            /* [retval][out] */ PCRYPT_DATA_BLOB thumbPrintBlob);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateKeyArchiveCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pPrivateKeyArchiveCert);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *GetPrivateKeyArchiveCertificate )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *binaryBlobToString )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LPWSTR *ppwszString);
        
        HRESULT ( STDMETHODCALLTYPE *stringToBinaryBlob )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszString,
            /* [out] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LONG *pdwSkip,
            /* [out] */ LONG *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *addExtensionToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue);
        
        HRESULT ( STDMETHODCALLTYPE *addAttributeToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *resetExtensions )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *resetAttributes )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [out] */ PCRYPT_DATA_BLOB pblobRequest);
        
        HRESULT ( STDMETHODCALLTYPE *createFileRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [in] */ LPCWSTR pwszRequestFileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptResponseBlob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFileResponseWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszResponseFileName);
        
        HRESULT ( STDMETHODCALLTYPE *getCertContextFromResponseBlob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *getCertContextFromFileResponseWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszResponseFileName,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *createPFXWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszPassword,
            /* [out] */ PCRYPT_DATA_BLOB pblobPFX);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePFXWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszPassword,
            /* [in] */ LPCWSTR pwszPFXFileName);
        
        HRESULT ( STDMETHODCALLTYPE *setPendingRequestInfoWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lRequestID,
            /* [in] */ LPCWSTR pwszCADNS,
            /* [in] */ LPCWSTR pwszCAName,
            /* [in] */ LPCWSTR pwszFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *enumPendingRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [out] */ LPVOID ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *removePendingRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLenEx )( 
            IEnroll4 * This,
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7BlobEx )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
            /* [retval][out] */ LONG *plCertInstalled);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStrEx )( 
            IEnroll4 * This,
            /* [in] */ LONG lType,
            /* [in] */ LPCWSTR pwszOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion);
        
        HRESULT ( STDMETHODCALLTYPE *getProviderTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszProvName,
            /* [retval][out] */ LONG *plProvType);
        
        HRESULT ( STDMETHODCALLTYPE *addBlobPropertyToCertificateWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ PCRYPT_DATA_BLOB pBlobProperty);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignerCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pSignerCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IEnroll4 * This,
            /* [in] */ LONG lClientId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IEnroll4 * This,
            /* [retval][out] */ LONG *plClientId);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeSubjectKeyID )( 
            IEnroll4 * This,
            /* [in] */ BOOL fInclude);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeSubjectKeyID )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *pfInclude);
        
        END_INTERFACE
    } IEnroll4Vtbl;

    interface IEnroll4
    {
        CONST_VTBL struct IEnroll4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnroll4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnroll4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnroll4_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) ) 

#define IEnroll4_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName) ) 

#define IEnroll4_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    ( (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) ) 

#define IEnroll4_acceptPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll4_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7) ) 

#define IEnroll4_getMyStore(This)	\
    ( (This)->lpVtbl -> getMyStore(This) ) 

#define IEnroll4_getCAStore(This)	\
    ( (This)->lpVtbl -> getCAStore(This) ) 

#define IEnroll4_getROOTHStore(This)	\
    ( (This)->lpVtbl -> getROOTHStore(This) ) 

#define IEnroll4_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) ) 

#define IEnroll4_enumContainersWStr(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr) ) 

#define IEnroll4_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    ( (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10) ) 

#define IEnroll4_get_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll4_put_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll4_get_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll4_put_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll4_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define IEnroll4_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define IEnroll4_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define IEnroll4_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define IEnroll4_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define IEnroll4_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define IEnroll4_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll4_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll4_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define IEnroll4_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define IEnroll4_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define IEnroll4_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define IEnroll4_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define IEnroll4_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define IEnroll4_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll4_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll4_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define IEnroll4_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define IEnroll4_get_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_SPCFileNameWStr(This,szw) ) 

#define IEnroll4_put_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_SPCFileNameWStr(This,szw) ) 

#define IEnroll4_get_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_PVKFileNameWStr(This,szw) ) 

#define IEnroll4_put_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_PVKFileNameWStr(This,szw) ) 

#define IEnroll4_get_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw) ) 

#define IEnroll4_put_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw) ) 

#define IEnroll4_get_RenewalCertificate(This,ppCertContext)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext) ) 

#define IEnroll4_put_RenewalCertificate(This,pCertContext)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext) ) 

#define IEnroll4_AddCertTypeToRequestWStr(This,szw)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw) ) 

#define IEnroll4_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    ( (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value) ) 

#define IEnroll4_AddExtensionsToRequest(This,pCertExtensions)	\
    ( (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions) ) 

#define IEnroll4_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    ( (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) ) 

#define IEnroll4_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    ( (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) ) 


#define IEnroll4_InstallPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll4_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnroll4_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define IEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define IEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define IEnroll4_GetAlgNameWStr(This,algID,ppwsz)	\
    ( (This)->lpVtbl -> GetAlgNameWStr(This,algID,ppwsz) ) 

#define IEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll4_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define IEnroll4_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define IEnroll4_SetHStoreMy(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreMy(This,hStore) ) 

#define IEnroll4_SetHStoreCA(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreCA(This,hStore) ) 

#define IEnroll4_SetHStoreROOT(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreROOT(This,hStore) ) 

#define IEnroll4_SetHStoreRequest(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreRequest(This,hStore) ) 

#define IEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define IEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 


#define IEnroll4_put_ThumbPrintWStr(This,thumbPrintBlob)	\
    ( (This)->lpVtbl -> put_ThumbPrintWStr(This,thumbPrintBlob) ) 

#define IEnroll4_get_ThumbPrintWStr(This,thumbPrintBlob)	\
    ( (This)->lpVtbl -> get_ThumbPrintWStr(This,thumbPrintBlob) ) 

#define IEnroll4_SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert)	\
    ( (This)->lpVtbl -> SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert) ) 

#define IEnroll4_GetPrivateKeyArchiveCertificate(This)	\
    ( (This)->lpVtbl -> GetPrivateKeyArchiveCertificate(This) ) 

#define IEnroll4_binaryBlobToString(This,Flags,pblobBinary,ppwszString)	\
    ( (This)->lpVtbl -> binaryBlobToString(This,Flags,pblobBinary,ppwszString) ) 

#define IEnroll4_stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags)	\
    ( (This)->lpVtbl -> stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags) ) 

#define IEnroll4_addExtensionToRequestWStr(This,Flags,pwszName,pblobValue)	\
    ( (This)->lpVtbl -> addExtensionToRequestWStr(This,Flags,pwszName,pblobValue) ) 

#define IEnroll4_addAttributeToRequestWStr(This,Flags,pwszName,pblobValue)	\
    ( (This)->lpVtbl -> addAttributeToRequestWStr(This,Flags,pwszName,pblobValue) ) 

#define IEnroll4_addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue)	\
    ( (This)->lpVtbl -> addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue) ) 

#define IEnroll4_resetExtensions(This)	\
    ( (This)->lpVtbl -> resetExtensions(This) ) 

#define IEnroll4_resetAttributes(This)	\
    ( (This)->lpVtbl -> resetAttributes(This) ) 

#define IEnroll4_createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest)	\
    ( (This)->lpVtbl -> createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest) ) 

#define IEnroll4_createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName)	\
    ( (This)->lpVtbl -> createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName) ) 

#define IEnroll4_acceptResponseBlob(This,pblobResponse)	\
    ( (This)->lpVtbl -> acceptResponseBlob(This,pblobResponse) ) 

#define IEnroll4_acceptFileResponseWStr(This,pwszResponseFileName)	\
    ( (This)->lpVtbl -> acceptFileResponseWStr(This,pwszResponseFileName) ) 

#define IEnroll4_getCertContextFromResponseBlob(This,pblobResponse,ppCertContext)	\
    ( (This)->lpVtbl -> getCertContextFromResponseBlob(This,pblobResponse,ppCertContext) ) 

#define IEnroll4_getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext)	\
    ( (This)->lpVtbl -> getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext) ) 

#define IEnroll4_createPFXWStr(This,pwszPassword,pblobPFX)	\
    ( (This)->lpVtbl -> createPFXWStr(This,pwszPassword,pblobPFX) ) 

#define IEnroll4_createFilePFXWStr(This,pwszPassword,pwszPFXFileName)	\
    ( (This)->lpVtbl -> createFilePFXWStr(This,pwszPassword,pwszPFXFileName) ) 

#define IEnroll4_setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName)	\
    ( (This)->lpVtbl -> setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName) ) 

#define IEnroll4_enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty)	\
    ( (This)->lpVtbl -> enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty) ) 

#define IEnroll4_removePendingRequestWStr(This,thumbPrintBlob)	\
    ( (This)->lpVtbl -> removePendingRequestWStr(This,thumbPrintBlob) ) 

#define IEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize) ) 

#define IEnroll4_InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled)	\
    ( (This)->lpVtbl -> InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled) ) 

#define IEnroll4_AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion) ) 

#define IEnroll4_getProviderTypeWStr(This,pwszProvName,plProvType)	\
    ( (This)->lpVtbl -> getProviderTypeWStr(This,pwszProvName,plProvType) ) 

#define IEnroll4_addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty)	\
    ( (This)->lpVtbl -> addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty) ) 

#define IEnroll4_SetSignerCertificate(This,pSignerCert)	\
    ( (This)->lpVtbl -> SetSignerCertificate(This,pSignerCert) ) 

#define IEnroll4_put_ClientId(This,lClientId)	\
    ( (This)->lpVtbl -> put_ClientId(This,lClientId) ) 

#define IEnroll4_get_ClientId(This,plClientId)	\
    ( (This)->lpVtbl -> get_ClientId(This,plClientId) ) 

#define IEnroll4_put_IncludeSubjectKeyID(This,fInclude)	\
    ( (This)->lpVtbl -> put_IncludeSubjectKeyID(This,fInclude) ) 

#define IEnroll4_get_IncludeSubjectKeyID(This,pfInclude)	\
    ( (This)->lpVtbl -> get_IncludeSubjectKeyID(This,pfInclude) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnroll4_INTERFACE_DEFINED__ */



#ifndef __XENROLLLib_LIBRARY_DEFINED__
#define __XENROLLLib_LIBRARY_DEFINED__

/* library XENROLLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XENROLLLib;

EXTERN_C const CLSID CLSID_CEnroll2;

#ifdef __cplusplus

class DECLSPEC_UUID("127698e4-e730-4e5c-a2b1-21490a70c8a1")
CEnroll2;
#endif

EXTERN_C const CLSID CLSID_CEnroll;

#ifdef __cplusplus

class DECLSPEC_UUID("43F8F289-7A20-11D0-8F06-00C04FC295E1")
CEnroll;
#endif
#endif /* __XENROLLLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xenroll_0000_0007 */
/* [local] */ 

extern "C" IEnroll * WINAPI PIEnrollGetNoCOM(void);
extern "C" IEnroll2 * WINAPI PIEnroll2GetNoCOM(void);
extern "C" IEnroll4 * WINAPI PIEnroll4GetNoCOM(void);
#define CRYPT_ENUM_ALL_PROVIDERS  0x1
#define XEPR_ENUM_FIRST        -1
#define XEPR_CADNS           0x01
#define XEPR_CANAME          0x02
#define XEPR_CAFRIENDLYNAME  0x03
#define XEPR_REQUESTID       0x04
#define XEPR_DATE            0x05
#define XEPR_TEMPLATENAME    0x06
#define XEPR_VERSION         0x07
#define XEPR_HASH            0x08
#define XEPR_V1TEMPLATENAME  0x09
#define XEPR_V2TEMPLATEOID   0x10
#define XECR_PKCS10_V2_0     0x1
#define XECR_PKCS7           0x2
#define XECR_CMC             0x3
#define XECR_PKCS10_V1_5     0x4
#define XEKL_KEYSIZE_MIN     0x1
#define XEKL_KEYSIZE_MAX     0x2
#define XEKL_KEYSIZE_INC     0x3
#define XEKL_KEYSIZE_DEFAULT 0x4
#define XEKL_KEYSPEC_KEYX    0x1
#define XEKL_KEYSPEC_SIG     0x2
#define XECT_EXTENSION_V1    0x1
#define XECT_EXTENSION_V2    0x2
#define XECP_STRING_PROPERTY 0x1
#define XECI_DISABLE     0x0
#define XECI_XENROLL     0x1
#define XECI_AUTOENROLL  0x2
#define XECI_REQWIZARD   0x3
#define XECI_CERTREQ     0x4


extern RPC_IF_HANDLE __MIDL_itf_xenroll_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xenroll_0000_0007_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\XMLTrnsF.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for xmltrnsf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xmltrnsf_h__
#define __xmltrnsf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef interface IWmiXMLTransformer IWmiXMLTransformer;
#endif 	/* __IWmiXMLTransformer_FWD_DEFINED__ */


#ifndef __WmiXMLTransformer_FWD_DEFINED__
#define __WmiXMLTransformer_FWD_DEFINED__

#ifdef __cplusplus
typedef class WmiXMLTransformer WmiXMLTransformer;
#else
typedef struct WmiXMLTransformer WmiXMLTransformer;
#endif /* __cplusplus */

#endif 	/* __WmiXMLTransformer_FWD_DEFINED__ */


#ifndef __ISWbemXMLDocumentSet_FWD_DEFINED__
#define __ISWbemXMLDocumentSet_FWD_DEFINED__
typedef interface ISWbemXMLDocumentSet ISWbemXMLDocumentSet;
#endif 	/* __ISWbemXMLDocumentSet_FWD_DEFINED__ */


#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef interface IWmiXMLTransformer IWmiXMLTransformer;
#endif 	/* __IWmiXMLTransformer_FWD_DEFINED__ */


/* header files for imported files */
#include "msxml.h"
#include "wbemdisp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WmiXMLTransformer_LIBRARY_DEFINED__
#define __WmiXMLTransformer_LIBRARY_DEFINED__

/* library WmiXMLTransformer */
/* [helpstring][version][lcid][uuid] */ 


typedef /* [helpstring][uuid][v1_enum] */  DECLSPEC_UUID("28D1EEA5-D41E-46c2-B42D-6CE0B9B4D7A7") 
enum WmiXMLEncoding
    {	wmiXML_CIM_DTD_2_0	= 0,
	wmiXML_WMI_DTD_2_0	= 0x1,
	wmiXML_WMI_DTD_WHISTLER	= 0x2
    } 	WmiXMLEncoding;

typedef /* [helpstring][uuid][v1_enum] */  DECLSPEC_UUID("598BCA7A-E40E-4265-8517-C9A86E2FC07E") 
enum WmiXMLCompilationTypeEnum
    {	WmiXMLCompilationWellFormCheck	= 0,
	WmiXMLCompilationValidityCheck	= 0x1,
	WmiXMLCompilationFullCompileAndLoad	= 0x2
    } 	WmiXMLCompilationTypeEnum;


EXTERN_C const IID LIBID_WmiXMLTransformer;

#ifndef __IWmiXMLTransformer_INTERFACE_DEFINED__
#define __IWmiXMLTransformer_INTERFACE_DEFINED__

/* interface IWmiXMLTransformer */
/* [helpstring][oleautomation][nonextensible][hidden][dual][uuid][local][object] */ 


EXTERN_C const IID IID_IWmiXMLTransformer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB624102-3145-4daf-B0EA-FF5A31178600")
    IWmiXMLTransformer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLEncodingType( 
            /* [out][retval] */ WmiXMLEncoding *piEncoding) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLEncodingType( 
            /* [in] */ WmiXMLEncoding iEncoding) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QualifierFilter( 
            /* [out][retval] */ VARIANT_BOOL *bQualifierFilter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_QualifierFilter( 
            /* [in] */ VARIANT_BOOL bQualifierFilter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClassOriginFilter( 
            /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ClassOriginFilter( 
            /* [in] */ VARIANT_BOOL bClassOriginFilter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [out][retval] */ BSTR *strUser) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_User( 
            /* [in] */ BSTR strUser) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [out][retval] */ BSTR *strPassword) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Password( 
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Authority( 
            /* [out][retval] */ BSTR *strAuthority) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Authority( 
            /* [in] */ BSTR strAuthority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImpersonationLevel( 
            /* [out][retval] */ DWORD *pdwImpersonationLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ImpersonationLevel( 
            /* [in] */ DWORD dwImpersonationLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AuthenticationLevel( 
            /* [out][retval] */ DWORD *pdwAuthenticationLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AuthenticationLevel( 
            /* [in] */ DWORD dwAuthenticationLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Locale( 
            /* [out][retval] */ BSTR *strLocale) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Locale( 
            /* [in] */ BSTR strLocale) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalOnly( 
            /* [out][retval] */ VARIANT_BOOL *bLocalOnly) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LocalOnly( 
            /* [in] */ VARIANT_BOOL bLocalOnly) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ BSTR strQuery,
            /* [defaultvalue][in] */ BSTR strQueryLanguage,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumClasses( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumInstances( 
            /* [in] */ BSTR strClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumClassNames( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumInstanceNames( 
            /* [in] */ BSTR strClassPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Compile( 
            /* [in] */ VARIANT *pvInputSource,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ WmiXMLCompilationTypeEnum iOperation,
            /* [in] */ IDispatch *pCtx,
            /* [retval][out] */ VARIANT_BOOL *pStatus) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Privileges( 
            /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CompilationErrors( 
            /* [retval][out] */ BSTR *pstrErrors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWmiXMLTransformerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWmiXMLTransformer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWmiXMLTransformer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWmiXMLTransformer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWmiXMLTransformer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWmiXMLTransformer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWmiXMLTransformer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XMLEncodingType )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ WmiXMLEncoding *piEncoding);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_XMLEncodingType )( 
            IWmiXMLTransformer * This,
            /* [in] */ WmiXMLEncoding iEncoding);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_QualifierFilter )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bQualifierFilter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_QualifierFilter )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bQualifierFilter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassOriginFilter )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClassOriginFilter )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bClassOriginFilter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strUser);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_User )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strUser);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Password )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strPassword);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Password )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authority )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strAuthority);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Authority )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strAuthority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImpersonationLevel )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ DWORD *pdwImpersonationLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ImpersonationLevel )( 
            IWmiXMLTransformer * This,
            /* [in] */ DWORD dwImpersonationLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationLevel )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ DWORD *pdwAuthenticationLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationLevel )( 
            IWmiXMLTransformer * This,
            /* [in] */ DWORD dwAuthenticationLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locale )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strLocale);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locale )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strLocale);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalOnly )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bLocalOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalOnly )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bLocalOnly);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ BSTR strQuery,
            /* [defaultvalue][in] */ BSTR strQueryLanguage,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumClasses )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumInstances )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumClassNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumInstanceNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strClassPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Compile )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT *pvInputSource,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ WmiXMLCompilationTypeEnum iOperation,
            /* [in] */ IDispatch *pCtx,
            /* [retval][out] */ VARIANT_BOOL *pStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Privileges )( 
            IWmiXMLTransformer * This,
            /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CompilationErrors )( 
            IWmiXMLTransformer * This,
            /* [retval][out] */ BSTR *pstrErrors);
        
        END_INTERFACE
    } IWmiXMLTransformerVtbl;

    interface IWmiXMLTransformer
    {
        CONST_VTBL struct IWmiXMLTransformerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWmiXMLTransformer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWmiXMLTransformer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWmiXMLTransformer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWmiXMLTransformer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWmiXMLTransformer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWmiXMLTransformer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWmiXMLTransformer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWmiXMLTransformer_get_XMLEncodingType(This,piEncoding)	\
    (This)->lpVtbl -> get_XMLEncodingType(This,piEncoding)

#define IWmiXMLTransformer_put_XMLEncodingType(This,iEncoding)	\
    (This)->lpVtbl -> put_XMLEncodingType(This,iEncoding)

#define IWmiXMLTransformer_get_QualifierFilter(This,bQualifierFilter)	\
    (This)->lpVtbl -> get_QualifierFilter(This,bQualifierFilter)

#define IWmiXMLTransformer_put_QualifierFilter(This,bQualifierFilter)	\
    (This)->lpVtbl -> put_QualifierFilter(This,bQualifierFilter)

#define IWmiXMLTransformer_get_ClassOriginFilter(This,bClassOriginFilter)	\
    (This)->lpVtbl -> get_ClassOriginFilter(This,bClassOriginFilter)

#define IWmiXMLTransformer_put_ClassOriginFilter(This,bClassOriginFilter)	\
    (This)->lpVtbl -> put_ClassOriginFilter(This,bClassOriginFilter)

#define IWmiXMLTransformer_get_User(This,strUser)	\
    (This)->lpVtbl -> get_User(This,strUser)

#define IWmiXMLTransformer_put_User(This,strUser)	\
    (This)->lpVtbl -> put_User(This,strUser)

#define IWmiXMLTransformer_get_Password(This,strPassword)	\
    (This)->lpVtbl -> get_Password(This,strPassword)

#define IWmiXMLTransformer_put_Password(This,strPassword)	\
    (This)->lpVtbl -> put_Password(This,strPassword)

#define IWmiXMLTransformer_get_Authority(This,strAuthority)	\
    (This)->lpVtbl -> get_Authority(This,strAuthority)

#define IWmiXMLTransformer_put_Authority(This,strAuthority)	\
    (This)->lpVtbl -> put_Authority(This,strAuthority)

#define IWmiXMLTransformer_get_ImpersonationLevel(This,pdwImpersonationLevel)	\
    (This)->lpVtbl -> get_ImpersonationLevel(This,pdwImpersonationLevel)

#define IWmiXMLTransformer_put_ImpersonationLevel(This,dwImpersonationLevel)	\
    (This)->lpVtbl -> put_ImpersonationLevel(This,dwImpersonationLevel)

#define IWmiXMLTransformer_get_AuthenticationLevel(This,pdwAuthenticationLevel)	\
    (This)->lpVtbl -> get_AuthenticationLevel(This,pdwAuthenticationLevel)

#define IWmiXMLTransformer_put_AuthenticationLevel(This,dwAuthenticationLevel)	\
    (This)->lpVtbl -> put_AuthenticationLevel(This,dwAuthenticationLevel)

#define IWmiXMLTransformer_get_Locale(This,strLocale)	\
    (This)->lpVtbl -> get_Locale(This,strLocale)

#define IWmiXMLTransformer_put_Locale(This,strLocale)	\
    (This)->lpVtbl -> put_Locale(This,strLocale)

#define IWmiXMLTransformer_get_LocalOnly(This,bLocalOnly)	\
    (This)->lpVtbl -> get_LocalOnly(This,bLocalOnly)

#define IWmiXMLTransformer_put_LocalOnly(This,bLocalOnly)	\
    (This)->lpVtbl -> put_LocalOnly(This,bLocalOnly)

#define IWmiXMLTransformer_GetObject(This,strObjectPath,pCtx,ppXMLDocument)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,pCtx,ppXMLDocument)

#define IWmiXMLTransformer_ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus)	\
    (This)->lpVtbl -> Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus)

#define IWmiXMLTransformer_get_Privileges(This,objWbemPrivilegeSet)	\
    (This)->lpVtbl -> get_Privileges(This,objWbemPrivilegeSet)

#define IWmiXMLTransformer_get_CompilationErrors(This,pstrErrors)	\
    (This)->lpVtbl -> get_CompilationErrors(This,pstrErrors)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_XMLEncodingType_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ WmiXMLEncoding *piEncoding);


void __RPC_STUB IWmiXMLTransformer_get_XMLEncodingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_XMLEncodingType_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ WmiXMLEncoding iEncoding);


void __RPC_STUB IWmiXMLTransformer_put_XMLEncodingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_QualifierFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bQualifierFilter);


void __RPC_STUB IWmiXMLTransformer_get_QualifierFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_QualifierFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bQualifierFilter);


void __RPC_STUB IWmiXMLTransformer_put_QualifierFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_ClassOriginFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter);


void __RPC_STUB IWmiXMLTransformer_get_ClassOriginFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_ClassOriginFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bClassOriginFilter);


void __RPC_STUB IWmiXMLTransformer_put_ClassOriginFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_User_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strUser);


void __RPC_STUB IWmiXMLTransformer_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_User_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strUser);


void __RPC_STUB IWmiXMLTransformer_put_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Password_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strPassword);


void __RPC_STUB IWmiXMLTransformer_get_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Password_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IWmiXMLTransformer_put_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Authority_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strAuthority);


void __RPC_STUB IWmiXMLTransformer_get_Authority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Authority_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strAuthority);


void __RPC_STUB IWmiXMLTransformer_put_Authority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_ImpersonationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ DWORD *pdwImpersonationLevel);


void __RPC_STUB IWmiXMLTransformer_get_ImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_ImpersonationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ DWORD dwImpersonationLevel);


void __RPC_STUB IWmiXMLTransformer_put_ImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_AuthenticationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ DWORD *pdwAuthenticationLevel);


void __RPC_STUB IWmiXMLTransformer_get_AuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_AuthenticationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ DWORD dwAuthenticationLevel);


void __RPC_STUB IWmiXMLTransformer_put_AuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Locale_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strLocale);


void __RPC_STUB IWmiXMLTransformer_get_Locale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Locale_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strLocale);


void __RPC_STUB IWmiXMLTransformer_put_Locale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_LocalOnly_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bLocalOnly);


void __RPC_STUB IWmiXMLTransformer_get_LocalOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_LocalOnly_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bLocalOnly);


void __RPC_STUB IWmiXMLTransformer_put_LocalOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_GetObject_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strObjectPath,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);


void __RPC_STUB IWmiXMLTransformer_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_ExecQuery_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strNamespacePath,
    /* [in] */ BSTR strQuery,
    /* [defaultvalue][in] */ BSTR strQueryLanguage,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumClasses_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strSuperClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumInstances_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumInstances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumClassNames_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strSuperClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumClassNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumInstanceNames_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strClassPath,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumInstanceNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_Compile_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT *pvInputSource,
    /* [in] */ BSTR strNamespacePath,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [in] */ WmiXMLCompilationTypeEnum iOperation,
    /* [in] */ IDispatch *pCtx,
    /* [retval][out] */ VARIANT_BOOL *pStatus);


void __RPC_STUB IWmiXMLTransformer_Compile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Privileges_Proxy( 
    IWmiXMLTransformer * This,
    /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet);


void __RPC_STUB IWmiXMLTransformer_get_Privileges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_CompilationErrors_Proxy( 
    IWmiXMLTransformer * This,
    /* [retval][out] */ BSTR *pstrErrors);


void __RPC_STUB IWmiXMLTransformer_get_CompilationErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWmiXMLTransformer_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WmiXMLTransformer;

#ifdef __cplusplus

class DECLSPEC_UUID("A2BB0F35-458E-4075-8A4B-F92664943917")
WmiXMLTransformer;
#endif
#endif /* __WmiXMLTransformer_LIBRARY_DEFINED__ */

#ifndef __ISWbemXMLDocumentSet_INTERFACE_DEFINED__
#define __ISWbemXMLDocumentSet_INTERFACE_DEFINED__

/* interface ISWbemXMLDocumentSet */
/* [helpstring][nonextensible][hidden][dual][oleautomation][uuid][object][local] */ 


EXTERN_C const IID IID_ISWbemXMLDocumentSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E46A227-5207-4603-8440-9FCC5AF16407")
    ISWbemXMLDocumentSet : public IDispatch
    {
    public:
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pUnk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ long iFlags,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NextDocument( 
            /* [unique][retval][out] */ IXMLDOMDocument **ppDoc) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SkipNextDocument( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISWbemXMLDocumentSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISWbemXMLDocumentSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISWbemXMLDocumentSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISWbemXMLDocumentSet * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISWbemXMLDocumentSet * This,
            /* [retval][out] */ IUnknown **pUnk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ long iFlags,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ISWbemXMLDocumentSet * This,
            /* [retval][out] */ long *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NextDocument )( 
            ISWbemXMLDocumentSet * This,
            /* [unique][retval][out] */ IXMLDOMDocument **ppDoc);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SkipNextDocument )( 
            ISWbemXMLDocumentSet * This);
        
        END_INTERFACE
    } ISWbemXMLDocumentSetVtbl;

    interface ISWbemXMLDocumentSet
    {
        CONST_VTBL struct ISWbemXMLDocumentSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISWbemXMLDocumentSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISWbemXMLDocumentSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISWbemXMLDocumentSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISWbemXMLDocumentSet_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISWbemXMLDocumentSet_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISWbemXMLDocumentSet_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISWbemXMLDocumentSet_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISWbemXMLDocumentSet_get__NewEnum(This,pUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,pUnk)

#define ISWbemXMLDocumentSet_Item(This,strObjectPath,iFlags,ppXMLDocument)	\
    (This)->lpVtbl -> Item(This,strObjectPath,iFlags,ppXMLDocument)

#define ISWbemXMLDocumentSet_get_Count(This,iCount)	\
    (This)->lpVtbl -> get_Count(This,iCount)

#define ISWbemXMLDocumentSet_NextDocument(This,ppDoc)	\
    (This)->lpVtbl -> NextDocument(This,ppDoc)

#define ISWbemXMLDocumentSet_SkipNextDocument(This)	\
    (This)->lpVtbl -> SkipNextDocument(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_get__NewEnum_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [retval][out] */ IUnknown **pUnk);


void __RPC_STUB ISWbemXMLDocumentSet_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_Item_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [in] */ BSTR strObjectPath,
    /* [defaultvalue][in] */ long iFlags,
    /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);


void __RPC_STUB ISWbemXMLDocumentSet_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_get_Count_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [retval][out] */ long *iCount);


void __RPC_STUB ISWbemXMLDocumentSet_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_NextDocument_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [unique][retval][out] */ IXMLDOMDocument **ppDoc);


void __RPC_STUB ISWbemXMLDocumentSet_NextDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_SkipNextDocument_Proxy( 
    ISWbemXMLDocumentSet * This);


void __RPC_STUB ISWbemXMLDocumentSet_SkipNextDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISWbemXMLDocumentSet_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\xprtdefs.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//===========================================================================
//
// filename XPrtDefs.h (Derived from edevdefs.h)
//
// External Device (like a VCR) control interface parameter and value definitions
//
// Note:new constants added: ED_BASE+800L -> ED_BASE+811L
//
// 1-30-98:
//   New constant added for DVCR: ED_BASE+900L -> ED_BASE+1000L
// 7-15-03:
//   Add new constants for device transports and device types: 
//       ED_BASE+1001L..ED_BASE+1037L
// 

#ifndef __XPRTDEFS__
#define __XPRTDEFS__


#define ED_BASE                        0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM     1
#define DEV_PORT_COM1    2    // standard serial ports
#define DEV_PORT_COM2    3
#define DEV_PORT_COM3    4
#define DEV_PORT_COM4    5
#define DEV_PORT_DIAQ    6    // Diaquest driver
#define DEV_PORT_ARTI    7    // ARTI driver
#define DEV_PORT_1394    8    // IEEE 1394 Serial Bus
#define DEV_PORT_USB     9    // Universal Serial Bus
#define DEV_PORT_MIN     DEV_PORT_SIM
#define DEV_PORT_MAX     DEV_PORT_USB


// IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//    OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD           ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE    ED_BASE+2L    // for multitrack devices: 
                                                     // switches currently recording tracks off 
                                                     // and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO            ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO            ED_BASE+4L
#define ED_DEVCAP_USES_FILES           ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE             ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE          ED_BASE+7L    // returns one of the following:
#define ED_DEVTYPE_VCR                 ED_BASE+8L
#define ED_DEVTYPE_LASERDISK           ED_BASE+9L
#define ED_DEVTYPE_ATR                 ED_BASE+10L
#define ED_DEVTYPE_DDR                 ED_BASE+11L
#define ED_DEVTYPE_ROUTER              ED_BASE+12L
#define ED_DEVTYPE_KEYER               ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO         ED_BASE+14L
#define ED_DEVTYPE_DVE                 ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN             ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO         ED_BASE+17L
#define ED_DEVTYPE_CG                  ED_BASE+18L
#define ED_DEVTYPE_TBC                 ED_BASE+19L
#define ED_DEVTYPE_TCG                 ED_BASE+20L
#define ED_DEVTYPE_GPI                 ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK            ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD            ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID   ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ        ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE       ED_BASE+26L
//    used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ          ED_BASE+27L
//    used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ           ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL              ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL             ED_BASE+30L

// returns indication of device's synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY        ED_BASE+31L    // returns one of the following:
#define ED_SYNCACC_PRECISE             ED_BASE+32L
#define ED_SYNCACC_FRAME               ED_BASE+33L
#define ED_SYNCACC_ROUGH               ED_BASE+34L

// returns device's normal framerate.
#define ED_DEVCAP_NORMAL_RATE          ED_BASE+35L    // returns one of the following:
#define ED_RATE_24                     ED_BASE+36L
#define ED_RATE_25                     ED_BASE+37L
#define ED_RATE_2997                   ED_BASE+38L
#define ED_RATE_30                     ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW    ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES  ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST             ED_BASE+42L
    
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS         ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS         ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING    ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE            ED_BASE+46L    // returns one of the following:
#define ED_SEEK_PERFECT                ED_BASE+47L    // indicates device can execute seek 
                                                      // within 1 video frames without signal 
                                                      //    break (like a DDR)
#define ED_SEEK_FAST                   ED_BASE+48L    // indicates device can move pretty quick 
                                                //  with short break in signal
#define ED_SEEK_SLOW                   ED_BASE+49L    // seeks like a tape transport

#define ED_POWER_ON                    ED_BASE+50L
#define ED_POWER_OFF                   ED_BASE+51L
#define ED_POWER_STANDBY               ED_BASE+52L

#define ED_POWER_DEVICE_DEPENDENT      ED_BASE+1033L  // Power is on with limited functions

#define ED_ACTIVE                      ED_BASE+53L
#define ED_INACTIVE                    ED_BASE+54L
#define ED_ALL                         ED_BASE+55L
#define ED_TEST                        ED_BASE+56L

//    IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//       OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT          ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY      ED_BASE+101L    // variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS ED_BASE+102L    // servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE         ED_BASE+103L    // show device's input on its output
#define ED_TRANSCAP_CAN_SET_PB         ED_BASE+104L    // show media playback on device's output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN ED_BASE+105L    // transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT ED_BASE+106L   // transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN ED_BASE+107L    // transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT ED_BASE+108L   // transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX   ED_BASE+109L    // max forward speed (multiple of play speed) 
                                                       //  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN   ED_BASE+800L    // min forward speed (multiple of play speed) 
                                                       //  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX   ED_BASE+110L    // max reverse speed (multiple of play speed) in
                                                       //  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN   ED_BASE+801L    // min reverse speed (multiple of play speed)
                                                       //  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX    ED_BASE+802L    // max forward speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN    ED_BASE+803L    // min forward speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX    ED_BASE+804L    // max reverse speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN    ED_BASE+805L    // min reverse speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS   ED_BASE+111L    // returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK          ED_BASE+112L    // returns track number of LTC timecode track.
                                                       //  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC          ED_BASE+113L    // device's output not stable
#define ED_TRANSCAP_NEEDS_CUEING       ED_BASE+114L    // device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT         ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE       ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP         ED_BASE+117L    // device responds to Frame Advance command by 
                                                       //  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE     ED_BASE+118L    // VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH  ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE         ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER          ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER          ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK          ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS     ED_BASE+806L    // OATRUE means device/filter can support
                                                       //  multiple edit events
#define ED_TRANSCAP_IS_MASTER          ED_BASE+807L    // OATRUE means device is the master clock
                                                       //  for synchronizing (this sets timecode-to-
                                                       //  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT             ED_BASE+814L    // OATRUE means device has Dynamic Tracking

//    IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP               ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN             ED_BASE+131L
#define ED_MEDIA_UNLOAD                ED_BASE+132L

//    IAMExtTransport Modes
#define ED_MODE_PLAY                   ED_BASE+200L    // Forward playback at normal speed
#define ED_MODE_STOP                   ED_BASE+201L
#define ED_MODE_FREEZE                 ED_BASE+202L    // Forward pause
#define ED_MODE_THAW                   ED_BASE+203L
#define ED_MODE_FF                     ED_BASE+204L    // Fast forward
#define ED_MODE_REW                    ED_BASE+205L    // Fast rewind
#define ED_MODE_RECORD                 ED_BASE+206L
#define ED_MODE_RECORD_STROBE          ED_BASE+207L
#define ED_MODE_RECORD_FREEZE          ED_BASE+808L    // Pause recording
#define ED_MODE_STEP                   ED_BASE+208L    // same as "jog"
#define ED_MODE_STEP_FWD               ED_BASE+208L    // same as ED_MODE_STEP - next frame
#define ED_MODE_STEP_REV               ED_BASE+809L    // Previous frame
#define ED_MODE_SHUTTLE                ED_BASE+209L
#define ED_MODE_EDIT_CUE               ED_BASE+210L
#define ED_MODE_VAR_SPEED              ED_BASE+211L
#define ED_MODE_PERFORM                ED_BASE+212L    // returned status only
#define ED_MODE_LINK_ON                ED_BASE+280L
#define ED_MODE_LINK_OFF               ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE          ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE         ED_BASE+811L
#define ED_MODE_SHOT_SEARCH            ED_BASE+812L


//    IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE           ED_BASE+400L    // can be one of the following:
#define ED_TCG_SMPTE_LTC               ED_BASE+401L
#define ED_TCG_SMPTE_VITC              ED_BASE+402L
#define ED_TCG_MIDI_QF                 ED_BASE+403L
#define ED_TCG_MIDI_FULL               ED_BASE+404L

#define ED_TCG_FRAMERATE               ED_BASE+405L    // can be one of the following:
#define ED_FORMAT_SMPTE_30             ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP         ED_BASE+407L
#define ED_FORMAT_SMPTE_25             ED_BASE+408L
#define ED_FORMAT_SMPTE_24             ED_BASE+409L

#define ED_TCG_SYNC_SOURCE             ED_BASE+410L    // can be one of the following:
#define ED_TCG_VIDEO                   ED_BASE+411L
#define ED_TCG_READER                  ED_BASE+412L
#define ED_TCG_FREE                    ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE        ED_BASE+414L    // can have one these values:
                                                       //    ED_TCG_FREE || ED_TCG_READER 
                                                       //    (for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE                  ED_BASE+416L    // can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC                     ED_BASE+417L
#define ED_TCR_VITC                    ED_BASE+418L
#define ED_TCR_CT                      ED_BASE+419L    // Control Track
#define ED_TCR_FTC                     ED_BASE+420L    // File TimeCode - for file-based devices
                                                //  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE              ED_BASE+421L    // for notification mode - 
                                                //  successive calls to GetTimecode
                                                //  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE                  ED_BASE+422L    // can be one of the following:
#define ED_TCR                         ED_BASE+423L
#define ED_TCG                         ED_BASE+424L

#define ED_TCD_SIZE                    ED_BASE+425L    // can be one of the following:
#define ED_SMALL                       ED_BASE+426L
#define ED_MED                         ED_BASE+427L
#define ED_LARGE                       ED_BASE+428L

#define ED_TCD_POSITION                ED_BASE+429L    // can be one of the following:
#define ED_TOP                         0x0001
#define ED_MIDDLE                      0x0002
#define ED_BOTTOM                      0x0004          // or'd  with
#define ED_LEFT                        0x0100
#define ED_CENTER                      0x0200
#define ED_RIGHT                       0x0400

#define ED_TCD_INTENSITY               ED_BASE+436L    // can be one of the following:
#define ED_HIGH                        ED_BASE+437L
#define ED_LOW                         ED_BASE+438L

#define ED_TCD_TRANSPARENCY            ED_BASE+439L    // 0-4, 0 is opaque

#define ED_TCD_INVERT                  ED_BASE+440L    // OATRUE=black on white
                                                       // OAFALSE=white on black
//    IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE                        ED_BASE+500L    // see ED_MODE_xxx values above
#define ED_ERROR                       ED_BASE+501L
#define ED_LOCAL                       ED_BASE+502L
#define ED_RECORD_INHIBIT              ED_BASE+503L
#define ED_SERVO_LOCK                  ED_BASE+504L
#define ED_MEDIA_PRESENT               ED_BASE+505L
#define ED_MEDIA_LENGTH                ED_BASE+506L
#define ED_MEDIA_SIZE                  ED_BASE+507L
#define ED_MEDIA_TRACK_COUNT           ED_BASE+508L
#define ED_MEDIA_TRACK_LENGTH          ED_BASE+509L
#define ED_MEDIA_SIDE                  ED_BASE+510L

#define ED_MEDIA_TYPE                  ED_BASE+511L    // can be one of the following:
#define ED_MEDIA_VHS                   ED_BASE+512L
#define ED_MEDIA_SVHS                  ED_BASE+513L
#define ED_MEDIA_HI8                   ED_BASE+514L
#define ED_MEDIA_UMATIC                ED_BASE+515L
#define ED_MEDIA_DVC                   ED_BASE+516L
#define ED_MEDIA_1_INCH                ED_BASE+517L
#define ED_MEDIA_D1                    ED_BASE+518L
#define ED_MEDIA_D2                    ED_BASE+519L
#define ED_MEDIA_D3                    ED_BASE+520L
#define ED_MEDIA_D5                    ED_BASE+521L
#define ED_MEDIA_DBETA                 ED_BASE+522L
#define ED_MEDIA_BETA                  ED_BASE+523L
#define ED_MEDIA_8MM                   ED_BASE+524L
#define ED_MEDIA_DDR                   ED_BASE+525L
#define ED_MEDIA_SX                    ED_BASE+813L
#define ED_MEDIA_OTHER                 ED_BASE+526L
#define ED_MEDIA_CLV                   ED_BASE+527L
#define ED_MEDIA_CAV                   ED_BASE+528L
#define ED_MEDIA_POSITION              ED_BASE+529L

#define ED_MEDIA_NEO                   ED_BASE+531L    // Mini digital tape for MPEG2TS signal
#define ED_MEDIA_MICROMV               ED_MEDIA_NEO

#define ED_LINK_MODE                   ED_BASE+530L    // OATRUE if transport controls
                                                       // are linked to graph's RUN, 
                                                       // STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define ED_TRANSBASIC_TIME_FORMAT      ED_BASE+540L    // can be one of the following:
#define ED_FORMAT_MILLISECONDS         ED_BASE+541L
#define ED_FORMAT_FRAMES               ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME       ED_BASE+543L

#define ED_FORMAT_HMSF                 ED_BASE+547L
#define ED_FORMAT_TMSF                 ED_BASE+548L

#define ED_TRANSBASIC_TIME_REFERENCE   ED_BASE+549L    // can be one of the following:
#define ED_TIMEREF_TIMECODE            ED_BASE+550L
#define ED_TIMEREF_CONTROL_TRACK       ED_BASE+551L
#define ED_TIMEREF_INDEX               ED_BASE+552L

#define ED_TRANSBASIC_SUPERIMPOSE      ED_BASE+553L    // enable/disable onscreen display
#define ED_TRANSBASIC_END_STOP_ACTION  ED_BASE+554L    // can be one of: ED_MODE_STOP |
                                                        //    ED_MODE_REWIND | ED_MODE_FREEZE
#define ED_TRANSBASIC_RECORD_FORMAT    ED_BASE+555L    // can be one of the following:
#define ED_RECORD_FORMAT_SP            ED_BASE+556L
#define ED_RECORD_FORMAT_LP            ED_BASE+557L
#define ED_RECORD_FORMAT_EP            ED_BASE+558L

#define ED_TRANSBASIC_STEP_COUNT       ED_BASE+559L
#define ED_TRANSBASIC_STEP_UNIT        ED_BASE+560L    // can be one of the following:
#define ED_STEP_FIELD                  ED_BASE+561L
#define ED_STEP_FRAME                  ED_BASE+562L
#define ED_STEP_3_2                    ED_BASE+563L

#define ED_TRANSBASIC_PREROLL          ED_BASE+564L
#define ED_TRANSBASIC_RECPREROLL       ED_BASE+565L
#define ED_TRANSBASIC_POSTROLL         ED_BASE+566L
#define ED_TRANSBASIC_EDIT_DELAY       ED_BASE+567L
#define ED_TRANSBASIC_PLAYTC_DELAY     ED_BASE+568L
#define ED_TRANSBASIC_RECTC_DELAY      ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD       ED_BASE+570L
#define ED_TRANSBASIC_FRAME_SERVO      ED_BASE+571L
#define ED_TRANSBASIC_CF_SERVO         ED_BASE+572L
#define ED_TRANSBASIC_SERVO_REF        ED_BASE+573L    // can be one of the following:
#define ED_REF_EXTERNAL                ED_BASE+574L
#define ED_REF_INPUT                   ED_BASE+575L
#define ED_REF_INTERNAL                ED_BASE+576L
#define ED_REF_AUTO                    ED_BASE+577L

#define ED_TRANSBASIC_WARN_GL          ED_BASE+578L
#define ED_TRANSBASIC_SET_TRACKING     ED_BASE+579L    // can be one of the following:
#define ED_TRACKING_PLUS               ED_BASE+580L
#define ED_TRACKING_MINUS              ED_BASE+581L
#define ED_TRACKING_RESET              ED_BASE+582L

#define ED_TRANSBASIC_SET_FREEZE_TIMEOUT ED_BASE+583L
#define ED_TRANSBASIC_VOLUME_NAME      ED_BASE+584L
#define ED_TRANSBASIC_BALLISTIC_1      ED_BASE+585L    // space for proprietary data
#define ED_TRANSBASIC_BALLISTIC_2      ED_BASE+586L
#define ED_TRANSBASIC_BALLISTIC_3      ED_BASE+587L
#define ED_TRANSBASIC_BALLISTIC_4      ED_BASE+588L
#define ED_TRANSBASIC_BALLISTIC_5      ED_BASE+589L
#define ED_TRANSBASIC_BALLISTIC_6      ED_BASE+590L
#define ED_TRANSBASIC_BALLISTIC_7      ED_BASE+591L
#define ED_TRANSBASIC_BALLISTIC_8      ED_BASE+592L
#define ED_TRANSBASIC_BALLISTIC_9      ED_BASE+593L
#define ED_TRANSBASIC_BALLISTIC_10     ED_BASE+594L
#define ED_TRANSBASIC_BALLISTIC_11     ED_BASE+595L
#define ED_TRANSBASIC_BALLISTIC_12     ED_BASE+596L
#define ED_TRANSBASIC_BALLISTIC_13     ED_BASE+597L
#define ED_TRANSBASIC_BALLISTIC_14     ED_BASE+598L
#define ED_TRANSBASIC_BALLISTIC_15     ED_BASE+599L
#define ED_TRANSBASIC_BALLISTIC_16     ED_BASE+600L
#define ED_TRANSBASIC_BALLISTIC_17     ED_BASE+601L
#define ED_TRANSBASIC_BALLISTIC_18     ED_BASE+602L
#define ED_TRANSBASIC_BALLISTIC_19     ED_BASE+603L
#define ED_TRANSBASIC_BALLISTIC_20     ED_BASE+604L

// consumer VCR items
#define ED_TRANSBASIC_SETCLOCK         ED_BASE+605L
#define ED_TRANSBASIC_SET_COUNTER_FORMAT ED_BASE+606L    // uses time format flags
#define ED_TRANSBASIC_SET_COUNTER_VALUE ED_BASE+607L

#define ED_TRANSBASIC_SETTUNER_CH_UP   ED_BASE+608L
#define ED_TRANSBASIC_SETTUNER_CH_DN   ED_BASE+609L
#define ED_TRANSBASIC_SETTUNER_SK_UP   ED_BASE+610L
#define ED_TRANSBASIC_SETTUNER_SK_DN   ED_BASE+611L
#define ED_TRANSBASIC_SETTUNER_CH      ED_BASE+612L
#define ED_TRANSBASIC_SETTUNER_NUM     ED_BASE+613L

#define ED_TRANSBASIC_SETTIMER_EVENT   ED_BASE+614L
#define ED_TRANSBASIC_SETTIMER_STARTDAY ED_BASE+615L
#define ED_TRANSBASIC_SETTIMER_STARTTIME ED_BASE+616L
#define ED_TRANSBASIC_SETTIMER_STOPDAY ED_BASE+617L
#define ED_TRANSBASIC_SETTIMER_STOPTIME ED_BASE+618L

// IAMExtTransport video parameters
#define ED_TRANSVIDEO_SET_OUTPUT       ED_BASE+630L    // can be one of the following:
#define ED_E2E                         ED_BASE+631L
#define ED_PLAYBACK                    ED_BASE+632L
#define ED_OFF                         ED_BASE+633L

#define ED_TRANSVIDEO_SET_SOURCE       ED_BASE+634L

// IAMExtTransport audio parameters
#define ED_TRANSAUDIO_ENABLE_OUTPUT    ED_BASE+640L    // can be the following:
#define ED_AUDIO_ALL                   0x10000000    //    or any of the following OR'd together
#define ED_AUDIO_1                     0x0000001L
#define ED_AUDIO_2                     0x0000002L
#define ED_AUDIO_3                     0x0000004L
#define ED_AUDIO_4                     0x0000008L
#define ED_AUDIO_5                     0x0000010L
#define ED_AUDIO_6                     0x0000020L
#define ED_AUDIO_7                     0x0000040L
#define ED_AUDIO_8                     0x0000080L
#define ED_AUDIO_9                     0x0000100L
#define ED_AUDIO_10                    0x0000200L
#define ED_AUDIO_11                    0x0000400L
#define ED_AUDIO_12                    0x0000800L
#define ED_AUDIO_13                    0x0001000L
#define ED_AUDIO_14                    0x0002000L
#define ED_AUDIO_15                    0x0004000L
#define ED_AUDIO_16                    0x0008000L
#define ED_AUDIO_17                    0x0010000L
#define ED_AUDIO_18                    0x0020000L
#define ED_AUDIO_19                    0x0040000L
#define ED_AUDIO_20                    0x0080000L
#define ED_AUDIO_21                    0x0100000L
#define ED_AUDIO_22                    0x0200000L
#define ED_AUDIO_23                    0x0400000L
#define ED_AUDIO_24                    0x0800000L
#define ED_VIDEO                       0x2000000L    // for Edit props below

#define ED_TRANSAUDIO_ENABLE_RECORD    ED_BASE+642L
#define ED_TRANSAUDIO_ENABLE_SELSYNC   ED_BASE+643L
#define ED_TRANSAUDIO_SET_SOURCE       ED_BASE+644L
#define ED_TRANSAUDIO_SET_MONITOR      ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID                     ED_BASE+652L
#define ED_EXECUTING                   ED_BASE+653L
#define ED_REGISTER                    ED_BASE+654L
#define ED_DELETE                      ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT                 ED_BASE+656L    // event handle to signal event 
                                                       // completion
#define ED_EDIT_TEST                   ED_BASE+657L    // returns OAFALSE if filter thinks
                                                       //  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE              ED_BASE+658L    // OATRUE means start put the 
                                                       // device into edit mode (editing
                                                       // "on the fly") immediately upon
                                                       //  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE                   ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE          ED_BASE+660L
#define ED_EDIT_MODE_INSERT            ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD      ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME     ED_BASE+663L    // these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER  ED_BASE+664L    // laserdisks

#define ED_EDIT_MASTER                 ED_BASE+666L    // OATRUE causes device 
                                                       //  not to synchronize

#define ED_EDIT_TRACK        ED_BASE+667L
// can be one of the following possible OR'd values:
//    ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT            ED_BASE+668L    // in current time format
#define ED_EDIT_SRC_OUTPOINT           ED_BASE+669L    // in current time format
#define ED_EDIT_REC_INPOINT            ED_BASE+670L    // in current time format
#define ED_EDIT_REC_OUTPOINT           ED_BASE+671L    // in current time format

#define ED_EDIT_REHEARSE_MODE          ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB                    ED_BASE+673L    // means rehearse the edit with 
                                                       //  "black-video-black"
#define ED_EDIT_VBV                    ED_BASE+674L
#define ED_EDIT_VVV                    ED_BASE+675L
#define ED_EDIT_PERFORM                ED_BASE+676L    // means perform the edit with no 
                                                       //  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT                  ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT                ED_BASE+678L        // in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK                   ED_BASE+679L    // OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE              ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN           ED_BASE+681L    // seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT          ED_BASE+682L    // seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL           ED_BASE+683L    // seek to edit's 
                                                       //  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT        ED_BASE+684L    // seek to preroll point 
                                                       // using control track (used for tapes with 
                                                       // discontinuoustimecode before edit point: seek
                                                       // to inpoint using timecode, then backup to 
                                                       // preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK          ED_BASE+685L    // seek to bookmark (just like 
                                                       //  timecode search)
// This property is used for multiple-VCR systems where each machine must
// cue to a different location relative to the graph's reference clock.  The
// basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
// that tells the VCR what offset to maintain between it's timecode (converted
// to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET                 ED_BASE+686L    // in current time format

#define ED_EDIT_PREREAD                ED_BASE+815L    // OATRUE means device supports
                                                       //  pre-read (recorder can also be
                                                       //  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY        ED_BASE+700L






// **************************************************
//
// New constants 
//
// **************************************************


//
// Additional Device type
//
#define ED_DEVTYPE_CAMERA              ED_BASE+900L

#define ED_DEVTYPE_TUNER               ED_BASE+901L

#define ED_DEVTYPE_DVHS                ED_BASE+902L     // Digital VHS

#define ED_DEVTYPE_UNKNOWN             ED_BASE+903L     // Driver cannot determine the device type

#define ED_DEVTYPE_CAMERA_STORAGE      ED_BASE+1034L    // Storage for digital still images, short video files, etc.

#define ED_DEVTYPE_DTV                 ED_BASE+1035L    // DTV with serial bus interface

#define ED_DEVTYPE_PC_VIRTUAL          ED_BASE+1036L    // Emulated device (virtual) on a PC



//
// Unknownn capability 
//     Instead of return E_NOTIMPL, or S_OK with OAFALSE, it may return S_OK with _UNKNOWN
//
#define ED_CAPABILITY_UNKNOWN          ED_BASE+910L


//
// Send raw 1394/AVC extenal device command via GetTransportBasicParameters()
// This is specifically for a 1394 AVC device connected with DEV_PORT_1394.
//
#define ED_RAW_EXT_DEV_CMD             ED_BASE+920L


//
// MEDIUM INFO
//
#define ED_MEDIA_VHSC                  ED_BASE+925L  // New media type
#define ED_MEDIA_UNKNOWN               ED_BASE+926L  // Unknown media
#define ED_MEDIA_NOT_PRESENT           ED_BASE+927L  


//
// Device Control command that can result in pending state.
//
#define ED_CONTROL_HEVENT_GET          ED_BASE+928L  // To get a sychronous event handle
#define ED_CONTROL_HEVENT_RELEASE      ED_BASE+929L  // To release sychronous event handle must match what it got

#define ED_DEV_REMOVED_HEVENT_GET      ED_BASE+960L  // To be a notify event and will be signal if device is removed.
#define ED_DEV_REMOVED_HEVENT_RELEASE  ED_BASE+961L  // Release this event handle


//
// TRANSPORT STATE
//
#define ED_NOTIFY_HEVENT_GET           ED_BASE+930L  // To get a sychronous event handle
#define ED_NOTIFY_HEVENT_RELEASE       ED_BASE+931L  // To release sychronous event handle must match what it got
#define ED_MODE_CHANGE_NOTIFY          ED_BASE+932L  // This is asynchronous operation, wait for event. 

#define ED_MODE_PLAY_FASTEST_FWD       ED_BASE+933L
#define ED_MODE_PLAY_SLOWEST_FWD       ED_BASE+934L
#define ED_MODE_PLAY_FASTEST_REV       ED_BASE+935L
#define ED_MODE_PLAY_SLOWEST_REV       ED_BASE+936L

#define ED_MODE_WIND                   ED_BASE+937L  
#define ED_MODE_REW_FASTEST            ED_BASE+938L  // High speed rewind

#define ED_MODE_REV_PLAY               ED_BASE+939L  // x1 speed reverse play

//
// Additional play modes (added post Windows XP)
//

#define ED_MODE_PLAY_SLOW_FWD_6        ED_BASE+1001L  // Slow forward
#define ED_MODE_PLAY_SLOW_FWD_5        ED_BASE+1002L
#define ED_MODE_PLAY_SLOW_FWD_4        ED_BASE+1003L
#define ED_MODE_PLAY_SLOW_FWD_3        ED_BASE+1004L
#define ED_MODE_PLAY_SLOW_FWD_2        ED_BASE+1005L
#define ED_MODE_PLAY_SLOW_FWD_1        ED_BASE+1006L

#define ED_MODE_PLAY_FAST_FWD_1        ED_BASE+1007L  // Fast forward
#define ED_MODE_PLAY_FAST_FWD_2        ED_BASE+1008L
#define ED_MODE_PLAY_FAST_FWD_3        ED_BASE+1009L
#define ED_MODE_PLAY_FAST_FWD_4        ED_BASE+1010L
#define ED_MODE_PLAY_FAST_FWD_5        ED_BASE+1011L
#define ED_MODE_PLAY_FAST_FWD_6        ED_BASE+1012L

#define ED_MODE_PLAY_SLOW_REV_6        ED_BASE+1013L  // Slow reverse
#define ED_MODE_PLAY_SLOW_REV_5        ED_BASE+1014L
#define ED_MODE_PLAY_SLOW_REV_4        ED_BASE+1015L
#define ED_MODE_PLAY_SLOW_REV_3        ED_BASE+1016L
#define ED_MODE_PLAY_SLOW_REV_2        ED_BASE+1017L
#define ED_MODE_PLAY_SLOW_REV_1        ED_BASE+1018L

#define ED_MODE_PLAY_FAST_REV_1        ED_BASE+1019L  // Fast reverse
#define ED_MODE_PLAY_FAST_REV_2        ED_BASE+1020L
#define ED_MODE_PLAY_FAST_REV_3        ED_BASE+1021L
#define ED_MODE_PLAY_FAST_REV_4        ED_BASE+1022L
#define ED_MODE_PLAY_FAST_REV_5        ED_BASE+1023L
#define ED_MODE_PLAY_FAST_REV_6        ED_BASE+1024L

#define ED_MODE_REVERSE                ED_MODE_REV_PLAY // Same as Reverse playback
#define ED_MODE_REVERSE_FREEZE         ED_BASE+1025L    // Pause at reverse playback

#define ED_MODE_PLAY_SLOW_FWD_X        ED_BASE+1026L    // Possible response for a trick play
#define ED_MODE_PLAY_FAST_FWD_X        ED_BASE+1027L    // Possible response for a trick play
#define ED_MODE_PLAY_SLOW_REV_X        ED_BASE+1028L    // Possible response for a trick play
#define ED_MODE_PLAY_FAST_REV_X        ED_BASE+1029L    // Possible response for a trick play

#define ED_MODE_STOP_START             ED_BASE+1030L    // Indicate stopping at the begin of a tape
#define ED_MODE_STOP_END               ED_BASE+1031L    // Indicate stopping at the end of a tape
#define ED_MODE_STOP_EMERGENCY         ED_BASE+1032L    // Indicate stopping due to an emergency 

//
// TRANSPOSRTBASIC: input and output signal
//
#define ED_TRANSBASIC_INPUT_SIGNAL        ED_BASE+940L
#define ED_TRANSBASIC_OUTPUT_SIGNAL       ED_BASE+941L

#define ED_TRANSBASIC_SIGNAL_525_60_SD    ED_BASE+942L
#define ED_TRANSBASIC_SIGNAL_525_60_SDL   ED_BASE+943L
#define ED_TRANSBASIC_SIGNAL_625_50_SD    ED_BASE+944L
#define ED_TRANSBASIC_SIGNAL_625_50_SDL   ED_BASE+945L

#define ED_TRANSBASIC_SIGNAL_625_60_HD    ED_BASE+947L
#define ED_TRANSBASIC_SIGNAL_625_50_HD    ED_BASE+948L

#define ED_TRANSBASIC_SIGNAL_MPEG2TS      ED_BASE+946L

#define ED_TRANSBASIC_SIGNAL_2500_60_MPEG ED_BASE+980L
#define ED_TRANSBASIC_SIGNAL_1250_60_MPEG ED_BASE+981L
#define ED_TRANSBASIC_SIGNAL_0625_60_MPEG ED_BASE+982L

#define ED_TRANSBASIC_SIGNAL_2500_50_MPEG ED_BASE+985L
#define ED_TRANSBASIC_SIGNAL_1250_50_MPEG ED_BASE+986L
#define ED_TRANSBASIC_SIGNAL_0625_50_MPEG ED_BASE+987L

#define ED_TRANSBASIC_SIGNAL_UNKNOWN      ED_BASE+990L

#define ED_TRANSBASIC_SIGNAL_525_60_DV25  ED_BASE+991L
#define ED_TRANSBASIC_SIGNAL_625_50_DV25  ED_BASE+992L

#define ED_TRANSBASIC_SIGNAL_525_60_DV50  ED_BASE+993L
#define ED_TRANSBASIC_SIGNAL_625_50_DV50  ED_BASE+994L

#define ED_TRANSBASIC_SIGNAL_HD_60_DVH1   ED_BASE+995L  // DVCPRO 100: 1080i or 720p
#define ED_TRANSBASIC_SIGNAL_HD_50_DVH1   ED_BASE+996L  // DVCPRO 100: 1080i only



//
// TIMECODE/AbsoluteTrackNumber/RealTimeCounter read/seek/write
//
#define ED_DEVCAP_TIMECODE_SEEK        ED_BASE+950L

#define ED_DEVCAP_ATN_READ             ED_BASE+951L
#define ED_DEVCAP_ATN_SEEK             ED_BASE+952L
#define ED_DEVCAP_ATN_WRITE            ED_BASE+953L

#define ED_DEVCAP_RTC_READ             ED_BASE+954L
#define ED_DEVCAP_RTC_SEEK             ED_BASE+955L
#define ED_DEVCAP_RTC_WRITE            ED_BASE+956L

//
// Basic parameter
//
#define ED_TIMEREF_ATN                 ED_BASE+958L


//
// GUID used to identify a class driver
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// 8C0F6AF2-0EDB-44c1-8AEB-59040BD830ED  MSTapeDeviceGUID
OUR_GUID_ENTRY(MSTapeDeviceGUID,
0x8C0F6AF2, 0x0EDB, 0x44c1, 0x8A, 0xEB, 0x59, 0x04, 0x0B, 0xD8, 0x30, 0xED)

#endif // __XPRTDEFS__

// eof XPrtDefs.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\XmlDomDid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDOMDID_H__
#define __XMLDOMDID_H__
//;end_internal

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\zmouse.h ===
/****************************************************************************
*                                                                           *
* ZMOUSE.H -- Include file for IntelliMouse(tm) 1.0                         *
*                                                                           *
* NOTE:  Zmouse.h contains #defines required when providing IntelliMouse    *
*        wheel support for Windows95 and NT3.51.  Wheel is supported        *
*        natively in WinNT4.0, please refer to the NT4.0 SDK for more info  *
*        on providing support for IntelliMouse in NT4.0.                    *
*                                                                           *
* Copyright (c) 1983-1999, Microsoft Corp. All rights reserved.             *
*                                                                           *
\***************************************************************************/


#if _MSC_VER > 1000
#pragma once
#endif

/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#ifdef UNICODE
#define MSH_MOUSEWHEEL L"MSWHEEL_ROLLMSG"
#else
#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
#endif
   // wParam = wheel rotation expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one notch


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	   *  determining if wheel support active
	   *  determining # of Scroll Lines
***************************************************************************/

// Class name for MSWHEEL.EXE's invisible window
// use FindWindow to get hwnd to MSWHEEL
#ifdef UNICODE
#define MOUSEZ_CLASSNAME  L"MouseZ"           // wheel window class
#define MOUSEZ_TITLE      L"Magellan MSWHEEL" // wheel window title
#else
#define MOUSEZ_CLASSNAME  "MouseZ"            // wheel window class
#define MOUSEZ_TITLE      "Magellan MSWHEEL"  // wheel window title
#endif

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines
// below to get the message numbers for:
// 1) the message that can be sent to the MSWHEEL window to
//    query if wheel support is active (MSH_WHEELSUPPORT)>
// 2) the message to query for the number of scroll lines
//    (MSH_SCROLL_LINES)
//
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is not currently available.

#ifdef UNICODE
#define MSH_WHEELSUPPORT L"MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                 // to query for wheel support
#else
#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG"  // name of msg to send
                                                 // to query for wheel support
#endif

// MSH_WHEELSUPPORT
//    wParam - not used
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise


#ifdef UNICODE
#define MSH_SCROLL_LINES L"MSH_SCROLL_LINES_MSG"
#else
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"
#endif

// MSH_SCROLL_LINES
//    wParam - not used
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL
#define WHEEL_PAGESCROLL  (UINT_MAX)   // signifies to scroll a page, also
                                       // defined in winuser.h in the
                                       // NT4.0 SDK
#endif

#ifndef SPI_SETWHEELSCROLLLINES
#define SPI_SETWHEELSCROLLLINES   105  // Also defined in winuser.h in the
                                       // NT4.0 SDK, please see the NT4.0 SDK
                                       // documentation for NT4.0 implementation
                                       // specifics.
                                       // For Win95 and WinNT3.51,
                                       // Mswheel broadcasts the message
                                       // WM_SETTINGCHANGE (equivalent to
                                       // WM_WININICHANGE) when the scroll
                                       // lines has changed.  Applications
                                       // will recieve the WM_SETTINGCHANGE
                                       // message with the wParam set to
                                       // SPI_SETWHEELSCROLLLINES.  When
                                       // this message is recieved the application
                                       // should query Mswheel for the new
                                       // setting.
#endif


/*********************************************************************
* INLINE FUNCTION: HwndMsWheel
* Purpose : Get a reference to MSWheel Window, the registered messages,
*           wheel support active setting, and number of scrollLines
* Params  : PUINT puiMsh_MsgMouseWheel - address of UINT to contain returned registered wheel message
*           PUINT puiMsh_Msg3DSupport - address of UINT to contain wheel support registered message
*           PUINT puiMsh_MsgScrollLines - address of UINT to contain Scroll lines registered message
*           PBOOL pf3DSupport - address of BOOL to contain returned flag for wheel support active
*           PINT  piScrollLines - address of int to contain returned scroll lines
* Returns : HWND handle to the MsWheel window
* Note    : The return value for pf3DSupport and piScrollLines is dependant
*           on the POINT32 module.  If POINT32 module is not running then
*           the values returned for these parameters will be
*           FALSE and 3, respectively.
*********************************************************************/
__inline HWND HwndMSWheel(
      PUINT puiMsh_MsgMouseWheel,
      PUINT puiMsh_Msg3DSupport,
      PUINT puiMsh_MsgScrollLines,
      PBOOL pf3DSupport,
      PINT  piScrollLines
)
{
   HWND hdlMsWheel;

   hdlMsWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);

   *puiMsh_MsgMouseWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);
   *puiMsh_Msg3DSupport = RegisterWindowMessage(MSH_WHEELSUPPORT);
   *puiMsh_MsgScrollLines = RegisterWindowMessage(MSH_SCROLL_LINES);

   if (*puiMsh_Msg3DSupport)
      *pf3DSupport = (BOOL)SendMessage(hdlMsWheel, *puiMsh_Msg3DSupport, 0, 0);
   else
      *pf3DSupport = FALSE;  // default to FALSE

   if (*puiMsh_MsgScrollLines)
      *piScrollLines = (int)SendMessage(hdlMsWheel, *puiMsh_MsgScrollLines, 0, 0);
   else
      *piScrollLines = 3;  // default

   return(hdlMsWheel);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\xmllite.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for xmllite.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __xmllite_h__
#define __xmllite_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXmlReader_FWD_DEFINED__
#define __IXmlReader_FWD_DEFINED__
typedef interface IXmlReader IXmlReader;
#endif 	/* __IXmlReader_FWD_DEFINED__ */


#ifndef __IXmlResolver_FWD_DEFINED__
#define __IXmlResolver_FWD_DEFINED__
typedef interface IXmlResolver IXmlResolver;
#endif 	/* __IXmlResolver_FWD_DEFINED__ */


#ifndef __IXmlWriter_FWD_DEFINED__
#define __IXmlWriter_FWD_DEFINED__
typedef interface IXmlWriter IXmlWriter;
#endif 	/* __IXmlWriter_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_xmllite_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//--------------------------------------------------------------------------



typedef IUnknown IXmlReaderInput;
typedef IUnknown IXmlWriterOutput;
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlReader Constructors
STDAPI CreateXmlReader(__in REFIID riid,
    __out void ** ppvObject,
    __in_opt IMalloc * pMalloc);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlReaderInput Constructors
STDAPI CreateXmlReaderInputWithEncodingCodePage(
    __in IUnknown * pInputStream,
    __in_opt IMalloc * pMalloc,
    __in UINT nEncodingCodePage,
    __in BOOL fEncodingHint,
    __in_opt LPCWSTR pwszBaseUri,
    __out IXmlReaderInput ** ppInput);
STDAPI CreateXmlReaderInputWithEncodingName(
    __in IUnknown * pInputStream,
    __in_opt IMalloc * pMalloc,
    __in LPCWSTR pwszEncodingName,
    __in BOOL fEncodingHint,
    __in_opt LPCWSTR pwszBaseUri,
    __out IXmlReaderInput ** ppInput);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlWriter Constructors
STDAPI CreateXmlWriter(__in REFIID riid,
    __out void ** ppvObject,
    __in_opt IMalloc * pMalloc);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlWriterOutput Constructors
STDAPI CreateXmlWriterOutputWithEncodingCodePage(
    __in IUnknown *pOutputStream,
    __in_opt IMalloc *pMalloc,
    __in UINT nEncodingCodePage,
    __out IXmlWriterOutput **ppOutput);
STDAPI CreateXmlWriterOutputWithEncodingName(
    __in IUnknown *pOutputStream,
    __in_opt IMalloc *pMalloc,
    __in LPCWSTR pwszEncodingName,
    __out IXmlWriterOutput **ppOutput);


extern RPC_IF_HANDLE __MIDL_itf_xmllite_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmllite_0000_0000_v0_0_s_ifspec;


#ifndef __XmlLite_LIBRARY_DEFINED__
#define __XmlLite_LIBRARY_DEFINED__

/* library XmlLite */
/* [version][lcid][helpstring][uuid] */ 

typedef 
enum XmlNodeType
    {	XmlNodeType_None	= 0,
	XmlNodeType_Element	= 1,
	XmlNodeType_Attribute	= 2,
	XmlNodeType_Text	= 3,
	XmlNodeType_CDATA	= 4,
	XmlNodeType_ProcessingInstruction	= 7,
	XmlNodeType_Comment	= 8,
	XmlNodeType_DocumentType	= 10,
	XmlNodeType_Whitespace	= 13,
	XmlNodeType_EndElement	= 15,
	XmlNodeType_XmlDeclaration	= 17,
	_XmlNodeType_Last	= 17
    } 	XmlNodeType;

typedef 
enum XmlConformanceLevel
    {	XmlConformanceLevel_Auto	= 0,
	XmlConformanceLevel_Fragment	= 1,
	XmlConformanceLevel_Document	= 2,
	_XmlConformanceLevel_Last	= 2
    } 	XmlConformanceLevel;

typedef 
enum DtdProcessing
    {	DtdProcessing_Prohibit	= 0,
	DtdProcessing_Parse	= ( DtdProcessing_Prohibit + 1 ) ,
	_DtdProcessing_Last	= DtdProcessing_Parse
    } 	DtdProcessing;

typedef 
enum XmlReadState
    {	XmlReadState_Initial	= 0,
	XmlReadState_Interactive	= 1,
	XmlReadState_Error	= 2,
	XmlReadState_EndOfFile	= 3,
	XmlReadState_Closed	= 4
    } 	XmlReadState;

typedef 
enum XmlReaderProperty
    {	XmlReaderProperty_MultiLanguage	= 0,
	XmlReaderProperty_ConformanceLevel	= ( XmlReaderProperty_MultiLanguage + 1 ) ,
	XmlReaderProperty_RandomAccess	= ( XmlReaderProperty_ConformanceLevel + 1 ) ,
	XmlReaderProperty_XmlResolver	= ( XmlReaderProperty_RandomAccess + 1 ) ,
	XmlReaderProperty_DtdProcessing	= ( XmlReaderProperty_XmlResolver + 1 ) ,
	XmlReaderProperty_ReadState	= ( XmlReaderProperty_DtdProcessing + 1 ) ,
	XmlReaderProperty_MaxElementDepth	= ( XmlReaderProperty_ReadState + 1 ) ,
	XmlReaderProperty_MaxEntityExpansion	= ( XmlReaderProperty_MaxElementDepth + 1 ) ,
	_XmlReaderProperty_Last	= XmlReaderProperty_MaxEntityExpansion
    } 	XmlReaderProperty;

typedef 
enum XmlError
    {	MX_E_MX	= 0xc00cee00,
	MX_E_INPUTEND	= ( MX_E_MX + 1 ) ,
	MX_E_ENCODING	= ( MX_E_INPUTEND + 1 ) ,
	MX_E_ENCODINGSWITCH	= ( MX_E_ENCODING + 1 ) ,
	MX_E_ENCODINGSIGNATURE	= ( MX_E_ENCODINGSWITCH + 1 ) ,
	WC_E_WC	= 0xc00cee20,
	WC_E_WHITESPACE	= ( WC_E_WC + 1 ) ,
	WC_E_SEMICOLON	= ( WC_E_WHITESPACE + 1 ) ,
	WC_E_GREATERTHAN	= ( WC_E_SEMICOLON + 1 ) ,
	WC_E_QUOTE	= ( WC_E_GREATERTHAN + 1 ) ,
	WC_E_EQUAL	= ( WC_E_QUOTE + 1 ) ,
	WC_E_LESSTHAN	= ( WC_E_EQUAL + 1 ) ,
	WC_E_HEXDIGIT	= ( WC_E_LESSTHAN + 1 ) ,
	WC_E_DIGIT	= ( WC_E_HEXDIGIT + 1 ) ,
	WC_E_LEFTBRACKET	= ( WC_E_DIGIT + 1 ) ,
	WC_E_LEFTPAREN	= ( WC_E_LEFTBRACKET + 1 ) ,
	WC_E_XMLCHARACTER	= ( WC_E_LEFTPAREN + 1 ) ,
	WC_E_NAMECHARACTER	= ( WC_E_XMLCHARACTER + 1 ) ,
	WC_E_SYNTAX	= ( WC_E_NAMECHARACTER + 1 ) ,
	WC_E_CDSECT	= ( WC_E_SYNTAX + 1 ) ,
	WC_E_COMMENT	= ( WC_E_CDSECT + 1 ) ,
	WC_E_CONDSECT	= ( WC_E_COMMENT + 1 ) ,
	WC_E_DECLATTLIST	= ( WC_E_CONDSECT + 1 ) ,
	WC_E_DECLDOCTYPE	= ( WC_E_DECLATTLIST + 1 ) ,
	WC_E_DECLELEMENT	= ( WC_E_DECLDOCTYPE + 1 ) ,
	WC_E_DECLENTITY	= ( WC_E_DECLELEMENT + 1 ) ,
	WC_E_DECLNOTATION	= ( WC_E_DECLENTITY + 1 ) ,
	WC_E_NDATA	= ( WC_E_DECLNOTATION + 1 ) ,
	WC_E_PUBLIC	= ( WC_E_NDATA + 1 ) ,
	WC_E_SYSTEM	= ( WC_E_PUBLIC + 1 ) ,
	WC_E_NAME	= ( WC_E_SYSTEM + 1 ) ,
	WC_E_ROOTELEMENT	= ( WC_E_NAME + 1 ) ,
	WC_E_ELEMENTMATCH	= ( WC_E_ROOTELEMENT + 1 ) ,
	WC_E_UNIQUEATTRIBUTE	= ( WC_E_ELEMENTMATCH + 1 ) ,
	WC_E_TEXTXMLDECL	= ( WC_E_UNIQUEATTRIBUTE + 1 ) ,
	WC_E_LEADINGXML	= ( WC_E_TEXTXMLDECL + 1 ) ,
	WC_E_TEXTDECL	= ( WC_E_LEADINGXML + 1 ) ,
	WC_E_XMLDECL	= ( WC_E_TEXTDECL + 1 ) ,
	WC_E_ENCNAME	= ( WC_E_XMLDECL + 1 ) ,
	WC_E_PUBLICID	= ( WC_E_ENCNAME + 1 ) ,
	WC_E_PESINTERNALSUBSET	= ( WC_E_PUBLICID + 1 ) ,
	WC_E_PESBETWEENDECLS	= ( WC_E_PESINTERNALSUBSET + 1 ) ,
	WC_E_NORECURSION	= ( WC_E_PESBETWEENDECLS + 1 ) ,
	WC_E_ENTITYCONTENT	= ( WC_E_NORECURSION + 1 ) ,
	WC_E_UNDECLAREDENTITY	= ( WC_E_ENTITYCONTENT + 1 ) ,
	WC_E_PARSEDENTITY	= ( WC_E_UNDECLAREDENTITY + 1 ) ,
	WC_E_NOEXTERNALENTITYREF	= ( WC_E_PARSEDENTITY + 1 ) ,
	WC_E_PI	= ( WC_E_NOEXTERNALENTITYREF + 1 ) ,
	WC_E_SYSTEMID	= ( WC_E_PI + 1 ) ,
	WC_E_QUESTIONMARK	= ( WC_E_SYSTEMID + 1 ) ,
	WC_E_CDSECTEND	= ( WC_E_QUESTIONMARK + 1 ) ,
	WC_E_MOREDATA	= ( WC_E_CDSECTEND + 1 ) ,
	WC_E_DTDPROHIBITED	= ( WC_E_MOREDATA + 1 ) ,
	WC_E_INVALIDXMLSPACE	= ( WC_E_DTDPROHIBITED + 1 ) ,
	NC_E_NC	= 0xc00cee60,
	NC_E_QNAMECHARACTER	= ( NC_E_NC + 1 ) ,
	NC_E_QNAMECOLON	= ( NC_E_QNAMECHARACTER + 1 ) ,
	NC_E_NAMECOLON	= ( NC_E_QNAMECOLON + 1 ) ,
	NC_E_DECLAREDPREFIX	= ( NC_E_NAMECOLON + 1 ) ,
	NC_E_UNDECLAREDPREFIX	= ( NC_E_DECLAREDPREFIX + 1 ) ,
	NC_E_EMPTYURI	= ( NC_E_UNDECLAREDPREFIX + 1 ) ,
	NC_E_XMLPREFIXRESERVED	= ( NC_E_EMPTYURI + 1 ) ,
	NC_E_XMLNSPREFIXRESERVED	= ( NC_E_XMLPREFIXRESERVED + 1 ) ,
	NC_E_XMLURIRESERVED	= ( NC_E_XMLNSPREFIXRESERVED + 1 ) ,
	NC_E_XMLNSURIRESERVED	= ( NC_E_XMLURIRESERVED + 1 ) ,
	SC_E_SC	= 0xc00cee80,
	SC_E_MAXELEMENTDEPTH	= ( SC_E_SC + 1 ) ,
	SC_E_MAXENTITYEXPANSION	= ( SC_E_MAXELEMENTDEPTH + 1 ) ,
	WR_E_WR	= 0xc00cef00,
	WR_E_NONWHITESPACE	= ( WR_E_WR + 1 ) ,
	WR_E_NSPREFIXDECLARED	= ( WR_E_NONWHITESPACE + 1 ) ,
	WR_E_NSPREFIXWITHEMPTYNSURI	= ( WR_E_NSPREFIXDECLARED + 1 ) ,
	WR_E_DUPLICATEATTRIBUTE	= ( WR_E_NSPREFIXWITHEMPTYNSURI + 1 ) ,
	WR_E_XMLNSPREFIXDECLARATION	= ( WR_E_DUPLICATEATTRIBUTE + 1 ) ,
	WR_E_XMLPREFIXDECLARATION	= ( WR_E_XMLNSPREFIXDECLARATION + 1 ) ,
	WR_E_XMLURIDECLARATION	= ( WR_E_XMLPREFIXDECLARATION + 1 ) ,
	WR_E_XMLNSURIDECLARATION	= ( WR_E_XMLURIDECLARATION + 1 ) ,
	WR_E_NAMESPACEUNDECLARED	= ( WR_E_XMLNSURIDECLARATION + 1 ) ,
	WR_E_INVALIDXMLSPACE	= ( WR_E_NAMESPACEUNDECLARED + 1 ) ,
	WR_E_INVALIDACTION	= ( WR_E_INVALIDXMLSPACE + 1 ) ,
	WR_E_INVALIDSURROGATEPAIR	= ( WR_E_INVALIDACTION + 1 ) ,
	XML_E_INVALID_DECIMAL	= 0xc00ce01d,
	XML_E_INVALID_HEXIDECIMAL	= 0xc00ce01e,
	XML_E_INVALID_UNICODE	= 0xc00ce01f,
	XML_E_INVALIDENCODING	= 0xc00ce06e
    } 	XmlError;

typedef 
enum XmlStandalone
    {	XmlStandalone_Omit	= 0,
	XmlStandalone_Yes	= 1,
	XmlStandalone_No	= 2,
	_XmlStandalone_Last	= 2
    } 	XmlStandalone;

typedef 
enum XmlWriterProperty
    {	XmlWriterProperty_MultiLanguage	= 0,
	XmlWriterProperty_Indent	= ( XmlWriterProperty_MultiLanguage + 1 ) ,
	XmlWriterProperty_ByteOrderMark	= ( XmlWriterProperty_Indent + 1 ) ,
	XmlWriterProperty_OmitXmlDeclaration	= ( XmlWriterProperty_ByteOrderMark + 1 ) ,
	XmlWriterProperty_ConformanceLevel	= ( XmlWriterProperty_OmitXmlDeclaration + 1 ) ,
	_XmlWriterProperty_Last	= XmlWriterProperty_OmitXmlDeclaration
    } 	XmlWriterProperty;


EXTERN_C const IID LIBID_XmlLite;

#ifndef __IXmlReader_INTERFACE_DEFINED__
#define __IXmlReader_INTERFACE_DEFINED__

/* interface IXmlReader */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_IXmlReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7279FC81-709D-4095-B63D-69FE4B0D9030")
    IXmlReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /*  */ 
            __in_opt  IUnknown *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __out  LONG_PTR *ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __in_opt  LONG_PTR pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /*  */ 
            __out_opt  XmlNodeType *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNodeType( 
            /*  */ 
            __out  XmlNodeType *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToFirstAttribute( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToNextAttribute( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToAttributeByName( 
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQualifiedName( 
            /*  */ 
            __out  LPCWSTR *ppwszQualifiedName,
            /*  */ 
            __out_opt  UINT *pcwchQualifiedName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceUri( 
            /*  */ 
            __out  LPCWSTR *ppwszNamespaceUri,
            /*  */ 
            __out_opt  UINT *pcwchNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalName( 
            /*  */ 
            __out  LPCWSTR *ppwszLocalName,
            /*  */ 
            __out_opt  UINT *pcwchLocalName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrefix( 
            /*  */ 
            __out  LPCWSTR *ppwszPrefix,
            /*  */ 
            __out_opt  UINT *pcwchPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /*  */ 
            __out  LPCWSTR *ppwszValue,
            /*  */ 
            __out_opt  UINT *pcwchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadValueChunk( 
            /*  */ 
            __out_ecount_part(cwchChunkSize, *pcwchRead)  WCHAR *pwchBuffer,
            /*  */ 
            __in  UINT cwchChunkSize,
            /*  */ 
            __inout  UINT *pcwchRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseUri( 
            /*  */ 
            __out  LPCWSTR *ppwszBaseUri,
            /*  */ 
            __out_opt  UINT *pcwchBaseUri) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsDefault( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsEmptyElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineNumber( 
            /*  */ 
            __out  UINT *pnLineNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinePosition( 
            /*  */ 
            __out  UINT *pnLinePosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /*  */ 
            __out  UINT *pnAttributeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDepth( 
            /*  */ 
            __out  UINT *pnDepth) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsEOF( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXmlReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXmlReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXmlReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            IXmlReader * This,
            /*  */ 
            __in_opt  IUnknown *pInput);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IXmlReader * This,
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __out  LONG_PTR *ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IXmlReader * This,
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __in_opt  LONG_PTR pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IXmlReader * This,
            /*  */ 
            __out_opt  XmlNodeType *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeType )( 
            IXmlReader * This,
            /*  */ 
            __out  XmlNodeType *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToFirstAttribute )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToNextAttribute )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToAttributeByName )( 
            IXmlReader * This,
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToElement )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifiedName )( 
            IXmlReader * This,
            /*  */ 
            __out  LPCWSTR *ppwszQualifiedName,
            /*  */ 
            __out_opt  UINT *pcwchQualifiedName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaceUri )( 
            IXmlReader * This,
            /*  */ 
            __out  LPCWSTR *ppwszNamespaceUri,
            /*  */ 
            __out_opt  UINT *pcwchNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalName )( 
            IXmlReader * This,
            /*  */ 
            __out  LPCWSTR *ppwszLocalName,
            /*  */ 
            __out_opt  UINT *pcwchLocalName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrefix )( 
            IXmlReader * This,
            /*  */ 
            __out  LPCWSTR *ppwszPrefix,
            /*  */ 
            __out_opt  UINT *pcwchPrefix);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IXmlReader * This,
            /*  */ 
            __out  LPCWSTR *ppwszValue,
            /*  */ 
            __out_opt  UINT *pcwchValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadValueChunk )( 
            IXmlReader * This,
            /*  */ 
            __out_ecount_part(cwchChunkSize, *pcwchRead)  WCHAR *pwchBuffer,
            /*  */ 
            __in  UINT cwchChunkSize,
            /*  */ 
            __inout  UINT *pcwchRead);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseUri )( 
            IXmlReader * This,
            /*  */ 
            __out  LPCWSTR *ppwszBaseUri,
            /*  */ 
            __out_opt  UINT *pcwchBaseUri);
        
        BOOL ( STDMETHODCALLTYPE *IsDefault )( 
            IXmlReader * This);
        
        BOOL ( STDMETHODCALLTYPE *IsEmptyElement )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXmlReader * This,
            /*  */ 
            __out  UINT *pnLineNumber);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXmlReader * This,
            /*  */ 
            __out  UINT *pnLinePosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IXmlReader * This,
            /*  */ 
            __out  UINT *pnAttributeCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDepth )( 
            IXmlReader * This,
            /*  */ 
            __out  UINT *pnDepth);
        
        BOOL ( STDMETHODCALLTYPE *IsEOF )( 
            IXmlReader * This);
        
        END_INTERFACE
    } IXmlReaderVtbl;

    interface IXmlReader
    {
        CONST_VTBL struct IXmlReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXmlReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXmlReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXmlReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXmlReader_SetInput(This,pInput)	\
    ( (This)->lpVtbl -> SetInput(This,pInput) ) 

#define IXmlReader_GetProperty(This,nProperty,ppValue)	\
    ( (This)->lpVtbl -> GetProperty(This,nProperty,ppValue) ) 

#define IXmlReader_SetProperty(This,nProperty,pValue)	\
    ( (This)->lpVtbl -> SetProperty(This,nProperty,pValue) ) 

#define IXmlReader_Read(This,pNodeType)	\
    ( (This)->lpVtbl -> Read(This,pNodeType) ) 

#define IXmlReader_GetNodeType(This,pNodeType)	\
    ( (This)->lpVtbl -> GetNodeType(This,pNodeType) ) 

#define IXmlReader_MoveToFirstAttribute(This)	\
    ( (This)->lpVtbl -> MoveToFirstAttribute(This) ) 

#define IXmlReader_MoveToNextAttribute(This)	\
    ( (This)->lpVtbl -> MoveToNextAttribute(This) ) 

#define IXmlReader_MoveToAttributeByName(This,pwszLocalName,pwszNamespaceUri)	\
    ( (This)->lpVtbl -> MoveToAttributeByName(This,pwszLocalName,pwszNamespaceUri) ) 

#define IXmlReader_MoveToElement(This)	\
    ( (This)->lpVtbl -> MoveToElement(This) ) 

#define IXmlReader_GetQualifiedName(This,ppwszQualifiedName,pcwchQualifiedName)	\
    ( (This)->lpVtbl -> GetQualifiedName(This,ppwszQualifiedName,pcwchQualifiedName) ) 

#define IXmlReader_GetNamespaceUri(This,ppwszNamespaceUri,pcwchNamespaceUri)	\
    ( (This)->lpVtbl -> GetNamespaceUri(This,ppwszNamespaceUri,pcwchNamespaceUri) ) 

#define IXmlReader_GetLocalName(This,ppwszLocalName,pcwchLocalName)	\
    ( (This)->lpVtbl -> GetLocalName(This,ppwszLocalName,pcwchLocalName) ) 

#define IXmlReader_GetPrefix(This,ppwszPrefix,pcwchPrefix)	\
    ( (This)->lpVtbl -> GetPrefix(This,ppwszPrefix,pcwchPrefix) ) 

#define IXmlReader_GetValue(This,ppwszValue,pcwchValue)	\
    ( (This)->lpVtbl -> GetValue(This,ppwszValue,pcwchValue) ) 

#define IXmlReader_ReadValueChunk(This,pwchBuffer,cwchChunkSize,pcwchRead)	\
    ( (This)->lpVtbl -> ReadValueChunk(This,pwchBuffer,cwchChunkSize,pcwchRead) ) 

#define IXmlReader_GetBaseUri(This,ppwszBaseUri,pcwchBaseUri)	\
    ( (This)->lpVtbl -> GetBaseUri(This,ppwszBaseUri,pcwchBaseUri) ) 

#define IXmlReader_IsDefault(This)	\
    ( (This)->lpVtbl -> IsDefault(This) ) 

#define IXmlReader_IsEmptyElement(This)	\
    ( (This)->lpVtbl -> IsEmptyElement(This) ) 

#define IXmlReader_GetLineNumber(This,pnLineNumber)	\
    ( (This)->lpVtbl -> GetLineNumber(This,pnLineNumber) ) 

#define IXmlReader_GetLinePosition(This,pnLinePosition)	\
    ( (This)->lpVtbl -> GetLinePosition(This,pnLinePosition) ) 

#define IXmlReader_GetAttributeCount(This,pnAttributeCount)	\
    ( (This)->lpVtbl -> GetAttributeCount(This,pnAttributeCount) ) 

#define IXmlReader_GetDepth(This,pnDepth)	\
    ( (This)->lpVtbl -> GetDepth(This,pnDepth) ) 

#define IXmlReader_IsEOF(This)	\
    ( (This)->lpVtbl -> IsEOF(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXmlReader_INTERFACE_DEFINED__ */


#ifndef __IXmlResolver_INTERFACE_DEFINED__
#define __IXmlResolver_INTERFACE_DEFINED__

/* interface IXmlResolver */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_IXmlResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7279FC82-709D-4095-B63D-69FE4B0D9030")
    IXmlResolver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResolveUri( 
            /*  */ 
            __in_opt  LPCWSTR pwszBaseUri,
            /*  */ 
            __in_opt  LPCWSTR pwszPublicIdentifier,
            /*  */ 
            __in_opt  LPCWSTR pwszSystemIdentifier,
            /*  */ 
            __out  IUnknown **ppResolvedInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXmlResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXmlResolver * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXmlResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXmlResolver * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveUri )( 
            IXmlResolver * This,
            /*  */ 
            __in_opt  LPCWSTR pwszBaseUri,
            /*  */ 
            __in_opt  LPCWSTR pwszPublicIdentifier,
            /*  */ 
            __in_opt  LPCWSTR pwszSystemIdentifier,
            /*  */ 
            __out  IUnknown **ppResolvedInput);
        
        END_INTERFACE
    } IXmlResolverVtbl;

    interface IXmlResolver
    {
        CONST_VTBL struct IXmlResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXmlResolver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXmlResolver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXmlResolver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXmlResolver_ResolveUri(This,pwszBaseUri,pwszPublicIdentifier,pwszSystemIdentifier,ppResolvedInput)	\
    ( (This)->lpVtbl -> ResolveUri(This,pwszBaseUri,pwszPublicIdentifier,pwszSystemIdentifier,ppResolvedInput) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXmlResolver_INTERFACE_DEFINED__ */


#ifndef __IXmlWriter_INTERFACE_DEFINED__
#define __IXmlWriter_INTERFACE_DEFINED__

/* interface IXmlWriter */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_IXmlWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7279FC88-709D-4095-B63D-69FE4B0D9030")
    IXmlWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutput( 
            /*  */ 
            __in_opt  IUnknown *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __out  LONG_PTR *ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __in_opt  LONG_PTR pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAttributes( 
            /*  */ 
            __in  IXmlReader *pReader,
            /*  */ 
            __in  BOOL fWriteDefaultAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAttributeString( 
            /*  */ 
            __in_opt  LPCWSTR pwszPrefix,
            /*  */ 
            __in_opt  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /*  */ 
            __in_opt  LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteCData( 
            /*  */ 
            __in_opt  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteCharEntity( 
            /*  */ 
            __in  WCHAR wch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteChars( 
            /*  */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /*  */ 
            __in  UINT cwch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteComment( 
            /*  */ 
            __in_opt  LPCWSTR pwszComment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDocType( 
            /*  */ 
            __in_opt  LPCWSTR pwszName,
            /*  */ 
            __in_opt  LPCWSTR pwszPublicId,
            /*  */ 
            __in_opt  LPCWSTR pwszSystemId,
            /*  */ 
            __in_opt  LPCWSTR pwszSubset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteElementString( 
            /*  */ 
            __in_opt  LPCWSTR pwszPrefix,
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /*  */ 
            __in_opt  LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteEndDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteEndElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteEntityRef( 
            /*  */ 
            __in  LPCWSTR pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteFullEndElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteName( 
            /*  */ 
            __in  LPCWSTR pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteNmToken( 
            /*  */ 
            __in  LPCWSTR pwszNmToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteNode( 
            /*  */ 
            __in  IXmlReader *pReader,
            /*  */ 
            __in  BOOL fWriteDefaultAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteNodeShallow( 
            /*  */ 
            __in  IXmlReader *pReader,
            /*  */ 
            __in  BOOL fWriteDefaultAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteProcessingInstruction( 
            /*  */ 
            __in  LPCWSTR pwszName,
            /*  */ 
            __in_opt  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQualifiedName( 
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteRaw( 
            /*  */ 
            __in_opt  LPCWSTR pwszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteRawChars( 
            /*  */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /*  */ 
            __in  UINT cwch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStartDocument( 
            /*  */ 
            __in  XmlStandalone standalone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStartElement( 
            /*  */ 
            __in_opt  LPCWSTR pwszPrefix,
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteString( 
            /*  */ 
            __in_opt  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSurrogateCharEntity( 
            /*  */ 
            __in  WCHAR wchLow,
            /*  */ 
            __in  WCHAR wchHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteWhitespace( 
            /*  */ 
            __in_opt  LPCWSTR pwszWhitespace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXmlWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXmlWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXmlWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutput )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  IUnknown *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IXmlWriter * This,
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __out  LONG_PTR *ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IXmlWriter * This,
            /*  */ 
            __in  UINT nProperty,
            /*  */ 
            __in_opt  LONG_PTR pValue);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAttributes )( 
            IXmlWriter * This,
            /*  */ 
            __in  IXmlReader *pReader,
            /*  */ 
            __in  BOOL fWriteDefaultAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAttributeString )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszPrefix,
            /*  */ 
            __in_opt  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /*  */ 
            __in_opt  LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *WriteCData )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *WriteCharEntity )( 
            IXmlWriter * This,
            /*  */ 
            __in  WCHAR wch);
        
        HRESULT ( STDMETHODCALLTYPE *WriteChars )( 
            IXmlWriter * This,
            /*  */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /*  */ 
            __in  UINT cwch);
        
        HRESULT ( STDMETHODCALLTYPE *WriteComment )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszComment);
        
        HRESULT ( STDMETHODCALLTYPE *WriteDocType )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszName,
            /*  */ 
            __in_opt  LPCWSTR pwszPublicId,
            /*  */ 
            __in_opt  LPCWSTR pwszSystemId,
            /*  */ 
            __in_opt  LPCWSTR pwszSubset);
        
        HRESULT ( STDMETHODCALLTYPE *WriteElementString )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszPrefix,
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /*  */ 
            __in_opt  LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *WriteEndDocument )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteEndElement )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteEntityRef )( 
            IXmlWriter * This,
            /*  */ 
            __in  LPCWSTR pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *WriteFullEndElement )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteName )( 
            IXmlWriter * This,
            /*  */ 
            __in  LPCWSTR pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *WriteNmToken )( 
            IXmlWriter * This,
            /*  */ 
            __in  LPCWSTR pwszNmToken);
        
        HRESULT ( STDMETHODCALLTYPE *WriteNode )( 
            IXmlWriter * This,
            /*  */ 
            __in  IXmlReader *pReader,
            /*  */ 
            __in  BOOL fWriteDefaultAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *WriteNodeShallow )( 
            IXmlWriter * This,
            /*  */ 
            __in  IXmlReader *pReader,
            /*  */ 
            __in  BOOL fWriteDefaultAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *WriteProcessingInstruction )( 
            IXmlWriter * This,
            /*  */ 
            __in  LPCWSTR pwszName,
            /*  */ 
            __in_opt  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *WriteQualifiedName )( 
            IXmlWriter * This,
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *WriteRaw )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszData);
        
        HRESULT ( STDMETHODCALLTYPE *WriteRawChars )( 
            IXmlWriter * This,
            /*  */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /*  */ 
            __in  UINT cwch);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStartDocument )( 
            IXmlWriter * This,
            /*  */ 
            __in  XmlStandalone standalone);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStartElement )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszPrefix,
            /*  */ 
            __in  LPCWSTR pwszLocalName,
            /*  */ 
            __in_opt  LPCWSTR pwszNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *WriteString )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSurrogateCharEntity )( 
            IXmlWriter * This,
            /*  */ 
            __in  WCHAR wchLow,
            /*  */ 
            __in  WCHAR wchHigh);
        
        HRESULT ( STDMETHODCALLTYPE *WriteWhitespace )( 
            IXmlWriter * This,
            /*  */ 
            __in_opt  LPCWSTR pwszWhitespace);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IXmlWriter * This);
        
        END_INTERFACE
    } IXmlWriterVtbl;

    interface IXmlWriter
    {
        CONST_VTBL struct IXmlWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXmlWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXmlWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXmlWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXmlWriter_SetOutput(This,pOutput)	\
    ( (This)->lpVtbl -> SetOutput(This,pOutput) ) 

#define IXmlWriter_GetProperty(This,nProperty,ppValue)	\
    ( (This)->lpVtbl -> GetProperty(This,nProperty,ppValue) ) 

#define IXmlWriter_SetProperty(This,nProperty,pValue)	\
    ( (This)->lpVtbl -> SetProperty(This,nProperty,pValue) ) 

#define IXmlWriter_WriteAttributes(This,pReader,fWriteDefaultAttributes)	\
    ( (This)->lpVtbl -> WriteAttributes(This,pReader,fWriteDefaultAttributes) ) 

#define IXmlWriter_WriteAttributeString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue)	\
    ( (This)->lpVtbl -> WriteAttributeString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue) ) 

#define IXmlWriter_WriteCData(This,pwszText)	\
    ( (This)->lpVtbl -> WriteCData(This,pwszText) ) 

#define IXmlWriter_WriteCharEntity(This,wch)	\
    ( (This)->lpVtbl -> WriteCharEntity(This,wch) ) 

#define IXmlWriter_WriteChars(This,pwch,cwch)	\
    ( (This)->lpVtbl -> WriteChars(This,pwch,cwch) ) 

#define IXmlWriter_WriteComment(This,pwszComment)	\
    ( (This)->lpVtbl -> WriteComment(This,pwszComment) ) 

#define IXmlWriter_WriteDocType(This,pwszName,pwszPublicId,pwszSystemId,pwszSubset)	\
    ( (This)->lpVtbl -> WriteDocType(This,pwszName,pwszPublicId,pwszSystemId,pwszSubset) ) 

#define IXmlWriter_WriteElementString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue)	\
    ( (This)->lpVtbl -> WriteElementString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue) ) 

#define IXmlWriter_WriteEndDocument(This)	\
    ( (This)->lpVtbl -> WriteEndDocument(This) ) 

#define IXmlWriter_WriteEndElement(This)	\
    ( (This)->lpVtbl -> WriteEndElement(This) ) 

#define IXmlWriter_WriteEntityRef(This,pwszName)	\
    ( (This)->lpVtbl -> WriteEntityRef(This,pwszName) ) 

#define IXmlWriter_WriteFullEndElement(This)	\
    ( (This)->lpVtbl -> WriteFullEndElement(This) ) 

#define IXmlWriter_WriteName(This,pwszName)	\
    ( (This)->lpVtbl -> WriteName(This,pwszName) ) 

#define IXmlWriter_WriteNmToken(This,pwszNmToken)	\
    ( (This)->lpVtbl -> WriteNmToken(This,pwszNmToken) ) 

#define IXmlWriter_WriteNode(This,pReader,fWriteDefaultAttributes)	\
    ( (This)->lpVtbl -> WriteNode(This,pReader,fWriteDefaultAttributes) ) 

#define IXmlWriter_WriteNodeShallow(This,pReader,fWriteDefaultAttributes)	\
    ( (This)->lpVtbl -> WriteNodeShallow(This,pReader,fWriteDefaultAttributes) ) 

#define IXmlWriter_WriteProcessingInstruction(This,pwszName,pwszText)	\
    ( (This)->lpVtbl -> WriteProcessingInstruction(This,pwszName,pwszText) ) 

#define IXmlWriter_WriteQualifiedName(This,pwszLocalName,pwszNamespaceUri)	\
    ( (This)->lpVtbl -> WriteQualifiedName(This,pwszLocalName,pwszNamespaceUri) ) 

#define IXmlWriter_WriteRaw(This,pwszData)	\
    ( (This)->lpVtbl -> WriteRaw(This,pwszData) ) 

#define IXmlWriter_WriteRawChars(This,pwch,cwch)	\
    ( (This)->lpVtbl -> WriteRawChars(This,pwch,cwch) ) 

#define IXmlWriter_WriteStartDocument(This,standalone)	\
    ( (This)->lpVtbl -> WriteStartDocument(This,standalone) ) 

#define IXmlWriter_WriteStartElement(This,pwszPrefix,pwszLocalName,pwszNamespaceUri)	\
    ( (This)->lpVtbl -> WriteStartElement(This,pwszPrefix,pwszLocalName,pwszNamespaceUri) ) 

#define IXmlWriter_WriteString(This,pwszText)	\
    ( (This)->lpVtbl -> WriteString(This,pwszText) ) 

#define IXmlWriter_WriteSurrogateCharEntity(This,wchLow,wchHigh)	\
    ( (This)->lpVtbl -> WriteSurrogateCharEntity(This,wchLow,wchHigh) ) 

#define IXmlWriter_WriteWhitespace(This,pwszWhitespace)	\
    ( (This)->lpVtbl -> WriteWhitespace(This,pwszWhitespace) ) 

#define IXmlWriter_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXmlWriter_INTERFACE_DEFINED__ */

#endif /* __XmlLite_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xmllite_0001_0113 */
/* [local] */ 

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IID helpers
#define IID_IXmlReader   __uuidof(IXmlReader)
#define IID_IXmlWriter   __uuidof(IXmlWriter)
#define IID_IXmlResolver __uuidof(IXmlResolver)


extern RPC_IF_HANDLE __MIDL_itf_xmllite_0001_0113_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmllite_0001_0113_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\xoleHlp.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft   D.T.C (Distributed Transaction Coordinator)

 (c) 1995    Microsoft Corporation.  All Rights Reserved


Filename :  xolehlp.h
            contains DTC helper APIs used by RM's and application clients
            to obtain the transaction manager
----------------------------------------------------------------------------- */

#ifndef __XOLEHLP__H__
#define __XOLEHLP__H__


/*----------------------------------------
//  Defines
//--------------------------------------*/
#ifdef _M_CEE_PURE
#define EXPORTAPI HRESULT
#else
#define EXPORTAPI __declspec( dllexport )HRESULT
#endif

/*----------------------------------------
// Constants
//--------------------------------------*/
const DWORD     OLE_TM_CONFIG_VERSION_1     = 1;
const DWORD     OLE_TM_CONFIG_VERSION_2     = 2;

typedef enum APPLICATIONTYPE
{
    LOCAL_APPLICATIONTYPE,
    CLUSTERRESOURCE_APPLICATIONTYPE
};

const DWORD     OLE_TM_FLAG_NONE            = 0x00000000;
const DWORD     OLE_TM_FLAG_NODEMANDSTART   = 0x00000001;

// If this flag is set, the application specifies that it does not wish 
// to take advantage of any features that need agile recovery 
// support. 
// As a consequence,  the application will be restricted to 
// using the default transaction manager on a cluster.
const DWORD     OLE_TM_FLAG_NOAGILERECOVERY = 0x00000002;

// The following are flags used specifically for MSDTC.
const DWORD     OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS = 0x80000000;
const DWORD     OLE_TM_FLAG_INTERNAL_TO_TM  =          0x40000000;

/*----------------------------------------
//  Structure definitions
//--------------------------------------*/
typedef struct _OLE_TM_CONFIG_PARAMS_V1
{
    DWORD       dwVersion;
    DWORD       dwcConcurrencyHint;
} OLE_TM_CONFIG_PARAMS_V1;

typedef struct _OLE_TM_CONFIG_PARAMS_V2
{
    DWORD           dwVersion;
    DWORD           dwcConcurrencyHint;
    APPLICATIONTYPE applicationType;
    GUID            clusterResourceId;
} OLE_TM_CONFIG_PARAMS_V2;


/*----------------------------------------
//  Function Prototypes
//--------------------------------------*/

/*----------------------------------------
//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which 
//case the MS DTC on the same host is contacted and the interface provided
//for it.
//--------------------------------------*/
EXPORTAPI __cdecl DtcGetTransactionManager( 
                                    /* in */ __in LPSTR i_pszHost,
                                    /* in */ __in LPSTR i_pszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_dwReserved1,
                                    /* in */ WORD i_wcbReserved2,
                                    /* in */ __in_bcount(i_wcbReserved2) void * i_pvReserved2,
                                    /* out */ void** o_ppvObject
                                    );
EXTERN_C HRESULT __cdecl DtcGetTransactionManagerC(
                                    /* in */ __in LPSTR i_pszHost,
                                    /* in */ __in LPSTR i_pszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_dwReserved1,
                                    /* in */ WORD i_wcbReserved2,
                                    /* in */ __in_bcount(i_wcbReserved2) void * i_pvReserved2,
                                    /* out */ void ** o_ppvObject
                                    );

EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExA(
                                    /* in */ __in_opt LPSTR i_pszHost,
                                    /* in */ __in_opt LPSTR i_pszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_grfOptions,
                                    /* in */ void * i_pvConfigParams,
                                    /* out */ void ** o_ppvObject
                                    );


EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExW(
                                    /* in */ __in_opt LPWSTR i_pwszHost,
                                    /* in */ __in_opt LPWSTR i_pwszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_grfOptions,
                                    /* in */ void * i_pvConfigParams,
                                    /* out */ void ** o_ppvObject
                                    );
#ifdef UNICODE
#define DtcGetTransactionManagerEx      DtcGetTransactionManagerExW
#else
#define DtcGetTransactionManagerEx      DtcGetTransactionManagerExA
#endif


#ifndef EXTERN_GUID
#define EXTERN_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) DEFINE_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)
#endif

/*----------------------------------------
// Define a CLSID that can be used to obtain a transaction manager instance via CoCreateInstance;
// this is an alternate to using DtcGetTransactionManager. 
//
// CLSID_MSDtcTransactionManager = {5B18AB61-091D-11d1-97DF-00C04FB9618A}
//--------------------------------------*/
EXTERN_GUID(CLSID_MSDtcTransactionManager, 0x5b18ab61, 0x91d, 0x11d1, 0x97, 0xdf, 0x0, 0xc0, 0x4f, 0xb9, 0x61, 0x8a);

/*----------------------------------------
// Define a CLSID that can be used with CoCreateInstance to instantiate a vanilla transaction
// object with the local transaction manager. It's equivalent to doing 
//
//  pTransactionDispenser->BeginTransaction(NULL, ISOLATIONLEVEL_UNSPECIFIED, ISOFLAG_RETAIN_DONTCARE, NULL, &ptx);
//
// CLSID_MSDtcTransaction = {39F8D76B-0928-11d1-97DF-00C04FB9618A}
//--------------------------------------*/
EXTERN_GUID(CLSID_MSDtcTransaction, 0x39f8d76b, 0x928, 0x11d1, 0x97, 0xdf, 0x0, 0xc0, 0x4f, 0xb9, 0x61, 0x8a);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\_dbdao.h ===
/************************************************************************
**	_ D B D A O . H													*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 			*
**		   All Rights Reserved					 						*
************************************************************************/
/*
	_DBDAO.H

	Internal definitions and prototypes for dbdao C++ classes
*/
#ifndef __DBDAO_H_
#define __DBDAO_H_


/*****************************************************************************
* Forwards
*/
class COleVariant;
class CdbBookmark;
class CdbException;
class CdbOleObject;
class CdbObject;
class CdbError;
class CdbProperty;
class CdbDBEngine;
class CdbWorkspace;
class CdbDatabase;
class CdbConnection;
class CdbRecordset;
class CdbGetRowsEx;
class CdbQueryDef;
class CdbTableDef;
class CdbField;
class CdbRelation;
class CdbIndex;
class CdbUser;
class CdbGroup;
class CdbDocument;
class CdbContainer;
class CdbParameter;
class CdbCollection;
class CdbErrors;
class CdbProperties;
class CdbWorkspaces;
class CdbDatabases;
class CdbConnections;
class CdbRecordsets;
class CdbQueryDefs;
class CdbTableDefs;
class CdbFields;
class CdbRelations;
class CdbIndexes;
class CdbUsers;
class CdbGroups;
class CdbDocuments;
class CdbContainers;
class CdbParameters;
class CdbBStr;

/*****************************************************************************
* DAO runtime key
*/
const char szKEY[] = "mbmabptebkjcdlgtjmskjwtsdhjbmkmwtrak";

/*****************************************************************************
* Miscellaneous defines
*/
#define DAO_MAXSEEKFIELDS 13


/*****************************************************************************
* CdbBSTR (OLE BSTR helper)
*/
class DLLEXPORT CdbBSTR
	{
	public:
	CONSTRUCTOR			CdbBSTR				(BSTR=NULL);
	DESTRUCTOR			~CdbBSTR			(VOID);

	operator			BSTR *				(VOID);
	operator			LPCTSTR				(VOID);

	private:
	BSTR				m_bstr;
	};

/*****************************************************************************
* CdbVariant (OLE Variant helper)
*/
class CdbVariant : public COleVariant
	{
	public:
	CONSTRUCTOR						CdbVariant						(LONG l);
	CONSTRUCTOR                     CdbVariant                      (VOID);
	CONSTRUCTOR                     CdbVariant                      (LPCTSTR pstr);
	CONSTRUCTOR                     CdbVariant                      (SHORT s, BOOL bIsBool = FALSE);
	CONSTRUCTOR                     CdbVariant                      (LPVARIANT pv);
	CONSTRUCTOR                     CdbVariant                      (LPSAFEARRAY psa);

	VOID                            operator =                      (LPVARIANT pv);
	VOID                            operator =                      (LPCTSTR pstr);
	VOID                            operator =                      (SHORT s);
	VOID                            operator =                      (const int i);
	VOID                            operator =                      (LONG l);
	};

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	VOID) : COleVariant()
	{
	vt		= VT_ERROR;
	scode	= DISP_E_PARAMNOTFOUND;
	}

inline CdbVariant::CdbVariant (LONG l)
{
		if (l == -1)		
			{	
			vt		= VT_ERROR;
			scode	= DISP_E_PARAMNOTFOUND;
			}
		else
			{
			vt		= VT_I4;
			lVal	= l;
			}
}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPCTSTR pstr): COleVariant(pstr,VT_BSTRT)
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	SHORT s, BOOL bIsBool) : COleVariant(s)
	{
	if (bIsBool)
		{
		vt		= VT_BOOL;
		boolVal	= s;
		}
	else if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPVARIANT	pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPSAFEARRAY psa)
	{
	if (!psa)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_ARRAY|VT_UI1;
		parray	= psa;
		}
	}

inline VOID	CdbVariant::operator =(
	LPVARIANT pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline VOID	CdbVariant::operator =(
	LPCTSTR pstr) 
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
#ifdef UNICODE
		bstrVal = SysAllocString(pstr);
#else
		bstrVal = SysAllocStringByteLen(pstr, strlen(pstr));
#endif
		vt = VT_BSTR;
		}
	}


inline VOID	CdbVariant::operator =(
	SHORT s)
	{
	if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= s;
		}
	}

inline VOID	CdbVariant::operator =(
	const int i)
	{
	if (i==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= (SHORT)i;
		}
	}


inline VOID	CdbVariant::operator =(
	LONG 	l)
	{
	if (l==-1)
		{
		vt 		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I4;
		lVal	= l;
		}
	}


/*****************************************************************************
* CdbWide
*/
HRESULT	CdbWideFromAnsi(LPSTR, unsigned int, BSTR *);

class CdbWide
	{
	public:
	CONSTRUCTOR			CdbWide				(LPSTR pstr, unsigned int cb=0)
		{
		CdbWideFromAnsi(pstr, (pstr ? (cb==0 ? strlen(pstr) : cb) : 0), &m_bstr);
		}
	DESTRUCTOR			~CdbWide			()
		{
		SysFreeString(m_bstr);
		}

	operator			LPWSTR					()
		{
		return (LPWSTR)m_bstr;
		}
	operator			LPSTR					()
		{
		return (LPSTR)m_bstr;
		}

	ULONG				cBytes					()
		{
		return SysStringByteLen(m_bstr);
		}

	private:
	BSTR				m_bstr;
	};


/*****************************************************************************
* CdbOleObject
*/
class DLLEXPORT CdbOleObject : public CObject
	{
	public:
	CONSTRUCTOR                             CdbOleObject            (VOID);
	virtual DESTRUCTOR						~CdbOleObject           (VOID);
	BOOL                                    Exists                  (VOID);
	CdbOleObject &							operator =              (CdbOleObject &o);
											operator LPUNKNOWN		(){ return GetInterface();}
	VOID                                    SetInterface            (LPUNKNOWN punk, BOOL bAddRef=FALSE);
	VOID                                    SetInterface            (REFIID riidClass, REFIID riidInterface);
	VOID                                    SetInterfaceLic         (REFIID riidClass, REFIID riidInterface);
	LPUNKNOWN								GetInterface            (BOOL bAddRef=FALSE, BOOL bThrowException=TRUE) const;

	virtual VOID							OnInterfaceChange       (VOID);
	VOID                                    SetRichErrorInfo        (LPOLESTR pstrSource, LPOLESTR pstrDescription, LPOLESTR pstrHelpFile, ULONG ulHelpID) const;

	protected:
	BOOL                                    StartOLE                        (VOID);
	LPUNKNOWN                               m_punkInterface;
	};



/*****************************************************************************
* CdbCollection
*/
class DLLEXPORT CdbCollection : public CdbOleObject
	{
	public:

	// Methods
	virtual CdbObject               ObItem                  (LONG i) = 0;
	virtual CdbObject               ObItem                  (LPCTSTR pstr) = 0;
	virtual LONG                    GetCount                (VOID) = 0;
	virtual VOID                    ObAppend                (CdbObject &obj) = 0;
	virtual VOID                    Delete                  (LPCTSTR pstr) = 0;
	virtual VOID                    Refresh                 (VOID) = 0;
	};

class DLLEXPORT CdbStaticCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID) ;
	};

class DLLEXPORT CdbDynamicCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID);
	};

#define DAOMFC_STATIC_COLLECTION_DECL(objColl, objSingle, intSingle)    \
	class DLLEXPORT objColl : public CdbStaticCollection                                                    \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

#define DAOMFC_DYNAMIC_COLLECTION_DECL(objColl, objSingle, intSingle)   \
	class DLLEXPORT objColl : public CdbDynamicCollection                                                   \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		VOID                            Append                          (objSingle &o);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

DAOMFC_STATIC_COLLECTION_DECL(CdbErrors, CdbError, DAOError);
DAOMFC_STATIC_COLLECTION_DECL(CdbDatabases, CdbDatabase, DAODatabase);
//Connections are special cased so we can trap the copy constructor
DAOMFC_STATIC_COLLECTION_DECL(CdbRecordsets, CdbRecordset, DAORecordset);
DAOMFC_STATIC_COLLECTION_DECL(CdbParameters, CdbParameter, DAOParameter);
DAOMFC_STATIC_COLLECTION_DECL(CdbDocuments, CdbDocument, DAODocument);
DAOMFC_STATIC_COLLECTION_DECL(CdbContainers, CdbContainer, DAOContainer);

DAOMFC_DYNAMIC_COLLECTION_DECL(CdbProperties, CdbProperty, DAOProperty);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbFields, CdbField, DAOField);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbQueryDefs, CdbQueryDef, DAOQueryDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbTableDefs, CdbTableDef, DAOTableDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbIndexes, CdbIndex, DAOIndex);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbRelations, CdbRelation, DAORelation);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbUsers, CdbUser, DAOUser);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbGroups, CdbGroup, DAOGroup);

//Need some extra functions in CdbWorkspaces to support the delay in creating the 
//default workspace needed to support the JET/ODBC option.
class DLLEXPORT CdbWorkspaces : public CdbDynamicCollection
	{        
	friend CdbDBEngine;
	private:
	DAODBEngine	*					pDBEng;
	BOOL							m_bDontStart;

	public:                                                                                                                 
	CONSTRUCTOR                     CdbWorkspaces			(VOID){pDBEng = NULL;}
	CdbWorkspace                    Item                    (LONG i);                               
	CdbWorkspace                    Item                    (LPCTSTR pstr);                 
	VOID                            Append                  (CdbWorkspace &o);                 
	CdbWorkspace                    operator[]              (LONG i);                         
	CdbWorkspace                    operator[]              (LPCTSTR pstr);                
	VOID                            SetDBEngine	            (DAODBEngine	*peng){pDBEng = peng;}
	VOID	                        GetDelayedInterface     ();
	};

//Need to trap Connections in the copy constructor so the user can't
//get a "sorta-kinda" working Connections collection on a Jet workspace
class DLLEXPORT CdbConnections : public CdbStaticCollection
	{        
	public:
	CONSTRUCTOR						CdbConnections			(CdbConnections &Connections);
	CONSTRUCTOR						CdbConnections			(){pwrk = NULL;}
	CdbConnection                   Item                    (LONG i);                               
	CdbConnection                   Item                    (LPCTSTR pstr);                 
	CdbConnection                   operator[]              (LONG i);                               
	CdbConnection                   operator[]              (LPCTSTR pstr);               
	CdbConnections	&				operator =				(CdbConnections &o);
	LONG                            GetCount                (VOID);
	VOID                            Refresh                 (VOID) ;
	VOID							SetWorkspace			(DAOWorkspace * pParent){pwrk = pParent;}			

	private:
	VOID							CheckInterface();
	DAOWorkspace *					pwrk;
	};

/*****************************************************************************
* CdbObject
*/
class DLLEXPORT CdbObject : public CdbOleObject
	{
	public:
	CONSTRUCTOR                             CdbObject                       (VOID);
	CONSTRUCTOR                             CdbObject                       (LPUNKNOWN punk, BOOL bAddRef=FALSE);

	virtual CString                 GetName                         (VOID); 
	virtual VOID                    SetName                         (LPCTSTR pstr);

	CdbProperties                   Properties;
	};



/*****************************************************************************
* CdbGetRowsEx  (holds GetRowsEx for Recordset)
*/

class DLLEXPORT CdbGetRowsEx : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbGetRowsEx            (VOID);
	CONSTRUCTOR                     CdbGetRowsEx            (ICDAORecordset *pGetRows, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbGetRowsEx            (const CdbGetRowsEx &);
	CdbGetRowsEx &          operator =                      (const CdbGetRowsEx &);
	VOID                            OnInterfaceChange       (VOID);

	};

/*****************************************************************************
* Helper macros
*/

//Initialize a variant
#define DAOVINIT(var)						\
	do										\
		{									\
		(var).vt	= VT_ERROR;				\
		(var).scode	= DISP_E_PARAMNOTFOUND;	\
		}									\
	while (0)


// LPTSTR to VARIANT
#define STV(pstr)	CdbVariant(pstr)

// LPTSTR to BSTR
#define STB(pstr)	V_BSTR(((LPVARIANT)STV(pstr)))

// LONG to VARIANT
#define LTV(l)		CdbVariant(l)

// Optional LONG to VARIANT
#define OLTV(l)		CdbVariant((l))

// C/C++ bool to DAO bool
#define BTB(b)		((VARIANT_BOOL)(b?-1:0))

// C/C++ bool to VARIANT
#define BTV(b)		CdbVariant(BTB(b), TRUE)

// C/C++ short to VARIANT
#define SHTV(s)		CdbVariant((SHORT)s)

// OLE variant to VARIANT
#define VTV(pv)		CdbVariant(pv)

// SAFEARRAY to VARIANT
#define ATV(psa, var)								\
	do												\
		{											\
		if (!psa)									\
			{										\
			var.vt		= VT_ERROR;					\
			var.scode	= DISP_E_PARAMNOTFOUND;		\
			}										\
		else										\
			{										\
			var.vt		= VT_ARRAY|VT_UI1;			\
			SafeArrayCopy(psa, &var.parray);	\
			}										\
		}											\
	while (0)

#define DAOMFC_CALL(hr)						\
	do \
	{ \
    HRESULT  hresult = (hr);           \
		if(FAILED(hresult)) \
		{ \
			TRACE0("\nDBDAO Call Failed.\n\t"); \
			TRACE2("\nIn file %s on line %d\n", _T("DBDAO.CPP"), __LINE__); \
			TRACE1("hResult = %X\n", hresult); \
			if (GetScode(hresult) == E_OUTOFMEMORY) \
				AfxThrowMemoryException(); \
			else \
				throw CdbException(hresult); \
		} \
	} while (0)


/*****************************************************************************
* Property Set/Get helper macros
*/

// Get a LONG property
#define LPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		LONG		l	= 0;						\
													\
		DAOMFC_CALL(p->meth(&l));					\
													\
		return l;									\
		}											\
	while (0)

// Set a LONG property
#define LPROPSET(intDAO, meth, l)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(l));					\
		}											\
	while(0)

// Get a SHORT property
#define WPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		SHORT		s	= 0;						\
													\
		DAOMFC_CALL(p->meth(&s));					\
													\
		return s;									\
		}											\
	while (0)

// Set a SHORT property
#define WPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(s));					\
		}											\
	while(0)

// Get a STRING property
#define SPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		CdbBSTR		bstr;							\
													\
		DAOMFC_CALL(p->meth(bstr));					\
													\
		return bstr;								\
		}											\
	while (0)

// Set a STRING property
#define SPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(STB(s)));				\
		}											\
	while(0)

// Get a DATETIME property
#define DPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		VARIANT 	Var;								\
													\
		VariantInit(&Var);							\
		DAOMFC_CALL(p->meth(&Var));					\
		return Var;									\
		}											\
	while (0)

// Set a DATETIME property
#define DPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a BOOLEAN property
#define BPROPGET(intDAO, meth)							\
	do													\
		{												\
		intDAO *		p	= (intDAO *)GetInterface();	\
		VARIANT_BOOL	vb	= 0;						\
														\
		DAOMFC_CALL(p->meth(&vb));						\
														\
		return (BOOL)vb;								\
		}												\
	while (0)

// Set a BOOLEAN property
#define BPROPSET(intDAO, meth, b)						\
	do													\
		{												\
		intDAO *	p = (intDAO *)GetInterface();		\
														\
		DAOMFC_CALL(p->meth(BTB(b)));					\
		}												\
	while(0)

// Get a VARIANT property
#define VPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		COleVariant 	v;								\
													\
		VariantInit(&v);							\
		DAOMFC_CALL(p->meth(&v));					\
													\
		return &v;									\
		}											\
	while (0)

// Set a VARIANT property
#define VPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a DWORD property
#define DWPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		DWORD		dw	= 0;						\
													\
		DAOMFC_CALL(p->meth(&dw));					\
													\
		return dw;									\
		}											\
	while (0)


#define DAOMFC_STATIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

#define DAOMFC_DYNAMIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		VOID				objColl::Append				(objSingle &o)	{ ObAppend(o); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

DECLARE_INTERFACE_(DAOMFCSCollection, _DAOCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};

DECLARE_INTERFACE_(DAOMFCDCollection, _DAODynaCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};


#endif // __DBDAO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\atl90\afx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_H__
#define __AFX_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

#pragma once

/////////////////////////////////////////////////////////////////////////////

#ifdef _DLL
#ifndef _AFXDLL
#error Building MFC application with /MD[d] (CRT dll version) requires MFC shared dll version. Please #define _AFXDLL or do not use /MD[d]
#endif
#endif

// Since MFC itself is built with wchar_t as a native type, it will not have
// the correct type info for types built with wchar_t typedef'd to unsigned
// short.  Make sure that the user's app builds this type info in this case.
#ifndef _NATIVE_WCHAR_T_DEFINED
#define _AFX_FULLTYPEINFO
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 
 
#ifdef __ATLDBGMEM_H__
#error <atldbgmem.h> cannot be used in MFC projects. See AfxEnableMemoryTracking
#endif

#if defined(_MFC_DLL_BLD) && defined(_DEBUG)
#ifndef _CRTDBG_MAP_ALLOC
#define _CRTDBG_MAP_ALLOC
#endif
#endif

#ifndef _INC_NEW
	#include <new.h>
#endif

#include <afxver_.h>        // Target version control

#ifdef _WIN64
#ifndef _AFX_NO_DAO_SUPPORT
#define _AFX_NO_DAO_SUPPORT
#endif
#endif

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _AFXDLL
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "nafxcwd.lib")
		#else
			#pragma comment(lib, "nafxcw.lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "uafxcwd.lib")
		#else
			#pragma comment(lib, "uafxcw.lib")
		#endif
	#endif
#else
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "d.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "d.lib")
		#else
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER ".lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER ".lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "ud.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "ud.lib")
		#else
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "u.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "u.lib")
		#endif
	#endif
#endif

#ifdef _DLL
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "msvcrtd.lib")
	#else
		#pragma comment(lib, "msvcrt.lib")
	#endif
#else
#ifdef _MT
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "libcmtd.lib")
	#else
		#pragma comment(lib, "libcmt.lib")
	#endif
#else
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "libcd.lib")
	#else
		#pragma comment(lib, "libc.lib")
	#endif
#endif
#endif

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "msimg32.lib")
#pragma comment(lib, "comdlg32.lib")
#pragma comment(lib, "winspool.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "shlwapi.lib")

// force inclusion of NOLIB.OBJ for /disallowlib directives
#pragma comment(linker, "/include:__afxForceEXCLUDE")

// force inclusion of DLLMODUL.OBJ for _USRDLL
#ifdef _USRDLL
#pragma comment(linker, "/include:__afxForceUSRDLL")
#endif

// force inclusion of STDAFX.OBJ for precompiled types
#ifdef _AFXDLL
#pragma comment(linker, "/include:__afxForceSTDAFX")
#endif

#endif //!_AFX_NOFORCE_LIBS

#if !defined( _AFX_NOFORCE_MANIFEST ) && !defined(_VC_NODEFAULTLIB) && defined( _AFXDLL )

#define __MFC_MAKE_STR_HELPER(x) #x
#define __MFC_MAKE_STR(x) __MFC_MAKE_STR_HELPER(x)

#include <mfcassem.h>

#endif	// !_AFX_NOFORCE_MANIFEST && !_VC_NODEFAULTLIB && _AFXDLL

#ifdef _MANAGED

#ifndef AFX_NO_CLR_COINIT_STA
#pragma comment(linker, "/CLRTHREADATTRIBUTE:STA")
#endif 

#endif //_MANAGED
/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file
//   in addition to standard primitive data types and various helper macros

struct CRuntimeClass;          // object type information

class CObject;                        // the root of all objects classes

	class CException;                 // the root of all exceptions
		class CArchiveException;      // archive exception
		class CFileException;         // file exception
		class CSimpleException;
			class CMemoryException;       // out-of-memory exception
			class CNotSupportedException; // feature not supported exception
			class CInvalidArgException;	  // one of the parameters to the function is invalid

	class CFile;                      // raw binary file
		class CStdioFile;             // buffered stdio text/binary file
		class CMemFile;               // memory based file

// Non CObject classes
struct CFileStatus;                   // file status information
struct CMemoryState;                  // diagnostic memory support

class CArchive;                       // object persistence tool
class CDumpContext;                   // object diagnostic dumping

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	#include <stdio.h>
#endif
#ifndef _INC_STDLIB
	#include <stdlib.h>
#endif
#ifndef _INC_TIME
	#include <time.h>
#endif
#ifndef _INC_LIMITS
	#include <limits.h>
#endif
#ifndef _INC_STDDEF
	#include <stddef.h>
#endif
#ifndef _INC_STDARG
	#include <stdarg.h>
#endif
#ifndef _INC_ERRNO 
#include <errno.h>
#endif

#include <malloc.h>

#ifndef _AFX_NO_DEBUG_CRT
#ifndef _INC_CRTDBG
	#include <crtdbg.h>
#endif
#endif // _AFX_NO_DEBUG_CRT

#ifdef _AFX_OLD_EXCEPTIONS
#error MFC no longer supports setjmp/longjmp exception handling.
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Basic types
// abstract iteration position
struct __POSITION {};
typedef __POSITION* POSITION;

// Standard constants
#undef FALSE
#undef TRUE
#undef NULL

#define FALSE   0
#define TRUE    1
#define NULL    0

/////////////////////////////////////////////////////////////////////////////
// _AFX_FUNCNAME definition
#ifdef UNICODE
#define _AFX_FUNCNAME(_Name) _Name##W
#else
#define _AFX_FUNCNAME(_Name) _Name##A
#endif

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files

#pragma warning(disable: 4505)  // unreferenced local function has been removed
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // function not inlined
#pragma warning(disable: 4127)  // constant expression used in macros do while(0);

// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning( push )
#endif

// warnings generated with common MFC/Windows code
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4191)  // pointer-to-function casting
// warnings caused by normal optimizations
#ifndef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif
// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4204)  // non-constant aggregate initializer
#endif
#pragma warning(disable: 4263 4264)  // base class method is hidden

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG

BOOL AFXAPI AfxAssertFailedLine(LPCSTR lpszFileName, int nLine);

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...);
// Note: file names are still ANSI strings (filenames rarely need UNICODE)
void AFXAPI AfxAssertValidObject(const CObject* pOb,
				LPCSTR lpszFileName, int nLine);
void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView

#include <atltrace.h>

// extern ATL::CTrace TRACE;
#define TRACE ATLTRACE

#define THIS_FILE          __FILE__
#define VERIFY(f)          ASSERT(f)
#define DEBUG_ONLY(f)      (f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              TRACE(_T("%s"), _T(sz))
#define TRACE1(sz, p1)          TRACE(_T(sz), p1)
#define TRACE2(sz, p1, p2)      TRACE(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  TRACE(_T(sz), p1, p2, p3)

// These AFX_DUMP macros also provided for backward compatibility
#define AFX_DUMP0(dc, sz)   dc << _T(sz)
#define AFX_DUMP1(dc, sz, p1) dc << _T(sz) << p1

#else   // _DEBUG

#define VERIFY(f)          ((void)(f))
#define DEBUG_ONLY(f)      ((void)0)
#pragma warning(push)
#pragma warning(disable : 4793)
inline void AFX_CDECL AfxTrace(...) { }
#pragma warning(pop)
#define TRACE              __noop
#define TRACE0(sz)
#define TRACE1(sz, p1)
#define TRACE2(sz, p1, p2)
#define TRACE3(sz, p1, p2, p3)

#endif // !_DEBUG

#define ASSERT(f)          DEBUG_ONLY((void) ((f) || !::AfxAssertFailedLine(THIS_FILE, __LINE__) || (AfxDebugBreak(), 0)))
/* see ATL headers for commentary on this */
/* We use the name AFXASSUME to avoid name clashes */

#if defined(_PREFAST_) || defined (_DEBUG)
#define AFXASSUME(cond)			do { bool __afx_condVal=!!(cond); ASSERT(__afx_condVal); __analysis_assume(__afx_condVal); } while(0) 
#else
#define AFXASSUME(cond)			((void)0)
#endif

#define ASSERT_VALID(pOb)  DEBUG_ONLY((::AfxAssertValidObject(pOb, THIS_FILE, __LINE__)))

// Debug ASSERTs then throws. Retail throws if condition not met
#define ENSURE_THROW(cond, exception)	\
	do { int __afx_condVal=!!(cond); ASSERT(__afx_condVal); if (!(__afx_condVal)){exception;} } while (false)
#define ENSURE(cond)		ENSURE_THROW(cond, ::AfxThrowInvalidArgException() )
#define ENSURE_ARG(cond)	ENSURE_THROW(cond, ::AfxThrowInvalidArgException() )

// Debug ASSERT_VALIDs then throws. Retail throws if pOb is NULL
#define ENSURE_VALID_THROW(pOb, exception)	\
	do { ASSERT_VALID(pOb); if (!(pOb)){exception;} } while (false)
#define ENSURE_VALID(pOb)	ENSURE_VALID_THROW(pOb, ::AfxThrowInvalidArgException() )

#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && AfxIsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || AfxIsValidAddress((p), sizeof(type), FALSE))

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x

#ifdef _DEBUG
#define REPORT_EXCEPTION(pException, szMsg) \
	do { \
		TCHAR szErrorMessage[512]; \
		if (pException->GetErrorMessage(szErrorMessage, sizeof(szErrorMessage)/sizeof(*szErrorMessage), 0)) \
			TRACE(traceAppMsg, 0, _T("%s (%s:%d)\n%s\n"), szMsg, _T(__FILE__), __LINE__, szErrorMessage); \
		else \
			TRACE(traceAppMsg, 0, _T("%s (%s:%d)\n"), szMsg, _T(__FILE__), __LINE__); \
		ASSERT(FALSE); \
	} while (0)
#else
#define REPORT_EXCEPTION(pException, szMsg) \
	do { \
		CString strMsg; \
		TCHAR  szErrorMessage[512]; \
		if (pException->GetErrorMessage(szErrorMessage, sizeof(szErrorMessage)/sizeof(*szErrorMessage), 0)) \
			strMsg.Format(_T("%s (%s:%d)\n%s"), szMsg, _T(__FILE__), __LINE__, szErrorMessage); \
		else \
			strMsg.Format(_T("%s (%s:%d)"), szMsg, _T(__FILE__), __LINE__); \
		AfxMessageBox(strMsg); \
	} while (0)
#endif

#define EXCEPTION_IN_DTOR(pException) \
	do { \
		REPORT_EXCEPTION((pException), _T("Exception thrown in destructor")); \
		delete pException; \
	} while (0)
	
#define AFX_BEGIN_DESTRUCTOR try {
#define AFX_END_DESTRUCTOR   } catch (CException *pException) { EXCEPTION_IN_DTOR(pException); }

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define BEFORE_START_POSITION ((POSITION)-1L)

/////////////////////////////////////////////////////////////////////////////
// explicit initialization for general purpose classes

BOOL AFXAPI AfxInitialize(BOOL bDLL = FALSE, DWORD dwVersion = _MFC_VER);

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Basic object model

// generate static object constructor for class registration
void AFXAPI AfxClassInit(CRuntimeClass* pNewClass);
struct AFX_CLASSINIT
	{ AFX_CLASSINIT(CRuntimeClass* pNewClass) { AfxClassInit(pNewClass); } };

struct CRuntimeClass
{
// Attributes
	LPCSTR m_lpszClassName;
	int m_nObjectSize;
	UINT m_wSchema; // schema number of the loaded class
	CObject* (PASCAL* m_pfnCreateObject)(); // NULL => abstract class
#ifdef _AFXDLL
	CRuntimeClass* (PASCAL* m_pfnGetBaseClass)();
#else
	CRuntimeClass* m_pBaseClass;
#endif

// Operations
	CObject* CreateObject();
	BOOL IsDerivedFrom(const CRuntimeClass* pBaseClass) const;

	// dynamic name lookup and creation
	static CRuntimeClass* PASCAL FromName(LPCSTR lpszClassName);
	static CRuntimeClass* PASCAL FromName(LPCWSTR lpszClassName);
	static CObject* PASCAL CreateObject(LPCSTR lpszClassName);
	static CObject* PASCAL CreateObject(LPCWSTR lpszClassName);

// Implementation
	void Store(CArchive& ar) const;
	static CRuntimeClass* PASCAL Load(CArchive& ar, UINT* pwSchemaNum);

	// CRuntimeClass objects linked together in simple list
	CRuntimeClass* m_pNextClass;       // linked list of registered classes
	const AFX_CLASSINIT* m_pClassInit;
};

/////////////////////////////////////////////////////////////////////////////
// Standard exception throws

void __declspec(noreturn) AFXAPI AfxThrowMemoryException();
void __declspec(noreturn) AFXAPI AfxThrowNotSupportedException();
void __declspec(noreturn) AFXAPI AfxThrowInvalidArgException();
void __declspec(noreturn) AFXAPI AfxThrowArchiveException(int cause,
	LPCTSTR lpszArchiveName = NULL);
void __declspec(noreturn) AFXAPI AfxThrowFileException(int cause, LONG lOsError = -1,
	LPCTSTR lpszFileName = NULL);
void __declspec(noreturn) AFXAPI AfxThrowOleException(LONG sc);

/////////////////////////////////////////////////////////////////////////////
// CRT functions

inline errno_t AfxCrtErrorCheck(errno_t error)
{
	switch(error)
	{
	case ENOMEM:
		AfxThrowMemoryException();
		break;
	case EINVAL:
	case ERANGE:
		AfxThrowInvalidArgException();
		break;
	case STRUNCATE:
	case 0:
		break;
	default:
		AfxThrowInvalidArgException();
		break;
	}
	return error;
}

#define AFX_CRT_ERRORCHECK(expr) \
	AfxCrtErrorCheck(expr)

inline void __cdecl Afx_clearerr_s(FILE *stream)
{
	AFX_CRT_ERRORCHECK(::clearerr_s(stream));
}

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif

/////////////////////////////////////////////////////////////////////////////
// class CObject is the root of all compliant objects

class AFX_NOVTABLE CObject
{
public:

// Object model (types, destruction, allocation)
	virtual CRuntimeClass* GetRuntimeClass() const;
	virtual ~CObject() = 0;  // virtual destructors are necessary

	// Diagnostic allocations
	void* PASCAL operator new(size_t nSize);
	void* PASCAL operator new(size_t, void* p);
	void PASCAL operator delete(void* p);
#if _MSC_VER >= 1200
	void PASCAL operator delete(void* p, void* pPlace);
#endif

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	// for file name/line number tracking using DEBUG_NEW
	void* PASCAL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#if _MSC_VER >= 1200
	void PASCAL operator delete(void *p, LPCSTR lpszFileName, int nLine);
#endif
#endif

	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
protected:
	CObject();
private:
	CObject(const CObject& objectSrc);              // no implementation
	void operator=(const CObject& objectSrc);       // no implementation

// Attributes
public:
	BOOL IsSerializable() const;
	BOOL IsKindOf(const CRuntimeClass* pClass) const;

// Overridables
	virtual void Serialize(CArchive& ar);

#if defined(_DEBUG) || defined(_AFXDLL)
	// Diagnostic Support
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Implementation
public:
	static const CRuntimeClass classCObject;
#ifdef _AFXDLL
	static CRuntimeClass* PASCAL _GetBaseClass();
	static CRuntimeClass* PASCAL GetThisClass();
#endif
};

// Helper macros
#define _RUNTIME_CLASS(class_name) ((CRuntimeClass*)(&class_name::class##class_name))
#ifdef _AFXDLL
#define RUNTIME_CLASS(class_name) (class_name::GetThisClass())
#else
#define RUNTIME_CLASS(class_name) _RUNTIME_CLASS(class_name)
#endif
#define ASSERT_KINDOF(class_name, object) \
	ASSERT((object)->IsKindOf(RUNTIME_CLASS(class_name)))

// RTTI helper macros/functions
const CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, CObject* pObject);
#define DYNAMIC_DOWNCAST(class_name, object) \
	(class_name*)AfxDynamicDownCast(RUNTIME_CLASS(class_name), object)

#ifdef _DEBUG
const CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, CObject* pObject);
#define STATIC_DOWNCAST(class_name, object) \
	(static_cast<class_name*>(AfxStaticDownCast(RUNTIME_CLASS(class_name), object)))
#else
#define STATIC_DOWNCAST(class_name, object) (static_cast<class_name*>(object))
#endif

//////////////////////////////////////////////////////////////////////////////
// Helper macros for declaring CRuntimeClass compatible classes

#ifdef _AFXDLL
#define DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static const CRuntimeClass class##class_name; \
	static CRuntimeClass* PASCAL GetThisClass(); \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static CRuntimeClass class##class_name; \
	static CRuntimeClass* PASCAL GetThisClass(); \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#else
#define DECLARE_DYNAMIC(class_name) \
public: \
	static const CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
public: \
	static CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#endif

// not serializable, but dynamically constructable
#define DECLARE_DYNCREATE(class_name) \
	DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define _DECLARE_DYNCREATE(class_name) \
	_DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define DECLARE_SERIAL(class_name) \
	_DECLARE_DYNCREATE(class_name) \
	AFX_API friend CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb);

#ifdef _AFXDLL
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT const CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL, class_init }; \
	CRuntimeClass* PASCAL class_name::GetThisClass() \
		{ return _RUNTIME_CLASS(class_name); } \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return _RUNTIME_CLASS(class_name); }

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL, class_init }; \
	CRuntimeClass* PASCAL class_name::GetThisClass() \
		{ return _RUNTIME_CLASS(class_name); } \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return _RUNTIME_CLASS(class_name); }

#else
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	AFX_COMDAT const CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL, class_init }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); }

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	AFX_COMDAT CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL, class_init }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); }

#endif

#define IMPLEMENT_DYNAMIC(class_name, base_class_name) \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, NULL, NULL)

#define IMPLEMENT_DYNCREATE(class_name, base_class_name) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, \
		class_name::CreateObject, NULL)

#define IMPLEMENT_SERIAL(class_name, base_class_name, wSchema) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	extern AFX_CLASSINIT _init_##class_name; \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
		class_name::CreateObject, &_init_##class_name) \
	AFX_CLASSINIT _init_##class_name(RUNTIME_CLASS(class_name)); \
	CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb) \
		{ pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name)); \
			return ar; }

// optional bit for schema number that enables object versioning
#define VERSIONABLE_SCHEMA  (0x80000000)

/////////////////////////////////////////////////////////////////////////////
// other helpers

// zero fill everything after the vtbl pointer
#define AFX_ZERO_INIT_OBJECT(base_class) \
	memset(((base_class*)this)+1, 0, sizeof(*this) - sizeof(class base_class));


/////////////////////////////////////////////////////////////////////////////
// Exceptions

class AFX_NOVTABLE CException : public CObject
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CException)

public:
// Constructors
	CException();   // sets m_bAutoDelete = TRUE
	explicit CException(BOOL bAutoDelete);   // sets m_bAutoDelete = bAutoDelete

// Operations
	void Delete();  // use to delete exception in 'catch' block

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const ;
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL);
	virtual int ReportError(UINT nType = MB_OK, UINT nMessageID = 0);

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CException() = 0;
	BOOL m_bAutoDelete;
#ifdef _DEBUG
	void PASCAL operator delete(void* pbData);
#if _MSC_VER >= 1200
	void PASCAL operator delete(void* pbData, LPCSTR lpszFileName, int nLine);
#endif
protected:
	BOOL m_bReadyForDelete;
#endif
};

#include <afxstr.h>

// ATL Classes

class CSimpleException : public CException
{
	DECLARE_DYNAMIC(CSimpleException)
	
	// base class for resource-critical MFC exceptions
	// handles ownership and initialization of an error message

public:
// Constructors
	CSimpleException();
	explicit CSimpleException(BOOL bAutoDelete);

// Operations
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CSimpleException() = 0;
	BOOL m_bAutoDelete;

	void InitString();      // used during MFC initialization

protected:
	BOOL m_bInitialized;
	BOOL m_bLoaded;
	TCHAR m_szMessage[128];
	UINT m_nResourceID;

#ifdef _DEBUG
	BOOL m_bReadyForDelete;
#endif
};

// helper routines for non-C++ EH implementations
	// for THROW_LAST auto-delete backward compatiblity
	void AFXAPI AfxThrowLastCleanup();

// other out-of-line helper functions
void AFXAPI AfxTryCleanup();

#ifndef _AFX_JUMPBUF
// Use portable 'jmp_buf' defined by ANSI by default.
#define _AFX_JUMPBUF jmp_buf
#endif

// Placed on frame for EXCEPTION linkage, or CException cleanup
struct AFX_EXCEPTION_LINK
{
	AFX_EXCEPTION_LINK* m_pLinkPrev;    // previous top, next in handler chain
	CException* m_pException;   // current exception (NULL in TRY block)

	AFX_EXCEPTION_LINK();       // for initialization and linking
	~AFX_EXCEPTION_LINK()       // for cleanup and unlinking
		{ AfxTryCleanup(); };
};

// Exception global state - never access directly
struct AFX_EXCEPTION_CONTEXT
{
	AFX_EXCEPTION_LINK* m_pLinkTop;

	// Note: most of the exception context is now in the AFX_EXCEPTION_LINK
};

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_PNH AFXAPI AfxGetNewHandler();
_PNH AFXAPI AfxSetNewHandler(_PNH pfnNewHandler);
int AFX_CDECL AfxNewHandler(size_t nSize);

void AFXAPI AfxAbort();


/////////////////////////////////////////////////////////////////////////////
// Exception macros using try, catch and throw
//  (for backward compatibility to previous versions of MFC)

#define TRY { AFX_EXCEPTION_LINK _afxExceptionLink; try {

#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH } }

#define THROW(e) throw e
#define THROW_LAST() (AfxThrowLastCleanup(), throw)

// Advanced macros for smaller code
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH_ALL } } }

#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e; } }


/////////////////////////////////////////////////////////////////////////////
// Standard Exception classes

class CMemoryException : public CSimpleException
{
	DECLARE_DYNAMIC(CMemoryException)
public:
	CMemoryException();

// Implementation
public:
	explicit CMemoryException(BOOL bAutoDelete);
	CMemoryException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CMemoryException();
};

class CNotSupportedException : public CSimpleException
{
	DECLARE_DYNAMIC(CNotSupportedException)
public:
	CNotSupportedException();

// Implementation
public:
	explicit CNotSupportedException(BOOL bAutoDelete);
	CNotSupportedException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CNotSupportedException();
};
class CInvalidArgException : public CSimpleException
{
	DECLARE_DYNAMIC(CInvalidArgException)
public:
	CInvalidArgException();

// Implementation
public:
	CInvalidArgException(BOOL bAutoDelete);
	CInvalidArgException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CInvalidArgException();
};

class CArchiveException : public CException
{
	DECLARE_DYNAMIC(CArchiveException)
public:
	enum {
		none,
		genericException,
		readOnly,
		endOfFile,
		writeOnly,
		badIndex,
		badClass,
		badSchema
	};

#pragma warning(push)
#pragma warning(disable:4996)
	AFX_DEPRECATED("CArchiveException::generic clashes with future language keyword generic and should not be used. Use CArchiveException::genericException instead.") static const int __identifier(generic) = genericException;
#pragma warning(pop)

// Constructor
	/* explicit */ CArchiveException(int cause = CArchiveException::none,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int m_cause;
	CString m_strFileName;

// Implementation
public:
	virtual ~CArchiveException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

class CFileException : public CException
{
	DECLARE_DYNAMIC(CFileException)

public:
	enum {
		none,
		genericException,
		fileNotFound,
		badPath,
		tooManyOpenFiles,
		accessDenied,
		invalidFile,
		removeCurrentDir,
		directoryFull,
		badSeek,
		hardIO,
		sharingViolation,
		lockViolation,
		diskFull,
		endOfFile
	};

#pragma warning(push)
#pragma warning(disable:4996)
	AFX_DEPRECATED("CFileException::generic clashes with future language keyword generic and should not be used. Use CFileException::genericException instead.") static const int __identifier(generic) = genericException;
#pragma warning(pop)

// Constructor
	/* explicit */ CFileException(int cause = CFileException::none, LONG lOsError = -1,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int     m_cause;
	LONG    m_lOsError;
	CString m_strFileName;

// Operations
	// convert a OS dependent error code to a Cause
	static int PASCAL OsErrorToException(LONG lOsError);
	static int PASCAL ErrnoToException(int nErrno);

	// helper functions to throw exception after converting to a Cause
	static void PASCAL ThrowOsError(LONG lOsError, LPCTSTR lpszFileName = NULL);
	static void PASCAL ThrowErrno(int nErrno, LPCTSTR lpszFileName = NULL);

// Implementation
public:
	virtual ~CFileException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
#endif
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

/////////////////////////////////////////////////////////////////////////////
// File - raw unbuffered disk file I/O

class CFile : public CObject
{
	DECLARE_DYNAMIC(CFile)

public:
// Flag values
	enum OpenFlags {
		modeRead =         (int) 0x00000,
		modeWrite =        (int) 0x00001,
		modeReadWrite =    (int) 0x00002,
		shareCompat =      (int) 0x00000,
		shareExclusive =   (int) 0x00010,
		shareDenyWrite =   (int) 0x00020,
		shareDenyRead =    (int) 0x00030,
		shareDenyNone =    (int) 0x00040,
		modeNoInherit =    (int) 0x00080,
		modeCreate =       (int) 0x01000,
		modeNoTruncate =   (int) 0x02000,
		typeText =         (int) 0x04000, // typeText and typeBinary are
		typeBinary =       (int) 0x08000, // used in derived classes only
		osNoBuffer =       (int) 0x10000,
		osWriteThrough =   (int) 0x20000,
		osRandomAccess =   (int) 0x40000,
		osSequentialScan = (int) 0x80000,
		};

	enum Attribute {
		normal =    0x00,
		readOnly =  0x01,
		hidden =    0x02,
		system =    0x04,
		volume =    0x08,
		directory = 0x10,
		archive =   0x20
		};

	enum SeekPosition { begin = 0x0, current = 0x1, end = 0x2 };

	static AFX_DATA const HANDLE hFileNull;

// Constructors
	CFile();
	CFile(HANDLE hFile);
	CFile(LPCTSTR lpszFileName, UINT nOpenFlags);

// Attributes
	HANDLE m_hFile;
	operator HANDLE() const;

	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual CString GetFileName() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFilePath() const;
	virtual void SetFilePath(LPCTSTR lpszNewName);

// Operations
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);

	static void PASCAL Rename(LPCTSTR lpszOldName,
				LPCTSTR lpszNewName);
	static void PASCAL Remove(LPCTSTR lpszFileName);
	static BOOL PASCAL GetStatus(LPCTSTR lpszFileName,
				CFileStatus& rStatus);
	static void PASCAL SetStatus(LPCTSTR lpszFileName,
				const CFileStatus& status);

	ULONGLONG SeekToEnd();
	void SeekToBegin();

// Overridables
	virtual CFile* Duplicate() const;

	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Implementation
public:
	virtual ~CFile();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	enum BufferCommand { bufferRead, bufferWrite, bufferCommit, bufferCheck };
	enum BufferFlags 
	{ 
		bufferDirect = 0x01,
		bufferBlocking = 0x02
	};
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

protected:
	BOOL m_bCloseOnDelete;
	CString m_strFileName;
};

/////////////////////////////////////////////////////////////////////////////
// STDIO file implementation

class CStdioFile : public CFile
{
	DECLARE_DYNAMIC(CStdioFile)

public:
// Constructors
	CStdioFile();
	CStdioFile(FILE* pOpenStream);
	CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags);

// Attributes
	FILE* m_pStream;    // stdio FILE
						// m_hFile from base class is _fileno(m_pStream)

// Operations
	// reading and writing strings
	virtual void WriteString(LPCTSTR lpsz);
	virtual LPTSTR ReadString(_Out_z_cap_(nMax) LPTSTR lpsz, _In_ UINT nMax);
	virtual BOOL ReadString(CString& rString);

// Implementation
public:
	virtual ~CStdioFile();
#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
	virtual ULONGLONG GetPosition() const;
   virtual ULONGLONG GetLength() const;
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Memory based file implementation

class CMemFile : public CFile
{
	DECLARE_DYNAMIC(CMemFile)

public:
// Constructors
	/* explicit */ CMemFile(UINT nGrowBytes = 1024);
	CMemFile(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);

// Operations
	void Attach(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);
	BYTE* Detach();

// Advanced Overridables
protected:
	virtual BYTE* Alloc(SIZE_T nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, SIZE_T nBytes);
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, SIZE_T nBytes);
	virtual void Free(BYTE* lpMem);
	virtual void GrowFile(SIZE_T dwNewLen);

// Implementation
protected:
	SIZE_T m_nGrowBytes;
	SIZE_T m_nPosition;
	SIZE_T m_nBufferSize;
	SIZE_T m_nFileSize;
	BYTE* m_lpBuffer;
	BOOL m_bAutoDelete;

public:
	virtual ~CMemFile();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);
	virtual ULONGLONG GetLength() const;

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Local file searches

#include <atltime.h>
using ATL::CTime;
using ATL::CTimeSpan;

class CFileFind : public CObject
{
public:
	CFileFind();
	virtual ~CFileFind();

// Attributes
public:
	ULONGLONG GetLength() const;
	virtual CString GetFileName() const;
	virtual CString GetFilePath() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFileURL() const;
	virtual CString GetRoot() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	virtual BOOL MatchesMask(DWORD dwMask) const;

	virtual BOOL IsDots() const;
	// these aren't virtual because they all use MatchesMask(), which is
	BOOL IsReadOnly() const;
	BOOL IsDirectory() const;
	BOOL IsCompressed() const;
	BOOL IsSystem() const;
	BOOL IsHidden() const;
	BOOL IsTemporary() const;
	BOOL IsNormal() const;
	BOOL IsArchived() const;

// Operations
	void Close();
	virtual BOOL FindFile(LPCTSTR pstrName = NULL, DWORD dwUnused = 0);
	virtual BOOL FindNextFile();

protected:
	virtual void CloseContext();

// Implementation
protected:
	void* m_pFoundInfo;
	void* m_pNextInfo;
	HANDLE m_hContext;
	CString m_strRoot;
	TCHAR m_chDirSeparator;     // not '\\' for Internet classes

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFileFind)
};

// CTimeSpan diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc,CTimeSpan dateSpanSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, CTimeSpan dateSpanSrc);
CArchive& AFXAPI operator>>(CArchive& ar, CTimeSpan& dateSpanSrc);

// CTime diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, CTime dateSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, CTime dateSrc);
CArchive& AFXAPI operator>>(CArchive& ar, CTime& dateSrc);

/////////////////////////////////////////////////////////////////////////////
// File status

struct CFileStatus
{
	CTime m_ctime;          // creation date/time of file
	CTime m_mtime;          // last modification date/time of file
	CTime m_atime;          // last access date/time of file
	ULONGLONG m_size;            // logical size of file in bytes
	BYTE m_attribute;       // logical OR of CFile::Attribute enum values
	BYTE _m_padding;        // pad the structure to a WORD
	TCHAR m_szFullName[_MAX_PATH]; // absolute path name

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic memory management routines

// Low level sanity checks for memory blocks
BOOL AFXAPI AfxIsValidAddress(const void* lp,
			UINT_PTR nBytes, BOOL bReadWrite = TRUE);
BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL AFXAPI AfxIsValidString(LPCSTR lpsz, int nLength = -1);

// Sanity checks for ATOMs
BOOL AfxIsValidAtom(ATOM nAtom);
BOOL AfxIsValidAtom(LPCTSTR psz);

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)

// Memory tracking allocation
void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#define DEBUG_NEW new(THIS_FILE, __LINE__)
#if _MSC_VER >= 1200
void AFX_CDECL operator delete(void* p, LPCSTR lpszFileName, int nLine);
#endif

void * __cdecl operator new[](size_t);
#if _MSC_VER >= 1210
void* __cdecl operator new[](size_t nSize, LPCSTR lpszFileName, int nLine);
void __cdecl operator delete[](void* p, LPCSTR lpszFileName, int nLine);
void __cdecl operator delete[](void *);
#endif

void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,
	LPCSTR lpszFileName, int nLine);
void AFXAPI AfxFreeMemoryDebug(void* pbData, BOOL bIsObject);

// Dump any memory leaks since program started
BOOL AFXAPI AfxDumpMemoryLeaks();

// Return TRUE if valid memory block of nBytes
BOOL AFXAPI AfxIsMemoryBlock(const void* p, UINT nBytes,
	LONG* plRequestNumber = NULL);

// Return TRUE if memory is sane or print out what is wrong
BOOL AFXAPI AfxCheckMemory();

#define afxMemDF _crtDbgFlag

enum AfxMemDF // memory debug/diagnostic flags
{
	allocMemDF          = _CRTDBG_ALLOC_MEM_DF,         // turn on debugging allocator
	delayFreeMemDF      = _CRTDBG_DELAY_FREE_MEM_DF,         // delay freeing memory
	checkAlwaysMemDF    = _CRTDBG_CHECK_ALWAYS_DF,          // AfxCheckMemory on every alloc/free
	checkEvery16MemDF	= _CRTDBG_CHECK_EVERY_16_DF,
	checkEvery128MemDF	= _CRTDBG_CHECK_EVERY_128_DF,
	checkEvery1024MemDF	= _CRTDBG_CHECK_EVERY_1024_DF,
	checkDefaultMemDF	= _CRTDBG_CHECK_DEFAULT_DF
};

#define AfxOutputDebugString TRACE

// turn on/off tracking for a short while
BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack);

// Turn on/off the global flag _afxMemoryLeakOverride. if bEnable is TRUE
// then further calls to AfxEnableMemoryTracking() wont change the current
// memory tracking state, until AfxEnableMemoryLeakOverride(BOOL bEnable)
// is called again with bEnable == FALSE.
BOOL AFXAPI AfxEnableMemoryLeakOverride(BOOL bEnable);

// Advanced initialization: for overriding default diagnostics
BOOL AFXAPI AfxDiagnosticInit(void);

// A failure hook returns whether to permit allocation
typedef BOOL (AFXAPI* AFX_ALLOC_HOOK)(size_t nSize, BOOL bObject, LONG lRequestNumber);

// Set new hook, return old (never NULL)
AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook);

// Debugger hook on specified allocation request - Obsolete
void AFXAPI AfxSetAllocStop(LONG lRequestNumber);

// Memory state for snapshots/leak detection
struct CMemoryState
{
// Attributes
	enum blockUsage
	{
		freeBlock,    // memory not used
		objectBlock,  // contains a CObject derived class object
		bitBlock,     // contains ::operator new data
		crtBlock,
		ignoredBlock,
		nBlockUseMax  // total number of usages
	};

	_CrtMemState m_memState;
	LONG_PTR m_lCounts[nBlockUseMax];
	LONG_PTR m_lSizes[nBlockUseMax];
	LONG_PTR m_lHighWaterCount;
	LONG_PTR m_lTotalCount;

	CMemoryState();

// Operations
	void Checkpoint();  // fill with current state
	BOOL Difference(const CMemoryState& oldState,
					const CMemoryState& newState);  // fill with difference
	void UpdateData();

	// Output to afxDump
	void DumpStatistics() const;
	void DumpAllObjectsSince() const;
};

// Enumerate allocated objects or runtime classes
void AFXAPI AfxDoForAllObjects(void (AFX_CDECL *pfn)(CObject* pObject, void* pContext),
	void* pContext);
void AFXAPI AfxDoForAllClasses(void (AFX_CDECL *pfn)(const CRuntimeClass* pClass,
	void* pContext), void* pContext);

#else

// non-_DEBUG_ALLOC version that assume everything is OK
#define DEBUG_NEW new
#define AfxCheckMemory() TRUE
#define AfxIsMemoryBlock(p, nBytes) TRUE
#define AfxEnableMemoryTracking(bTrack) FALSE
#define AfxEnableMemoryLeakOverride(bEnable) TRUE
#define AfxOutputDebugString(lpsz) ::OutputDebugString(lpsz)

// diagnostic initialization
#ifndef _DEBUG
#define AfxDiagnosticInit() TRUE
#else
BOOL AFXAPI AfxDiagnosticInit(void);
#endif

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Archives for serializing CObject data

// needed for implementation
template<class TYPE, class ARG_TYPE>
class CArray;
class CPtrArray;
class CMapPtrToPtr;
class CDocument;

class CArchive
{
protected:
	enum SchemaMapReservedRefs { objTypeArrayRef = 1 };
	enum LoadArrayObjType{ typeUndefined = 0, typeCRuntimeClass = 1, typeCObject = 2 };	
public:
// Flag values
	enum Mode { store = 0, load = 1, bNoFlushOnDelete = 2, bNoByteSwap = 4 };

	CArchive(CFile* pFile, UINT nMode, int nBufSize = 4096, void* lpBuf = NULL);
	~CArchive();

// Attributes
	BOOL IsLoading() const;
	BOOL IsStoring() const;
	BOOL IsByteSwapping() const;
	BOOL IsBufferEmpty() const;

	CFile* GetFile() const;
	UINT GetObjectSchema(); // only valid when reading a CObject*
	void SetObjectSchema(UINT nSchema);

	// pointer to document being serialized -- must set to serialize
	//  COleClientItems in a document!
	CDocument* m_pDocument;

// Operations
	UINT Read(void* lpBuf, UINT nMax);
	void EnsureRead(void *lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nMax);
	void Flush();
	void Close();
	void Abort();   // close and shutdown without exceptions

	// reading and writing strings
	void WriteString(LPCTSTR lpsz);
	LPTSTR ReadString(_Out_z_cap_(nMax+1) LPTSTR lpsz, _In_ UINT nMax);
	BOOL ReadString(CString& rString);

public:
	// Object I/O is pointer based to avoid added construction overhead.
	// Use the Serialize member function directly for embedded objects.
	friend CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb);

	friend CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb);
	friend CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb);

	// insertion operations
	CArchive& operator<<(BYTE by);
	CArchive& operator<<(WORD w);
	CArchive& operator<<(LONG l);
	CArchive& operator<<(DWORD dw);
	CArchive& operator<<(float f);
	CArchive& operator<<(double d);
	CArchive& operator<<(LONGLONG dwdw);
	CArchive& operator<<(ULONGLONG dwdw);

	CArchive& operator<<(int i);
	CArchive& operator<<(short w);
	CArchive& operator<<(char ch);
#ifdef _NATIVE_WCHAR_T_DEFINED
	CArchive& operator<<(wchar_t ch);
#endif
	CArchive& operator<<(unsigned u);

	template < typename BaseType , bool t_bMFCDLL>
	CArchive& operator<<(const ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str);

	template< typename BaseType, class StringTraits >	
	CArchive& operator<<(const ATL::CStringT<BaseType, StringTraits>& str);
	
	template < typename BaseType , bool t_bMFCDLL>
	CArchive& operator>>(ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str);

	template< typename BaseType, class StringTraits >
	CArchive& operator>>(ATL::CStringT<BaseType, StringTraits>& str);

	CArchive& operator<<(bool b);

	// extraction operations
	CArchive& operator>>(BYTE& by);
	CArchive& operator>>(WORD& w);
	CArchive& operator>>(DWORD& dw);
	CArchive& operator>>(LONG& l);
	CArchive& operator>>(float& f);
	CArchive& operator>>(double& d);
	CArchive& operator>>(LONGLONG& dwdw);
	CArchive& operator>>(ULONGLONG& dwdw);

	CArchive& operator>>(int& i);
	CArchive& operator>>(short& w);
	CArchive& operator>>(char& ch);
#ifdef _NATIVE_WCHAR_T_DEFINED
	CArchive& operator>>(wchar_t& ch);
#endif
	CArchive& operator>>(unsigned& u);
	CArchive& operator>>(bool& b);

	// object read/write
	CObject* ReadObject(const CRuntimeClass* pClass);
	void WriteObject(const CObject* pOb);
	// advanced object mapping (used for forced references)
	void MapObject(const CObject* pOb);

	// advanced versioning support
	void WriteClass(const CRuntimeClass* pClassRef);
	CRuntimeClass* ReadClass(const CRuntimeClass* pClassRefRequested = NULL,
		UINT* pSchema = NULL, DWORD* pObTag = NULL);
	void SerializeClass(const CRuntimeClass* pClassRef);

	// advanced operations (used when storing/loading many objects)
	void SetStoreParams(UINT nHashSize = 2053, UINT nBlockSize = 128);
	void SetLoadParams(UINT nGrowBy = 1024);

	void EnsureSchemaMapExists(CArray<LoadArrayObjType, const LoadArrayObjType&>** ppObjTypeArray = NULL);
// Implementation
public:
	BOOL m_bForceFlat;  // for COleClientItem implementation (default TRUE)
	BOOL m_bDirectBuffer;   // TRUE if m_pFile supports direct buffering
	BOOL m_bBlocking;  // TRUE if m_pFile can block for unbounded periods of time
	void FillBuffer(UINT nBytesNeeded);
	void CheckCount();  // throw exception if m_nMapCount is too large

	// special functions for reading and writing (16-bit compatible) counts
	DWORD_PTR ReadCount();
	void WriteCount(DWORD_PTR dwCount);

	// public for advanced use
	UINT m_nObjectSchema;
	CString m_strFileName;

protected:
	// archive objects cannot be copied or assigned
	CArchive(const CArchive& arSrc);
	void operator=(const CArchive& arSrc);

	BOOL m_nMode;
	BOOL m_bUserBuf;
	int m_nBufSize;
	CFile* m_pFile;
	BYTE* m_lpBufCur;
	BYTE* m_lpBufMax;
	BYTE* m_lpBufStart;

	// array/map for CObject* and CRuntimeClass* load/store
	UINT m_nMapCount;
	union
	{
		CPtrArray* m_pLoadArray;
		CMapPtrToPtr* m_pStoreMap;
	};
	// map to keep track of mismatched schemas
	CMapPtrToPtr* m_pSchemaMap;

	// advanced parameters (controls performance with large archives)
	UINT m_nGrowSize;
	UINT m_nHashSize;
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic dumping

// Note: AfxDumpStack is available in release builds, although it is always
//      statically linked so as to not negatively affect the size of MFCXX.DLL.

#define AFX_STACK_DUMP_TARGET_TRACE                     0x0001
#define AFX_STACK_DUMP_TARGET_CLIPBOARD 0x0002
#define AFX_STACK_DUMP_TARGET_BOTH                      0x0003
#define AFX_STACK_DUMP_TARGET_ODS                       0x0004
#ifdef _DEBUG
#define AFX_STACK_DUMP_TARGET_DEFAULT           AFX_STACK_DUMP_TARGET_TRACE
#else
#define AFX_STACK_DUMP_TARGET_DEFAULT           AFX_STACK_DUMP_TARGET_CLIPBOARD
#endif

void AFXAPI AfxDumpStack(DWORD dwFlags = AFX_STACK_DUMP_TARGET_DEFAULT);

class CDumpContext
{
public:
	CDumpContext(CFile* pFile = NULL);

// Attributes
	int GetDepth() const;      // 0 => this object, 1 => children objects
	void SetDepth(int nNewDepth);

// Operations
	CDumpContext& operator<<(LPCTSTR lpsz);
#ifdef _UNICODE
	CDumpContext& operator<<(LPCSTR lpsz);  // automatically widened
#else
	CDumpContext& operator<<(LPCWSTR lpsz); // automatically thinned
#endif
	template< typename BaseType, class StringTraits >
	CDumpContext& operator<<(const ATL::CStringT<BaseType, 
		StringTraits>& str)
	{
		*this << static_cast< const BaseType* >( str );
		return *this;
	}
	CDumpContext& operator<<(const void* lp);
	CDumpContext& operator<<(const CObject* pOb);
	CDumpContext& operator<<(const CObject& ob);
	CDumpContext& operator<<(BYTE by);
	CDumpContext& operator<<(WORD w);
	CDumpContext& DumpAsHex(BYTE b);
	CDumpContext& DumpAsHex(WORD w);
#ifdef _WIN64
	CDumpContext& operator<<(LONG l);
	CDumpContext& operator<<(DWORD dw);
	CDumpContext& operator<<(int n);
	CDumpContext& operator<<(UINT u);
	CDumpContext& DumpAsHex(LONG l);
	CDumpContext& DumpAsHex(DWORD dw);
	CDumpContext& DumpAsHex(int n);
	CDumpContext& DumpAsHex(UINT u);
#else
	CDumpContext& operator<<(LONG_PTR l);
	CDumpContext& operator<<(DWORD_PTR dw);
	CDumpContext& operator<<(INT_PTR n);
	CDumpContext& operator<<(UINT_PTR u);
	CDumpContext& DumpAsHex(LONG_PTR l);
	CDumpContext& DumpAsHex(DWORD_PTR dw);
	CDumpContext& DumpAsHex(INT_PTR n);
	CDumpContext& DumpAsHex(UINT_PTR u);
#endif
	CDumpContext& operator<<(float f);
	CDumpContext& operator<<(double d);
	CDumpContext& operator<<(LONGLONG n);
	CDumpContext& operator<<(ULONGLONG n);
	CDumpContext& DumpAsHex(LONGLONG n);
	CDumpContext& DumpAsHex(ULONGLONG n);
	CDumpContext& operator<<(HWND h);
	CDumpContext& operator<<(HDC h);
	CDumpContext& operator<<(HMENU h);
	CDumpContext& operator<<(HACCEL h);
	CDumpContext& operator<<(HFONT h);
	void HexDump(LPCTSTR lpszLine, BYTE* pby, int nBytes, int nWidth);
	void Flush();

// Implementation
protected:
	// dump context objects cannot be copied or assigned
	CDumpContext(const CDumpContext& dcSrc);
	void operator=(const CDumpContext& dcSrc);
	void OutputString(LPCTSTR lpsz);

	int m_nDepth;

public:
	CFile* m_pFile;
};

/////////////////////////////////////////////////////////////////////////////
int __cdecl _AfxInitManaged();

#ifdef _DEBUG
extern AFX_DATA CDumpContext afxDump;
extern AFX_DATA BOOL afxTraceEnabled;
#endif

#ifdef _DEBUG
#define AFXDUMP( exp ) (void)(afxDump<<exp)
#else
#define AFXDUMP( exp )
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXCOLL_H__
	#include <afxcoll.h>
	#ifndef __AFXSTATE_H__
		#include <afxstat_.h> // for _AFX_APP_STATE and _AFX_THREAD_STATE
	#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFX_INLINE AFX_INLINE

#if !defined(_AFX_CORE_IMPL) || !defined(_AFXDLL) || defined(_DEBUG)
#define _AFX_PUBLIC_INLINE AFX_INLINE
#else
#define _AFX_PUBLIC_INLINE
#endif

#endif

#include <afx.inl>


#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning( pop )
#endif

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\atl90\afx.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifndef AFX_H_TEMPLATE_INCLUDE_GUARD
#define AFX_H_TEMPLATE_INCLUDE_GUARD
//Used CStringT to serialize CSimpleStringT because it supports conversions (char <--> wchar_t).
template < typename BaseType , bool t_bMFCDLL>
CArchive& CArchive::operator<<(const ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str)
{
	ATL::CStringT< BaseType, StrTraitMFC_DLL< BaseType > > cstrT(str);
	*this << cstrT;
	return *this;
}	

template< typename BaseType, class StringTraits >
CArchive& CArchive::operator<<(const ATL::CStringT<BaseType, StringTraits>& str)
{
	AfxWriteStringLength(*this, str.GetLength(), sizeof(BaseType) == sizeof(wchar_t));
	Write(str, str.GetLength()*sizeof(BaseType));
	return *this;
}   

template < typename BaseType , bool t_bMFCDLL>
CArchive& CArchive::operator>>(ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str)
{
	ATL::CStringT< BaseType, StrTraitMFC_DLL< BaseType > > cstrT;
	*this >> cstrT;
	str = cstrT;
	return *this;
}

template< typename BaseType, class StringTraits >
CArchive& CArchive::operator>>(ATL::CStringT<BaseType, StringTraits>& str)
{
	int nCharSize;  // 1 = char, 2 = wchar_t
	UINT nLength = UINT( AfxReadStringLength(*this, nCharSize) );
	if (nCharSize == sizeof(char))
	{
		ATL::CTempBuffer< char > pszBufferA(nLength);

		UINT nBytesRead = Read(pszBufferA, nLength*sizeof(char));
		if (nBytesRead != (nLength*sizeof(char)))
			AfxThrowArchiveException(CArchiveException::endOfFile);
		str = ATL::CStringT<BaseType, StringTraits>(pszBufferA, nLength);
	}
	else
	{
		ASSERT(nCharSize == sizeof(wchar_t));

		ATL::CTempBuffer< wchar_t > pszBufferW(nLength);

		UINT nBytesRead = Read(pszBufferW, nLength*sizeof(wchar_t));
		if (nBytesRead != (nLength*sizeof(wchar_t)))
			AfxThrowArchiveException(CArchiveException::endOfFile);
		str = ATL::CStringT<BaseType, StringTraits>(pszBufferW, nLength);
	}

	return *this;
}

#endif //AFX_H_TEMPLATE_INCLUDE_GUARD

#ifndef AFX_INL_MANAGED_INIT_INCLUDE_GUARD
#define AFX_INL_MANAGED_INIT_INCLUDE_GUARD
#if !defined(_AFX_MFCS) && !defined(_AFX_ISAPI)
__declspec( noinline ) inline int __cdecl  _AfxInitManaged()
{
	return 0;
}
#endif // !_AFX_MFCS && !_AFX_ISAPI
extern "C"
{
__declspec(selectany) void* _pIncludeInitManaged = (void*)_AfxInitManaged;
}
#endif  // AFX_INL_MANAGED_INIT_INCLUDE_GUARD

#ifdef _AFX_INLINE
#ifndef AFX_INL_INCLUDE_GUARD
#define AFX_INL_INCLUDE_GUARD

// CObject
_AFX_INLINE CObject::CObject()
	{ }
_AFX_INLINE CObject::~CObject()
	{ }
_AFX_INLINE void CObject::Serialize(CArchive&)
	{ /* CObject does not serialize anything by default */ }
_AFX_INLINE void* PASCAL CObject::operator new(size_t, void* p)
	{ return p; }
#ifndef _DEBUG
// _DEBUG versions in afxmem.cpp
_AFX_INLINE void PASCAL CObject::operator delete(void* p)
	{ ::operator delete(p); }
#if _MSC_VER >= 1200
_AFX_INLINE void PASCAL CObject::operator delete(void* p, void*)
	{ ::operator delete(p); }
#endif
_AFX_INLINE void* PASCAL CObject::operator new(size_t nSize)
	{ return ::operator new(nSize); }
// _DEBUG versions in objcore.cpp
#ifdef _AFXDLL
_AFX_INLINE void CObject::AssertValid() const
	{ /* no asserts in release builds */ }
_AFX_INLINE void CObject::Dump(CDumpContext&) const
	{ /* no dumping in release builds */ }
#endif //_AFXDLL
#endif //!_DEBUG
_AFX_INLINE const CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, const CObject* pObject)
	{ return (const CObject*)AfxDynamicDownCast(pClass, (CObject*)pObject); }
#ifdef _DEBUG
_AFX_INLINE const CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, const CObject* pObject)
	{ return (const CObject*)AfxStaticDownCast(pClass, (CObject*)pObject); }
#endif

// exceptions
_AFX_INLINE CException::~CException()
	{ }
_AFX_INLINE CSimpleException::CSimpleException()
	{ m_bInitialized = FALSE; m_bLoaded = FALSE; }
_AFX_INLINE CSimpleException::CSimpleException(BOOL bAutoDelete)
	: CException(bAutoDelete) { m_bInitialized = FALSE; m_bLoaded = FALSE; }
_AFX_INLINE CSimpleException::~CSimpleException()
	{ }

_AFX_INLINE CMemoryException::CMemoryException()
	: CSimpleException() { }
_AFX_INLINE CMemoryException::CMemoryException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CMemoryException::~CMemoryException()
	{ }
_AFX_INLINE CNotSupportedException::CNotSupportedException()
	: CSimpleException() { }
_AFX_INLINE CNotSupportedException::CNotSupportedException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CNotSupportedException::~CNotSupportedException()
	{ }
_AFX_INLINE CInvalidArgException::CInvalidArgException()
	: CSimpleException() { }
_AFX_INLINE CInvalidArgException::CInvalidArgException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CInvalidArgException::~CInvalidArgException()
	{ }
_AFX_INLINE CArchiveException::CArchiveException(int cause,
	LPCTSTR lpszFileName /* = NULL */)
	{ m_cause = cause; m_strFileName = lpszFileName; }
	
_AFX_INLINE CArchiveException::~CArchiveException()
	{ }
_AFX_INLINE CFileException::CFileException(int cause, LONG lOsError,
	LPCTSTR pstrFileName /* = NULL */)
	{ m_cause = cause; m_lOsError = lOsError; m_strFileName = pstrFileName; }
_AFX_INLINE CFileException::~CFileException()
	{ }

// CFile
_AFX_INLINE CFile::operator HANDLE() const
	{ return m_hFile; }
_AFX_INLINE ULONGLONG CFile::SeekToEnd()
	{ return Seek(0, CFile::end); }
_AFX_INLINE void CFile::SeekToBegin()
	{ Seek(0, CFile::begin); }
_AFX_INLINE void CFile::SetFilePath(LPCTSTR lpszNewName)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidString(lpszNewName));
	if(lpszNewName != NULL)
		m_strFileName = lpszNewName;
	else
		AfxThrowInvalidArgException();  

}

// CFileFind
_AFX_INLINE BOOL CFileFind::IsReadOnly() const
	{ return MatchesMask(FILE_ATTRIBUTE_READONLY); }
_AFX_INLINE BOOL CFileFind::IsDirectory() const
	{ return MatchesMask(FILE_ATTRIBUTE_DIRECTORY); }
_AFX_INLINE BOOL CFileFind::IsCompressed() const
	{ return MatchesMask(FILE_ATTRIBUTE_COMPRESSED); }
_AFX_INLINE BOOL CFileFind::IsSystem() const
	{ return MatchesMask(FILE_ATTRIBUTE_SYSTEM); }
_AFX_INLINE BOOL CFileFind::IsHidden() const
	{ return MatchesMask(FILE_ATTRIBUTE_HIDDEN); }
_AFX_INLINE BOOL CFileFind::IsTemporary() const
	{ return MatchesMask(FILE_ATTRIBUTE_TEMPORARY); }
_AFX_INLINE BOOL CFileFind::IsNormal() const
	{ return MatchesMask(FILE_ATTRIBUTE_NORMAL); }
_AFX_INLINE BOOL CFileFind::IsArchived() const
	{ return MatchesMask(FILE_ATTRIBUTE_ARCHIVE); }

// CArchive
_AFX_INLINE BOOL CArchive::IsLoading() const
	{ return (m_nMode & CArchive::load) != 0; }
_AFX_INLINE BOOL CArchive::IsStoring() const
	{ return (m_nMode & CArchive::load) == 0; }
_AFX_INLINE BOOL CArchive::IsByteSwapping() const
	{ return FALSE; }
_AFX_INLINE BOOL CArchive::IsBufferEmpty() const
	{ return m_lpBufCur == m_lpBufMax; }
_AFX_INLINE CFile* CArchive::GetFile() const
	{ return m_pFile; }
_AFX_INLINE void CArchive::SetObjectSchema(UINT nSchema)
	{ m_nObjectSchema = nSchema; }
_AFX_INLINE void CArchive::SetStoreParams(UINT nHashSize, UINT nBlockSize)
{
	ASSERT(IsStoring());
	ASSERT(m_pStoreMap == NULL);    // must be before first object written
	m_nHashSize = nHashSize;
	m_nGrowSize = nBlockSize;
}
_AFX_INLINE void CArchive::SetLoadParams(UINT nGrowBy)
{
	ASSERT(IsLoading());
	ASSERT(m_pLoadArray == NULL);   // must be before first object read
	m_nGrowSize = nGrowBy;
}
_AFX_INLINE CArchive& CArchive::operator<<(int i)
	{ return CArchive::operator<<((LONG)i); }
_AFX_INLINE CArchive& CArchive::operator<<(unsigned u)
	{ return CArchive::operator<<((LONG)u); }
_AFX_INLINE CArchive& CArchive::operator<<(short w)
	{ return CArchive::operator<<((WORD)w); }
_AFX_INLINE CArchive& CArchive::operator<<(char ch)
	{ return CArchive::operator<<((BYTE)ch); }
#ifdef _NATIVE_WCHAR_T_DEFINED
_AFX_INLINE CArchive& CArchive::operator<<(wchar_t ch)
	{ return CArchive::operator<<((WORD)ch); }
#endif
_AFX_INLINE CArchive& CArchive::operator<<(bool b)
	{ return CArchive::operator <<((BYTE)(b ? 1 : 0)); }
_AFX_INLINE CArchive& CArchive::operator<<(BYTE by)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax) Flush();
		*(UNALIGNED BYTE*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator<<(LONGLONG dwdw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONGLONG) > m_lpBufMax) Flush();
		*(UNALIGNED LONGLONG*)m_lpBufCur = dwdw; m_lpBufCur += sizeof(LONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(ULONGLONG dwdw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(ULONGLONG) > m_lpBufMax) Flush();
		*(UNALIGNED ULONGLONG*)m_lpBufCur = dwdw; m_lpBufCur += sizeof(ULONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(WORD w)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(WORD) > m_lpBufMax) Flush();
			*(UNALIGNED WORD*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(LONG l)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONG) > m_lpBufMax) Flush();
		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(DWORD dw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax) Flush();
		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(float f)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(float) > m_lpBufMax) Flush();
		*(UNALIGNED float*)m_lpBufCur = f; m_lpBufCur += sizeof(float); return *this;
}
_AFX_INLINE CArchive& CArchive::operator<<(double d)
{
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(double) > m_lpBufMax) Flush();
		*(UNALIGNED double*)m_lpBufCur = d; m_lpBufCur += sizeof(double); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator>>(int& i)
	{ return CArchive::operator>>((LONG&)i); }
_AFX_INLINE CArchive& CArchive::operator>>(unsigned& u)
	{ return CArchive::operator>>((LONG&)u); }
_AFX_INLINE CArchive& CArchive::operator>>(short& w)
	{ return CArchive::operator>>((WORD&)w); }
_AFX_INLINE CArchive& CArchive::operator>>(char& ch)
	{ return CArchive::operator>>((BYTE&)ch); }
#ifdef _NATIVE_WCHAR_T_DEFINED
_AFX_INLINE CArchive& CArchive::operator>>(wchar_t& ch)
	{ return CArchive::operator>>((WORD&)ch); }
#endif
_AFX_INLINE CArchive& CArchive::operator>>(bool& b)
	{ BYTE by; CArchive& ar = CArchive::operator>>(by); b = (by ? true : false); return ar; }
_AFX_INLINE CArchive& CArchive::operator>>(BYTE& by)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax)
		FillBuffer(UINT(sizeof(BYTE) - (m_lpBufMax - m_lpBufCur)));
	by = *(UNALIGNED BYTE*)m_lpBufCur; m_lpBufCur += sizeof(BYTE); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator>>(LONGLONG& dwdw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONGLONG) > m_lpBufMax)
		FillBuffer(sizeof(LONGLONG) - (UINT)(m_lpBufMax - m_lpBufCur));
	dwdw = *(UNALIGNED LONGLONG*)m_lpBufCur; m_lpBufCur += sizeof(LONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(ULONGLONG& dwdw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(ULONGLONG) > m_lpBufMax)
		FillBuffer(sizeof(ULONGLONG) - (UINT)(m_lpBufMax - m_lpBufCur));
	dwdw = *(UNALIGNED ULONGLONG*)m_lpBufCur; m_lpBufCur += sizeof(ULONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(WORD& w)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(WORD) > m_lpBufMax)
		FillBuffer(UINT(sizeof(WORD) - (m_lpBufMax - m_lpBufCur)));
	w = *(UNALIGNED WORD*)m_lpBufCur; m_lpBufCur += sizeof(WORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(DWORD& dw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax)
		FillBuffer(UINT(sizeof(DWORD) - (m_lpBufMax - m_lpBufCur)));
	dw = *(UNALIGNED DWORD*)m_lpBufCur; m_lpBufCur += sizeof(DWORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(float& f)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(float) > m_lpBufMax)
		FillBuffer(UINT(sizeof(float) - (m_lpBufMax - m_lpBufCur)));
	f = *(UNALIGNED float*)m_lpBufCur; m_lpBufCur += sizeof(float); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(double& d)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(double) > m_lpBufMax)
		FillBuffer(UINT(sizeof(double) - (m_lpBufMax - m_lpBufCur)));
	d = *(UNALIGNED double*)m_lpBufCur; m_lpBufCur += sizeof(double); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(LONG& l)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONG) > m_lpBufMax)
		FillBuffer(UINT(sizeof(LONG) - (m_lpBufMax - m_lpBufCur)));
	l = *(UNALIGNED LONG*)m_lpBufCur; m_lpBufCur += sizeof(LONG); return *this; 
}

_AFX_INLINE CArchive::CArchive(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE void CArchive::operator=(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb)
	{ ar.WriteObject(pOb); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }

_AFX_INLINE void CArchive::EnsureRead(void *lpBuf, UINT nCount)
{
	UINT nRead=Read(lpBuf, nCount);
	if(nRead!=nCount)
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}

// CDumpContext
_AFX_INLINE int CDumpContext::GetDepth() const
	{ return m_nDepth; }
_AFX_INLINE void CDumpContext::SetDepth(int nNewDepth)
	{ m_nDepth = nNewDepth; }
_AFX_INLINE CDumpContext::CDumpContext(const CDumpContext& /* dcSrc */)
	{ }
_AFX_INLINE void CDumpContext::operator=(const CDumpContext& /* dcSrc */)
	{ }

/////////////////////////////////////////////////////////////////////////////
#endif //AFX_INL_INCLUDE_GUARD
#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\atl90\afxadv.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: This header file contains useful classes that are documented only
//  in the MFC Technical Notes.  These classes may change from version to
//  version, so be prepared to change your code accordingly if you utilize
//  this header.  In the future, commonly used portions of this header
//  may be moved and officially documented.

#ifndef __AFXADV_H__
#define __AFXADV_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXADV - MFC Advanced Classes

// Classes declared in this file

//CObject
	//CFile
		//CMemFile
			class CSharedFile;          // Shared memory file

	class CRecentFileList;              // used in CWinApp for MRU list
	class CDockState;                   // state of docking toolbars

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Shared file support

class CSharedFile : public CMemFile
{
	DECLARE_DYNAMIC(CSharedFile)

public:
// Constructors
	/* explicit */ CSharedFile(UINT nAllocFlags = GMEM_MOVEABLE,
		UINT nGrowBytes = 4096);

// Attributes
	HGLOBAL Detach();
	void SetHandle(HGLOBAL hGlobalMemory, BOOL bAllowGrow = TRUE);

// Implementation
public:
	virtual ~CSharedFile();
protected:
	virtual BYTE* Alloc(SIZE_T nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, SIZE_T nBytes);
	virtual void Free(BYTE* lpMem);

	UINT m_nAllocFlags;
	HGLOBAL m_hGlobalMemory;
	BOOL m_bAllowGrow;
};

/////////////////////////////////////////////////////////////////////////////
// CRecentFileList

#define AFX_ABBREV_FILENAME_LEN 30

class CRecentFileList
{
// Constructors
public:
	CRecentFileList(UINT nStart, LPCTSTR lpszSection,
		LPCTSTR lpszEntryFormat, int nSize,
		int nMaxDispLen = AFX_ABBREV_FILENAME_LEN);

// Attributes
	int GetSize() const;
	CString& operator[](int nIndex);

// Operations
	virtual void Remove(int nIndex);
	virtual void Add(LPCTSTR lpszPathName);
	virtual BOOL GetDisplayName(CString& strName, int nIndex,
		LPCTSTR lpszCurDir, int nCurDir, BOOL bAtLeastName = TRUE) const;
	virtual void UpdateMenu(CCmdUI* pCmdUI);
	virtual void ReadList();    // reads from registry or ini file
	virtual void WriteList();   // writes to registry or ini file

// Implementation
	virtual ~CRecentFileList();

	int m_nSize;                // contents of the MRU list
	CString* m_arrNames;
	CString m_strSectionName;   // for saving
	CString m_strEntryFormat;
	UINT m_nStart;              // for displaying
	int m_nMaxDisplayLength;
	CString m_strOriginal;      // original menu item contents
};

AFX_INLINE int CRecentFileList::GetSize() const
	{ return m_nSize; }
AFX_INLINE CString& CRecentFileList::operator[](int nIndex)
{ ENSURE_ARG(nIndex >=0 && nIndex < m_nSize); return m_arrNames[nIndex]; }

/////////////////////////////////////////////////////////////////////////////
// CDockState - used for docking serialization

class CDockState : public CObject
{
	DECLARE_SERIAL(CDockState)
	CDockState();

public:
// Attributes
	CPtrArray m_arrBarInfo;

public:
// Operations
	void LoadState(LPCTSTR lpszProfileName);
	void SaveState(LPCTSTR lpszProfileName);
	void Clear(); //deletes all the barinfo's
	DWORD GetVersion();

// Implementation
protected:
	BOOL m_bScaling;
	CRect m_rectDevice;
	CRect m_rectClip;
	CSize m_sizeLogical;
	DWORD m_dwVersion;

public:
	~CDockState();
	virtual void Serialize(CArchive& ar);

	// scaling implementation
	void ScalePoint(CPoint& pt);
	void ScaleRectPos(CRect& rect);
	CSize GetScreenSize();
	void SetScreenSize(CSize& size);
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXADV_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\atl90\afxcmn2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H (via WINCTRL6.CPP)

#pragma once

#ifdef _AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CStatusBarCtrl::IsSimple() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_ISSIMPLE, 0, 0); }
_AFXCMN_INLINE void CStatusBarCtrl::SetTipText(int nPane, LPCTSTR pszTipText)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, SB_SETTIPTEXT, nPane, (LPARAM)pszTipText); }
_AFXCMN_INLINE COLORREF CStatusBarCtrl::SetBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, SB_SETBKCOLOR, 0, (LPARAM)cr); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetIcon(int iPart, HICON hIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SETICON, iPart, (LPARAM)hIcon); }
_AFXCMN_INLINE HICON CStatusBarCtrl::GetIcon(int iPart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON) ::SendMessage(m_hWnd, SB_GETICON, iPart, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CSpinButtonCtrl::SetRange32(int nLower, int nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper); }
_AFXCMN_INLINE void CSpinButtonCtrl::GetRange32(int& nLower, int& nUpper) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_GETRANGE32, (WPARAM) &nLower, (LPARAM) &nUpper); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CSpinButtonCtrl::GetPos32(LPBOOL lpbError /*= NULL*/) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, UDM_GETPOS32, 0, (LPARAM)lpbError); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetPos32(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, UDM_SETPOS32, 0, (LPARAM)nPos); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE DWORD CToolBarCtrl::GetButtonSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetDisabledImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETDISABLEDIMAGELIST, 0, 0)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetHotImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETHOTIMAGELIST, 0, 0)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETIMAGELIST, 0, 0)); }
_AFXCMN_INLINE DWORD CToolBarCtrl::GetStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETSTYLE, 0, 0L); }
_AFXCMN_INLINE INT CToolBarCtrl::GetMaxTextRows() const
	{ ASSERT(::IsWindow(m_hWnd)); return (INT) ::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetRect(int nID, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETRECT, nID, (LPARAM)lpRect); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonHighlighted(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIGHLIGHTED, nID, 0); }
_AFXCMN_INLINE void CToolBarCtrl::LoadImages(int iBitmapID, HINSTANCE hinst)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_LOADIMAGES, iBitmapID, (LPARAM)hinst); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonWidth(int cxMin, int cxMax)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetDisabledImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetHotImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETHOTIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetIndent(int iIndent)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETINDENT, iIndent, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetMaxTextRows(int iMaxRows)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, iMaxRows, 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetStyle(DWORD dwStyle)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETSTYLE, 0, dwStyle); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetButtonInfo(int nID, TBBUTTONINFO* ptbbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETBUTTONINFO, nID, (LPARAM)ptbbi); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonInfo(int nID, TBBUTTONINFO* ptbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONINFO, nID, (LPARAM)ptbbi); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetDrawTextFlags(DWORD dwMask, DWORD dwDTFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETDRAWTEXTFLAGS, dwMask, dwDTFlags); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetAnchorHighlight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETANCHORHIGHLIGHT, 0, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetAnchorHighlight(BOOL fAnchor)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETANCHORHIGHLIGHT, fAnchor, 0); }
_AFXCMN_INLINE int CToolBarCtrl::GetHotItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETHOTITEM, 0, 0); }
_AFXCMN_INLINE int CToolBarCtrl::SetHotItem(int nHot)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_SETHOTITEM, nHot, 0); }
_AFXCMN_INLINE void CToolBarCtrl::GetInsertMark(TBINSERTMARK* ptbim) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_GETINSERTMARK, 0, (LPARAM)ptbim); }
_AFXCMN_INLINE void CToolBarCtrl::SetInsertMark(TBINSERTMARK* ptbim)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETINSERTMARK, 0, (LPARAM)ptbim); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetMaxSize(LPSIZE pSize) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETMAXSIZE, 0, (LPARAM)pSize); }
_AFXCMN_INLINE BOOL CToolBarCtrl::InsertMarkHitTest(LPPOINT ppt, LPTBINSERTMARK ptbim) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)ppt, (LPARAM)ptbim); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MapAccelerator(TCHAR chAccel, UINT* pIDBtn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)pIDBtn); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MarkButton(int nID, BOOL bHighlight)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MARKBUTTON, nID, MAKELPARAM(bHighlight, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MoveButton(UINT nOldPos, UINT nNewPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MOVEBUTTON, nOldPos, nNewPos); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CToolBarCtrl::GetString(_In_ int nString, _Out_z_cap_post_count_(cchMaxLen, return + 1) LPTSTR lpstrString, _In_ size_t cchMaxLen) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(cchMaxLen, nString), (LPARAM)lpstrString); lpstrString[cchMaxLen]=_T('\0'); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE DWORD CListCtrl::SetExtendedStyle(DWORD dwNewStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, (LPARAM) dwNewStyle); }
_AFXCMN_INLINE HCURSOR CListCtrl::SetHotCursor(HCURSOR hc)
	{ ASSERT(::IsWindow(m_hWnd) && hc != NULL); return (HCURSOR) ::SendMessage(m_hWnd, LVM_SETHOTCURSOR, 0, (LPARAM) hc); }
_AFXCMN_INLINE int CListCtrl::SetHotItem(int iIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SETHOTITEM, (WPARAM) iIndex, 0); }
_AFXCMN_INLINE void CListCtrl::SetWorkAreas(int nWorkAreas, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_SETWORKAREAS, nWorkAreas, (LPARAM) lpRect); }
_AFXCMN_INLINE int CListCtrl::SubItemHitTest(LPLVHITTESTINFO pInfo)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM) pInfo); }
_AFXCMN_INLINE HCURSOR CListCtrl::GetHotCursor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR) ::SendMessage(m_hWnd, LVM_GETHOTCURSOR, 0, 0); }
_AFXCMN_INLINE int CListCtrl::GetHotItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETHOTITEM, 0, 0); }
_AFXCMN_INLINE DWORD CListCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0); }
_AFXCMN_INLINE CSize CListCtrl::ApproximateViewRect(CSize sz, int iCount) const
	{ ASSERT(::IsWindow(m_hWnd)); return CSize((DWORD) ::SendMessage(m_hWnd, LVM_APPROXIMATEVIEWRECT, iCount, MAKELPARAM(sz.cx, sz.cy))); }
_AFXCMN_INLINE BOOL CListCtrl::GetBkImage(LVBKIMAGE* plvbkImage) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETBKIMAGE, 0, (LPARAM)plvbkImage); }
_AFXCMN_INLINE DWORD CListCtrl::GetHoverTime() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_GETHOVERTIME, 0, 0); }
_AFXCMN_INLINE void CListCtrl::GetWorkAreas(int nWorkAreas, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_GETWORKAREAS, nWorkAreas, (LPARAM)prc); }
_AFXCMN_INLINE BOOL CListCtrl::SetBkImage(LVBKIMAGE* plvbkImage)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LVM_SETBKIMAGE, 0, (LPARAM)plvbkImage); }
_AFXCMN_INLINE DWORD CListCtrl::SetHoverTime(DWORD dwHoverTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, LVM_SETHOVERTIME, 0, dwHoverTime); }
_AFXCMN_INLINE UINT CListCtrl::GetNumberOfWorkAreas() const
	{ ASSERT(::IsWindow(m_hWnd)); UINT nWorkAreas; ::SendMessage(m_hWnd, LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)&nWorkAreas); return nWorkAreas; }
_AFXCMN_INLINE int CListCtrl::SetSelectionMark(int iIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SETSELECTIONMARK, 0, (LPARAM) iIndex); }
_AFXCMN_INLINE int CListCtrl::GetSelectionMark() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETSELECTIONMARK, 0, 0); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CHeaderCtrl::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(lpRect != NULL); return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXCMN_INLINE int CHeaderCtrl::OrderToIndex(int nOrder) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_ORDERTOINDEX, nOrder, 0); }
_AFXCMN_INLINE int CHeaderCtrl::SetHotDivider(CPoint pt)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, TRUE, MAKELPARAM(pt.x, pt.y)); }
_AFXCMN_INLINE int CHeaderCtrl::SetHotDivider(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, FALSE, nIndex); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::GetImageList(_In_ int nImageList /* = HDSIL_NORMAL */) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_GETIMAGELIST, nImageList, 0L)); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::SetImageList(CImageList* pImageList, _In_ int nImageList /* = HDSIL_NORMAL */)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_SETIMAGELIST, nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::CreateDragImage(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_CREATEDRAGIMAGE, nIndex, 0L)); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CHeaderCtrl::GetBitmapMargin() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_GETBITMAPMARGIN, 0, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::SetBitmapMargin(int nWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETBITMAPMARGIN, nWidth, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::SetFilterChangeTimeout(DWORD dwTimeOut)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, dwTimeOut); }
_AFXCMN_INLINE int CHeaderCtrl::EditFilter(int nColumn, BOOL bDiscardChanges)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_EDITFILTER, nColumn, MAKELPARAM(bDiscardChanges, 0)); }
_AFXCMN_INLINE BOOL CHeaderCtrl::ClearFilter(int nColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_CLEARFILTER, nColumn, 0L); }
_AFXCMN_INLINE BOOL CHeaderCtrl::ClearAllFilters()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_CLEARFILTER, (WPARAM)-1, 0L); }
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CHeaderCtrl::GetItemDropDownRect(int iItem, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetItemDropDownRect(m_hWnd, iItem, lpRect); } // HDM_GETITEMDROPDOWNRECT
_AFXCMN_INLINE BOOL CHeaderCtrl::GetOverflowRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetOverflowRect(m_hWnd, lpRect); } // HDM_GETOVERFLOWRECT
_AFXCMN_INLINE int CHeaderCtrl::GetFocusedItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetFocusedItem(m_hWnd); } // HDM_GETFOCUSEDITEM
_AFXCMN_INLINE BOOL CHeaderCtrl::SetFocusedItem(int iItem)
	{ ASSERT(::IsWindow(m_hWnd)); return Header_SetFocusedItem(m_hWnd, iItem); } // HDM_SETFOCUSEDITEM
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CReBarCtrl::CReBarCtrl()
	{ }
_AFXCMN_INLINE UINT CReBarCtrl::GetBandCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETBANDCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::GetBandInfo(UINT uBand, REBARBANDINFO* prbbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETBANDINFO, uBand, (LPARAM)prbbi); }
_AFXCMN_INLINE UINT CReBarCtrl::GetBarHeight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETBARHEIGHT, 0, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::GetBarInfo(REBARINFO* prbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)prbi); }
_AFXCMN_INLINE COLORREF CReBarCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE IDropTarget* CReBarCtrl::GetDropTarget() const
	{ ASSERT(::IsWindow(m_hWnd)); IDropTarget* pdt; ::SendMessage(m_hWnd, RB_GETDROPTARGET, 0, (LPARAM)&pdt); return pdt; }
_AFXCMN_INLINE BOOL CReBarCtrl::GetRect(UINT uBand, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETRECT, uBand, (LPARAM)prc); }
_AFXCMN_INLINE UINT CReBarCtrl::GetRowCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETROWCOUNT, 0, 0L); }
_AFXCMN_INLINE UINT CReBarCtrl::GetRowHeight(UINT uRow) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETROWHEIGHT, uRow, 0L); }
_AFXCMN_INLINE COLORREF CReBarCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CReBarCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, RB_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE int CReBarCtrl::IDToIndex(UINT uBandID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, RB_IDTOINDEX, uBandID, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::SetBandInfo(UINT uBand, REBARBANDINFO* prbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBANDINFO, uBand, (LPARAM)prbbi); }
_AFXCMN_INLINE BOOL CReBarCtrl::SetBarInfo(REBARINFO* prbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)prbi); }
_AFXCMN_INLINE COLORREF CReBarCtrl::SetBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_SETBKCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE CWnd* CReBarCtrl::SetOwner(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); CWnd::SetOwner(pWnd);  return CWnd::FromHandle((HWND)::SendMessage(m_hWnd, RB_SETPARENT, (WPARAM)pWnd->m_hWnd, 0L)); }
_AFXCMN_INLINE COLORREF CReBarCtrl::SetTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_SETTEXTCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE void CReBarCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_SETTOOLTIPS, (WPARAM)pTip->m_hWnd, 0L); }
_AFXCMN_INLINE void CReBarCtrl::BeginDrag(UINT uBand, DWORD dwPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_BEGINDRAG, uBand, dwPos); }
_AFXCMN_INLINE BOOL CReBarCtrl::DeleteBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_DELETEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::DragMove(DWORD dwPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_DRAGMOVE, 0, dwPos); }
_AFXCMN_INLINE void CReBarCtrl::EndDrag()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_ENDDRAG, 0, 0L); }
_AFXCMN_INLINE int CReBarCtrl::HitTest(RBHITTESTINFO* prbht)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, RB_HITTEST, 0, (LPARAM)prbht); }
_AFXCMN_INLINE BOOL CReBarCtrl::InsertBand(UINT uIndex, REBARBANDINFO* prbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_INSERTBAND, uIndex, (LPARAM)prbbi); }
_AFXCMN_INLINE void CReBarCtrl::MaximizeBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MAXIMIZEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::MinimizeBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MINIMIZEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::RestoreBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MAXIMIZEBAND, uBand, 1L); }
_AFXCMN_INLINE BOOL CReBarCtrl::SizeToRect(CRect& rect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SIZETORECT, 0, (LPARAM)&rect); }
_AFXCMN_INLINE BOOL CReBarCtrl::ShowBand(UINT uBand, BOOL fShow /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SHOWBAND, uBand, fShow); }
_AFXCMN_INLINE void CReBarCtrl::GetBandBorders(UINT uBand, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_GETBANDBORDERS, uBand, (LPARAM)prc); }
_AFXCMN_INLINE CPalette* CReBarCtrl::GetPalette() const
	{ ASSERT(::IsWindow(m_hWnd)); return CPalette::FromHandle((HPALETTE)::SendMessage(m_hWnd, RB_GETPALETTE, 0, 0L)); }
_AFXCMN_INLINE CPalette* CReBarCtrl::SetPalette(HPALETTE hPal)
	{ ASSERT(::IsWindow(m_hWnd)); return CPalette::FromHandle((HPALETTE)::SendMessage(m_hWnd, RB_SETPALETTE, 0, (LPARAM)hPal)); }
_AFXCMN_INLINE BOOL CReBarCtrl::MoveBand(UINT uFrom, UINT uTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_MOVEBAND, uFrom, uTo); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE void CReBarCtrl::PushChevron(UINT uBand, LPARAM lAppValue)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_PUSHCHEVRON, uBand, lAppValue); }
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CReBarCtrl::SetBandWidth(UINT uBand, int cxWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBANDWIDTH, (WPARAM)uBand, (LPARAM)cxWidth); }
_AFXCMN_INLINE DWORD CReBarCtrl::SetExtendedStyle(DWORD dwMask, DWORD dwStyleEx)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, RB_SETEXTENDEDSTYLE, dwMask, dwStyleEx); }
_AFXCMN_INLINE DWORD CReBarCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, RB_GETEXTENDEDSTYLE, 0, 0L); }
#endif // _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CToolTipCtrl::SetDelayTime(UINT nDelay)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, 0, nDelay); }
_AFXCMN_INLINE int CToolTipCtrl::GetDelayTime(DWORD dwDuration) const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETDELAYTIME, dwDuration, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::GetMargin(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_GETMARGIN, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CToolTipCtrl::GetMaxTipWidth() const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETMAXTIPWIDTH, 0, 0L); }
_AFXCMN_INLINE COLORREF CToolTipCtrl::GetTipBkColor() const
	{ ASSERT(::IsWindow(m_hWnd));  return (COLORREF) ::SendMessage(m_hWnd, TTM_GETTIPBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CToolTipCtrl::GetTipTextColor() const
	{ ASSERT(::IsWindow(m_hWnd));  return (COLORREF) ::SendMessage(m_hWnd, TTM_GETTIPTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::Pop()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_POP, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetDelayTime(DWORD dwDuration, int iTime)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, dwDuration, MAKELPARAM(iTime, 0)); }
_AFXCMN_INLINE void CToolTipCtrl::SetMargin(LPRECT lprc)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETMARGIN, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CToolTipCtrl::SetMaxTipWidth(int iWidth)
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_SETMAXTIPWIDTH, 0, iWidth); }
_AFXCMN_INLINE void CToolTipCtrl::SetTipBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTIPBKCOLOR, clr, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetTipTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTIPTEXTCOLOR, clr, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::Update()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_UPDATE, 0, 0L); }
_AFXCMN_INLINE BOOL CToolTipCtrl::GetCurrentTool(LPTOOLINFO lpToolInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TTM_GETCURRENTTOOL, 0, (LPARAM)lpToolInfo); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE CSize CToolTipCtrl::GetBubbleSize(LPTOOLINFO lpToolInfo) const
	{ ASSERT(::IsWindow(m_hWnd));  return CSize((DWORD)::SendMessage(m_hWnd, TTM_GETBUBBLESIZE, 0, (LPARAM)lpToolInfo)); }
_AFXCMN_INLINE BOOL CToolTipCtrl::AdjustRect(LPRECT lprc, BOOL bLarger /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd));  return (BOOL)::SendMessage(m_hWnd, TTM_ADJUSTRECT, bLarger, (LPARAM)lprc); }
_AFXCMN_INLINE BOOL CToolTipCtrl::SetTitle(UINT uIcon, LPCTSTR lpstrTitle)
	{ ASSERT(::IsWindow(m_hWnd));  return (BOOL)::SendMessage(m_hWnd, TTM_SETTITLE, uIcon, (LPARAM)lpstrTitle); }
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE void CToolTipCtrl::Popup()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_POPUP, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::GetTitle(PTTGETTITLE pTTGetTitle) const
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_GETTITLE, 0, (LPARAM)pTTGetTitle); }
#endif
/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CComboBoxEx::CComboBoxEx()
	{ }
_AFXCMN_INLINE DWORD CComboBoxEx::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, CBEM_GETEXTENDEDSTYLE, 0, 0); }
_AFXCMN_INLINE DWORD CComboBoxEx::SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, CBEM_SETEXTENDEDSTYLE, (DWORD) dwExMask, (LPARAM) dwExStyles); }
_AFXCMN_INLINE BOOL CComboBoxEx::HasEditChanged()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, CBEM_HASEDITCHANGED, 0, 0); }
_AFXCMN_INLINE CEdit* CComboBoxEx::GetEditCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*) CEdit::FromHandle((HWND) ::SendMessage(m_hWnd, CBEM_GETEDITCONTROL, 0, 0)); }
_AFXCMN_INLINE CComboBox* CComboBoxEx::GetComboBoxCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CComboBox*) CComboBox::FromHandle((HWND) ::SendMessage(m_hWnd, CBEM_GETCOMBOCONTROL, 0, 0)); }
_AFXCMN_INLINE CImageList* CComboBoxEx::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, CBEM_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CComboBoxEx::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, CBEM_GETIMAGELIST, 0, 0)); }

// While CComboBoxEx derives from CComboBox, there are some
// CB_messages the underlying ComboBoxEx control doesn't support.

_AFXCMN_INLINE int CComboBoxEx::Dir(UINT attr, LPCTSTR lpszWildCard)
	{ UNUSED_ALWAYS(attr); UNUSED_ALWAYS(lpszWildCard);
		ASSERT(FALSE); return CB_ERR; }
_AFXCMN_INLINE int CComboBoxEx::FindString(int nIndexStart, LPCTSTR lpszFind) const
	{ UNUSED_ALWAYS(nIndexStart); UNUSED_ALWAYS(lpszFind);
		ASSERT(FALSE); return CB_ERR; }
_AFXCMN_INLINE int CComboBoxEx::AddString(LPCTSTR lpszString)
	{ UNUSED_ALWAYS(lpszString); ASSERT(FALSE); return CB_ERR;}
_AFXCMN_INLINE BOOL CComboBoxEx::SetEditSel(int nStartChar, int nEndChar)
	{ UNUSED_ALWAYS(nStartChar); UNUSED_ALWAYS(nEndChar);
		ASSERT(FALSE); return FALSE; }
_AFXCMN_INLINE int CComboBoxEx::InsertString(int nIndex, LPCTSTR lpszString)
	{ UNUSED_ALWAYS(nIndex); UNUSED_ALWAYS(lpszString);
		ASSERT(FALSE); return CB_ERR; }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE int CProgressCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

#if (_WIN32_IE >= 0x0400)
_AFXCMN_INLINE COLORREF CProgressCtrl::SetBarColor(COLORREF clrBar)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_SETBARCOLOR, 0, clrBar); }
#endif	// _WIN32_IE >= 0x0400

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE BOOL CProgressCtrl::SetMarquee(BOOL fMarqueeMode, int nInterval)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, PBM_SETMARQUEE, (WPARAM)fMarqueeMode, (LPARAM)nInterval); }
#endif	// _WIN32_WINNT >= 0x0501 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE int CProgressCtrl::GetStep() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETSTEP, 0, 0L); }
_AFXCMN_INLINE COLORREF CProgressCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CProgressCtrl::GetBarColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_GETBARCOLOR, 0, 0L); }
_AFXCMN_INLINE int CProgressCtrl::SetState(int iState)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETSTATE, (WPARAM)iState, 0L); }
_AFXCMN_INLINE int CProgressCtrl::GetState() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETSTATE, 0, 0L); }
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CIPAddressCtrl::CIPAddressCtrl()
	{ }
_AFXCMN_INLINE void CIPAddressCtrl::ClearAddress()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_CLEARADDRESS, 0, 0L); }
_AFXCMN_INLINE BOOL CIPAddressCtrl::IsBlank() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, IPM_ISBLANK, 0, 0L); }
_AFXCMN_INLINE int CIPAddressCtrl::GetAddress(DWORD& dwAddress) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM) &dwAddress); }
_AFXCMN_INLINE void CIPAddressCtrl::SetAddress(DWORD dwAddress)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETADDRESS, 0, (LPARAM) dwAddress); }
_AFXCMN_INLINE void CIPAddressCtrl::SetAddress(BYTE nField0, BYTE nField1, BYTE nField2, BYTE nField3)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETADDRESS, 0, (LPARAM) MAKEIPADDRESS(nField0, nField1, nField2, nField3)); }
_AFXCMN_INLINE void CIPAddressCtrl::SetFieldFocus(WORD nField)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETFOCUS, (WPARAM) nField, 0); }
_AFXCMN_INLINE void CIPAddressCtrl::SetFieldRange(int nField, BYTE nLower, BYTE nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETRANGE, (WPARAM) nField, MAKEIPRANGE(nLower, nUpper)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CImageList::SetImageCount(UINT uNewCount)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_SetImageCount(m_hImageList, uNewCount); }
_AFXCMN_INLINE BOOL CImageList::Copy(int iDst, int iSrc, UINT uFlags /* = ILCF_MOVE */)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_Copy(m_hImageList, iDst, m_hImageList, iSrc, uFlags); }
_AFXCMN_INLINE BOOL CImageList::Copy(int iDst, CImageList* pSrc, int iSrc, UINT uFlags /* = ILCF_MOVE */)
	{ ASSERT(m_hImageList != NULL); ASSERT(pSrc != NULL && (HIMAGELIST)*pSrc != NULL); return AfxImageList_Copy(m_hImageList, iDst, *pSrc, iSrc, uFlags); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\atl90\afxcmn.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H

#pragma once

#ifdef _AFXCMN_INLINE

_AFXCMN_INLINE CDragListBox::CDragListBox()
	{ m_nLast = -1;}
_AFXCMN_INLINE int CDragListBox::ItemFromPt(CPoint pt, BOOL bAutoScroll) const
	{ASSERT(::IsWindow(m_hWnd)); return ::AfxLBItemFromPt(m_hWnd, pt, bAutoScroll); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CToolBarCtrl::CToolBarCtrl()
	{ }
_AFXCMN_INLINE BOOL CToolBarCtrl::EnableButton(int nID, BOOL bEnable)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ENABLEBUTTON, nID, MAKELPARAM(bEnable, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::CheckButton(int nID, BOOL bCheck)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_CHECKBUTTON, nID, MAKELPARAM(bCheck, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::PressButton(int nID, BOOL bPress)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_PRESSBUTTON, nID, MAKELPARAM(bPress, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::HideButton(int nID, BOOL bHide)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_HIDEBUTTON, nID, MAKELPARAM(bHide, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::Indeterminate(int nID, BOOL bIndeterminate)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INDETERMINATE, nID, MAKELPARAM(bIndeterminate, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonEnabled(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONENABLED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonChecked(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONCHECKED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonPressed(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONPRESSED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonHidden(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIDDEN, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonIndeterminate(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONINDETERMINATE, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetState(int nID, UINT nState)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETSTATE, nID, MAKELPARAM(nState, 0)); }
_AFXCMN_INLINE int CToolBarCtrl::GetState(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETSTATE, nID, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::AddButtons(int nNumButtons, LPTBBUTTON lpButtons)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ADDBUTTONS, nNumButtons, (LPARAM)lpButtons); }
_AFXCMN_INLINE BOOL CToolBarCtrl::InsertButton(int nIndex, LPTBBUTTON lpButton)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)lpButton); }
_AFXCMN_INLINE BOOL CToolBarCtrl::DeleteButton(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_DELETEBUTTON, nIndex, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetButton(int nIndex, LPTBBUTTON lpButton) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETBUTTON, nIndex, (LPARAM)lpButton); }
_AFXCMN_INLINE int CToolBarCtrl::GetButtonCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_BUTTONCOUNT, 0, 0L); }
_AFXCMN_INLINE UINT CToolBarCtrl::CommandToIndex(UINT nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TB_COMMANDTOINDEX, nID, 0L); }
_AFXCMN_INLINE void CToolBarCtrl::Customize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_CUSTOMIZE, 0, 0L); }
// lpszStrings are separated by zeroes, last one is marked by two zeroes
_AFXCMN_INLINE int CToolBarCtrl::AddStrings(LPCTSTR lpszStrings)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)lpszStrings); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXCMN_INLINE void CToolBarCtrl::SetButtonStructSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, nSize, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonSize(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetBitmapSize(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE void CToolBarCtrl::AutoSize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_AUTOSIZE, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CToolBarCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TB_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CToolBarCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETTOOLTIPS, (WPARAM)pTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetOwner(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETPARENT, (WPARAM)pWnd->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetRows(int nRows, BOOL bLarger, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETROWS, MAKEWPARAM(nRows, bLarger), (LPARAM)lpRect); }
_AFXCMN_INLINE int CToolBarCtrl::GetRows() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETROWS, 0, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetCmdID(int nIndex, UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETCMDID, nIndex, nID); }
_AFXCMN_INLINE UINT CToolBarCtrl::GetBitmapFlags() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L); }
_AFXCMN_INLINE int CToolBarCtrl::GetBitmap(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETBITMAP, nID, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::ReplaceBitmap(_In_ LPTBREPLACEBITMAP pReplaceBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_REPLACEBITMAP, 0, (LPARAM)pReplaceBitmap); }
_AFXCMN_INLINE BOOL CToolBarCtrl::ChangeBitmap(int idButton, int iBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_CHANGEBITMAP, idButton, (LPARAM)MAKELPARAM(iBitmap, 0)); }
_AFXCMN_INLINE int CToolBarCtrl::HitTest(LPPOINT ppt) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_HITTEST, 0, (LPARAM)ppt); }
_AFXCMN_INLINE DWORD CToolBarCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETEXTENDEDSTYLE, 0, 0L); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetExtendedStyle(DWORD dwExStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETEXTENDEDSTYLE, 0, dwExStyle); }
_AFXCMN_INLINE void CToolBarCtrl::GetPadding(int& nHorzPadding, int& nVertPadding) const
	{ ASSERT(::IsWindow(m_hWnd)); DWORD dwPadding = (DWORD)::SendMessage(m_hWnd, TB_GETPADDING, 0, 0L); nHorzPadding = (int)LOWORD(dwPadding); nVertPadding = (int)HIWORD(dwPadding); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetPadding(int nHorzPadding, int nVertPadding)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETPADDING, 0, (LPARAM)MAKELPARAM(nHorzPadding, nVertPadding)); }
_AFXCMN_INLINE COLORREF CToolBarCtrl::GetInsertMarkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TB_GETINSERTMARKCOLOR, 0, 0); }
_AFXCMN_INLINE COLORREF CToolBarCtrl::SetInsertMarkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TB_SETINSERTMARKCOLOR, 0, (LPARAM) clrNew); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetColorScheme(COLORSCHEME* lpcs) const
	{ ASSERT(::IsWindow(m_hWnd)); lpcs->dwSize = ULONG(sizeof(COLORSCHEME)); return (BOOL)(::SendMessage(m_hWnd, TB_GETCOLORSCHEME, 0, (LPARAM)lpcs) != 0); }
_AFXCMN_INLINE void CToolBarCtrl::SetColorScheme(const COLORSCHEME* lpcs)
	{ ASSERT(::IsWindow(m_hWnd)); ((COLORSCHEME*)lpcs)->dwSize = sizeof(COLORSCHEME); ::SendMessage(m_hWnd, TB_SETCOLORSCHEME, 0, (LPARAM)lpcs); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CStatusBarCtrl::CStatusBarCtrl()
	{ }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetText(LPCTSTR lpszText, int nPane, int nType)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(nPane < 256); return (BOOL) ::SendMessage(m_hWnd, SB_SETTEXT, (nPane|nType), (LPARAM)lpszText); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetParts(int nParts, int* pWidths)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SETPARTS, nParts, (LPARAM)pWidths); }
_AFXCMN_INLINE int CStatusBarCtrl::GetParts(int nParts, int* pParts) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, SB_GETPARTS, nParts, (LPARAM)pParts); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::GetBorders(int* pBorders) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)pBorders); }
_AFXCMN_INLINE void CStatusBarCtrl::SetMinHeight(int nMin)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, SB_SETMINHEIGHT, nMin, 0L); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetSimple(BOOL bSimple)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SIMPLE, bSimple, 0L); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::GetRect(int nPane, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_GETRECT, nPane, (LPARAM)lpRect); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CListCtrl::CListCtrl()
	{ }
_AFXCMN_INLINE CToolTipCtrl* CListCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, LVM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE CToolTipCtrl* CListCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, LVM_SETTOOLTIPS, 0, (LPARAM) pTip->GetSafeHwnd())); }
_AFXCMN_INLINE COLORREF CListCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETBKCOLOR, 0, cr); }
_AFXCMN_INLINE CImageList* CListCtrl::GetImageList(int nImageList) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, LVM_GETIMAGELIST, nImageList, 0L)); }
_AFXCMN_INLINE CImageList* CListCtrl::SetImageList(CImageList* pImageList, int nImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, LVM_SETIMAGELIST, nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE int CListCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::GetItem(LVITEM* pItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CListCtrl::SetItem(const LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemData(int nItem, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData); }
_AFXCMN_INLINE int CListCtrl::InsertItem(const LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_INSERTITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE int CListCtrl::InsertItem(int nItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(LVIF_TEXT, nItem, lpszItem, 0, 0, 0, 0); }
_AFXCMN_INLINE int CListCtrl::InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(LVIF_TEXT|LVIF_IMAGE, nItem, lpszItem, 0, 0, nImage, 0); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteItem(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETEITEM, nItem, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETEALLITEMS, 0, 0L); }
_AFXCMN_INLINE UINT CListCtrl::GetCallbackMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETCALLBACKMASK, 0, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SetCallbackMask(UINT nMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCALLBACKMASK, nMask, 0); }
_AFXCMN_INLINE int CListCtrl::GetNextItem(int nItem, int nFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETNEXTITEM, nItem, MAKELPARAM(nFlags, 0)); }
_AFXCMN_INLINE POSITION CListCtrl::GetFirstSelectedItemPosition() const
	{ ASSERT(::IsWindow(m_hWnd)); return (POSITION)(DWORD_PTR)(1+GetNextItem(-1, LVIS_SELECTED)); }
_AFXCMN_INLINE int CListCtrl::GetNextSelectedItem(POSITION& pos) const
	{ ASSERT(::IsWindow(m_hWnd)); DWORD_PTR nOldPos = (DWORD_PTR)pos-1; pos = (POSITION)(DWORD_PTR)(1+GetNextItem((UINT)nOldPos, LVIS_SELECTED)); return (UINT)nOldPos; }
_AFXCMN_INLINE int CListCtrl::FindItem(LVFINDINFO* pFindInfo, int nStart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_FINDITEM, nStart, (LPARAM)pFindInfo); }
_AFXCMN_INLINE int CListCtrl::HitTest(LVHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)pHitTestInfo); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemPosition(int nItem, POINT pt)  // LVM_SETITEMPOSITION is not supported, only LVM_SETITEMPOSITION32 is.
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt); }
_AFXCMN_INLINE BOOL CListCtrl::GetItemPosition(int nItem, LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEMPOSITION, nItem, (LPARAM)lpPoint); }
_AFXCMN_INLINE int CListCtrl::GetStringWidth(LPCTSTR lpsz) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETSTRINGWIDTH, 0, (LPARAM)lpsz); }
_AFXCMN_INLINE BOOL CListCtrl::EnsureVisible(int nItem, BOOL bPartialOK)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_ENSUREVISIBLE, nItem, MAKELPARAM(bPartialOK, 0)); }
_AFXCMN_INLINE BOOL CListCtrl::Scroll(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SCROLL, size.cx, size.cy); }
_AFXCMN_INLINE BOOL CListCtrl::RedrawItems(int nFirst, int nLast)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_REDRAWITEMS, nFirst, nLast); }
_AFXCMN_INLINE BOOL CListCtrl::Arrange(UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_ARRANGE, nCode, 0L); }
_AFXCMN_INLINE CEdit* CListCtrl::EditLabel(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle( (HWND)::SendMessage(m_hWnd, LVM_EDITLABEL, nItem, 0L)); }
_AFXCMN_INLINE CEdit* CListCtrl::GetEditControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle( (HWND)::SendMessage(m_hWnd, LVM_GETEDITCONTROL, 0, 0L)); }
_AFXCMN_INLINE BOOL CListCtrl::GetColumn(int nCol, LVCOLUMN* pColumn) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE BOOL CListCtrl::SetColumn(int nCol, const LVCOLUMN* pColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE int CListCtrl::InsertColumn(int nCol, const LVCOLUMN* pColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteColumn(int nCol)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETECOLUMN, nCol, 0); }
_AFXCMN_INLINE int CListCtrl::GetColumnWidth(int nCol) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SetColumnWidth(int nCol, int cx)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCOLUMNWIDTH, nCol, MAKELPARAM(cx, 0)); }
_AFXCMN_INLINE BOOL CListCtrl::GetViewRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETVIEWRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE COLORREF CListCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetTextColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETTEXTCOLOR, 0, cr); }
_AFXCMN_INLINE COLORREF CListCtrl::GetTextBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETTEXTBKCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetTextBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETTEXTBKCOLOR, 0, cr); }
_AFXCMN_INLINE int CListCtrl::GetTopIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETTOPINDEX, 0, 0); }
_AFXCMN_INLINE int CListCtrl::GetCountPerPage() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETCOUNTPERPAGE, 0, 0); }
_AFXCMN_INLINE BOOL CListCtrl::GetOrigin(LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETORIGIN, 0, (LPARAM)lpPoint); }
_AFXCMN_INLINE BOOL CListCtrl::Update(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_UPDATE, nItem, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemState(int nItem, LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)pItem); }
_AFXCMN_INLINE UINT CListCtrl::GetItemState(int nItem, UINT nMask) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETITEMSTATE, nItem, nMask); }
_AFXCMN_INLINE void CListCtrl::SetItemCount(int nItems)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SortItems(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SORTITEMS, dwData, (LPARAM)pfnCompare); }
_AFXCMN_INLINE BOOL CListCtrl::SortItemsEx(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SORTITEMSEX, dwData, (LPARAM)pfnCompare); }
_AFXCMN_INLINE UINT CListCtrl::GetSelectedCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETSELECTEDCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::GetItemSpacing(BOOL fSmall, int* pnHorzSpacing, int* pnVertSpacing) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pnHorzSpacing != NULL);
	ASSERT(pnVertSpacing != NULL);
        if (pnHorzSpacing == NULL || pnVertSpacing == NULL)
        {
            return FALSE;
        }
	DWORD dwSpacing = (DWORD)::SendMessage(m_hWnd, LVM_GETITEMSPACING, (WPARAM)fSmall, 0L); 
	*pnHorzSpacing = (int)LOWORD(dwSpacing); 
	*pnVertSpacing = (int)HIWORD(dwSpacing); 
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CTreeCtrl::CTreeCtrl()
	{ }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPTVINSERTSTRUCT lpInsertStruct)
	{ ASSERT(::IsWindow(m_hWnd));  return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPCTSTR lpszItem, int nImage,
	int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter); }
_AFXCMN_INLINE BOOL CTreeCtrl::DeleteItem(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem); }
#pragma warning(disable: 4310)
_AFXCMN_INLINE BOOL CTreeCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT); }
#pragma warning(default: 4310)
_AFXCMN_INLINE BOOL CTreeCtrl::Expand(HTREEITEM hItem, UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE UINT CTreeCtrl::GetCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETCOUNT, 0, 0); }
_AFXCMN_INLINE UINT CTreeCtrl::GetIndent() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETINDENT, 0, 0); }
_AFXCMN_INLINE void CTreeCtrl::SetIndent(UINT nIndent)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TVM_SETINDENT, nIndent, 0); }
_AFXCMN_INLINE CImageList* CTreeCtrl::GetImageList(int nImageList) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TVM_GETIMAGELIST, (WPARAM)nImageList, 0)); }
_AFXCMN_INLINE CImageList* CTreeCtrl::SetImageList(CImageList* pImageList, int nImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE UINT CTreeCtrl::SetScrollTime(UINT uScrollTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_SETSCROLLTIME, (WPARAM) uScrollTime, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextItem(HTREEITEM hItem, UINT nCode) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetChildItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextSiblingItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetPrevSiblingItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetParentItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetFirstVisibleItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextVisibleItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetPrevVisibleItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetLastVisibleItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_LASTVISIBLE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetSelectedItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0); }
_AFXCMN_INLINE UINT CTreeCtrl::GetScrollTime() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_GETSCROLLTIME, 0, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetDropHilightItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetRootItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::Select(HTREEITEM hItem, UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectItem(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectDropTarget(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectSetFirstVisible(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::GetItem(TVITEM* pItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItem(TVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData); }
_AFXCMN_INLINE CEdit* CTreeCtrl::EditLabel(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_EDITLABEL, 0, (LPARAM)hItem)); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::HitTest(TVHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo); }
_AFXCMN_INLINE CEdit* CTreeCtrl::GetEditControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_GETEDITCONTROL, 0, 0)); }
_AFXCMN_INLINE UINT CTreeCtrl::GetVisibleCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETVISIBLECOUNT, 0, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::SortChildren(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDREN, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::EnsureVisible(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_ENSUREVISIBLE, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SortChildrenCB(LPTVSORTCB pSort)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDRENCB, 0, (LPARAM)pSort); }
_AFXCMN_INLINE CToolTipCtrl* CTreeCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE CToolTipCtrl* CTreeCtrl::SetToolTips(CToolTipCtrl* pWndTip)
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_SETTOOLTIPS, (WPARAM)pWndTip->GetSafeHwnd(), 0L)); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETBKCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE SHORT CTreeCtrl::GetItemHeight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (SHORT) ::SendMessage(m_hWnd, TVM_GETITEMHEIGHT, 0, 0L); }
_AFXCMN_INLINE SHORT CTreeCtrl::SetItemHeight(SHORT cyHeight)
	{ ASSERT(::IsWindow(m_hWnd)); return (SHORT) ::SendMessage(m_hWnd, TVM_SETITEMHEIGHT, cyHeight, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETTEXTCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetInsertMark(HTREEITEM hItem, BOOL fAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SETINSERTMARK, fAfter, (LPARAM)hItem); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetInsertMarkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETINSERTMARKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetInsertMarkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETINSERTMARKCOLOR, 0, (LPARAM)clrNew); }
_AFXCMN_INLINE BOOL CTreeCtrl::EndEditLabelNow(BOOL fCancelWithoutSave)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_ENDEDITLABELNOW, (WPARAM)fCancelWithoutSave, 0); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE COLORREF CTreeCtrl::GetLineColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, TVM_GETLINECOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetLineColor(COLORREF clrNew /*= CLR_DEFAULT*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, TVM_SETLINECOLOR, 0, (LPARAM)clrNew); }
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE UINT CTreeCtrl::MapItemToAccId(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_MAPHTREEITEMTOACCID, (WPARAM)hItem, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::MapAccIdToItem(UINT uAccId) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM) ::SendMessage(m_hWnd, TVM_MAPACCIDTOHTREEITEM, (WPARAM)uAccId, 0); }
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE UINT CTreeCtrl::GetSelectedCount()
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_GETSELECTEDCOUNT, 0, 0); }
_AFXCMN_INLINE void CTreeCtrl::ShowInfoTip(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TVM_SHOWINFOTIP, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemStateEx(HTREEITEM hItem, UINT uStateEx)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)SetItemEx(hItem, TVIF_STATEEX, 0, 0, 0, 0, 0, 0, uStateEx, 0, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemExpandedImageIndex(HTREEITEM hItem, int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)SetItemEx(hItem, TVIF_EXPANDEDIMAGE, 0, 0, 0, 0, 0, 0, TVIF_EXPANDEDIMAGE, 0, nIndex); }
_AFXCMN_INLINE DWORD CTreeCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TVM_GETEXTENDEDSTYLE, (WPARAM)0, 0); }
_AFXCMN_INLINE DWORD CTreeCtrl::SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TVM_SETEXTENDEDSTYLE, (WPARAM)dwExMask, (LPARAM)dwExStyles); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetAutoscrollInfo(UINT uPixelsPerSec, UINT uUpdateTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SETAUTOSCROLLINFO, (WPARAM)uPixelsPerSec, (LPARAM)uUpdateTime); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CHotKeyCtrl::CHotKeyCtrl()
	{ }
_AFXCMN_INLINE void CHotKeyCtrl::SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, HKM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0L); }
_AFXCMN_INLINE DWORD CHotKeyCtrl::GetHotKey() const
//IA64: Assume retval of HKM_GETHOTKEY is still 32-bit
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L)); }
_AFXCMN_INLINE void CHotKeyCtrl::SetRules(WORD wInvalidComb, WORD wModifiers)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, HKM_SETRULES, wInvalidComb, MAKELPARAM(wModifiers, 0)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CToolTipCtrl::Activate(BOOL bActivate)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetToolInfo(LPTOOLINFO lpToolInfo)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo); }
_AFXCMN_INLINE void CToolTipCtrl::RelayEvent(LPMSG lpMsg)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg); }
_AFXCMN_INLINE int CToolTipCtrl::GetToolCount() const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETTOOLCOUNT, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CSpinButtonCtrl::CSpinButtonCtrl()
 	{ }
_AFXCMN_INLINE UINT CSpinButtonCtrl::GetAccel(int nAccel, UDACCEL* pAccel) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) LOWORD(::SendMessage(m_hWnd, UDM_GETACCEL, nAccel, (LPARAM)pAccel)); }
_AFXCMN_INLINE UINT CSpinButtonCtrl::GetBase() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) LOWORD(::SendMessage(m_hWnd, UDM_GETBASE, 0, 0l)); }
_AFXCMN_INLINE CWnd* CSpinButtonCtrl::GetBuddy() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, UDM_GETBUDDY, 0, 0l)); }
_AFXCMN_INLINE int CSpinButtonCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) (::SendMessage(m_hWnd, UDM_GETPOS, 0, 0l)); }
_AFXCMN_INLINE DWORD CSpinButtonCtrl::GetRange() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0l); }
_AFXCMN_INLINE BOOL CSpinButtonCtrl::SetAccel(int nAccel, UDACCEL* pAccel)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) LOWORD(::SendMessage(m_hWnd, UDM_SETACCEL, nAccel, (LPARAM)pAccel)); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetBase(int nBase)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, UDM_SETBASE, nBase, 0L); }
_AFXCMN_INLINE CWnd* CSpinButtonCtrl::SetBuddy(CWnd* pWndBuddy)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, UDM_SETBUDDY, (WPARAM)pWndBuddy->GetSafeHwnd(), 0L)); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) (short) LOWORD(::SendMessage(m_hWnd, UDM_SETPOS, 0, MAKELPARAM(nPos, 0))); }
_AFXCMN_INLINE void CSpinButtonCtrl::SetRange(short nLower, short nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_SETRANGE, 0, MAKELPARAM(nUpper, nLower)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CSliderCtrl::CSliderCtrl()
	{ }
_AFXCMN_INLINE int CSliderCtrl::GetLineSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETLINESIZE, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::SetLineSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_SETLINESIZE, 0, nSize); }
_AFXCMN_INLINE int CSliderCtrl::GetPageSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETPAGESIZE, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::SetPageSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_SETPAGESIZE, 0, nSize); }
_AFXCMN_INLINE int CSliderCtrl::GetRangeMax() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETRANGEMAX, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::GetRangeMin() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETRANGEMIN, 0, 0l); }
_AFXCMN_INLINE void CSliderCtrl::SetRangeMin(int nMin, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETRANGEMIN, bRedraw, nMin); }
_AFXCMN_INLINE void CSliderCtrl::SetRangeMax(int nMax, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETRANGEMAX, bRedraw, nMax); }
_AFXCMN_INLINE void CSliderCtrl::ClearSel(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_CLEARSEL, bRedraw, 0l); }
_AFXCMN_INLINE void CSliderCtrl::GetChannelRect(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprc); }
_AFXCMN_INLINE void CSliderCtrl::GetThumbRect(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CSliderCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETPOS, 0, 0l); }
_AFXCMN_INLINE void CSliderCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETPOS, TRUE, nPos); }
_AFXCMN_INLINE void CSliderCtrl::ClearTics(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_CLEARTICS, bRedraw, 0l); }
_AFXCMN_INLINE UINT CSliderCtrl::GetNumTics() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TBM_GETNUMTICS, 0, 0l); }
_AFXCMN_INLINE DWORD* CSliderCtrl::GetTicArray() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD*) ::SendMessage(m_hWnd, TBM_GETPTICS, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::GetTic(int nTic) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTIC, nTic, 0L); }
_AFXCMN_INLINE int CSliderCtrl::GetTicPos(int nTic) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTICPOS, nTic, 0L); }
_AFXCMN_INLINE BOOL CSliderCtrl::SetTic(int nTic)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TBM_SETTIC, 0, nTic); }
_AFXCMN_INLINE void CSliderCtrl::SetTicFreq(int nFreq)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTICFREQ, nFreq, 0L); }
_AFXCMN_INLINE CWnd* CSliderCtrl::GetBuddy(BOOL fLocation) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, TBM_GETBUDDY, fLocation, 0l)); }
_AFXCMN_INLINE CWnd* CSliderCtrl::SetBuddy(CWnd* pWndBuddy, BOOL fLocation)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, TBM_SETBUDDY, fLocation, (LPARAM)pWndBuddy->GetSafeHwnd())); }
_AFXCMN_INLINE CToolTipCtrl* CSliderCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TBM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CSliderCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTOOLTIPS, (WPARAM)pTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE int CSliderCtrl::SetTipSide(int nLocation)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TBM_SETTIPSIDE, nLocation, 0L); }
_AFXCMN_INLINE void CSliderCtrl::SetThumbLength(int nLength)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTHUMBLENGTH, (WPARAM)nLength, 0L); }
_AFXCMN_INLINE int CSliderCtrl::GetThumbLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTHUMBLENGTH, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CProgressCtrl::CProgressCtrl()
	{ }
_AFXCMN_INLINE COLORREF CProgressCtrl::SetBkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_SETBKCOLOR, 0, (LPARAM) clrNew); }
_AFXCMN_INLINE void CProgressCtrl::SetRange(short nLower, short nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }
_AFXCMN_INLINE void CProgressCtrl::SetRange32(int nLower, int nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper); }
_AFXCMN_INLINE int CProgressCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETPOS, 0, 0); }
_AFXCMN_INLINE int CProgressCtrl::OffsetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_DELTAPOS, nPos, 0L); }
_AFXCMN_INLINE int CProgressCtrl::SetStep(int nStep)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETSTEP, nStep, 0L); }
_AFXCMN_INLINE int CProgressCtrl::StepIt()
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_STEPIT, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CHeaderCtrl::CHeaderCtrl()
	{ }
_AFXCMN_INLINE int CHeaderCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, HDM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::InsertItem(int nPos, HDITEM* phdi)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_INSERTITEM, nPos, (LPARAM)phdi); }
_AFXCMN_INLINE BOOL CHeaderCtrl::DeleteItem(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_DELETEITEM, nPos, 0L); }
_AFXCMN_INLINE BOOL CHeaderCtrl::GetItem(int nPos, HDITEM* pHeaderItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_GETITEM, nPos, (LPARAM)pHeaderItem); }
_AFXCMN_INLINE BOOL CHeaderCtrl::SetItem(int nPos, HDITEM* pHeaderItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_SETITEM, nPos, (LPARAM)pHeaderItem); }
_AFXCMN_INLINE BOOL CHeaderCtrl::Layout(HDLAYOUT* pHeaderLayout)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_LAYOUT, 0, (LPARAM)pHeaderLayout); }
_AFXCMN_INLINE int CHeaderCtrl::HitTest(_Inout_ LPHDHITTESTINFO pHeaderHitTestInfo)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, HDM_HITTEST, 0, (LPARAM)pHeaderHitTestInfo); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CTabCtrl::CTabCtrl()
	{ }
_AFXCMN_INLINE CImageList* CTabCtrl::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TCM_GETIMAGELIST, 0, 0L)); }
_AFXCMN_INLINE CImageList* CTabCtrl::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TCM_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE int CTabCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::GetItem(int nItem, TCITEM* pTabCtrlItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_GETITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE BOOL CTabCtrl::SetItem(int nItem, TCITEM* pTabCtrlItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE BOOL CTabCtrl::SetItemExtra(int nBytes)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_SETITEMEXTRA, (WPARAM) nBytes, 0); }
_AFXCMN_INLINE void CTabCtrl::SetCurFocus(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETCURFOCUS, (WPARAM) nItem, 0); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, TCITEM* pTabCtrlItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (LONG)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return CTabCtrl::InsertItem(TCIF_TEXT, nItem, lpszItem, 0, 0); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); return CTabCtrl::InsertItem(TCIF_TEXT|TCIF_IMAGE, nItem, lpszItem, nImage, 0); }
_AFXCMN_INLINE BOOL CTabCtrl::DeleteItem(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_DELETEITEM, nItem, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_DELETEALLITEMS, 0, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::GetItemRect(int nItem, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_GETITEMRECT, nItem, (LPARAM)lpRect); }
_AFXCMN_INLINE int CTabCtrl::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETCURSEL, 0, 0L); }
_AFXCMN_INLINE int CTabCtrl::SetCurSel(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_SETCURSEL, nItem, 0L); }
_AFXCMN_INLINE int CTabCtrl::HitTest(TCHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_HITTEST, 0, (LPARAM) pHitTestInfo); }
_AFXCMN_INLINE void CTabCtrl::AdjustRect(BOOL bLarger, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_ADJUSTRECT, bLarger, (LPARAM)lpRect); }
_AFXCMN_INLINE CSize CTabCtrl::SetItemSize(CSize size)
//IA64: Assume size is still packed into a DWORD
	{ ASSERT(::IsWindow(m_hWnd)); return (CSize)DWORD(::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx,size.cy))); }
_AFXCMN_INLINE void CTabCtrl::RemoveImage(int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_REMOVEIMAGE, nImage, 0L); }
_AFXCMN_INLINE void CTabCtrl::SetPadding(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE int CTabCtrl::GetRowCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETROWCOUNT, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CTabCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TCM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CTabCtrl::SetToolTips(CToolTipCtrl* pWndTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETTOOLTIPS, (WPARAM)pWndTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE int CTabCtrl::GetCurFocus() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETCURFOCUS, 0, 0L); }
_AFXCMN_INLINE int CTabCtrl::SetMinTabWidth(int cx)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_SETMINTABWIDTH, 0, (LPARAM)cx); }
_AFXCMN_INLINE void CTabCtrl::DeselectAll(BOOL fExcludeFocus)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_DESELECTALL, fExcludeFocus, 0); }
_AFXCMN_INLINE BOOL CTabCtrl::HighlightItem(int idItem, BOOL fHighlight /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_HIGHLIGHTITEM, idItem, MAKELPARAM(fHighlight, 0)); }
_AFXCMN_INLINE DWORD CTabCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TCM_GETEXTENDEDSTYLE, 0, 0); }
_AFXCMN_INLINE DWORD CTabCtrl::SetExtendedStyle(DWORD dwNewStyle, DWORD dwExMask /*= 0*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TCM_SETEXTENDEDSTYLE, dwExMask, dwNewStyle); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CAnimateCtrl::CAnimateCtrl()
	{ }
_AFXCMN_INLINE BOOL CAnimateCtrl::Open(LPCTSTR lpszName)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN,
		(WPARAM) ::AfxFindResourceHandle(lpszName, _T("AVI")), (LPARAM)lpszName); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Open(UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN,
		(WPARAM) ::AfxFindResourceHandle(MAKEINTRESOURCE(nID), _T("AVI")), (LPARAM) nID); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Play(UINT nFrom, UINT nTo, UINT nRep)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, nRep, MAKELPARAM(nFrom, nTo)); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Stop()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_STOP, 0, 0L); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Close()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, 0L); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Seek(UINT nTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, 0, MAKELPARAM(nTo, nTo)); }
#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CAnimateCtrl::IsPlaying() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_ISPLAYING, 0, 0L); }
#endif

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_NO_RICHEDIT_SUPPORT
_AFXCMN_INLINE CRichEditCtrl::CRichEditCtrl()
	{ }
_AFXCMN_INLINE BOOL CRichEditCtrl::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::CanRedo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANREDO, 0, 0); }
_AFXCMN_INLINE UNDONAMEID CRichEditCtrl::GetUndoName() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UNDONAMEID) ::SendMessage(m_hWnd, EM_GETUNDONAME, 0, 0); }
_AFXCMN_INLINE UNDONAMEID CRichEditCtrl::GetRedoName() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UNDONAMEID) ::SendMessage(m_hWnd, EM_GETREDONAME, 0, 0); }
_AFXCMN_INLINE int CRichEditCtrl::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::SetModify(BOOL bModified /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0);}
_AFXCMN_INLINE BOOL CRichEditCtrl::SetTextMode(UINT fMode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_SETTEXTMODE, (WPARAM) fMode, 0); }
_AFXCMN_INLINE UINT CRichEditCtrl::GetTextMode() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETTEXTMODE, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE CPoint CRichEditCtrl::GetCharPos(long lChar) const
	{ ASSERT(::IsWindow(m_hWnd)); CPoint pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)lChar); return pt;}
_AFXCMN_INLINE UINT CRichEditCtrl::GetOptions() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETOPTIONS, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::SetOptions(WORD wOp, DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETOPTIONS, (WPARAM)wOp, (LPARAM)dwFlags); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetAutoURLDetect(BOOL bEnable /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_AUTOURLDETECT, (WPARAM) bEnable, 0); }
_AFXCMN_INLINE void CRichEditCtrl::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXCMN_INLINE UINT CRichEditCtrl::SetUndoLimit(UINT nLimit)
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_SETUNDOLIMIT, (WPARAM) nLimit, 0); }
_AFXCMN_INLINE void CRichEditCtrl::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXCMN_INLINE void CRichEditCtrl::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE void CRichEditCtrl::StopGroupTyping()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_STOPGROUPTYPING, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::Redo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_REDO, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetReadOnly(BOOL bReadOnly /* = TRUE */ )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXCMN_INLINE int CRichEditCtrl::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXCMN_INLINE BOOL CRichEditCtrl::DisplayBand(LPRECT pDisplayRect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect); }
_AFXCMN_INLINE void CRichEditCtrl::GetSel(CHARRANGE &cr) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr); }
_AFXCMN_INLINE BOOL CRichEditCtrl::GetPunctuation(UINT fType, PUNCTUATION* lpPunc) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_GETPUNCTUATION, (WPARAM) fType, (LPARAM) lpPunc); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetPunctuation(UINT fType, PUNCTUATION* lpPunc)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_SETPUNCTUATION, (WPARAM) fType, (LPARAM) lpPunc); }
_AFXCMN_INLINE void CRichEditCtrl::LimitText(long nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars); }
_AFXCMN_INLINE long CRichEditCtrl::LineFromChar(long nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex); }
_AFXCMN_INLINE CPoint CRichEditCtrl::PosFromChar(UINT nChar) const
	{ ASSERT(::IsWindow(m_hWnd)); POINTL pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, nChar); return CPoint(pt.x, pt.y); }
_AFXCMN_INLINE int CRichEditCtrl::CharFromPos(CPoint pt) const
	{ ASSERT(::IsWindow(m_hWnd)); POINTL ptl = {pt.x, pt.y}; return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, (LPARAM)&ptl); }
_AFXCMN_INLINE void CRichEditCtrl::SetSel(CHARRANGE &cr)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr); }
_AFXCMN_INLINE DWORD CRichEditCtrl::FindWordBreak(UINT nCode, DWORD nStart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_FINDWORDBREAK, (WPARAM) nCode, (LPARAM) nStart); }

_AFXCMN_INLINE long CRichEditCtrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)pFindText); }

_AFXCMN_INLINE long CRichEditCtrl::FormatRange(FORMATRANGE* pfr, BOOL bDisplay)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FORMATRANGE, (WPARAM)bDisplay, (LPARAM)pfr); }

_AFXCMN_INLINE long CRichEditCtrl::GetEventMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L); }

_AFXCMN_INLINE long CRichEditCtrl::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L); }

_AFXCMN_INLINE long CRichEditCtrl::GetSelText(_Pre_notnull_ _Post_z_ LPSTR lpBuf) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf); }

_AFXCMN_INLINE void CRichEditCtrl::HideSelection(BOOL bHide, BOOL bPerm)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bPerm); }

_AFXCMN_INLINE void CRichEditCtrl::RequestResize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L); }

_AFXCMN_INLINE WORD CRichEditCtrl::GetSelectionType() const
	{ ASSERT(::IsWindow(m_hWnd)); return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L); }

_AFXCMN_INLINE UINT CRichEditCtrl::GetWordWrapMode() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETWORDWRAPMODE, 0, 0); }

_AFXCMN_INLINE UINT CRichEditCtrl::SetWordWrapMode(UINT uFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_SETWORDWRAPMODE, (WPARAM) uFlags, 0); }

_AFXCMN_INLINE COLORREF CRichEditCtrl::SetBackgroundColor(BOOL bSysColor, COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, bSysColor, cr); }

_AFXCMN_INLINE DWORD CRichEditCtrl::SetEventMask(DWORD dwEventMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetOLECallback(IRichEditOleCallback* pCallback)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetTargetDevice(HDC hDC, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, lLineWidth); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetTargetDevice(CDC &dc, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)dc.m_hDC, lLineWidth); }

_AFXCMN_INLINE long CRichEditCtrl::StreamIn(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMIN, nFormat, (LPARAM)&es); }

_AFXCMN_INLINE long CRichEditCtrl::StreamOut(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es); }

_AFXCMN_INLINE long CRichEditCtrl::GetTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, NULL, NULL); }

#endif //!_AFX_NO_RICHEDIT_SUPPORT
/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\atl90\afxcmn.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCMN_H__
#define __AFXCMN_H__

#ifdef _AFX_NO_AFXCMN_SUPPORT
	#error Windows Common Control classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef IMAGE_BITMAP
#define IMAGE_BITMAP 0
#endif

#ifndef HDSIL_NORMAL
#define HDSIL_NORMAL 0
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#if (_WIN32_WINNT >= 0x0501)
	#include <uxtheme.h>
#endif	// _WIN32_WINNT >= 0x0501

#ifndef _AFX_NO_RICHEDIT_SUPPORT
	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif
	#ifdef __AFXOLE_H__  // only include richole if OLE support is included
		#ifndef _RICHOLE_
			#include <richole.h>
			#define _RICHOLE_
		#endif
	#else
		struct IRichEditOle;
		struct IRichEditOleCallback;
	#endif
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning(push)
#endif

#pragma warning(disable: 4263 4264)  // base class method is hidden

/////////////////////////////////////////////////////////////////////////////
// AFXCMN - MFC COMCTL32 Control Classes

// Classes declared in this file

//TOOLINFO
	class CToolInfo;

//CObject
	//CCmdTarget;
		//CWnd
			// class CListBox;
				class CDragListBox;
			class CStatusBarCtrl;
			class CListCtrl;
			class CTreeCtrl;
			class CSpinButtonCtrl;
			class CSliderCtrl;
			class CProgressCtrl;
			// class CComboBox;
				class CComboBoxEx;
			class CHeaderCtrl;
			class CHotKeyCtrl;
			class CToolTipCtrl;
			class CTabCtrl;
			class CAnimateCtrl;
			class CToolBarCtrl;
			class CReBarCtrl;
			class CRichEditCtrl;
			class CIPAddressCtrl;
			class CPagerCtrl;
			class CLinkCtrl;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
			class CNetAddressCtrl;
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CToolInfo

#ifdef _UNICODE
class CToolInfo : public tagTOOLINFOW
#else
class CToolInfo : public tagTOOLINFOA
#endif
{
public:
	TCHAR szText[256];
};

/////////////////////////////////////////////////////////////////////////////
// CDragListBox

class CDragListBox : public CListBox
{
	DECLARE_DYNAMIC(CDragListBox)

// Constructors
public:
	CDragListBox();

// Attributes

	// find item index at given point
	int ItemFromPt(_In_ CPoint pt, _In_ BOOL bAutoScroll = TRUE) const;

// Operations

	// draws insertion line
	virtual void DrawInsert(_In_ int nItem);

// Overridables

	// Override to respond to beginning of drag event.
	virtual BOOL BeginDrag(_In_ CPoint pt);

	// Overrdie to react to user cancelling drag.
	virtual void CancelDrag(_In_ CPoint pt);

	// Called as user drags. Return constant indicating cursor.
	virtual UINT Dragging(_In_ CPoint pt);

	// Called when user releases mouse button to end drag event.
	virtual void Dropped(_In_ int nSrcIndex, _In_ CPoint pt);

// Implementation
public:
	int m_nLast;
	void DrawSingle(_In_ int nIndex);
	virtual void PreSubclassWindow();
	virtual ~CDragListBox();

protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

/////////////////////////////////////////////////////////////////////////////
// CStatusBarCtrl

// NOTE: This class must remain a binary-compatible subset
// of CStatusBar. Do not add data members or virtual functions
// directly to this class.
class CStatusBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CStatusBarCtrl)

// Constructors
public:
	CStatusBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Sets text in a particular pane.
	BOOL SetText(_In_z_ LPCTSTR lpszText, _In_ int nPane, _In_ int nType);

	// Retrieves text from a particular pane.
	CString GetText(_In_ int nPane, _In_ int* pType = NULL) const;
	int GetText(_Pre_notnull_ _Post_z_ LPTSTR lpszText, _In_ int nPane, _Out_ int* pType = NULL) const;

	// Gets the legnth of text in a particular pane without
	// retreiving the actual text.
	int GetTextLength(_In_ int nPane, _Out_ int* pType = NULL) const;

	// Sets size of individual panes within the control.
	BOOL SetParts(_In_ int nParts, _In_ int* pWidths);

	// Returns sizes of each pane within the control.
	int GetParts(_In_ int nParts, _Out_ int* pParts) const;

	// Get sizes of all borders in on control.
	BOOL GetBorders(_Out_ int* pBorders) const;
	BOOL GetBorders(_Out_ int& nHorz, _Out_ int& nVert, _Out_ int& nSpacing) const;

	// Sets the minimum allowable height for the control.
	void SetMinHeight(_In_ int nMin);

	// Sets the control to have one single pane and no subdivisions.
	BOOL SetSimple(_In_ BOOL bSimple = TRUE);

	// Gets the bounding rectangle of a specific pane.
	BOOL GetRect(_In_ int nPane, _Out_ LPRECT lpRect) const;

	// Determines if the control has one single pane.
	BOOL IsSimple() const;

	// Returns tooltip text for the given pane.
	CString GetTipText(_In_ int nPane) const;

	// Sets tooltip text for the given pane.
	void SetTipText(_In_ int nPane, _In_z_ LPCTSTR pszTipText);

	// Sets background color for all panes in the control.
	COLORREF SetBkColor(_In_ COLORREF cr);

	// Sets icon for the given part.
	BOOL SetIcon(_In_ int iPart, _In_ HICON hIcon);

	// Retrieves icon for the given part.
	HICON GetIcon(_In_ int iPart) const;

// Overridables
	// Override to perform owner draw. Control must
	// have the owner draw style.
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	// virtual OK here - ~CWnd is virtual
	virtual ~CStatusBarCtrl();
protected:
	// virtual OK here - CWnd makes this virtual
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

/////////////////////////////////////////////////////////////////////////////
// CListCtrl

// NOTE: This class must remain a binary-compatible subset
// of CListView. Do not add data members or virtual functions
// directly to this class.
class CListCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual is OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CListCtrl)

// Constructors
public:
	CListCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the background color for the control.
	COLORREF GetBkColor() const;

	// Sets background color for the control.
	BOOL SetBkColor(_In_ COLORREF cr);

	// Retrieves the image list associated with the control.
	CImageList* GetImageList(_In_ int nImageList) const;

	// Sets the image list associated with this control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList);

	// Retrieves the tool tip control associated with this control.
	CToolTipCtrl* GetToolTips() const;

	// Sets the tool tip control to be used by this control.
	CToolTipCtrl* SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Retrieves the number of items in the control.
	int GetItemCount() const;

	// Retrieves a description of a particular item in the control.
	BOOL GetItem(_Out_ LVITEM* pItem) const;

	// Sets information to an existing item in the control.
	BOOL SetItem(_In_ const LVITEM* pItem);
	BOOL SetItem(_In_ int nItem, _In_ int nSubItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam);
	BOOL SetItem(_In_ int nItem, _In_ int nSubItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam, _In_ int nIndent);

	// Determines which item attributes are maintained by the application
	// instead of the control itself.
	UINT GetCallbackMask() const;

	// Specifies which item attributes are maintained by the application
	// instead of the control itself.
	BOOL SetCallbackMask(_In_ UINT nMask);

	// Get the next item after nItem matching flags in nFlags.
	int GetNextItem(_In_ int nItem, _In_ int nFlags) const;

	// Gets first item selected in the control and prepares for
	// finding other selected items (if the control has the multiple
	// selection style).
	POSITION GetFirstSelectedItemPosition() const;

	// Finds the next selected item, after a previous call
	// to GetFirstSelectedItemPosition().
	int GetNextSelectedItem(_Inout_ POSITION& pos) const;

	// Retrieves the bounding rectangle for a particular item.
	BOOL GetItemRect(_In_ int nItem, _Out_ LPRECT lpRect, _In_ UINT nCode) const;

	// Find the location of a particular item in the control,
	// relative to the control's client area.
	BOOL SetItemPosition(_In_ int nItem, _In_ POINT pt);
	BOOL GetItemPosition(_In_ int nItem, _Out_ LPPOINT lpPoint) const;

	// Determines the width of a string as displayed in report mode.
	int GetStringWidth(_In_z_ LPCTSTR lpsz) const;

	// Retrieves the edit control associated with the currently edited
	// item in the control.
	CEdit* GetEditControl() const;

	// Retrieves information about a column in a report-mode control.
	BOOL GetColumn(_In_ int nCol, _Out_ LVCOLUMN* pColumn) const;

	// Sets information about a column in a report-mode control.
	BOOL SetColumn(_In_ int nCol, _In_ const LVCOLUMN* pColumn);

	// Retrieves the width of a column in a report-mode control.
	int GetColumnWidth(_In_ int nCol) const;

	// Sets the width of a column in a report-mode control.
	BOOL SetColumnWidth(_In_ int nCol, _In_ int cx);

	BOOL GetViewRect(_Out_ LPRECT lpRect) const;

	// Retrieves foreground color of text labels in the control.
	COLORREF GetTextColor() const;

	// Sets foreground color of text labels in the control.
	BOOL SetTextColor(_In_ COLORREF cr);

	// Retrieves background color of text labels in the control.
	COLORREF GetTextBkColor() const;

	// Sets background color of text labels in the control.
	BOOL SetTextBkColor(_In_ COLORREF cr);

	// Retrieves the index of the topmost visible item in the control.
	int GetTopIndex() const;

	// Retrieves the number of items displayed at one time
	// the control's client area.
	int GetCountPerPage() const;

	// Retrieves the current origin of the client area.
	BOOL GetOrigin(_Out_ LPPOINT lpPoint) const;

	// Sets the state of a particular item.
	BOOL SetItemState(_In_ int nItem, _In_ LVITEM* pItem);
	BOOL SetItemState(_In_ int nItem, _In_ UINT nState, _In_ UINT nMask);

	// Retrieves the state of a particular item.
	UINT GetItemState(_In_ int nItem, _In_ UINT nMask) const;

	// Retrieves the text associated with a particular item.
	CString GetItemText(_In_ int nItem, _In_ int nSubItem) const;
	int GetItemText(_In_ int nItem, _In_ int nSubItem, _Out_z_cap_post_count_(nLen, return + 1) LPTSTR lpszText, _In_ int nLen) const;

	// Sets the text associated with a particular item.
	BOOL SetItemText(_In_ int nItem, _In_ int nSubItem, _In_z_ LPCTSTR lpszText);

	// Sets the count of items in the control. The control will use
	// this value to preallocate memory for its own storage; you may
	// exceed the item count at any time, but accurate preallocation
	// can help performance.
	void SetItemCount(_In_ int nItems);

	// Sets the data (lParam) associated with a particular item.
	BOOL SetItemData(_In_ int nItem, _In_ DWORD_PTR dwData);

	// Retrieves the data (lParam) associated with a particular item.
	DWORD_PTR GetItemData(_In_ int nItem) const;

	// Retrieves the number of selected items in the control.
	UINT GetSelectedCount() const;

	// Retrieves the spacing between items in the control.
	BOOL GetItemSpacing(_In_ BOOL fSmall, _Out_ int* pnHorzSpacing, _Out_ int* pnVertSpacing) const;

	BOOL SetColumnOrderArray(_In_ int iCount, _In_ LPINT piArray);
	BOOL GetColumnOrderArray(_Out_ LPINT piArray, _In_ int iCount = -1) const;

	// Sets minimum spacing of items in the icon view.
	CSize SetIconSpacing(_In_ CSize size);
	CSize SetIconSpacing(_In_ int cx, _In_ int cy);

	// Retrieves a reference to the header control in
	// a report-mode control.
	CHeaderCtrl* GetHeaderCtrl() const;

	// Retrieves the cursor used over hot items. (Only valid for
	// controls with the LVS_EX_TRACKSELECT style.)
	HCURSOR GetHotCursor() const;

	// Sets cursor to be used over hot items. (Only used in controls
	// with the LVS_EX_TRACKSELECT style.)
	HCURSOR SetHotCursor(_In_ HCURSOR hc);

	BOOL GetSubItemRect(_In_ int iItem, _In_ int iSubItem, _In_ int nArea, _Out_ CRect& ref) const;

	// Retrieves the item currently hot-selected, or -1 if none.
	int GetHotItem() const;

	// Sets the item to be currently hot-selected.
	int SetHotItem(_In_ int iIndex);

	// Retrieves the item with the selection mark, or -1 if none.
	int GetSelectionMark() const;

	// Sets the item with the selection mark.
	int SetSelectionMark(_In_ int iIndex);

	// Retrieves the control-specific extended style bits.
	DWORD GetExtendedStyle() const;

	// Sets the control-specific extended style bits.
	DWORD SetExtendedStyle(_In_ DWORD dwNewStyle);

	// Determines the visual feature of a subitem control under
	// the specified point.
	int SubItemHitTest(_In_ LPLVHITTESTINFO pInfo);

	// Sets up virtual work areas within the control.
	void SetWorkAreas(_In_ int nWorkAreas, _In_ LPRECT lpRect);

	// Updates expected item count for a virtual control.
	BOOL SetItemCountEx(_In_ int iCount, _In_ DWORD dwFlags = LVSICF_NOINVALIDATEALL);

	// Calculates the approximate minimum size required to
	// display the passed number of items.
	CSize ApproximateViewRect(_In_ CSize sz = CSize(-1, -1),
		int iCount = -1) const;

	// Retrieves information about the background image in the control.
	BOOL GetBkImage(_Out_ LVBKIMAGE* plvbkImage) const;

	// Retrieves the delay (in milliseconds) for the mouse to hover
	// over an item before it is selected.
	DWORD GetHoverTime() const;

	// Retrieves the rectangles defining the workareas in the control.
	void GetWorkAreas(_In_ int nWorkAreas, _Out_ LPRECT prc) const;

	// Sets the image used in the background of the control.
   BOOL SetBkImage(_In_ HBITMAP hbm, _In_ BOOL fTile = TRUE,
		_In_ int xOffsetPercent = 0, _In_ int yOffsetPercent = 0);
   BOOL SetBkImage(_In_z_ LPTSTR pszUrl, _In_ BOOL fTile = TRUE,
		_In_ int xOffsetPercent = 0, _In_ int yOffsetPercent = 0);
   BOOL SetBkImage(_In_ LVBKIMAGE* plvbkImage);

	// Sets the delay (in milliseconds) for the mouse to hover
	// over an item before it is selected.
	DWORD SetHoverTime(_In_ DWORD dwHoverTime = (DWORD)-1);

	// Returns the number of work areas in the control.
	UINT GetNumberOfWorkAreas() const;

	// Retrieves the checked state of a particular item. Only useful
	// on controls with the LVS_EX_CHECKBOXES style.
	BOOL GetCheck(_In_ int nItem) const;

	// Sets the checked state of a particular item. Only useful
	// on controls with the LVS_EX_CHECKBOXES style.
	BOOL SetCheck(_In_ int nItem, _In_ BOOL fCheck = TRUE);

// Operations

	// Adds an item to the control.
	int InsertItem(_In_ const LVITEM* pItem);
	int InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem);
	int InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ int nImage);

	// Removes a single item from the control.
	BOOL DeleteItem(_In_ int nItem);

	// Removes all items from the control.
	BOOL DeleteAllItems();

	// Finds an item in the control matching the specified criteria.
	int FindItem(_In_ LVFINDINFO* pFindInfo, _In_ int nStart = -1) const;

	// Determines the visual feature of the control under
	// the specified point.
	int HitTest(_In_ LVHITTESTINFO* pHitTestInfo) const;
	int HitTest(_In_ CPoint pt, _In_opt_ UINT* pFlags = NULL) const;

	// Causes the control to scroll its content so the specified item
	// is completely (or at least partially, depending on the
	// bPartialOK parameter) visible.
	BOOL EnsureVisible(_In_ int nItem, _In_ BOOL bPartialOK);

	// Forces the control to scroll its client area
	// by the specified amount.
	BOOL Scroll(_In_ CSize size);

	// Forces the control to repaint a specific range of items.
	BOOL RedrawItems(_In_ int nFirst, _In_ int nLast);

	// Causes the control to rearrange items within its client area.
	BOOL Arrange(_In_ UINT nCode);

	// Causes the control to enter edit mode on the speficied item.
	CEdit* EditLabel(_In_ int nItem);

	// Inserts a column into a report-mode control.
	int InsertColumn(_In_ int nCol, _In_ const LVCOLUMN* pColumn);
	int InsertColumn(_In_ int nCol, _In_z_ LPCTSTR lpszColumnHeading,
		_In_ int nFormat = LVCFMT_LEFT, _In_ int nWidth = -1, _In_ int nSubItem = -1);

	// Deletes a column from a report-mode control.
	BOOL DeleteColumn(_In_ int nCol);

	// Creates a drag-time image from a particular item in the control.
	CImageList* CreateDragImage(_In_ int nItem, _In_ LPPOINT lpPoint);

	// Forces the control to repaint a specific item.
	BOOL Update(_In_ int nItem);

	// Call to sort items using a custom comparison function.
	BOOL SortItems(_In_ PFNLVCOMPARE pfnCompare, _In_ DWORD_PTR dwData);
	BOOL SortItemsEx(_In_ PFNLVCOMPARE pfnCompare, _In_ DWORD_PTR dwData);

#if (_WIN32_WINNT >= 0x0501)

	// Sets the selected column in a report-mode control.
	AFX_ANSI_DEPRECATED void SetSelectedColumn(_In_ int iCol);

	AFX_ANSI_DEPRECATED DWORD SetView(_In_ int iView);
	AFX_ANSI_DEPRECATED DWORD GetView() const;

	// Adds a group to the control.
	AFX_ANSI_DEPRECATED int InsertGroup(_In_ int index, _In_ PLVGROUP pgrp);

	// Sets information about the specified group (by ID) in the control.
	AFX_ANSI_DEPRECATED int SetGroupInfo(_In_ int iGroupId, _In_ PLVGROUP pGroup);

	// Retrieves information for the specified group in the control.
	AFX_ANSI_DEPRECATED int GetGroupInfo(_In_ int iGroupId, _Out_ PLVGROUP pgrp) const;

	// Removes a group from the control.
	AFX_ANSI_DEPRECATED int RemoveGroup(_In_ int iGroupId);

	// Moves a group in the control.
	AFX_ANSI_DEPRECATED void MoveGroup(_In_ int iGroupId, _In_ int toIndex);

	// Moves an item to a different group in the control.
	AFX_ANSI_DEPRECATED void MoveItemToGroup(_In_ int idItemFrom, _In_ int idGroupTo);

	// Sets group metric information to a group in the control.
	AFX_ANSI_DEPRECATED void SetGroupMetrics(_In_ PLVGROUPMETRICS pGroupMetrics);

	// Retrieves group metric information for a group in the control.
	AFX_ANSI_DEPRECATED void GetGroupMetrics(_Out_ PLVGROUPMETRICS pGroupMetrics) const;

	// Enables group view in the control.
	AFX_ANSI_DEPRECATED int EnableGroupView(_In_ BOOL fEnable);

	// Uses an application-defined comparison function to sort groups by ID within the list-view control.
	AFX_ANSI_DEPRECATED BOOL SortGroups(_In_ PFNLVGROUPCOMPARE _pfnGroupCompare, _In_ LPVOID _plv);

	// Inserts a group into an ordered list of groups in the control.
	AFX_ANSI_DEPRECATED void InsertGroupSorted(_In_ PLVINSERTGROUPSORTED pStructInsert);

	// Removes all groups from the control.
	AFX_ANSI_DEPRECATED void RemoveAllGroups();

	// Determines if the control has a group with the specified ID.
	AFX_ANSI_DEPRECATED BOOL HasGroup(_In_ int iGroupId) const;

	// Sets information that the list-view control uses in tile view.
	AFX_ANSI_DEPRECATED BOOL SetTileViewInfo(_In_ PLVTILEVIEWINFO ptvi);

	// Retrieves information about the list-view control in tile view.
	AFX_ANSI_DEPRECATED BOOL GetTileViewInfo(_Out_ PLVTILEVIEWINFO ptvi) const;

	// Sets information for a tile of the list-view control.
	AFX_ANSI_DEPRECATED BOOL SetTileInfo(_In_ PLVTILEINFO pti);

	// Retrieves information about a tile in the list-view control.
	AFX_ANSI_DEPRECATED BOOL GetTileInfo(_Out_ PLVTILEINFO pti) const;

	// Sets the insertion point in the control to the defined position.
	AFX_ANSI_DEPRECATED BOOL SetInsertMark(_In_ LPLVINSERTMARK lvim);

	// Retrieves the position of the insertion point in the control.
	AFX_ANSI_DEPRECATED BOOL GetInsertMark(_Out_ LPLVINSERTMARK lvim) const;

	// Retrieves the insertion point closest to a specified point.
	AFX_ANSI_DEPRECATED int InsertMarkHitTest(_In_ LPPOINT pPoint, _In_ LPLVINSERTMARK lvim) const;

	// Retrieves the rectangle that bounds the insertion point in the control.
	AFX_ANSI_DEPRECATED int GetInsertMarkRect(_Out_ LPRECT pRect) const;

	// Sets the color of the insertion point in the control.
	AFX_ANSI_DEPRECATED COLORREF SetInsertMarkColor(_In_ COLORREF color);

	// Retrieves the color of the insertion point in the control.
	AFX_ANSI_DEPRECATED COLORREF GetInsertMarkColor() const;

	// Sets ToolTip text for the control.
	AFX_ANSI_DEPRECATED BOOL SetInfoTip(_In_ PLVSETINFOTIP plvInfoTip);

	// Retrieves the selected column in a report-mode control.
	AFX_ANSI_DEPRECATED UINT GetSelectedColumn() const;

	// Determines if group view is enabled for the control.
	AFX_ANSI_DEPRECATED BOOL IsGroupViewEnabled() const;

	// Retrieves the color of the border of the list-view control.
	AFX_ANSI_DEPRECATED COLORREF GetOutlineColor() const;

	// Sets the color of the border of the list-view control.
	AFX_ANSI_DEPRECATED COLORREF SetOutlineColor(_In_ COLORREF color);

	// Cancels an item text editing operation in the control.
	AFX_ANSI_DEPRECATED void CancelEditLabel();

#endif	// _WIN32_WINNT >= 0x0501

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the string displayed when the list-view is empty.
	CString GetEmptyText() const;

	// REVIEW: Retrieves the rectangle for the specified item in the list-view (by group/item index).
	BOOL GetItemIndexRect(_In_ PLVITEMINDEX pItemIndex, _In_ int iColumn, _In_ int rectType, _Out_ LPRECT pRect) const;

	// REVIEW: Sets state for the specified item in the list-view (by group/item index).
	HRESULT SetItemIndexState(_In_ PLVITEMINDEX pItemIndex, _In_ DWORD dwState, _In_ DWORD dwMask);

	// REVIEW: Retrieves the next item in the list-view (by group/item index) based on the flags.
	BOOL GetNextItemIndex(_In_ PLVITEMINDEX pItemIndex, _In_ int nFlags) const;
	
	// Retrieves the number of groups in the control.
	int GetGroupCount() const;
	
	// REVIEW: Retrieves information about the specified group (by index) in the control.
	BOOL GetGroupInfoByIndex(_In_ int iIndex, _Out_ PLVGROUP pGroup) const;

	// Sets state information to the specified group in the control.
	void SetGroupState(_In_ int iGroupId, _In_ DWORD dwMask, _In_ DWORD dwState);

	// Retrieves state information for the specified group in the control.
	UINT GetGroupState(_In_ int iGroupId, _In_ DWORD dwMask) const;

	// REVIEW: Gets the group that has the focus in the control.
	int GetFocusedGroup() const;

	// REVIEW: Gets the rectangle for the specified group in the control.
	BOOL GetGroupRect(_In_ int iGroupId, _Out_ LPRECT lpRect, _In_ int iType = LVGGR_GROUP) const;

	// Maps the index of an item in the control to a unique ID.
	UINT MapIndexToID(_In_ UINT index) const;

	// Maps the unique ID of an item in the control to an index.
	UINT MapIDToIndex(_In_ UINT id) const;
	
	// Indicates if an item in the list-view control is visible.
	BOOL IsItemVisible(_In_ int index) const;

#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Overridables
	// Override to perform owner draw. Control must
	// have the owner draw style.
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	int InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ UINT nState,
		_In_ UINT nStateMask, _In_ int nImage, _In_ LPARAM lParam);
	// virtual OK here - ~CWnd is virtual
	virtual ~CListCtrl();
protected:
	void RemoveImageList(_In_ int nImageList);
	// virtual OK here - CWnd makes this virtual
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
protected:
	//{{AFX_MSG(CListCtrl)
	afx_msg void OnNcDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrl

// NOTE: This class must remain a binary-compatible subset
// of CTreeView. Do not add data members or virtual functions
// directly to this class.
class CTreeCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CTreeCtrl)

// Constructors
public:
	CTreeCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Retrieves the bounding rectangle for the specified item.
	BOOL GetItemRect(_In_ HTREEITEM hItem, _Out_ LPRECT lpRect, _In_ BOOL bTextOnly) const;

	// Gets the count of items in the control.
	UINT GetCount() const;

	// Returns the level-to-level indentation (in pixels).
	UINT GetIndent() const;

	// Sets the level-to-level indentation (in pixels).
	void SetIndent(_In_ UINT nIndent);

	// Retrieves the image list associated with the control.
	CImageList* GetImageList(_In_ int nImageList) const;

	// Sets the image list associated with this control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList);

	// Retrieves the next item having the given relationship with the
	// specified item.
	HTREEITEM GetNextItem(_In_ HTREEITEM hItem, _In_ UINT nCode) const;

	// Retrieves the next child item after the specified item.
	HTREEITEM GetChildItem(_In_ HTREEITEM hItem) const;

	// Retrieves the next sibling item after the specified item.
	HTREEITEM GetNextSiblingItem(_In_ HTREEITEM hItem) const;

	// Retrieves the previous sibling item of the specified item.
	HTREEITEM GetPrevSiblingItem(_In_ HTREEITEM hItem) const;

	// Retrieves the parent of the specified item.
	HTREEITEM GetParentItem(_In_ HTREEITEM hItem) const;

	// Retrieves the topmost visible item in the control.
	HTREEITEM GetFirstVisibleItem() const;

	// Retrieves the next visible item after the specified item.
	HTREEITEM GetNextVisibleItem(_In_ HTREEITEM hItem) const;

	// Retrieves the previous visible item before the specified item.
	HTREEITEM GetPrevVisibleItem(_In_ HTREEITEM hItem) const;

	// Retrieves the last expanded item in the tree. This does not retrieve the last item visible in the tree-view window.
	HTREEITEM GetLastVisibleItem() const;

	// Retrieves the higlighted item, NULL if none.
	HTREEITEM GetSelectedItem() const;

	// Retrieves the currently drop-highlighted item, NULL if none.
	HTREEITEM GetDropHilightItem() const;

	// Retrieves the root item of the control, NULL if none.
	HTREEITEM GetRootItem() const;

	// Retrieves information about a particular item in the control.
	BOOL GetItem(_Out_ TVITEM* pItem) const;

	// Retrieves the text associated with the given item.
	CString GetItemText(_In_ HTREEITEM hItem) const;

	// Retrieves the images associated with the given item.
	BOOL GetItemImage(_In_ HTREEITEM hItem, _Out_ int& nImage,
		_Out_ int& nSelectedImage) const;

	// Retrieves the state of the given item.
	UINT GetItemState(_In_ HTREEITEM hItem, _In_ UINT nStateMask) const;

	// Retrieves the user-supplied data associated with the given item.
	DWORD_PTR GetItemData(_In_ HTREEITEM hItem) const;

	// Sets the state of the an item.
	BOOL SetItem(_In_ TVITEM* pItem);
	BOOL SetItem(_In_ HTREEITEM hItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam);

#if (_WIN32_IE >= 0x0600)
	BOOL SetItemEx(_In_ HTREEITEM hItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam,
		_In_ UINT uStateEx, _In_opt_ HWND hWnd, _In_ int iExpandedImage);
#endif

	// Sets the text of the specified item.
	BOOL SetItemText(_In_ HTREEITEM hItem, _In_z_ LPCTSTR lpszItem);

	// Sets the image on the specified item.
	BOOL SetItemImage(_In_ HTREEITEM hItem, _In_ int nImage, _In_ int nSelectedImage);

	// Sets the state of the specified item.
	BOOL SetItemState(_In_ HTREEITEM hItem, _In_ UINT nState, _In_ UINT nStateMask);

	// Sets the user data on the specified item.
	BOOL SetItemData(_In_ HTREEITEM hItem, _In_ DWORD_PTR dwData);

	// Determines if the specified item has children.
	BOOL ItemHasChildren(_In_ HTREEITEM hItem) const;

	// Retrieves the edit control used to perform in-place editing.
	CEdit* GetEditControl() const;

	// Gets the count of items presently visible in the control.
	UINT GetVisibleCount() const;

	// Retrieves the tool tip control associated with this control.
	CToolTipCtrl* GetToolTips() const;

	// Sets the tool tip control to be used by this control.
	CToolTipCtrl* SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Retrieves the background colour used throughout the control.
	COLORREF GetBkColor() const;

	// Sets the background color to be used throughout the control.
	COLORREF SetBkColor(_In_ COLORREF clr);

	// Retrieves the height of items in the control.
	SHORT GetItemHeight() const;

	// Sets the height of items in the control.
	SHORT SetItemHeight(_In_ SHORT cyHeight);

	// Retrieves the text color used for all items in the control.
	COLORREF GetTextColor() const;

	// Sets the text color used for all items in the control.
	COLORREF SetTextColor(_In_ COLORREF clr);

	// Sets the insertion mark to the specified item in the control.
	BOOL SetInsertMark(_In_ HTREEITEM hItem, _In_ BOOL fAfter = TRUE);

	// Gets the checked state of the specified item in the control.
	// (Only useful on a control with the TVS_CHECKBOXES style.)
	BOOL GetCheck(_In_ HTREEITEM hItem) const;

	// Sets the checked state of the specified item in the control.
	// (Only useful on a control with the TVS_CHECKBOXES style.)
	BOOL SetCheck(_In_ HTREEITEM hItem, _In_ BOOL fCheck = TRUE);

	COLORREF GetInsertMarkColor() const;
	COLORREF SetInsertMarkColor(_In_ COLORREF clrNew);

	// Sets the maximum time (in milliseconds) the control will
	// spend smooth scrolling its content.
	UINT SetScrollTime(_In_ UINT uScrollTime);

	// Retrieves the maximum time (in milliseconds) the control will
	// spend smooth scrolling its content.
	UINT GetScrollTime() const;

#if _WIN32_IE >= 0x0500
	COLORREF GetLineColor() const;
	COLORREF SetLineColor(_In_ COLORREF clrNew = CLR_DEFAULT);
#endif

#if (_WIN32_IE >= 0x0600)
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Maps treeview item id to accessibility identifier.
	UINT MapItemToAccId(HTREEITEM hItem) const;

	// Maps accessibility identifier id to treeview item.
	HTREEITEM MapAccIdToItem(UINT uAccId) const;

	// Set autoscrolling rate and delay (?).
	BOOL SetAutoscrollInfo(UINT uPixelsPerSec, UINT uUpdateTime);
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// Get count of selected items in the tree control.
	UINT GetSelectedCount();

	// Get rectangle for the specified part of the specified item.
	BOOL GetItemPartRect(HTREEITEM hItem, TVITEMPART nPart, LPRECT lpRect);

	// Get the extended state of the item
	UINT GetItemStateEx(HTREEITEM hItem) const;
	
	// Set the extended state of the item
	BOOL SetItemStateEx(HTREEITEM hItem, UINT uStateEx);

	// Get the expanded image index for the specified item
	int GetItemExpandedImageIndex(HTREEITEM hItem) const;
	
	// Set the expanded image index for the specified item
	BOOL SetItemExpandedImageIndex(HTREEITEM hItem, int nIndex);

	// Get extended styles for the tree control.
	DWORD GetExtendedStyle() const;

	// Set extended styles on the tree control.
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles);
#endif

// Operations

	// Inserts a new item to the control.
	HTREEITEM InsertItem(_In_ LPTVINSERTSTRUCT lpInsertStruct);
	HTREEITEM InsertItem(_In_ UINT nMask, _In_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam,
		_In_ HTREEITEM hParent, _In_ HTREEITEM hInsertAfter);
	HTREEITEM InsertItem(_In_z_ LPCTSTR lpszItem, _In_ HTREEITEM hParent = TVI_ROOT,
		_In_ HTREEITEM hInsertAfter = TVI_LAST);
	HTREEITEM InsertItem(_In_z_ LPCTSTR lpszItem, _In_ int nImage, _In_ int nSelectedImage,
		_In_ HTREEITEM hParent = TVI_ROOT, _In_ HTREEITEM hInsertAfter = TVI_LAST);

	// Removes the specified item from the control.
	BOOL DeleteItem(_In_ HTREEITEM hItem);

	// Removes all items from the control.
	BOOL DeleteAllItems();

	// Expands the children of the specified item.
	BOOL Expand(_In_ HTREEITEM hItem, _In_ UINT nCode);

	// Selects the specified item.
	BOOL Select(_In_ HTREEITEM hItem, _In_ UINT nCode);

	// Selects the specified item.
	BOOL SelectItem(_In_opt_ HTREEITEM hItem);

	// Selects an item to be the drop target in the control.
	BOOL SelectDropTarget(_In_ HTREEITEM hItem);

	// Draws the specified item as the drop target for the control.
	BOOL SelectSetFirstVisible(_In_ HTREEITEM hItem);

	// Begins editing the label of the specified item.
	CEdit* EditLabel(_In_ HTREEITEM hItem);

	// Determines the visual feature of the control under
	// the specified point.
	HTREEITEM HitTest(_In_ CPoint pt, _In_ UINT* pFlags = NULL) const;
	HTREEITEM HitTest(_In_ TVHITTESTINFO* pHitTestInfo) const;

	// Create a drag image for the specified item.
	CImageList* CreateDragImage(_In_ HTREEITEM hItem);

	// Sorts all children of the specified item.
	BOOL SortChildren(_In_ HTREEITEM hItem);

	// Scrolls the control to ensure the specified item is visible.
	BOOL EnsureVisible(_In_ HTREEITEM hItem);

	// Sorts items in the control using the provided callback function.
	BOOL SortChildrenCB(_In_ LPTVSORTCB pSort);

	// Terminates label editing operation.
	BOOL EndEditLabelNow(BOOL fCancelWithoutSave);

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// Shows information tooltip on the specified item.
	void ShowInfoTip(HTREEITEM hItem);
#endif

// Implementation
protected:
	void RemoveImageList(_In_ int nImageList);

public:
	// virtual OK here - ~CWnd is virtual
	virtual ~CTreeCtrl();
	//{{AFX_MSG(CTreeCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSpinButtonCtrl

class CSpinButtonCtrl : public CWnd
{
	DECLARE_DYNAMIC(CSpinButtonCtrl)

// Constructors
public:
	CSpinButtonCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets acceleration information for the up-down control.
	BOOL SetAccel(_In_ int nAccel, _In_ UDACCEL* pAccel);

	// Retrieves acceleration information for the up-down control.
	UINT GetAccel(_In_ int nAccel, _Out_ UDACCEL* pAccel) const;

	// Sets the radix base for the up-down control.
	int SetBase(_In_ int nBase);

	// Retrieves the current radix base for the up-down control.
	UINT GetBase() const;

	// Sets the up-down control's buddy window.
	CWnd* SetBuddy(_In_ CWnd* pWndBuddy);

	// Retrieves the up-down control's current buddy window.
	CWnd* GetBuddy() const;

	// Sets the current position of an up-down control with 16-bit precision.
	int SetPos(_In_ int nPos);

	// Retrieves the current position of an up-down control with 16-bit precision.
	int GetPos() const;

	// Sets the minimum and maximum positions (range) for the up-down control.
	void SetRange(_In_ short nLower, _In_ short nUpper);
	void SetRange32(_In_ int nLower, _In_ int nUpper);

	// Retrieves the minimum and maximum positions (range) for the up-down control.
	DWORD GetRange() const;
	void GetRange(_Out_ int &lower, _Out_ int& upper) const;
	void GetRange32(_Out_ int &lower, _Out_ int& upper) const;

#if _WIN32_IE >= 0x0500
	// Retrieves the current position of the up-down control with 32-bit precision.
	int GetPos32(_Out_ LPBOOL lpbError = NULL) const;

	// Sets the current position of an up-down control with 32-bit precision.
	int SetPos32(_In_ int nPos);
#endif

// Implementation
public:
	virtual ~CSpinButtonCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CSliderCtrl

class CSliderCtrl : public CWnd
{
	DECLARE_DYNAMIC(CSliderCtrl)

// Constructors
public:
	CSliderCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the up/down arrow keys.
	int GetLineSize() const;

	// Sets the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the up/down arrow keys.
	int SetLineSize(_In_ int nSize);

	// Retrieves the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the PgUp/PgDn keys.
	int GetPageSize() const;

	// Sets the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the PgUp/PgDn keys.
	int SetPageSize(_In_ int nSize);

	// Retrieves the maximum position for the slider in the trackbar control.
	int GetRangeMax() const;

	// Retrieves the minimum position for the slider in the trackbar control.
	int GetRangeMin() const;

	// Retrieves the minimum and maximum positions for the slider in the trackbar control.
	void GetRange(_Out_ int& nMin, _Out_ int& nMax) const;

	// Sets the minimum position for the slider in the trackbar control.
	void SetRangeMin(_In_ int nMin, _In_ BOOL bRedraw = FALSE);

	// Sets the maximum position for the slider in the trackbar control.
	void SetRangeMax(_In_ int nMax, _In_ BOOL bRedraw = FALSE);

	// Sets the minimum and maximum positions for the slider in the trackbar control.
	void SetRange(_In_ int nMin, _In_ int nMax, _In_ BOOL bRedraw = FALSE);

	// Retrieves the starting and ending positions of the selection in the trackbar control.
	void GetSelection(_Out_ int& nMin, _Out_ int& nMax) const;

	// Sets the starting and ending positions of the selection in the trackbar control.
	void SetSelection(_In_ int nMin, _In_ int nMax);

	// Retrieves the bounding rectangle for the trackbar control's channel.
	void GetChannelRect(_Out_ LPRECT lprc) const;

	// Retrieves the bounding rectangle for the slider in the trackbar control.
	void GetThumbRect(_Out_ LPRECT lprc) const;

	// Retrieves the current logical position of the slider in the trackbar control.
	int GetPos() const;

	// Sets the current logical position of the slider in the trackbar control.
	void SetPos(_In_ int nPos);

	// Retrieves the number of tick marks in a trackbar control.
	UINT GetNumTics() const;

	// Retrieves an array of positions of tick marks in the trackbar control.
	DWORD* GetTicArray() const;

	// Retrieves the logical position of the specified tick mark in the trackbar control.
	int GetTic(_In_ int nTic) const;

	// Retrieves the current physical position of the specified tick mark in the trackbar control.
	int GetTicPos(_In_ int nTic) const;

	// Sets a tick mark in the trackbar control at the specified logical position.
	BOOL SetTic(_In_ int nTic);

	// Sets the interval frequency for tick marks in the trackbar control.
	void SetTicFreq(_In_ int nFreq);

	// Retrieves the trackbar control buddy window at the specified location.
	CWnd* GetBuddy(_In_ BOOL fLocation = TRUE) const;

	// Assigns the specified window as the buddy window for the trackbar control.
	CWnd* SetBuddy(_In_ CWnd* pWndBuddy, _In_ BOOL fLocation = TRUE);

	// Retrieves the ToolTip control assigned to the trackbar control.
	CToolTipCtrl* GetToolTips() const;

	// Assigns a ToolTip control to the trackbar control.
	void SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Positions the ToolTip control used by the trackbar control.
	int SetTipSide(_In_ int nLocation);

	// Sets the length of the slider in the trackbar control.
	void SetThumbLength(_In_ int nLength);

	// Retrieves the length of the slider in the trackbar control.
	int GetThumbLength() const;

// Operations
	// Clears the current selection range in the trackbar control.
	void ClearSel(_In_ BOOL bRedraw = FALSE);

	// Removes the current tick marks from the trackbar control.
	void ClearTics(_In_ BOOL bRedraw = FALSE);

// Implementation
public:
	virtual ~CSliderCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrl

class CProgressCtrl : public CWnd
{
	DECLARE_DYNAMIC(CProgressCtrl)

// Constructors
public:
	CProgressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Sets range of values for the control. (16-bit limit)
	void SetRange(_In_ short nLower, _In_ short nUpper);

	// Sets range of values for the control. (32-bit limit)
	void SetRange32(_In_ int nLower, _In_ int nUpper);

	// Retrieves range of values for the control. (32-bit limit)
	void GetRange(_Out_ int& nLower, _Out_ int& nUpper) const;

	// Gets the current position within the set range of the control.
	int GetPos() const;

	// Sets the current position within the set range of the control.
	int SetPos(_In_ int nPos);

	// Displaces the current position within the set range of the
	// control by the passed value.
	int OffsetPos(_In_ int nPos);

	// Sets the step by which increments happen with a call to StepIt().
	int SetStep(_In_ int nStep);

	// Sets the control's background color.
	COLORREF SetBkColor(_In_ COLORREF clrNew);

#if (_WIN32_IE >= 0x0400)
	// Sets the color of the progress indicator bar in the progress bar control.
	COLORREF SetBarColor(_In_ COLORREF clrBar);
#endif	// _WIN32_IE >= 0x0400

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Sets the progress bar control to marquee mode.
	BOOL SetMarquee(_In_ BOOL fMarqueeMode, _In_ int nInterval);
#endif	// _WIN32_WINNT >= 0x0501 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the step increment for the progress bar control.
	int GetStep() const;

	// REVIEW: Retrieves the background color of the progress bar control.
	COLORREF GetBkColor() const;

	// REVIEW: Retrieves the color of the progress bar control.
	COLORREF GetBarColor() const;

	// REVIEW: Sets the state of the progress bar.
	int SetState(_In_ int iState);

	// REVIEW: Retrieves the state of the progress bar.
	int GetState() const;
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Operations

	// Steps the control by the value set with SetStep().
	int StepIt();

// Implementation
public:
	virtual ~CProgressCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CComboBoxEx

class CComboBoxEx : public CComboBox
{
	DECLARE_DYNAMIC(CComboBoxEx)

// Constructors
public:
	CComboBoxEx();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Operations
	using CComboBox::DeleteItem;
	int DeleteItem(_In_ int iIndex);
	BOOL GetItem(_Out_ COMBOBOXEXITEM* pCBItem);
	int InsertItem(_In_ const COMBOBOXEXITEM* pCBItem);
	BOOL SetItem(_In_ const COMBOBOXEXITEM* pCBItem);

// Attributes
	BOOL HasEditChanged();
	DWORD GetExtendedStyle() const;
	DWORD SetExtendedStyle(_In_ DWORD dwExMask, _In_ DWORD dwExStyles);
	CEdit* GetEditCtrl() const;
	CComboBox* GetComboBoxCtrl() const;
	CImageList* GetImageList() const;
	CImageList* SetImageList(_In_ CImageList* pImageList);

#if (_WIN32_WINNT >= 0x0501)
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

	// These functions are supported by the Windows ComboBox control,
	// but not supported by the Windows ComboBoxEx control.

	int Dir(_In_ UINT attr, _In_z_ LPCTSTR lpszWildCard);
	int FindString(_In_ int nIndexStart, _In_z_ LPCTSTR lpszFind) const;
	int AddString(_In_z_ LPCTSTR lpszString);
	BOOL SetEditSel(_In_ int nStartChar, _In_ int nEndChar);
	int InsertString(_In_ int nIndex, _In_z_ LPCTSTR lpszString);

// Implementation
public:
	virtual ~CComboBoxEx();
};

/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

class CHeaderCtrl : public CWnd
{
	DECLARE_DYNAMIC(CHeaderCtrl)

// Constructors
public:
	CHeaderCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves a count of the items in the header control.
	int GetItemCount() const;

	// Retrieves information about an item in the header control.
	BOOL GetItem(_In_ int nPos, _Out_ HDITEM* pHeaderItem) const;

	// Sets the attributes of the specified item in the header control.
	BOOL SetItem(_In_ int nPos, _In_ HDITEM* pHeaderItem);

	// Retrieves the image list assigned to the header control.
	CImageList* GetImageList(_In_ int nImageList = HDSIL_NORMAL) const;

	// Assigns an image list to the header control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList = HDSIL_NORMAL);

	// Retrieves the bounding rectangle for the specified item in the header control.
	BOOL GetItemRect(_In_ int nIndex, _Out_ LPRECT lpRect) const;

	// Retrieves the current left-to-right order of items in the header control.
	BOOL GetOrderArray(_In_ LPINT piArray, _In_ int iCount) const;

	// Sets the left-to-right order of items in the header control.
	BOOL SetOrderArray(_In_ int iCount, _In_ LPINT piArray);

	// Retrieves an index value for an item based on its order in the header control.
	int OrderToIndex(_In_ int nOrder) const;

	// Determines which header item, if any, is at the specified point.
	int HitTest(_Inout_ LPHDHITTESTINFO pHeaderHitTestInfo);

#if _WIN32_IE >= 0x0500
	// Retrieves the width of the bitmap margin for the header control.
	int GetBitmapMargin() const;

	// Sets the width of the bitmap margin for the header control.
	int SetBitmapMargin(_In_ int nWidth);
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW:
	BOOL GetItemDropDownRect(_In_ int iItem, _Out_ LPRECT lpRect) const;

	// REVIEW: 
	BOOL GetOverflowRect(_Out_ LPRECT lpRect) const;

	// REVIEW: Gets the item in the header control that has the focus.
	int GetFocusedItem() const;

	// Sets the focus to the specified item in the header control.
	BOOL SetFocusedItem(_In_ int iItem);
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

// Operations
	// Inserts a new item into the header control.
	int InsertItem(_In_ int nPos, _In_ HDITEM* phdi);

	// Deletes an item from a header control.
	BOOL DeleteItem(_In_ int nPos);

	// Retrieves the correct size and position of the header control within the parent window.
	BOOL Layout(_In_ HDLAYOUT* pHeaderLayout);

	// Creates a semi-transparent version of an item's image for use as a dragging image.
	CImageList* CreateDragImage(_In_ int nIndex);

	// Changes the color of a divider between header items to indicate
	// the destination of an external drag-and-drop operation.
	int SetHotDivider(_In_ CPoint pt);
	int SetHotDivider(_In_ int nIndex);

#if _WIN32_IE >= 0x0500
	// Sets the timeout interval between the time a change takes place in the
	// filter attributes and the posting of an HDN_FILTERCHANGE notification.
	int SetFilterChangeTimeout(_In_ DWORD dwTimeOut);

	// Starts editing the filter for the specified column.
	int EditFilter(_In_ int nColumn, _In_ BOOL bDiscardChanges);

	// Clears the filter for the specified column in the header control.
	BOOL ClearFilter(_In_ int nColumn);

	// Clears all filters for all columns in the header control.
	BOOL ClearAllFilters();
#endif

// Overridables
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CHeaderCtrl();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

};

/////////////////////////////////////////////////////////////////////////////
// CHotKeyCtrl

class CHotKeyCtrl : public CWnd
{
	DECLARE_DYNAMIC(CHotKeyCtrl)

// Constructors
public:
	CHotKeyCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets the hot key combination for the hot key control.
	void SetHotKey(_In_ WORD wVirtualKeyCode, _In_ WORD wModifiers);

	// Retrieves the virtual key code and modifier flags of the hot key from the hot key control.
	DWORD GetHotKey() const;

	// Retrieves the virtual key code and modifier flags of the hot key from the hot key control.
	void GetHotKey(_Out_ WORD &wVirtualKeyCode, _In_ WORD &wModifiers) const;

	// Retrieves a string representation of the hot key code and flags.
	CString GetHotKeyName() const;

// Operations
	// Defines the invalid combinations and the default modifier combination for the hot key control.
	void SetRules(_In_ WORD wInvalidComb, _In_ WORD wModifiers);

	// Retrieves a string representation of the virtual key.
	static CString GetKeyName(_In_ UINT vk, _In_ BOOL fExtended);

// Implementation
public:
	virtual ~CHotKeyCtrl();

};

/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl

class CToolTipCtrl : public CWnd
{
	DECLARE_DYNAMIC(CToolTipCtrl)

// Constructors
public:
	CToolTipCtrl();

	// Generic creator
	virtual BOOL Create(_In_ CWnd* pParentWnd, _In_ DWORD dwStyle = 0);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ CWnd* pParentWnd, _In_ DWORD dwStyle = 0, _In_ DWORD dwStyleEx = 0);

// Attributes
	// Retrieves the text for a tool in the ToolTip control .
	void GetText(_Out_ CString& str, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0) const;

	// Retrieves the information that the ToolTip control maintains about a tool.
	BOOL GetToolInfo(_Out_ CToolInfo& ToolInfo, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0) const;

	// Sets the information that the ToolTip control maintains about a tool.
	void SetToolInfo(_In_ LPTOOLINFO lpToolInfo);

	// Sets a new bounding rectangle for a tool.
	void SetToolRect(_In_ CWnd* pWnd, _In_ UINT_PTR nIDTool, _In_ LPCRECT lpRect);

	// Retrieves a count of the tools maintained by the ToolTip control.
	int GetToolCount() const;

	// Retrieves the initial, pop-up, or reshow duration currently set for the ToolTip control.
	int GetDelayTime(_In_ DWORD dwDuration) const;

	// Sets the initial, pop-up, or reshow duration for the ToolTip control.
	void SetDelayTime(_In_ DWORD dwDuration, _In_ int iTime);

	// Retrieves the top, left, bottom, and right margins set for the ToolTip window.
	void GetMargin(_Out_ LPRECT lprc) const;

	// Sets the top, left, bottom, and right margins for the ToolTip window.
	void SetMargin(_In_ LPRECT lprc);

	// Retrieves the maximum width for the ToolTip window.
	int GetMaxTipWidth() const;

	// Sets the maximum width for the ToolTip window.
	int SetMaxTipWidth(_In_ int iWidth);

	// Retrieves the background color in the ToolTip window.
	COLORREF GetTipBkColor() const;

	// Sets the background color in the ToolTip window.
	void SetTipBkColor(_In_ COLORREF clr);

	// Retrieves the text color in the ToolTip window.
	COLORREF GetTipTextColor() const;

	// Sets the text color in the ToolTip window.
	void SetTipTextColor(_In_ COLORREF clr);

	// Retrieves the information for the current tool in the ToolTip control.
	BOOL GetCurrentTool(_Out_ LPTOOLINFO lpToolInfo) const;

#if _WIN32_IE >= 0x0500
	// Returns the width and height of the ToolTip control.
	CSize GetBubbleSize(_In_ LPTOOLINFO lpToolInfo) const;
#endif

#if (_WIN32_WINNT >= 0x0501)
	// Sets the visual style of the ToolTip control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

// Operations
	// Activates or deactivates the ToolTip control.
	void Activate(_In_ BOOL bActivate);

	// Registers a tool with the ToolTip control.
	BOOL AddTool(_In_ CWnd* pWnd, _In_ UINT nIDText, _In_opt_ LPCRECT lpRectTool = NULL,
		_In_ UINT_PTR nIDTool = 0);
	BOOL AddTool(_In_ CWnd* pWnd, _In_z_ LPCTSTR lpszText = LPSTR_TEXTCALLBACK,
		_In_opt_ LPCRECT lpRectTool = NULL, _In_ UINT_PTR nIDTool = 0);

	// Removes a tool from the ToolTip control.
	void DelTool(_In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);

	// Tests a point to determine whether it is within the bounding rectangle of
	// the specified tool and, if it is, retrieves information about the tool.
	BOOL HitTest(_In_ CWnd* pWnd, _In_ CPoint pt, _In_ LPTOOLINFO lpToolInfo) const;

	// Passes a mouse message to the ToolTip control for processing.
	void RelayEvent(_In_ LPMSG lpMsg);

	void SetDelayTime(_In_ UINT nDelay);

	// Sets the ToolTip text for a tool.
	void UpdateTipText(_In_z_ LPCTSTR lpszText, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);
	void UpdateTipText(_In_ UINT nIDText, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);

	// Forces the current tool to be redrawn.
	void Update();

	// Removes the displayed ToolTip window from view.
	void Pop();

#if _WIN32_IE >= 0x0500
	// Calculates a ToolTip control's text display rectangle
	// from its window rectangle, or the ToolTip window rectangle
	// needed to display a specified text display rectangle.
	BOOL AdjustRect(_Out_ LPRECT lprc, _In_ BOOL bLarger = TRUE);

	// Adds a standard icon and title string to the ToolTip.
	BOOL SetTitle(_In_ UINT uIcon, _In_z_ LPCTSTR lpstrTitle);
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Causes the ToolTip to display at the coordinates of the last mouse message.
	void Popup();

	// Retrieves information concerning the title of a tooltip control.
	void GetTitle(_Out_ PTTGETTITLE pTTGetTitle) const;
#endif

// Implementation
public:
	void FillInToolInfo(_Out_ TOOLINFO& ti, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool) const;
	virtual ~CToolTipCtrl();
#ifndef _AFXDLL
	virtual BOOL DestroyToolTipCtrl();
#else
	BOOL DestroyToolTipCtrl();
#endif

protected:
	//{{AFX_MSG(CToolTipCtrl)
	afx_msg LRESULT OnDisableModal(WPARAM, LPARAM);
	afx_msg LRESULT OnWindowFromPoint(WPARAM, LPARAM);
	afx_msg LRESULT OnAddTool(WPARAM, LPARAM);
	afx_msg void OnEnable(BOOL bEnable);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMapStringToPtr m_mapString;

	friend class CWnd;
	friend class CToolBar;
};

/////////////////////////////////////////////////////////////////////////////
// CTabCtrl

class CTabCtrl : public CWnd
{
	DECLARE_DYNAMIC(CTabCtrl)

// Constructors
public:
	CTabCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the image list associated with the tab control.
	CImageList* GetImageList() const;

	// Assigns an image list to the tab control.
	CImageList* SetImageList(_In_ CImageList* pImageList);

	// Retrieves the number of tabs in the tab control.
	int GetItemCount() const;

	// Retrieves information about the specified tab in the tab control.
	BOOL GetItem(_In_ int nItem, _Out_ TCITEM* pTabCtrlItem) const;

	// Sets some or all attributes of the specified tab in the tab control.
	BOOL SetItem(_In_ int nItem, _In_ TCITEM* pTabCtrlItem);

	// Sets the number of bytes per tab reserved for application-defined data in the tab control.
	BOOL SetItemExtra(_In_ int nBytes);

	// Retrieves the bounding rectangle for the specified tab in the tab control.
	BOOL GetItemRect(_In_ int nItem, _Out_ LPRECT lpRect) const;

	// Determines the currently selected tab in the tab control.
	int GetCurSel() const;

	// Selects the specified tab in the tab control.
	int SetCurSel(_In_ int nItem);

	// Sets the focus to the specified tab in the tab control.
	void SetCurFocus(_In_ int nItem);

	// Sets the width and height of tabs in a fixed-width or owner-drawn tab control.
	CSize SetItemSize(_In_ CSize size);

	// Sets the amount of space (padding) around each tab's icon and label in the tab control.
	void SetPadding(_In_ CSize size);

	// Retrieves the current number of rows of tabs in the tab control.
	int GetRowCount() const;

	// Retrieves the ToolTip control associated with the tab control.
	CToolTipCtrl* GetToolTips() const;

	// Assigns a ToolTip control to the tab control.
	void SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Returns the index of the tab that has the focus in a tab control.
	int GetCurFocus() const;

	// Sets the minimum width of tabs in the tab control.
	int SetMinTabWidth(_In_ int cx);

	// Retrieves the extended styles that are currently in use for the tab control.
	DWORD GetExtendedStyle() const;

	// Sets the extended styles that the tab control will use.
	DWORD SetExtendedStyle(_In_ DWORD dwNewStyle, _In_ DWORD dwExMask = 0);

	// Retrieves state of a tab in the tab control.
	DWORD GetItemState(_In_ int nItem, _In_ DWORD dwMask) const;

	// Sets state for a tab in the tab control.
	BOOL SetItemState(_In_ int nItem, _In_ DWORD dwMask, _In_ DWORD dwState);

// Operations
	// Inserts a new tab in the tab control.
	LONG InsertItem(_In_ int nItem, _In_ TCITEM* pTabCtrlItem);
	LONG InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem);
	LONG InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ int nImage);
	LONG InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ LPARAM lParam);
	LONG InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ LPARAM lParam, _In_ DWORD dwState, _In_ DWORD dwStateMask);

	// Removes a tab from the tab control.
	BOOL DeleteItem(_In_ int nItem);

	// Removes all tabs from the tab control.
	BOOL DeleteAllItems();

	// Calculates the tab control's display area given a window rectangle.
	void AdjustRect(_In_ BOOL bLarger, _Inout_ LPRECT lpRect);

	// Removes an image from the tab control's image list.
	void RemoveImage(_In_ int nImage);

	// Determines which tab, if any, is at a specified screen position.
	int HitTest(_In_ TCHITTESTINFO* pHitTestInfo) const;

	// Resets tabs in the tab control, clearing any that were in the pressed state.
	void DeselectAll(_In_ BOOL fExcludeFocus);

	// Sets the highlight state of a tab in the tab control.
	BOOL HighlightItem(_In_ int idItem, _In_ BOOL fHighlight = TRUE);

// Overridables
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CTabCtrl();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
	//{{AFX_MSG(CTabCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrl

class CAnimateCtrl : public CWnd
{
	DECLARE_DYNAMIC(CAnimateCtrl)

// Constructors
public:
	CAnimateCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Operations
	// Opens an AVI clip and displays its first frame in the animation control.
	BOOL Open(_In_z_ LPCTSTR lpszFileName);
	BOOL Open(_In_ UINT nID);

	// Plays the AVI clip opened in the animation control.
	BOOL Play(_In_ UINT nFrom, _In_ UINT nTo, _In_ UINT nRep);

	// Stops playing the AVI clip opened in the animation control.
	BOOL Stop();

	// Closes the AVI clip opened in the animation control.
	BOOL Close();

	// Displays the specified frame of the AVI clip opened in the animation control.
	BOOL Seek(_In_ UINT nTo);

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW: Determines whether the animation control is playing a clip.
	BOOL IsPlaying() const;
#endif

// Implementation
public:
	virtual ~CAnimateCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrl

struct IDropTarget; // forward declaration

// NOTE: This class must remain a binary-compatible subset
// of CToolBar. Do not add data members or virtual functions
// directly to this class.
class CToolBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC OK here - CWnd already has virtual from DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CToolBarCtrl)

// Construction
public:
	CToolBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
public:
	// Determines whether the specified button in the toolbar is enabled.
	BOOL IsButtonEnabled(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is checked.
	BOOL IsButtonChecked(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is pressed.
	BOOL IsButtonPressed(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is hidden.
	BOOL IsButtonHidden(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is indeterminate.
	BOOL IsButtonIndeterminate(_In_ int nID) const;

	// Sets the state for the specified button in the toolbar.
	BOOL SetState(_In_ int nID, _In_ UINT nState);

	// Retrieves the state of the specified button in the toolbar.
	int GetState(_In_ int nID) const;

	// Retrieves information about the specified button in the toolbar.
	BOOL GetButton(_In_ int nIndex, _Out_ LPTBBUTTON lpButton) const;

	// Retrieves a count of the buttons currently in the toolbar control.
	int GetButtonCount() const;

	// Retrieves the bounding rectangle of the specified button in the toolbar (by index).
	BOOL GetItemRect(_In_ int nIndex, _Out_ LPRECT lpRect) const;

	// Retrieves the bounding rectangle for the specified button in the toolbar (by command).
	BOOL GetRect(_In_ int nID, _Out_ LPRECT lpRect) const;

	// Specifies the size of the TBBUTTON structure to the toolbar control.
	void SetButtonStructSize(_In_ int nSize);

	// Retrieves the current width and height of toolbar buttons, in pixels.
	DWORD GetButtonSize() const;

	// Sets the size of the buttons to be added to the toolbar.
	BOOL SetButtonSize(_In_ CSize size);

	// Sets the size of the bitmapped images to be added to the toolbar.
	BOOL SetBitmapSize(_In_ CSize size);

	// Retrieves the ToolTip control associated with the toolbar.
	CToolTipCtrl* GetToolTips() const;

	// Associates a ToolTip control with the toolbar.
	void SetToolTips(_In_ CToolTipCtrl* pTip);

	// Sets the window to which the toolbar control sends notification messages.
	void SetOwner(_In_ CWnd* pWnd);

	// Sets the number of rows of buttons in the toolbar.
	void SetRows(_In_ int nRows, _In_ BOOL bLarger, _In_ LPRECT lpRect);

	// Retrieves the number of rows of buttons in the toolbar.
	int GetRows() const;

	// Sets the command identifier of the specified toolbar button.
	BOOL SetCmdID(_In_ int nIndex, _In_ UINT nID);

	// Retrieves the flags that describe the type of bitmap to be used.
	UINT GetBitmapFlags() const;

	// Retrieves the index of the bitmap associated with the specified button in the toolbar.
	int GetBitmap(_In_ int nID) const;

	// Replaces one bitmap in the toolbar control with another bitmap.
	BOOL ReplaceBitmap(_In_ LPTBREPLACEBITMAP pReplaceBitmap);

	// Changes the bitmap for the specified button in the toolbar control.
	BOOL ChangeBitmap(_In_ int idButton, _In_ int iBitmap);

	// Retrieves the image list that the toolbar control uses to display inactive buttons.
	CImageList* GetDisabledImageList() const;

	// Retrieves the image list that the toolbar control uses to display hot buttons.
	CImageList* GetHotImageList() const;

	// Retrieves the image list that the toolbar control uses to display buttons in their default state
	CImageList* GetImageList() const;

	// Retrieves the styles currently in use for the toolbar control.
	DWORD GetStyle() const;

	// Retrieves the maximum number of text rows that can be displayed on a toolbar button.
	int GetMaxTextRows() const;

	// Determines whether the specified button in the toolbar is highlighted.
	BOOL IsButtonHighlighted(_In_ int nID) const;

	// Sets the minimum and maximum button widths in the toolbar control.
	BOOL SetButtonWidth(_In_ int cxMin, _In_ int cxMax);

	// Sets the image list that the toolbar control will use to display disabled buttons.
	CImageList* SetDisabledImageList(_In_ CImageList* pImageList);

	// Sets the image list that the toolbar control will use to display hot buttons.
	CImageList* SetHotImageList(_In_ CImageList* pImageList);

	// Sets the image list that the toolbar control will use to display buttons in their default state.
	CImageList* SetImageList(_In_ CImageList* pImageList);

	// Retrieves the IDropTarget for the toolbar control.
	HRESULT GetDropTarget(_Out_ IDropTarget** ppDropTarget) const;

	// Sets the indentation for the first button in the toolbar control.
	BOOL SetIndent(_In_ int iIndent);

	// Sets the maximum number of text rows that can be displayed on a toolbar button.
	BOOL SetMaxTextRows(_In_ int iMaxRows);

	// Sets the styles for the toolbar control.
	void SetStyle(_In_ DWORD dwStyle);

	// Retrieves extended information for the specified button in the toolbar.
	BOOL GetButtonInfo(_In_ int nID, _Out_ TBBUTTONINFO* ptbbi) const;

	// Sets the information for the specified button in the toolbar.
	BOOL SetButtonInfo(_In_ int nID, _In_ TBBUTTONINFO* ptbbi);

	// Sets the text drawing flags for the toolbar.
	DWORD SetDrawTextFlags(_In_ DWORD dwMask, _In_ DWORD dwDTFlags);

	// Retrieves the anchor highlight setting for the toolbar.
	BOOL GetAnchorHighlight() const;

	// Sets the anchor highlight setting for the toolbar.
	BOOL SetAnchorHighlight(_In_ BOOL fAnchor = TRUE);

	// Retrieves the index of the hot item in the toolbar.
	int GetHotItem() const;

	// Sets the index of the hot item in the toolbar.
	int SetHotItem(_In_ int nHot);

	// Retrieves the current insertion mark for the toolbar.
	void GetInsertMark(_Out_ TBINSERTMARK* ptbim) const;

	// Sets the current insertion mark for the toolbar.
	void SetInsertMark(_In_ TBINSERTMARK* ptbim);

	// Retrieves the total size of all of the visible buttons and separators in the toolbar.
	BOOL GetMaxSize(_Out_ LPSIZE pSize) const;

	// Retrieves the insertion mark information for a point in the toolbar.
	BOOL InsertMarkHitTest(_In_ LPPOINT ppt, _In_ LPTBINSERTMARK ptbim) const;

	// Retrieves the extended styles for the toolbar control.
	DWORD GetExtendedStyle() const;

	// Sets the extended styles for the toolbar control.
	DWORD SetExtendedStyle(_In_ DWORD dwExStyle);

	// Retrieves the padding for the toolbar control.
	void GetPadding(_Out_ int& nHorzPadding, _Out_ int& nVertPadding) const;

	// Sets the padding for the toolbar control.
	DWORD SetPadding(_In_ int nHorzPadding, _In_ int nVertPadding);

	// Retrieves the color used to draw the insertion mark for the toolbar.
	COLORREF GetInsertMarkColor() const;

	// Sets the color used to draw the insertion mark for the toolbar.
	COLORREF SetInsertMarkColor(_In_ COLORREF clrNew);

	// Retrieves the color scheme information from the toolbar control.
	BOOL GetColorScheme(_Out_ COLORSCHEME* lpcs) const;

	// Sets the color scheme information for the toolbar control.
	void SetColorScheme(_In_ const COLORSCHEME* lpcs);

#if (_WIN32_WINNT >= 0x0501)
	// Retrieves the metrics of the toolbar control.
	AFX_ANSI_DEPRECATED void GetMetrics(_Out_ LPTBMETRICS ptbm) const;

	// Sets the metrics of the toolbar control.
	AFX_ANSI_DEPRECATED void SetMetrics(_In_ LPTBMETRICS ptbm);

	// Sets the visual style of the toolbar control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW: Sets the image list that the toolbar control uses to display buttons in a pressed state.
	CImageList* SetPressedImageList(_In_ int iImageID, _In_ CImageList* pImageList);

	// REVIEW: Retrieves the image list that the toolbar control uses to display buttons in a pressed state.
	CImageList* GetPressedImageList() const;
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

// Operations
public:
	// Enables or disables the specified button in the toolbar.
	BOOL EnableButton(_In_ int nID, _In_ BOOL bEnable = TRUE);

	// Checks or unchecks the specified button in the toolbar.
	BOOL CheckButton(_In_ int nID, _In_ BOOL bCheck = TRUE);

	// Presses or releases the specified button in the toolbar.
	BOOL PressButton(_In_ int nID, _In_ BOOL bPress = TRUE);

	// Hides or shows the specified button in the toolbar.
	BOOL HideButton(_In_ int nID, _In_ BOOL bHide = TRUE);

	// Sets or clears the indeterminate state of the specified button in the toolbar.
	BOOL Indeterminate(_In_ int nID, _In_ BOOL bIndeterminate = TRUE);

	// Adds one or more images to the list of button images available for the toolbar control.
	int AddBitmap(_In_ int nNumButtons, _In_ UINT nBitmapID);
	int AddBitmap(_In_ int nNumButtons, _In_ CBitmap* pBitmap);

	// Adds one or more buttons to the toolbar control.
	BOOL AddButtons(_In_ int nNumButtons, _In_ LPTBBUTTON lpButtons);

	// Inserts a button into the toolbar control.
	BOOL InsertButton(_In_ int nIndex, _In_ LPTBBUTTON lpButton);

	// Deletes a button from the toolbar control.
	BOOL DeleteButton(_In_ int nIndex);

	// Retrieves the zero-based index for the button associated with the specified command identifier.
	UINT CommandToIndex(_In_ UINT nID) const;

	// Saves state for the toolbar control.
	void SaveState(_In_ HKEY hKeyRoot, _In_z_ LPCTSTR lpszSubKey,
		_In_z_ LPCTSTR lpszValueName);

	// Restores state for the toolbar control.
	void RestoreState(_In_ HKEY hKeyRoot, _In_z_ LPCTSTR lpszSubKey,
		_In_z_ LPCTSTR lpszValueName);

	// Loads system-defined button images into the toolbar control's image list.
	void LoadImages(_In_ int iBitmapID, _In_ HINSTANCE hinst);

	// Determines the ID of the button that corresponds to the specified accelerator character.
	BOOL MapAccelerator(_In_ TCHAR chAccel, _In_ UINT* pIDBtn);

	// Sets the highlight state of the specified button in the toolbar control.
	BOOL MarkButton(_In_ int nID, _In_ BOOL fHighlight = TRUE);

	// Moves a button from one index to another in the toolbar control.
	BOOL MoveButton(_In_ UINT nOldPos, _In_ UINT nNewPos);

	// Determines where a point lies in the toolbar control..
	int HitTest(_In_ LPPOINT ppt) const;

	// Displays the Customize Toolbar dialog box.
	void Customize();

	// Adds one or more strings to the toolbar control's string pool.
	int AddString(_In_ UINT nStringID);
	int AddStrings(_In_z_ LPCTSTR lpszStrings);

	// Causes the toolbar control to be resized.
	void AutoSize();

#if _WIN32_IE >= 0x0500
	int GetString(_In_ int nString, _Out_z_cap_post_count_(cchMaxLen, return + 1) LPTSTR lpstrString, _In_ size_t cchMaxLen) const;
	int GetString(_In_ int nString, _Out_ CString& str) const;
#endif

// Implementation
public:
	// virtual OK here: ~CWnd() is already virtual
	virtual ~CToolBarCtrl();

protected:
	//{{AFX_MSG(CToolBarCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CReBarCtrl

// NOTE: This class must remain a binary-compatible subset
// of CReBar. Do not add data members or virtual functions
// directly to this class.
class CReBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual is OK here - CWnd already has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CReBarCtrl)

// Construction
public:
	CReBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
public:
	// Retrieves the count of bands currently in the rebar control.
	UINT GetBandCount() const;

	// Retrieves information about the specified band in the rebar control.
	BOOL GetBandInfo(_In_ UINT uBand, _Out_ REBARBANDINFO* prbbi) const;

	// Retrieves the height of the rebar control.
	UINT GetBarHeight() const;

	// Retrieves information about the rebar control and the image list it uses.
	BOOL GetBarInfo(_Out_ REBARINFO* prbi) const;

	// Retrieves the rebar control's default background color.
	COLORREF GetBkColor() const;

	// Retrieves the rebar control's IDropTarget interface pointer.
	IDropTarget* GetDropTarget() const;

	// Retrieves the bounding rectangle for the specified band in the rebar control.
	BOOL GetRect(_In_ UINT uBand, _Out_ LPRECT prc) const;

	// Retrieves the number of rows of bands in the rebar control.
	UINT GetRowCount() const;

	// Retrieves the height of the specified row in the rebar control.
	UINT GetRowHeight(_In_ UINT uRow) const;

	// Retrieves the rebar control's default text color.
	COLORREF GetTextColor() const;

	// Retrieves the ToolTip control associated with the rebar control.
	CToolTipCtrl* GetToolTips() const;

	// Converts the specified band identifier to a band index in the rebar control.
	int IDToIndex(_In_ UINT uBandID) const;

	// Sets characteristics of the specified band in the rebar control.
	BOOL SetBandInfo(_In_ UINT uBand, _In_ REBARBANDINFO* prbbi);

	// Sets the characteristics of the rebar control.
	BOOL SetBarInfo(_In_ REBARINFO* prbi);

	// Sets the rebar control's default background color.
	COLORREF SetBkColor(_In_ COLORREF clr);

	// Sets the rebar control's parent window.
	CWnd* SetOwner(_In_ CWnd* pWnd);

	// Sets the rebar control's default text color.
	COLORREF SetTextColor(_In_ COLORREF clr);

	// Associates the ToolTip control with the rebar control.
	void SetToolTips(_In_ CToolTipCtrl* pToolTip);

	// Retrieves the image list associated with the rebar control.
	CImageList* GetImageList() const;

	// Associates an image list with the rebar control.
	BOOL SetImageList(_In_ CImageList* pImageList);

	// Retrieves the borders of a band in the rebar control.
	void GetBandBorders(_In_ UINT uBand, _Out_ LPRECT prc) const;

	// Retrieves the rebar control's current palette.
	CPalette* GetPalette() const;

	// Sets the rebar control's current palette.
	CPalette* SetPalette(_In_ HPALETTE hPal);

	// Retrieves the color scheme information from the rebar control.
	BOOL GetColorScheme(_Out_ COLORSCHEME* lpcs) const;

	// Sets the color scheme information for the rebar control.
	void SetColorScheme(_In_ const COLORSCHEME* lpcs);

#if (_WIN32_WINNT >= 0x0501)
	// Retrieves the margins of a band in the rebar control.
	AFX_ANSI_DEPRECATED void GetBandMargins(_Out_ PMARGINS pMargins) const;

	// Sets the visual style of the rebar control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Sets the width for a docked band in the rebar control.
	BOOL SetBandWidth(_In_ UINT uBand, _In_ int cxWidth);

	// REVIEW: Sets the extended style of the rebar control.
	DWORD SetExtendedStyle(_In_ DWORD dwMask, _In_ DWORD dwStyleEx);

	// REVIEW: Retrieves the extended style of the rebar control.
	DWORD GetExtendedStyle() const;
#endif // _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Operations
public:
	// Puts the rebar control in drag-and-drop mode.
	void BeginDrag(_In_ UINT uBand, _In_ DWORD dwPos = (DWORD)-1);

	// Deletes a band from the rebar control.
	BOOL DeleteBand(_In_ UINT uBand);

	// Updates the drag position in the rebar control.
	void DragMove(_In_ DWORD dwPos = (DWORD)-1);

	// Terminates the rebar control's drag-and-drop operation.
	void EndDrag();

	// Determines which portion of a rebar band is at a given
	// point on the screen, if a rebar band exists at that point.
	int HitTest(_In_ RBHITTESTINFO* prbht);

	// Inserts a new band in the rebar control.
	BOOL InsertBand(_In_ UINT uIndex, _In_ REBARBANDINFO* prbbi);

	// Resizes a band in the rebar control to its largest size.
	void MaximizeBand(_In_ UINT uBand);

	// Resizes a band in the rebar control to its smallest size.
	void MinimizeBand(_In_ UINT uBand);

	// Resizes a band in the rebar control to its ideal size.
	void RestoreBand(_In_ UINT uBand);

	// Shows or hides the specified band in the rebar control.
	BOOL ShowBand(_In_ UINT uBand, _In_ BOOL fShow = TRUE);

	// Attempts to find the best layout of the bands for the given rectangle.
	BOOL SizeToRect(_Out_ CRect& rect);

	// Moves the specified band from one index to another in the rebar control.
	BOOL MoveBand(_In_ UINT uFrom, _In_ UINT uTo);

#if _WIN32_IE >= 0x0500
	// Programmatically push a chevron in the rebar control.
	void PushChevron(_In_ UINT uBand, _In_ LPARAM lAppValue);
#endif

// Implementation
public:
	// virtual OK here: ~CWnd() is already virtual
	virtual ~CReBarCtrl();
};

#ifndef _AFX_NO_RICHEDIT_SUPPORT
/////////////////////////////////////////////////////////////////////////////
// CRichEditCtrl

// NOTE: This class must remain a binary-compatible subset
// of CRichEditView. Do not add data members or virtual functions
// directly to this class.
class CRichEditCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CRichEditCtrl)

// Constructors
public:
	CRichEditCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	BOOL CanUndo() const;
	BOOL CanRedo() const;
	UNDONAMEID GetUndoName() const;
	UNDONAMEID GetRedoName() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(_In_ BOOL bModified = TRUE);
	BOOL SetTextMode(_In_ UINT fMode);
	UINT GetTextMode() const;
	void GetRect(_Out_ LPRECT lpRect) const;
	CPoint GetCharPos(_In_ long lChar) const;
	UINT GetOptions() const;
	void SetOptions(_In_ WORD wOp, _In_ DWORD dwFlags);
	BOOL SetAutoURLDetect(_In_ BOOL bEnable = TRUE);
	UINT GetWordWrapMode() const;
	UINT SetWordWrapMode(_In_ UINT uFlags) const;
	BOOL GetPunctuation(_In_ UINT fType, _Out_ PUNCTUATION* lpPunc) const;
	BOOL SetPunctuation(_In_ UINT fType, _In_ PUNCTUATION* lpPunc);

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	// NOTE: Copied line does not contain null character!
	int GetLine(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszBuffer) const;
	// NOTE: Copied line does not contain null character!
	int GetLine(_In_ int nIndex, _Out_cap_post_count_(nMaxLength, return) LPTSTR lpszBuffer, _In_ int nMaxLength) const;

	BOOL CanPaste(_In_ UINT nFormat = 0) const;
	void GetSel(_Out_ long& nStartChar, _Out_ long& nEndChar) const;
	void GetSel(_Out_ CHARRANGE &cr) const;
	void LimitText(_In_ long nChars = 0);
	long LineFromChar(_In_ long nIndex) const;
	CPoint PosFromChar(_In_ UINT nChar) const;
	int CharFromPos(_In_ CPoint pt) const;

	void SetSel(_In_ long nStartChar, _In_ long nEndChar);
	void SetSel(_In_ CHARRANGE &cr);
	DWORD GetDefaultCharFormat(_Out_ CHARFORMAT &cf) const;
	DWORD GetDefaultCharFormat(_Out_ CHARFORMAT2 &cf) const;
	DWORD GetSelectionCharFormat(_Out_ CHARFORMAT &cf) const;
	DWORD GetSelectionCharFormat(_Out_ CHARFORMAT2 &cf) const;
	long GetEventMask() const;
	long GetLimitText() const;
	DWORD GetParaFormat(_Out_ PARAFORMAT &pf) const;
	DWORD GetParaFormat(_Out_ PARAFORMAT2 &pf) const;
	// richedit EM_GETSELTEXT is ANSI
	_AFX_INSECURE_DEPRECATE("GetSelText(char *) is unsafe. Instead, use GetSelText(void) returning CString") 
	long GetSelText(_Pre_notnull_ _Post_z_ LPSTR lpBuf) const;
	int GetTextRange(_In_ int nFirst, _In_ int nLast, _Out_ CString& refString) const;
	CString GetSelText() const;
	WORD GetSelectionType() const;
	COLORREF SetBackgroundColor(_In_ BOOL bSysColor, _In_ COLORREF cr);
	BOOL SetDefaultCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetDefaultCharFormat(_In_ CHARFORMAT2 &cf);
	BOOL SetSelectionCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetSelectionCharFormat(_In_ CHARFORMAT2 &cf);
	BOOL SetWordCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetWordCharFormat(_In_ CHARFORMAT2 &cf);
	DWORD SetEventMask(_In_ DWORD dwEventMask);
	BOOL SetParaFormat(_In_ PARAFORMAT &pf);
	BOOL SetParaFormat(_In_ PARAFORMAT2 &pf);
	BOOL SetTargetDevice(_In_ HDC hDC, _In_ long lLineWidth);
	BOOL SetTargetDevice(_In_ CDC &dc, _In_ long lLineWidth);
	long GetTextLength() const;
	long GetTextLengthEx(_In_ DWORD dwFlags, _In_ UINT uCodePage = -1) const;
	BOOL SetReadOnly(_In_ BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;

// Operations
	void EmptyUndoBuffer();
	void StopGroupTyping();
	UINT SetUndoLimit(_In_ UINT nLimit);

	int LineIndex(_In_ int nLine = -1) const;
	int LineLength(_In_ int nLine = -1) const;
	void LineScroll(_In_ int nLines, _In_ int nChars = 0);
	void ReplaceSel(_In_z_ LPCTSTR lpszNewText, _In_ BOOL bCanUndo = FALSE);
	void SetRect(_In_ LPCRECT lpRect);

	BOOL DisplayBand(_In_ LPRECT pDisplayRect);
	long FindText(_In_ DWORD dwFlags, _Out_ FINDTEXTEX* pFindText) const;
	DWORD FindWordBreak(_In_ UINT nCode, _In_ DWORD nStart) const;
	long FormatRange(_In_ FORMATRANGE* pfr, _In_ BOOL bDisplay = TRUE);
	void HideSelection(_In_ BOOL bHide, _In_ BOOL bPerm);
	void PasteSpecial(_In_ UINT nClipFormat, _In_ DWORD dvAspect = 0, _In_ HMETAFILE hMF = 0);
	void RequestResize();
	long StreamIn(_In_ int nFormat, EDITSTREAM &es);
	long StreamOut(_In_ int nFormat, EDITSTREAM &es);

	// Clipboard operations
	BOOL Undo();
	BOOL Redo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// OLE support
	IRichEditOle* GetIRichEditOle() const;
	BOOL SetOLECallback(IRichEditOleCallback* pCallback);

// Implementation
public:
	// virtual OK here - ~CWnd is already virtual
	virtual ~CRichEditCtrl();
};
#endif //!_AFX_NO_RICHEDIT_SUPPORT


/////////////////////////////////////////////////////////////////////////////
// CIPAddressCtrl

class CIPAddressCtrl : public CWnd
{
	DECLARE_DYNAMIC(CIPAddressCtrl)

public:
// Constructors
	CIPAddressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Determines if all fields in the IP address control are blank.
	BOOL IsBlank() const;

	// Clears the contents of the IP address control.
	void ClearAddress();

	// Retrieves the address values for all four fields in the IP address control.
	int GetAddress(_Out_ BYTE& nField0, _Out_ BYTE& nField1, _Out_ BYTE& nField2, _Out_ BYTE& nField3) const;
	int GetAddress(_Out_ DWORD& dwAddress) const;

	// Sets the address values for all four fields in the IP address control.
	void SetAddress(_In_ DWORD dwAddress);
	void SetAddress(_In_ BYTE nField0, _In_ BYTE nField1, _In_ BYTE nField2, _In_ BYTE nField3);

	// Sets the keyboard focus to the specified field in the IP address control.
	void SetFieldFocus(_In_ WORD nField);

	// Sets the valid range for the specified field in the IP address control.
	void SetFieldRange(_In_ int nField, _In_ BYTE nLower, _In_ BYTE nUpper);

// Implementation
public:
	virtual ~CIPAddressCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

class CPagerCtrl : public CWnd
{
	DECLARE_DYNAMIC(CPagerCtrl)

// Constructors
public:
	CPagerCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets the contained window for the pager control.
	void SetChild(_In_ HWND hwndChild);

	// Sets the current background color for the pager control.
	COLORREF SetBkColor(_In_ COLORREF clrBk);

	// Retrieves the current background color for the pager control.
	COLORREF GetBkColor() const;

	// Sets the current border size for the pager control.
	int SetBorder(_In_ int iBorder);

	// Retrieves the current border size for the pager control.
	int GetBorder() const;

	// Sets the current scroll position for the pager control.
	void SetScrollPos(_In_ int iPos);

	// Retrieves the current scroll position of the pager control.
	int GetScrollPos() const;

	// Sets the current button size for the pager control.
	int SetButtonSize(_In_ int iButtonSize);

	// Retrieves the current button size for the pager control.
	int GetButtonSize() const;

	// Determines whether the specified button in the pager control is invisible.
	BOOL IsButtonInvisible(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is normal.
	BOOL IsButtonNormal(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is grayed.
	BOOL IsButtonGrayed(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is depressed.
	BOOL IsButtonDepressed(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is hot.
	BOOL IsButtonHot(_In_ int iButton) const;

	// Retrieves the state of the specified button in a pager control.
	DWORD GetButtonState(_In_ int iButton) const;

	// Retrieves a pager control's IDropTarget interface pointer.
	IDropTarget* GetDropTarget() const;

// Operations

	// Forces the pager control to recalculate the size of the contained window.
	void RecalcSize();

	// Enables or disables mouse forwarding for the pager control.
	void ForwardMouse(_In_ BOOL bForward);

// Implementation
public:
	virtual ~CPagerCtrl();
};

#if (_WIN32_WINNT >= 0x0501)
/////////////////////////////////////////////////////////////////////////////
// CLinkCtrl

AFX_ANSI_DEPRECATED class CLinkCtrl : public CWnd
{
	DECLARE_DYNAMIC(CLinkCtrl)

// Constructors
public:
	CLinkCtrl();

	// Generic creator
	AFX_DEPRECATED("CLinkCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID) is no longer supported as the Link Control does not get initialized correctly using this method. Instead, use CLinkCtrl::Create(LPCTSTR lpszLinkMarkup, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)")
		virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL Create(_In_z_ LPCTSTR lpszLinkMarkup, _In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	AFX_DEPRECATED("CLinkCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID) is no longer supported as the Link Control does not get initialized correctly using this method. Instead, use CLinkCtrl::CreateEx(LPCTSTR lpszLinkMarkup, DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)")
		virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
			_In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL CreateEx(_In_z_ LPCTSTR lpszLinkMarkup, _In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the preferred height of a link for the control's current width.
	int GetIdealHeight() const;

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the preferred size of a link for the specified width.
	int GetIdealSize(_In_ int cxMaxWidth, _Out_ SIZE* pSize) const;
#endif // (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

// Operations
	// Set the states and attributes of an item.
	BOOL SetItem(_In_ PLITEM pItem);
	BOOL SetItemID(_In_ int iLink, _In_z_ LPCWSTR szID);
	BOOL SetItemUrl(_In_ int iLink, _In_z_ LPCWSTR szUrl);
	BOOL SetItemState(_In_ int iLink, _In_ UINT state, _In_ UINT stateMask = LIS_FOCUSED | LIS_ENABLED | LIS_VISITED);

	// Retrieve the states and attributes of an item.
	BOOL GetItem(_Out_ PLITEM pItem) const;
	BOOL GetItemID(_In_ int iLink, _Out_ CString& strID) const;
	BOOL GetItemID(_In_ int iLink, _Out_z_cap_(cchID) LPWSTR szID, _In_ UINT cchID) const;
	BOOL GetItemUrl(_In_ int iLink, _Out_ CString& strUrl) const;
	BOOL GetItemUrl(_In_ int iLink, _Out_z_cap_(cchUrl) LPWSTR szUrl, _In_ UINT cchUrl) const;
	BOOL GetItemState(_In_ int iLink, _Out_ UINT *pnState, _In_ UINT stateMask = LIS_FOCUSED | LIS_ENABLED | LIS_VISITED) const;

	// Determines whether the user clicked the specified link.
	BOOL HitTest(_In_ PLHITTESTINFO phti) const;

// Implementation
public:
	virtual ~CLinkCtrl();
};

#endif	// _WIN32_WINNT >= 0x0501

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CNetAddressCtrl

class CNetAddressCtrl : public CEdit
{
	DECLARE_DYNAMIC(CNetAddressCtrl)

public:
// Constructors
	CNetAddressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the address in the control.
	HRESULT GetAddress(_Out_ PNC_ADDRESS pAddress) const;

	// Sets the allowed address types for the control.
	HRESULT SetAllowType(_In_ DWORD dwAddrMask);

	// Retrieves the allowed address types for the control.
	DWORD GetAllowType() const;

// Operations
	// Displays the error tip for the control.
	HRESULT DisplayErrorTip();

// Implementation
public:
	virtual ~CNetAddressCtrl();
};

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ALL_WARNINGS
#pragma warning(pop)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCMN_INLINE AFX_INLINE
#include <afxcmn.inl>
#include <afxcmn2.inl>
#undef _AFXCMN_INLINE
#endif
#include <afxcmn3.inl>

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXCMN_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\atl90\afxcomctl32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Fusion: Dlls that have WinSxS assemblies and several versions can be loaded
// into the same process, and called by mfc, need special wrappers to allow the
// same mfc dll to call the correct version, stored in the module state of the
// user exe/dll.

#ifndef __AFXCOMCTL32_H__
#define __AFXCOMCTL32_H__

#pragma once

#pragma warning(disable: 4127)  // conditional expression constant

/////////////////////////////////////////////////////////////////////////////
// (WinSxS/Manifest) API.



enum eActCtxResult { ActCtxFailed, ActCtxSucceeded, ActCtxNoFusion };
#if (_WIN32_WINNT >= 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED

HANDLE AFXAPI AfxCreateActCtxW(PCACTCTXW pActCtx);
void AFXAPI AfxReleaseActCtx(HANDLE hActCtx);
BOOL AFXAPI AfxActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie);
BOOL AFXAPI AfxDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);
#else
HANDLE AFXAPI AfxCreateActCtxW(void *pActCtx);
void AFXAPI AfxReleaseActCtx(HANDLE hActCtx);
BOOL AFXAPI AfxActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie);
BOOL AFXAPI AfxDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);
#endif
BOOL AFXAPI AfxGetAmbientActCtx();
void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
eActCtxResult AFXAPI AfxActivateActCtxWrapper(HANDLE hActCtx, ULONG_PTR *lpCookie);
/////////////////////////////////////////////////////////////////////////////

#pragma push_macro("AFX_ISOLATIONAWARE_COMMON_ACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC_ACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC_DEACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC")
#pragma push_macro("AFX_ISOLATIONAWARE_STATICLINK_FUNC")
#pragma push_macro("AFX_ISOLATIONAWARE_STATICLINK_PROC")
#pragma push_macro("AFX_ISOLATIONAWARE_PROC")

#define AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		ULONG_PTR ulActCtxCookie = 0;\
		eActCtxResult eActResult = AfxActivateActCtxWrapper(AfxGetModuleState()->m_hActCtx, &ulActCtxCookie);\

#define AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval) \
		AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		type result=(failure_retval);\
		if (eActResult==ActCtxFailed)\
		{\
			return result;\
		}\
		__try {

#define AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval) \
}\
		__finally\
		{\
			if (eActResult!=ActCtxNoFusion)\
			{\
				const BOOL fPreserveLastError = (result == (failure_retval) );\
				const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;\
				AfxDeactivateActCtx(0,ulActCtxCookie);\
				if (fPreserveLastError)\
				{\
					SetLastError(dwLastError);\
				}\
			}\
		}\
		return result;

#define AFX_ISOLATIONAWARE_STATICLINK_FUNC(type, name, params, args, failure_retval) \
	inline type AfxCtx##name##params \
	{ \
		AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
		result=name##args; \
		AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
	}

#define AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
		AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		if (eActResult==ActCtxFailed)\
		{\
			return;\
		}\
		__try {

#define AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
}\
		__finally\
		{\
			if (eActResult!=ActCtxNoFusion)\
			{\
				AfxDeactivateActCtx(0,ulActCtxCookie);\
			}\
		}		

#define AFX_ISOLATIONAWARE_STATICLINK_PROC(name, params, args) \
	inline void AfxCtx##name##params \
	{ \
		AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
		name##args; \
		AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
	}
	

#define AFX_PROC_PTR_TYPE(type, name_with_postfix, params) \
	struct name_with_postfix \
	{ \
		typedef type (WINAPI *Ptr)##params; \
		Ptr p; \
		name_with_postfix() : p(NULL) {} \
		void operator=(Ptr q) { p = q; } \
		Ptr operator->() { return p; } \
		operator Ptr() { return p; } \
		bool operator!() const { return !p; } \
	}

#define AFX_ISOLATIONAWARE_FUNC(type, name, params, args, failure_retval) \
	AFX_PROC_PTR_TYPE(type, name##_Type, params) m__##name; \
	\
	name##_Type GetProcAddress_##name() \
	{ \
		if (!m__##name) \
		{ \
			m__##name = (name##_Type::Ptr) ::GetProcAddress(GetModuleHandle(), #name); \
		} \
		return m__##name; \
	} \
	\
	type _##name##params \
	{ \
			AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
			GetProcAddress_##name(); \
			ENSURE(m__##name != NULL); \
			result=m__##name##args; \
			AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
	}

#define AFX_ISOLATIONAWARE_PROC(name, params, args) \
	AFX_PROC_PTR_TYPE(void, name##_Type, params) m__##name; \
	\
	name##_Type GetProcAddress_##name() \
	{ \
		if (!m__##name) \
		{ \
			m__##name = (name##_Type::Ptr) ::GetProcAddress(GetModuleHandle(), #name); \
		} \
		return m__##name; \
	} \
	\
	void _##name##params \
	{ \
			AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
			GetProcAddress_##name(); \
			ENSURE(m__##name != NULL); \
			m__##name##args; \
			AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
	}


#define AFX_COMCTL32_IF_EXISTS(proc) (afxComCtlWrapper->GetProcAddress_##proc() != NULL)

#if defined(_UNICODE)
#define AFX_COMCTL32_IF_EXISTS2(proc) (afxComCtlWrapper->GetProcAddress_##proc##W() != NULL)
#else
#define AFX_COMCTL32_IF_EXISTS2(proc) (afxComCtlWrapper->GetProcAddress_##proc##A() != NULL)
#endif

/////////////////////////////////////////////////////////////////////////////
// Base class for all dll wrappers
//
class CDllIsolationWrapperBase : public CNoTrackObject
{
public:
	HMODULE m_hModule;
	bool m_bFreeLib;
protected:
	CString m_strModuleName;
public:
	HMODULE GetModuleHandle()
	{
		if (m_hModule == NULL)
		{
			m_hModule = ::GetModuleHandle(m_strModuleName.GetString());
			if (m_hModule == NULL)
			{
				m_hModule = ::LoadLibrary(m_strModuleName.GetString());
				m_bFreeLib = m_hModule != NULL;
			}
		}
		return m_hModule;
	}

public:
	CDllIsolationWrapperBase()
	{
		CommonConstruct();
	}
	CDllIsolationWrapperBase(const CString& strModuleName) 
	: m_strModuleName(strModuleName)
	{
		CommonConstruct();
	}

	void CommonConstruct()
	{
		m_hModule  = NULL;
		m_bFreeLib = false;
	}
	virtual ~CDllIsolationWrapperBase()
	{ 
		m_bFreeLib && ::FreeLibrary(m_hModule);
	}

};

class CComCtlWrapper : public CDllIsolationWrapperBase
{
public:
	CComCtlWrapper() 
	: CDllIsolationWrapperBase(_T("comctl32.dll"))
	{
	}

public:
	AFX_ISOLATIONAWARE_PROC(InitCommonControls, (), ())
	AFX_ISOLATIONAWARE_FUNC(BOOL, InitCommonControlsEx, (LPINITCOMMONCONTROLSEX unnamed1), (unnamed1), FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Create, (int cx,int cy,UINT flags,int cInitial,int cGrow), (cx,cy,flags,cInitial,cGrow), NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Destroy, (HIMAGELIST himl), (himl), FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_GetImageCount, (HIMAGELIST himl), (himl), 0)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetImageCount, (HIMAGELIST himl,UINT uNewCount), (himl,uNewCount), FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_Add, (HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask), (himl,hbmImage,hbmMask), -1)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_ReplaceIcon, (HIMAGELIST himl,int i,HICON hicon), (himl,i,hicon),-1)
	AFX_ISOLATIONAWARE_FUNC(COLORREF, ImageList_SetBkColor, (HIMAGELIST himl,COLORREF clrBk), (himl,clrBk),RGB(0,0,0))
	AFX_ISOLATIONAWARE_FUNC(COLORREF, ImageList_GetBkColor, (HIMAGELIST himl), (himl),RGB(0,0,0))
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetOverlayImage, (HIMAGELIST himl,int iImage,int iOverlay), (himl,iImage,iOverlay),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Draw, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle), (himl,i,hdcDst,x,y,fStyle),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Replace, (HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask), (himl,i,hbmImage,hbmMask),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_AddMasked, (HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask), (himl,hbmImage,crMask),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DrawEx, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle), (himl,i,hdcDst,x,y,dx,dy,rgbBk,rgbFg,fStyle),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DrawIndirect, (IMAGELISTDRAWPARAMS*pimldp), (pimldp),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Remove, (HIMAGELIST himl,int i), (himl,i),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HICON, ImageList_GetIcon, (HIMAGELIST himl,int i,UINT flags), (himl,i,flags),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_LoadImageA, (HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_LoadImageW, (HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Copy, (HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags), (himlDst,iDst,himlSrc,iSrc,uFlags),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_BeginDrag, (HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot), (himlTrack,iTrack,dxHotspot,dyHotspot),FALSE)
	AFX_ISOLATIONAWARE_PROC(ImageList_EndDrag, (), ())
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragEnter, (HWND hwndLock,int x,int y), (hwndLock,x,y),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragLeave, (HWND hwndLock), (hwndLock),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragMove, (int x,int y), (x,y),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetDragCursorImage, (HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot), (himlDrag,iDrag,dxHotspot,dyHotspot),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragShowNolock, (BOOL fShow), (fShow),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_GetDragImage, (POINT*ppt,POINT*pptHotspot), (ppt,pptHotspot),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Read, (IStream *pstm), (pstm),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Write, (HIMAGELIST himl,IStream *pstm), (himl,pstm),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(HRESULT, ImageList_ReadEx, (DWORD dwFlags,IStream *pstm,REFIID riid,PVOID*ppv), (dwFlags,pstm,riid,ppv),S_OK)
	AFX_ISOLATIONAWARE_FUNC(HRESULT, ImageList_WriteEx, (HIMAGELIST himl,DWORD dwFlags,IStream *pstm), (himl,dwFlags,pstm),S_OK)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_GetIconSize, (HIMAGELIST himl,int*cx,int*cy), (himl,cx,cy),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetIconSize, (HIMAGELIST himl,int cx,int cy), (himl,cx,cy),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_GetImageInfo, (HIMAGELIST himl,int i,IMAGEINFO*pImageInfo), (himl,i,pImageInfo),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Merge, (HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy), (himl1,i1,himl2,i2,dx,dy),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Duplicate, (HIMAGELIST himl), (himl),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateToolbarEx, (HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize), (hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize),NULL)
	AFX_ISOLATIONAWARE_FUNC(HBITMAP, CreateMappedBitmap, (HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,LPCOLORMAP lpColorMap,int iNumMaps), (hInstance,idBitmap,wFlags,lpColorMap,iNumMaps),NULL)
	AFX_ISOLATIONAWARE_PROC(DrawStatusTextA, (HDC hDC,LPRECT lprc,LPCSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
	AFX_ISOLATIONAWARE_PROC(DrawStatusTextW, (HDC hDC,LPRECT lprc,LPCWSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateStatusWindowA, (long style,LPCSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateStatusWindowW, (long style,LPCWSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID),NULL)
	AFX_ISOLATIONAWARE_PROC(MenuHelp, (UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,UINT*lpwIDs), (uMsg,wParam,lParam,hMainMenu,hInst,hwndStatus,lpwIDs))
	AFX_ISOLATIONAWARE_FUNC(BOOL, ShowHideMenuCtl, (HWND hWnd,UINT_PTR uFlags,LPINT lpInfo), (hWnd,uFlags,lpInfo),FALSE)
	AFX_ISOLATIONAWARE_PROC(GetEffectiveClientRect, (HWND hWnd,LPRECT lprc,LPINT lpInfo), (hWnd,lprc,lpInfo))
	AFX_ISOLATIONAWARE_FUNC(BOOL, MakeDragList, (HWND hLB), (hLB),FALSE)
	AFX_ISOLATIONAWARE_PROC(DrawInsert, (HWND handParent,HWND hLB,int nItem), (handParent,hLB,nItem))
	AFX_ISOLATIONAWARE_FUNC(int, LBItemFromPt, (HWND hLB,POINT pt,BOOL bAutoScroll), (hLB,pt,bAutoScroll),-1)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateUpDownControl, (DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos), (dwStyle,x,y,cx,cy,hParent,nID,hInst,hBuddy,nUpper,nLower,nPos),NULL)
	AFX_ISOLATIONAWARE_PROC(InitMUILanguage, (LANGID uiLang), (uiLang))
	AFX_ISOLATIONAWARE_FUNC(LANGID, GetMUILanguage, (), (),MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
	AFX_ISOLATIONAWARE_FUNC(HDSA, DSA_Create, (int cbItem,int cItemGrow), (cbItem,cItemGrow),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DSA_Destroy, (HDSA hdsa), (hdsa),FALSE)
	AFX_ISOLATIONAWARE_PROC(DSA_DestroyCallback, (HDSA hdsa,PFNDSAENUMCALLBACK pfnCB,void*pData), (hdsa,pfnCB,pData))
	AFX_ISOLATIONAWARE_FUNC(PVOID, DSA_GetItemPtr, (HDSA hdsa,int i), (hdsa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(int, DSA_InsertItem, (HDSA hdsa,int i,void*pitem), (hdsa,i,pitem),-1)
	AFX_ISOLATIONAWARE_FUNC(HDPA, DPA_Create, (int cItemGrow), (cItemGrow),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_Destroy, (HDPA hdpa), (hdpa),FALSE)
	AFX_ISOLATIONAWARE_FUNC(PVOID, DPA_DeletePtr, (HDPA hdpa,int i), (hdpa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_DeleteAllPtrs, (HDPA hdpa), (hdpa),FALSE)
	AFX_ISOLATIONAWARE_PROC(DPA_EnumCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
	AFX_ISOLATIONAWARE_PROC(DPA_DestroyCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_SetPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, DPA_InsertPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p),-1)
	AFX_ISOLATIONAWARE_FUNC(PVOID, DPA_GetPtr, (HDPA hdpa,INT_PTR i), (hdpa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_Sort, (HDPA hdpa,PFNDPACOMPARE pfnCompare,LPARAM lParam), (hdpa,pfnCompare,lParam),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, DPA_Search, (HDPA hdpa,void*pFind,int iStart,PFNDPACOMPARE pfnCompare,LPARAM lParam,UINT options), (hdpa,pFind,iStart,pfnCompare,lParam,options),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL, Str_SetPtrW, (LPWSTR*ppsz,LPCWSTR psz), (ppsz,psz),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, _TrackMouseEvent, (LPTRACKMOUSEEVENT lpEventTrack), (lpEventTrack),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_EnableScrollBar, (HWND unnamed1,int unnamed2,UINT unnamed3), (unnamed1,unnamed2,unnamed3),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_ShowScrollBar, (HWND unnamed1,int code,BOOL unnamed2),