     continue;
            case TRAYSTATE_OPEN:
                fTrayOpen = TRUE;
                break;
            default:
                fTrayOpen = FALSE;
                break;
            }
            if(!TryEnterCriticalSection(&csTray)) {
                /* Can't get the critical section, so go back and tray again */
                if(ptrqHead)
                    SetEvent(hevtTrayQ);
                continue;
            }
            ptrq = ptrqHead;
            if(ptrq) {
                ptrqHead = ptrq->ptrqNext;
                if(ptrqHead)
                    SetEvent(hevtTrayQ);
                if(pptrqTail == &ptrq->ptrqNext)
                    pptrqTail = &ptrqHead;
            }
            LeaveCriticalSection(&csTray);
            if(ptrq) {
                switch(ptrq->nTrayState) {
                case TRAYSTATE_OPEN:
                    hr = fTrayOpen ? E_INVALIDARG : S_OK;
                    break;
                case TRAYSTATE_CLOSED:
                    if(fTrayOpen) {
                        g_pfsysDiscInsert = ptrq->pfsys;
                        hr = S_OK;
                    } else
                        hr = E_INVALIDARG;
                    break;
                default:
                    hr = E_INVALIDARG;
                    break;
                }
                if(SUCCEEDED(hr))
                    ChangeTrayState(ptrq->nTrayState);
                SatisfyTrq(ptrq, hr);
            }
            break;

        case WAIT_OBJECT_0 + 3:
            /* Tray state change */
            ChangeTrayState(-1);
            break;
        default:
            /* Terminate.  Remove the filesystem and simulate tray closed */
            EnterCriticalSection(&csFsys);
            if(g_pfsys) {
                g_pfsys->MountUnmount(FALSE);
                g_pfsys = NULL;
            }
            LeaveCriticalSection(&csFsys);
			/* Move the traystate to no media along a valid set of states */
			switch(nTrayState) {
			case TRAYSTATE_NOMEDIA:
				/* We're already in the right state */
				break;

			case TRAYSTATE_DETECT:
				SetTrayState(TRAYSTATE_UNLOADING);
				Sleep(100);
				// fall through

			default:
				SetTrayState(TRAYSTATE_OPENING);
				Sleep(100);
				// fall through

			case TRAYSTATE_OPENING:
			case TRAYSTATE_OPEN:
				SetTrayState(TRAYSTATE_CLOSING);
				Sleep(100);
				// fall through

			case TRAYSTATE_CLOSING:
				SetTrayState(TRAYSTATE_CLOSED);
				Sleep(100);
				// fall through

			case TRAYSTATE_CLOSED:
	            SetTrayState(TRAYSTATE_NOMEDIA);
				break;
			}

            return 0;
        }
    }
}

void StopTrayState(void)
{
    PTRQ ptrq, ptrqT;

    /* Shut down the thread */
    fTerminate = TRUE;
    SetEvent(hevtTerminateEmulation);
    WaitForSingleObject(hthrTray, INFINITE);

    /* Flush the tray request queue */
    EnterCriticalSection(&csTray);
    ptrq = ptrqHead;
    ptrqHead = NULL;
    LeaveCriticalSection(&csTray);
    while(ptrq) {
        ptrqT = ptrq;
        ptrq = ptrq->ptrqNext;
        SatisfyTrq(ptrqT, E_INVALIDARG);
    }

    /* Clean up */
    CloseHandle(hthrTray);
    CloseHandle(hevtEject);
    CloseHandle(hevtTrayQ);
    CloseHandle(hevtTrayTimer);
    CloseHandle(hevtTerminateEmulation);
}

HRESULT StartEmulating(void)
{
    HRESULT hr;
    HANDLE hevt;

    for(;;) {
        if(!InterlockedExchange((PLONG)&fStartedEmulation, TRUE)) {
            /* Create some global objects */
            if(!fHaveCSTray) {
                InitializeCriticalSection(&csTray);
                InitializeCriticalSection(&csFsys);
                fHaveCSTray = TRUE;
                pptrqTail = &ptrqHead;
            }
            fTerminate = FALSE;
            hevtEject = CreateEvent(NULL, FALSE, FALSE, NULL);
            hevtTrayQ = CreateEvent(NULL, FALSE, FALSE, NULL);
            hevtTerminateEmulation = CreateEvent(NULL, FALSE, FALSE, NULL);
            hevtTrayTimer = CreateWaitableTimer(NULL, FALSE, NULL);
            hthrTray = NULL;
            if(!hevtEject || !hevtTrayQ || !hevtTerminateEmulation)
                break;

            /* Start up the traystate thread */
            hthrTray = CreateThread(NULL, 0, TrayStateThread, NULL, 0, NULL);
            if(!hthrTray)
                break;

            /* Now start the IDE session */
            EnterCriticalSection(&csTray);
            hr = StartIDE();
            if(FAILED(hr)) {
                StopTrayState();
                fStartedEmulation = FALSE;
                LeaveCriticalSection(&csTray);
                return hr;
            }
            SetTrayState(TRAYSTATE_NOMEDIA);
            fEmulationRunning = TRUE;
            LeaveCriticalSection(&csTray);
            return S_OK;
        } else {
            if(fEmulationRunning)
                return E_INVALIDARG;
            Sleep(100);
        }
    }

    if(hevtEject)
        CloseHandle(hevtEject);
    if(hevtTrayQ)
        CloseHandle(hevtTrayQ);
    if(hevtTerminateEmulation)
        CloseHandle(hevtTerminateEmulation);
    if(hevtTrayTimer)
        CloseHandle(hevtTrayTimer);
    DeleteCriticalSection(&csFsys);
    return E_OUTOFMEMORY;
}

HRESULT StopEmulating(void)
{
    HRESULT hr;

    if(!fHaveCSTray)
        hr = E_INVALIDARG;
    else {
        EnterCriticalSection(&csTray);
        if(fEmulationRunning) {
            fEmulationRunning = FALSE;
            /* The thread goes first so that we can stabilize the tray state */
            StopTrayState();
            /* Then we stop the IDE session */
            StopIDE();
            fStartedEmulation = FALSE;
            hr = S_OK;
        } else
            hr = E_INVALIDARG;
        LeaveCriticalSection(&csTray);
    }
    return hr;
}

static HRESULT QueueTrq(PTRQ ptrqIn, BOOL fWait)
{
    HRESULT hr;
    PTRQ ptrq;

    if(!fHaveCSTray)
        hr = E_INVALIDARG;
    else {
        EnterCriticalSection(&csTray);
        
        /* Queue a TRQ if there's somebody to service it */
        if(fEmulationRunning) {
            if(fWait) {
                ptrq = ptrqIn;
                ptrq->hevt = CreateEvent(NULL, FALSE, FALSE, NULL);
                if(!ptrq->hevt) {
                    ptrq = NULL;
                    hr = E_OUTOFMEMORY;
                }
            } else {
                ptrq = (PTRQ)LocalAlloc(LMEM_FIXED, sizeof *ptrq);
                memcpy(ptrq, ptrqIn, sizeof *ptrq);
                ptrq->hevt = NULL;
            }
            if(ptrq) {
                ptrq->ptrqNext = NULL;
                *pptrqTail = ptrq;
                pptrqTail = &ptrq->ptrqNext;
            }
        } else {
            ptrq = NULL;
            hr = E_INVALIDARG;
        }
        LeaveCriticalSection(&csTray);

        /* If we queued a TRQ, then generate the appropriate status.  If
         * this is an asynchronous request, the status is OK; if synchronous,
         * we have to wait for it */
        if(ptrq) {
            SetEvent(hevtTrayQ);
            if(fWait) {
                WaitForSingleObject(ptrq->hevt, INFINITE);
                CloseHandle(ptrq->hevt);
                hr = ptrq->hr;
            } else
                hr = S_OK;
        }
    }

    return hr;
}

HRESULT EmulationOpenTray(BOOL fWait)
{
    TRQ trq;

    trq.nTrayState = TRAYSTATE_OPEN;
    return QueueTrq(&trq, fWait);
}

HRESULT EmulationCloseTray(CEmulationFilesystem *pfsys, BOOL fWait)
{
    TRQ trq;

    trq.nTrayState = TRAYSTATE_CLOSED;
    trq.pfsys = pfsys;
    return QueueTrq(&trq, fWait);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\emucore\emucore.cpp ===
HRESULT StartEmulating(void)
{
    HRESULT hr;

    /* If we're already emulating, we can't restart */
    if(g_pfsys)
        return E_INVALIDARG;
       
    /* Start up IDE */
    g_pfsys = NULL;
    hr = StartIDE();
    
    /* We're good to go */
    return hr;
}

HRESULT StopEmulating(void)
{
    /* Shut down the worker thread if it's out there */
    StopIDE();
    g_pfsys = NULL;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\isoemu\precomp.h ===
#include <windows.h>
#include <emucore.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\isoemu\isoemu.cpp ===
/*
 *
 * isoemu.cpp
 *
 * Emulate from ISO files
 *
 */

#include "precomp.h"

class CISO : public CEmulationFilesystem
{
public:
    virtual void MountUnmount(BOOL);
    virtual void GetPhysicalGeometry(PHYSICAL_GEOMETRY *, BOOL);
    virtual int NumberOfPlaceholders(int Layer);
    virtual void GetPlaceholderInformation(int Layer,
        PLACEHOLDER *Placeholders);
    virtual ULONG GetSectorData(ULONG lsn, ULONG cblk, PUCHAR rgbData);

    HANDLE m_h;
    DWORD m_cblk;
};

CISO g_iso;
HANDLE g_hevtUnmount;

void CISO::MountUnmount(BOOL fMount)
{
    if(!fMount)
        SetEvent(g_hevtUnmount);
}

void CISO::GetPhysicalGeometry(PHYSICAL_GEOMETRY *pgeom, BOOL)
{
    memset(pgeom, 0, sizeof *pgeom);
    pgeom->Layer0StartPSN = 0x30000;
    pgeom->Layer0SectorCount = m_cblk;
}

int CISO::NumberOfPlaceholders(int iLayer)
{
    return 0;
}

void CISO::GetPlaceholderInformation(int iLayer, PLACEHOLDER *Placeholders)
{
}

ULONG CISO::GetSectorData(ULONG lsn, ULONG cblk, PUCHAR rgbData)
{
    LARGE_INTEGER li;
    DWORD cb;

    if(lsn < m_cblk && (lsn + cblk) <= m_cblk) {
        li.QuadPart = lsn * 2048;
        if(!SetFilePointerEx(m_h, li, NULL, FILE_BEGIN))
            return EMU_ERR_UNEXPECTED_ERROR;
        if(!ReadFile(m_h, rgbData, 2048 * cblk, &cb, NULL) || cb != 2048 * cblk)
            return EMU_ERR_UNEXPECTED_ERROR;
    } else
        return EMU_ERR_INVALID_LSN;

    return EMU_ERR_SUCCESS;
}

int __cdecl main(int argc, char **argv)
{
    LARGE_INTEGER li;
    HANDLE h;
    DWORD dw;

    if(argc < 2) {
        fprintf(stderr, "usage: isoemu iso.iso\n");
        return 1;
    }

    h = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        0, NULL);
    if(INVALID_HANDLE_VALUE == h || !GetFileSizeEx(h, &li)) {
        fprintf(stderr, "error opening %s\n", argv[1]);
        return 1;
    }

    g_hevtUnmount = CreateEvent(NULL, FALSE, FALSE, NULL);
    g_iso.m_h = h;
    g_iso.m_cblk = (ULONG)(li.QuadPart / 2048);
    StartEmulating();
    EmulationOpenTray(TRUE);
    EmulationCloseTray(&g_iso, TRUE);
    WaitForSingleObject(g_hevtUnmount, INFINITE);
    EmulationCloseTray(NULL, TRUE);
    StopEmulating();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\About.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      About.h
// Contents:  
// Revisions: 4-Feb-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

extern void DoAbout(HWND hwndParent);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\inc\emucore.h ===
/*
 *
 * emucore.h
 *
 * Core emulation stuff
 *
 */

#ifndef _EMUCORE_H
#define _EMUCORE_H

struct PLACEHOLDER {
    ULONG StartLSN;
    ULONG SectorCount;
};

struct PHYSICAL_GEOMETRY {
    ULONG Layer0StartPSN;
    ULONG Layer0SectorCount;
    ULONG Layer1SectorCount;
    BOOL IsX2Disc;
	BOOL SupportsMultiplePartitions;
};

class CEmulationFilesystem;

HRESULT StartEmulating(void);
HRESULT EmulationOpenTray(BOOL fWait);
HRESULT EmulationCloseTray(CEmulationFilesystem *, BOOL fWait);
HRESULT StopEmulating(void);
void AccumulateSeekDelay(ULONG PSN, PULARGE_INTEGER Delay);
BOOL DefaultChallengeResponse(UCHAR id, PULONG ChallengeValue,
    PULONG ResponseValue, PULARGE_INTEGER Delay);
BOOL DefaultControlData(PUCHAR, ULONG, PULARGE_INTEGER);

class CEmulationFilesystem
{
public:
    /* MountUnmount is called whenever the virtual disc is "physically"
     * inserted or removed from the device tray */
    virtual void MountUnmount(BOOL fMount) =0;

    /* GetPhysicalGeometry returns the physical geometry of the device */
    virtual void GetPhysicalGeometry(PHYSICAL_GEOMETRY *,
		BOOL fExtendedPartition) =0;

    /* NumberOfPlaceholders returns the number of placeholders on a
     * layer */
    virtual int NumberOfPlaceholders(int Layer) =0;

    /* GetPlaceholderInformation fills in an array of placeholder structures
     * for a given layer */
    virtual void GetPlaceholderInformation(int Layer,
        PLACEHOLDER *Placeholders) =0;
    
    /* GetSectorData fills in rgbData with (cblk * 2kb) data and returns 0 if
     * successful or one of the error codes if unsuccessful */
    virtual ULONG GetSectorData(ULONG lsn, ULONG cblk, PUCHAR rgbData) =0;

	/* GetControlData returns the DVDX2 control data for the disc */
	virtual BOOL GetControlData(BOOL fXControl, PUCHAR pb, ULONG cb,
		PULARGE_INTEGER Delay)
	{
		return DefaultControlData(pb, cb, Delay);
	}

	/* DiscChallengeResponse performs a DVDX2 authentication challenge */
    virtual BOOL DiscChallengeResponse(UCHAR id, PULONG ChallengeValue,
        PULONG ResponseValue, PULARGE_INTEGER Delay)
    {
        return DefaultChallengeResponse(id, ChallengeValue, ResponseValue,
            Delay);
    }
};

enum {
    EMU_ERR_SUCCESS = 0,
    EMU_ERR_PLACEHOLDER,
    EMU_ERR_INVALID_LSN,
    EMU_ERR_UNEXPECTED_ERROR
};

#endif // EMUCORE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CExpListView.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      clistview.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define NUM_COLUMNS 6


class CExpListView : public CMyListView
{
public:
    BOOL Init(HWND hwndParent);
    void UpdateItem(void *pvItem, DWORD dwItemState, int iColumn, HDC hdcDest, RECT *prcDest);
    DWORD GetItemWidth(HDC hdc, void *pvItem, int iColumn);

    int CompareObjects(const void *pv1, const void *pv2);

    virtual BOOL Override_LButtonDblClick(sMouseInfo *pmi, DWORD dwFlags);
    virtual BOOL Override_LButtonDown(sMouseInfo *pmi, DWORD dwFlags);
    virtual BOOL Override_MouseMove(sMouseInfo *pmi, DWORD dwFlags);
    virtual void Notify_SelectChange(void *pvObj, BOOL fSelected);

    void SetDir(CFileObject *pfoFolder);
    void AddObject(void *pvObj);
    void RemoveObject(void *pvObj);
    void RefreshObject(void *pvObj);
    void SetChildrenCheckState(CFileObject *pfo);

private:
    void UpdateCheckState();


    ULARGE_INTEGER m_uliSelectedSize;
    int m_nSelected;
    HBITMAP m_hbmpChecked, m_hbmpUnchecked, m_hbmpUncheckedLit, m_hbmpCheckedLit;
    HFONT m_hfont;
    HIMAGELIST m_himlFileIcons;
    CFileObject *m_pfoDisplay;
    CFileObject *m_poMouseOver;
    int m_iMouseOverItem;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFastToSlow.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFastToSlow.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CFastToSlow : public CInitedObject
{
public:
    bool Init(HWND hwndParent, COLORREF rgbTopColor, COLORREF rgbBotColor);
    ~CFastToSlow();

    void Resize(RECT *prc);

    void SetVisible(bool fVisible) { ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE); }

    void Repaint(HDC hdc);
    DWORD GetWidth() {return m_rc.right - m_rc.left; }
    WNDPROC m_pfnStaticWndProc;
private:

    RECT m_rc;
    HWND m_hwndTip;
    COLORREF m_rgbTopColor, m_rgbBotColor;
    HWND m_hwnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFastToSlow.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFastToSlow.cpp
// Contents:  Contains the class definition for the CFastToSlow object.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ColorBarWndProc
// Purpose:   Subclassed window procedure for the color bar static controls.
// Arguments: hwnd              -- The handle to the window that the message is
//                                 intended for.
//            uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LONG FAR PASCAL ColorBarWndProc(HWND hwnd, UINT uMsg, WORD wparam, LONG lparam)
{
    PAINTSTRUCT ps;

    // Determine which CFastToSlow this message is actually intended for.
    CFastToSlow *pcb = (CFastToSlow*)GetWindowLong(hwnd, GWL_USERDATA);

    switch(uMsg)
    {
    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        pcb->Repaint(ps.hdc);
        EndPaint(hwnd, &ps);
        return 0;
    }

    // If we didn't handle the message above, then pass the message on to the
    // original wndproc for this control.
    return CallWindowProc(pcb->m_pfnStaticWndProc, hwnd, uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFastToSlow::CFastToSlow
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CFastToSlow::Init(HWND hwndParent, COLORREF rgbTopColor, COLORREF rgbBotColor)
{
    // Create the hwnd
    m_hwnd = CreateWindow("static", "", WS_CHILD | WS_VISIBLE, 0, 0, 0, 0,
                          hwndParent, NULL, g_hInst, NULL);
    if (!m_hwnd)
        return false;

    // Subclass the colorbar so that we can override erasebackground messages
    m_pfnStaticWndProc = (WNDPROC)SetWindowLong(m_hwnd, GWL_WNDPROC, (long)ColorBarWndProc);

    // Point our hwnd at 'this' object
    SetWindowLong(m_hwnd, GWL_USERDATA, (long)this);

    m_hwndTip = CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
                            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, m_hwnd, NULL, g_hInst, NULL);

    
    SetWindowPos(m_hwndTip, HWND_TOPMOST,0, 0, 0, 0,
             SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    m_rgbTopColor = rgbTopColor;
    m_rgbBotColor = rgbBotColor;

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFastToSlow::~CFastToSlow
// Purpose:   CFastToSlow destructor
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFastToSlow::~CFastToSlow()
{
    if (m_hwnd)
        DestroyWindow(m_hwnd);
    if (m_hwndTip)
        DestroyWindow(m_hwndTip);
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFastToSlow::Resize
// Purpose:   Called when the colorbar's owning window is resized, and this
//            object needs to resize (and repaint) itself
// Arguments: prc       -- New dimensions of the object
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CFastToSlow::Resize(RECT *prc)
{
    m_rc = *prc;
    MoveWindow(m_hwnd, prc->left, prc->top, prc->right - prc->left,
               prc->bottom - prc->top, TRUE);
    InvalidateRect(m_hwnd, NULL, TRUE);

    // Update our tooltip's position
    TOOLINFO ti;
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_SUBCLASS;
    ti.hwnd = g_hwndMain;
    ti.hinst = g_hInst;
    ti.uId = 0;
    ti.lpszText = MAKEINTRESOURCE(IDS_COLORBAR_TOOLTIP);
    ti.rect = m_rc;

    SendMessage(m_hwndTip, TTM_SETMAXTIPWIDTH, 0, 80);

 
    // Delete Previous tool (if any)
    SendMessage(m_hwndTip, TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);

    // Send an ADDTOOL message to the tooltip control window
    SendMessage(m_hwndTip, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFastToSlow::Repaint
// Purpose:   Called when the colorbar needs to refresh its onscreen display
// Arguments: hdc               -- Device context to render to.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CFastToSlow::Repaint(HDC hdc)
{
    // Setup the necessary structures for the Win32 'GradientFill' call.
    TRIVERTEX rgtv[] = {0, 0,
                        GetRValue(m_rgbTopColor)<<8,
                        GetGValue(m_rgbTopColor)<<8,
                        GetBValue(m_rgbTopColor)<<8, 0,
                        m_rc.right-m_rc.left, m_rc.bottom-m_rc.top,
                        GetRValue(m_rgbBotColor)<<8,
                        GetGValue(m_rgbBotColor)<<8,
                        GetBValue(m_rgbBotColor)<<8, 0};

    GRADIENT_RECT rggr = {0, 1};
    GradientFill(hdc, rgtv, 2, &rggr, 1, GRADIENT_FILL_RECT_V);

    if (m_rc.left == 0)
    {
        RECT rc = {m_rc.right-1, 0, m_rc.right, m_rc.bottom-m_rc.top};
        FillRect(hdc, &rc, (HBRUSH)GetStockObject(LTGRAY_BRUSH));
    }
    else
    {
        RECT rc = {0, 0, 1, m_rc.bottom-m_rc.top};
        FillRect(hdc, &rc, (HBRUSH)GetStockObject(LTGRAY_BRUSH));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\About.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      About.cpp
// Contents:  
// Revisions: 4-Feb-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  AboutDlgProc
// Purpose:   Message handler for About dialog. This function is automatically called by Windows
//            whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK AboutDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[1024], szFormat[1024];

	switch (message)
	{
	case WM_INITDIALOG:
        // Get the build number from the resource file
        LoadString(g_hInst, IDS_ABOUT, szFormat, 1024);
        sprintf(szBuf, szFormat, VER_PRODUCTBUILD);
        SetDlgItemText(hDlg, IDC_ABOUTTEXT, szBuf);
		return true;

	case WM_COMMAND:
		EndDialog(hDlg, 0);
		return false;
	}
    return false;
}

void DoAbout(HWND hwndParent)
{
    DialogBox(g_hInst, (LPCTSTR)IDD_ABOUTBOX, hwndParent, (DLGPROC)AboutDlgProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CExpListView.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CExpListView.cpp
// Contents:  
// Revisions: 6-Nov-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ ENUMERATIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// The columns visible in the Explorer View's listview control.
enum {COL_INCLUDED = 0, COL_NAME, COL_SIZE, COL_TYPE, COL_MODIFIED,
      COL_LOCATION};


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::SetDir
// Purpose:   Populate the list view with the contents of specified folder
// Arguments: pfoFolder     -- The folder with which to populate the list
//                             view.
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CExpListView::SetDir(CFileObject *pfoFolder)
{
    assert(pfoFolder);
    assert(this);

    // Erase contents from previous folder (if any)
    Clear();

    // Enumerate over the folder's child objects and add each of them.
    CFileObject *pfoChild = pfoFolder->m_lpfoChildren.GetFirst();
    while (pfoChild)
    {
        AddItemAtIndex(pfoChild, 0);
        pfoChild = pfoFolder->m_lpfoChildren.GetNext();
    }

    // Track which folder we're now viewing.
    m_pfoDisplay = pfoFolder;

    // Not over any mouse item at start
    m_iMouseOverItem = -1;

    // Mark that we're dirty to force refresh
    m_fDirty = TRUE;

    // Update status bar
    char sz[100];
    int nObjects = pfoFolder->m_lpfoChildren.GetCount();
    sprintf(sz, "%d objects", nObjects);
    g_statusbar.SetText(0, sz);

    FormatByteString(pfoFolder->m_lpfoChildren.GetSize(), sz);
    g_statusbar.SetText(1, sz);

    // Start out with none selected
    m_nSelected = 0;
    m_uliSelectedSize.QuadPart = 0;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::Init
// Purpose:   Initialize the list view control; create columns and font.
// Arguments: hwndParent        -- The window we're attache to.
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CExpListView::Init(HWND hwndParent)
{
    SHFILEINFO sfi;
    LOGFONT    lf;

    assert(hwndParent);

    // Initialize our base 'MyListView' object.
    if (!CMyListView::Init(hwndParent))
        return FALSE;

    // Get the imagelist of icons for the file display
    ZeroMemory(&sfi, sizeof sfi);
    DWORD flg = SHGFI_ICON | SHGFI_SMALLICON | SHGFI_SYSICONINDEX;
    m_himlFileIcons = (HIMAGELIST)SHGetFileInfo("C:\\", 0, &sfi, sizeof(sfi),
                                                flg);

    // Preload bitmap images for the various checkbox states.
    m_hbmpUnchecked    = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_UNCHECK));
    m_hbmpChecked      = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_CHECK));
    m_hbmpUncheckedLit = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_UNCHECKLIT));
    m_hbmpCheckedLit   = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_CHECKLIT));

    // Init columns for listview
    // NOTE: Order must match order in COL_* enumeration
    AddColumn("Included",      60);
    AddColumn("Name",          150);
    AddColumn("Size",          75);
    AddColumn("Type",          75);
    AddColumn("Date Modified", 100);
    AddColumn("Location",      75);

    // Create the GDI font object that will be used to render the list view
    // elements.
    memset(&lf, 0, sizeof lf);
    lf.lfHeight = -11;
    lf.lfWeight = 0;
    strcpy(lf.lfFaceName, "Tahoma");
    m_hfont = CreateFontIndirect(&lf);

    // Default to Sorting by the 'Name' column
    m_iSortColumn = COL_NAME;

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::UpdateItem
// Purpose:   Update the display of the specified item.
// Arguments: pvItem      -- Data for the row to update
//            dwItemState -- Selected or focused
//            iColumn     -- The specific column to update
//            hdcDest     -- Device Context into which to render.
//            prcDest     -- Destination rect (clipped)
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CExpListView::UpdateItem(void *pvItem, DWORD dwItemState, int iColumn,
                              HDC hdcDest, RECT *prcDest)
{
    char *psz;
    HDC hdcBmp;
    HBITMAP hbmpPrev;
    int nX, nY, nW;
    CFileObject *pfo = (CFileObject*)pvItem;
    DWORD dwAlign = DT_LEFT;
    DWORD dwFlags;
    
    static HBRUSH s_hbrLightGray = CreateSolidBrush(RGB(247,247,247));

    assert(pvItem);
    assert(hdcDest);
    assert(iColumn < NUM_COLUMNS);

    // If prcDest is NULL, then the item is completely offscreen
    if (prcDest == NULL)
        return;

    // UNDONE: Can choose to use offscreenbuffer only when resizing if so
    //         desired (not really necessary for scroll/update).
#define OFFSCREENBUFFER
#ifdef OFFSCREENBUFFER
    static HBITMAP s_hbmpOff = NULL;
    static int s_nLastWidth = -1, s_nLastHeight = -1;
    RECT rcOrig = *prcDest;
    prcDest->bottom -= prcDest->top;
    prcDest->top = 0;
    prcDest->right -= prcDest->left;
    prcDest->left = 0;
    
    HDC hdcOffscreen = CreateCompatibleDC(hdcDest);

    // Resuse the offscreen bitmap from the previuos call unless it needs to
    // grow.
    if (prcDest->right - prcDest->left > s_nLastWidth ||
        prcDest->bottom - prcDest->top > s_nLastHeight)
    {
        if (s_hbmpOff)
            DeleteObject(s_hbmpOff);
        s_hbmpOff = CreateCompatibleBitmap(hdcDest,
                                           prcDest->right - prcDest->left,
                                           prcDest->bottom - prcDest->top);
        s_nLastWidth = prcDest->right - prcDest->left;
        s_nLastHeight = prcDest->bottom - prcDest->top;
    }

    HBITMAP hbmpPrevOff = (HBITMAP)SelectObject(hdcOffscreen, s_hbmpOff);
#else
    HDC hdcOffscreen = hdcDest;
#endif
    SelectObject(hdcOffscreen, m_hfont);

    if (dwItemState & LVF_ITEMSELECTED)
    {
        // Draw selected state background
        if (iColumn == 1)
        {
            if (dwItemState & LVF_ITEMFOCUSED)
            {
                FillRect(hdcOffscreen, prcDest,
                         GetSysColorBrush(COLOR_BACKGROUND));
                SetBkColor(hdcOffscreen, GetSysColor(COLOR_BACKGROUND));
                SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOW));
            }
            else
            {
                FillRect(hdcOffscreen, prcDest,
                         GetSysColorBrush(COLOR_BTNSHADOW));
                SetBkColor(hdcOffscreen, GetSysColor(COLOR_BTNSHADOW));
                SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOWTEXT));
            }
        }
        else
        {
            if (dwItemState & LVF_ITEMFOCUSED)
            {
                FillRect(hdcOffscreen, prcDest,
                         GetSysColorBrush(COLOR_HIGHLIGHT));
                SetBkColor(hdcOffscreen, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(hdcOffscreen, GetSysColor(COLOR_HIGHLIGHTTEXT));
            }
            else
            {
                FillRect(hdcOffscreen, prcDest,
                         GetSysColorBrush(COLOR_INACTIVEBORDER));
                SetBkColor(hdcOffscreen, GetSysColor(COLOR_INACTIVEBORDER));
                SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOWTEXT));
            }
        }
    }
    else
    {
        // Draw unselected state background
        if (iColumn == 1)
        {
            FillRect(hdcOffscreen, prcDest, s_hbrLightGray);
            SetBkColor(hdcOffscreen, RGB(247,247,247));
        }
        else
        {
            FillRect(hdcOffscreen, prcDest, GetSysColorBrush(COLOR_WINDOW));
            SetBkColor(hdcOffscreen, GetSysColor(COLOR_WINDOW));
        }
        SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOWTEXT));
    }

    // Column 0 contains the checkbox and is centered - don't offset it.
    if (iColumn != 0)
    {
        prcDest->right -= 5;
        prcDest->top ++;
    }

    // Render the requested column.
    switch(iColumn)
    {
    case COL_INCLUDED:
        // Draw included state (centered in the first column)
        hdcBmp = CreateCompatibleDC(hdcOffscreen);
        hbmpPrev;
        if (pfo->m_checkstate == CHECKSTATE_CHECKED)
            if (pfo->m_fMouseOver)
                hbmpPrev = (HBITMAP)SelectObject(hdcBmp, m_hbmpCheckedLit);
            else
                hbmpPrev = (HBITMAP)SelectObject(hdcBmp, m_hbmpChecked);
        else
            if (pfo->m_fMouseOver)
                hbmpPrev = (HBITMAP)SelectObject(hdcBmp, m_hbmpUncheckedLit);
            else
                hbmpPrev = (HBITMAP)SelectObject(hdcBmp, m_hbmpUnchecked);

        nW = min(prcDest->right - prcDest->left, CB_SIZE);
        if (nW < CB_SIZE)
            nX = prcDest->left-2;
        else
            nX = prcDest->left + (prcDest->right - prcDest->left) / 2 - 7;
        nY = prcDest->top + (prcDest->bottom - prcDest->top) / 2 - 6;
        BitBlt(hdcOffscreen, nX, nY, nW, CB_SIZE, hdcBmp, CB_SIZE-nW, 0,
               SRCCOPY);
        SelectObject(hdcBmp, hbmpPrev);
        DeleteDC(hdcBmp);
        psz = NULL;
        break;

    case COL_NAME:
        // Render the icon
        nW = min(GetSystemMetrics(SM_CXSMICON),
                 prcDest->right - prcDest->left);
        dwFlags = ILD_TRANSPARENT | ILD_NORMAL;
        if ((dwItemState & LVF_ITEMSELECTED) &&
            (dwItemState & LVF_ITEMFOCUSED))
            dwFlags |= ILD_SELECTED;
        ImageList_Draw(pfo->m_himl, pfo->m_iIcon, hdcOffscreen,
                       prcDest->left, prcDest->top, dwFlags);

        prcDest->left += 20;
        psz = pfo->m_szName;
        break;

    case COL_SIZE:
        psz     = pfo->m_szSize;
        dwAlign = DT_RIGHT;
        break;

    case COL_TYPE:
        psz = pfo->m_szType;
        break;

    case COL_MODIFIED:
        psz = pfo->m_szModified;
        break;
    
    case COL_LOCATION:
        // UNDONE: change m_szLocation to an index into g_rgszLoc.
        psz = pfo->m_szLocation;
        break;

    default:
        assert(FALSE);
    }
    // Render the text string (if one).
    if (psz)
        DrawTextEx(hdcOffscreen, psz, strlen(psz), prcDest,
                   dwAlign | DT_END_ELLIPSIS, NULL);

#ifdef OFFSCREENBUFFER
    // Render offscreen buffer to the final destination DC.
    BitBlt(hdcDest, rcOrig.left, rcOrig.top,
           rcOrig.right - rcOrig.left, rcOrig.bottom - rcOrig.top,
           hdcOffscreen, 0, 0, SRCCOPY);
    SelectObject(hdcOffscreen, hbmpPrevOff);
    DeleteDC(hdcOffscreen);
#endif
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::GetItemWidth
// Purpose:   Obtain the Width (in pixels) of the specified column's text.
// Arguments: hdc       -- Device Context for the item
//            pvItem    -- Item data
//            iColumn   -- Column to query on.
// Return:    Width (in pixels) of the text in the specified column
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD CExpListView::GetItemWidth(HDC hdc, void *pvItem, int iColumn)
{
    CFileObject *pfo = (CFileObject*)pvItem;
    SIZE size;
    char *psz;
    int  nAdd = 5; // 5 for the padding we add during drawing

    assert(hdc);
    assert(pvItem);
    assert(iColumn < NUM_COLUMNS);

    switch(iColumn)
    {
    case COL_INCLUDED: return CB_SIZE+4;
    case COL_NAME:     psz = pfo->m_szName;     nAdd += 20; break;
    case COL_SIZE:     psz = pfo->m_szSize;     break;
    case COL_TYPE:     psz = pfo->m_szType;     break;
    case COL_MODIFIED: psz = pfo->m_szModified; break;
    case COL_LOCATION: psz = pfo->m_szLocation; break;
    }

    SelectObject(hdc, m_hfont);
    GetTextExtentPoint32(hdc, psz, strlen(psz), &size);
    SetTextJustification(hdc, 0, 0);
    return size.cx + nAdd;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::CompareObjects
// Purpose:   Compare to objects and return their 'sorting order'
// Arguments: pv1       -- First object to compare
//            pv2       -- Second object to compare
// Return:    return -1 if pv1 is "less than" pv2
//            return 1 if pv2 is "less than" pv1
//            return 0 if pv1 "equals" pv2
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CExpListView::CompareObjects(const void *pv1, const void *pv2)
{
    int nRet;

    assert(pv1);
    assert(pv2);
    
    CFileObject *po1 = (CFileObject*)pv1;
    CFileObject *po2 = (CFileObject*)pv2;

    // If one of the objects is a directory and the other isn't, then the
    // directory always comes first
    BOOL f1 = po1->m_dwa & FILE_ATTRIBUTE_DIRECTORY ? TRUE : FALSE;
    BOOL f2 = po2->m_dwa & FILE_ATTRIBUTE_DIRECTORY ? TRUE : FALSE;
    if (f1 && !f2)
        return -1;
    if (f2 && !f1)
        return 1;

    // Sort pv1 and pv2 based on the contents of the current sort column
    switch(m_iSortColumn)
    {
    case COL_INCLUDED:
        if (po1->m_checkstate == po2->m_checkstate)
            return _stricmp(po1->m_szName, po2->m_szName);
        return (po1->m_checkstate == CHECKSTATE_CHECKED) ? -1 : 1;

    case COL_NAME:
        return _stricmp(po1->m_szName, po2->m_szName);

    case COL_SIZE:
        if (po1->m_uliSize.QuadPart == po2->m_uliSize.QuadPart)
            return _stricmp(po1->m_szName, po2->m_szName);
        return (po1->m_uliSize.QuadPart < po2->m_uliSize.QuadPart) ? -1 : 1;

    case COL_TYPE:
        nRet = _stricmp(po1->m_szType, po2->m_szType);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;

    case COL_MODIFIED:
        nRet = CompareFileTime(&po1->m_ftModified, &po2->m_ftModified);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;

    case COL_LOCATION:
        nRet = _stricmp(po1->m_szLocation, po2->m_szLocation);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;

    default:
        assert(false);
    }

    // Should never get here.
    return 0;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::Override_LButtonDown
// Purpose:   Check if the user is over the 'include' checkbox when they
//            click the mouse.
// Arguments: pmi       -- Contains mouse state information.
//            dwFlags   -- Additional key state (Shift, Ctrl).
// Return:    'FALSE' if we've handled the message.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CExpListView::Override_LButtonDown(sMouseInfo *pmi, DWORD dwFlags)
{
    assert(pmi);

    RECT rcCheckBox;
    POINT pt = {pmi->nX, pmi->nY};

    // Only need to handle button down over include column
    if (pmi->iColumn != COL_INCLUDED)
        return TRUE;
    
    // User clicked on included column.  Are they in the checkbox?
    // Checkbox (12x12) is centered in the item
    rcCheckBox.left = pmi->rcSubItem.left + (pmi->rcSubItem.right -
                                         pmi->rcSubItem.left - CB_SIZE) / 2;
    rcCheckBox.right = rcCheckBox.left + CB_SIZE;
    rcCheckBox.top = pmi->rcSubItem.top + (pmi->rcSubItem.bottom -
                                        pmi->rcSubItem.top - CB_SIZE) / 2+1;
    rcCheckBox.bottom = rcCheckBox.top + CB_SIZE;
    if (!PtInRect(&rcCheckBox, pt))
        return TRUE;

    // If here, we're in the checkbox!
    CFileObject *po = (CFileObject*)pmi->pvItem;
    assert(po);
    
    // Toggle the object's included state.
    po->m_checkstate = (po->m_checkstate == CHECKSTATE_CHECKED) ?
                                  CHECKSTATE_UNCHECKED : CHECKSTATE_CHECKED;
    
    // If the object is a folder, then update its child objects to match it
    if (po->m_fIsDir)
    {
        // UNDONE: The recursive checkstate code works fine, but is not
        //         pretty.  Given time, remove it from treeview and place in
        //         ViewMode_Explorer of CFileHierarchy and clean it up
        //         considerably.

        // Treeview only sets check state of folders, not files, so force them
        // all here.
        SetChildrenCheckState(po);

        // Update the object itself
        g_vmExplorer.m_treeview.SetCheckState(po->m_hti, po->m_checkstate);

        // Update all of its child objects
        g_vmExplorer.m_treeview.RecurseDownSetState(po->m_hti,
                                                    po->m_checkstate);
    }

    // Finally, select the clicked item
    if (dwFlags & (MK_SHIFT | MK_CONTROL))
        SelectItem(pmi->iRow, dwFlags | MK_FORCESEL);
    else
    {
        if (!m_rgli[pmi->iRow].dwFlags & LVF_ITEMSELECTED)
            UnselectAllItems();
        SelectSingleItem(pmi->iRow);
    }
    SetFocusItem(pmi->iRow);
 
    // Update ALL selected items to match the same state
    for (int i = 0; i < m_cItems; i++)
        if (m_rgli[i].dwFlags & LVF_ITEMSELECTED)
        {
            CFileObject *po2 = (CFileObject*)(m_rgli[i].pvData);
            po2->m_checkstate = po->m_checkstate;
            if (po2->m_fIsDir)
            {
                SetChildrenCheckState(po2);
                g_vmExplorer.m_treeview.SetCheckState(po2->m_hti,
                                                      po2->m_checkstate);
                g_vmExplorer.m_treeview.RecurseDownSetState(po2->m_hti,
                                                         po2->m_checkstate);
            }
            RefreshItem(i);
        }

    // Propagate the check state information to the treeview.
    UpdateCheckState();

    // Mark that the layout has been modified.
    SetModified();

    // Return that we've handled the message.
    return FALSE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::Override_LButtonDblClick
// Purpose:   If user double clicks on a folder, then set that as the current
//            displayed folder.
// Arguments: pmi       -- Contains mouse state information.
//            dwFlags   -- Additional key state (Shift, Ctrl).
// Return:    'FALSE' if we've handled the message.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CExpListView::Override_LButtonDblClick(sMouseInfo *pmi, DWORD dwFlags)
{
    assert(pmi);

    // We only care if the user double clicked on the name column
    if (pmi->iColumn != COL_NAME)
        return TRUE;

    // If the item is a folder, then set it as the current folder
    CFileObject *pfo = (CFileObject*)pmi->pvItem;
    if (pfo->m_fIsDir)
    {
        SetDir(pfo);
        g_vmExplorer.m_treeview.SetCurFolder(pfo);
        InvalidateRect(m_hwnd, NULL, TRUE);
    }
    
    // Return that we've handled the message.
    return FALSE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::Override_MouseMove
// Purpose:   If user moves the mouse over a checkbox, then hilight it.
// Arguments: pmi       -- Contains mouse state information.
//            dwFlags   -- Additional key state (Shift, Ctrl).
// Return:    'FALSE' if we've handled the message.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CExpListView::Override_MouseMove(sMouseInfo *pmi, DWORD dwFlags)
{
    assert(pmi);

    RECT rcCheckBox;
    POINT pt = {pmi->nX, pmi->nY};

    // We only care about the 'included' column
    if (pmi->iColumn != COL_INCLUDED)
        return TRUE;

    CFileObject *po = (CFileObject*)pmi->pvItem;
    assert(po);
 
    // Mouse is in column 0.  Are they in the checkbox?
    // Checkbox (12x12) is centered in the item
    rcCheckBox.left = pmi->rcSubItem.left + (pmi->rcSubItem.right -
                                         pmi->rcSubItem.left - CB_SIZE) / 2;
    rcCheckBox.right = rcCheckBox.left + CB_SIZE;
    rcCheckBox.top = pmi->rcSubItem.top + (pmi->rcSubItem.bottom -
                                        pmi->rcSubItem.top - CB_SIZE) / 2+1;
    rcCheckBox.bottom = rcCheckBox.top + CB_SIZE;
    if (!PtInRect(&rcCheckBox, pt))
    {
        // We're not in a checkbox
        if (m_iMouseOverItem != -1)
        {
            // We left a checkbox during the mouse move
            assert(m_poMouseOver);
            m_poMouseOver->m_fMouseOver = FALSE;
            RefreshItem(m_iMouseOverItem);
            m_iMouseOverItem = -1;
        }
        return TRUE;
    }
    
    if (m_iMouseOverItem != pmi->iRow && m_iMouseOverItem != -1)
    {
        // We scrolled out of a checkbox, and into a new one.  Unhighlight
        // the previously lit checkbox.
        assert(m_poMouseOver);
        m_poMouseOver->m_fMouseOver = FALSE;
        RefreshItem(m_iMouseOverItem);
    }

    // We're in a checkbox - highlight it.
    po->m_fMouseOver = TRUE;
    m_iMouseOverItem = pmi->iRow;
    m_poMouseOver = po;
    RefreshItem(m_iMouseOverItem);

    // Return that we handled the message
    return FALSE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::AddObject
// Purpose:   Adds a new object to the start of the listview.
// Arguments: pvObj     -- The object to Add
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CExpListView::AddObject(void *pvObj)
{
    assert(pvObj);

    CFileObject *pfo = (CFileObject *)pvObj;

    // Only add the object if it's a child of the current folder we're
    // displaying.
    if (pfo->m_pfoParent == m_pfoDisplay)
        AddItemAtIndex(pvObj, 0);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::RemoveObject
// Purpose:   Removes an object from the listview.
// Arguments: pvObj     -- The object to Remove
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CExpListView::RemoveObject(void *pvObj)
{
    assert(pvObj);

    CFileObject *pfo = (CFileObject*)pvObj;

    // If the user deleted the folder we were currently in, then move to the
    // parent object.
    if (pfo == m_pfoDisplay)
    {
        SetDir(pfo->m_pfoParent);
        return;
    }

    // If the user deleted a file in the listview, then remove it
    if (pfo->m_pfoParent == m_pfoDisplay)
        DeleteItem(pvObj);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CExpListView::RefreshObject
// Purpose:   Force an update of a particular object.  Only called when size
//            and/or time accessed of the object has changed.
// Arguments: pvObj     -- The objec to refresh
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CExpListView::RefreshObject(void *pvObj)
{
    // UNDONE: Unoptimized
    for (int i = 0; i < m_cItems; i++)
    {
        if (m_rgli[i].pvData == pvObj)
        {
            // Found it.  Update size and time
            ((CFileObject*)pvObj)->UpdateSizeTime();
            RefreshItem(i);
            m_fDirty = TRUE;
            break;
        }
    }
}

void CExpListView::UpdateCheckState()
{
    assert(m_pfoDisplay);

    CFileObject *pfoChild = m_pfoDisplay->m_lpfoChildren.GetFirst();
    
    // Shouldn't get here unless there's at least one child in the listview
    assert(pfoChild);

    // Determine the aggregate state of all objects in the current folder
    eCheckState csAggregate = pfoChild->m_checkstate;
    while ((pfoChild = m_pfoDisplay->m_lpfoChildren.GetNext()) != NULL)
    {
        if (pfoChild->m_checkstate != csAggregate)
        {
            csAggregate = CHECKSTATE_TRISTATE;
            break;
        }
    }
    
    // Has state of currently displayed object changed?
    if (csAggregate != m_pfoDisplay->m_checkstate)
    {
        g_vmExplorer.m_treeview.RecurseSetCheckState(m_pfoDisplay->m_hti,
                                                     csAggregate);
    }
}

void CExpListView::SetChildrenCheckState(CFileObject *pfo)
{
    assert(pfo);
    
    // set all child of 'pfo' to pfo's checkstate
    CFileObject *pfoChild = pfo->m_lpfoChildren.GetFirst();

    while (pfoChild)
    {
        pfoChild->m_checkstate = pfo->m_checkstate;
        if (pfoChild->m_fIsDir)
            SetChildrenCheckState(pfoChild);
        pfoChild = pfo->m_lpfoChildren.GetNext();
    }
}

void CExpListView::Notify_SelectChange(void *pvObj, BOOL fSelected)
{
    CFileObject *pfo = (CFileObject*)pvObj;

    if (pfo == NULL)
    {
        m_nSelected = 0;
        m_uliSelectedSize.QuadPart = 0;
        return;
    }

    // update 'space used'
    if (fSelected)
    {
        m_nSelected++;
        m_uliSelectedSize.QuadPart += pfo->m_uliSize.QuadPart;
    }
    else
    {
        m_nSelected--;
        m_uliSelectedSize.QuadPart -= pfo->m_uliSize.QuadPart;
        assert(m_nSelected >= 0);
    }

    // Update status bar
    char sz[100];
    int nObjects = m_pfoDisplay->m_lpfoChildren.GetCount();
    if (m_nSelected == 0)
    {
        sprintf(sz, "%d objects", nObjects);
        g_statusbar.SetText(0, sz);

        FormatByteString(m_pfoDisplay->m_lpfoChildren.GetSize(), sz);
        g_statusbar.SetText(1, sz);
    }
    else if (m_nSelected == 1)
    {
        // Which is selected object?
        CFileObject *pfoSelected;
        if (fSelected)
            pfoSelected = pfo;
        else
        {
            // find it
            for (int i = 0; i < m_cItems; i++)
                if (m_rgli[i].dwFlags & LVF_ITEMSELECTED)
                {
                    pfoSelected = (CFileObject*)m_rgli[i].pvData;
                    break;
                }
            assert(i < m_cItems);
        }
        sprintf(sz, "Type: %s  Date Modified: %s  Size: %s  Location: %s",
                pfoSelected->m_szType, pfoSelected->m_szModified,
                pfoSelected->m_szSize, pfoSelected->m_szLocation);
        
        g_statusbar.SetText(0, sz);
        g_statusbar.SetText(1, pfoSelected->m_szSize);
    }
    else
    {
        sprintf(sz, "%d objects selected", m_nSelected);        
        g_statusbar.SetText(0, sz);
        FormatByteString(m_uliSelectedSize, sz);
        g_statusbar.SetText(1, sz);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CInitedObject.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CInitedObject.h
// Contents: Contains the declaration of the CInitedObject object class.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CInitedObject
// Purpose: Tracks initialization state of an object.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CInitedObject
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CInitedObject        -- Standard constructor
    CInitedObject()
    {
        m_hrInit = E_FAIL;
    }


    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetInitCode          -- Returns the result of initialization
    HRESULT GetInitCode()
    {
        if (this == NULL)
            return E_FAIL;
        return m_hrInit;
    }

    // IsInited             -- Returns 'true' if the object was successfully initialized
    bool IsInited()
    {
        return GetInitCode() == S_OK;
    }


protected:

    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // SetInited            -- Allows a derived class to clear or set the initialized state to track
    //                         the derived class' initialization success.
    void SetInited(HRESULT hrInit)
    {
        m_hrInit = hrInit;
    }

private:

    // m_hrInit             -- Tracks the result of object initialization.
    HRESULT m_hrInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFile.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.h
// Contents:  
// Revisions: 8-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define FILE_MEMORY 0x0001
#define FILE_DISK   0x0002

#define FILE_READ   0x0004
#define FILE_WRITE  0x0008

class CFile : public CInitedObject
{
public:
    CFile(char *szName, DWORD dwFlags = FILE_READ | FILE_DISK);
    ~CFile();
    void Close();
    bool WriteData(void *pvData, DWORD cBytes);
    DWORD GetCurLoc();
    bool WriteWORD(WORD wData);
    bool WriteBYTE(BYTE byData);
    bool WriteDWORD(DWORD dwData);
    bool WriteString(char *sz);

    bool ReadData(void *pvData, DWORD cBytes);
    bool ReadBYTE(BYTE *pbyData);
    bool ReadWORD(WORD *pwData);
    bool ReadDWORD(DWORD *pdwData);
    bool ReadString(char *sz);

    // true if file is stored only in memory
    bool m_fMemoryFile;
    bool SetPos(DWORD dwPos);
    char m_szName[MAX_PATH];
    
private:
    HANDLE m_hfile;
    DWORD m_dwMemSize;
    BYTE *m_rgbyData;
    void IncreaseMemSize(DWORD cBytes);
    BYTE *m_pbyMemCur;
    bool m_fClosed;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.cpp
// Contents:  
// Revisions: 8-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <malloc.h>

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFile::CFile(char *szName, DWORD dwFlags) : CInitedObject()
{
    strcpy(m_szName, szName);
    m_fMemoryFile = dwFlags & FILE_MEMORY;
    if (m_fMemoryFile)
    {
        // File only exists in memory.  Allocate a block
        m_dwMemSize = 20000;
        m_rgbyData = (BYTE*)malloc(m_dwMemSize);
        if (!m_rgbyData)
            FatalError(E_OUTOFMEMORY);

        m_pbyMemCur = m_rgbyData;
    }
    else
    {
        // File exists on disk
        if (dwFlags & FILE_READ)
            m_hfile = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        else
            m_hfile = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (m_hfile == INVALID_HANDLE_VALUE)
        {
            m_fClosed = true;
            return;
        }
    }
    m_fClosed = false;
    SetInited(S_OK);
}

CFile::~CFile()
{
    Close();
}

void CFile::IncreaseMemSize(DWORD dwBytes)
{
    DWORD dwOrigSize = m_dwMemSize;

    assert(m_dwMemSize);
    while (m_dwMemSize < (m_pbyMemCur - m_rgbyData) + dwBytes)
    {
        assert(m_dwMemSize*2);
        m_dwMemSize *= 2;
    }

    if (dwOrigSize != m_dwMemSize)
    {
        DWORD dwOffset = m_pbyMemCur - m_rgbyData;
        m_rgbyData = (BYTE*)realloc(m_rgbyData, m_dwMemSize);
        if (!m_rgbyData)
            FatalError(E_OUTOFMEMORY);

        m_pbyMemCur = m_rgbyData + dwOffset;
    }
}

void CFile::Close()
{
    if (m_fClosed)
        return;

    if (m_fMemoryFile)
    {
        free(m_rgbyData);
    }
    else
        CloseHandle(m_hfile);

    m_fClosed = true;
}

bool CFile::WriteData(void *pvData, DWORD cBytes)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(cBytes);
        memcpy(m_pbyMemCur, pvData, cBytes);
        m_pbyMemCur += cBytes;
    }
    else
    {
        DWORD dwWritten;
        if (!WriteFile(m_hfile, (BYTE*)pvData, cBytes, &dwWritten, NULL) || dwWritten != cBytes)
            return false;
    }

    return true;

}
bool CFile::ReadData(void *pvData, DWORD cBytes)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(cBytes);
        memcpy(m_pbyMemCur, pvData, cBytes);
        m_pbyMemCur += cBytes;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, (BYTE*)pvData, cBytes, &dwRead, NULL) || dwRead != cBytes)
            return FALSE;
    }

    return TRUE;

}

DWORD CFile::GetCurLoc()
{
    if (m_fMemoryFile)
    {
        return m_pbyMemCur - m_rgbyData;
    }
    else
    {
        // NOTE: only works with files < 2^32 bytes.  However, the GDF_DIR_ENTRY 'filesize' var can only be that big, so presumably this is okay...
        return SetFilePointer(m_hfile, 0, NULL, FILE_CURRENT);
    }
}

bool CFile::WriteBYTE(BYTE byData)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(1);
        memcpy(m_pbyMemCur, &byData, 1);
        m_pbyMemCur += 1;
    }
    else
    {
        DWORD dwWritten;
        BYTE rgby[] = {byData};
        if (!WriteFile(m_hfile, rgby, 1, &dwWritten, NULL) || dwWritten != 1)
            return false;
    }
    return true;
}

bool CFile::WriteWORD(WORD wData)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(2);
        memcpy(m_pbyMemCur, &wData, 2);
        m_pbyMemCur += 2;
    }
    else
    {
        DWORD dwWritten;
        WORD rgw[] = {wData};
        if (!WriteFile(m_hfile, rgw, 2, &dwWritten, NULL) || dwWritten != 2)
            return false;
    }

    return true;
}


bool CFile::WriteDWORD(DWORD dwData)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(4);
        memcpy(m_pbyMemCur, &dwData, 4);
        m_pbyMemCur += 4;
    }
    else
    {
        DWORD dwWritten;
        DWORD rgdw[] = {dwData};
        if (!WriteFile(m_hfile, rgdw, 4, &dwWritten, NULL) || dwWritten != 4)
            return false;
    }
    return true;
}

bool CFile::WriteString(char *sz)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(strlen(sz)+4);
        if (!WriteDWORD(strlen(sz)))
            return false;
        memcpy(m_pbyMemCur, sz, strlen(sz));
        m_pbyMemCur += strlen(sz);
    }
    else
    {
        DWORD dwWritten;
        if (!WriteDWORD(strlen(sz)))
            return false;
        if (!WriteFile(m_hfile, sz, strlen(sz), &dwWritten, NULL) || dwWritten != strlen(sz))
            return false;
    }
    return true;
}

bool CFile::ReadBYTE(BYTE *pbyData)
{
    if (m_fMemoryFile)
    {
        memcpy(pbyData, m_pbyMemCur, 1);
        m_pbyMemCur += 1;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, pbyData, 1, &dwRead, NULL) || dwRead != 1)
            return false;
    }
    return true;
}

bool CFile::ReadWORD(WORD *pwData)
{
    if (m_fMemoryFile)
    {
        memcpy(pwData, m_pbyMemCur, 2);
        m_pbyMemCur += 2;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, pwData, 2, &dwRead, NULL) || dwRead != 2)
            return false;
    }
    return true;
}

bool CFile::ReadDWORD(DWORD *pdwData)
{
    if (m_fMemoryFile)
    {
        memcpy(pdwData, m_pbyMemCur, 4);
        m_pbyMemCur += 4;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, pdwData, 4, &dwRead, NULL) || dwRead != 4)
            return false;
    }
    return true;
}

bool CFile::ReadString(char *sz)
{
    if (m_fMemoryFile)
    {
        DWORD dwStrlen;
        if (!ReadDWORD(&dwStrlen))
            return false;
        memcpy(sz, m_pbyMemCur, dwStrlen);
        sz[dwStrlen] = '\0';
        m_pbyMemCur += dwStrlen;
    }
    else
    {
        DWORD dwStrlen, dwRead;
        if (!ReadDWORD(&dwStrlen))
            return false;
        if (!ReadFile(m_hfile, sz, dwStrlen, &dwRead, NULL) || dwRead != dwStrlen)
            return false;
        sz[dwStrlen] = '\0';
    }
    return true;
}

bool CFile::SetPos(DWORD dwPos)
{
    if (m_fMemoryFile)
        m_pbyMemCur = m_rgbyData + dwPos;
    else
        SetFilePointer(m_hfile, dwPos, 0, FILE_BEGIN);
    
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFileHierarchy.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFileHierarchy.h
// Contents:  
// Revisions: 13-Dec-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef enum eCheckState {CHECKSTATE_CHECKED, CHECKSTATE_UNCHECKED, CHECKSTATE_TRISTATE, CHECKSTATE_UNDEFINED};

class CFileObject;


class CFileHierarchy
{
public:
    CFileHierarchy() {};
    ~CFileHierarchy() {};
    BOOL Init() {m_pfiRoot = NULL; return TRUE;}
    BOOL SetRoot(char *szRootDir);
    BOOL Add(CFileObject *pfo);
    BOOL Remove(CFileObject *pfo);
    CFileObject *m_pfiRoot;
    char m_szRootDir[MAX_PATH];
    void RemoveAll();
    BOOL PersistTo(CFile *pfileDest);
    BOOL CreateFrom(CFile *pfileDest, char *szRoot);
    CFileObject *RecurseCreateFrom(CFile *pfileDest);

private:
    CFileObject *RecursePopulate(char *szFolder, WIN32_FIND_DATA *pwfd, int nDepth);
    void RemoveAllChildren(CFileObject *pfoFolder);

    // used for updating progress bar
    int m_cFiles, m_cFolders;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFileHierarchy.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFileHierarchy.cpp
// Contents:  
// Revisions: 14-Dec-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CFileHierarchy::SetRoot(char *szFolder)
{
    WIN32_FIND_DATA wfd;
    m_cFiles = 0;
    m_cFolders = 0;
    
    // Caller must have reset the file hierarchy first
    assert(m_pfiRoot == NULL);

    HANDLE hff = FindFirstFile(szFolder, &wfd);
    if (hff == INVALID_HANDLE_VALUE)
    {
        // The directory that we want to listen to doesn't actually exist!
        // undone: Caller must handle error!
        return FALSE;
    }
    FindClose(hff);
    
    m_pfiRoot = RecursePopulate(szFolder, &wfd, 1);
    assert(m_pfiRoot); // undone: handle this error
    sprintf(m_szRootDir, szFolder);

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CFileHierarchy::PersistTo(CFile *pfileDest)
{
    // Persist the contents of the file hierarchy to the specified file
    assert(pfileDest);
    assert(m_pfiRoot);
    return m_pfiRoot->PersistTo(pfileDest);
}

BOOL CFileHierarchy::CreateFrom(CFile *pfileDest, char *szRoot)
{
    assert(pfileDest);
    m_pfiRoot = new CFileObject(pfileDest);
    sprintf(m_szRootDir, szRoot);
    return m_pfiRoot && m_pfiRoot->m_fInited;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileHierarchy::RecursePopulate(char *szFolder,
                                             WIN32_FIND_DATA *pwfd,
                                             int nDepth)
{
    // Recursively populate the hierarchy with the specified folder
    char sz[MAX_PATH];
    WIN32_FIND_DATA wfd;

    CheckMessages();
    if (pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        m_cFolders++;
    else
        m_cFiles++;
    if (((m_cFolders + m_cFiles) % 27) == 0) // pick an off-# to make it look like it's updating more often
    {
        g_updatebox.SetFileCount(m_cFiles);
        g_updatebox.SetFolderCount(m_cFolders);
    }

    // Create the file object that will hold information about the object
    // called 'szPath' in the physical file system.
    CFileObject *pfi = new CFileObject(szFolder, pwfd);
    pfi->m_nDepth = nDepth;
    
    // By default, all files are included
    pfi->m_checkstate = CHECKSTATE_CHECKED;

    // If pfo is a dir, then recurse into it
    if (pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        // Find all files in the dir
        sprintf(sz, "%s\\*.*", szFolder);

        HANDLE hff = FindFirstFile(sz, &wfd);
        if (hff == INVALID_HANDLE_VALUE)
        {
            // Folder must have been deleted between the time RecursePopulate
            // was called and FindFirstFile was called.  We simply return
            // since there's nothing more to add!  The ForceUpdate call after
            // CFileHierarchy::SetRoot will ensure everything's uptodate.
            delete pfi;
            return NULL;
        }
        do
        {
            if (_stricmp(wfd.cFileName, ".") && _stricmp(wfd.cFileName, ".."))
            {
                // Found an object in the dir.  Recurse into it, and then
                // add the object to pfo's list of child objects
                sprintf(sz, "%s\\%s", szFolder, wfd.cFileName);
                pfi->AddChild(RecursePopulate(sz, &wfd, nDepth + 1));
            }        
        } while (FindNextFile(hff, &wfd));
        FindClose(hff);
    }

    // Return the file object that represents 'szName'.
    return pfi;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CFileHierarchy::Add(CFileObject *pfoChangeThread)
{
    // At this point, pfo is a ChangeThread fileObject; we create a new
    // FileObject for the MainThread (see the xbGameDisc technical specification
    // for a detailed description of why we do this - in short, reentrancy
    // issues and code complexity are not worth the trade off of memory usage).
    CFileObject *pfoNew = new CFileObject(pfoChangeThread);

    // Track the concordant changethread object so that we don't have to
    // search for pfoNew when file attribute changes occur
    pfoNew->m_pfoChangeThread = pfoChangeThread;
    pfoChangeThread->m_pfoMainThread = pfoNew;

    // The changethread object must have a parent object that was already
    // added to the MainThread hierarchy - thus we can simply obtain the 
    // MainThread parent object of the newly created object.
    CFileObject *pfoParent;
    pfoParent = pfoChangeThread->m_pfoOrigParent->m_pfoMainThread;

    assert(pfoParent);
    pfoParent->AddChild(pfoNew);

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CFileHierarchy::Remove(CFileObject *pfoChangeThread)
{
    CFileObject *pfoToRemove = pfoChangeThread->m_pfoMainThread;

    // Remove pfoToRemove from this hierarchy; the change thread will handle
    // removing pfoChangeThread from its hierarchy.
    CFileObject *pfoParent = pfoToRemove->m_pfoParent;
    assert(pfoParent);
    pfoParent->RemoveChild(pfoToRemove);
    delete pfoToRemove;
    
    return TRUE;
}

void CFileHierarchy::RemoveAll()
{
    if (m_pfiRoot)
    {
        // Delete all objects in the file hierarchy
        RemoveAllChildren(m_pfiRoot);
        delete m_pfiRoot;
        m_pfiRoot = NULL;
    }
}

void CFileHierarchy::RemoveAllChildren(CFileObject *pfoFolder)
{
    CFileObject *pfoChild;
    while ((pfoChild = pfoFolder->m_lpfoChildren.GetFirst()) != NULL)
    {
        RemoveAllChildren(pfoChild);
        pfoFolder->RemoveChild(pfoChild);
        delete pfoChild;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFileObject.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFileObject.cpp
// Contents:  
// Revisions: 29-Nov-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObjectNode::CFileObjectNode(CFileObject *pfo)
{
    m_pfo = pfo;
    pfo->m_pfon = this;
    m_pfonPrev = m_pfonNext = NULL;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObjectList::CFileObjectList()
{
    m_pfonHead = m_pfonCur = NULL;
    m_uliSize.QuadPart = 0;
    m_cObjects = 0;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CFileObjectList::Add(CFileObject *pfo)
{
    CFileObjectNode *pfonNew = new CFileObjectNode(pfo);
    if (m_pfonHead == NULL)
        m_pfonHead = pfonNew;
    else
    {
        pfonNew->m_pfonNext = m_pfonHead;
        m_pfonHead->m_pfonPrev = pfonNew;
        m_pfonHead = pfonNew;
    }
    m_cObjects++;
    m_uliSize.QuadPart += pfo->m_uliSize.QuadPart;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CFileObjectList::Remove(CFileObject *pfo)
{
    CFileObjectNode *pfon = pfo->m_pfon;
    if (pfon == m_pfonHead)
    {
        m_pfonHead = m_pfonHead->m_pfonNext;
        if (m_pfonHead)
            m_pfonHead->m_pfonPrev = NULL;
    }
    else
    {
        if (pfon->m_pfonPrev)
            pfon->m_pfonPrev->m_pfonNext = pfon->m_pfonNext;
        if (pfon->m_pfonNext)
            pfon->m_pfonNext->m_pfonPrev = pfon->m_pfonPrev;
    }
    if (pfon == m_pfonCur)
        m_pfonCur = NULL;
    delete pfo->m_pfon;
    pfo->m_pfon = NULL;
    m_uliSize.QuadPart -= pfo->m_uliSize.QuadPart;
    m_cObjects--;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileObjectList::GetByName(char *szName)
{
    CFileObjectNode *pfonCur = m_pfonHead;
    while (pfonCur)
    {
        if (!_stricmp(pfonCur->m_pfo->m_szName, szName))
            return pfonCur->m_pfo;
        pfonCur = pfonCur->m_pfonNext;
    }
    
    return NULL;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileObjectList::GetCur()
{
    if (m_pfonCur == NULL)
        return NULL;
    else
        return m_pfonCur->m_pfo;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileObjectList::GetFirst()
{
    m_pfonCur = m_pfonHead;
    return GetCur();
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileObjectList::GetNext()
{
    if (m_pfonCur == NULL)
        return GetFirst();
    m_pfonCur = m_pfonCur->m_pfonNext;
    return GetCur();
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFileObject::CFileObject(char *szObjName, WIN32_FIND_DATA *pwfd,
                         CChangeQueue *pcq)
{
    SYSTEMTIME stModified;
    FILETIME ft;

    // szObjName must contain full path string
    assert(strrchr(szObjName, '\\') != NULL);
    
    m_uliSize.HighPart = pwfd->nFileSizeHigh;
    m_uliSize.LowPart  = pwfd->nFileSizeLow;
    m_ftModified       = pwfd->ftLastWriteTime;
    m_fIsDir           = pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    
    m_pfoParent        = NULL;
    m_pfoChangeThread  = NULL;
    m_pfoMainThread    = NULL;

    m_hti  = NULL;
    m_checkstate = CHECKSTATE_CHECKED;
    m_nDepth = 0;
   

    // Type info
    m_fMouseOver = FALSE;
    sprintf(m_szPath, szObjName);
    strcpy(m_szName, pwfd->cFileName);
    strcpy(m_szLocation, "Excluded");

    m_dwa              = pwfd->dwFileAttributes;
    m_ftModified       = pwfd->ftLastWriteTime;
    m_uliSize.LowPart  = pwfd->nFileSizeLow;
    m_uliSize.HighPart = pwfd->nFileSizeHigh;
    m_fTypeInfoLoaded  = false;

    LoadTypeInfo();

    FileTimeToLocalFileTime(&m_ftModified, &ft);
    FileTimeToSystemTime(&ft, &stModified);
    char *pszAMPM;
    if (stModified.wHour > 12)
    {
        stModified.wHour -= 12;
        pszAMPM = "PM";
    }
    else
        pszAMPM = "AM";
    strcpy(m_szFolder, "undone");
    strcpy(m_szSizeOnDisk, "undone");
    strcpy(m_szSectorRange, "undone");

    sprintf(m_szModified, "%02d/%02d/%d  %d:%02d %s",
        stModified.wMonth, stModified.wDay, stModified.wYear,
        stModified.wHour, stModified.wMinute, pszAMPM);

    if (m_uliSize.QuadPart != 0)
    {
        char sz[1024];
        strcpy(sz, "                  ");
        FormatByteString(m_uliSize, sz);
        sprintf(m_szSize, sz);
    }
    else
        strcpy(m_szSize, "");

    m_pcq = pcq;
    m_fInited = true;
}

void CFileObject::UpdateSizeTime()
{
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    if (GetFileAttributesEx(m_szPath, GetFileExInfoStandard, &wfad) == 0)
    {
        // Couldn't find the file - must have been deleted; leave size/time
        // info alone.
        return;
    }

    m_ftModified      = wfad.ftLastWriteTime;
    m_uliSize.LowPart  = wfad.nFileSizeLow;
    m_uliSize.HighPart = wfad.nFileSizeHigh;

    SYSTEMTIME stModified;
    FILETIME ft;
    FileTimeToLocalFileTime(&m_ftModified, &ft);
    FileTimeToSystemTime(&ft, &stModified);
    char *pszAMPM;
    if (stModified.wHour > 12)
    {
        stModified.wHour -= 12;
        pszAMPM = "PM";
    }
    else
        pszAMPM = "AM";

    sprintf(m_szModified, "%02d/%02d/%d  %d:%02d %s",
        stModified.wMonth, stModified.wDay, stModified.wYear,
        stModified.wHour, stModified.wMinute, pszAMPM);

    if (m_uliSize.QuadPart != 0)
    {
        char sz[1024];
        FormatByteString(m_uliSize, sz);
        sprintf(m_szSize, sz);
    }
    else
        strcpy(m_szSize, "");
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject::CFileObject(CFileObject *pfoSource)
{
    // undone: copy constructor?
    // undone: copying unnecessary vars
    m_pfoParent = NULL;

    strcpy(m_szLocation, pfoSource->m_szLocation);
    strcpy(m_szName, pfoSource->m_szName);
    strcpy(m_szType, pfoSource->m_szType);
    strcpy(m_szSize, pfoSource->m_szSize);
    strcpy(m_szModified, pfoSource->m_szModified);
    strcpy(m_szPath, pfoSource->m_szPath);
    m_hti  = NULL;
    m_checkstate = CHECKSTATE_UNCHECKED;
    m_nDepth = 0;
    m_uliSize = pfoSource->m_uliSize;
    m_ftModified = pfoSource->m_ftModified;
    m_dwa = pfoSource->m_dwa;
    m_fIsDir = pfoSource->m_fIsDir;
    m_fMouseOver = FALSE;
    m_iIcon = pfoSource->m_iIcon;
    m_pfoChangeThread = NULL;
    m_pfoMainThread = NULL;
    m_pfon = NULL;
    m_pcq = NULL;

    strcpy(m_szFolder, "undone");
    strcpy(m_szSizeOnDisk, "undone");
    strcpy(m_szSectorRange, "undone");
    m_pfoInner = NULL;
    m_pfoOuter = NULL;
    m_fInited = true;
}

CFileObject::~CFileObject()
{
    if (m_pfoParent && m_pfon)
        m_pfoParent->RemoveChild(this);
    m_pfoParent = NULL;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CFileObject::AddChild(CFileObject *pfoChild)
{
    if (pfoChild == NULL)
        return;
    pfoChild->m_pfoParent = this;
    pfoChild->m_pfoOrigParent = this;
    m_lpfoChildren.Add(pfoChild);
    if (m_pcq)
        m_pcq->Enqueue(EVENT_ADDED, pfoChild);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CFileObject::RemoveChild(CFileObject *pfoChild)
{
    // Keep track of pointer to parent object for main thread wil need it.
    if (m_pcq == NULL)
        pfoChild->m_pfoParent = NULL;
    m_lpfoChildren.Remove(pfoChild);
    if (m_pcq)
        m_pcq->Enqueue(EVENT_REMOVED, pfoChild);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileObject::GetFirstChild()
{
    return m_lpfoChildren.GetFirst();
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileObject::GetNextChild()
{
    return m_lpfoChildren.GetNext();
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileObject *CFileObject::GetChildByName(char *szName)
{
    return m_lpfoChildren.GetByName(szName);
}

// Write this object's contents to the specified destination file
BOOL CFileObject::PersistTo(CFile *pfileDest)
{
    char *szRelPath = m_szPath + strlen(g_szRootDir);
    if (!pfileDest->WriteString(szRelPath) || 
        !pfileDest->WriteString(m_szLocation) ||        // recreate?
        !pfileDest->WriteString(m_szType) ||            // recreate?
        !pfileDest->WriteString(m_szSize) ||            // recreate?
        !pfileDest->WriteString(m_szModified) ||
        !pfileDest->WriteDWORD(m_checkstate) ||
        !pfileDest->WriteDWORD(m_nDepth) ||
        !pfileDest->WriteData(&m_uliSize, sizeof m_uliSize) ||
        !pfileDest->WriteData(&m_ftModified, sizeof m_ftModified) ||
        !pfileDest->WriteDWORD(m_dwa) ||
        !pfileDest->WriteString(m_szFolder) ||          // recreate?
        !pfileDest->WriteString(m_szSizeOnDisk) ||      // recreate?
        !pfileDest->WriteString(m_szSectorRange) ||     // recreate?
        !pfileDest->WriteDWORD(m_lpfoChildren.GetCount()))
        return FALSE;        

    // Recurse into children
    CFileObject *pfoChild = m_lpfoChildren.GetFirst();
    while (pfoChild)
    {
        if (!pfoChild->PersistTo(pfileDest))
            return FALSE;
        pfoChild = m_lpfoChildren.GetNext();
    }

    return TRUE;
}

CFileObject::CFileObject(CFile *pfileSrc)
{
    char szRelPath[MAX_PATH];
    DWORD nChildren;
    if (!pfileSrc->ReadString(szRelPath) || 
        !pfileSrc->ReadString(m_szLocation) ||      // recreate?
        !pfileSrc->ReadString(m_szType) ||          // recreate?
        !pfileSrc->ReadString(m_szSize) ||          // recreate?
        !pfileSrc->ReadString(m_szModified) ||
        !pfileSrc->ReadDWORD((DWORD*)&m_checkstate) ||
        !pfileSrc->ReadDWORD((DWORD*)&m_nDepth) ||
        !pfileSrc->ReadData(&m_uliSize, sizeof m_uliSize) ||
        !pfileSrc->ReadData(&m_ftModified, sizeof m_ftModified) ||
        !pfileSrc->ReadDWORD(&m_dwa) ||
        !pfileSrc->ReadString(m_szFolder) ||        // recreate?
        !pfileSrc->ReadString(m_szSizeOnDisk) ||    // recreate?
        !pfileSrc->ReadString(m_szSectorRange) ||   // recreate?
        !pfileSrc->ReadDWORD(&nChildren))
        return;

    // Generate path and name from szRelPath
    sprintf(m_szPath, "%s%s", g_szRootDir, szRelPath);
    if (strrchr(szRelPath, '\\'))
        strcpy(m_szName, strrchr(szRelPath, '\\') + 1);
    else
    {
        strcpy(m_szName, "");
    }
    
    m_hti        = NULL;
    m_fIsDir     = m_dwa & FILE_ATTRIBUTE_DIRECTORY ? true : false;
    m_fMouseOver = FALSE;
    m_iIcon      = 0;
    m_pfon       = NULL;
    m_pcq        = NULL;
    m_pfoInner   = NULL;
    m_pfoOuter   = NULL;
    m_pfoParent  = NULL;
    m_pfoChangeThread = NULL;
    m_pfoMainThread   = NULL;
    m_fTypeInfoLoaded = false;
  
    LoadTypeInfo();

    // Recurse into children
    for (DWORD i = 0; i < nChildren; i++)
    {
        CFileObject *pfoChild = new CFileObject(pfileSrc);
        if (!pfoChild->m_fInited)
            return;
        AddChild(pfoChild);
    }

    m_fInited = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFileObject.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFileObject.h
// Contents:  
// Revisions: 29-Nov-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


class CFileObject;

class CFileObjectNode
{
    friend class CFileObjectList;
    CFileObjectNode(CFileObject *pfo);
    CFileObject *m_pfo;
    CFileObjectNode *m_pfonPrev, *m_pfonNext;
};

class CFileObjectList
{
public:

    CFileObjectList();
    void Add(CFileObject *pobj);
    void Remove(CFileObject *pobj);
    CFileObject *GetByName(char *szName);
    CFileObject *GetFirst();
    CFileObject *GetCur();
    CFileObject *GetNext();
    ULARGE_INTEGER GetSize() {return m_uliSize;}
    DWORD GetCount() {return m_cObjects; }
private:
    int m_cObjects;
    ULARGE_INTEGER m_uliSize;
    CFileObjectNode *m_pfonCur;
    CFileObjectNode *m_pfonHead;
};

class CFileObject
{
public:
    CFileObject(char *szObjName, WIN32_FIND_DATA *pwfd,
                CChangeQueue *pcq = NULL);
    CFileObject(CFileObject *pfoSource);
    CFileObject(CFile *pfileSrc);

    ~CFileObject();
    void AddChild(CFileObject *pfoChild);
    void RemoveChild(CFileObject *pfoChild);
    CFileObject *GetFirstChild();
    CFileObject *GetNextChild();
    CFileObject *GetChildByName(char *szName);

    BOOL PersistTo(CFile *pfileDest);

    void UpdateSizeTime();
    void LoadTypeInfo();

    // File attribute information (name, size, etc)
    CFileObject *m_pfoParent;
    CFileObject *m_pfoOrigParent;   // This is necessary since the cq obj may have been removed from its parent!
    char m_szName[MAX_PATH];
    char m_szPath[MAX_PATH];
    ULARGE_INTEGER m_uliSize;
    FILETIME m_ftModified;
    CFileObjectList m_lpfoChildren;
    BOOL m_fIsDir;
    DWORD m_dwa;              // File attributes

    // ChangeThread-related information
    CFileObjectNode *m_pfon;
    CChangeQueue *m_pcq;
    CFileObject *m_pfoChangeThread, *m_pfoMainThread;

    
    // Information displayed in the Explorer View
    HTREEITEM m_hti;
    eCheckState m_checkstate;
    int m_nDepth;

    char m_szType[255];     // Type of the file (Application, DLL, etc)
    char m_szSize[30];      // String representation of liSize
    char m_szModified[30];  // String representation of ftModified
    char m_szLocation[15];  // Excluded, Unplaced, Layer 0, or Layer 1
    int  m_iIcon;           // Index into the list of system icons
    BOOL m_fMouseOver;      // Used for highlighting the 'included' checkbox


    // Information displayed in the Layer view
    char m_szFolder[MAX_PATH]; 
    char m_szSizeOnDisk[20]; 
    char m_szSectorRange[30];
    CFileObject *m_pfoInner;
    CFileObject *m_pfoOuter;

    bool m_fInited;
    HIMAGELIST m_himl;
    HICON m_hIcon;

private:
    bool m_fTypeInfoLoaded;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CFileObject_LoadTypeInfo.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFileObject_LoadTypeInfo.cpp
// Contents:  
// Revisions: 28-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ TYPEDEFS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct {
    char szExt[MAX_PATH];
    char szType[MAX_PATH];
    HIMAGELIST himl;
    int iIcon;
} sTypeInfo;


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ STATIC GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

sTypeInfo g_tiFolder = {NULL};
sTypeInfo g_tiFile   = {NULL};

static sTypeInfo *g_rgiconexts = NULL;
static int g_cLoadedExts    = 0;
static int g_cMaxLoadedExts = 0;


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CFileObject::LoadTypeInfo()
{
    SHFILEINFO sfi;
    if (!m_fTypeInfoLoaded)
    {
        // Have we already loaded the icon information for this type of file?
        if (m_fIsDir)
        {
            // Loaded dir icon?
            if (g_tiFolder.himl == NULL)
            {
                g_tiFolder.himl = (HIMAGELIST)SHGetFileInfo(m_szPath, 0, &sfi,
                                                         sizeof(sfi),
                                                         SHGFI_SYSICONINDEX |
                                                         SHGFI_SMALLICON |
                                                         SHGFI_TYPENAME);
                g_tiFolder.iIcon = sfi.iIcon;
                strcpy(g_tiFolder.szType, sfi.szTypeName);
            }
            m_himl = g_tiFolder.himl;
            m_iIcon = g_tiFolder.iIcon;
            strcpy(m_szType, g_tiFolder.szType);
        }
        else
        {
            // Search by extension
            char *pszExt = strrchr(m_szPath, '.');
            if (pszExt == NULL)
            {
                // Force default extension; we could load the file's actual
                // icon, but it's not worth the perf hit
                if (g_tiFile.himl == NULL)
                {
                    g_tiFile.himl = (HIMAGELIST)SHGetFileInfo(m_szPath, 0, &sfi,
                                                        sizeof(sfi),
                                                        SHGFI_SYSICONINDEX |
                                                        SHGFI_SMALLICON |
                                                        SHGFI_TYPENAME);
                    g_tiFile.iIcon = sfi.iIcon;
                    strcpy(g_tiFile.szType, sfi.szTypeName);
                }
                m_himl = g_tiFile.himl;
                m_iIcon = g_tiFile.iIcon;
                strcpy(m_szType, g_tiFile.szType);
            }
            else
            {
                // Has extension already been loaded?
                // undone-perf: for now, array is fine, although eventually may
                // want to move to hash.
                bool fLoad = true;
                for (int i = 0; i < g_cLoadedExts; i++)
                {
                    if (!_stricmp(g_rgiconexts[i].szExt, pszExt))
                    {
                        // Found it
                        m_himl = g_rgiconexts[i].himl;
                        m_iIcon = g_rgiconexts[i].iIcon;
                        strcpy(m_szType, g_rgiconexts[i].szType);
                        fLoad = false;
                        break;
                    }
                }

                if (fLoad)
                {
                    m_himl = (HIMAGELIST)SHGetFileInfo(m_szPath, 0, &sfi, sizeof(sfi),
                                  SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_TYPENAME);
                    m_iIcon = sfi.iIcon;
                    strcpy(m_szType, sfi.szTypeName);

                    // Add to list
                    if (g_rgiconexts == NULL ||
                        g_cLoadedExts >= g_cMaxLoadedExts)
                    {
                        g_cMaxLoadedExts += 20;
                        g_rgiconexts = (sTypeInfo*)realloc(g_rgiconexts,
                                       g_cMaxLoadedExts * sizeof sTypeInfo);
                    }
                    g_rgiconexts[g_cLoadedExts].iIcon = m_iIcon;
                    g_rgiconexts[g_cLoadedExts].himl = m_himl;
                    strcpy(g_rgiconexts[g_cLoadedExts].szExt, pszExt);
                    strcpy(g_rgiconexts[g_cLoadedExts].szType, sfi.szTypeName);
                    g_cLoadedExts++;
                }
            }
        }
        m_fTypeInfoLoaded = true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CLayerListView.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      clistview.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define NUM_COLUMNS 6


class CLayerListView : public CMyListView
{
public:
    BOOL Init(HWND hwndParent);
    void UpdateItem(void *pvItem, DWORD dwItemState, int iColumn, HDC hdcDest, RECT *prcDest);
    DWORD GetItemWidth(HDC hdc, void *pvItem, int iColumn);

    int CompareObjects(const void *pv1, const void *pv2);

    virtual BOOL Override_LButtonDblClick(sMouseInfo *pmi, DWORD dwFlags);
    virtual BOOL Override_LButtonDown(sMouseInfo *pmi, DWORD dwFlags);
    virtual BOOL Override_MouseMove(sMouseInfo *pmi, DWORD dwFlags);

    void SetDir(CFileObject *pfoFolder);
    void AddObject(void *pvObj);
    void RemoveObject(void *pvObj);
    void RefreshObject(void *pvObj);

private:
    HFONT m_hfont;
    HIMAGELIST m_himlFileIcons;
    CFileObject *m_pfoDisplay;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CLayerListView.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CLayerListView.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

enum {COL_NAME = 0, COL_FOLDER, COL_SIZEONDISK, COL_SECTORRANGE};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CLayerListView::SetDir
// Purpose:   Populate the list view with the contents of the specified folder
// Arguments: 
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CLayerListView::SetDir(CFileObject *pfoFolder)
{
    assert(pfoFolder);
    assert(this);

    CFileObject *pfoChild = pfoFolder->m_lpfoChildren.GetFirst();

    // Erase contents from previous entry
    Clear();

    m_pfoDisplay = pfoFolder;
    
    // Add the child objects
    if (pfoChild == NULL)
        InvalidateRect(m_hwnd, NULL, FALSE);

    while (pfoChild)
    {
        AddItemAtIndex(pfoChild, 0);
        pfoChild = pfoFolder->m_lpfoChildren.GetNext();
    }

    m_fDirty = true;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CLayerListView::Init
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CLayerListView::Init(HWND hwndParent)
{
    // initialize our 'MyListView' object.
    if (!CMyListView::Init(hwndParent))
        return FALSE;

    SHFILEINFO sfi;
    ZeroMemory(&sfi, sizeof(sfi));
    DWORD flg = SHGFI_ICON | SHGFI_SMALLICON | SHGFI_SYSICONINDEX;
    m_himlFileIcons = (HIMAGELIST)SHGetFileInfo("C:\\", 0, &sfi, sizeof(sfi), flg);

    // init columns for listview
    // NOTE: Order must match order in COL_* enumeration
    AddColumn("Name", 150);
    AddColumn("Folder", 250);
    AddColumn("Size on Disk", 75);
    AddColumn("Sector Range", 100);

    // Create the GDI font object
    LOGFONT lf;
    memset(&lf, 0, sizeof(lf));
    lf.lfHeight = -11;
    lf.lfWeight = 0;
    strcpy(lf.lfFaceName, "Tahoma");
    m_hfont = CreateFontIndirect(&lf);

    m_iSortColumn = COL_NAME;
    return TRUE;
}

#define LVF_ITEMSELECTED 1
#define LVF_ITEMFOCUSED  2
 
void CLayerListView::UpdateItem(void *pvItem, DWORD dwItemState, int iColumn, HDC hdcDest, RECT *prcDest)
{
    char *psz;
    int nW;
    CFileObject *pfo = (CFileObject*)pvItem;
    DWORD dwAlign = DT_LEFT;

    // if prcClip is NULL, then the item is completely offscreen
    if (prcDest == NULL)
        return;

    // undone: Can choose to use offscreenbuffer only when resizing if so desire (not really necessary for scroll/update)
#define OFFSCREENBUFFER
#ifdef OFFSCREENBUFFER
    static HBITMAP s_hbmpOff;
    static int s_nLastWidth = -1, s_nLastHeight = -1;
    RECT rcOrig = *prcDest;
    prcDest->bottom -= prcDest->top;
    prcDest->top = 0;
    prcDest->right -= prcDest->left;
    prcDest->left = 0;
    
    HDC hdcOffscreen = CreateCompatibleDC(hdcDest);
    if (prcDest->right - prcDest->left > s_nLastWidth  || prcDest->bottom - prcDest->top > s_nLastHeight)
    {
        s_hbmpOff = CreateCompatibleBitmap(hdcDest, prcDest->right - prcDest->left,
                                           prcDest->bottom - prcDest->top);
        s_nLastWidth = prcDest->right - prcDest->left;
        s_nLastHeight = prcDest->bottom - prcDest->top;
        DebugOutput("create (%d, %d)\n", s_nLastWidth, s_nLastHeight);
    }
    HBITMAP hbmpPrevOff = (HBITMAP)SelectObject(hdcOffscreen, s_hbmpOff);
#else
    HDC hdcOffscreen = hdcDest;
#endif
    SelectObject(hdcOffscreen, m_hfont);
    if (dwItemState & LVF_ITEMSELECTED)
    {
        if (dwItemState & LVF_ITEMFOCUSED)
        {
            FillRect(hdcOffscreen, prcDest, GetSysColorBrush(COLOR_HIGHLIGHT));
            SetBkColor(hdcOffscreen, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(hdcOffscreen, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            FillRect(hdcOffscreen, prcDest, GetSysColorBrush(COLOR_INACTIVEBORDER));
            SetBkColor(hdcOffscreen, GetSysColor(COLOR_INACTIVEBORDER));
            SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOWTEXT));
        }
    }
    else
    {
        FillRect(hdcOffscreen, prcDest, GetSysColorBrush(COLOR_WINDOW));
        SetBkColor(hdcOffscreen, GetSysColor(COLOR_WINDOW));
        SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOWTEXT));
    }
    if (iColumn != 0)
    {
        prcDest->right -= 5;
        prcDest->top ++;
    }

    switch(iColumn)
    {
    case COL_NAME:
        nW = min(GetSystemMetrics(SM_CXSMICON), prcDest->right - prcDest->left);
        if (nW > 0 && pfo->m_fIsDir)
        {
            DWORD dwFlags = ILD_TRANSPARENT | ILD_NORMAL;
            if (dwItemState & LVF_ITEMSELECTED && dwItemState & LVF_ITEMFOCUSED)
                dwFlags |= ILD_SELECTED;
            ImageList_Draw(m_himlFileIcons, pfo->m_iIcon, hdcOffscreen, prcDest->left, prcDest->top, dwFlags);
            prcDest->left += 20;
        }

        psz = pfo->m_szName;
        break;

    case COL_FOLDER:      psz = pfo->m_szFolder;      break;
    case COL_SIZEONDISK:  psz = pfo->m_szSizeOnDisk;  break;
    case COL_SECTORRANGE: psz = pfo->m_szSectorRange; break;
    }
    if (psz)
        DrawTextEx(hdcOffscreen, psz, strlen(psz), prcDest, dwAlign | DT_END_ELLIPSIS, NULL);
#ifdef OFFSCREENBUFFER
    BitBlt(hdcDest, rcOrig.left, rcOrig.top,
           rcOrig.right - rcOrig.left, rcOrig.bottom - rcOrig.top,
           hdcOffscreen, 0, 0, SRCCOPY);
    SelectObject(hdcOffscreen, hbmpPrevOff);
    DeleteDC(hdcOffscreen);
#endif
}

DWORD CLayerListView::GetItemWidth(HDC hdc, void *pvItem, int iColumn)
{
    CFileObject *pfo = (CFileObject*)pvItem;
    SIZE    size;
    char    *psz;
    int     nAdd = 0;

    switch(iColumn)
    {
    case COL_NAME:        psz = pfo->m_szName;     if (pfo->m_fIsDir) nAdd = 20; break;
    case COL_FOLDER:      psz = pfo->m_szFolder;      break;
    case COL_SIZEONDISK:  psz = pfo->m_szSizeOnDisk;  break;
    case COL_SECTORRANGE: psz = pfo->m_szSectorRange; break;
    }

    GetTextExtentPoint32(hdc, psz, strlen(psz), &size);
    SetTextJustification(hdc, 0, 0);
    return size.cx + nAdd + 5; // +5 for the padding we add during drawing
}

// return -1 if pv1 is "less than" pv2
// return 1 if pv2 is "less than" pv1
// return 0 if pv1 "equals" pv2
int CLayerListView::CompareObjects(const void *pv1, const void *pv2)
{
    int nRet;

    // pv1 and pv2 are passed in as pointers to array elements.  Do
    // some wacky casting to get the actual object pointers.
    CFileObject *po1 = ((CFileObject*)*(DWORD*)pv1);
    CFileObject *po2 = ((CFileObject*)*(DWORD*)pv2);

    // If one of the objects is a directory and the other isn't, then the directory
    // always comes first
    bool f1 = po1->m_dwa & FILE_ATTRIBUTE_DIRECTORY ? true : false;
    bool f2 = po2->m_dwa & FILE_ATTRIBUTE_DIRECTORY ? true : false;
    if (f1 && !f2)
        return -1;
    if (f2 && !f1)
        return 1;

    switch(m_iSortColumn)
    {
    case COL_NAME:
        return _stricmp(po1->m_szName, po2->m_szName);

    case COL_FOLDER:
        nRet = _stricmp(po1->m_szFolder, po2->m_szFolder);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;

    case COL_SIZEONDISK:
        nRet = _stricmp(po1->m_szSizeOnDisk, po2->m_szSizeOnDisk);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;

    case COL_SECTORRANGE:
        nRet = _stricmp(po1->m_szSectorRange, po2->m_szSectorRange);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;
    }
    assert(true);
    return 0;
}

BOOL CLayerListView::Override_LButtonDown(sMouseInfo *pmi, DWORD dwFlags)
{
    return TRUE;
}

BOOL CLayerListView::Override_LButtonDblClick(sMouseInfo *pmi, DWORD dwFlags)
{
    return TRUE;
}

BOOL CLayerListView::Override_MouseMove(sMouseInfo *pmi, DWORD dwFlags)
{
    return TRUE;
}

void CLayerListView::AddObject(void *pvObj)
{
    CFileObject *pfo = (CFileObject *)pvObj;

    // Only add the object if it's a child of the current folder we're displaying
    if (pfo->m_pfoParent == m_pfoDisplay)
        AddItemAtIndex(pvObj, 0);
}

void CLayerListView::RemoveObject(void *pvObj)
{
    CFileObject *pfo = (CFileObject*)pvObj;

    // If the user deleted the folder we were currently in, then go to the parent object
    if (pfo == m_pfoDisplay)
    {
        SetDir(pfo->m_pfoParent);
        return;
    }

    // If the user deleted a file in the listview, then remove it
    if (pfo->m_pfoParent == m_pfoDisplay)
    {
        DeleteItem(pvObj);
    }  
}

void CLayerListView::RefreshObject(void *pvObj)
{
    // UNDONE: very unoptimized
    for (int i = 0; i < m_cItems; i++)
    {
        if (m_rgli[i].pvData == pvObj)
        {
            // Found it.  Update size and time
            ((CFileObject*)pvObj)->UpdateSizeTime();
            RefreshItem(i);
            m_fDirty = true;
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CMyListView.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CMyListView.cpp
// Contents:  
// Revisions: 6-Nov-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"
#include <zmouse.h>

bool gs_fInitedListViewClasses = false;
CMyListView *g_pmlvTemp = NULL;

#define LVF_FOCUSITEM    4 // internal use only

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LRESULT CALLBACK MyListViewWndProc(HWND hwnd, UINT uMsg, WPARAM wparam,
                                   LPARAM lparam)
{
    // Thunk over to the actual ListView object.
    CMyListView *pmlv = (CMyListView*)GetWindowLong(hwnd, GWL_USERDATA);
    if (!pmlv)
    {
        assert(g_pmlvTemp);
        pmlv = g_pmlvTemp;
        pmlv->m_hwnd = hwnd;
        g_pmlvTemp = NULL;
        SetWindowLong(hwnd, GWL_USERDATA, (long)pmlv);
    }
    return pmlv->WndProc(uMsg, wparam, lparam);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CMyListView::Init(HWND hwndParent)
{
    WNDCLASSEX wcex;

    if (!gs_fInitedListViewClasses)
    {
        // Register the class for the app's window.
        memset(&wcex, 0, sizeof wcex);
        wcex.cbSize         = sizeof(WNDCLASSEX); 
        wcex.style          = CS_HREDRAW | CS_VREDRAW |CS_DBLCLKS;
        wcex.lpfnWndProc    = (WNDPROC)MyListViewWndProc;
        wcex.hInstance      = g_hInst;
        wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
        wcex.lpszClassName  = "MyListView";
        if (!RegisterClassEx(&wcex))
            return FALSE;
        
        gs_fInitedListViewClasses = true;
    }

    m_iFocusItem = -1;

    // Create the GDI font object
    LOGFONT lf;
    memset(&lf, 0, sizeof(lf));
    lf.lfHeight = -11;
    lf.lfWeight = 0;
    strcpy(lf.lfFaceName, "Tahoma");
    m_hfont = CreateFontIndirect(&lf);

    m_nCurHScrollLoc = 0;
    m_nMaxHScroll = 0;
    m_nCurVScrollLoc = 0;
    m_nMaxVScroll = 0;

    m_fHaveFocus = false;
    m_iShiftItem = -1;

    m_fInvertSort = false;
    m_cItems = 0;
    m_nItemHeight = 17;

    m_cMaxItems = 0;
    m_cAddItemDelta = 100;
    m_rgli = NULL;

    m_fDirty = FALSE;

    // Warning: this is not reentrant!
    assert(g_pmlvTemp == NULL);
    g_pmlvTemp = this;
    CreateWindow("MyListView", "", WS_CHILD | WS_HSCROLL | WS_VSCROLL |
                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE, 0, 0, 0, 0,
                 hwndParent, (HMENU)WNDID_LISTVIEW, g_hInst, NULL);
    if (m_hwnd == NULL)
        return FALSE;

    // Add our column (header) control
    if (!InitHeader())
        return FALSE;

    SendMessage(m_hwndHeader, WM_SETFONT, (WPARAM)m_hfont, FALSE);

    // Initialize the scroll bars
    ShowScrollBar(m_hwnd, SB_VERT, false);
    ShowScrollBar(m_hwnd, SB_HORZ, false);

    m_iSortColumn = -1;

    return TRUE;
}

bool m_fMouseDown = false;
LRESULT CMyListView::WndProc(UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    LPNMHEADER pnmhdr;
    LPHDITEM   phdi;
    SCROLLINFO si;
    int        nDelta;
    
//    TrackMessage(uMsg, wparam, lparam, "ListView");

    switch(uMsg)
    {
    case WM_PAINT:
        UpdateListDisplay();
        break;

    case WM_ERASEBKGND:
        return 1;
        
    case WM_NOTIFY:
        pnmhdr = (LPNMHEADER)lparam;
        switch(pnmhdr->hdr.code)
        {
        case HDN_ITEMCHANGED:
            // User is moving (resizing) a divider.  Update the columns.
            phdi = pnmhdr->pitem;
            m_rgnColWidths[pnmhdr->iItem] = phdi->cxy;
            UpdateColumnWidths();
            UpdateScrollBars();
            InvalidateRect(m_hwnd, NULL, TRUE);
            // Update the position of the header control in case it's been scrolled.
            // Note that this creates slightly strange behaviour, but the behaviour
            // exactly mimics what WinXP does, so, when in rome...
            // (example: shrink window so that horz scroll bar appears; scroll
            //  window all the way to the right; shrink one of the column headers;
            //  RESULT: The whole column quickly shrinks).
            SetWindowPos(m_hwndHeader, NULL, -m_nCurHScrollLoc, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
            break;

        case HDN_ITEMCLICK:
            // User clicked a column header. need to sort by that column
            SortColumn(pnmhdr->iItem);
            break;
            
        case HDN_DIVIDERDBLCLICK:
            // User double clicked a header divider.  Resize the column to
            // the maximum length of the contents of that column in any row.
            HandleHeaderDoubleClick(pnmhdr);
            break;
        }
        break;

    case IDM_EDIT_SELECTALL:
        SelectAllItems();
        break;

    case WM_DRAWITEM:
        if (wparam == WNDID_LISTVIEW_HEADER)
        {
            DrawHeader((LPDRAWITEMSTRUCT)lparam);
            return TRUE;
        }
        break;

    case WM_HSCROLL: 
        si.cbSize = sizeof(si); 
        si.fMask  = SIF_ALL; 
        GetScrollInfo(m_hwnd, SB_HORZ, &si);

        switch (LOWORD(wparam)) 
        { 
        case SB_PAGEUP:     nDelta = -100; break; 
        case SB_PAGEDOWN:   nDelta = 100;  break; 
        case SB_LINEUP:     nDelta = -5;   break; 
        case SB_LINEDOWN:   nDelta = 5;    break; 
        case SB_THUMBTRACK: nDelta = HIWORD(wparam) - si.nPos; break;
        default:            nDelta = 0;    break;
        }

        nDelta = max(-si.nPos, min(nDelta, (int)(si.nMax -
                                                 (si.nPos + si.nPage))));
        if (nDelta)
        {
            si.nPos += nDelta;
            m_nCurHScrollLoc = si.nPos;
            SetScrollInfo(m_hwnd, SB_HORZ, &si, TRUE);
            ScrollWindowEx(m_hwnd, -nDelta, 0, NULL, NULL,
                           NULL, NULL, 0);
            RECT rc;
            GetClientRect(m_hwnd, &rc);
            MoveWindow(m_hwndHeader, -m_nCurHScrollLoc, 0, rc.right - rc.left +
                       m_nCurHScrollLoc, m_nHeaderHeight, TRUE);

            InvalidateRect(m_hwnd, NULL, TRUE);
            UpdateWindow(m_hwndHeader);
        }
        break;

    case WM_LBUTTONDOWN: HandleButtonDown(LOWORD(lparam), HIWORD(lparam), wparam); break;
    case WM_LBUTTONDBLCLK: HandleButtonDblClick(LOWORD(lparam), HIWORD(lparam), wparam); break;
    case WM_LBUTTONUP:   HandleButtonUp(LOWORD(lparam), HIWORD(lparam), wparam);   break;
    case WM_MOUSEMOVE:   HandleMouseMove(LOWORD(lparam), HIWORD(lparam), wparam);  break;

    case WM_SETFOCUS:
         g_hwndPrevFocus = m_hwnd;
         m_fHaveFocus = true;
         m_iShiftItem = m_iFocusItem;
         UpdateAllItems();
         break;

    case WM_KILLFOCUS:
         m_fHaveFocus = false;
         UpdateAllItems();
         break;

    case WM_KEYDOWN:
        si.cbSize = sizeof(si); 
        si.fMask  = SIF_ALL; 
        GetScrollInfo(m_hwnd, SB_VERT, &si);

        switch (wparam)
        {
        case VK_SHIFT:
            // only update if shift wasn't previously pressed (ie ignore autorepeat)
            if ((lparam & 0x40000000) == 0)
                m_iShiftItem = m_iFocusItem;
            break;

        default:
            HandleKeyDown(wparam);
            break;
        }
        break;

    case WM_MOUSEWHEEL:
    case WM_VSCROLL: 
        si.cbSize = sizeof(si); 
        si.fMask  = SIF_ALL; 
        GetScrollInfo(m_hwnd, SB_VERT, &si);

        if (uMsg == WM_MOUSEWHEEL)
        {
            if ((short)HIWORD(wparam) > 0)
                nDelta = -m_nItemHeight;
            else
                nDelta = m_nItemHeight;
        }
        else
        {
            switch (LOWORD(wparam)) 
            { 
            case SB_PAGEUP:     nDelta = -((int)si.nPage - m_nItemHeight); break; 
            case SB_PAGEDOWN:   nDelta = ((int)si.nPage - m_nItemHeight);  break; 
            case SB_LINEUP:     nDelta = -m_nItemHeight;          break; 
            case SB_LINEDOWN:   nDelta = m_nItemHeight;           break; 
            case SB_THUMBTRACK: nDelta = si.nTrackPos - si.nPos;  break;
            default:            nDelta = 0;                       break;
            }
        }

        nDelta = max(-si.nPos, min(nDelta, (int)(si.nMax -
                                                 (si.nPos + si.nPage))));
        nDelta = (nDelta / m_nItemHeight) * m_nItemHeight;
        if (nDelta)
        {
            si.nPos += nDelta;
            si.nPos = (si.nPos / m_nItemHeight) * m_nItemHeight;
            m_nCurVScrollLoc = si.nPos;
            SetScrollInfo(m_hwnd, SB_VERT, &si, TRUE);
            ScrollWindowEx(m_hwnd, 0, -nDelta, NULL, NULL,
                           NULL, NULL, 0);
            RECT rc;
            GetClientRect(m_hwnd, &rc);

            if (nDelta < 0)
                rc.bottom = rc.top - nDelta + m_nHeaderHeight;
            else
                rc.top = rc.bottom - nDelta;

            InvalidateRect(m_hwnd, &rc, TRUE);
            UpdateWindow(m_hwnd);
        }
        break;
    }

    return DefWindowProc(m_hwnd, uMsg, wparam, lparam);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SortObjects
// Purpose:   Comparison function for qsort.
// Arguments: pvElem1       -- The first element to compare.
//            pvElem2       -- The second element to compare.
// Return:    <0 if (elem1<elem2), 0 if (elem1==elem2), >0 if (elem1>elem2)
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CMyListView *g_plvTemp = NULL;
int _cdecl SortObjects(const void *pvElem1, const void *pvElem2)
{
    // pvElem1 and pvElem2 are passed in as pointers to array elements.  Do
    // some wacky casting to get the actual object pointers.
    void *pv1 = (void*)*(DWORD*)pvElem1;
    void *pv2 = (void*)*(DWORD*)pvElem2;
    int nRet = g_plvTemp->CompareObjects(pv1, pv2);
    if (g_plvTemp->m_fInvertSort)
        nRet *= -1;
    return nRet;
}

DWORD GetKeyFlags()
{
    DWORD dwKeys = 0;

    if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
        dwKeys |= MK_SHIFT;
    if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
        dwKeys |= MK_CONTROL;

    return dwKeys;
}

int CMyListView::GetTopItem()
{
    SCROLLINFO si;
    si.cbSize = sizeof(si); 
    si.fMask  = SIF_ALL; 
    GetScrollInfo(m_hwnd, SB_VERT, &si);

    return si.nPos / m_nItemHeight;
}

int CMyListView::GetBottomItem()
{
    SCROLLINFO si;
    si.cbSize = sizeof(si); 
    si.fMask  = SIF_ALL; 
    GetScrollInfo(m_hwnd, SB_VERT, &si);

    return (si.nPos + si.nPage-m_nItemHeight)/ m_nItemHeight-1;
}
void CMyListView::SetFocusItem(int iFocusItem)
{
    if (m_iFocusItem != -1)
        m_rgli[m_iFocusItem].dwFlags &= ~LVF_FOCUSITEM;
    m_iFocusItem = iFocusItem;
    if (m_iFocusItem != -1)
        m_rgli[m_iFocusItem].dwFlags |= LVF_FOCUSITEM;
}

void CMyListView::HandleKeyDown(DWORD dwVKey)
{
    int iTopItem, iBottomItem;
    SCROLLINFO si;
    si.cbSize = sizeof(si); 
    si.fMask  = SIF_ALL; 
    if (m_cItems == 0)
        return;
    
    int iOrigFocusItem = m_iFocusItem;
    switch(dwVKey)
    {
    case VK_UP:
        iTopItem = GetTopItem();
        if (m_iFocusItem == iTopItem)
        {
            if (m_iFocusItem == 0)
                break;

            SendMessage(m_hwnd, WM_VSCROLL, SB_LINEUP, 0L);
            iTopItem = GetTopItem();
        }
        SetFocusItem(m_iFocusItem-1);

        break;
        
    case VK_DOWN:
        iBottomItem = GetBottomItem();
        if (m_iFocusItem == iBottomItem)
        {
            if (m_iFocusItem == m_cItems - 1)
                break;

            SendMessage(m_hwnd, WM_VSCROLL, SB_LINEDOWN, 0L);
            iBottomItem = GetBottomItem();
        }
        SetFocusItem(m_iFocusItem+1);
        break;

    case VK_PRIOR:
        iTopItem = GetTopItem();
        if (m_iFocusItem == iTopItem)
        {
            if (m_iFocusItem == 0)
                break;

            SendMessage(m_hwnd, WM_VSCROLL, SB_PAGEUP, 0L);
            iTopItem = GetTopItem();
        }
        SetFocusItem(iTopItem);
        break;
    
    case VK_NEXT:
        iBottomItem = GetBottomItem();
        if (m_iFocusItem == iBottomItem)
        {
            if (m_iFocusItem == m_cItems - 1)
                break;

            SendMessage(m_hwnd, WM_VSCROLL, SB_PAGEDOWN, 0L);
            iBottomItem = GetBottomItem();
        }
        SetFocusItem(iBottomItem);
        break;
        
    case VK_HOME:
        GetScrollInfo(m_hwnd, SB_VERT, &si);
        si.nPos = 0;
        m_nCurVScrollLoc = si.nPos;
        SetScrollInfo(m_hwnd, SB_VERT, &si, TRUE);
        InvalidateRect(m_hwnd, NULL, FALSE);
        SetFocusItem(0);
        break;

    case VK_END:
        GetScrollInfo(m_hwnd, SB_VERT, &si);
        si.nPos = ((si.nMax - si.nPage) / m_nItemHeight) * m_nItemHeight;
        m_nCurVScrollLoc = max(0,si.nPos);
        SetScrollInfo(m_hwnd, SB_VERT, &si, TRUE);
        InvalidateRect(m_hwnd, NULL, FALSE);
        SetFocusItem(m_cItems-1);
        break;

    default:
        return;
    }
    if (m_iFocusItem != iOrigFocusItem && iOrigFocusItem != -1)
        RefreshItem(iOrigFocusItem);
    if (GetKeyFlags() == MK_CONTROL)
        RefreshItem(m_iFocusItem);
    else
        SelectItem(m_iFocusItem, GetKeyFlags());
}


// Return true if we drew it.
BOOL CMyListView::DrawHeader(LPDRAWITEMSTRUCT pdis)
{
    HDC hdcHeader = pdis->hDC; 
    RECT rc = pdis->rcItem; 
    int iColumn = pdis->itemID; 
    int nState = pdis->itemState; 

//#define OFFSCREEN
#ifdef OFFSCREEN
    static HBITMAP s_hbmpOff;
    static int s_nLastWidth = -1, s_nLastHeight = -1;
    RECT rcOrig = rc;
    rc.bottom -= rc.top;
    rc.top = 0;
    rc.right -= rc.left;
    rc.left = 0;
    
    HDC hdcOffscreen = CreateCompatibleDC(hdcHeader);
    if (rc.right - rc.left > s_nLastWidth  || rc.bottom - rc.top > s_nLastHeight)
    {
        s_hbmpOff = CreateCompatibleBitmap(hdcHeader, rc.right - rc.left,
                                           rc.bottom - rc.top);
        s_nLastWidth = rc.right - rc.left;
        s_nLastHeight = rc.bottom - rc.top;
        DebugOutput("create header bmp (%d, %d)\n", s_nLastWidth, s_nLastHeight);
    }
    HBITMAP hbmpPrevOff = (HBITMAP)SelectObject(hdcOffscreen, s_hbmpOff);
#else
    HDC hdcOffscreen = pdis->hDC;
#endif

    // Draw the sort icon if we're sorting on this column
    SetTextColor(hdcOffscreen, RGB(0, 0, 0)); 
    SetBkMode(hdcOffscreen, TRANSPARENT); 
    HFONT hfontPrev = (HFONT)SelectObject(hdcOffscreen, m_hfont);

    FillRect(hdcOffscreen, &rc, GetSysColorBrush(COLOR_BTNFACE));

    rc.left += 7;
    rc.top  += 3;
    if (nState & ODS_SELECTED) 
    {
        rc.left++;
        rc.top++;
    }

    HDITEM hdi;
    char sz[256];
    hdi.mask = HDI_TEXT;
    hdi.pszText = sz;
    hdi.cchTextMax = 256;
    Header_GetItem(m_hwndHeader, iColumn, &hdi);
    DrawText(hdcOffscreen, sz, strlen(sz), &rc, DT_LEFT); 

    if (iColumn == m_iSortColumn) 
    {
        SIZE size;
        GetTextExtentPoint32(hdcOffscreen, sz, strlen(sz), &size);
        SetTextJustification(hdcOffscreen, 0, 0);
    
        int nX = min(rc.left + size.cx + 2, rc.right - 16);
        ImageList_Draw(m_himlSortArrows, m_fInvertSort ? 0 : 1,
                       hdcOffscreen, nX, rc.top-1, ILD_TRANSPARENT | ILD_NORMAL);
    }

    SelectObject(hdcOffscreen, hfontPrev);
#ifdef OFFSCREEN
    BitBlt(hdcHeader, rcOrig.left, rcOrig.top,
           rcOrig.right - rcOrig.left, rcOrig.bottom - rcOrig.top,
           hdcOffscreen, 0, 0, SRCCOPY);
    SelectObject(hdcOffscreen, hbmpPrevOff);
    DeleteDC(hdcOffscreen);
#endif
    return TRUE;
}

void CMyListView::SortColumn(int iColumn)
{
    m_fInvertSort = (m_iSortColumn == iColumn) & !m_fInvertSort;

    RECT rc;
    rc.top = 0;
    rc.bottom =20;
    rc.left = 0;
    for (int i = 0; i < m_iSortColumn; i++)
        rc.left += m_rgnColWidths[i];
    rc.left += 5;
    rc.right = rc.left + m_rgnColWidths[i] - 5;
    InvalidateRect(m_hwndHeader, &rc, TRUE);
    
    m_iSortColumn = iColumn;
    // warning: not reentrant
    assert(g_plvTemp == NULL);
    g_plvTemp = this;
    qsort((void*)m_rgli, m_cItems, sizeof(sListItem), &SortObjects);
    g_plvTemp = NULL;

    // Update m_iFocusItem.  Find the item with 'LVF_FOCUSITEM' and set m_iFocusItem to it.
    for (int i2 = 0; i2 < m_cItems; i2++)
        if (m_rgli[i2].dwFlags & LVF_FOCUSITEM)
        {
            SetFocusItem(i2);
            break;
        }

    UpdateAllItems();
}

void CMyListView::GetMouseInfoAt(int nX, int nY, sMouseInfo *pmi)
{
    int iRow, iColumn;
        
    pmi->nX = nX;
    pmi->nY = nY - m_nHeaderHeight+1;
    
    if (GetItemAtPoint(nX, nY, &iRow, &iColumn))
    {
        pmi->iRow = iRow;
        pmi->iColumn = iColumn;
        pmi->pvItem = m_rgli[iRow].pvData;
    
        pmi->rcItem.left  = -m_nCurHScrollLoc;
        pmi->rcItem.right = pmi->rcItem.left + m_nHeaderHeight;
        pmi->rcItem.top = (iRow - GetTopItem()) * m_nItemHeight;
        pmi->rcItem.bottom = pmi->rcItem.top + m_nItemHeight;

        pmi->rcSubItem = pmi->rcItem;
        int nCols = Header_GetItemCount(m_hwndHeader);
        for (int c = 0; c < iColumn; c++)
            pmi->rcSubItem.left += m_rgnColWidths[c];
        pmi->rcSubItem.right = pmi->rcSubItem.left + m_rgnColWidths[c];
    }
    else
    {
        pmi->iRow = -1;
        pmi->iColumn = -1;
        pmi->pvItem = NULL;
    }
}

BOOL CMyListView::GetItemAtPoint(int nX, int nY, int *piItem, int *piColumn)
{
    if (nX > GetHeaderWidth() + m_nCurHScrollLoc)
        return FALSE;
    
    *piItem = (m_nCurVScrollLoc + nY - m_nHeaderHeight)/ m_nItemHeight;

    if (*piItem >= m_cItems)
        return FALSE;

    if (piColumn == NULL)
        return TRUE;
    int nC = -m_nCurHScrollLoc;
    int nCols = Header_GetItemCount(m_hwndHeader);
    for (int c = 0; c < nCols; c++)
    {
        if (nX < nC + m_rgnColWidths[c])
        {
            *piColumn = c;
            break;
        }
        nC += m_rgnColWidths[c];
    }

    if (c == nCols)
        return FALSE;
    return TRUE;
}

void CMyListView::UnselectAllItems()
{
    g_statusbar.DeferUpdate();
    SetFocusItem(-1);
    for (int i = 0; i < m_cItems; i++)
    {
        if (m_rgli[i].dwFlags & LVF_ITEMSELECTED)
        {
            UnselectItem(i);
        }
    }
    g_statusbar.Update();
}

void CMyListView::SelectAllItems()
{
    g_statusbar.DeferUpdate();
    Notify_SelectChange(NULL, false);

    for (int i = 0; i < m_cItems; i++)
    {
        if (~(m_rgli[i].dwFlags & LVF_ITEMSELECTED))
        {
            SelectSingleItem(i);
        }
    }
    g_statusbar.Update();
}

void CMyListView::UpdateAllItems()
{
    g_statusbar.DeferUpdate();
    for (int i = 0; i < m_cItems; i++)
        RefreshItem(i);
    g_statusbar.Update();
}

BOOL CMyListView::IsSelected(int iItem)
{
    // undone: allow subclass to reject selection
    return (m_rgli[iItem].dwFlags & LVF_ITEMSELECTED) ? TRUE : FALSE;
}

void CMyListView::SelectSingleItem(int iItem)
{
    // undone: allow subclass to reject selection
    m_rgli[iItem].dwFlags |= LVF_ITEMSELECTED;
    Notify_SelectChange(m_rgli[iItem].pvData, true);
    RefreshItem(iItem);
}

void CMyListView::UnselectItem(int iItem)
{
    // undone: allow subclass to reject selection
    m_rgli[iItem].dwFlags &= ~LVF_ITEMSELECTED;
    Notify_SelectChange(m_rgli[iItem].pvData, false);
    RefreshItem(iItem);
}

void CMyListView::RefreshItem(int iItem)
{
    int nCols = Header_GetItemCount(m_hwndHeader);
    RECT rcClient;
    GetClientRect(m_hwnd, &rcClient);

    // Is the item onscreen?
    RECT rcItem = rcClient, rcClip;
    rcItem.left -= m_nCurHScrollLoc;
    rcItem.right = rcItem.left + GetHeaderWidth();
    rcItem.top =  iItem * m_nItemHeight - m_nCurVScrollLoc + m_nHeaderHeight;
    rcItem.bottom = rcItem.top + m_nItemHeight;
    RECT rcFocus = rcItem;
    BOOL fOnScreen = IntersectRect(&rcClip, &rcItem, &rcClient);

    rcItem.right = rcItem.left + m_rgnColWidths[0]; 
    HDC hdc = GetDC(m_hwnd);
    SelectObject(hdc, m_hfont);
    int nC = -m_nCurHScrollLoc;
    DWORD dwFocusFlag = m_fHaveFocus ? LVF_ITEMFOCUSED : 0;
    for (int c = 0; c < nCols; c++)
    {
        // Is the subitem onscreen?
        BOOL fSubOnScreen = fOnScreen;
        if (fOnScreen)
        {
            rcItem.left  = nC;
            rcItem.right = rcItem.left + m_rgnColWidths[c];
            fSubOnScreen = IntersectRect(&rcClip, &rcItem, &rcClient);
        }

        RECT *prcClip;
        RECT rc = rcItem;
        if (fSubOnScreen)
            prcClip = &rc;
        else
            prcClip = NULL;
        UpdateItem(m_rgli[iItem].pvData, m_rgli[iItem].dwFlags | dwFocusFlag, c, hdc, prcClip);

        nC += m_rgnColWidths[c];
    }

    if (m_iFocusItem == iItem)
        if (m_fHaveFocus)
            DrawFocusRect(hdc, &rcFocus);
    
    ReleaseDC(m_hwnd, hdc);
}

void CMyListView::HandleButtonDown(int nX, int nY, DWORD dwFlags)
{
    sMouseInfo mi;

    GetMouseInfoAt(nX, nY, &mi);

    m_fHaveFocus = true;

    // Give the listview keyboard input focus
    SetFocus(m_hwnd);

    // let the subclass completely override us if so desired
    if (!Override_LButtonDown(&mi, dwFlags))
        return;

    // Over an item?
    if (mi.pvItem == NULL) {
        // Didn't click on an item.  Since we don't support dragrects, there's
        // nothing to do here.
        UnselectAllItems();
    }
    else
        SelectItem(mi.iRow, dwFlags);
}

void CMyListView::HandleButtonDblClick(int nX, int nY, DWORD dwFlags)
{
    sMouseInfo mi;

    GetMouseInfoAt(nX, nY, &mi);

    m_fHaveFocus = true;

    // Give the listview keyboard input focus
    SetFocus(m_hwnd);

    // let the subclass completely override us if so desired
    Override_LButtonDblClick(&mi, dwFlags);

    // We don't do anything for double clicks ourselves.
}

void CMyListView::SelectItem(int iItem, DWORD dwFlags)
{
    int i1, i2;

    if (iItem < m_iShiftItem) {
        i1 = iItem;
        i2 = m_iShiftItem;
    } else {
        i1 = m_iShiftItem;
        i2 = iItem;
    }

    g_statusbar.DeferUpdate();

    int iPrevFocus = m_iFocusItem;
    SetFocusItem(-1);
    if (iPrevFocus != -1)
        RefreshItem(iPrevFocus);
    // User clicked on item 'iItem'.  if 'ctrl' isn't pressed, then
    // unselect all other previously selected items
    if (!(dwFlags & MK_CONTROL)) {
        // If shift is pressed then unselect those items NOT in the new selection range
        if (!(dwFlags & MK_SHIFT))
            UnselectAllItems();
        else {
            for (int i = 0; i < m_cItems; i++) {
                if (IsSelected(i) && (i < i1 || i > i2)) {
                    UnselectItem(i);
                    RefreshItem(i);
                }
            }
        }
    }

    // If 'shift' is pressed, then select every item between the current-focus
    // item and the item the user clicked on.
    if ((dwFlags & MK_SHIFT) && m_iShiftItem != -1) {
        for (int i = i1; i <= i2; i++)
            if (!IsSelected(i))
                SelectSingleItem(i);
    } else {
        // Finally, select the item
        if (IsSelected(iItem) && !(dwFlags & MK_FORCESEL))
            UnselectItem(iItem);
        else
            SelectSingleItem(iItem);
    }
    SetFocusItem(iItem);
    RefreshItem(m_iFocusItem);
    g_statusbar.Update();
}

void CMyListView::HandleButtonUp(int nX, int nY, DWORD dwFlags)
{
    sMouseInfo mi;
    GetMouseInfoAt(nX, nY, &mi);
    // No dragrect, so no default handling
    Override_LButtonUp(&mi, dwFlags);
}

void CMyListView::HandleMouseMove(int nX, int nY, DWORD dwFlags)
{
    sMouseInfo mi;
    GetMouseInfoAt(nX, nY, &mi);

    // No dragrect, so no default handling.
    Override_MouseMove(&mi, dwFlags);
}

void CMyListView::HandleHeaderDoubleClick(LPNMHEADER pnmhdr)
{
    // Find the length of the contents of all rows in the specified column;
    // resize the column so that the longest one fits.
    int nMaxWidth = 0;
    HDC hdc = GetDC(m_hwnd);
    SelectObject(hdc, m_hfont);
    for (int i = 0; i < m_cItems; i++)
        nMaxWidth = max(nMaxWidth, (int)GetItemWidth(hdc, m_rgli[i].pvData, pnmhdr->iItem));

    ReleaseDC(m_hwnd, hdc);

    HDITEM hdi;
    hdi.mask = HDI_WIDTH;
    hdi.cxy = nMaxWidth;
    Header_SetItem(m_hwndHeader, pnmhdr->iItem, &hdi);


    UpdateColumnWidths();
    UpdateScrollBars();
    InvalidateRect(m_hwnd, NULL, TRUE);

    // Update the position of the header control in case it's been scrolled.
    // Note that this creates slightly strange behaviour, but the behaviour
    // exactly mimics what WinXP does, so, when in rome...
    // (example: shrink window so that horz scroll bar appears; scroll
    //  window all the way to the right; shrink one of the column headers;
    //  RESULT: The whole column quickly shrinks).
    SetWindowPos(m_hwndHeader, NULL, -m_nCurHScrollLoc, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

}

BOOL CMyListView::InitHeader()
{
    RECT rcParent;
    HDLAYOUT hdl;
    WINDOWPOS wp;

    m_hwndHeader = CreateWindow(WC_HEADER, "", WS_CHILD | WS_VISIBLE | HDS_BUTTONS | HDS_HORZ | HDS_FULLDRAG, 0, 0, 0, 0,
                                m_hwnd, (HMENU)WNDID_LISTVIEW_HEADER, g_hInst, NULL);
    if (m_hwndHeader == NULL)
        return FALSE;

    // Retrieve the bounding rectangle of the listview's 
    // client area, and then request size and position values 
    // from the header control. 
    GetClientRect(m_hwnd, &rcParent); 

    hdl.prc = &rcParent; 
    hdl.pwpos = &wp; 
    if (!Header_Layout(m_hwndHeader, &hdl)) 
        return FALSE;
    m_nHeaderHeight = wp.cy;

    m_himlSortArrows = ImageList_Create(16, 16, ILC_COLOR8, 2, 1);
    if (m_himlSortArrows == NULL) 
        return FALSE; 

    HBITMAP hbmp;
    if ((hbmp = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_SORTARROWS))) == NULL)
        return FALSE;
    int nImageIndex = ImageList_Add(m_himlSortArrows, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp);
    if (nImageIndex == -1)
        return FALSE;

    Header_SetImageList(m_hwndHeader, m_himlSortArrows);

    return TRUE;
}

void CMyListView::SetVisible(bool fVisible)
{
    ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE);
}

int CMyListView::GetHeaderWidth()
{
    return m_nHeaderWidth;
}

int CMyListView::GetTotalItemHeight()
{
    return m_cItems * m_nItemHeight;
}
        
void CMyListView::UpdateIfDirty()
{
    if (m_fDirty)
    {
        InvalidateRect(m_hwnd, NULL, FALSE);
        SetWindowPos(m_hwndHeader, NULL, -m_nCurHScrollLoc, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        InvalidateRect(m_hwndHeader, NULL, TRUE);
        UpdateWindow(m_hwndHeader);

        UpdateScrollBars();
        
        m_fInvertSort = !m_fInvertSort;
        SortColumn(m_iSortColumn);
        
        UpdateWindow(m_hwnd);
        m_fDirty = FALSE;
    }
}

void CMyListView::Resize(RECT *prc)
{
    m_nMaxHScroll = max(GetHeaderWidth() - (prc->right - prc->left), 0); 
    m_nMaxVScroll = max(GetTotalItemHeight() - (prc->bottom - prc->top-m_nHeaderHeight - 30), 0); 
    m_nCurHScrollLoc = min(m_nCurHScrollLoc, m_nMaxHScroll); 
    m_nCurVScrollLoc = min(m_nCurVScrollLoc, m_nMaxVScroll); 

    MoveWindow(m_hwnd, prc->left, prc->top, prc->right - prc->left,
               prc->bottom - prc->top, TRUE);
    MoveWindow(m_hwndHeader, -m_nCurHScrollLoc, 0, prc->right - prc->left+m_nCurHScrollLoc, m_nHeaderHeight, FALSE);
    UpdateWindow(m_hwndHeader);
    
    UpdateScrollBars();

    UpdateWindow(m_hwnd);
}

void CMyListView::UpdateScrollBars()
{
    RECT rc;
    GetClientRect(m_hwnd, &rc);

    m_nMaxHScroll = max(GetHeaderWidth() - (rc.right - rc.left), 0); 
    m_nMaxVScroll = max(GetTotalItemHeight() - (rc.bottom - rc.top-m_nHeaderHeight - m_nItemHeight), 0); 
    m_nCurHScrollLoc = min(m_nCurHScrollLoc, m_nMaxHScroll); 
    m_nCurVScrollLoc = min(m_nCurVScrollLoc, m_nMaxVScroll); 

    // Update the horz/vert scrollbars so that the dragbar is proportional to the
    // size of the listview in that dimension
    SCROLLINFO si;
    si.cbSize = sizeof si;
    si.fMask = SIF_RANGE | SIF_PAGE;
    si.nMin = 0;
    si.nMax = GetHeaderWidth();
    si.nPage = rc.right - rc.left;
    SetScrollInfo(m_hwnd, SB_HORZ, &si, TRUE);
    
    si.nMin = 0;
    if (m_nMaxVScroll == 0)
        si.nMax = GetTotalItemHeight()+m_nItemHeight;
    else
        si.nMax = ((GetTotalItemHeight() + m_nHeaderHeight + m_nItemHeight) / m_nItemHeight) * m_nItemHeight;
    si.nPage = rc.bottom - rc.top;
    SetScrollInfo(m_hwnd, SB_VERT, &si, TRUE);

    // Do we need to show/enable the scroll bars?
    BOOL fShowHScroll = rc.right - rc.left < GetHeaderWidth();
    BOOL fShowVScroll = rc.bottom - rc.top > m_nHeaderHeight && rc.bottom - rc.top < GetTotalItemHeight() + m_nHeaderHeight;
    ShowScrollBar(m_hwnd, SB_HORZ, fShowHScroll);
    ShowScrollBar(m_hwnd, SB_VERT, fShowVScroll);
    EnableScrollBar(m_hwnd, SB_HORZ, fShowHScroll ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
    EnableScrollBar(m_hwnd, SB_VERT, fShowVScroll ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
}

BOOL CMyListView::AddItemAtIndex(void *pvItem, int iLoc)
{
    if (m_cItems + 1 > m_cMaxItems)
    {
        // Realloc the internal storage container
        m_cMaxItems += m_cAddItemDelta;
        m_rgli = (sListItem*)realloc(m_rgli, m_cMaxItems * sizeof(sListItem));
    }
    m_rgli[m_cItems].pvData = pvItem;
    m_rgli[m_cItems].dwFlags = 0;
    m_cItems++;
    m_fDirty = TRUE;
    return TRUE;
}

BOOL CMyListView::DeleteItem(void *pvItem)
{
    // Remove the specified item from the listview
    // UNDONE: very unoptimized
    for (int i = 0; i < m_cItems; i++)
    {
        if (m_rgli[i].pvData == pvItem)
        {
            // found it.  Remove it.
            if (i < m_cItems - 1)
                memcpy(&m_rgli[i], &m_rgli[i+1], (m_cItems - i - 1) * sizeof (sListItem));
            m_cItems--;
            m_fDirty = TRUE;
            return TRUE;
        }
    }
    return FALSE;
}

void CMyListView::Clear()
{
    m_iFocusItem = -1;
    m_fHaveFocus = false;
    m_iShiftItem = -1;
    m_nCurHScrollLoc = 0;
    m_nCurVScrollLoc = 0;
    SetScrollPos(m_hwnd, SB_HORZ, 0, FALSE);
    SetScrollPos(m_hwnd, SB_VERT, 0, FALSE);
    free(m_rgli);
    // Note: leave m_cMaxItems at it's highwater point?
    m_cMaxItems = 0;
    m_cItems    = 0; 
    m_rgli      = NULL;
    m_fDirty    = true;

    InvalidateRect(m_hwnd, NULL, TRUE);
    UpdateWindow(m_hwnd);
}

void CMyListView::AddColumn(char *szName, UINT nWidth)
{
    HDITEM hdi; 

    hdi.mask = HDI_TEXT | HDI_FORMAT | HDI_WIDTH; 
    hdi.fmt = HDF_OWNERDRAW; 

    hdi.pszText = szName; 
    hdi.cxy = nWidth; 
    hdi.cchTextMax = lstrlen(hdi.pszText); 
 
    Header_InsertItem(m_hwndHeader, 1000, (LPARAM)&hdi);
    UpdateColumnWidths();
}

void CMyListView::UpdateColumnWidths()
{
    m_nHeaderWidth = 0;
    int nCols = Header_GetItemCount(m_hwndHeader);
    for (int i = 0; i < nCols; i++)
    {
        HDITEM hdi;
        hdi.mask = HDI_WIDTH;
        Header_GetItem(m_hwndHeader, i, &hdi);
        m_nHeaderWidth += hdi.cxy;
        m_rgnColWidths[i] = hdi.cxy;
    }
}

void CMyListView::UpdateListDisplay()
{
    HDC hdc;
    PAINTSTRUCT ps;

    hdc = BeginPaint(m_hwnd, &ps);
    RECT rcPaint = ps.rcPaint;

    // For now, draw the items in their entirety
    int nY = m_nHeaderHeight;
    int nFirstItem = m_nCurVScrollLoc / m_nItemHeight;
    int nX;

    SelectObject(hdc, m_hfont);
    DWORD dwFocusFlag = m_fHaveFocus ? LVF_ITEMFOCUSED : 0;
    int nLastItem = min(m_cItems, nFirstItem + (ps.rcPaint.bottom + m_nItemHeight) / m_nItemHeight);
    for (int i = nFirstItem; i < nLastItem; i++)
    {
        nX = -m_nCurHScrollLoc;
        for (int c = 0; c < NUM_COLUMNS; c++)
        {
            RECT rcDummy, rc = {nX, nY, nX + m_rgnColWidths[c], nY + m_nItemHeight};
            if (IntersectRect(&rcDummy, &rc, &rcPaint))
                UpdateItem(m_rgli[i].pvData, m_rgli[i].dwFlags | dwFocusFlag, c, hdc, &rc);

            nX += m_rgnColWidths[c];
        }
        if (m_fHaveFocus && m_iFocusItem == i)
        {
            RECT rc = {-m_nCurHScrollLoc, nY, -m_nCurHScrollLoc + m_nHeaderWidth, nY + m_nItemHeight};
            DrawFocusRect(hdc, &rc);
        }
        nY += m_nItemHeight;
    }

    // Fill unused area if necessary
    if (nX < rcPaint.right)
    {
        RECT rc = rcPaint;
        rc.left = nX;
        FillRect(hdc, &rc, GetSysColorBrush(COLOR_WINDOW));
    }

    if (nY < rcPaint.bottom)
    {
        RECT rc = rcPaint;
        rc.top = nY;
        FillRect(hdc, &rc, GetSysColorBrush(COLOR_WINDOW));
    }

    EndPaint(m_hwnd, &ps);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CSplitter.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CSplitter.cpp
// Contents:  
// Revisions: 31-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CSplitter *g_psplitterTemp = NULL;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SplitterWndProc
// Purpose:   Subclassed window procedure for the Splitter controls.
// Arguments: hwnd              -- The handle to the window that the message is
//                                 intended for.
//            uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LONG FAR PASCAL SplitterWndProc(HWND hwnd, UINT uMsg, WORD wparam, LONG lparam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    
//    TrackMessage(uMsg, wparam, lparam, "Splitter");

    // Determine which CSplitter this message is actually intended for.
    CSplitter *psplitter = (CSplitter*)GetWindowLong(hwnd, GWL_USERDATA);
    if (!psplitter)
    {
        assert(g_psplitterTemp);
        SetWindowLong(hwnd, GWL_USERDATA, (long)g_psplitterTemp);
        psplitter = g_psplitterTemp;
        g_psplitterTemp = NULL;
    }

    switch(uMsg)
    {
    case WM_LBUTTONDOWN:
        psplitter->HandleMouseDown((signed short) LOWORD(lparam), (signed short) HIWORD(lparam));
        break;

    case WM_LBUTTONUP:
        psplitter->HandleMouseUp((signed short) LOWORD(lparam), (signed short) HIWORD(lparam));
        break;

    case WM_MOUSEMOVE:
        psplitter->HandleMouseMove((signed short) LOWORD(lparam), (signed short) HIWORD(lparam));
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        FillRect(hdc, &ps.rcPaint, GetSysColorBrush(COLOR_BTNFACE));
        EndPaint(hwnd, &ps);
        break;
    }

    return DefWindowProc(hwnd, uMsg, wparam, lparam);
}


void CSplitter::HandleMouseDown(int nClientX, int nClientY)
{
    RECT rcParent;
    GetClientRect(m_hwndParent, &rcParent);

    // start drag
    m_fDragging = true;
    m_nDragDeltaX = nClientX;
    SetCapture(m_hwnd);
}

void CSplitter::HandleMouseMove(int nClientX, int nClientY)
{
    if (!m_fDragging)
        return;

    RECT rcParent;
    GetClientRect(m_hwndParent, &rcParent);

    POINT pt = {nClientX, nClientY};
    MapWindowPoints(m_hwnd, m_hwndParent, &pt, 1);

    pt.x = max(50, pt.x);
    pt.x = min(rcParent.right - 50, pt.x);
    m_nPos = pt.x - m_nDragDeltaX;
    m_nPermPos = pt.x - m_nDragDeltaX;
    m_pvmParent->Resize(rcParent.right - rcParent.left, rcParent.bottom - rcParent.top);
    UpdateWindow(m_hwnd);
}

void CSplitter::HandleMouseUp(int nClientX, int nClientY)
{
    // stop drag
    m_fDragging = false;
    ReleaseCapture();
}

bool gs_fRegedSplitter = false;
BOOL CSplitter::Init(CViewMode *pvmParent, HWND hwndParent, int nStartPos)
{
    WNDCLASSEX wcex;

    m_nWidth = 4;
    m_fDragging = false;
    m_hwndParent = hwndParent;
    m_pvmParent = pvmParent;
    m_nPos = nStartPos;
    m_nPermPos = nStartPos;

    if (!gs_fRegedSplitter)
    {
        // Register the class for the app's window.
        wcex.cbSize        = sizeof(WNDCLASSEX); 
        wcex.style         = CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc   = (WNDPROC)SplitterWndProc;
        wcex.hInstance     = g_hInst;
        wcex.hCursor       = LoadCursor(NULL, IDC_SIZEWE);
        wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcex.lpszClassName = "MySplitter";
        wcex.cbClsExtra    = 0;
        wcex.cbWndExtra    = 0;
        wcex.hIcon         = 0;
        wcex.lpszMenuName  = NULL;
        wcex.hIconSm       = 0;
        if (!RegisterClassEx(&wcex))
            return NULL;
        gs_fRegedSplitter = true;
    }

    assert(g_psplitterTemp == NULL);
    g_psplitterTemp = this;
    m_hwnd = CreateWindow("MySplitter", "", WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, 0, 0, 0, 0,
                          hwndParent, (HMENU)WNDID_SPLITTER, g_hInst, NULL);
    
    return TRUE;
}

void CSplitter::Resize(RECT *prc)
{
    MoveWindow(m_hwnd, prc->left, prc->top, prc->right - prc->left,
               prc->bottom - prc->top, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CSplitter.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      csplitter.h
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CViewMode;

class CSplitter
{
public:
    BOOL Init(CViewMode *pvmParent, HWND hwndParent, int nStartPos);
    int GetPos() {return m_nPos; }
    int GetPermPos() {return m_nPermPos; }
    int GetWidth() {return m_nWidth; }
    void Resize(RECT *prc);

    void HandleMouseDown(int nClientX, int nClientY);
    void HandleMouseMove(int nClientX, int nClientY);
    void HandleMouseUp(int nClientX, int nClientY);

    WNDPROC m_pfnStaticWndProc;
    void SetVisible(bool fVisible) { ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE); }

private:

    BOOL m_fDragging;
    int  m_nPermPos;
    int  m_nPos;
    int  m_nWidth;
    int  m_nDragDeltaX;
    HWND m_hwnd;
    HWND m_hwndParent;
    CViewMode *m_pvmParent;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CStatusBar.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cstatusbar.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::CStatusBar
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStatusBar::Init(HWND hwndParent)
{
    m_nW = 100;

    // Create the status bar
    m_hwnd = CreateStatusWindow(WS_CHILD | WS_VISIBLE | CCS_BOTTOM | SBARS_SIZEGRIP, NULL,
                                hwndParent, 2);

    if (!m_hwnd)
        return false;

    m_fDeferUpdate = false;
    SetNumParts(2);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::~CStatusBar
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStatusBar::~CStatusBar()
{
    if (m_hwnd)
        DestroyWindow(m_hwnd);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStatusBar::SetNumParts(int nParts)
{
    m_nParts = nParts;
    
    int rgn2[] = {(int)((float)m_nW*.85), -1};
    SendMessage(m_hwnd, SB_SETPARTS, nParts, (LPARAM) (LPINT) rgn2);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::SetText
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStatusBar::SetText(int iRegion, char *szText)
{
    strcpy(m_rgszText[iRegion], szText);
    if (!m_fDeferUpdate)
        SendMessage(m_hwnd, SB_SETTEXT, iRegion, (LPARAM) szText);
}

void CStatusBar::Update()
{
    SendMessage(m_hwnd, SB_SETTEXT, 0, (LPARAM) m_rgszText[0]);
    SendMessage(m_hwnd, SB_SETTEXT, 1, (LPARAM) m_rgszText[1]);
    m_fDeferUpdate = false;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::Resize
// Purpose:   
// Arguments: 
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStatusBar::Resize(int nW, int nH)
{
    MoveWindow(m_hwnd, 0, nH - 20, nW, nH, TRUE);

    m_nW = nW;
    // Set the size of the status bar areas
    int rgnRegionSizes[2];
    if (m_nParts == 1)
        rgnRegionSizes[0] = -1;
    else
    {
        rgnRegionSizes[0] = (int)((float)m_nW * .85) - 2;
        rgnRegionSizes[1] = -1;
    }
    SendMessage(m_hwnd, SB_SETPARTS, m_nParts, (LPARAM)rgnRegionSizes);
}

int CStatusBar::GetHeight()
{
    RECT rc;
    GetClientRect(m_hwnd, &rc);
    return rc.bottom - rc.top;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CMyListView.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CMyListView.h
// Contents:  
// Revisions: 6-Nov-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct
{
    int nX, nY;
    RECT rcItem;
    RECT rcSubItem;
    int iRow, iColumn;
    void *pvItem;
} sMouseInfo;

extern DWORD GetKeyFlags();

typedef struct
{
    void *pvData;
    DWORD dwFlags;
} sListItem;

#define LVF_ITEMSELECTED 1
#define LVF_ITEMFOCUSED  2

#define MAX_COLUMNS 100
#define MK_FORCESEL 0x80000000

class CMyListView
{
public:
    BOOL Init(HWND hwndParent);
    void AddColumn(char *szName, UINT nWidth);
    BOOL DeleteItem(void *pvItem);
    BOOL AddItemAtIndex(void *pvitem, int iLoc);
    void SetVisible(bool fVisible);
    void Resize(RECT *prc);

    void SelectAllItems();
    void UpdateListDisplay();

    void Clear();
    
    LRESULT WndProc(UINT uMsg, WPARAM wparam, LPARAM lparam);

    HWND m_hwnd;

    virtual void UpdateItem(void *pvItem, DWORD dwItemState, int iColumn, HDC hdcDest, RECT *prcDest) = NULL;
    virtual DWORD GetItemWidth(HDC hdc, void *pvItem, int iColumn) = NULL;

    virtual BOOL Override_LButtonDown(sMouseInfo *pmi, DWORD dwFlags) {return TRUE;}
    virtual BOOL Override_LButtonDblClick(sMouseInfo *pmi, DWORD dwFlags) {return TRUE;}
    virtual BOOL Override_LButtonUp(sMouseInfo *pmi, DWORD dwFlags) {return TRUE;}
    virtual BOOL Override_MouseMove(sMouseInfo *pmi, DWORD dwFlags) {return TRUE;}
    
    virtual void Notify_SelectChange(void *pvObj, BOOL fSelected) {}
    virtual int CompareObjects(const void *pv1, const void *pv2) = NULL;
    int m_fInvertSort;
    virtual void AddObject(void *pvObj) = NULL;
    virtual void RemoveObject(void *pvObj) = NULL;

    void UpdateIfDirty();
    int GetHeaderHeight() {return m_nHeaderHeight;}

    BOOL m_fDirty;
protected:
    int m_iSortColumn;
    void SortColumn(int iColumn);
    BOOL GetItemAtPoint(int nX, int nY, int *piItem, int *piColumn);
    void RefreshItem(int iItem);
    void UnselectAllItems();
    void SelectItem(int iItem, DWORD dwFlags);
    void UnselectItem(int iItem);
    void SelectSingleItem(int iItem);
    BOOL IsSelected(int iItem);

    sListItem *m_rgli;
    int m_cItems;

    void SetFocusItem(int iFocusItem);
private:

    void HandleKeyDown(DWORD dwVKey);

    void GetMouseInfoAt(int nX, int nY, sMouseInfo *pmi);

    int GetTopItem();
    int GetBottomItem();

    void HandleButtonDown(int nX, int nY, DWORD dwFlags);
    void HandleButtonDblClick(int nX, int nY, DWORD dwFlags);
    void HandleButtonUp(int nX, int nY, DWORD dwFlags);
    void HandleMouseMove(int nX, int nY, DWORD dwFlags);

    void UpdateAllItems();


    BOOL InitHeader();
    int GetHeaderWidth();
    HWND m_hwndHeader;
    int m_nHeaderHeight;
    int m_nHeaderWidth;

    void UpdateScrollBars();
    void UpdateColumnWidths();

    void HandleHeaderDoubleClick(LPNMHEADER pnmhdr);
    BOOL DrawHeader(LPDRAWITEMSTRUCT pdis);


    int GetTotalItemHeight();
    int m_nItemHeight;

    int m_rgnColWidths[MAX_COLUMNS];
    int m_nCurHScrollLoc;
    int m_nMaxHScroll;
    int m_nCurVScrollLoc;
    int m_nMaxVScroll;

    RECT m_rcStartSize;
    BOOL m_fSizing;
    
    HFONT m_hfont;

    int m_iFocusItem;
    int m_iShiftItem;
    bool m_fHaveFocus;

    HIMAGELIST m_himlSortArrows;

    int m_cMaxItems;
    int m_cAddItemDelta;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CToolbarMgr.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CToolbar.cpp
// Contents:  
// Revisions: 29-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL InitToolbars()
{
    REBARBANDINFO rbbi;

    TBBUTTON rgtb[] = {
        {STD_FILENEW,  IDM_FILE_NEW,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {STD_FILEOPEN, IDM_FILE_OPEN, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {STD_FILESAVE, IDM_FILE_SAVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0,            0,            TBSTATE_ENABLED, TBSTYLE_SEP,    0L, 0},
        {0, IDM_VIEW_FILE,           TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0, IDM_VIEW_LAYOUT,         TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0,            0,            TBSTATE_ENABLED, TBSTYLE_SEP,    0L, 0},
        {0, IDM_TOOLS_EMULATE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, IDM_TOOLS_PREMASTER,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, IDM_TOOLS_PERF,          TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}};

    HWND hwndTB = CreateToolbarEx(g_tbm.GetRebarHwnd(), WS_CHILD | WS_VISIBLE|
                                  TBSTYLE_TOOLTIPS | TBSTYLE_FLAT |
                                  CCS_NODIVIDER | CCS_NORESIZE, 
                                  1, 3, (HINSTANCE)HINST_COMMCTRL,
                                  IDB_STD_SMALL_COLOR,  (LPCTBBUTTON)&rgtb,
                                  4, 0, 22, 16, 16, sizeof (TBBUTTON));

    // Add the non-standard buttons
    TBADDBITMAP tb;
    tb.hInst = g_hInst;
    tb.nID = BMP_TOOLBAR_GEN;
    int iNewBmps = SendMessage (hwndTB, TB_ADDBITMAP, 5, (LPARAM)&tb);

    rgtb[4].iBitmap = iNewBmps  + 0;
    rgtb[5].iBitmap = iNewBmps  + 1;
    rgtb[7].iBitmap = iNewBmps  + 2;
    rgtb[8].iBitmap = iNewBmps  + 3;
    rgtb[9].iBitmap = iNewBmps  + 4;

    SendMessage (hwndTB, TB_ADDBUTTONS, 6, (LONG) &rgtb[4]);
    
    DWORD dwBtnSize = SendMessage(hwndTB, TB_GETBUTTONSIZE, 0, 0);


    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize       = sizeof(REBARBANDINFO);
    rbbi.fMask        = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE |
                        RBBIM_SIZE | RBBIM_ID;
    rbbi.fStyle       = RBBS_CHILDEDGE | RBBS_GRIPPERALWAYS;
    rbbi.cxMinChild   = 0;
    rbbi.cyMinChild   = HIWORD(dwBtnSize);
    rbbi.cx           = 250;
    rbbi.cxMinChild   = 50;
    rbbi.wID          = TB_GLOBAL;
    rbbi.hwndChild    = hwndTB;
    g_tbm.AddBand(&rbbi);

    // And now the 'view toolbar'
    TBBUTTON rgtb2[] = {
        {0, IDM_EDIT_GROUP,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, IDM_EDIT_UNGROUP, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, 0,                TBSTATE_ENABLED, TBSTYLE_SEP,    0L, 0},
        {0, IDM_VIEW_LAYER0,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0, IDM_VIEW_LAYER1,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0, IDM_VIEW_BOTHLAYERS,TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0, IDM_VIEW_UNPLACED,TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {0, 0,                TBSTATE_ENABLED, TBSTYLE_SEP,    0L, 0},
        {0, IDM_EDIT_FIND,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, IDM_EDIT_RESCAN,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}};

    hwndTB = CreateToolbarEx(g_tbm.GetRebarHwnd(), WS_CHILD | WS_VISIBLE|
                             TBSTYLE_TOOLTIPS | TBSTYLE_FLAT |
                             CCS_NODIVIDER | CCS_NORESIZE, 
                             0, 0, NULL,
                             IDB_STD_SMALL_COLOR,  (LPCTBBUTTON)&rgtb2,
                             0, 0, 22, 16, 16, sizeof (TBBUTTON));

    // Add the non-standard buttons
    tb.hInst = g_hInst;
    tb.nID = IDB_TOOLBAR_LAYERVIEW;
    iNewBmps = SendMessage (hwndTB, TB_ADDBITMAP, 8, (LPARAM)&tb);

    rgtb2[0].iBitmap = iNewBmps + 0;
    rgtb2[1].iBitmap = iNewBmps + 1;
    rgtb2[3].iBitmap = iNewBmps + 2;
    rgtb2[4].iBitmap = iNewBmps + 3;
    rgtb2[5].iBitmap = iNewBmps + 4;
    rgtb2[6].iBitmap = iNewBmps + 5;
    rgtb2[8].iBitmap = iNewBmps + 6;
    rgtb2[9].iBitmap = iNewBmps + 7;

    SendMessage (hwndTB, TB_ADDBUTTONS, 10, (LONG) rgtb2);
    
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize       = sizeof(REBARBANDINFO);
    rbbi.fMask        = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE |
                        RBBIM_SIZE | RBBIM_ID;
    rbbi.fStyle       = RBBS_CHILDEDGE | RBBS_GRIPPERALWAYS;
    rbbi.cxMinChild   = 50;
    rbbi.cyMinChild   = HIWORD(dwBtnSize);
    rbbi.cx           = 100;
    rbbi.wID          = TB_LAYER;
    rbbi.hwndChild    = hwndTB;
    g_tbm.AddBand(&rbbi);
    g_tbm.Show(TB_LAYER);

    return TRUE;
}

BOOL CToolbarMgr::Init(HWND hwndParent)
{
    REBARINFO rbi;
 
    InitCommonControls();

    // Create the Rebar itself.  This Win32 object will contain the actual
    // toolbars in 'bands' that are subsequently added
    m_hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
                            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS |
                            RBS_VARHEIGHT | RBS_BANDBORDERS|
                            WS_CLIPCHILDREN | CCS_NODIVIDER,
                            0, 0, 0, 0, hwndParent, (HMENU)WNDID_TOOLBARMGR, g_hInst, NULL);

    if (m_hwnd == NULL)
        return FALSE;

    // Initialize and send the REBARINFO structure.
    rbi.cbSize = sizeof(REBARINFO);
    rbi.fMask  = 0;
    rbi.himl   = (HIMAGELIST)NULL;
    if(!SendMessage(m_hwnd, RB_SETBARINFO, 0, (LPARAM)&rbi))
        return FALSE;

    m_hwndParent = hwndParent;
    return TRUE;
}

BOOL CToolbarMgr::AddBand(REBARBANDINFO *prbbi)
{
    SendMessage(m_hwnd, RB_INSERTBAND, (WPARAM)(UINT) prbbi->wID, (LPARAM)(LPREBARBANDINFO)prbbi);

    // By default bands are visible at the start.
    Show(prbbi->wID);
    
    return TRUE;
}

void CToolbarMgr::Show(DWORD dwToolbar)
{
    // Make toolbar visible
    WPARAM wId = SendMessage(m_hwnd, RB_IDTOINDEX, dwToolbar, 0);
    SendMessage(m_hwnd, RB_SHOWBAND, wId, (LPARAM)TRUE);
}

void CToolbarMgr::Hide(DWORD dwToolbar)
{
    // Make toolbar invisible
    WPARAM wId = SendMessage(m_hwnd, RB_IDTOINDEX, dwToolbar, 0);
    SendMessage(m_hwnd, RB_SHOWBAND, wId, (LPARAM)FALSE);
}

void CToolbarMgr::Resize(WPARAM wparam, LPARAM lparam)
{
    SendMessage(m_hwnd, WM_SIZE, wparam, lparam);
}

DWORD CToolbarMgr::GetRowsHeight()
{
    return SendMessage(m_hwnd, RB_GETBARHEIGHT, 0, 0)+2;
}

void CToolbarMgr::HandleNotify(LPNMHDR pnmhdr)
{
    switch (pnmhdr->code)
    {
    case RBN_HEIGHTCHANGE:
        SendMessage(m_hwndParent, UM_TOOLBARRESIZED, 0, 0);
        break;
    }
}

void CToolbarMgr::CheckButton(int idBand, int idButton, bool fDown)
{
    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_CHILD;
    WPARAM wId = SendMessage(m_hwnd, RB_IDTOINDEX, idBand, 0);
    SendMessage(m_hwnd, RB_GETBANDINFO, wId, (LPARAM)&rbbi);
    SendMessage(rbbi.hwndChild, TB_CHECKBUTTON, idButton, MAKELONG(fDown, 0));
}

void CToolbarMgr::EnableButton(int idBand, int idButton, bool fEnabled)
{
    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_CHILD;
    WPARAM wId = SendMessage(m_hwnd, RB_IDTOINDEX, idBand, 0);
    SendMessage(m_hwnd, RB_GETBANDINFO, wId, (LPARAM)&rbbi);
    DWORD dwState = SendMessage(rbbi.hwndChild, TB_GETSTATE, idButton, 0);
    dwState = (dwState & TBSTATE_CHECKED) | (fEnabled ? TBSTATE_ENABLED : 0);
    SendMessage(rbbi.hwndChild, TB_SETSTATE, idButton, MAKELONG(dwState, 0));
}

BOOL CToolbarMgr::IsButtonChecked(int idBand, int idButton)
{
    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_CHILD;
    WPARAM wId = SendMessage(m_hwnd, RB_IDTOINDEX, idBand, 0);
    SendMessage(m_hwnd, RB_GETBANDINFO, wId, (LPARAM)&rbbi);
    DWORD dwState = SendMessage(rbbi.hwndChild, TB_GETSTATE, idButton, 0);

    return dwState & TBSTATE_CHECKED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CToolbarMgr.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CToolbarMgr.h
// Contents:  
// Revisions: 30-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CToolbarMgr
{
public:
    BOOL Init(HWND hwndParent);
    void Show(DWORD dwToolbar);
    void Hide(DWORD dwToolbar);

    BOOL AddBand(REBARBANDINFO *prbbi);

    DWORD GetRowsHeight();
    void Resize(WPARAM wparam, LPARAM lparam);

    HWND GetRebarHwnd() {return m_hwnd; }
    void HandleNotify(LPNMHDR pnmhdr);
    void CheckButton(int idBand, int idButton, bool fDown);
    void EnableButton(int idBand, int idButton, bool fEnabled);

    BOOL IsButtonChecked(int idBand, int idButton);

private:
    HWND m_hwnd;
    HWND m_hwndParent;
};

BOOL InitToolbars();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CStatusBar.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cstatusbar.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CStatusBar
{
public:
    bool Init(HWND hwndParent);
    ~CStatusBar();

    void SetText(int iRegion, char *szText);
    void MoveTo(int nX, int nY, int nW, int nH);

    void SetNumParts(int nParts);

    void Resize(int nW, int nH);

    int GetHeight();

    void Update();
    void DeferUpdate() {m_fDeferUpdate = true;}

private:
    char m_rgszText[2][400];
    bool m_fDeferUpdate;
    HWND m_hwnd;
    int m_nParts;
    int m_nW;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CToolbar.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CToolbar.cpp
// Contents:  
// Revisions: 29-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CTreeView.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      TreeView.h
// Contents:  
// Revisions: 15-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

enum {IMAGE_XROOT = 0, IMAGE_XDRIVE, IMAGE_UNCHECK, IMAGE_CHECK, IMAGE_TRISTATE,
      IMAGE_FOLDEROPEN, IMAGE_FOLDERCLOSED};

class CFolderInfo;
class CFileHierarchy;
class CTreeView
{
public:
    CTreeView();
    BOOL Init(HWND hwndParent);
    void Uninit();

    BOOL Populate(CFileObject *pfo);
    BOOL HandleMouseDown(int nX, int nY);
    void Resize(RECT *prc);
    void HandleSelection(LPNMTREEVIEW pnmhdr);

    void SetCurFolder(CFileObject *pfo);

    void AddObject(CFileObject *pfo);
    void RemoveObject(CFileObject *pfo);
    void Clear();
    BOOL SetCheckState(HTREEITEM hItem, eCheckState checkstate);
    BOOL RecurseSetCheckState(HTREEITEM hItem, eCheckState checkstate);
    void RecurseDownSetState(HTREEITEM htiCur, eCheckState checkstate);
    void RecurseUpSetState(HTREEITEM htiCur);
    void SetVisible(bool fVisible) { ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE); 
                                     ShowWindow(m_hwndStatic, fVisible ? SW_SHOW : SW_HIDE); }

private:

    BOOL InitImageList();
    HTREEITEM AddItem(CFileObject *pfo, int nLevel, HTREEITEM htiParent);
    void ToggleCheckState(HTREEITEM htiCur);
    eCheckState GetCheckState(HTREEITEM hItem);
    INT GetTVItemLPARAM(HTREEITEM hti);
    
    HIMAGELIST m_himl;
    HWND m_hwnd, m_hwndStatic;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CUnplacedListView.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      clistview.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define NUM_COLUMNS 6


class CUnplacedListView : public CMyListView
{
public:
    BOOL Init(HWND hwndParent);
    void UpdateItem(void *pvItem, DWORD dwItemState, int iColumn, HDC hdcDest, RECT *prcDest);
    DWORD GetItemWidth(HDC hdc, void *pvItem, int iColumn);

    int CompareObjects(const void *pv1, const void *pv2);

    virtual BOOL Override_LButtonDblClick(sMouseInfo *pmi, DWORD dwFlags);
    virtual BOOL Override_LButtonDown(sMouseInfo *pmi, DWORD dwFlags);
    virtual BOOL Override_MouseMove(sMouseInfo *pmi, DWORD dwFlags);

    void AddObject(void *pvObj);
    void RemoveObject(void *pvObj);
    void RefreshObject(void *pvObj);

private:
    HFONT m_hfont;
    HIMAGELIST m_himlFileIcons;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CTreeView.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      TreeView.cpp
// Contents:  
// Revisions: 15-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// Hack: Done to allow TreeViewProc to call into the actual CTreeView object.
//       I know there's only one in this app, so I don't bother with storing
//       the pointer in GWL_USERDATA (etc).
static CTreeView *g_ptreeview = NULL;
static WNDPROC gs_treeviewproc;
static WNDPROC gs_staticproc;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK TreeViewProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
//    TrackMessage(uMsg, wparam, lparam, "TreeView");
    switch(uMsg)
    {
    case WM_SETFOCUS:
         g_hwndPrevFocus = hwnd;
         break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
        // We don't like the default treeview checkbox handling, so we
        // explicitly handle it ourselves.  If the user presses the mouse
        // over a checkbox, we toggle its state.
        if (g_ptreeview->HandleMouseDown(LOWORD(lparam), HIWORD(lparam)))
        {
            // Return zero to indicate that we handled the message
            return 0;
        }

        break;
    }

    // Pass all other messages to the base window procedure.
    return CallWindowProc(gs_treeviewproc, hwnd, uMsg, wparam, lparam);
}
HFONT m_hfont;
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK StaticProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rc;
    
    switch(uMsg)
    {
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        GetClientRect(hwnd, &rc);
        FillRect(hdc, &rc, GetSysColorBrush(COLOR_BTNFACE));
        SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
        SelectObject(hdc, m_hfont);
        ExtTextOut(hdc, 2, 2, ETO_CLIPPED, &rc, "Folders", 7, NULL);
        rc.top = rc.bottom-1;
        FillRect(hdc, &rc, GetSysColorBrush(COLOR_BTNSHADOW));
        EndPaint(hwnd, &ps);
        break;
    }

    // Pass all other messages to the base window procedure.
    return CallWindowProc(gs_staticproc, hwnd, uMsg, wparam, lparam);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::CTreeView
// Purpose:   
// Arguments: 
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CTreeView::CTreeView()
{
    m_himl = NULL;
    m_hwnd = NULL;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::Resize
// Purpose:   
// Arguments: 
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CTreeView::Resize(RECT *prc)
{
    int nH = 20;
    MoveWindow(m_hwndStatic, prc->left, prc->top, prc->right - prc->left,
               nH, TRUE);
    MoveWindow(m_hwnd, prc->left, prc->top + nH, prc->right - prc->left,
               prc->bottom - prc->top-nH, TRUE);
    UpdateWindow(m_hwnd);
    UpdateWindow(m_hwndStatic);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::Init
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CTreeView::Init(HWND hwndParent)
{
    // Create the Win32 treeview control.
    m_hwndStatic = CreateWindow("static", "Folders", WS_VISIBLE | WS_CHILD, 
                            0, 0, 0, 0, hwndParent, (HMENU) WNDID_TREEVIEW_STATIC, g_hInst, NULL); 
    assert(gs_staticproc == NULL); // Only allow one instance for now.
    gs_staticproc = (WNDPROC) SetWindowLong(m_hwndStatic, GWL_WNDPROC,
                                             (LONG)StaticProc);
    // Create the GDI font object
    LOGFONT lf;
    memset(&lf, 0, sizeof(lf));
    lf.lfHeight = -11;
    lf.lfWeight = 0;
    strcpy(lf.lfFaceName, "Tahoma");
    m_hfont = CreateFontIndirect(&lf);
    
    m_hwnd = CreateWindowEx(0, WC_TREEVIEW, "", WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS |
                            TVS_HASLINES | TVS_HASBUTTONS |
                            TVS_LINESATROOT |TVS_SHOWSELALWAYS, 
                            0, 0, 0, 0, hwndParent, (HMENU) WNDID_TREEVIEW, g_hInst, NULL); 

    // Overload the default window procedure so that we can apply our own
    // mouse button handling.
    assert(gs_treeviewproc == NULL); // Only allow one instance for now.
    gs_treeviewproc = (WNDPROC) SetWindowLong(m_hwnd, GWL_WNDPROC,
                                             (LONG)TreeViewProc);
    g_ptreeview = this;
    
    // Initialize the image list for the treeview item icons.
    if (!InitImageList())
        return FALSE; 

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::Uninit
// Purpose:   
// Arguments: 
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CTreeView::Uninit()
{
    if (m_himl)
        ImageList_Destroy(m_himl);
    if (m_hwnd)
        DestroyWindow(m_hwnd);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::InitImageList
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CTreeView::InitImageList() 
{ 
    HBITMAP hbmp;

    // Create the image list. 
    m_himl = ImageList_Create(16, 16, ILC_COLOR8, 1, 0);
    if (m_himl == NULL) 
        return FALSE; 

    hbmp = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_TREEVIEW)); 
    if (hbmp == NULL)
        return FALSE;

    int nImageIndex = ImageList_Add(m_himl, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp); 

    if (nImageIndex == -1)
        return FALSE;

    // Associate the image list with the tree-view control. 
    TreeView_SetImageList(m_hwnd, m_himl, TVSIL_NORMAL); 
    TreeView_SetImageList(m_hwnd, m_himl, TVSIL_STATE); 

    return TRUE; 
} 

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::AddItem
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HTREEITEM CTreeView::AddItem(CFileObject *pfo, int nLevel, HTREEITEM htiParent)
{ 
    TVITEM tvi; 
    TVINSERTSTRUCT tvins; 
    static HTREEITEM hPrev = (HTREEITEM) TVI_FIRST; 
 
    tvi.mask = TVIF_TEXT | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_IMAGE;
 
    if (nLevel == 1)
    {
        tvi.iImage = IMAGE_XROOT; 
        tvi.iSelectedImage = IMAGE_XROOT; 
        tvi.pszText = "Game Disc Root"; 
    }
    else
    {
        tvi.iImage = IMAGE_FOLDERCLOSED; 
        tvi.iSelectedImage = IMAGE_FOLDEROPEN; 
        tvi.pszText = pfo->m_szName; 
    }
    tvi.cchTextMax = lstrlen(tvi.pszText); 
 
    // Save the heading level in the item's application-defined 
    // data area. 
    tvi.lParam = (LPARAM) pfo; 
 
    tvins.item = tvi; 
    tvins.hInsertAfter = hPrev; 
 
    // Set the parent item based on the specified level. 
    tvins.hParent = htiParent; 
 
    // Add the item to the tree-view control. 
    hPrev = (HTREEITEM) SendMessage(m_hwnd, TVM_INSERTITEM, 0, 
                                    (LPARAM) (LPTVINSERTSTRUCT) &tvins); 

    return hPrev; 
} 

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::SetCheckState
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CTreeView::SetCheckState(HTREEITEM hItem, eCheckState checkstate)
{
    TVITEM tvItem;

    ((CFileObject*)GetTVItemLPARAM(hItem))->m_checkstate = checkstate;
    
    tvItem.mask = TVIF_HANDLE | TVIF_STATE;
    tvItem.hItem = hItem;
    tvItem.stateMask = TVIS_STATEIMAGEMASK;

    switch (checkstate) {
    case CHECKSTATE_CHECKED:
        tvItem.state = INDEXTOSTATEIMAGEMASK(IMAGE_CHECK);
        break;
    case CHECKSTATE_UNCHECKED:
        tvItem.state = INDEXTOSTATEIMAGEMASK(IMAGE_UNCHECK);
        break;
    case CHECKSTATE_TRISTATE:
        tvItem.state = INDEXTOSTATEIMAGEMASK(IMAGE_TRISTATE);
        break;
    }

    return TreeView_SetItem(m_hwnd, &tvItem);
}

BOOL CTreeView::RecurseSetCheckState(HTREEITEM hItem, eCheckState checkstate)
{
    HTREEITEM htiParent = TreeView_GetParent(m_hwnd, hItem);

    if (htiParent)
        if (!SetCheckState(hItem, checkstate))
            return FALSE;

    // Now, for every child of htiCur, set its state to match htiCur
    if (checkstate != CHECKSTATE_TRISTATE)
        RecurseDownSetState(hItem, checkstate);
        
    // now, for every parent of htiCur, enumerate its children and set state appropriately
    // This is necessary since the state may be the greyed out 'tristate'.
    if (htiParent)
        RecurseUpSetState(htiParent);

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::GetCheckState
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
eCheckState CTreeView::GetCheckState(HTREEITEM hItem)
{
    TVITEM tvItem;

    // Prepare to receive the desired information.
    tvItem.mask = TVIF_HANDLE | TVIF_STATE;
    tvItem.hItem = hItem;
    tvItem.stateMask = TVIS_STATEIMAGEMASK;

    // Request the information.
    TreeView_GetItem(m_hwnd, &tvItem);

    // Return zero if it's not checked, or nonzero otherwise.
    switch (tvItem.state >> 12) {
    case IMAGE_CHECK:    return CHECKSTATE_CHECKED;
    case IMAGE_UNCHECK:  return CHECKSTATE_UNCHECKED;
    case IMAGE_TRISTATE: return CHECKSTATE_TRISTATE;
    }
    return CHECKSTATE_UNDEFINED;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::ToggleCheckState
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CTreeView::ToggleCheckState(HTREEITEM htiCur)
{
    eCheckState checkstate = GetCheckState(htiCur);
    if (checkstate == CHECKSTATE_UNCHECKED)
        checkstate = CHECKSTATE_CHECKED;
    else
        checkstate = CHECKSTATE_UNCHECKED;
    
    if (!SetCheckState(htiCur, checkstate))
        return;

    // Now, for every child of htiCur, set its state to match htiCur
    RecurseDownSetState(htiCur, checkstate);
        
    // now, for every parent of htiCur, enumerate its children and set state appropriately
    // This is necessary since the state may be the greyed out 'tristate'.
    RecurseUpSetState(TreeView_GetParent(m_hwnd, htiCur));
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::GetTVItemLPARAM
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
INT CTreeView::GetTVItemLPARAM(HTREEITEM hti)
{
    TVITEM tvi;
    tvi.mask = TVIF_HANDLE | TVIF_PARAM;
    tvi.hItem = hti;
    TreeView_GetItem(m_hwnd, &tvi);

    return tvi.lParam;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::RecurseDownSetState
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CTreeView::RecurseDownSetState(HTREEITEM htiCur, eCheckState checkstate)
{
    HTREEITEM htiChild = TreeView_GetChild(m_hwnd, htiCur);
    while (htiChild)
    {
        SetCheckState(htiChild, checkstate);
        RecurseDownSetState(htiChild, checkstate);

        htiChild = TreeView_GetNextSibling(m_hwnd, htiChild);
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::RecurseUpSetState
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CTreeView::RecurseUpSetState(HTREEITEM htiCur)
{
    // Determine the state of the current item based on the state of all
    // its child items.
    // if ALL == unchecked, this == unchecked
    // if ALL == checked, this == checked
    // else this == tristate

    // Stop if this is the root
    CFileObject *pfo = (CFileObject*)GetTVItemLPARAM(htiCur);
    assert(pfo);
    if (pfo->m_nDepth == 1)
        return;

    // Get the check state of the first child.
    CFileObject *pfoChild = pfo->m_lpfoChildren.GetFirst();
    assert(pfoChild);
    eCheckState csAggregate = pfoChild->m_checkstate;
    while ((pfoChild = pfo->m_lpfoChildren.GetNext()) != NULL)
    {
        eCheckState csChild = pfoChild->m_checkstate;
        if (csChild != csAggregate)
        {
            // Our children have different states; we're thus tristate
            csAggregate = CHECKSTATE_TRISTATE;
            break;
        } 
    }

    SetCheckState(htiCur, csAggregate);
    RecurseUpSetState(TreeView_GetParent(m_hwnd, htiCur));
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::HandleMouseDown
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CTreeView::HandleMouseDown(int nX, int nY)
{
    // Find the item (if any) the cursor is over
    RECT rcItem;
    HTREEITEM htiCur = TreeView_GetFirstVisible(m_hwnd);
    POINT pt = {nX, nY};
    int nIndent = TreeView_GetIndent(m_hwnd);

    while (htiCur)
    {
        // Is the mouse over the line containing the current item?
        TreeView_GetItemRect(m_hwnd, htiCur, &rcItem, FALSE);
        if (PtInRect(&rcItem, pt) && rcItem.top != 0)
        {
            // Mouse is over the line.  Is it over the checkbox?  Get the
            // indentation level of the item.
            rcItem.left = nIndent * ((CFileObject*)GetTVItemLPARAM(htiCur))->m_nDepth;
            rcItem.right = rcItem.left + 13;

            if (PtInRect(&rcItem, pt))
            {
                // Yep, it's over the checkbox -- Toggle it
                ToggleCheckState(htiCur);

                g_vmExplorer.m_listview.SetChildrenCheckState((CFileObject*)GetTVItemLPARAM(htiCur));
                InvalidateRect(g_vmExplorer.m_listview.m_hwnd, NULL, FALSE);
                
                SetModified();

                // return that we handled the message
                return TRUE;
            }

            // Mouse isn't over the checkbox -- let the OS handle the msg
            return FALSE;
        }
        htiCur = TreeView_GetNextVisible(m_hwnd, htiCur);
    }

    // Mouse wasn't over any item
    return FALSE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CTreeView::Populate
// Purpose:   Adds pfiCur and (recursively) each of its subfolders.
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CTreeView::Populate(CFileObject *pfoCur)
{
    HTREEITEM htiParent;

    assert (pfoCur != NULL);
    assert (pfoCur->m_fIsDir);

    // If pfiCur doesn't have a parent, then it's the root node.
    if (pfoCur->m_pfoParent == NULL)
        htiParent = TVI_ROOT;
    else
        htiParent = pfoCur->m_pfoParent->m_hti;

    // Add pfoCur to the treeview and set its default check state.
    pfoCur->m_hti = AddItem(pfoCur, pfoCur->m_nDepth, htiParent);
    if (pfoCur->m_nDepth > 1)
        SetCheckState(pfoCur->m_hti, pfoCur->m_checkstate);

    // Then recurse into each of its child folders and add them.
    CFileObject *pfoChild = pfoCur->m_lpfoChildren.GetFirst();
    while (pfoChild)
    {
        if (pfoChild->m_fIsDir)
            if (!Populate(pfoChild))
                return FALSE;
        pfoChild = pfoCur->m_lpfoChildren.GetNext();
    }    

    return TRUE;
}

void CTreeView::HandleSelection(LPNMTREEVIEW pnmhdr)
{
    TVITEM item;
    item.hItem = pnmhdr->itemNew.hItem;
    item.mask = TVIF_PARAM;
    TreeView_GetItem(m_hwnd, &item);

    g_vmExplorer.m_listview.SetDir((CFileObject*)item.lParam);
}

void CTreeView::SetCurFolder(CFileObject *pfo)
{
    TreeView_SelectItem(m_hwnd, pfo->m_hti);
    TreeView_Expand(m_hwnd, pfo->m_hti, TVE_EXPAND);
}

void CTreeView::AddObject(CFileObject *pfo)
{
    pfo->m_hti = AddItem(pfo, pfo->m_pfoParent->m_nDepth + 1, pfo->m_pfoParent->m_hti);
    pfo->m_nDepth = pfo->m_pfoParent->m_nDepth + 1;
    SetCheckState(pfo->m_hti, pfo->m_checkstate);
}

void CTreeView::RemoveObject(CFileObject *pfo)
{
    TreeView_DeleteItem(m_hwnd, pfo->m_hti);
}

void CTreeView::Clear()
{
    TreeView_DeleteAllItems(m_hwnd);
    InvalidateRect(m_hwnd, NULL, TRUE);
    UpdateWindow(m_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CUnplacedListView.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CUnplacedListView.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

enum {COL_NAME = 0, COL_FOLDER, COL_SIZEONDISK};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CUnplacedListView::Init
// Purpose:   
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CUnplacedListView::Init(HWND hwndParent)
{
    // initialize our 'MyListView' object.
    if (!CMyListView::Init(hwndParent))
        return FALSE;

    SHFILEINFO sfi;
    ZeroMemory(&sfi, sizeof(sfi));
    DWORD flg = SHGFI_ICON | SHGFI_SMALLICON | SHGFI_SYSICONINDEX;
    m_himlFileIcons = (HIMAGELIST)SHGetFileInfo("C:\\", 0, &sfi, sizeof(sfi), flg);

    // init columns for listview
    // NOTE: Order must match order in COL_* enumeration
    AddColumn("Name", 150);
    AddColumn("Folder", 250);
    AddColumn("Size on Disk", 75);

    // Create the GDI font object
    LOGFONT lf;
    memset(&lf, 0, sizeof(lf));
    lf.lfHeight = -11;
    lf.lfWeight = 0;
    strcpy(lf.lfFaceName, "Tahoma");
    m_hfont = CreateFontIndirect(&lf);

    m_iSortColumn = COL_NAME;
    return TRUE;
}

#define LVF_ITEMSELECTED 1
#define LVF_ITEMFOCUSED  2
 
void CUnplacedListView::UpdateItem(void *pvItem, DWORD dwItemState, int iColumn, HDC hdcDest, RECT *prcDest)
{
    char *psz;
    int nW;
    CFileObject *pfo = (CFileObject*)pvItem;
    DWORD dwAlign = DT_LEFT;

    // if prcClip is NULL, then the item is completely offscreen
    if (prcDest == NULL)
        return;

    // undone: Can choose to use offscreenbuffer only when resizing if so desire (not really necessary for scroll/update)
#define OFFSCREENBUFFER
#ifdef OFFSCREENBUFFER
    static HBITMAP s_hbmpOff;
    static int s_nLastWidth = -1, s_nLastHeight = -1;
    RECT rcOrig = *prcDest;
    prcDest->bottom -= prcDest->top;
    prcDest->top = 0;
    prcDest->right -= prcDest->left;
    prcDest->left = 0;
    
    HDC hdcOffscreen = CreateCompatibleDC(hdcDest);
    if (prcDest->right - prcDest->left > s_nLastWidth  || prcDest->bottom - prcDest->top > s_nLastHeight)
    {
        s_hbmpOff = CreateCompatibleBitmap(hdcDest, prcDest->right - prcDest->left,
                                           prcDest->bottom - prcDest->top);
        s_nLastWidth = prcDest->right - prcDest->left;
        s_nLastHeight = prcDest->bottom - prcDest->top;
        DebugOutput("create (%d, %d)\n", s_nLastWidth, s_nLastHeight);
    }
    HBITMAP hbmpPrevOff = (HBITMAP)SelectObject(hdcOffscreen, s_hbmpOff);
#else
    HDC hdcOffscreen = hdcDest;
#endif
    SelectObject(hdcOffscreen, m_hfont);
    if (dwItemState & LVF_ITEMSELECTED)
    {
        if (dwItemState & LVF_ITEMFOCUSED)
        {
            FillRect(hdcOffscreen, prcDest, GetSysColorBrush(COLOR_HIGHLIGHT));
            SetBkColor(hdcOffscreen, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(hdcOffscreen, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            FillRect(hdcOffscreen, prcDest, GetSysColorBrush(COLOR_INACTIVEBORDER));
            SetBkColor(hdcOffscreen, GetSysColor(COLOR_INACTIVEBORDER));
            SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOWTEXT));
        }
    }
    else
    {
        FillRect(hdcOffscreen, prcDest, GetSysColorBrush(COLOR_WINDOW));
        SetBkColor(hdcOffscreen, GetSysColor(COLOR_WINDOW));
        SetTextColor(hdcOffscreen, GetSysColor(COLOR_WINDOWTEXT));
    }
    if (iColumn != 0)
    {
        prcDest->right -= 5;
        prcDest->top ++;
    }
//enum {COL_NAME = 0, COL_FOLDER, COL_SIZEONDISK, COL_SECTORRANGE};

    switch(iColumn)
    {
    case COL_NAME:
        nW = min(GetSystemMetrics(SM_CXSMICON), prcDest->right - prcDest->left);
        if (nW > 0 && pfo->m_fIsDir)
        {
            DWORD dwFlags = ILD_TRANSPARENT | ILD_NORMAL;
            if (dwItemState & LVF_ITEMSELECTED && dwItemState & LVF_ITEMFOCUSED)
                dwFlags |= ILD_SELECTED;
            ImageList_Draw(m_himlFileIcons, pfo->m_iIcon, hdcOffscreen, prcDest->left, prcDest->top, dwFlags);
            prcDest->left += 20;
        }

        psz = pfo->m_szName;
        break;

    case COL_FOLDER:      psz = pfo->m_szFolder;      break;
    case COL_SIZEONDISK:  psz = pfo->m_szSizeOnDisk;  break;
    }
    if (psz)
        DrawTextEx(hdcOffscreen, psz, strlen(psz), prcDest, dwAlign | DT_END_ELLIPSIS, NULL);
#ifdef OFFSCREENBUFFER
    BitBlt(hdcDest, rcOrig.left, rcOrig.top,
           rcOrig.right - rcOrig.left, rcOrig.bottom - rcOrig.top,
           hdcOffscreen, 0, 0, SRCCOPY);
    SelectObject(hdcOffscreen, hbmpPrevOff);
    DeleteDC(hdcOffscreen);
#endif
}

DWORD CUnplacedListView::GetItemWidth(HDC hdc, void *pvItem, int iColumn)
{
    CFileObject *pfo = (CFileObject*)pvItem;
    SIZE    size;
    char    *psz;
    int     nAdd = 0;

    switch(iColumn)
    {
    case COL_NAME:        psz = pfo->m_szName;     if (pfo->m_fIsDir) nAdd = 20; break;
    case COL_FOLDER:      psz = pfo->m_szFolder;      break;
    case COL_SIZEONDISK:  psz = pfo->m_szSizeOnDisk;  break;
    }

    GetTextExtentPoint32(hdc, psz, strlen(psz), &size);
    SetTextJustification(hdc, 0, 0);
    return size.cx + nAdd + 5; // +5 for the padding we add during drawing
}

// return -1 if pv1 is "less than" pv2
// return 1 if pv2 is "less than" pv1
// return 0 if pv1 "equals" pv2
int CUnplacedListView::CompareObjects(const void *pv1, const void *pv2)
{
    int nRet;

    // pv1 and pv2 are passed in as pointers to array elements.  Do
    // some wacky casting to get the actual object pointers.
    CFileObject *po1 = ((CFileObject*)*(DWORD*)pv1);
    CFileObject *po2 = ((CFileObject*)*(DWORD*)pv2);

    // If one of the objects is a directory and the other isn't, then the directory
    // always comes first
    bool f1 = po1->m_dwa & FILE_ATTRIBUTE_DIRECTORY ? true : false;
    bool f2 = po2->m_dwa & FILE_ATTRIBUTE_DIRECTORY ? true : false;
    if (f1 && !f2)
        return -1;
    if (f2 && !f1)
        return 1;

    switch(m_iSortColumn)
    {
    case COL_NAME:
        return _stricmp(po1->m_szName, po2->m_szName);

    case COL_FOLDER:
        nRet = _stricmp(po1->m_szFolder, po2->m_szFolder);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;

    case COL_SIZEONDISK:
        nRet = _stricmp(po1->m_szSizeOnDisk, po2->m_szSizeOnDisk);
        if (nRet == 0)
            nRet = _stricmp(po1->m_szName, po2->m_szName);
        return nRet;
    }
    assert(true);
    return 0;
}

// Over a checkbox? If so, uncheck it
BOOL CUnplacedListView::Override_LButtonDown(sMouseInfo *pmi, DWORD dwFlags)
{
    return TRUE;
}

BOOL CUnplacedListView::Override_LButtonDblClick(sMouseInfo *pmi, DWORD dwFlags)
{
    return TRUE;
}

BOOL CUnplacedListView::Override_MouseMove(sMouseInfo *pmi, DWORD dwFlags)
{
    return TRUE;
}

void CUnplacedListView::AddObject(void *pvObj)
{
    AddItemAtIndex(pvObj, 0);
}

void CUnplacedListView::RemoveObject(void *pvObj)
{
    DeleteItem(pvObj);
}

void CUnplacedListView::RefreshObject(void *pvObj)
{
    // UNDONE: very unoptimized
    for (int i = 0; i < m_cItems; i++)
    {
        if (m_rgli[i].pvData == pvObj)
        {
            // Found it.  Update size and time
            ((CFileObject*)pvObj)->UpdateSizeTime();
            RefreshItem(i);
            m_fDirty = true;
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CUnplacedWindow.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CUnplacedWindow.cpp
// Contents:  
// Revisions: 31-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CUnplacedWindow *g_punplacedTemp = NULL;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UnplacedWndProc
// Purpose:   Subclassed window procedure for the unplaced window.
// Arguments: hwnd              -- The handle to the window that the message is
//                                 intended for.
//            uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LONG FAR PASCAL UnplacedWndProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    RECT rc = {0};
    WINDOWPLACEMENT wp;

    // Determine which CUnplacedWindow this message is actually intended for.
    CUnplacedWindow *punplaced = (CUnplacedWindow*)GetWindowLong(hwnd, GWL_USERDATA);
    if (!punplaced)
    {
        assert(g_punplacedTemp);
        SetWindowLong(hwnd, GWL_USERDATA, (long)g_punplacedTemp);
        punplaced = g_punplacedTemp;
        g_punplacedTemp = NULL;
    }

    switch (uMsg)
    {
    case WM_SIZE:
        rc.right = LOWORD(lparam);
        rc.bottom = HIWORD(lparam) - punplaced->m_statusbar.GetHeight();
        punplaced->m_listview.Resize(&rc);
        punplaced->m_statusbar.Resize(LOWORD(lparam), HIWORD(lparam));        
        // fallthru

    case WM_MOVE:
        wp.length = sizeof wp;
        GetWindowPlacement(hwnd, &wp);

        g_nUnplacedWindowX = wp.rcNormalPosition.left;
        g_nUnplacedWindowY = wp.rcNormalPosition.top;
        g_nUnplacedWindowW = wp.rcNormalPosition.right  - wp.rcNormalPosition.left;
        g_nUnplacedWindowH = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
        break;  
        
 //   case WM_SHOWWINDOW:
   //     if (wparam == TRUE)
     //       SetForegroundWindow(punplaced->m_hwndParent);
  //          ShowWindow(punplaced->m_hwndParent, SW_SHOW);
  //      break;

    case WM_CLOSE:
        // User clicked on the 'close' button on the unplaced window.  Tell the
        // main window to hide us
        SendMessage(punplaced->m_hwndParent, WM_COMMAND, IDM_VIEW_UNPLACED, 0);
        g_tbm.CheckButton(TB_LAYER, IDM_VIEW_UNPLACED, 0);

        // Return zero so that we tell the OS "we handled the message; DON'T
        // close the window"
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wparam, lparam);
}

BOOL CUnplacedWindow::Init(CViewMode *pvmParent, HWND hwndParent)
{
    WNDCLASSEX wcex;
    static bool sfRegedUnplaced = false;

    m_hwndParent = hwndParent;
    m_pvmParent = pvmParent;
    m_fVisible = FALSE;
    
    if (!sfRegedUnplaced)
    {
        // Register the class for the app's window.
        memset(&wcex, 0, sizeof wcex);
        wcex.cbSize        = sizeof wcex; 
        wcex.lpfnWndProc   = UnplacedWndProc;
        wcex.hInstance     = g_hInst;
        wcex.lpszClassName = "UnplacedWindow";
        if (!RegisterClassEx(&wcex))
            return NULL;
        sfRegedUnplaced = true;
    }

    assert(g_punplacedTemp == NULL);
    g_punplacedTemp = this;
    m_hwnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                            "UnplacedWindow", "Unplaced Files Window",
                            WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION |
                            WS_THICKFRAME | WS_CLIPSIBLINGS | WS_SYSMENU,
                            g_nUnplacedWindowX, g_nUnplacedWindowY,
                            g_nUnplacedWindowW, g_nUnplacedWindowH,
                            hwndParent, NULL, g_hInst, NULL);

    if (!m_listview.Init(m_hwnd))
        return FALSE;

    // Initialize the status bar
    m_statusbar.Init(m_hwnd);
    m_statusbar.SetNumParts(1);
    
    RECT rc;
    GetClientRect(m_hwnd, &rc);
    m_statusbar.Resize(rc.right, rc.bottom);
    
    rc.bottom -= m_statusbar.GetHeight();
    m_listview.Resize(&rc);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CUpdateBox.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CUpdateBox.h
// Contents:  
// Revisions: 15-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CUpdateBox
{
public:
    CUpdateBox();
    ~CUpdateBox();
    void Start(char *szTitle);
    void Stop();

    void SetStatus(char *szStatus);
    void SetFileCount(int nFiles);
    void SetFolderCount(int nFolders);

    DWORD UpdateBoxThread();
    LRESULT CALLBACK UpdateBoxDialog(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
    HWND m_hwnd;

private:
    HANDLE m_hthread;
    HANDLE m_hevtStopUpdate;
    CRITICAL_SECTION m_csStatusText;
    bool m_fNewStatus;
    bool m_fNewObjCount;
    char m_szStatusText[255];
    char m_szFiles[20];
    char m_szFolders[20];
    char m_szTitle[1024];
    int m_nPeriods;
};

extern CUpdateBox *g_pupdateboxCur;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CUnplacedWindow.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CUnplacedWindow.h
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CViewMode;
class CStatusBar;

class CUnplacedWindow
{
public:
    BOOL Init(CViewMode *pvmParent, HWND hwndParent);

    WNDPROC m_pfnUnplacedWndProc;
    void SetVisible(BOOL fVisible) {
        ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE); 
        if (fVisible)
            InvalidateRect(m_hwnd, NULL, TRUE);

    }
    void ToggleView() {
        m_fVisible = !m_fVisible;
        SetVisible(m_fVisible);
    }
    HWND m_hwnd;
    CUnplacedListView m_listview;
    CStatusBar m_statusbar;
    HWND m_hwndParent;
    BOOL m_fVisible;
    
private:

    CViewMode *m_pvmParent;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CUpdateBox.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CUpdateBox.cpp
// Contents:  
// Revisions: 15-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UpdateBoxThread
// Purpose:   Non-instance-specific version of the thread.  Immediately
//            calls into the correct instance.
// Arguments: pvArg     -- The CUpdateBox that this thread 'belongs to'
// Return:    '0' for success, '-1' for failure
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD WINAPI UpdateBoxThread(LPVOID pvArg)
{
    return ((CUpdateBox*)pvArg)->UpdateBoxThread();
}

CUpdateBox::CUpdateBox()
{
    m_fNewStatus = false;
    m_fNewObjCount = false;
    InitializeCriticalSection(&m_csStatusText);

    strcpy(m_szTitle, "");
    strcpy(m_szStatusText, "");
    SetFileCount(-1);
    SetFolderCount(-1);
    
    m_hthread  = NULL;
    m_hevtStopUpdate = CreateEvent(NULL, FALSE, FALSE, "StopUpdate");
}

CUpdateBox::~CUpdateBox()
{
    if (m_hthread)
        Stop();
    DeleteObject(m_hevtStopUpdate);
}

CUpdateBox *g_pupdateboxCur = NULL;

void CUpdateBox::Start(char *szTitle)
{
    strcpy(m_szTitle, szTitle);
    m_nPeriods = 0;
    m_fNewStatus = false;
    strcpy(m_szStatusText, "");
    SetFileCount(-1);
    SetFolderCount(-1);

    // WARNING: This does not allow multiple UpdateBoxes to appear
    // simultaneously.  I do not need that functionality here...
    assert(g_pupdateboxCur == NULL);
    g_pupdateboxCur = this;

    // Spawn the thread that displays the dialog box
    m_hthread = CreateThread(NULL, 0, ::UpdateBoxThread, this, 0, NULL);

}
extern BOOL g_fQuit;

void CUpdateBox::Stop()
{
    // Tell the dialog box thread to stop and go away
    SetEvent(m_hevtStopUpdate);

    // Wait for the dialog box thread to die
    MSG msg;
    while (WaitForSingleObject(m_hthread, 0) == WAIT_TIMEOUT)
    {
        if (PeekMessage(&msg, NULL,  0, 0, PM_REMOVE)) 
        {

            if (!TranslateAccelerator(g_hwndMain, g_haccel, &msg))
            {
                if (msg.message == WM_QUIT)
                {
                    // User is trying to quit the application.
                    g_fQuit = true;
                    break;
                }
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }    

    // At this point, the FileSystemChange thread has exited.  undone: need to delete?
    DeleteObject(m_hthread);
    m_hthread = NULL;
    
    g_pupdateboxCur = NULL;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UpdateBoxDialog
// Return:    nonzero if we processed the message
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK UpdateBoxDialog(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    return g_pupdateboxCur->UpdateBoxDialog(hwnd, message, wParam, lParam);
}

LRESULT CALLBACK CUpdateBox::UpdateBoxDialog(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static int s_iTimer;
    static DWORD s_dwLastPeriod;
    DWORD dwTime;

	switch(message)
	{
	case WM_INITDIALOG:
        m_hwnd = hwnd;

        SetWindowText(hwnd, m_szTitle);
        s_iTimer = SetTimer(hwnd, 1, 50, NULL);
        SetDlgItemText(hwnd, IDC_STATUS, "");
        SetDlgItemText(hwnd, IDC_PROGRESS, "");
        CenterDialog(hwnd);
        SetForegroundWindow(hwnd);
		return 1;

    case WM_TIMER:
        if (WaitForSingleObject(m_hevtStopUpdate, 0) == WAIT_OBJECT_0)
        {
            // we're done!
            KillTimer(hwnd, s_iTimer);
            EndDialog(hwnd, 0);
            return 1;
        }

        // New text?
        if (m_fNewStatus)
        {
            EnterCriticalSection(&m_csStatusText);
            SetDlgItemText(hwnd, IDC_STATUS, m_szStatusText);
            LeaveCriticalSection(&m_csStatusText);
            s_dwLastPeriod = GetTickCount();
            m_fNewStatus = false;
        }

        if (m_fNewObjCount)
        {
            EnterCriticalSection(&m_csStatusText);
            SetDlgItemText(hwnd, IDC_FILES, m_szFiles);
            SetDlgItemText(hwnd, IDC_FOLDERS, m_szFolders);
            LeaveCriticalSection(&m_csStatusText);
            m_fNewObjCount = false;
        }

        // Time to add a period?
        dwTime = GetTickCount();

        if (dwTime > s_dwLastPeriod + 1000)
        {
            char szText[100];
            if (m_nPeriods > 10)
            {
                strcpy(szText, m_szStatusText);
                m_nPeriods = 0;
            }
            else
            {
                GetDlgItemText(hwnd, IDC_STATUS, szText, 100);
                strcat(szText, ". ");
                m_nPeriods++;
            }
            SetDlgItemText(hwnd, IDC_STATUS, szText);
            s_dwLastPeriod = dwTime;
        }
        break;
	}
	return FALSE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UpdateBoxThread
// Purpose:   Display a modal dialog box with update contents
// Arguments: None
// Returns:   '0' if successfully connected; '-1' otherwise.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD CUpdateBox::UpdateBoxThread()
{
    DialogBox(g_hInst, MAKEINTRESOURCE(IDD_UPDATEBOXDLG), g_hwndMain, (DLGPROC) ::UpdateBoxDialog);
    return 0;
}

void CUpdateBox::SetStatus(char *szStatus)
{
    EnterCriticalSection(&m_csStatusText);
    sprintf (m_szStatusText, szStatus);
    LeaveCriticalSection(&m_csStatusText);

    sprintf(m_szFiles, "");
    sprintf(m_szFolders, "");
    m_fNewStatus = true;
}

void CUpdateBox::SetFileCount(int nFiles)
{
    EnterCriticalSection(&m_csStatusText);
    if (nFiles == -1)
        sprintf(m_szFiles, "Files: ");
    else
        sprintf(m_szFiles, "Files: %d", nFiles);
    LeaveCriticalSection(&m_csStatusText);
    m_fNewObjCount = true;
}

void CUpdateBox::SetFolderCount(int nFolders)
{
    EnterCriticalSection(&m_csStatusText);
    if (nFolders == -1)
        sprintf(m_szFolders, "Folders: ");
    else
        sprintf(m_szFolders, "Folders: %d", nFolders);
    LeaveCriticalSection(&m_csStatusText);
    m_fNewObjCount = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CViewMode_Layer.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CViewMode_Layer.h
// Contents:  
// Revisions: 31-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef enum eLayer {LV_LAYER0 = 0, LV_LAYER1, LV_UNPLACED};
typedef enum eLayerViewMode {LVM_LAYER0, LVM_LAYER1, LVM_BOTHLAYERS};

class CViewMode_Layer : public CViewMode
{
public:
    BOOL Init(HWND hwndParent);

    void Show();
    void Hide();
    void Resize(int nW, int nH);
    void HandleEvent(eEvent event, CFileObject *pfo);
    void UpdateIfDirty();
    void Clear();
    void HandleMenuCommand(WORD command);

    CUnplacedWindow m_unplaced;
private:
    void Resize();
    void ViewLayer(eLayerViewMode lvm, DWORD dwCmd);

    CLayerListView m_rglv[3];
    CSplitter m_splitter;
    eLayerViewMode m_lvmCur;
    int m_nW, m_nH;
    BOOL m_fVisible;
};

extern CViewMode_Layer g_vmLayer;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CViewMode_Explorer.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CViewMode_Explorer.h
// Contents:  
// Revisions: 31-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CViewMode_Explorer : public CViewMode
{
public:
    BOOL Init(HWND hwndParent);

    void Show();
    void Hide();
    void Resize(int nW, int nH);
    void HandleEvent(eEvent event, CFileObject *pfo);
    void UpdateIfDirty();
    void Clear();
    void HandleMenuCommand(WORD command);

    CTreeView m_treeview;
    CExpListView m_listview;
    CSplitter m_splitter;
};

extern CViewMode_Explorer g_vmExplorer;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\Debug.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      Debug.cpp
// Contents:  
// Revisions: 7-Dec-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"

extern CChangeQueue g_cq;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void Debug_VerifyState()
{
    // Tell the filesystemchange thread to force a sync and validate it's local fs.
    g_cq.ValidateFileSystem();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\Debug.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      Debug.h
// Contents:  
// Revisions: 7-Dec-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void Debug_VerifyState();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CViewMode.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CViewMode.h
// Contents:  
// Revisions: 31-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


class CViewMode
{
public:
    virtual void Show() = NULL;
    virtual void Hide() = NULL;
    virtual void Resize(int nW, int nH) = NULL;
    virtual void HandleEvent(eEvent event, CFileObject *pfo) = NULL;
    virtual void UpdateIfDirty() = NULL;
    virtual void Clear() = NULL;
    virtual void HandleMenuCommand(WORD command) = NULL;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CViewMode_Explorer.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CViewMode_Explorer.cpp
// Contents:  
// Revisions: 31-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

CViewMode_Explorer g_vmExplorer;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CViewMode_Explorer::Init(HWND hwndParent)
{
    RECT rc;

    // Initialize the treeview and listview.
    if (!m_treeview.Init(hwndParent))
        return FALSE;
    if (!m_listview.Init(hwndParent))
        return FALSE;

    // By default, split is halfway through window.
    if (!m_splitter.Init(this, hwndParent, g_nSplitterX))
        return FALSE;

    GetClientRect(hwndParent, &rc); 
    Resize(rc.right - rc.left, rc.bottom - rc.top);
    
    return TRUE;
}

void CViewMode_Explorer::Show()
{
    g_tbm.CheckButton(TB_GLOBAL, IDM_VIEW_FILE, TRUE);
    HMENU hmenu = GetMenu(g_hwndMain);
    CheckMenuItem(hmenu, IDM_VIEW_FILE, MF_CHECKED);
    m_splitter.SetVisible(TRUE);
    m_treeview.SetVisible(TRUE);
    m_listview.SetVisible(TRUE);
}

void CViewMode_Explorer::Hide()
{
    HMENU hmenu = GetMenu(g_hwndMain);
    CheckMenuItem(hmenu, IDM_VIEW_FILE, MF_UNCHECKED);
    m_splitter.SetVisible(FALSE);
    m_treeview.SetVisible(FALSE);
    m_listview.SetVisible(FALSE);
}

void CViewMode_Explorer::Resize(int nW, int nH)
{
    // Resize the various controls
    int nSplitterW = m_splitter.GetWidth();
    int nSplitterX = m_splitter.GetPos();
    int nRowHeight = g_tbm.GetRowsHeight();
    g_nSplitterX = nSplitterX;

    int nStatusH = g_statusbar.GetHeight();

    RECT rcTreeView = {0, nRowHeight, nSplitterX, nH-nStatusH};
    RECT rcListView = {nSplitterX + nSplitterW,  nRowHeight, nW, nH-nStatusH};
    RECT rcSplitter = {nSplitterX, nRowHeight, nSplitterX + nSplitterW, nH-nStatusH};

    m_splitter.Resize(&rcSplitter);
    m_treeview.Resize(&rcTreeView);
    m_listview.Resize(&rcListView);
}

void CViewMode_Explorer::UpdateIfDirty()
{
    m_listview.UpdateIfDirty();

    // treeview automatically refreshes
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleEvent
// Purpose:   
// Arguments: 
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CViewMode_Explorer::HandleEvent(eEvent event, CFileObject *pfo)
{
    switch(event)
    {
    case EVENT_ADDED:
        if (pfo->m_fIsDir)
            m_treeview.AddObject(pfo);
        m_listview.AddObject(pfo);
        break;

    case EVENT_REMOVED:
        // Remove the object from the treeview and listview as appropriate
        if (pfo->m_fIsDir)
            m_treeview.RemoveObject(pfo);
        m_listview.RemoveObject(pfo);
        break;
    
    case EVENT_TIMECHANGED:
    case EVENT_SIZECHANGED:
        m_listview.RefreshObject(pfo);
        break;
    }
}

void CViewMode_Explorer::Clear()
{
    m_listview.Clear();
    m_treeview.Clear();
}

void CViewMode_Explorer::HandleMenuCommand(WORD command)
{
    switch(command)
    {
    case IDM_EDIT_SELECTALL:
        m_listview.SelectAllItems();
        SetFocus(m_listview.m_hwnd);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\CViewMode_Layer.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CViewMode_Layer.cpp
// Contents:  
// Revisions: 31-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// g_vmLayer    -- The 'layer' view mode.  Contains several listviews
CViewMode_Layer g_vmLayer;

CFastToSlow m_ftosLeft;
CFastToSlow m_ftosRight;


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CViewMode_Layer::Init(HWND hwndParent)
{
    RECT rc;

    if (!m_rglv[LV_LAYER0].Init(hwndParent))
        return FALSE;
    if (!m_rglv[LV_LAYER1].Init(hwndParent))
        return FALSE;
    if (!m_rglv[LV_UNPLACED].Init(hwndParent))
        return FALSE;

    if (!m_ftosLeft.Init(hwndParent, RGB(255, 0, 0), RGB(0, 255, 0)))
        return FALSE;
    if (!m_ftosRight.Init(hwndParent, RGB(0, 255, 0), RGB(255, 0, 0)))
        return FALSE;

    if (!m_splitter.Init(this, hwndParent, g_nSplitterX2))
        return FALSE;

    if (!m_unplaced.Init(this, hwndParent))
        return FALSE;

    GetClientRect(hwndParent, &rc); 
    m_nW = rc.right - rc.left;
    m_nH = rc.bottom - rc.top;

    HandleMenuCommand(IDM_VIEW_LAYER0);
    
    return TRUE;
}

void CViewMode_Layer::Show()
{
    // Enable the layer view controls on the toolbar and menu
    g_tbm.CheckButton(TB_GLOBAL, IDM_VIEW_LAYOUT, TRUE);

    HMENU hmenu = GetMenu(g_hwndMain);
    CheckMenuItem(hmenu, IDM_VIEW_LAYOUT,      MF_CHECKED);

    EnableMenuItem(hmenu, IDM_EDIT_GROUP,      MF_ENABLED);
    EnableMenuItem(hmenu, IDM_EDIT_UNGROUP,    MF_ENABLED);
    EnableMenuItem(hmenu, IDM_VIEW_LAYER0,     MF_ENABLED);
    EnableMenuItem(hmenu, IDM_VIEW_LAYER1,     MF_ENABLED);
    EnableMenuItem(hmenu, IDM_VIEW_BOTHLAYERS, MF_ENABLED);
    EnableMenuItem(hmenu, IDM_VIEW_UNPLACED,   MF_ENABLED);

    g_tbm.EnableButton(TB_LAYER, IDM_EDIT_GROUP, TRUE);
    g_tbm.EnableButton(TB_LAYER, IDM_EDIT_UNGROUP, TRUE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_LAYER0, TRUE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_LAYER1, TRUE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_BOTHLAYERS, TRUE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_UNPLACED, TRUE);

    m_unplaced.SetVisible(g_tbm.IsButtonChecked(TB_LAYER, IDM_VIEW_UNPLACED));

    m_fVisible = true;
    Resize();
}

void CViewMode_Layer::Hide()
{
    // Disable the layer view controls on the toolbar and menu
    g_tbm.EnableButton(TB_LAYER, IDM_EDIT_GROUP, FALSE);
    g_tbm.EnableButton(TB_LAYER, IDM_EDIT_UNGROUP, FALSE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_LAYER0, FALSE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_LAYER1, FALSE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_BOTHLAYERS, FALSE);
    g_tbm.EnableButton(TB_LAYER, IDM_VIEW_UNPLACED, FALSE);

    HMENU hmenu = GetMenu(g_hwndMain);
    CheckMenuItem(hmenu, IDM_VIEW_LAYOUT,      MF_UNCHECKED);
    EnableMenuItem(hmenu, IDM_EDIT_GROUP,      MF_GRAYED);
    EnableMenuItem(hmenu, IDM_EDIT_UNGROUP,    MF_GRAYED);
    EnableMenuItem(hmenu, IDM_VIEW_LAYER0,     MF_GRAYED);
    EnableMenuItem(hmenu, IDM_VIEW_LAYER1,     MF_GRAYED);
    EnableMenuItem(hmenu, IDM_VIEW_BOTHLAYERS, MF_GRAYED);
    EnableMenuItem(hmenu, IDM_VIEW_UNPLACED,   MF_GRAYED);

    m_splitter.SetVisible(FALSE);
    m_rglv[LV_LAYER0].SetVisible(FALSE);
    m_rglv[LV_LAYER1].SetVisible(FALSE);
    m_ftosLeft.SetVisible(FALSE);
    m_ftosRight.SetVisible(FALSE);
    m_unplaced.SetVisible(FALSE);
    m_fVisible = false;
}

void CViewMode_Layer::Resize()
{
    Resize(m_nW, m_nH);
}

// Resize the various controls
void CViewMode_Layer::Resize(int nW, int nH)
{
    int nRowHeight = g_tbm.GetRowsHeight();
    int nStatusH = g_statusbar.GetHeight();
    int nFastToSlowW = 20;
    switch (m_lvmCur)
    {
    case LVM_LAYER0:
        {
            RECT rcLV   = {nFastToSlowW, nRowHeight, nW, nH-nStatusH};
            RECT rcFtoS = {0, nRowHeight, nFastToSlowW, nH-nStatusH};
            if (m_fVisible)
            {
                m_splitter.SetVisible(FALSE);
                m_rglv[LV_LAYER0].SetVisible(TRUE);
                m_rglv[LV_LAYER1].SetVisible(FALSE);
                m_ftosLeft.SetVisible(TRUE);
                m_ftosRight.SetVisible(FALSE);
            }
            m_rglv[LV_LAYER0].Resize(&rcLV);
            m_ftosLeft.Resize(&rcFtoS);
        }
        break;
    case LVM_LAYER1:
        {
            RECT rcLV = {0, nRowHeight, nW-nFastToSlowW, nH-nStatusH};
            RECT rcFtoS = {nW-nFastToSlowW, nRowHeight, nW, nH-nStatusH};
            if (m_fVisible)
            {
                m_splitter.SetVisible(FALSE);
                m_rglv[LV_LAYER0].SetVisible(FALSE);
                m_rglv[LV_LAYER1].SetVisible(TRUE);
                m_ftosRight.SetVisible(TRUE);
                m_ftosLeft.SetVisible(FALSE);
            }
            m_rglv[LV_LAYER1].Resize(&rcLV);
            m_ftosRight.Resize(&rcFtoS);

        }
        break;

    case LVM_BOTHLAYERS:
        {
            int nSplitterW = m_splitter.GetWidth();
            int nSplitterX = m_splitter.GetPos();
            int nSplitterPermX = m_splitter.GetPermPos();
            g_nSplitterX2 = nSplitterX;

            if (nW > nSplitterPermX+nFastToSlowW-2)
                nSplitterX = nSplitterPermX;
            else
                nSplitterX = nW - nFastToSlowW - 2;
            RECT rcLV0 = {nFastToSlowW, nRowHeight, nSplitterX, nH-nStatusH};
            RECT rcLV1 = {nSplitterX + nSplitterW,  nRowHeight, nW-nFastToSlowW, nH-nStatusH};
            RECT rcSplitter  = {nSplitterX, nRowHeight, nSplitterX + nSplitterW, nH-nStatusH};
            RECT rcFtoSRight = {nW-nFastToSlowW, nRowHeight, nW, nH-nStatusH};
            RECT rcFtoSLeft  = {0, nRowHeight, nFastToSlowW, nH-nStatusH};

            if (m_fVisible)
            {
                m_splitter.SetVisible(TRUE);
                m_rglv[LV_LAYER0].SetVisible(TRUE);
                m_rglv[LV_LAYER1].SetVisible(TRUE);
                m_ftosLeft.SetVisible(TRUE);
                m_ftosRight.SetVisible(TRUE);
            }
            m_splitter.Resize(&rcSplitter);
            m_rglv[LV_LAYER0].Resize(&rcLV0);
            m_rglv[LV_LAYER1].Resize(&rcLV1);
            m_ftosRight.Resize(&rcFtoSRight);
            m_ftosLeft.Resize(&rcFtoSLeft);
        }
        break;
    }
    if (!m_fVisible)
    {
        m_splitter.SetVisible(FALSE);
        m_rglv[LV_LAYER0].SetVisible(FALSE);
        m_rglv[LV_LAYER1].SetVisible(FALSE);
        m_ftosLeft.SetVisible(FALSE);
        m_ftosRight.SetVisible(FALSE);
    }
    
    m_nW = nW;
    m_nH = nH;
}

void CViewMode_Layer::HandleEvent(eEvent event, CFileObject *pfo)
{
}

void CViewMode_Layer::UpdateIfDirty()
{
 //   m_listview.UpdateIfDirty();
}

void CViewMode_Layer::Clear()
{
}

void CViewMode_Layer::ViewLayer(eLayerViewMode lvm, DWORD dwCmd)
{
    m_lvmCur = lvm;
    g_tbm.CheckButton(TB_LAYER, dwCmd, TRUE);
    HMENU hmenu = GetMenu(g_hwndMain);
    CheckMenuItem(hmenu, IDM_VIEW_LAYER0,     (dwCmd == IDM_VIEW_LAYER0) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmenu, IDM_VIEW_LAYER1,     (dwCmd == IDM_VIEW_LAYER1) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmenu, IDM_VIEW_BOTHLAYERS, (dwCmd == IDM_VIEW_BOTHLAYERS) ? MF_CHECKED : MF_UNCHECKED);
    Resize();
}

void CViewMode_Layer::HandleMenuCommand(WORD command)
{
    switch(command)
    {
    case IDM_VIEW_LAYER0:
        ViewLayer(LVM_LAYER0, command);
        break;
    
    case IDM_VIEW_LAYER1:
        ViewLayer(LVM_LAYER1, command);
        break;

    case IDM_VIEW_BOTHLAYERS:
        ViewLayer(LVM_BOTHLAYERS, command);
        break;

    case IDM_VIEW_UNPLACED:
        m_unplaced.ToggleView();
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\FileSystemChangeThread.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      FileSystemChangeThread.cpp
// Contents:  
// Revisions: 27-Nov-2001: Created (jeffsim)
//
// UNDONE: things to test:
//  1. Delete the root dir - can't; FindFirstChangeNot locks it
//  2. Replace the root dir with a same-named file - can't; FindFirstChangeNot locks it
// A. Delete a file
// B. Delete a folder (what happens to the files?)
// C. Rename a file (should show up as a delete followed by create)
// D. Rename a folder ("   ")
// E. Save layout, exit, make changes, load layout.  NOTE: Could persist
//    "LKG local filesystem" and go through same code below
// f. Replace a dir with a same-named file (and vice versa)
// g. exit xbGameDisc immediately after changes to the filesystem (ie, before changes have a chance to
//    enqueue.  ALSO test when they'be been enqueued but not dequeued).
// h. Test across a network (ie rootdir == "\\jeffsim5\c$\files"
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"
#include <time.h>

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FileSystemChangeThread
// Purpose:   Non-instance-specific version of the thread.  Immediately
//            calls into the correct instance.
// Arguments: pvArg     -- The changequeue that this thread 'belongs to'
// Return:    '0' for success, '-1' for failure
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD WINAPI FileSystemChangeThread(LPVOID pvArg)
{
    return ((CChangeQueue*)pvArg)->FileSystemChangeThread();
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::CChangeQueue
// Purpose:   CChangeQueue constructor.  Creates the Thread.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CChangeQueue::CChangeQueue()
{
    m_cChangeQueueReady = 0;
    m_penHead = NULL;
    m_penTail = NULL;
    m_fFailedTimeCompare = FALSE;
    m_fValidating = FALSE;
    m_fStarted = FALSE;

    m_hevtStop                = CreateEvent(NULL, FALSE, FALSE, "Stop");
    m_hevtForceUpdate         = CreateEvent(NULL, FALSE, FALSE, "ForceUpdate");
    m_hevtForceUpdateComplete = CreateEvent(NULL, FALSE, FALSE, "ForceUpdateComplete");
    m_hevtDoneUpdate          = CreateEvent(NULL, FALSE, FALSE, "m_hevtDoneUpdate");
    m_hevtFinishedCQInit      = CreateEvent(NULL, FALSE, FALSE, "g_hevtFinishedCQInit");
    m_hevtStartQueue          = CreateEvent(NULL, FALSE, FALSE, "g_hevtStartQueue");

    // undone - leaking events?
    InitializeCriticalSection(&m_csQueue);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::~CChangeQueue
// Purpose:   CChangeQueue destructor.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CChangeQueue::~CChangeQueue()
{
    Stop();
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::Init
// Purpose:   Creates (and implicitly starts) the thread that track changes
//            to the physical file system.  However, the thread itself doesn't
//            do anything other than initialize the filechange notifiers and
//            wait for 'Start'.
// Arguments: szRoot - the root dir we'll monitor
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CChangeQueue::Init(char *szRoot)
{
    strcpy(m_szRoot, szRoot);

    // Create the thread that tracks file system changes; this will initialize
    // the filechange notifiers, but won't actually do anything else...
    m_hthreadFileSystemChange = CreateThread(NULL, 0,
                                   ::FileSystemChangeThread, this, 0, NULL);
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::Start
// Purpose:   Start up the Change thread that was created in 'Init()'
// Arguments: pfh - The file hierarchy we'll monitor
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CChangeQueue::Start(CFileHierarchy *pfh)
{
    // note: pfh is gauranteed not to change by the Main Thread until the
    // Change Thread is done populating its own hierarchy
    m_pfhInit = pfh;

    // Tell the filechange thread to populate itself from pfh
    SetEvent(m_hevtStartQueue);

    // Wait until the filechange thread tells us that it's down populating.
    WaitForSingleObject(m_hevtFinishedCQInit, INFINITE);
    
    m_fStarted = true;

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::Stop
// Purpose:   Stops and deletes the thread that tracks changes to the
//            physical file system.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CChangeQueue::Stop()
{
    if (m_fStarted == false)
        return;

    // The user isn't allowed to call stop until all of the events are handled.
    assert(m_penHead == NULL && m_penTail == NULL);

    // If already deleted or never even created, then bail ship.
    if (m_hthreadFileSystemChange != NULL)
        return;

    // Tell the FileSystemChangeThread that we're stopped
    SetEvent(m_hevtStop);

    // undone: msgloop here?
    
    // wait for FileSystemChangeThread to exit, so that we know it won't be
    // doing any more object-specific actions.
    WaitForSingleObject(m_hthreadFileSystemChange, INFINITE);

    // At this point, the FileSystemChange thread has exited.
    DeleteObject(m_hthreadFileSystemChange);
    m_hthreadFileSystemChange = NULL;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::ForceUpdate
// Purpose:   
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CChangeQueue::ForceUpdate()
{
    MSG msg;

    // Tell the FileSystemChangeThread to force an update
    SetEvent(m_hevtForceUpdate);

    // Wait until the FileSystemChangeThread has signalled that it's finished
    // We sit in the windows message loop here to avoid blocking the UI
    while (WaitForSingleObject(m_hevtForceUpdateComplete, 0) == WAIT_TIMEOUT)
    {
        if (PeekMessage(&msg, NULL,  0, 0, PM_REMOVE)) 
        {
            if (!TranslateAccelerator(g_hwndMain, g_haccel, &msg))
            {
                if (msg.message == WM_QUIT)
                {
                    // User is trying to quit the application.
                    // UNDONE: Need to wait until update is done?
                    break;
                }
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }    

    // Tell the thread to continue
    SetEvent(m_hevtDoneUpdate);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::RecursePopulate
// Purpose:   Recursively populates the local filesystem with the physical
//            file system object found at 'szPath'.
// Return:    
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFileObject *CChangeQueue::RecursePopulate(CFileObject *pfoParent, CFileObject *pfoMainThread)
{
    // Create the file object that will hold information about the object
    // called 'szPath' in the physical file system
    CFileObject *pfoNew = new CFileObject(pfoMainThread);
    pfoNew->m_pfoMainThread = pfoMainThread;
    pfoNew->m_pcq = this;
    pfoMainThread->m_pfoChangeThread = pfoNew;

    if (pfoParent)
    {
        pfoParent->m_pcq = NULL;
        pfoParent->AddChild(pfoNew);
        pfoParent->m_pcq = this;
    }
    
    CFileObject *pfoMainThreadChild = pfoMainThread->m_lpfoChildren.GetFirst();
    while (pfoMainThreadChild)
    {
        RecursePopulate(pfoNew, pfoMainThreadChild);
        pfoMainThreadChild = pfoMainThread->m_lpfoChildren.GetNext();
    }

    return pfoNew;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FileSystemChangeThread
// Purpose:   Thread that handles tracking changes to the underlying file
//            system.
// Arguments: pvUnused          -- Ignore.
// Returns:   '0' if successfully connected; '-1' otherwise.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD CChangeQueue::FileSystemChangeThread()
{
    HANDLE rghListen[3];
    int nRet;

    // Listen for file change notifications and "Stop" notifications
    rghListen[0] = m_hevtStop;
    rghListen[1] = m_hevtForceUpdate;
    rghListen[2] = FindFirstChangeNotification(m_szRoot, TRUE,
                                            FILE_NOTIFY_CHANGE_FILE_NAME |
                                            FILE_NOTIFY_CHANGE_DIR_NAME |
                                            FILE_NOTIFY_CHANGE_ATTRIBUTES |
                                            FILE_NOTIFY_CHANGE_SIZE |
                                            FILE_NOTIFY_CHANGE_LAST_WRITE);

    // Now that the change notifiers are going, wait until we're *really*
    // started.  This allows us to catch changes that occur while the file
    // hierarchy is being initially populated in the main thread.
    WaitForSingleObject(m_hevtStartQueue, INFINITE);

    // Create a local copy of the current filesystem.  This will be compared
    // against the physical filesystem when changes are notified.
    // Note: If a change occurs while we are constructing this local copy,
    // the wait will fire immediately and report the changes.
    m_pfoRoot = RecursePopulate(NULL, m_pfhInit->m_pfiRoot);

    // Tell the main thread that we're through with the file hierarchy and
    // that it can continue
    SetEvent(m_hevtFinishedCQInit);

    while (true)
    {
        // Kick back and wait for a file to change or for a Stop to occur
        DWORD dw = WaitForMultipleObjects(3, rghListen, FALSE, INFINITE); 
        if (dw == WAIT_OBJECT_0)
        {
            // 'Stop()' was called on us.
            nRet = 0;
            goto done;
        }

        BOOL fForceUpdate = FALSE;
        if (dw == WAIT_OBJECT_0 + 1)
            fForceUpdate = TRUE;

        // Reset the notification so that other changes are tracked next time
        // around the loop
        if (!FindNextChangeNotification(rghListen[2]))
        {
            // We should only get here if the user deleted the root tree that
            // we're watching.  Post a notification at the front of the change
            // queue so that the main thread can handle it as soon as possible.
            // We can ignore all other messages in the queue since they're
            // obviously now meaningless.  It is up to the main thread to
            // delete the actual queue messages (we don't touch them here in case
            // the main thread is currently accessing them).
            // Meanwhile, there's nothing left for us to track here, so we're
            // outta here!
            Enqueue(EVENT_ROOTDELETED, NULL);
            m_cChangeQueueReady = 1;
            nRet = 0;
            goto done;
        }

        // It's often the case that the user is doing a number of 
        // actions to the physical filesystem in the background.  To
        // batch these actions together as much as possible, we
        // wait for a period of time after the first notification
        // to see if any other actions occur; we keep waiting until
        // either the filesystem has been stable for that period of
        // time, or a larger "force update" period of time has elapsed.
        DWORD dwPauseTime = 500; // Wait for filesystem to be stable for .5s
        time_t timeEnd = time(NULL) + 10; // After 10s, force update
        while (time(NULL) < timeEnd || fForceUpdate)
        {
            dw = WaitForMultipleObjects(3, rghListen, FALSE, dwPauseTime); 

            // Need to reset change notification after every 'wait'
            // UNDONE: It's possible that FNCN shouldn't be called if the
            //         signalled event is 'force update'.  MSDN is unclear
            //         about this.  Same with FNCN call above.
            if (!FindNextChangeNotification(rghListen[2])) 
            {
                Enqueue(EVENT_ROOTDELETED, NULL);
                m_cChangeQueueReady = 1;
                nRet = 0;
                goto done;
            }

            // Check if things were stable for the duration of the pause
            if (dw == WAIT_TIMEOUT)
                break;

            if (dw == WAIT_OBJECT_0)
            {
                // 'Stop()' was called on us.
                nRet = 0;
                goto done;
            }
            if (dw == WAIT_OBJECT_0 + 1)
                fForceUpdate = TRUE;
        }

        // If here, then a file change occurred in the physical file
        // system. Determine which file(s) changed, and add the
        // appropriate events to the change queue.
		HandleChangeNotification();

        if (fForceUpdate)
        {
            // Debugging msg 'force update' was sent to us.  signal that we're updated
            SetEvent(m_hevtForceUpdateComplete);
            
            // Don't rescan the filesystem until the main thread has finished validating the fs
            WaitForSingleObject(m_hevtDoneUpdate, INFINITE);
        }
    }

done:

    FindCloseChangeNotification(rghListen[2]);

    return nRet;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::CheckExistingFiles
// Purpose:   Compares the local file system against the physical one to
//            determine if any files have been added to the physical fs or
//            modified (size, date). Recursive.
// Arguments: pfoCur        -- Folder to examine.
// Return:    'TRUE' if an event was added, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CChangeQueue::CheckExistingFiles(CFileObject *pfoCur)
{
    /*
    Algorithm:
    For (every child file in the current filesystem dir represented by pfoCur)
		If the child file doesn't exist in the local filesystem copy
			Add 'FileAdded' event to ChangeQueue
			Add child file to local filesystem
        else if the file exists in both, but the type has changed (file<->folder)
            Remove and readd the object
		Else if the child file exists in both, but size has changed
			Add 'FileSizeChanged' event to ChangeQueue
			Update local filesystem
        if the child file object is a folder, then recurse into it
    */

    BY_HANDLE_FILE_INFORMATION bhfi;
    WIN32_FIND_DATA wfdChild;
    char sz[MAX_PATH], szPathChild[MAX_PATH];
    FILETIME ftModified;
    DWORD nFileSizeLow, nFileSizeHigh;

    // Enumerate all files in current folder and ensure they all exist in
    // pfoCur's list of children.  If any do not, then add them (and recurse
    // into them if folders)
    sprintf(sz, "%s\\*.*", pfoCur->m_szPath);
    HANDLE hff = FindFirstFile(sz, &wfdChild);
    if (hff == INVALID_HANDLE_VALUE)
    {
        // Failed to find the folder.  It must have been deleted; let
        // CheckDeletedFiles handle it
        return;
    }
    do
    {
        if (!_stricmp(wfdChild.cFileName, ".") || !_stricmp(wfdChild.cFileName, ".."))
            continue;

        sprintf(szPathChild, "%s\\%s", pfoCur->m_szPath, wfdChild.cFileName);

        HANDLE hfileChild;
        int cTriedOpen = 0;
OpenFile:
        if (wfdChild.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            hfileChild = CreateFile(szPathChild, GENERIC_READ,
                       0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS , NULL);
        }
        else
        {
            hfileChild = CreateFile(szPathChild, GENERIC_READ,
                       0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        }

#if 0
#pragma message("*******************************************************************************************************************************")
#pragma message("************************  WARNING: FOLLOWING LINE ADDED FOR DEBUGGING PURPOSES ONLY AND MUST BE REMOVED ***********************")
#pragma message("*******************************************************************************************************************************")
m_fValidating = true;
#endif
        if (hfileChild == INVALID_HANDLE_VALUE)
        {
            // Couldn't open the file for reading.  Is it in use?
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_SHARING_VIOLATION)
            {
                if (cTriedOpen >= 5)
                {
                    // Already tried opening it several times and failed.
                    if (m_fValidating)
                    {
                        // Don't block UI when we're testing.
                        DebugOutput("***** FILE '%s' WAS IN USE *****\n", szPathChild);
                    }
                    else
                    {
                        // Pop a message box to the user to let them know
                        // the file is in use and we're not going anywhere
                        // until it's available.
                        sprintf(sz, "The file '%s' is in use and needs to be"
                                    " unlocked so that it can\n be added to"
                                    " the layout.  Please close all"
                                    " applications accessing the file and"
                                    " click 'OK'.", szPathChild);

                        MessageBox(NULL, sz, "File In Use",
                                 MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
                    }
                    goto OpenFile;
                }
                // File's in use by another process.  Try sleeping for a
                // little bit and see if the file is released
                Sleep(100);

                cTriedOpen++;
                goto OpenFile;
            }
            else
            {
                // File has been deleted.  Ignore it here; will be caught
                // by CheckDeletedFiles
                continue;
            }
        }

        // FindFirstFile and FindNextFile do not always return valid information.
        // (See MSDN) - Unfortunately MSDN is unclear on what causes it, thus
        // rendering the functions completely useless! Yay!  Call GFIBH on it
        // to ensure correct information.
        if (!GetFileInformationByHandle(hfileChild, &bhfi))
        {
            // Failed to get information about the object.  Go back and
            // try to reopen it.
            CloseHandle(hfileChild);
            goto OpenFile;
        }
        
        CloseHandle(hfileChild);
        ftModified    = bhfi.ftLastWriteTime;
        nFileSizeLow  = bhfi.nFileSizeLow;
        nFileSizeHigh = bhfi.nFileSizeHigh;
        
        // If the file isn't a child of the current object, then add it
        CFileObject *pfoChild = pfoCur->GetChildByName(wfdChild.cFileName);
        if (pfoChild == NULL)
        {
            // The file doesn't exist in the local file system, so the user
            // must have added it.  Add the object to the local file system
            pfoChild = new CFileObject(szPathChild, &wfdChild, this);
            pfoCur->AddChild(pfoChild);
        }
        else
        {
            // The child exists.
            if (wfdChild.dwFileAttributes != pfoChild->m_dwa)
            {
                // File type changed (ie file->folder or vice versa)
                // Delete the old one and readd the new one.
                RecurseRemoveChildren(pfoChild);
                pfoCur->RemoveChild(pfoChild);

                // Add the object back in (nonrecursively -- the
                // CheckExistingFiles call below will recurse into it for us).
                char sz[MAX_PATH];
                sprintf(sz, "%s\\%s", pfoCur->m_szPath, wfdChild.cFileName);
                pfoChild = new CFileObject(sz, &wfdChild, this);
                pfoCur->AddChild(pfoChild);
            }
            else if (pfoChild->m_uliSize.LowPart  != nFileSizeLow ||
                     pfoChild->m_uliSize.HighPart != nFileSizeHigh)
            {
                // File size changed
                pfoChild->m_uliSize.LowPart  = nFileSizeLow;
                pfoChild->m_uliSize.HighPart = nFileSizeHigh;
                Enqueue(EVENT_SIZECHANGED, pfoChild);
            }
            else if (CompareFileTime(&ftModified, &pfoChild->m_ftModified) != 0)
            {
                // 'Last modified' time changed
                pfoChild->m_ftModified = ftModified;
                Enqueue(EVENT_TIMECHANGED, pfoChild);
            }
        }

        // If the child is a directory, then recurse into it
        if (pfoChild->m_fIsDir)
            CheckExistingFiles(pfoChild);

    } while (FindNextFile(hff, &wfdChild));

    FindClose(hff);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CChangeQueue::RecurseRemoveChildren(CFileObject *pfoFolder)
{
    // Recursively remove all of the objects in pfoFolder from the local
    // file system.
    CFileObject *pfoChild;
    while ((pfoChild = pfoFolder->GetFirstChild()) != NULL)
    {
        // Recursively remove the child object's contents
        if (pfoChild->m_fIsDir)
            RecurseRemoveChildren(pfoChild);
        pfoFolder->RemoveChild(pfoChild);
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CChangeQueue::CheckDeletedFiles(CFileObject *pfoFolder)
{
    /*
	For (every file in the internal filesystem)	
		If the file doesn't exist in the current filesystem
			Add 'FileDeleted' event to ChangeQueue
			Remove file from local filesystem
    */
    CFileObject *pfoChild = pfoFolder->GetFirstChild();
    while (pfoChild)
    {
        // Does pfoChild exist in 'szPath'?
        if (GetFileAttributes(pfoChild->m_szPath) == INVALID_FILE_ATTRIBUTES)
        {
            // File doesn't exist; it's been removed from the physical fs!
            // Remove it from here as well
            if (pfoChild->m_fIsDir)
                RecurseRemoveChildren(pfoChild);
            pfoFolder->RemoveChild(pfoChild);
        }
        else
        {
            // The file exists.  Recurse into it if it's a dir
            if (pfoChild->m_fIsDir)
                CheckDeletedFiles(pfoChild);
        }

        pfoChild = pfoFolder->GetNextChild();
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CChangeQueue::HandleChangeNotification()
{
    m_fEventAdded = FALSE;

    // Recursively check if any files were added to the physical fs or resized
    CheckExistingFiles(m_pfoRoot);

    // Recursively check if any files were removed from the physical fs
    CheckDeletedFiles(m_pfoRoot);
 
    if (m_fEventAdded)
    {
        m_cChangeQueueReady++;
        m_fEventAdded = FALSE;
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CChangeQueue::Enqueue(eEvent event, CFileObject *pfo)
{
    CEventNode *pen = new CEventNode(event, pfo);
    EnterCriticalSection(&m_csQueue);

    if (event == EVENT_ROOTDELETED)
    {
        // Place this message at the head of the queue so that it gets
        // handled first
        pen->m_penNext = m_penHead;
        m_penHead = pen;
        if (m_penTail == NULL)
            m_penTail = m_penHead;
    }
    else
    {
        if (m_penHead == NULL)
        {
            m_penHead = m_penTail = pen;
        }
        else
        {
            m_penTail->m_penNext = pen;
            m_penTail = pen;
        }
    }
    LeaveCriticalSection(&m_csQueue);
    
    m_fEventAdded = TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CChangeQueue::Dequeue(eEvent *pevent, CFileObject **ppfo)
{
    assert(m_penHead && m_penTail);
    
    EnterCriticalSection(&m_csQueue);
    *pevent = m_penHead->m_event;
    *ppfo = m_penHead->m_pfo;
    CEventNode *pen = m_penHead;
    m_penHead = m_penHead->m_penNext;
    if (m_penHead == NULL)
        m_penTail = NULL;
    
    // We delete the EventNode, but it's up to the dequeue'er to delete the
    // fileobject IFF the event is a remove.
    delete pen;

    LeaveCriticalSection(&m_csQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\FileSystemChangeThread.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      FileSystemChangeThread.h
// Contents:  
// Revisions: 27-Nov-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CFileObject;
class CFileObjectList;
class CFileHierarchy;

class CEventNode
{
public:
    CEventNode(eEvent event, CFileObject *pfo) {m_event = event; m_pfo = pfo; m_penNext = NULL;}
    CEventNode *m_penNext;
    eEvent m_event;
    CFileObject *m_pfo;
};

class CChangeQueue
{
public:
    CChangeQueue();
    ~CChangeQueue();

    BOOL Init(char *szRoot);
    BOOL Start(CFileHierarchy *pfh);
    void Stop();

    void Enqueue(eEvent event, CFileObject *pfo);
    void Dequeue(eEvent *pevent, CFileObject **ppfo);

    BOOL HasEvent() {return m_penHead != NULL; }
    CFileObject *RecursePopulate(CFileObject *pfoParent, CFileObject *pfoMainThread);

    DWORD FileSystemChangeThread();

    void CheckExistingFiles(CFileObject *pfoCur);
    void CheckDeletedFiles(CFileObject *pfoFolder);

    void ValidateFileSystem();

    void ForceUpdate();

    int m_cChangeQueueReady;
private:
    CFileObject *m_pfoRoot;
    char m_szRoot[MAX_PATH];
    CFileHierarchy *m_pfhInit;

    // debugging:
    BOOL VerifyNoNewFiles(CFileObject *pfoFolder);
    void VerifyFilesExist(CFileObject *pfoFolder);

    void HandleChangeNotification();

    void RecurseRemoveChildren(CFileObject *pfoFolder);

    CEventNode *m_penHead, *m_penTail;

    HANDLE m_hthreadFileSystemChange;
    HANDLE m_hevtStop;
    HANDLE m_hevtForceUpdate;
    HANDLE m_hevtForceUpdateComplete;
    HANDLE m_hevtDoneUpdate;
    HANDLE m_hevtFinishedCQInit;
    HANDLE m_hevtStartQueue;

    BOOL   m_fStarted;
    BOOL   m_fFailedTimeCompare;
    BOOL   m_fEventAdded;
    CRITICAL_SECTION m_csQueue;
    BOOL   m_fValidating;
};

extern HANDLE g_hthreadFileSystemChange;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\NewOpenSave.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      NewOpenSave.cpp
// Contents:  
// Revisions: 28-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- precompiled header file
#include "stdafx.h"
#include <commdlg.h>


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CUpdateBox g_updatebox;

void HandleEvents();


void SetRoot(char *szPath)
{
    SetCursor(g_hcurWait);
    g_hcur = g_hcurWait;

    g_cq.Init(szPath);
    
    g_updatebox.Start("Creating Layout...");

    ClearModified();

    g_updatebox.SetStatus("Examining Root Directory contents");
    
    g_fh.SetRoot(szPath);

    g_updatebox.SetStatus("Populating Views");

    g_vmExplorer.m_treeview.Populate(g_fh.m_pfiRoot);
    g_vmExplorer.m_treeview.SetCurFolder(g_fh.m_pfiRoot);

    // "Start" the filechange queue object.  This object will be used to
    // notify us about changes to the underlying filesystem.  
    g_cq.Start(&g_fh);

    g_updatebox.SetStatus("Finalizing changes");
    
    // Don't let the UI go until we've handled all events
    while (g_cq.m_cChangeQueueReady > 0)
    {
        HandleEvents();
        g_cq.m_cChangeQueueReady--;
    }
    if (g_pvmCur)
        g_pvmCur->UpdateIfDirty();

    g_updatebox.Stop();

    SetCursor(g_hcurArrow);
    g_hcur = g_hcurArrow;
}

BOOL VerifyCloseWorkspace()
{
    assert (g_fModified);

    // Verify with the user that they want to exit even though the
    // workspace has been modified
    switch(MessageBoxResource(g_hwndMain, IDS_WS_MODIFIED_TEXT,
                           IDS_WS_MODIFIED_CAPTION,
                           MB_YESNOCANCEL | MB_ICONWARNING | MB_APPLMODAL))
    {
    case IDYES:
        // Save
        HandleSave();
        return TRUE;

    case IDNO:
        // Don't save, close
        return TRUE;

    case IDCANCEL:
        // Don't save, don't close
        return FALSE;
    }
    assert(FALSE);
    return FALSE;
}

void CloseWorkspace()
{
    eEvent event;
    CFileObject *pfo;

    // When here, user has said they want to close the current workspace; ergo,
    // we can shut everything down "messily".
    
    // 1. Empty out the queue so that the queue nodes are deleted
    g_cq.Stop();
    while (g_cq.HasEvent())
    {
        g_cq.Dequeue(&event, &pfo);
        if (event == EVENT_REMOVED)
            delete pfo;
    }

    // 2. Clean out the file hierarchy
    g_fh.RemoveAll();

    // 3. Clean out the UI elements
    g_vmExplorer.Clear();
    g_vmLayer.Clear();
    ClearModified();

    // 4. Disable save and save as...
    SetMenuCmds(MF_GRAYED);
}


typedef struct
{
    WORD wMajor;
    WORD wMinor;
    WORD wBuild;
    WORD wQFE;
} sVersion;

#define XLO_SIG "XBGDXLOFILE"
#define XLO_SIG_SIZE sizeof(XLO_SIG)
#include <time.h>
typedef struct
{
    BYTE  szSig[XLO_SIG_SIZE];
    char szRoot[MAX_PATH];
    time_t timeSaved;
    sVersion version;
} sXLOHeader;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  PersistTo
// Purpose:   
// Arguments: 
// Return:    
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool PersistTo(char *szFLDName)
{
    sXLOHeader xlohdr;
    int nMajor, nMinor, nBuild, nQFE;

    CFile *pfile = new CFile(szFLDName, FILE_WRITE);
    if (!pfile)
        FatalError(E_OUTOFMEMORY);
    if (!pfile->IsInited())
    {
        MessageBoxResource(g_hwndMain, IDS_ERR_SAVE_TEXT,
                           IDS_ERR_SAVE_CAPTION, MB_APPLMODAL | MB_OK);
        if (pfile)
            delete pfile;
        return false;
    }

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

    // Write out the header information
    memcpy(xlohdr.szSig, XLO_SIG, XLO_SIG_SIZE);
    xlohdr.timeSaved = time(NULL);
    sscanf(VER_PRODUCTVERSION_STR, "%d.%d.%d.%d", &nMajor, &nMinor, &nBuild,
                                                  &nQFE);
    xlohdr.version.wMajor = (WORD)nMajor;
    xlohdr.version.wMinor = (WORD)nMinor;
    xlohdr.version.wBuild = (WORD)nBuild;
    xlohdr.version.wQFE   = (WORD)nQFE;
    strcpy(xlohdr.szRoot, g_fh.m_szRootDir);

    pfile->WriteData(&xlohdr, sizeof xlohdr);

    g_fh.PersistTo(pfile);
    delete pfile;

    ClearModified();

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SaveAs
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool SaveAs()
{
    // Get the name of the XLO file to save to.
    OPENFILENAME ofn;
    char szFile[MAX_PATH];
    char szFilter[1024], szTitle[1024];

    LoadString(g_hInst, IDS_OPEN_FILTER, szFilter, 1024);
    char *szExt = szFilter + strlen(szFilter) + 1;
    strcpy(szExt, "*.XLO");
    szExt[6] = '\0';
    LoadString(g_hInst, IDS_SAVEAS_TITLE, szTitle, 1024);

    strcpy(szFile, "");

    // 1. Get the name of the FLD file to open.

    // Initialize the openfilename structure so that the GetOpenFileName function knows what
    // kind of files we want to allow.
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = g_hwndMain;
    ofn.hInstance         = g_hInst;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFile;
    ofn.nMaxFile          = MAX_PATH - 1;
    ofn.lpstrFileTitle    = ofn.lpstrFile;
    ofn.nMaxFileTitle     = ofn.nMaxFile;
    ofn.lpstrInitialDir   = "C:\\";
    ofn.lpstrDefExt       = "*.xlo";
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_CREATEPROMPT | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;

    // Pop up the common file open dialog
    if (!GetSaveFileName(&ofn))
    {
        // User clicked cancel or closed the dialog (or an error occurred).
        return false;
    }

    if (!PersistTo(szFile))
        return false;

    strcpy(g_szName, szFile);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleSave
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool HandleSave()
{
    // If we haven't been named yet, then force saveas to get name
    if (!lstrcmpi(g_szName, ""))
        return SaveAs();

    // Create the FLD file
    return PersistTo(g_szName);
}

bool HandleNew()
{
    char       szDisplayName[MAX_PATH];
    char       szPath[MAX_PATH];
    char       szTitle[1024];
    BROWSEINFO bi;
    IMalloc    *pmalloc;

    // Close out current workspace if appropriate.  This may
    // require shutting down and restarting g_cq...
    if (g_fModified)
    {
        if (!VerifyCloseWorkspace())
            return FALSE;
    }

    LoadString(g_hInst, IDS_NEW_TITLE, szTitle, 1024);

    // Get a pointer to the shell's allocator.  We'll need it to free up the pidl that's created.
    SHGetMalloc(&pmalloc);

getname:
    // Fill in the browse info structure.
    bi.pszDisplayName = szDisplayName;          // Buffer to hold display name
    bi.hwndOwner      = g_hwndMain;             // Owner window for the dialog
    bi.pidlRoot       = NULL;                   // Specify NULL for 'desktop'
    bi.lpszTitle      = szTitle;                // String to display at the top of the dialog
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;   // Don't display control panel, etc
    bi.lpfn           = NULL;                   // No need for the callback
    bi.lParam         = 0;                      // unused.

    // Open up the dialog and have the user select the path.  The function is modal.
    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (pidl == NULL)
    {
        // User cancelled out, so don't set anything.
        return FALSE;
    }
    
    // If here, then the user selected a path.  Extract it from the pidl and store it in the
    // buffer the caller specified.
    if (::SHGetPathFromIDList(pidl, szPath) == false)
    {
        // Malformed pidl, or other failure.  In any case, don't set the path
        return FALSE;
    }

    // We don't allow root drives to be dvd roots.
    if (szPath[3] == '\0')
    {
        MessageBox(g_hwndMain, "A drive root cannot be selected as the root DVD directory.",
                   "Invalid directory", MB_APPLMODAL | MB_ICONWARNING | MB_OK);
        goto getname;
    }


    // At this point, szPath contains the path the user chose.
    if (szPath[0] == '\0')
    {
        // SHGetPathFromIDList failed, or SHBrowseForFolder failed.
        return FALSE;
    }

    CloseWorkspace();        
    strcpy(g_szRootDir, szPath);
    SetRoot(g_szRootDir);
    
    SetModified();

    if (g_pvmCur == &g_vmLayer)
        SetViewMode(&g_vmExplorer);
    // Enable save and save as...
    SetMenuCmds(MF_ENABLED);

    return TRUE;
}


char g_szDlgText[MAX_PATH + 400];
char g_szDlgRoot[MAX_PATH];

LRESULT CALLBACK GetTextItemDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
	case WM_INITDIALOG:
        SetDlgItemText(hwnd, IDC_TEXT, g_szDlgText);
		return TRUE;
        
	case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
            GetDlgItemText(hwnd, IDC_ROOT, g_szDlgRoot, MAX_PATH);
		    EndDialog(hwnd, LOWORD(wParam));
        }
		return TRUE;
	}
	return FALSE;
}
bool g_fNewRoot;

BOOL GetRootDir(char *szRootDir, sXLOHeader *pxlohdr)
{
    BOOL fTried = false;

    strcpy(szRootDir, pxlohdr->szRoot);

openroot:
    // Is the root directory accessible?
    DWORD dw = GetFileAttributes(szRootDir);
    if (dw != INVALID_FILE_ATTRIBUTES && (dw & FILE_ATTRIBUTE_DIRECTORY))
        return TRUE;

    // Root dir isn't there.  Prompt user for new root directory.
    if (fTried) 
        sprintf(g_szDlgText, "The specified root directory, '%s', is not accessible; "
                    "the drive may not be visible to this machine.  You may "
                    "enter a different location for the root directory "
                    "below.  The new directory will be stored in the XLO "
                    "file the next time you save it.", szRootDir);
    else
        sprintf(g_szDlgText, "The root directory specified in the XLO file, '%s', is "
                    "not accessible; the drive may not be visible to this "
                    "machine.  You may enter a different location for the "
                    "root directory below.  The new directory will be "
                    "stored in the XLO file the next time you save it.",
                    szRootDir);
    fTried = true;

 	if (DialogBox(g_hInst, MAKEINTRESOURCE(IDD_GETROOTDIR), g_hwndMain,
                  (DLGPROC) GetTextItemDlg) == IDOK)
    {
        // User entered a new dir and clicked 'ok'
        strcpy(szRootDir, g_szDlgRoot);
        g_fNewRoot = true;
        goto openroot;
    }

    // user clicked 'cancel'
    return FALSE;
}

bool HandleOpen()
{
    OPENFILENAME ofn;
    char szFile[MAX_PATH];
    char szFilter[1024], szTitle[1024];

    // Close out current workspace if appropriate.  This may
    // require shutting down and restarting g_cq...
    if (g_fModified)
    {
        if (!VerifyCloseWorkspace())
            return false;
    }

    LoadString(g_hInst, IDS_OPEN_FILTER, szFilter, 1024);
    char *szExt = szFilter + strlen(szFilter) + 1;
    strcpy(szExt, "*.XLO");
    szExt[6] = '\0';
    LoadString(g_hInst, IDS_OPEN_TITLE, szTitle, 1024);

    strcpy(szFile, "");

    // 1. Get the name of the FLD file to open.

    // Initialize the openfilename structure so that the GetOpenFileName function knows what
    // kind of files we want to allow.
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = g_hwndMain;
    ofn.hInstance         = g_hInst;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFile;
    ofn.nMaxFile          = MAX_PATH - 1;
    ofn.lpstrFileTitle    = ofn.lpstrFile;
    ofn.nMaxFileTitle     = ofn.nMaxFile;
    ofn.lpstrInitialDir   = "C:\\";
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = "*.xlo";
    ofn.lCustData         = 0;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    // Pop up the common file open dialog
    if (!GetOpenFileName(&ofn))
    {
        // User clicked cancel or closed the dialog (or an error occurred).
        return false;
    }

    // If here, then a file name was chosen.
    CloseWorkspace();        
    g_cq.Stop();

    // Create the XLO file
    CFile *pfile = new CFile(szFile, FILE_READ);
    if (!pfile)
        FatalError(E_OUTOFMEMORY);
    if (!pfile->IsInited())
    {
        MessageBoxResource(g_hwndMain, IDS_ERR_OPEN_TEXT,
                           IDS_ERR_OPEN_CAPTION, MB_APPLMODAL | MB_OK);
        if (pfile)
            delete pfile;
        return false;
    }

    sXLOHeader xlohdr;

    // Read the header information.
    pfile->ReadData(&xlohdr, sizeof xlohdr);

    if (memcmp(xlohdr.szSig, XLO_SIG, XLO_SIG_SIZE))
    {
        // No idea what this is...
        MessageBoxResource(g_hwndMain, IDS_ERR_INVALID_FILE_TEXT,
                           IDS_ERR_INVALID_FILE_CAPTION, MB_APPLMODAL | MB_OK);
        delete pfile;
        return false;
    }

    // Does root directory specified in the XLO file exist?  If not, allow
    // user to specify a new root directory
    g_fNewRoot = false;
    if (!GetRootDir(g_szRootDir, &xlohdr))
    {
        delete pfile;
        return false;
    }

    g_updatebox.Start("Loading Layout...");
    g_updatebox.SetStatus("Loading Files");

    if (!g_fh.CreateFrom(pfile, g_szRootDir))
    {
        delete pfile;
        return false;
    }

    delete pfile;

    
    g_updatebox.SetStatus("Populating UI elements");

    g_vmExplorer.m_treeview.Populate(g_fh.m_pfiRoot);
    g_vmExplorer.m_treeview.SetCurFolder(g_fh.m_pfiRoot);

    // When creating a new layout, we initialize the changequeue *before*
    // populating the filehierarchy; this allows us to catch changes to files
    // that occur during said populating.  Here however, we're forced to
    // do a ForceUpdate anyways since files could have changed since the
    // layout was last saved; therefore, we don't bother listening for file
    // system changes while populating the filehierarchy.
    g_cq.Init(g_szRootDir);

    // "Start" the filechange queue object.  This object will be used to
    // notify us about changes to the underlying filesystem.  
    g_cq.Start(&g_fh);

    // Force an update on the filesystem in case files changed since the
    // the layout was last saved.
    g_updatebox.SetStatus("Scanning for changes since layout was saved.");
    g_cq.ForceUpdate();

    g_updatebox.Stop();

    strcpy(g_szName, szFile);
    if (g_fNewRoot)
        SetModified();
    else
        ClearModified();
    g_fJustOpened = true;

    if (g_pvmCur == &g_vmLayer)
        SetViewMode(&g_vmExplorer);

    // Enable save and save as...
    SetMenuCmds(MF_ENABLED);
    
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\NewOpenSave.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      NewOpenSave.h
// Contents:  
// Revisions: 28-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

extern BOOL VerifyCloseWorkspace();
extern void CloseWorkspace();
extern bool SaveAs();
extern bool HandleSave();
extern bool HandleOpen();
extern bool HandleNew();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\PersistSettings.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      PersistSettings.cpp
// Contents:  Functionality to read and write default values from the
//            registry.  This includes window locations, user options, etc.
// Revisions: 28-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- precompiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// REGISTRY_SUBKEY  -- The key that contains xbGameDisc default values.
#define REGISTRY_SUBKEY	"Software\\Microsoft\\XboxSDK\\xbGameDisc"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetRegistryDWORD
// Purpose:   Gets a REG_DWORD value from the registry.  If not found, then
//            the specified default value is returned.
// Arguments: szKey          -- Registry key to get.
//            dwDefaultValue -- Default value to return if key isn't found.
// Return:    Key value (or dwDefaultValue if key isn't found)
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD GetRegistryDWORD(char *szKey, DWORD dwDefaultValue)
{
	HKEY hKey;
	DWORD dwType = REG_DWORD, dwRet, dwSize;
	if (RegOpenKeyEx(HKEY_CURRENT_USER, REGISTRY_SUBKEY, 0, KEY_READ, &hKey))
        return dwDefaultValue;
    
	if (RegQueryValueEx(hKey, szKey, NULL, &dwType, (LPBYTE) &dwRet, &dwSize)
        || dwSize != 4)
    {
        RegCloseKey(hKey);
        return dwDefaultValue;
    }

	RegCloseKey(hKey);
	return dwRet;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SetRegistryDWORD
// Purpose:   Sets a REG_DWORD value in the registry.
// Arguments: szKey     -- Registry key to set.
//            dwValue   -- Value to set key to.
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void SetRegistryDWORD(char *szKey, DWORD dwValue)
{
	HKEY hKey;
    DWORD dw;
	RegCreateKeyEx(HKEY_CURRENT_USER, REGISTRY_SUBKEY, 0, "",
                   REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw);
	RegSetValueEx(hKey, szKey, 0, REG_DWORD, (CONST LPBYTE) &dwValue,
                  sizeof(DWORD));
    RegCloseKey(hKey);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  InitGlobalVars
// Purpose:   Obtain default values from registry for window locations et al.
//            Force particular default values if not found in the registry.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void InitGlobalVars()
{
    g_nWindowX = GetRegistryDWORD("nWindowX", 100);
    g_nWindowY = GetRegistryDWORD("nWindowY", 100);
    g_nWindowW = GetRegistryDWORD("nWindowW", 600);
    g_nWindowH = GetRegistryDWORD("nWindowH", 700);
    g_nCmdShow = GetRegistryDWORD("WindowShow", SW_SHOW);

    g_nSplitterX    = GetRegistryDWORD("nSplitterX", 300);
    g_nSplitterX2   = GetRegistryDWORD("nSplitterX2", 300);
    g_fDoStartupDlg = GetRegistryDWORD("fDoStartupDlg", TRUE) ? TRUE : FALSE;

    g_nUnplacedWindowX = GetRegistryDWORD("nUnplacedWindowX", 200);
    g_nUnplacedWindowY = GetRegistryDWORD("nUnplacedWindowY", 200);
    g_nUnplacedWindowW = GetRegistryDWORD("nUnplacedWindowW", 500);
    g_nUnplacedWindowH = GetRegistryDWORD("nUnplacedWindowH", 600);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  StoreGlobalVars
// Purpose:   Store window locations (et al) in registry for next run.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void StoreGlobalVars()
{
    WINDOWPLACEMENT wp;
    wp.length = sizeof wp;
    GetWindowPlacement(g_hwndMain, &wp);

    SetRegistryDWORD("nWindowX", wp.rcNormalPosition.left);
    SetRegistryDWORD("nWindowY", wp.rcNormalPosition.top);
    SetRegistryDWORD("nWindowW", wp.rcNormalPosition.right - wp.rcNormalPosition.left);
    SetRegistryDWORD("nWindowH", wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);
    if (wp.showCmd != SW_MAXIMIZE)
        SetRegistryDWORD("WindowShow", SW_SHOW);
    else
        SetRegistryDWORD("WindowShow", wp.showCmd);

    SetRegistryDWORD("nSplitterX",    g_nSplitterX);
    SetRegistryDWORD("nSplitterX2",   g_nSplitterX2);
    SetRegistryDWORD("fDoStartupDlg", g_fDoStartupDlg);

    SetRegistryDWORD("nUnplacedWindowX", g_nUnplacedWindowX);
    SetRegistryDWORD("nUnplacedWindowY", g_nUnplacedWindowY);
    SetRegistryDWORD("nUnplacedWindowW", g_nUnplacedWindowW);
    SetRegistryDWORD("nUnplacedWindowH", g_nUnplacedWindowH);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\StartupDlg.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      StartupDlg.cpp
// Contents:  
// Revisions: 1-Feb-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"

static BOOL g_fDoOpen;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LRESULT CALLBACK StartupDialog(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
	case WM_INITDIALOG:
        CheckRadioButton(hwnd, IDC_NEW, IDC_OPEN, g_fDoOpen ? IDC_OPEN : IDC_NEW);
        SetDlgControlFont(hwnd, IDC_NEW, 14, "Arial", FW_BOLD);
        SetDlgControlFont(hwnd, IDC_OPEN, 14, "Arial", FW_BOLD);
        SetDlgControlFont(hwnd, IDC_TITLE, 14, "Arial", FW_BOLD);
        CheckDlgButton(hwnd, IDC_DONTSHOW, !g_fDoStartupDlg);
		return 1;

    case WM_CTLCOLORSTATIC:
        if ((HWND)lParam == GetDlgItem(hwnd, IDC_TITLE))
        {
            SetBkColor((HDC)wParam, RGB(255,255,255));
            return (BOOL)GetStockObject(WHITE_BRUSH);
        }
        return FALSE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK)
        {
            g_fDoStartupDlg = !IsDlgButtonChecked(hwnd, IDC_DONTSHOW);
            g_fDoOpen = IsDlgButtonChecked(hwnd, IDC_OPEN);
		    EndDialog(hwnd, LOWORD(wParam));
        }
		return TRUE;
	}
	return FALSE;
}


void StartupDlg()
{
    g_fDoOpen = false;
    while (true)
    {
        DialogBox(g_hInst, MAKEINTRESOURCE(IDD_STARTUP), g_hwndMain, (DLGPROC) ::StartupDialog);
        if (g_fDoOpen)
        {
            if (HandleOpen())
                break;
        }
        else
        {
            if (HandleNew())
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\PersistSettings.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      PersistSettings.h
// Contents:  
// Revisions: 28-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void InitGlobalVars();
void StoreGlobalVars();

extern int g_nCmdShow;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbGameDisc.rc
//
#define IDS_COLUMN_INCLUDED             1
#define IDS_COLUMN_NAME                 2
#define IDS_COLUMN_SIZE                 3
#define IDS_COLUMN_TYPE                 4
#define IDS_COLUMN_DATEMODIFIED         5
#define IDS_COLUMN_LOCATION             6
#define IDS_WS_MODIFIED_TEXT            44
#define IDS_WS_MODIFIED_CAPTION         45
#define IDS_NEW_TITLE                   56
#define IDS_ERR_SAVE_TEXT               57
#define IDS_ERR_SAVE_CAPTION            58
#define IDS_OPEN_FILTER                 59
#define IDS_SAVEAS_TITLE                60
#define IDS_OPEN_TITLE                  62
#define IDS_ERR_OPEN_TEXT               63
#define IDS_ERR_OPEN_CAPTION            64
#define IDS_ERR_INVALID_FILE_TEXT       65
#define IDS_ERR_INVALID_FILE_CAPTION    66
#define IDS_ABOUT                       67
#define IDS_COLORBAR_TOOLTIP            68
#define IDD_STARTUP                     101
#define IDB_FOLDERCLOSED                101
#define IDB_CHECK                       102
#define IDB_UNCHECK                     103
#define IDB_XROOT                       104
#define IDB_XDRIVE                      105
#define IDB_FOLDEROPEN                  106
#define IDB_TREEVIEW                    107
#define IDB_CHECKLIT                    108
#define IDB_UNCHECKLIT                  109
#define IDB_SORTARROWS                  110
#define IDB_ABOUT                       111
#define BMP_TOOLBAR_GEN                 112
#define IDB_TOOLBAR_EXPVIEW             113
#define IDB_TOOLBAR_LAYERVIEW           114
#define IDD_UPDATEBOXDLG                115
#define IDD_GETROOTDIR                  116
#define IDD_ABOUTBOX                    117
#define IDB_BITMAP1                     203
#define IDB_BITMAP2                     204
#define IDC_STATUS                      1000
#define IDC_PROGRESS                    1001
#define IDC_FILES                       1001
#define IDC_ROOT                        1001
#define IDC_FOLDERS                     1002
#define IDC_TEXT                        1002
#define IDC_BROWSE                      1003
#define IDC_MYICON                      1004
#define IDC_ABOUTTEXT                   1005
#define IDC_STATIC1                     1006
#define IDC_STATIC2                     1007
#define IDC_STATIC3                     1008
#define IDC_STATIC4                     1009
#define IDC_STATIC5                     1010
#define IDC_STATIC0                     1011

#define IDC_NEW                         2000
#define IDC_OPEN                        2001
#define IDC_TITLE                       2002
#define IDC_DONTSHOW                    2003
#define IDM_FILE_EXIT                   40001
#define IDM_FILE_OPEN                   40002
#define IDM_EDIT_SELECTALL              40003
#define IDM_FILE_SAVE                   40004
#define IDM_FILE_SAVEAS                 40006
#define IDM_FILE_NEW                    40007
#define IDM_EDIT_FIND                   40008
#define IDM_EDIT_FINDNEXT               40009
#define IDM_EDIT_GROUP                  40010
#define IDM_EDIT_UNGROUP                40011
#define IDM_EDIT_RESCAN                 40012
#define IDM_EDIT_REGENLAYOUT            40013
#define IDM_VIEW_FILE                   40014
#define IDM_VIEW_LAYOUT                 40015
#define IDM_VIEW_LAYER0                 40016
#define IDM_VIEW_LAYER1                 40017
#define IDM_VIEW_BOTHLAYERS             40018
#define IDM_VIEW_UNPLACED               40019
#define IDM_TOOLS_EMULATE               40020
#define IDM_TOOLS_PERF                  40021
#define IDM_TOOLS_PREMASTER             40022
#define IDM_HELP_ABOUT                  40023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         41001
#define _APS_NEXT_CONTROL_VALUE         2204
#define _APS_NEXT_SYMED_VALUE           301
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xbGameDisc.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\TrackMessage.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      TrackMessage.cpp
// Contents:  
// Revisions: 6-Nov-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"
#include <zmouse.h>

#define TRACKMSGS

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct 
{
    UINT uMsg;
    char sz[100];
} sMsgMap;

sMsgMap gs_rgmsgmapNotify[] = {
    //genericnotifications
    {NM_OUTOFMEMORY, "NM_OUTOFMEMORY"},
    {NM_CLICK, "NM_CLICK"},
    {NM_DBLCLK, "NM_DBLCLK"},
    {NM_RETURN, "NM_RETURN"},
    {NM_RCLICK, "NM_RCLICK"},
    {NM_RDBLCLK, "NM_RDBLCLK"},
    {NM_SETFOCUS, "NM_SETFOCUS"},
    {NM_KILLFOCUS, "NM_KILLFOCUS"},
    {NM_CUSTOMDRAW, "NM_CUSTOMDRAW"},
    {NM_HOVER, "NM_HOVER"},
    {NM_NCHITTEST, "NM_NCHITTEST"},
    {NM_KEYDOWN, "NM_KEYDOWN"},
    {NM_RELEASEDCAPTURE, "NM_RELEASEDCAPTURE"},
    {NM_SETCURSOR, "NM_SETCURSOR"},
    {NM_CHAR, "NM_CHAR"},
//    {NM_TOOLTIPSCREATED, "NM_TOOLTIPSCREATED"},
//    {NM_LDOWN, "NM_LDOWN"},
//    {NM_RDOWN, "NM_RDOWN"},
//    {NM_THEMECHANGED, "NM_THEMECHANGED"},

    //Treeviewnotifications
    {TVN_KEYDOWN, "TVN_KEYDOWN"},
    {TVN_SINGLEEXPAND, "TVN_SINGLEEXPAND"},
    {TVN_SELCHANGING, "TVN_SELCHANGING"},
    {TVN_SELCHANGED, "TVN_SELCHANGED"},
    {TVN_GETDISPINFO, "TVN_GETDISPINFO"},
    {TVN_SETDISPINFO, "TVN_SETDISPINFO"},
    {TVN_ITEMEXPANDING, "TVN_ITEMEXPANDING"},
    {TVN_ITEMEXPANDED, "TVN_ITEMEXPANDED"},
    {TVN_BEGINDRAG, "TVN_BEGINDRAG"},
    {TVN_BEGINRDRAG, "TVN_BEGINRDRAG"},
    {TVN_DELETEITEM, "TVN_DELETEITEM"},
    {TVN_BEGINLABELEDIT, "TVN_BEGINLABELEDIT"},
    {TVN_ENDLABELEDIT, "TVN_ENDLABELEDIT"},
    {TVN_GETINFOTIP, "TVN_GETINFOTIP"},

    // header notifications
    {HDN_BEGINDRAG, "HDN_BEGINDRAG"},
    {HDN_ENDDRAG, "HDN_ENDDRAG"},
//    {HDN_FILTERCHANGE, "HDN_FILTERCHANGE"},
//    {HDN_FILTERBTNCLICK, "HDN_FILTERBTNCLICK"},
    {HDN_ITEMCHANGING, "HDN_ITEMCHANGING"},
    {HDN_ITEMCHANGED, "HDN_ITEMCHANGED"},
    {HDN_ITEMCLICK, "HDN_ITEMCLICK"},
    {HDN_ITEMDBLCLICK, "HDN_ITEMDBLCLICK"},
    {HDN_DIVIDERDBLCLICK, "HDN_DIVIDERDBLCLICK"},
    {HDN_BEGINTRACK, "HDN_BEGINTRACK"},
    {HDN_ENDTRACK, "HDN_ENDTRACK"},
    {HDN_TRACK, "HDN_TRACK"},
    {HDN_GETDISPINFO, "HDN_GETDISPINFO"},

    // Rebar notifications
    {RBN_HEIGHTCHANGE, "RBN_HEIGHTCHANGE"},
    {RBN_GETOBJECT, "RBN_GETOBJECT"},
    {RBN_LAYOUTCHANGED, "RBN_LAYOUTCHANGED"},
    {RBN_AUTOSIZE, "RBN_AUTOSIZE"},
    {RBN_BEGINDRAG, "RBN_BEGINDRAG"},
    {RBN_ENDDRAG, "RBN_ENDDRAG"},
    {RBN_DELETINGBAND, "RBN_DELETINGBAND"},
    {RBN_DELETEDBAND, "RBN_DELETEDBAND"},
    {RBN_CHILDSIZE, "RBN_CHILDSIZE"},
//    {RBN_CHEVRONPUSHED, "RBN_CHEVRONPUSHED"},
//    {RBN_MINMAX, "RBN_MINMAX"},
    {RBN_FIRST - 22, "RBN_AUTOBREAK"},
};

sMsgMap gs_rgmmWPCFlags[] = {
    {SWP_DRAWFRAME, "SWP_DRAWFRAME"},
    {SWP_FRAMECHANGED, "SWP_FRAMECHANGED"},
    {SWP_HIDEWINDOW, "SWP_HIDEWINDOW"},
    {SWP_NOACTIVATE, "SWP_NOACTIVATE"},
    {SWP_NOCOPYBITS, "SWP_NOCOPYBITS"},
    {SWP_NOMOVE, "SWP_NOMOVE"},
    {SWP_NOOWNERZORDER, "SWP_NOOWNERZORDER"},
    {SWP_NOREDRAW, "SWP_NOREDRAW"},
//    {SWP_NOREPOSITION, "SWP_NOREPOSITION"},
    {SWP_NOSENDCHANGING, "SWP_NOSENDCHANGING"},
    {SWP_NOSIZE, "SWP_NOSIZE"},
    {SWP_NOZORDER, "SWP_NOZORDER"},
    {SWP_SHOWWINDOW, "SWP_SHOWWINDOW"},
};

sMsgMap gs_rgmsgmap[] = {
    {WM_NULL, "WM_NULL"},
    {WM_CREATE, "WM_CREATE"},
    {WM_DESTROY, "WM_DESTROY"},
    {WM_MOVE, "WM_MOVE"},
    {WM_SIZE, "WM_SIZE"},
    {WM_ACTIVATE, "WM_ACTIVATE"},
    {WM_SETFOCUS, "WM_SETFOCUS"},
    {WM_KILLFOCUS, "WM_KILLFOCUS"},
    {WM_ENABLE, "WM_ENABLE"},
    {WM_SETREDRAW, "WM_SETREDRAW"},
    {WM_SETTEXT, "WM_SETTEXT"},
    {WM_GETTEXT, "WM_GETTEXT"},
    {WM_GETTEXTLENGTH, "WM_GETTEXTLENGTH"},
    {WM_PAINT, "WM_PAINT"},
    {WM_CLOSE, "WM_CLOSE"},
    {WM_QUERYENDSESSION, "WM_QUERYENDSESSION"},
    {WM_QUERYOPEN, "WM_QUERYOPEN"},
    {WM_ENDSESSION, "WM_ENDSESSION"},
    {WM_QUIT, "WM_QUIT"},
    {WM_ERASEBKGND, "WM_ERASEBKGND"},
    {WM_SYSCOLORCHANGE, "WM_SYSCOLORCHANGE"},
    {WM_SHOWWINDOW, "WM_SHOWWINDOW"},
    {WM_WININICHANGE, "WM_WININICHANGE"},
    {WM_SETTINGCHANGE, "WM_SETTINGCHANGE"},
    {WM_DEVMODECHANGE, "WM_DEVMODECHANGE"},
    {WM_ACTIVATEAPP, "WM_ACTIVATEAPP"},
    {WM_FONTCHANGE, "WM_FONTCHANGE"},
    {WM_TIMECHANGE, "WM_TIMECHANGE"},
    {WM_CANCELMODE, "WM_CANCELMODE"},
    {WM_SETCURSOR, "WM_SETCURSOR"},
    {WM_MOUSEACTIVATE, "WM_MOUSEACTIVATE"},
    {WM_CHILDACTIVATE, "WM_CHILDACTIVATE"},
    {WM_QUEUESYNC, "WM_QUEUESYNC"},
    {WM_GETMINMAXINFO, "WM_GETMINMAXINFO"},
    {WM_PAINTICON, "WM_PAINTICON"},
    {WM_ICONERASEBKGND, "WM_ICONERASEBKGND"},
    {WM_NEXTDLGCTL, "WM_NEXTDLGCTL"},
    {WM_SPOOLERSTATUS, "WM_SPOOLERSTATUS"},
    {WM_DRAWITEM, "WM_DRAWITEM"},
    {WM_MEASUREITEM, "WM_MEASUREITEM"},
    {WM_DELETEITEM, "WM_DELETEITEM"},
    {WM_VKEYTOITEM, "WM_VKEYTOITEM"},
    {WM_CHARTOITEM, "WM_CHARTOITEM"},
    {WM_SETFONT, "WM_SETFONT"},
    {WM_GETFONT, "WM_GETFONT"},
    {WM_SETHOTKEY, "WM_SETHOTKEY"},
    {WM_GETHOTKEY, "WM_GETHOTKEY"},
    {WM_QUERYDRAGICON, "WM_QUERYDRAGICON"},
    {WM_COMPAREITEM, "WM_COMPAREITEM"},
//    {WM_GETOBJECT, "WM_GETOBJECT"},
    {WM_COMPACTING, "WM_COMPACTING"},
    {WM_COMMNOTIFY, "WM_COMMNOTIFY"},
    {WM_WINDOWPOSCHANGING, "WM_WINDOWPOSCHANGING"},
    {WM_WINDOWPOSCHANGED, "WM_WINDOWPOSCHANGED"},
    {WM_POWER, "WM_POWER"},
    {WM_COPYDATA, "WM_COPYDATA"},
    {WM_CANCELJOURNAL, "WM_CANCELJOURNAL"},
    {WM_NOTIFY, "WM_NOTIFY"},
    {WM_INPUTLANGCHANGEREQUEST, "WM_INPUTLANGCHANGEREQUEST"},
    {WM_INPUTLANGCHANGE, "WM_INPUTLANGCHANGE"},
    {WM_TCARD, "WM_TCARD"},
    {WM_HELP, "WM_HELP"},
    {WM_USERCHANGED, "WM_USERCHANGED"},
    {WM_NOTIFYFORMAT, "WM_NOTIFYFORMAT"},
    {WM_CONTEXTMENU, "WM_CONTEXTMENU"},
    {WM_STYLECHANGING, "WM_STYLECHANGING"},
    {WM_STYLECHANGED, "WM_STYLECHANGED"},
    {WM_DISPLAYCHANGE, "WM_DISPLAYCHANGE"},
    {WM_GETICON, "WM_GETICON"},
    {WM_SETICON, "WM_SETICON"},
    {WM_NCCREATE, "WM_NCCREATE"},
    {WM_NCDESTROY, "WM_NCDESTROY"},
    {WM_NCCALCSIZE, "WM_NCCALCSIZE"},
    {WM_NCHITTEST, "WM_NCHITTEST"},
    {WM_NCPAINT, "WM_NCPAINT"},
    {WM_NCACTIVATE, "WM_NCACTIVATE"},
    {WM_GETDLGCODE, "WM_GETDLGCODE"},
    {WM_SYNCPAINT, "WM_SYNCPAINT"},
    {WM_NCMOUSEMOVE, "WM_NCMOUSEMOVE"},
    {WM_NCLBUTTONDOWN, "WM_NCLBUTTONDOWN"},
    {WM_NCLBUTTONUP, "WM_NCLBUTTONUP"},
    {WM_NCLBUTTONDBLCLK, "WM_NCLBUTTONDBLCLK"},
    {WM_NCRBUTTONDOWN, "WM_NCRBUTTONDOWN"},
    {WM_NCRBUTTONUP, "WM_NCRBUTTONUP"},
    {WM_NCRBUTTONDBLCLK, "WM_NCRBUTTONDBLCLK"},
    {WM_NCMBUTTONDOWN, "WM_NCMBUTTONDOWN"},
    {WM_NCMBUTTONUP, "WM_NCMBUTTONUP"},
    {WM_NCMBUTTONDBLCLK, "WM_NCMBUTTONDBLCLK"},
    {0x00AB, "WM_NCXBUTTONDOWN"},
    {0x00AC, "WM_NCXBUTTONUP"},
    {0x00AD, "WM_NCXBUTTONDBLCLK"},
    {0x00FF, "WM_INPUT"},
    {WM_KEYFIRST, "WM_KEYFIRST"},
    {WM_KEYDOWN, "WM_KEYDOWN"},
    {WM_KEYUP, "WM_KEYUP"},
    {WM_CHAR, "WM_CHAR"},
    {WM_DEADCHAR, "WM_DEADCHAR"},
    {WM_SYSKEYDOWN, "WM_SYSKEYDOWN"},
    {WM_SYSKEYUP, "WM_SYSKEYUP"},
    {WM_SYSCHAR, "WM_SYSCHAR"},
    {WM_SYSDEADCHAR, "WM_SYSDEADCHAR"},
    {WM_KEYLAST, "WM_KEYLAST"},
    {WM_IME_STARTCOMPOSITION, "WM_IME_STARTCOMPOSITION"},
    {WM_IME_ENDCOMPOSITION, "WM_IME_ENDCOMPOSITION"},
    {WM_IME_COMPOSITION, "WM_IME_COMPOSITION"},
    {WM_IME_KEYLAST, "WM_IME_KEYLAST"},
    {WM_INITDIALOG, "WM_INITDIALOG"},
    {WM_COMMAND, "WM_COMMAND"},
    {WM_SYSCOMMAND, "WM_SYSCOMMAND"},
    {WM_TIMER, "WM_TIMER"},
    {WM_HSCROLL, "WM_HSCROLL"},
    {WM_VSCROLL, "WM_VSCROLL"},
    {WM_INITMENU, "WM_INITMENU"},
    {WM_INITMENUPOPUP, "WM_INITMENUPOPUP"},
    {WM_MENUSELECT, "WM_MENUSELECT"},
    {WM_MENUCHAR, "WM_MENUCHAR"},
    {WM_ENTERIDLE, "WM_ENTERIDLE"},
//    {WM_MENURBUTTONUP, "WM_MENURBUTTONUP"},
//    {WM_MENUDRAG, "WM_MENUDRAG"},
//    {WM_MENUGETOBJECT, "WM_MENUGETOBJECT"},
//    {WM_UNINITMENUPOPUP, "WM_UNINITMENUPOPUP"},
//    {WM_MENUCOMMAND, "WM_MENUCOMMAND"},
    {0x0127, "WM_CHANGEUISTATE"},
    {0x0128, "WM_UPDATEUISTATE"},
    {0x0129, "WM_QUERYUISTATE"},
    {WM_CTLCOLORMSGBOX, "WM_CTLCOLORMSGBOX"},
    {WM_CTLCOLOREDIT, "WM_CTLCOLOREDIT"},
    {WM_CTLCOLORLISTBOX, "WM_CTLCOLORLISTBOX"},
    {WM_CTLCOLORBTN, "WM_CTLCOLORBTN"},
    {WM_CTLCOLORDLG, "WM_CTLCOLORDLG"},
    {WM_CTLCOLORSCROLLBAR, "WM_CTLCOLORSCROLLBAR"},
    {WM_CTLCOLORSTATIC, "WM_CTLCOLORSTATIC"},
    {WM_MOUSEFIRST, "WM_MOUSEFIRST"},
    {WM_MOUSEMOVE, "WM_MOUSEMOVE"},
    {WM_LBUTTONDOWN, "WM_LBUTTONDOWN"},
    {WM_LBUTTONUP, "WM_LBUTTONUP"},
    {WM_LBUTTONDBLCLK, "WM_LBUTTONDBLCLK"},
    {WM_RBUTTONDOWN, "WM_RBUTTONDOWN"},
    {WM_RBUTTONUP, "WM_RBUTTONUP"},
    {WM_RBUTTONDBLCLK, "WM_RBUTTONDBLCLK"},
    {WM_MBUTTONDOWN, "WM_MBUTTONDOWN"},
    {WM_MBUTTONUP, "WM_MBUTTONUP"},
    {WM_MBUTTONDBLCLK, "WM_MBUTTONDBLCLK"},
    {WM_MOUSEWHEEL, "WM_MOUSEWHEEL"},
    {0x020B, "WM_XBUTTONDOWN"},
    {0x020C, "WM_XBUTTONUP"},
    {0x020D, "WM_XBUTTONDBLCLK"},
    {WM_MOUSELAST, "WM_MOUSELAST"},
    {WM_PARENTNOTIFY, "WM_PARENTNOTIFY"},
    {WM_ENTERMENULOOP, "WM_ENTERMENULOOP"},
    {WM_EXITMENULOOP, "WM_EXITMENULOOP"},
    {WM_NEXTMENU, "WM_NEXTMENU"},
    {WM_SIZING, "WM_SIZING"},
    {WM_CAPTURECHANGED, "WM_CAPTURECHANGED"},
    {WM_MOVING, "WM_MOVING"},
    {WM_POWERBROADCAST, "WM_POWERBROADCAST"},
    {WM_DEVICECHANGE, "WM_DEVICECHANGE"},
    {WM_MDICREATE, "WM_MDICREATE"},
    {WM_MDIDESTROY, "WM_MDIDESTROY"},
    {WM_MDIACTIVATE, "WM_MDIACTIVATE"},
    {WM_MDIRESTORE, "WM_MDIRESTORE"},
    {WM_MDINEXT, "WM_MDINEXT"},
    {WM_MDIMAXIMIZE, "WM_MDIMAXIMIZE"},
    {WM_MDITILE, "WM_MDITILE"},
    {WM_MDICASCADE, "WM_MDICASCADE"},
    {WM_MDIICONARRANGE, "WM_MDIICONARRANGE"},
    {WM_MDIGETACTIVE, "WM_MDIGETACTIVE"},
    {WM_MDISETMENU, "WM_MDISETMENU"},
    {WM_ENTERSIZEMOVE, "WM_ENTERSIZEMOVE"},
    {WM_EXITSIZEMOVE, "WM_EXITSIZEMOVE"},
    {WM_DROPFILES, "WM_DROPFILES"},
    {WM_MDIREFRESHMENU, "WM_MDIREFRESHMENU"},
    {WM_IME_SETCONTEXT, "WM_IME_SETCONTEXT"},
    {WM_IME_NOTIFY, "WM_IME_NOTIFY"},
    {WM_IME_CONTROL, "WM_IME_CONTROL"},
    {WM_IME_COMPOSITIONFULL, "WM_IME_COMPOSITIONFULL"},
    {WM_IME_SELECT, "WM_IME_SELECT"},
    {WM_IME_CHAR, "WM_IME_CHAR"},
//    {WM_IME_REQUEST, "WM_IME_REQUEST"},
    {WM_IME_KEYDOWN, "WM_IME_KEYDOWN"},
    {WM_IME_KEYUP, "WM_IME_KEYUP"},
    {WM_MOUSEHOVER, "WM_MOUSEHOVER"},
    {WM_MOUSELEAVE, "WM_MOUSELEAVE"},
//    {WM_NCMOUSEHOVER, "WM_NCMOUSEHOVER"},
//    {WM_NCMOUSELEAVE, "WM_NCMOUSELEAVE"},
//    {WM_WTSSESSION_CHANGE, "WM_WTSSESSION_CHANGE"},
//    {WM_TABLET_FIRST, "WM_TABLET_FIRST"},
//    {WM_TABLET_LAST, "WM_TABLET_LAST"},
    {WM_CUT, "WM_CUT"},
    {WM_COPY, "WM_COPY"},
    {WM_PASTE, "WM_PASTE"},
    {WM_CLEAR, "WM_CLEAR"},
    {WM_UNDO, "WM_UNDO"},
    {WM_RENDERFORMAT, "WM_RENDERFORMAT"},
    {WM_RENDERALLFORMATS, "WM_RENDERALLFORMATS"},
    {WM_DESTROYCLIPBOARD, "WM_DESTROYCLIPBOARD"},
    {WM_DRAWCLIPBOARD, "WM_DRAWCLIPBOARD"},
    {WM_PAINTCLIPBOARD, "WM_PAINTCLIPBOARD"},
    {WM_VSCROLLCLIPBOARD, "WM_VSCROLLCLIPBOARD"},
    {WM_SIZECLIPBOARD, "WM_SIZECLIPBOARD"},
    {WM_ASKCBFORMATNAME, "WM_ASKCBFORMATNAME"},
    {WM_CHANGECBCHAIN, "WM_CHANGECBCHAIN"},
    {WM_HSCROLLCLIPBOARD, "WM_HSCROLLCLIPBOARD"},
    {WM_QUERYNEWPALETTE, "WM_QUERYNEWPALETTE"},
    {WM_PALETTEISCHANGING, "WM_PALETTEISCHANGING"},
    {WM_PALETTECHANGED, "WM_PALETTECHANGED"},
    {WM_HOTKEY, "WM_HOTKEY"},
    {WM_PRINT, "WM_PRINT"},
    {WM_PRINTCLIENT, "WM_PRINTCLIENT"},
    {0x0319, "WM_APPCOMMAND"},
    {0x031A, "WM_THEMECHANGED"},
    {WM_HANDHELDFIRST, "WM_HANDHELDFIRST"},
    {WM_HANDHELDLAST, "WM_HANDHELDLAST"},
    {WM_AFXFIRST, "WM_AFXFIRST"},
    {WM_AFXLAST, "WM_AFXLAST"},
    {WM_PENWINFIRST, "WM_PENWINFIRST"},
    {WM_PENWINLAST, "WM_PENWINLAST"},

    // TreeView messages
    {TVM_INSERTITEM, "TVM_INSERTITEM"},
    {TVM_DELETEITEM, "TVM_DELETEITEM"},
    {TVM_EXPAND, "TVM_EXPAND"},
    {TVM_GETITEMRECT, "TVM_GETITEMRECT"},
    {TVM_GETCOUNT, "TVM_GETCOUNT"},
    {TVM_GETINDENT, "TVM_GETINDENT"},
    {TVM_SETINDENT, "TVM_SETINDENT"},
    {TVM_GETIMAGELIST, "TVM_GETIMAGELIST"},
    {TVM_SETIMAGELIST, "TVM_SETIMAGELIST"},
    {TVM_GETNEXTITEM, "TVM_GETNEXTITEM"},
    {TVM_SELECTITEM, "TVM_SELECTITEM"},
    {TVM_GETITEM, "TVM_GETITEM"},
    {TVM_SETITEM, "TVM_SETITEM"},
    {TVM_EDITLABEL, "TVM_EDITLABEL"},
    {TVM_GETEDITCONTROL, "TVM_GETEDITCONTROL"},
    {TVM_GETVISIBLECOUNT, "TVM_GETVISIBLECOUNT"},
    {TVM_HITTEST, "TVM_HITTEST"},
    {TVM_CREATEDRAGIMAGE, "TVM_CREATEDRAGIMAGE"},
    {TVM_SORTCHILDREN, "TVM_SORTCHILDREN"},
    {TVM_ENSUREVISIBLE, "TVM_ENSUREVISIBLE"},
    {TVM_SORTCHILDRENCB, "TVM_SORTCHILDRENCB"},
    {TVM_ENDEDITLABELNOW, "TVM_ENDEDITLABELNOW"},
    {TVM_GETISEARCHSTRING, "TVM_GETISEARCHSTRING"},
    {TVM_SETTOOLTIPS, "TVM_SETTOOLTIPS"},
    {TVM_GETTOOLTIPS, "TVM_GETTOOLTIPS"},
    {TVM_SETINSERTMARK, "TVM_SETINSERTMARK"},
    {TVM_SETUNICODEFORMAT, "TVM_SETUNICODEFORMAT"},
    {TVM_GETUNICODEFORMAT, "TVM_GETUNICODEFORMAT"},
    {TVM_SETITEMHEIGHT, "TVM_SETITEMHEIGHT"},
    {TVM_GETITEMHEIGHT, "TVM_GETITEMHEIGHT"},
    {TVM_SETBKCOLOR, "TVM_SETBKCOLOR"},
    {TVM_SETTEXTCOLOR, "TVM_SETTEXTCOLOR"},
    {TVM_GETBKCOLOR, "TVM_GETBKCOLOR"},
    {TVM_GETTEXTCOLOR, "TVM_GETTEXTCOLOR"},
    {TVM_SETSCROLLTIME, "TVM_SETSCROLLTIME"},
    {TVM_GETSCROLLTIME, "TVM_GETSCROLLTIME"},
    {TVM_SETINSERTMARKCOLOR, "TVM_SETINSERTMARKCOLOR"},
    {TVM_GETINSERTMARKCOLOR, "TVM_GETINSERTMARKCOLOR"},
//    {TVM_GETITEMSTATE, "TVM_GETITEMSTATE"},
//    {TVM_SETLINECOLOR, "TVM_SETLINECOLOR"},
//    {TVM_GETLINECOLOR, "TVM_GETLINECOLOR"},
//    {TVM_MAPACCIDTOHTREEITEM, "TVM_MAPACCIDTOHTREEITEM"},
//    {TVM_MAPHTREEITEMTOACCID, "TVM_MAPHTREEITEMTOACCID"},
};

sMsgMap gs_rgmmNMCUSTOMDRAWFLAGS[] = 
{
    {CDDS_POSTERASE, "CDDS_POSTERASE"},
    {CDDS_POSTPAINT, "CDDS_POSTPAINT"},
    {CDDS_PREERASE, "CDDS_PREERASE"},
    {CDDS_PREPAINT, "CDDS_PREPAINT"},
    {CDDS_ITEM, "CDDS_ITEM"},
    {CDDS_ITEMPOSTERASE, "CDDS_ITEMPOSTERASE"},
    {CDDS_ITEMPOSTPAINT, "CDDS_ITEMPOSTPAINT"},
    {CDDS_ITEMPREERASE, "CDDS_ITEMPREERASE"},
    {CDDS_ITEMPREPAINT, "CDDS_ITEMPREPAINT"},
    {CDDS_SUBITEM, "CDDS_SUBITEM"},
};
    
void DumpFlags(DWORD dwFlags, sMsgMap *pmm, int cItems)
{
    bool fDumped = false;
    for (int j = 0; j < cItems; j++)
        if (dwFlags & pmm[j].uMsg)
        {
            if (fDumped)
                DebugOutput(" | ");
            DebugOutput("%s", pmm[j].sz);
            fDumped = true;
        }
}

void TrackMessage(UINT uMsg, WPARAM wparam, LPARAM lparam, char *szText)
{
    NMHDR *pnmhdr;
    int j;

#ifndef TRACKMSGS
    return;
#endif
    for (int i = 0; i < (sizeof gs_rgmsgmap) / sizeof sMsgMap; i++)
        if (uMsg == gs_rgmsgmap[i].uMsg)
        {
            DebugOutput("%s:  %s ", szText, gs_rgmsgmap[i].sz);

            // Special-case parameters
            switch(uMsg)
            {
            case WM_WINDOWPOSCHANGING:
            case WM_WINDOWPOSCHANGED:
                DebugOutput("((%d, %d) - (%d, %d) flags = ", ((WINDOWPOS*)lparam)->x, ((WINDOWPOS*)lparam)->y,
                            ((WINDOWPOS*)lparam)->cx, ((WINDOWPOS*)lparam)->cy);
                DumpFlags(((WINDOWPOS*)lparam)->flags, gs_rgmmWPCFlags, sizeof gs_rgmmWPCFlags / sizeof sMsgMap);
                DebugOutput(")\n");
                break;

            case WM_SIZE:
                DebugOutput("(Size = (%d,%d))\n", LOWORD(lparam), HIWORD(lparam));
                break;
            case WM_SIZING:
                DebugOutput("(Rect = (%d,%d)-(%d,%d))\n", ((LPRECT)lparam)->left, ((LPRECT)lparam)->top,
                    ((LPRECT)lparam)->right, ((LPRECT)lparam)->bottom);
                break;
            case WM_MOVE:
                DebugOutput("(Pos = (%d,%d))\n", LOWORD(lparam), HIWORD(lparam));
                break;
            case WM_NOTIFY:
                pnmhdr = (NMHDR*)lparam;
                for (j = 0; j < (sizeof gs_rgmsgmapNotify) / sizeof sMsgMap; j++)
                    if (pnmhdr->code == gs_rgmsgmapNotify[j].uMsg)
                    {
                        switch(pnmhdr->code)
                        {
                        case NM_CUSTOMDRAW:
                            DebugOutput("(NM_CUSTOMDRAW item=%d (drawstage = ",wparam);
                            DumpFlags(((LPNMCUSTOMDRAW)lparam)->dwDrawStage,
                                      gs_rgmmNMCUSTOMDRAWFLAGS,
                                      sizeof gs_rgmmNMCUSTOMDRAWFLAGS / sizeof sMsgMap);
                            DebugOutput(")\n");
                            break;
                        case HDN_TRACK:
                            {
                                LPNMHEADER pnmhdr = (LPNMHEADER)lparam;
                                LPHDITEM phdi = pnmhdr->pitem;
                                DebugOutput("(HDN_TRACK (item %d width %d)\n", pnmhdr->iItem, phdi->cxy);
                            }
                            break;
                        default:
                            DebugOutput("(%s item=%d (lparam = 0x%08x)\n", gs_rgmsgmapNotify[j].sz, wparam, lparam);
                            break;
                        }
                        return;
                    }
                    DebugOutput("(Unknown Notify Code: 0x%08x)\n", pnmhdr->code);
                break;

            default:
                 DebugOutput("(wparam = 0x%08x, lparam = 0x%08x)\n", wparam, lparam);
                 break;
            }
            return;
        }
    DebugOutput("%s: Unknown Message '%d'\n", szText, uMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\Util.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      util.cpp
// Contents:  
// Revisions: 7-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DebugOutput
// Purpose:   Outputs a variable-argument string to the debugger.  Used like
//            printf.
// Arguments: sz            -- Format to use (ie the first parm to printf() )
//            ...           -- [optional] Variable number of arguments.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(char *sz, ...)
{
#ifdef _DEBUG
    char szOut[255];
    va_list args;
    va_start(args, sz);

    vsprintf(szOut, sz, args);
    OutputDebugString(szOut);
    va_end(args);
#endif
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatByteString
// Purpose:   
// Arguments: 
// Return:   None 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FormatByteString(ULARGE_INTEGER uliVal, char *szDest)
{
    // Set nPrecision to the number of digits after the decimal point you want.
    int nPrecision = 2;
    double r = (double)uliVal.QuadPart;
	char *rgsz[] = {"Bytes", "KB", "MB", "GB"};
	int iName = 0;

	while(r > 1024.0f && iName < 3)
	{
        r = r / 1024.0f; iName++;
	}

    if (r - (double)((int)r) == 0.0 || uliVal.QuadPart < 1024768)
        sprintf(szDest, "%d %s", (int)r, rgsz[iName]);
    else
        sprintf(szDest, "%0.*f %s", nPrecision, r, rgsz[iName]);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FatalError
// Purpose:   Called when an unrecoverable error has occurred.  Forces exit
//            after notification
// Arguments: dwErr         -- The error that occurred
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FatalError(DWORD dwErr)
{
    char szError[1024], szCaption[1024];

    switch(dwErr)
    {
    case E_OUTOFMEMORY:
        sprintf(szError, "There is not enough memory available to complete the action.\n"\
                         "xbGameDisc will now close.  Please close other open applications"\
                         " and try again.");
        sprintf(szCaption, "Unrecoverable Error: Out of Memory");
        break;
    default:
        assert(false);
        break;
    }

    MessageBox(NULL, szError, szCaption,  MB_ICONEXCLAMATION | MB_OK);
    exit(-1);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResource
// Purpose:   Display a messagebox using string resources
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResource(HWND hwnd, DWORD dwTextId, DWORD dwCaptionId, DWORD dwFlags)
{
    char szText[2048], szCaption[256];
    LoadString(g_hInst, dwTextId,    szText,    2048);
    LoadString(g_hInst, dwCaptionId, szCaption, 256);
    return MessageBox(hwnd, szText, szCaption, dwFlags);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResourceParam
// Purpose:   Display a messagebox using string resources.  Expects one string
//            param for the text string.
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            szParam     -- String param for text string.
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResourceParam(HWND hwnd, DWORD dwTextId, char *szParam, DWORD dwCaptionId, DWORD dwFlags)
{
    char szText[2048], szText2[2048], szCaption[256];
    LoadString(g_hInst, dwTextId,    szText,    2048);
    LoadString(g_hInst, dwCaptionId, szCaption, 256);
    sprintf(szText2, szText, szParam);
    return MessageBox(hwnd, szText2, szCaption, dwFlags);
}


void CenterDialog(HWND hDlg)
{
	int x, y;
    POINT pt = {0};
	RECT rc, parentrc;
	GetWindowRect(hDlg, &rc);
	GetClientRect(g_hwndMain, &parentrc);
    ClientToScreen(g_hwndMain, &pt);
	x = pt.x + (parentrc.right / 2 - (rc.right - rc.left) / 2);
	y = pt.y + (parentrc.bottom / 2 - (rc.bottom - rc.top) / 2);
	SetWindowPos(hDlg, NULL, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW);
    BringWindowToTop(hDlg);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SetDlgControlFont
// Purpose:   Sets the font of the specified control in the specified dialog
// Arguments: hwnd                  -- The dialog with the control to set.
//            nControl              -- The control whose font we'll set
//            nHeight               -- Height of the font
//            szFace                -- Face of the font ("Arial", "Courier", etc)
//            nWeight               -- Normal (0) or Bold (FW_BOLD)
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT SetDlgControlFont(HWND hwnd, int nControl, int nHeight, char *szFace,
                          int nWeight)
{
    LOGFONT lf;

    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(hwnd, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;

    // Create the GDI font object
    memset(&lf, 0, sizeof(lf));
    lf.lfHeight = nHeight;
    lf.lfWeight = nWeight;
    lf.lfQuality = NONANTIALIASED_QUALITY;
    strcpy(lf.lfFaceName, szFace);
    HFONT hfont = CreateFontIndirect(&lf);
    
    // Set the control's current font to the newly created font
    SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfont, TRUE);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\Util.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      util.h
// Contents:  
// Revisions: 7-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CObjList;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DebugOutput
// Purpose:   Outputs a variable-argument string to the debugger.  Used like
//            printf.
// Arguments: sz            -- Format to use (ie the first parm to printf() )
//            ...           -- [optional] Variable number of arguments.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(char *sz, ...);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatByteString
// Purpose:   
// Arguments: 
// Return:   None 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FormatByteString(ULARGE_INTEGER uliVal, char *szDest);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FatalError
// Purpose:   Called when an unrecoverable error has occurred.  Forces exit
//            after notification
// Arguments: dwErr         -- The error that occurred
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FatalError(DWORD dwErr);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResource
// Purpose:   Display a messagebox using string resources
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResource(HWND hwnd, DWORD dwTextId, DWORD dwCaptionId,
                        DWORD dwFlags);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResourceParam
// Purpose:   Display a messagebox using string resources.  Expects one string
//            param for the text string.
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            szParam     -- String param for text string.
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResourceParam(HWND hwnd, DWORD dwTextId, char *szParam,
                             DWORD dwCaptionId, DWORD dwFlags);

void TrackMessage(UINT uMsg, WPARAM wparam, LPARAM lparam, char *szText);

void CenterDialog(HWND hDlg);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SetDlgControlFont
// Purpose:   Sets the font of the specified control in the specified dialog
// Arguments: hwnd                  -- The dialog with the control to set.
//            nControl              -- The control whose font we'll set
//            nHeight               -- Height of the font
//            szFace                -- Face of the font ("Arial", "Courier", etc)
//            nWeight               -- Normal (0) or Bold (FW_BOLD)
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT SetDlgControlFont(HWND hwnd, int nControl, int nHeight, char *szFace,
                          int nWeight);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\xbGameDisc.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      xbGameDisc.h
// Contents:  
// Revisions: 30-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

enum {TB_GLOBAL=0, TB_LAYER, TB_EXPLORER};

enum {VIEWMODE_EXPLORER, VIEWMODE_LAYER};

// Various window IDs.  Used for WM_NOTIFY handling.
enum {WNDID_TOOLBARMGR = 1000, WNDID_SPLITTER, WNDID_TREEVIEW, WNDID_TREEVIEW_STATIC,
      WNDID_EXPLISTVIEW, WNDID_LISTVIEW, WNDID_LISTVIEW_HEADER, WNDID_UNPLACED};

class CToolbarMgr;
class CStatusBar;

extern CToolbarMgr g_tbm;
extern HINSTANCE g_hInst;
extern CStatusBar g_statusbar;

enum {UM_TOOLBARRESIZED = WM_USER + 1};
typedef enum eEvent {EVENT_ADDED = 0, EVENT_REMOVED, EVENT_SIZECHANGED,
                     EVENT_TIMECHANGED, EVENT_ROOTDELETED};

#define CB_SIZE 13
extern HWND g_hwndPrevFocus;
extern HWND g_hwndMain;

extern HCURSOR g_hcurWait;
extern HCURSOR g_hcurArrow;
extern HCURSOR g_hcur;

extern int g_nWindowX, g_nWindowY, g_nWindowW, g_nWindowH;
extern int g_nUnplacedWindowX, g_nUnplacedWindowY, g_nUnplacedWindowW, g_nUnplacedWindowH;
extern int g_nCmdShow;

extern int g_nSplitterX, g_nSplitterX2;
extern bool g_fModified;
extern bool g_fDoStartupDlg;
extern HACCEL g_haccel;
extern BOOL CheckMessages();
extern CUpdateBox g_updatebox;
extern char g_szRootDir[MAX_PATH];
extern void SetModified();
extern void ClearModified();

class CFileHierarchy;
extern CFileHierarchy g_fh;

class CChangeQueue;
extern CChangeQueue g_cq;

class CViewMode;
extern CViewMode *g_pvmCur;

extern void SetViewMode(CViewMode *pvmNew);

extern bool g_fJustOpened;
extern char g_szName[MAX_PATH];

extern void SetMenuCmds(DWORD dw);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\ValidateFileSystem.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      ValidateFileSystem.cpp
// Contents:  
// Revisions: 10-Dec-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CChangeQueue::ValidateFileSystem
// Purpose:   Compares the physical filesystem against the local copy and
//            ensures that they are the same.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int cValid = 0;
void CChangeQueue::ValidateFileSystem()
{
    MSG msg;

    m_fValidating = TRUE;
forceupdate:
    // Tell the FileSystemChangeThread to force an update
    SetEvent(m_hevtForceUpdate);

    // Wait until the FileSystemChangeThread has signalled that it's finished
    // We sit in the windows message loop here to avoid blocking the UI
    while (WaitForSingleObject(m_hevtForceUpdateComplete, 0) == WAIT_TIMEOUT)
    {
        if (PeekMessage(&msg, g_hwndMain,  0, 0, PM_REMOVE)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }    

    SetCursor(g_hcurWait);

    // Recursively compare m_pfoRoot's contents against what is on the disk;
    // they must match exactly.
    VerifyFilesExist(m_pfoRoot);
    BOOL fFailTimeComp = !VerifyNoNewFiles(m_pfoRoot);

    // Tell the FileSystemChangeThread that we're done validating, and it
    // can continue updating
    SetEvent(m_hevtDoneUpdate);

    SetCursor(g_hcurArrow);

    // The file system takes it's time updating times on directories; try a
    // second time here just in case
    if (fFailTimeComp)
        goto forceupdate;

    m_fValidating = FALSE;

    DebugOutput("Passed: %d\n", ++cValid);
}

BOOL CChangeQueue::VerifyNoNewFiles(CFileObject *pfoCur)
{
    BY_HANDLE_FILE_INFORMATION bhfi;
    WIN32_FIND_DATA wfdChild;
    char sz[MAX_PATH], szPathChild[MAX_PATH];
    FILETIME ftModified;
    DWORD nFileSizeLow, nFileSizeHigh;

    // Enumerate all files in current folder and ensure they all exist in
    // pfoCur's list of children.  If any do not, then error!
    sprintf(sz, "%s\\*.*", pfoCur->m_szPath);
    HANDLE hff = FindFirstFile(sz, &wfdChild);
    if (hff == INVALID_HANDLE_VALUE)
    {
        // Failed to find the folder.
        char sz[1000];
        sprintf(sz, "The folder '%s' was unexpectedly deleted!", pfoCur->m_szPath);
        MessageBox(g_hwndMain, sz, "Error in validate", MB_ICONEXCLAMATION | MB_OK);
        exit(-1);
    }
    do
    {
        if (!_stricmp(wfdChild.cFileName, ".") || !_stricmp(wfdChild.cFileName, ".."))
            continue;

        sprintf(szPathChild, "%s\\%s", pfoCur->m_szPath, wfdChild.cFileName);

        HANDLE hfileChild;
        if (wfdChild.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            hfileChild = CreateFile(szPathChild, GENERIC_READ,
                       0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS , NULL);
        }
        else
        {
            hfileChild = CreateFile(szPathChild, GENERIC_READ,
                       0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        }
        if (hfileChild == INVALID_HANDLE_VALUE)
        {
            char sz[1000];
            sprintf(sz, "The object '%s' couldn't be opened! (error=0x%08x)", szPathChild, GetLastError());
            MessageBox(g_hwndMain, sz, "Error in validate", MB_ICONEXCLAMATION | MB_OK);
            exit(-1);
        }

        if (!GetFileInformationByHandle(hfileChild, &bhfi))
        {
            char sz[1000];
            sprintf(sz, "The object '%s' couldn't be opened #2! (error=0x%08x)", szPathChild, GetLastError());
            MessageBox(g_hwndMain, sz, "Error in validate", MB_ICONEXCLAMATION | MB_OK);
            exit(-1);
        }
        
        CloseHandle(hfileChild);
        ftModified    = bhfi.ftLastWriteTime;
        nFileSizeLow  = bhfi.nFileSizeLow;
        nFileSizeHigh = bhfi.nFileSizeHigh;
        
        // If the file isn't a child of the current object, then add it
        CFileObject *pfoChild = pfoCur->GetChildByName(wfdChild.cFileName);
        if (pfoChild == NULL)
        {
            // The file doesn't exist in the local file system!
            char sz[1000];
            sprintf(sz, "The object '%s' was in the physical fs but NOT the local fs!  Did you add this object while validation was running?", wfdChild.cFileName);
            MessageBox(g_hwndMain, sz, "Error in validate", MB_ICONEXCLAMATION | MB_OK);
            exit(-1);
        }
        else
        {
            // The child exists.
            if (wfdChild.dwFileAttributes != pfoChild->m_dwa)
            {
                char sz[1000];
                sprintf(sz, "The object '%s' has attributes '0x%08x' in the local fs, but attributes '0x%08x' in the physical fs!", 
                        pfoChild->m_szPath, pfoChild->m_dwa, wfdChild.dwFileAttributes);
                MessageBox(g_hwndMain, sz, "Error in validate", MB_ICONEXCLAMATION | MB_OK);
                exit(-1);
            }
            else if (pfoChild->m_uliSize.LowPart  != nFileSizeLow ||
                     pfoChild->m_uliSize.HighPart != nFileSizeHigh)
            {
                char sz[1000];
                sprintf(sz, "The object '%s' has size '%d' in the local fs but size '%d' in the physical fs!", 
                        pfoChild->m_szPath, pfoChild->m_uliSize.LowPart, nFileSizeLow);
                MessageBox(g_hwndMain, sz, "Error in validate", MB_ICONEXCLAMATION | MB_OK);
                exit(-1);
            }
            else if (CompareFileTime(&ftModified, &pfoChild->m_ftModified) != 0)
            {
                // 'Last modified' time changed.  This is not critical, and often the timestamp for
                // directories is updated a few moments later (caching, perhaps?).  In any case,
                // we jump back to try again; if it fails a second time then we hard-fail
                if (m_fFailedTimeCompare)
                {
                    char sz[1000];
                    sprintf(sz, "The object '%s' file time doesn't match!", pfoChild->m_szName);
                    MessageBox(g_hwndMain, sz, "Error in validate", MB_ICONEXCLAMATION | MB_OK);
                    exit(-1);
                }

                m_fFailedTimeCompare = true;
                FindClose(hff);
                return FALSE;
            }
        }

        // If the child is a directory, then recurse into it
        if (pfoChild->m_fIsDir)
            CheckExistingFiles(pfoChild);

    } while (FindNextFile(hff, &wfdChild));

    m_fFailedTimeCompare = false;

    FindClose(hff);
    return TRUE;
}

void CChangeQueue::VerifyFilesExist(CFileObject *pfoFolder)
{
    // For (every file in the internal filesystem)	
    //     If the file doesn't exist in the physical filesystem
    //         error!
    CFileObject *pfoChild = pfoFolder->GetFirstChild();
    while (pfoChild)
    {
        // Does pfoChild exist in 'szPath'?
        if (GetFileAttributes(pfoChild->m_szPath) == INVALID_FILE_ATTRIBUTES)
        {
            // File doesn't exist - error!
            char sz[1024];
            sprintf(sz, "Error - file '%s' was in the local filesystem but NOT in the physical filesystem!", pfoChild->m_szPath);
            MessageBox(g_hwndMain, sz, "Error in filesystem", MB_ICONEXCLAMATION | MB_OK);
            exit(-1);
        }
        else
        {
            // The file exists.  Recurse into it if it's a dir
            if (pfoChild->m_fIsDir)
                CheckDeletedFiles(pfoChild);
        }

        pfoChild = pfoFolder->GetNextChild();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\StdAfx.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      StdAfx.h
// Contents:  
// Revisions: 30-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Not defined in our build environment
#ifndef INVALID_FILE_ATTRIBUTES
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#endif

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include <shlobj.h>
#include <windows.h>
#include <assert.h>
#include <commctrl.h>
#include <stdio.h>
#include <shlguid.h>  
#include <shellapi.h>
#include <xboxverp.h>
#include <shlobj.h>

#include "CUpdateBox.h"
#include "CInitedObject.h"
#include "CFile.h"
#include "xbGameDisc.h"
#include "NewOpenSave.h"
#include "PersistSettings.h"

#include "resource.h"
#include "Util.h"

#include "CFastToSlow.h"
#include "CMyListView.h"

#include "CFileHierarchy.h"

#include "CStatusBar.h"
#include "CUnplacedListView.h"
#include "CUnplacedWindow.h"
#include "CSplitter.h"
#include "CToolbarMgr.h"
#include "CTreeView.h"
#include "CExpListView.h"
#include "CLayerListView.h"

#include "CViewMode.h"
#include "CViewMode_Explorer.h"
#include "CViewMode_Layer.h"

#include "FileSystemChangeThread.h"
#include "CFileObject.h"

#include "About.h"

#include "Debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\xbgamedisc\xbGameDisc.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      xbGameDisc.cpp
// Contents:  
// Revisions: 29-Oct-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"   -- Precompiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_szAppName -- Name of the application (used for class registration)
static char gs_szAppName[] = "xbGameDisc";

static bool g_fInited;

#define UM_DEBUG WM_USER + 1000

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES +++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_tbm        -- Creates and handles the various toolbars.
CToolbarMgr g_tbm;

// g_hInst      -- Handle to the 'current' instance of the application.
HINSTANCE g_hInst;

// g_pvmCur     -- The current view mode
CViewMode *g_pvmCur = NULL;

// g_statusbar  -- The status bar that appears at the bottom of the window
CStatusBar g_statusbar;

CChangeQueue g_cq;

// g_hwndPrevFocus  -- Used to restore focus to the correct control when
//                     the user tabs back to this app
HWND g_hwndPrevFocus;

HWND g_hwndMain;

void HandleDebugMsg(WPARAM wparam, LPARAM lparam);
void HandleEvents();

HACCEL g_haccel;

HCURSOR g_hcurWait;
HCURSOR g_hcurArrow;
HCURSOR g_hcur;

bool g_fModified;

char g_szName[MAX_PATH];

int g_nWindowX, g_nWindowY, g_nWindowW, g_nWindowH;
int g_nUnplacedWindowX, g_nUnplacedWindowY, g_nUnplacedWindowW, g_nUnplacedWindowH;
int g_nCmdShow;

int g_nSplitterX, g_nSplitterX2;
bool g_fDoStartupDlg;
char g_szRootDir[MAX_PATH];
bool g_fJustOpened = false;
CFileHierarchy g_fh;
void StartupDlg();

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void SetMenuCmds(DWORD dw)
{
    HMENU hmenu = GetMenu(g_hwndMain);
    EnableMenuItem(hmenu, IDM_FILE_SAVE,        dw);
    EnableMenuItem(hmenu, IDM_FILE_SAVEAS,      dw);
    EnableMenuItem(hmenu, IDM_EDIT_FIND,        dw);
    EnableMenuItem(hmenu, IDM_EDIT_SELECTALL,   dw);
    EnableMenuItem(hmenu, IDM_EDIT_FINDNEXT,    dw);
    EnableMenuItem(hmenu, IDM_EDIT_GROUP,       dw);
    EnableMenuItem(hmenu, IDM_EDIT_UNGROUP,     dw);
    EnableMenuItem(hmenu, IDM_EDIT_RESCAN,      dw);
    EnableMenuItem(hmenu, IDM_EDIT_REGENLAYOUT, dw);
    EnableMenuItem(hmenu, IDM_VIEW_FILE,        dw);
    EnableMenuItem(hmenu, IDM_VIEW_LAYOUT,      dw);
    EnableMenuItem(hmenu, IDM_TOOLS_EMULATE,    dw);
    EnableMenuItem(hmenu, IDM_TOOLS_PERF,       dw);
    EnableMenuItem(hmenu, IDM_TOOLS_PREMASTER,  dw);

    g_tbm.EnableButton(TB_GLOBAL, IDM_FILE_SAVE,       dw==MF_ENABLED);
    g_tbm.EnableButton(TB_GLOBAL, IDM_VIEW_FILE,       dw==MF_ENABLED);
    g_tbm.EnableButton(TB_GLOBAL, IDM_VIEW_LAYOUT,     dw==MF_ENABLED);
    g_tbm.EnableButton(TB_GLOBAL, IDM_TOOLS_EMULATE,   dw==MF_ENABLED);
    g_tbm.EnableButton(TB_GLOBAL, IDM_TOOLS_PREMASTER, dw==MF_ENABLED);
    g_tbm.EnableButton(TB_GLOBAL, IDM_TOOLS_PERF,      dw==MF_ENABLED);

    if (dw == MF_GRAYED)
    {
        g_tbm.EnableButton(TB_LAYER, IDM_EDIT_GROUP,   FALSE);
        g_tbm.EnableButton(TB_LAYER, IDM_EDIT_UNGROUP, FALSE);
        g_tbm.EnableButton(TB_LAYER, IDM_VIEW_LAYER0,  FALSE);
        g_tbm.EnableButton(TB_LAYER, IDM_VIEW_LAYER1,  FALSE);
        g_tbm.EnableButton(TB_LAYER, IDM_VIEW_BOTHLAYERS, FALSE);
        g_tbm.EnableButton(TB_LAYER, IDM_VIEW_UNPLACED,   dw==MF_ENABLED);
    }
    g_tbm.EnableButton(TB_LAYER, IDM_EDIT_RESCAN, dw==MF_ENABLED);
}

void SetViewMode(CViewMode *pvmNew)
{
    // Validate parameters
    assert(pvmNew);

    // Nothing to do if we're already in the specified mode
    if (pvmNew == g_pvmCur)
        return;

    // We're switching modes -- hide the current one and show the new one.
    if (g_pvmCur)
        g_pvmCur->Hide();
    g_pvmCur = pvmNew;
    g_pvmCur->Show();
}

void UpdateWindowCaption()
{
    char sz[MAX_PATH + 100];
    if (g_szName[0] == '\0')
        sprintf(sz, "xbGameDisc %s", g_fModified ? "*":"");
    else
        sprintf(sz, "xbGameDisc - [%s%s]", g_szName, g_fModified ? " *":"");
    SetWindowText(g_hwndMain, sz);
}

void ClearModified()
{
    g_fModified = false;

    UpdateWindowCaption();
}

void SetModified()
{
    g_fModified = true;

    UpdateWindowCaption();    
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WndProc
// Purpose:   This is the application's Windows message notification
//            function.  When Windows wants to tell the app that something
//            has happened (ie mouse button pressed), it does so by calling
//            into WndProc with the message and it's related information.
//            If this function does not handle the specified message, then
//            it is passed on to the Win32 function 'DefWindowProc', which
//            allows Windows to do any handling on it that it wants.
// Arguments: hwnd          -- Handle to the window
//            uMsg          -- The message sent to the window
//            wparam        -- A message parameter.
//            lparam        -- Another message parameter
// Return:    Result of the message processing - depends on the message sent.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    int nY;
    LPNMHDR pnmhdr;
    
//    TrackMessage(uMsg, wparam, lparam, "xbGameDisc");

    switch (uMsg) 
    {
    case WM_CREATE:
        g_hwndMain = hwnd;

        ClearModified();

        // Initialize the toolbar manager
		g_tbm.Init(hwnd);
        
        // Add the toolbars to the toolbarmgr
        InitToolbars();

        // Make the global toolbar visible
        g_tbm.Show(TB_GLOBAL);

        // Initialize the status bar
        g_statusbar.Init(hwnd);

        // Initialize the explorer and layer viewmodes (they will initialize
        // their own toolbars and menus).
        g_vmExplorer.Init(hwnd);
        g_vmLayer.Init(hwnd);

        // Initialize the file hierarchy 
         g_fh.Init();

        // By default, start in the Explorer mode
        g_vmLayer.Hide();
        SetViewMode(&g_vmExplorer);

        SetMenuCmds(MF_GRAYED);

        // Return 0 to tell windows to continue creation of the window
        return 0;

    case WM_SIZE:
        // Resize the different view modes to match the window's new size
        g_statusbar.Resize(LOWORD(lparam), HIWORD(lparam));        
        g_vmExplorer.Resize(LOWORD(lparam), HIWORD(lparam));
        g_vmLayer.Resize(LOWORD(lparam), HIWORD(lparam));

        // Resize the toolbar manager.
        g_tbm.Resize(wparam, lparam);
        break;

    case WM_NOTIFY:
        switch (wparam)
        {
        case WNDID_TOOLBARMGR:
            g_tbm.HandleNotify((LPNMHDR)lparam);
            break;
        case WNDID_TREEVIEW:
            pnmhdr = (LPNMHDR) lparam;
            if (pnmhdr->code == TVN_SELCHANGED)
                g_vmExplorer.m_treeview.HandleSelection(((LPNMTREEVIEW)pnmhdr));
            break;
        }
        break;

    case WM_SETFOCUS:
        if (g_hwndPrevFocus)
            SetFocus(g_hwndPrevFocus);
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        nY = g_tbm.GetRowsHeight();
        rc.left = ps.rcPaint.left;
        rc.right = ps.rcPaint.right;
        rc.top = nY-1;
        rc.bottom = rc.top + 1;
        FillRect(hdc, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH));
        rc.top = nY-2;
        rc.bottom = rc.top + 1;
        FillRect(hdc, &rc, (HBRUSH)GetStockObject(LTGRAY_BRUSH));
        EndPaint(hwnd, &ps);
        break;
        
    case WM_ERASEBKGND:
        return 1;

    case WM_CLOSE:
        // Close out current workspace if modified.
        if (g_fModified)
        {
            if (!VerifyCloseWorkspace())
                return 0;
        }
        CloseWorkspace();        
        StoreGlobalVars();
        PostQuitMessage(0);
        return 0;     

    case WM_COMMAND:
        switch(LOWORD(wparam))
        {
        case IDM_EDIT_SELECTALL:
        case IDM_VIEW_LAYER0:
        case IDM_VIEW_LAYER1:
        case IDM_VIEW_BOTHLAYERS:
        case IDM_VIEW_UNPLACED:
            g_pvmCur->HandleMenuCommand(LOWORD(wparam));
            break;
        case IDM_FILE_EXIT:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
        case IDM_VIEW_FILE:
            SetViewMode(&g_vmExplorer);
            break;
        case IDM_VIEW_LAYOUT:
            SetViewMode(&g_vmLayer);
            break;       
        case IDM_FILE_NEW:
            HandleNew();
            break;
        case IDM_FILE_SAVE:
            HandleSave();
            break;

        case IDM_FILE_SAVEAS:
            SaveAs();
            break;

        case IDM_FILE_OPEN:
            HandleOpen();
            break;

        case IDM_HELP_ABOUT:
            DoAbout(hwnd);
            break;
        }
        break;
        
    case WM_MOUSEMOVE:
        SetCursor(g_hcur);
        break;
        
    // USER DEFINED MESSAGES:

    case UM_TOOLBARRESIZED:
        // Toolbar has been resized; need to resize the current view to
        // take that into account.
        if (g_fInited)
        {
            GetClientRect(hwnd, &rc);
            g_vmExplorer.Resize(rc.right - rc.left, rc.bottom - rc.top);
            g_vmLayer.Resize(rc.right - rc.left, rc.bottom - rc.top);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case UM_DEBUG:
        // A test application has sent us a debug message
        HandleDebugMsg(wparam, lparam);
        break;
    }

    // Let Windows handle all unhandled messages
    return DefWindowProc(hwnd, uMsg, wparam, lparam);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  InitInstance
// Purpose:   Register our class and then create and show our window.
// Arguments: hinst         -- The handle to this instance of the app
//            nCmdShow      -- Default visibility of the application
// Return:    Handle to the newly created window (NULL if error).
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static HWND InitInstance(HINSTANCE hinst, int nCmdShow)
{
    WNDCLASSEX wcex;
    HWND       hwnd;

    g_fInited = false;

    // Register the class for the app's window.
    memset (&wcex, 0, sizeof wcex);
    wcex.cbSize         = sizeof(WNDCLASSEX); 
    wcex.lpfnWndProc    = (WNDPROC)WndProc;
    wcex.hInstance      = hinst;
    wcex.lpszClassName  = gs_szAppName;
    wcex.lpszMenuName   = TEXT("IDR_MENU1");
    if (!RegisterClassEx(&wcex))
        return NULL;

    // Create the app's window.
    hwnd = CreateWindow(gs_szAppName, gs_szAppName, WS_OVERLAPPEDWINDOW,
                        g_nWindowX, g_nWindowY, g_nWindowW, g_nWindowH, NULL, NULL, hinst, NULL);

    if (hwnd)
    {
        // Make our window visible and refresh it.
        ShowWindow(hwnd, nCmdShow);
        UpdateWindow(hwnd);
    }
    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

    g_hcurWait = LoadCursor(NULL, IDC_WAIT);
    g_hcurArrow = LoadCursor(NULL, IDC_ARROW);
    g_hcur = g_hcurArrow;

    g_fInited = true;

    // Drop into the startup dialog
    if (g_fDoStartupDlg)
        StartupDlg();

    return hwnd;
}

BOOL g_fQuit = false;
BOOL CheckMessages()
{
    MSG msg;
    if (PeekMessage(&msg, NULL,  0, 0, PM_REMOVE)) 
    {
        if (!TranslateAccelerator(g_hwndMain, g_haccel, &msg))
        {
            if (msg.message == WM_QUIT)
            {
                g_fQuit = true;
                return FALSE;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        return TRUE;
    }
    return FALSE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WinMain
// Purpose:   This is the default entry point into a Windows application.  
//            When the application is started, Windows calls into this
//            function - when this function exits, the application ends.
// Arguments: hinst         -- The handle to this instance of the app
//            hinstPrev     -- Obsolete; throwback to Win16 -- ignore
//            szCmdLine     -- Contains the parameter list passed to the app
//            nCmdShow      -- Default visibility of the application
// Return:    Result value application returns to the operating system
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int APIENTRY WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine,
                     int nCmdShow)
{
    g_hInst = hinst;

    // Initialize COM (necessary for SHGetFileInfo)
    CoInitialize(NULL);

    // Initialize global vars (which may have been saved in the registry
    // during a previous run)
    InitGlobalVars();
    
    // Initialize our class and create our window
    g_hwndMain = InitInstance (hinst, g_nCmdShow);
    if (g_hwndMain == NULL)
    {
        // A thoroughly unrecoverable (and unexpected) error occurred.  The
        // user's machine is fubar.
        MessageBox(NULL, "xbGameDisc failed to initialize.  Please "
                         "restart your computer and try again.",
                         "Failed to start", MB_ICONEXCLAMATION | MB_OK);
        return 0;
    }

    g_haccel = LoadAccelerators(hinst, "MYACCEL");
    
    // Main message loop:
    while (true)
    {
        if (!CheckMessages())
        {
            // Anything sitting in the change queue that we should handle?
            while (g_cq.m_cChangeQueueReady > 0)
            {
                HandleEvents();
                g_cq.m_cChangeQueueReady--;
            }
            if (g_pvmCur)
                g_pvmCur->UpdateIfDirty();
        }
        if (g_fQuit)
            break;
    }

    return 0;
}

void HandleDebugMsg(WPARAM wparam, LPARAM lparam)
{
    // A debugging application has sent us a debugging message.  Handle it here

    // For now, only message is "verify state"
    Debug_VerifyState();
}

void DumpEvent(eEvent event, CFileObject *pfo)
{
    return;
    
    if (event == EVENT_ADDED)
        DebugOutput("Added: %s", pfo->m_szPath);
    else if (event == EVENT_REMOVED)
        DebugOutput("Removed: %s", pfo->m_szPath);

    if (pfo->m_pfoParent) DebugOutput(" (parent=%s)", pfo->m_pfoParent->m_szName);
    DebugOutput("\n");
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleRootDeleted
// Purpose:   User deleted the root tree.  Clean up everything and warn the user
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleRootDeleted()
{
    CloseWorkspace();

    // Inform the user
    MessageBox(NULL, "The root directory has been removed.",
               "Root directory not found",
               MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function
// Purpose:   
// Arguments: 
// Return:    
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleEvents()
{
    eEvent event;
    CFileObject *pfo;
    bool fMod = false;
    
    while (g_cq.HasEvent())
    {
        g_cq.Dequeue(&event, &pfo);

        if (event == EVENT_ROOTDELETED)
        {
            // User deleted the root tree!
            HandleRootDeleted();
            return;
        }

//        DumpEvent(event, pfo);
        if (event == EVENT_ADDED)
            g_fh.Add(pfo);

        g_pvmCur->HandleEvent(event, pfo->m_pfoMainThread);
        
        if (event == EVENT_REMOVED)
        {
            g_fh.Remove(pfo);
            delete pfo;
        }

        // UNDONE: If *any* file system event occurs, the workspace is considered to
        // have been modified.  This may lead to some user confusion ("what?
        // I didn't modify anything!").  Need to document appropriately
        fMod = true;
    }
    if (fMod)
        SetModified();

    if (g_fJustOpened)
    {
        MessageBox(g_hwndMain, "Files have changed in the layout since the XLO file was last saved.",
                   "Layout has changed", MB_OK | MB_ICONWARNING | MB_APPLMODAL);
    }
    g_fJustOpened = false;
    g_pvmCur->UpdateIfDirty();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\producer.inc ===
MAJORCOMP=Windows	
MINORCOMP=directx

USE_MFC=1
USE_MSVCRT=1
USE_STATIC_ATL=1
ATL_VER=30
USE_MAPSYM=1
NOT_UNICODE=1
PLATFORM_MFC_VER = 0x0421
WIN32_IE_VERSION=0x0400

PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_CXX=1

!ifndef DMPROOT
DMPROOT = $(BASEDIR)\private\xdktools\Producer
!endif

#Shouldn't do -wd here, but I don't want to fix up all the source files yet...
C_DEFINES = $(C_DEFINES) -U_ATL_DLL -D_WIN32_IE=0x0400 -D_WIN32_WINNT=0x0400 -DDMP_XBOX
#-wd4242 -wd4244 -wd4296
!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif


!if "$(NTDEBUG)"!="" && "$(NTDEBUG)"!="ntsdnodbg"
MFC_LIBS=  \
          $(WSDK_LIB_PATH)\mfc42d.lib \
          $(WSDK_LIB_PATH)\mfcd42d.lib \
          $(WSDK_LIB_PATH)\mfcn42d.lib \
          $(WSDK_LIB_PATH)\mfco42d.lib \
          $(WSDK_LIB_PATH)\mfcs42d.lib
!else
MFC_LIBS=  \
          $(WSDK_LIB_PATH)\mfc42.lib \
          $(WSDK_LIB_PATH)\mfcs42.lib
!endif

MFC_INCLUDES=$(WSDK_INC_PATH)\mfc42

MFC_STATIC_LIB=$(MFC_STATIC_LIB) \
    $(WSDK_LIB_PATH)\mfcs42.lib

TARGETLIBS=$(TARGETLIBS) \
    $(WSDK_LIB_PATH)\kernel32.lib \
    $(WSDK_LIB_PATH)\user32.lib \
    $(WSDK_LIB_PATH)\gdi32.lib \
    $(WSDK_LIB_PATH)\comdlg32.lib \
    $(WSDK_LIB_PATH)\comctl32.lib \
    $(WSDK_LIB_PATH)\shell32.lib \
    $(WSDK_LIB_PATH)\winmm.lib \
    $(WSDK_LIB_PATH)\ole32.lib \
    $(WSDK_LIB_PATH)\oleaut32.lib \
    $(WSDK_LIB_PATH)\htmlhelp.lib \
    $(WSDK_LIB_PATH)\msdmo.lib \
    $(WSDK_LIB_PATH)\version.lib \
    $(WSDK_LIB_PATH)\advapi32.lib \
    $(DMPROOT)\Libs\i386\JazzCommon.lib \
    $(DMPROOT)\Libs\i386\DMUSProdGUID.lib \
    $(DMPROOT)\Libs\i386\DMUSProdGUIDPrivate.lib \
    $(WSDK_LIB_PATH)\uuid.lib

INCLUDES=$(INCLUDES);   \
		$(DMPROOT)\Includes; \
		$(DMPROOT)\Shared; \
		$(DMPROOT)\JazzCommon; \
		$(WSDK_INC_PATH)\atlmfc; \
		$(WSDK_INC_PATH);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\include\Conductor.h ===
/************************************************************************
*                                                                       *
*   conductor.h -- This module contains the API for the                 *
*                  DirectMusic Producer Conductor module.               *
*                                                                       *
*   Copyright (c) 1998-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef __Conductor_h__
#define __Conductor_h__

#include <windows.h>
#include "DMUSProd.h"

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C"{
#endif 

typedef __int64         REFERENCE_TIME;
typedef long            MUSIC_TIME;

/* Forward Declarations */ 
interface IDMUSProdMidiInCPt;
interface IDMUSProdConductorTempo;
interface IDMUSProdPortNotify;
interface IDMUSProdTransport;
interface IDMUSProdSecondaryTransport;
interface IDMUSProdNotifyCPt;
interface IDMUSProdConductor;
#ifndef __cplusplus 
typedef interface IDMUSProdMidiInCPt IDMUSProdMidiInCPt;
typedef interface IDMUSProdConductorTempo IDMUSProdConductorTempo;
typedef interface IDMUSProdPortNotify IDMUSProdPortNotify;
typedef interface IDMUSProdTransport IDMUSProdTransport;
typedef interface IDMUSProdSecondaryTransport IDMUSProdSecondaryTransport;
typedef interface IDMUSProdNotifyCPt IDMUSProdNotifyCPt;
typedef interface IDMUSProdConductor IDMUSProdConductor;
#endif  /* __cplusplus */

/* Macros for registering and unregistering to receive MIDI input. */
#define REGISTER_MIDI_IN(pconductor,cookie) \
IConnectionPointContainer *pICPC = NULL;\
if( SUCCEEDED( pconductor->QueryInterface( IID_IConnectionPointContainer, (void**)&pICPC )) )\
{IConnectionPoint *pICP = NULL;\
 if(SUCCEEDED( pICPC->FindConnectionPoint( IID_IDMUSProdMidiInCPt, &pICP )) )\
 {if( FAILED( pICP->Advise( (IUnknown*)((IDMUSProdMidiInCPt*)this), &cookie ) ) )\
  {cookie = 0;}\
  pICP->Release();}\
 pICPC->Release();}
#define UNREGISTER_MIDI_IN(pconductor,cookie) \
IConnectionPointContainer *pICPC = NULL;\
if( SUCCEEDED( pconductor->QueryInterface( IID_IConnectionPointContainer, (void**)&pICPC )) )\
{IConnectionPoint *pICP = NULL;\
 if(SUCCEEDED( pICPC->FindConnectionPoint( IID_IDMUSProdMidiInCPt, &pICP )) )\
 {if( SUCCEEDED( pICP->Unadvise( cookie ) ) )\
  {cookie = 0;}\
  pICP->Release();}\
 pICPC->Release();}
DEFINE_GUID(GUID_ConductorCountInBeatOffset, 0xb413282, 0xdc09, 0x11d2, 0xb0, 0xf1, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);

typedef struct _ConductorNotifyEvent
{
    long  m_cbSize;
    DWORD m_dwType;
    BYTE* m_pbData;
} ConductorNotifyEvent;

typedef enum enumConductorTransitionFlags
{
	TRANS_END_OF_SEGMENT	= 0x1,
	TRANS_REGULAR_PATTERN	= 0x2,
	TRANS_NO_TRANSITION		= 0x4
} ConductorTransitionFlags;

typedef struct _ConductorTransitionOptions
{
    DWORD dwBoundaryFlags;
    WORD wPatternType;
    DWORD dwFlags;
} ConductorTransitionOptions;

typedef enum enumButtonStateFlags
{
	BS_AUTO_UPDATE	= 0,
	BS_NO_AUTO_UPDATE	= 0x1,
	BS_PLAY_ENABLED		= 0x2,
	BS_PLAY_CHECKED		= 0x4,
	BS_STOP_ENABLED		= 0x8,
	BS_STOP_CHECKED		= 0x10,
	BS_RECORD_ENABLED	= 0x20,
	BS_RECORD_CHECKED	= 0x40
} ButtonStateFlags;

/*////////////////////////////////////////////////////////////////////
// IDMUSProdMidiInCPt */
#undef  INTERFACE
#define INTERFACE  IDMUSProdMidiInCPt
DECLARE_INTERFACE_(IDMUSProdMidiInCPt, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdMidiInCPt */
    STDMETHOD(OnMidiMsg)        (THIS_ REFERENCE_TIME rtTime,
                                       BYTE bStatus,
                                       BYTE bData1,
                                       BYTE bData2) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdConductorTempo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdConductorTempo
DECLARE_INTERFACE_(IDMUSProdConductorTempo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdConductorTempo */
    STDMETHOD(SetTempo)         (THIS_ double dblTempo) PURE;
    STDMETHOD(GetTempo)         (THIS_ double __RPC_FAR *pdblTempo) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPortNotify */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPortNotify
DECLARE_INTERFACE_(IDMUSProdPortNotify, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)		(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdPortNotify */
    STDMETHOD(OnOutputPortsChanged) (THIS) PURE;
    STDMETHOD(OnOutputPortsRemoved) (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTransport */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTransport
DECLARE_INTERFACE_(IDMUSProdTransport, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdTransport */
    STDMETHOD(Play)             (THIS_ BOOL fPlayFromStart) PURE;
    STDMETHOD(Stop)             (THIS_ BOOL fStopImmediate) PURE;
    STDMETHOD(Transition)       (THIS) PURE;
    STDMETHOD(Record)           (THIS_ BOOL fPressed) PURE;
    STDMETHOD(GetName)          (THIS_ BSTR __RPC_FAR *pbstrName) PURE;
    STDMETHOD(TrackCursor)      (THIS_ BOOL fTrackCursor) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSecondaryTransport */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSecondaryTransport
DECLARE_INTERFACE_(IDMUSProdSecondaryTransport, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)				(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
    STDMETHOD_(ULONG,Release)				(THIS) PURE;

    /* IDMUSProdSecondaryTransport */
    STDMETHOD(GetSecondaryTransportSegment) (THIS_ IUnknown __RPC_FAR *__RPC_FAR *ppunkISegment) PURE;
    STDMETHOD(GetSecondaryTransportName)    (THIS_ BSTR __RPC_FAR *pbstrName) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNotifyCPt */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNotifyCPt
DECLARE_INTERFACE_(IDMUSProdNotifyCPt, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdNotifyCPt */
    STDMETHOD(OnNotify)         (THIS_ ConductorNotifyEvent __RPC_FAR *pConductorNotifyEvent) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdConductor */
#undef  INTERFACE
#define INTERFACE  IDMUSProdConductor
DECLARE_INTERFACE_(IDMUSProdConductor, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)				(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
    STDMETHOD_(ULONG,Release)				(THIS) PURE;

    /* IDMUSProdConductor */
    STDMETHOD(GetPerformanceEngine)			(THIS_ IUnknown __RPC_FAR *__RPC_FAR *ppIPerformance) PURE;
    STDMETHOD(GetPort)						(THIS_ IUnknown __RPC_FAR *__RPC_FAR *ppIPort) PURE;
    STDMETHOD(RegisterTransport)			(THIS_ IDMUSProdTransport __RPC_FAR *pITransport,
												   DWORD dwFlags) PURE;
    STDMETHOD(UnRegisterTransport)			(THIS_ IDMUSProdTransport __RPC_FAR *pITransport) PURE;
    STDMETHOD(SetActiveTransport)			(THIS_ IDMUSProdTransport __RPC_FAR *pITransport,
												   DWORD dwFlags) PURE;
    STDMETHOD(IsTransportPlaying)			(THIS_ IDMUSProdTransport __RPC_FAR *pITransport) PURE;
    STDMETHOD(PlayMIDIEvent)				(THIS_ BYTE bStatus,
												   BYTE bData1,
												   BYTE bData2,
												   DWORD dwTime) PURE;
    STDMETHOD(SetBtnStates)					(THIS_ IDMUSProdTransport __RPC_FAR *pITransport,
												   DWORD dwFlags) PURE;
    STDMETHOD(SetTempo)						(THIS_ IDMUSProdTransport __RPC_FAR *pITransport,
												   double dblTempo,
												   BOOL fEnable) PURE;
    STDMETHOD(RegisterNotify)				(THIS_ IDMUSProdNotifyCPt __RPC_FAR *pINotifyCPt,
												   REFGUID rguidNotify) PURE;
    STDMETHOD(UnregisterNotify)				(THIS_ IDMUSProdNotifyCPt __RPC_FAR *pINotifyCPt,
												   REFGUID rguidNotify) PURE;
    STDMETHOD(SetTransportName)				(THIS_ IDMUSProdTransport __RPC_FAR *pITransport,
												   BSTR bstrName) PURE;
    STDMETHOD(TransportStopped)				(THIS_ IDMUSProdTransport __RPC_FAR *pITransport) PURE;
    STDMETHOD(GetTransitionOptions)			(THIS_ ConductorTransitionOptions __RPC_FAR *pTransitionOptions) PURE;
    STDMETHOD(RegisterSecondaryTransport)	(THIS_ IDMUSProdSecondaryTransport __RPC_FAR *pISecondaryTransport) PURE;
    STDMETHOD(UnRegisterSecondaryTransport)	(THIS_ IDMUSProdSecondaryTransport __RPC_FAR *pISecondaryTransport) PURE;
    STDMETHOD(SetSecondaryTransportName)	(THIS_ IDMUSProdSecondaryTransport __RPC_FAR *pISecondaryTransport,
												   BSTR bstrName) PURE;
    STDMETHOD(IsSecondaryTransportPlaying)	(THIS_ IDMUSProdSecondaryTransport __RPC_FAR *pISecondaryTransport) PURE;
    STDMETHOD(SetPChannelThru)				(THIS_ DWORD dwInputChannel,
												   DWORD dwPChannel) PURE;
    STDMETHOD(CancelPChannelThru)			(THIS_ DWORD dwInputChannel) PURE;
    STDMETHOD(IsTrackCursorEnabled)			(THIS) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_CConductor, 0x36f6dde8, 0x46ce, 0x11d0, 0xb9, 0xdb, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46);

/* IID's */
DEFINE_GUID(IID_IDMUSProdMidiInCPt, 0xaa349de0, 0xef0e, 0x11d0, 0xad, 0x22, 0x0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac);
DEFINE_GUID(IID_IDMUSProdConductorTempo, 0x32f40a16, 0x5f8f, 0x41a0, 0xb6, 0xbe, 0x51, 0x25, 0x7d, 0x1f, 0xe6, 0x88);
DEFINE_GUID(IID_IDMUSProdPortNotify, 0x9bd50920, 0x3c3c, 0x11d2, 0x8a, 0xa2, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdTransport, 0x8c7b3a62, 0xd33d, 0x11d2, 0xb0, 0xf0, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(IID_IDMUSProdSecondaryTransport, 0x52d006fa, 0x2281, 0x11d2, 0x88, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdNotifyCPt, 0xfa273400, 0x9f23, 0x11d1, 0x88, 0x77, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdConductor, 0xe8a27a9, 0x473e, 0x4f48, 0x82, 0x21, 0x57, 0x5b, 0xe7, 0x5, 0x95, 0x65);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* __Conductor_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\include\SegmentGuids.h ===
/************************************************************************
*                                                                       *
*   SegmentGUIDs.h -- This module contains the GUIDs for                *
*                        Segment Designer notifications                 *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef __SEGMENTGUIDS_H__
#define __SEGMENTGUIDS_H__
#include <objbase.h>

////////////////////////////////////////////////////////////////////////////////
// Segment Notification GUIDs
// {7013C793-0FCA-11d3-BCB5-00C04FA3726E}
DEFINE_GUID(GUID_ChordIndividualChordSharpsFlats, 0x7013c793, 0xfca, 0x11d3, 0xbc, 0xb5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
// {6F590FFB-EB69-11d1-88C9-00C04FBF8D15}
DEFINE_GUID(GUID_ChordKey, 0x6f590ffb, 0xeb69, 0x11d1, 0x88, 0xc9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
// {6F590FFC-EB69-11d1-88C9-00C04FBF8D15}
DEFINE_GUID(GUID_ChordSharpsFlats, 0x6f590ffc, 0xeb69, 0x11d1, 0x88, 0xc9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
// {96A0A26C-F4E7-11d1-88CB-00C04FBF8D15}
DEFINE_GUID(GUID_Segment_AllTracksAdded, 0x96a0a26c, 0xf4e7, 0x11d1, 0x88, 0xcb, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
// {F9A03440-38F3-11d2-89B5-00C04FD912C8}
DEFINE_GUID(GUID_DocRootNode, 0xf9a03440, 0x38f3, 0x11d2, 0x89, 0xb5, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
// {178633A6-4452-11d2-890C-00C04FBF8D15}
DEFINE_GUID(GUID_Segment_Undo_BSTR, 0x178633a6, 0x4452, 0x11d2, 0x89, 0xc, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
// {A2ACA78B-4461-11d2-BC6D-00C04FA3726E}
DEFINE_GUID(GUID_Segment_Length_Change, 0xa2aca78b, 0x4461, 0x11d2, 0xbc, 0x6d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
// {B53892D4-63B4-11d2-8918-00C04FBF8D15}
DEFINE_GUID(GUID_Segment_CreateTrack, 0xb53892d4, 0x63b4, 0x11d2, 0x89, 0x18, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
// {1C3840D2-0E39-11d3-A70C-00105A26620B}
DEFINE_GUID(GUID_Segment_DeletedTrack, 0x1c3840d2, 0xe39, 0x11d3, 0xa7, 0xc, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {CF0C97FA-679F-11d2-B064-00105A26620B}
DEFINE_GUID(GUID_Segment_DisplayContextMenu, 0xcf0c97fa, 0x679f, 0x11d2, 0xb0, 0x64, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {11CFE612-A757-11d2-B0D2-00105A26620B}
DEFINE_GUID(GUID_Segment_RecordButton, 0x11cfe612, 0xa757, 0x11d2, 0xb0, 0xd2, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {18D7F8F0-A757-11d2-B0D2-00105A26620B}
DEFINE_GUID(GUID_Segment_WindowActive, 0x18d7f8f0, 0xa757, 0x11d2, 0xb0, 0xd2, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {71754743-A98D-11d2-B0D3-00105A26620B}
DEFINE_GUID(GUID_Segment_Start, 0x71754743, 0xa98d, 0x11d2, 0xb0, 0xd3, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {71754744-A98D-11d2-B0D3-00105A26620B}
DEFINE_GUID(GUID_Segment_Stop, 0x71754744, 0xa98d, 0x11d2, 0xb0, 0xd3, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {1528EAB8-C518-11d2-B0E7-00105A26620B}
DEFINE_GUID(GUID_Segment_Set_Tempo, 0x1528eab8, 0xc518, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {7CFD1EE0-CBEF-11d2-8545-00105A2796DE}
DEFINE_GUID(GUID_Segment_NewStyleSelected, 0x7cfd1ee0, 0xcbef, 0x11d2, 0x85, 0x45, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
// {15CC2460-DD85-11d2-B43E-00105A2796DE}
DEFINE_GUID(GUID_Segment_FrameworkMsg, 0x15cc2460, 0xdd85, 0x11d2, 0xb4, 0x3e, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
// {9B3F0BE0-EDFF-11d2-B43F-00105A2796DE}
DEFINE_GUID(GUID_Segment_BandTrackChange, 0x9b3f0be0, 0xedff, 0x11d2, 0xb4, 0x3f, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
// {F811CE10-42A1-11d2-890B-00C04FBF8D15}
DEFINE_GUID(GUID_TimelineShowTimeSig, 0xf811ce10, 0x42a1, 0x11d2, 0x89, 0xb, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
// {9F879F8A-FDA3-11d2-A6F8-00105A26620B}
DEFINE_GUID(GUID_TimelineShowRealTime, 0x9f879f8a, 0xfda3, 0x11d2, 0xa6, 0xf8, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {03E2C8B0-C2F4-11d2-B0E7-00105A26620B}
DEFINE_GUID(GUID_TimelineSetSegStartTime, 0x3e2c8b0, 0xc2f4, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
// {CB715B92-C549-11d2-B0E7-00105A26620B}
DEFINE_GUID(GUID_TimelineSetCursor, 0xcb715b92, 0xc549, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);

#endif // __SEGMENTGUIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\libsrc\ConductorGUID.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IDMUSProdMidiInCPt = {0xAA349DE0,0xEF0E,0x11d0,{0xAD,0x22,0x00,0xA0,0xC9,0x2E,0x1C,0xAC}};


const IID IID_IDMUSProdConductorTempo = {0x32F40A16,0x5F8F,0x41a0,{0xB6,0xBE,0x51,0x25,0x7D,0x1F,0xE6,0x88}};


const IID IID_IDMUSProdPortNotify = {0x9BD50920,0x3C3C,0x11d2,{0x8A,0xA2,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};


const IID IID_IDMUSProdTransport = {0x8C7B3A62,0xD33D,0x11d2,{0xB0,0xF0,0x00,0x10,0x5A,0x26,0x62,0x0B}};


const IID IID_IDMUSProdSecondaryTransport = {0x52D006FA,0x2281,0x11d2,{0x88,0xF7,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};


const IID IID_IDMUSProdNotifyCPt = {0xFA273400,0x9F23,0x11d1,{0x88,0x77,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};


const IID IID_IDMUSProdConductor = {0x0E8A27A9,0x473E,0x4f48,{0x82,0x21,0x57,0x5B,0xE7,0x05,0x95,0x65}};


const CLSID CLSID_CConductor = {0x36F6DDE8,0x46CE,0x11D0,{0xB9,0xDB,0x00,0xAA,0x00,0xC0,0x81,0x46}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\include\SegmentDesigner.h ===
/************************************************************************
*                                                                       *
*   SegmentDesigner.h -- This module contains the API for the           *
*                        Segment Designer interfaces                    *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef __SegmentDesigner_h__
#define __SegmentDesigner_h__

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 
interface IDMUSProdSegmentEdit;
#ifndef __cplusplus 
typedef interface IDMUSProdSegmentEdit IDMUSProdSegmentEdit;
#endif /* __cplusplus */

typedef struct _DMUSProdFrameworkMsg
{
    GUID guidUpdateType;
    IUnknown __RPC_FAR *punkIDMUSProdNode;
    void __RPC_FAR *pData;
} DMUSProdFrameworkMsg;

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSegmentEdit */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSegmentEdit
DECLARE_INTERFACE_(IDMUSProdSegmentEdit, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)		(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
    STDMETHOD_(ULONG,Release)		(THIS) PURE;

    /* IDMUSProdSegmentEdit */
    STDMETHOD(AddStrip)				(THIS_ CLSID clsidTrackType,
										   DWORD dwGroupBits,
										   IUnknown __RPC_FAR *__RPC_FAR *ppIStripMgr) PURE;
    STDMETHOD(ContainsTempoStrip)	(THIS_ BOOL __RPC_FAR *pfTempoStripExists) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_SegmentDesigner,0xDFCE860E,0xA6FA,0x11d1,0x88,0x81,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(CLSID_SegmentComponent, 0xdfce860b, 0xa6fa, 0x11d1, 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);

/* GUID's */
DEFINE_GUID(GUID_SegmentNode, 0xdfce8609, 0xa6fa, 0x11d1, 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);

/* IID's */
DEFINE_GUID(IID_IDMUSProdSegmentEdit,0x18250220,0xCFE0,0x11d2,0x85,0x46,0x00,0x10,0x5A,0x27,0x96,0xDE);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* __SegmentDesigner_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\include\Timeline.h ===
/************************************************************************
*                                                                       *
*   Timeline.h -- This module contains the API for the                  *
*                 Timeline interfaces                                   *
*                                                                       *
*   Copyright (c) 1998-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef __Timeline_h__
#define __Timeline_h__

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include "stripmgr.h"

#ifdef __cplusplus
extern "C"{
#endif 

typedef __int64         REFERENCE_TIME;
typedef long            MUSIC_TIME;

/* Forward Declarations */ 
interface IDMUSProdTimelineDataObject;
interface IDMUSProdTimeline;
interface IDMUSProdTimelineCallback;
interface IDMUSProdTimelineEdit;
#ifndef __cplusplus 
typedef interface IDMUSProdTimelineDataObject IDMUSProdTimelineDataObject;
typedef interface IDMUSProdTimeline IDMUSProdTimeline;
typedef interface IDMUSProdTimelineCallback IDMUSProdTimelineCallback;
typedef interface IDMUSProdTimelineEdit IDMUSProdTimelineEdit;
#endif /* __cplusplus */

typedef enum enumTIMETYPE
{
	TIMETYPE_CLOCKS	= 0,
	TIMETYPE_MS		= TIMETYPE_CLOCKS + 1
} TIMETYPE;

typedef enum enumTIMELINE_PROPERTY
{
	TP_CLOCKLENGTH		 = 1,
	TP_STRIPMOUSECAPTURE = TP_CLOCKLENGTH + 1,
	TP_DMUSPRODFRAMEWORK = TP_STRIPMOUSECAPTURE + 1,
	TP_TIMELINECALLBACK  = TP_DMUSPRODFRAMEWORK + 1,
	TP_ACTIVESTRIP		 = TP_TIMELINECALLBACK + 1,
	TP_FUNCTIONBAR_WIDTH = TP_ACTIVESTRIP + 1,
	TP_MAXIMUM_HEIGHT	 = TP_FUNCTIONBAR_WIDTH + 1,
	TP_ZOOM				 = TP_MAXIMUM_HEIGHT + 1,
	TP_HORIZONTAL_SCROLL = TP_ZOOM + 1,
	TP_VERTICAL_SCROLL	 = TP_HORIZONTAL_SCROLL + 1,
	TP_SNAPAMOUNT		 = TP_VERTICAL_SCROLL + 1,
	TP_FREEZE_UNDO		 = TP_SNAPAMOUNT + 1,
	TP_SNAP_TO			 = TP_FREEZE_UNDO + 1
} TIMELINE_PROPERTY;

typedef enum enumDMUSPROD_TIMELINE_SNAP_TO
{
	DMUSPROD_TIMELINE_SNAP_NONE	= 0,
	DMUSPROD_TIMELINE_SNAP_GRID	= 1,
	DMUSPROD_TIMELINE_SNAP_BEAT	= 2,
	DMUSPROD_TIMELINE_SNAP_BAR	= 3
} DMUSPROD_TIMELINE_SNAP_TO;

typedef enum enumSTRIP_TIMELINE_PROPERTY
{
	STP_VERTICAL_SCROLL	  = 0,
	STP_GET_HDC			  = STP_VERTICAL_SCROLL + 1,
	STP_HEIGHT			  = STP_GET_HDC + 1,
	STP_STRIPVIEW		  = STP_HEIGHT + 1,
	STP_STRIP_RECT		  = STP_STRIPVIEW + 1,
	STP_FBAR_RECT		  = STP_STRIP_RECT + 1,
	STP_POSITION		  = STP_FBAR_RECT + 1,
	STP_GUTTER_SELECTED	  = STP_POSITION + 1,
	STP_ENTIRE_STRIP_RECT = STP_GUTTER_SELECTED + 1
} STRIP_TIMELINE_PROPERTY;

typedef enum enumMARKERID
{
	MARKER_CURRENTTIME	= 0,
	MARKER_BEGINSELECT	= MARKER_CURRENTTIME + 1,
	MARKER_ENDSELECT	= MARKER_BEGINSELECT + 1,
	MARKER_LEFTDISPLAY	= MARKER_ENDSELECT + 1
} MARKERID;

typedef enum enumMUSICLINE_PROPERTY
{
	ML_DRAW_MEASURE_BEAT_GRID = 0,
	ML_DRAW_MEASURE_BEAT	  = ML_DRAW_MEASURE_BEAT_GRID + 1
} MUSICLINE_PROPERTY;

typedef enum enumTIMELINE_PASTE_TYPE
{
	TL_PASTE_MERGE	   = 0,
	TL_PASTE_OVERWRITE = TL_PASTE_MERGE + 1
} TIMELINE_PASTE_TYPE;

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimelineDataObject */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimelineDataObject
DECLARE_INTERFACE_(IDMUSProdTimelineDataObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdTimelineDataObject */
    STDMETHOD(AddInternalClipFormat)	(THIS_ UINT uClipFormat,
											   IStream __RPC_FAR *pIStream) PURE;
    STDMETHOD(AddExternalClipFormat)	(THIS_ UINT uClipFormat,
											   IStream __RPC_FAR *pIStream) PURE;
    STDMETHOD(IsClipFormatAvailable)	(THIS_ UINT uClipFormat) PURE;
    STDMETHOD(AttemptRead)				(THIS_ UINT uClipFormat,
											   IStream __RPC_FAR *__RPC_FAR *ppIStream) PURE;
    STDMETHOD(GetBoundaries)			(THIS_ long __RPC_FAR *plStartTime,
											   long __RPC_FAR *plEndTime) PURE;
    STDMETHOD(SetBoundaries)			(THIS_ long lStartTime,
											   long lEndTime) PURE;
    STDMETHOD(Import)					(THIS_ IDataObject __RPC_FAR *pIDataObject) PURE;
    STDMETHOD(Export)					(THIS_ IDataObject __RPC_FAR *__RPC_FAR *ppIDataObject) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimeline */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimeline
DECLARE_INTERFACE_(IDMUSProdTimeline, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdTimeline */
    STDMETHOD(AddStripMgr)				(THIS_ IDMUSProdStripMgr __RPC_FAR *pIStripMgr,
											   DWORD dwGroupBits) PURE;
    STDMETHOD(AddStrip)					(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip) PURE;
    STDMETHOD(SetMarkerTime)			(THIS_ MARKERID idMarkerType,
											   TIMETYPE ttType,
											   long lClocks) PURE;
    STDMETHOD(GetMarkerTime)			(THIS_ MARKERID idMarkerType,
											   TIMETYPE ttType,
											   long __RPC_FAR *plClocks) PURE;
    STDMETHOD(ClocksToPosition)			(THIS_ long lClocks,
											   long __RPC_FAR *plPosition) PURE;
    STDMETHOD(PositionToClocks)			(THIS_ long lPosition,
											   long __RPC_FAR *plClocks) PURE;
    STDMETHOD(DrawMusicLines)			(THIS_ HDC hdc,
											   MUSICLINE_PROPERTY musicLineProperty,
											   DWORD dwGroupBits,
											   DWORD dwIndex,
											   LONG lXOffset) PURE;
    STDMETHOD(SetTimelineProperty)		(THIS_ TIMELINE_PROPERTY timelineProperty,
											   VARIANT variant) PURE;
    STDMETHOD(GetTimelineProperty)		(THIS_ TIMELINE_PROPERTY timelineProperty,
											   VARIANT __RPC_FAR *pVariant) PURE;
    STDMETHOD(Refresh)					(THIS) PURE;
    STDMETHOD(ClocksToMeasureBeat)		(THIS_ DWORD dwGroupBits,
											   DWORD dwIndex,
											   long lClocks,
											   long __RPC_FAR *plMeasure,
											   long __RPC_FAR *plBeat) PURE;
    STDMETHOD(PositionToMeasureBeat)	(THIS_ DWORD dwGroupBits,
											   DWORD dwIndex,
											   long lPosition,
											   long __RPC_FAR *plMeasure,
											   long __RPC_FAR *plBeat) PURE;
    STDMETHOD(MeasureBeatToClocks)		(THIS_ DWORD dwGroupBits,
											   DWORD dwIndex,
											   long lMeasure,
											   long lBeat,
											   long __RPC_FAR *plClocks) PURE;
    STDMETHOD(MeasureBeatToPosition)	(THIS_ DWORD dwGroupBits,
											   DWORD dwIndex,
											   long lMeasure,
											   long lBeat,
											   long __RPC_FAR *plPosition) PURE;
    STDMETHOD(StripInvalidateRect)		(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip,
											   RECT __RPC_FAR *pRect,
											   BOOL fErase) PURE;
    STDMETHOD(SetPropertyPage)			(THIS_ IUnknown __RPC_FAR *punkPropPageMgr,
											   IUnknown __RPC_FAR *punkPropPageObj) PURE;
    STDMETHOD(RemovePropertyPageObject)	(THIS_ IUnknown __RPC_FAR *punkPropPageObj) PURE;
    STDMETHOD(StripSetTimelineProperty)	(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip,
											   STRIP_TIMELINE_PROPERTY stripTimelineProperty,
											   VARIANT variant) PURE;
    STDMETHOD(OnDataChanged)			(THIS_ IUnknown __RPC_FAR *punkStripManager) PURE;
    STDMETHOD(TrackPopupMenu)			(THIS_ HMENU hMenu,
											   long lXPos,
											   long lYPos,
											   IDMUSProdStrip __RPC_FAR *pIStrip,
											   BOOL fEditMenu) PURE;
    STDMETHOD(ClocksToRefTime)			(THIS_ long lClocks,
											   REFERENCE_TIME __RPC_FAR *prtRefTime) PURE;
    STDMETHOD(PositionToRefTime)		(THIS_ long lPosition,
											   REFERENCE_TIME __RPC_FAR *prtRefTime) PURE;
    STDMETHOD(MeasureBeatToRefTime)		(THIS_ DWORD dwGroupBits,
											   DWORD dwIndex,
											   long lMeasure,
											   long lBeat,
											   REFERENCE_TIME __RPC_FAR *prtRefTime) PURE;
    STDMETHOD(RefTimeToClocks)			(THIS_ REFERENCE_TIME rtRefTime,
											   long __RPC_FAR *pTime) PURE;
    STDMETHOD(RefTimeToPosition)		(THIS_ REFERENCE_TIME rtRefTime,
											   long __RPC_FAR *plPosition) PURE;
    STDMETHOD(RefTimeToMeasureBeat)		(THIS_ DWORD dwGroupBits,
											   DWORD dwIndex,
											   REFERENCE_TIME rtRefTime,
											   long __RPC_FAR *plMeasure,
											   long __RPC_FAR *plBeat) PURE;
    STDMETHOD(ScreenToStripPosition)	(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip,
											   POINT __RPC_FAR *pPoint) PURE;
    STDMETHOD(StripGetTimelineProperty)	(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip,
											   STRIP_TIMELINE_PROPERTY stripTimelineProperty,
											   VARIANT __RPC_FAR *pVariant) PURE;
    STDMETHOD(RemoveStripMgr)			(THIS_ IDMUSProdStripMgr __RPC_FAR *pIStripMgr) PURE;
    STDMETHOD(RemoveStrip)				(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip) PURE;
    STDMETHOD(GetParam)					(THIS_ REFGUID rguidType,
											   DWORD dwGroupBits,
											   DWORD dwIndex,
											   MUSIC_TIME mtTime,
											   MUSIC_TIME __RPC_FAR *pmtNext,
											   void __RPC_FAR *pData) PURE;
    STDMETHOD(SetParam)					(THIS_ REFGUID rguidType,
											   DWORD dwGroupBits,
											   DWORD dwIndex,
											   MUSIC_TIME mtTime,
											   void __RPC_FAR *pData) PURE;
    STDMETHOD(GetStripMgr)				(THIS_ REFGUID rguidType,
											   DWORD dwGroupBits,
											   DWORD dwIndex,
											   IDMUSProdStripMgr __RPC_FAR *__RPC_FAR *ppIStripMgr) PURE;
    STDMETHOD(InsertStripAtDefaultPos)	(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip,
											   REFCLSID clsidType,
											   DWORD dwGroupBits,
											   DWORD dwIndex) PURE;
    STDMETHOD(EnumStrip)				(THIS_ DWORD dwEnum,
											   IDMUSProdStrip __RPC_FAR *__RPC_FAR *ppIStrip) PURE;
    STDMETHOD(InsertStripAtPos)			(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip,
											   DWORD dwPosition) PURE;
    STDMETHOD(StripToWindowPos)			(THIS_ IDMUSProdStrip __RPC_FAR *pIStrip,
											   POINT __RPC_FAR *pPoint) PURE;
    STDMETHOD(AddToNotifyList)			(THIS_ IDMUSProdStripMgr __RPC_FAR *pIStripMgr,
											   REFGUID rguidType,
											   DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveFromNotifyList)		(THIS_ IDMUSProdStripMgr __RPC_FAR *pIStripMgr,
											   REFGUID rguidType,
											   DWORD dwGroupBits) PURE;
    STDMETHOD(NotifyStripMgrs)			(THIS_ REFGUID rguidType,
											   DWORD dwGroupBits,
											   void __RPC_FAR *pData) PURE;
    STDMETHOD(AllocTimelineDataObject)	(THIS_ IDMUSProdTimelineDataObject __RPC_FAR *__RPC_FAR *ppITimelineDataObject) PURE;
    STDMETHOD(GetPasteType)				(THIS_ TIMELINE_PASTE_TYPE __RPC_FAR *ptlptPasteType) PURE;
    STDMETHOD(SetPasteType)				(THIS_ TIMELINE_PASTE_TYPE tlptPasteType) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimelineCallback */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimelineCallback
DECLARE_INTERFACE_(IDMUSProdTimelineCallback, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdTimelineCallback */
    STDMETHOD(OnDataChanged)	(THIS_ IUnknown __RPC_FAR *punkStripMgr) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimelineEdit */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimelineEdit
DECLARE_INTERFACE_(IDMUSProdTimelineEdit, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdTimelineEdit */
    STDMETHOD(Cut)				(THIS_ IDMUSProdTimelineDataObject __RPC_FAR *pIDataObject) PURE;
    STDMETHOD(Copy)				(THIS_ IDMUSProdTimelineDataObject __RPC_FAR *pIDataObject) PURE;
    STDMETHOD(Paste)			(THIS_ IDMUSProdTimelineDataObject __RPC_FAR *pIDataObject) PURE;
    STDMETHOD(Insert)			(THIS) PURE;
    STDMETHOD(Delete)			(THIS) PURE;
    STDMETHOD(SelectAll)		(THIS) PURE;
    STDMETHOD(CanCut)			(THIS) PURE;
    STDMETHOD(CanCopy)			(THIS) PURE;
    STDMETHOD(CanPaste)			(THIS_ IDMUSProdTimelineDataObject __RPC_FAR *pIDataObject) PURE;
    STDMETHOD(CanInsert)		(THIS) PURE;
    STDMETHOD(CanDelete)		(THIS) PURE;
    STDMETHOD(CanSelectAll)		(THIS) PURE;
};


/* CLSID's */
DEFINE_GUID(CLSID_TimelineCtl, 0xDB838A7C, 0xB4F5, 0x11d0, 0xa9, 0x7f, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* IID's */
DEFINE_GUID(IID_IDMUSProdTimelineDataObject, 0xD7D8A772, 0x3171, 0x11d2, 0x89, 0x0, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdTimeline, 0x22B5869D, 0x523E, 0x11d2, 0x89, 0x13, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdTimelineCallback, 0x8FE7E6D5, 0xF331, 0x11d0, 0xbc, 0x9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDMUSProdTimelineEdit, 0x8640F4B2, 0x2B01, 0x11d2, 0x88, 0xf9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* __Timeline_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\include\DMUSProd.h ===
/************************************************************************
*                                                                       *
*   DMUSProd.h -- This module contains the API for the                  *
*                 Framework interfaces                                  *
*                                                                       *
*   Copyright (c) 1998-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef __DMUSProd_h__
#define __DMUSProd_h__

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 
interface IDMUSProdFramework;
interface IDMUSProdNode;
interface IDMUSProdPropPageManager;
interface IDMUSProdPropPageObject;
interface IDMUSProdProject;
interface IDMUSProdComponent;
interface IDMUSProdRIFFExt;
interface IDMUSProdPersistInfo;
interface IDMUSProdDocType;
interface IDMUSProdEditor;
interface IDMUSProdSortNode;
interface IDMUSProdMenu;
interface IDMUSProdToolBar;
interface IDMUSProdPropSheet;
interface IDMUSProdFileRefChunk;
interface IDMUSProdLoaderRefChunk;
interface IDMUSProdNodeDrop;
interface IDMUSProdNotifySink;
interface IDMUSProdPChannelName;

#ifndef __cplusplus 
typedef interface IDMUSProdFramework IDMUSProdFramework;
typedef interface IDMUSProdNode IDMUSProdNode;
typedef interface IDMUSProdPropPageManager IDMUSProdPropPageManager;
typedef interface IDMUSProdPropPageObject IDMUSProdPropPageObject;
typedef interface IDMUSProdProject IDMUSProdProject;
typedef interface IDMUSProdComponent IDMUSProdComponent;
typedef interface IDMUSProdRIFFExt IDMUSProdRIFFExt;
typedef interface IDMUSProdPersistInfo IDMUSProdPersistInfo;
typedef interface IDMUSProdDocType IDMUSProdDocType;
typedef interface IDMUSProdEditor IDMUSProdEditor;
typedef interface IDMUSProdSortNode IDMUSProdSortNode;
typedef interface IDMUSProdMenu IDMUSProdMenu;
typedef interface IDMUSProdToolBar IDMUSProdToolBar;
typedef interface IDMUSProdPropSheet IDMUSProdPropSheet;
typedef interface IDMUSProdFileRefChunk IDMUSProdFileRefChunk;
typedef interface IDMUSProdLoaderRefChunk IDMUSProdLoaderRefChunk;
typedef interface IDMUSProdNodeDrop IDMUSProdNodeDrop;
typedef interface IDMUSProdNotifySink IDMUSProdNotifySink;
typedef interface IDMUSProdPChannelName IDMUSProdPChannelName;
#endif /* __cplusplus */


#define CF_DMUSPROD_FILE "DMUSProd File v.1"
#define FOURCC_DMUSPROD_FILEREF mmioFOURCC('j','z','f','r')

typedef enum enumStatusBarStyle
{
	SBS_NOBORDERS	= 0,
	SBS_RAISED		= SBS_NOBORDERS + 1,
	SBS_SUNKEN		= SBS_RAISED + 1
} StatusBarStyle;

typedef enum enumStatusBarLifeSpan
{
	SBLS_APPLICATION	= 0,
	SBLS_EDITOR			= 1000,
	SBLS_CONTROL		= 2000,
	SBLS_MOUSEDOWNUP	= 3000
} StatusBarLifeSpan;

typedef enum enumFileType
{
	FT_UNKNOWN	= 0,
	FT_DESIGN	= FT_UNKNOWN + 1,
	FT_RUNTIME	= FT_DESIGN + 1
}FileType;

typedef enum enumWhichLoader
{
	WL_DIRECTMUSIC	= 0,
	WL_PRODUCER	= WL_DIRECTMUSIC + 1
} WhichLoader;

typedef struct _DMUSProdListInfo
{
    WORD wSize;
    BSTR bstrName;
    BSTR bstrDescriptor;
    GUID guidObject;
} DMUSProdListInfo;

typedef struct _DMUSProdStreamInfo
{
    FileType ftFileType;
    GUID guidDataFormat;
    IDMUSProdNode __RPC_FAR *pITargetDirectoryNode;
} DMUSProdStreamInfo;

/*////////////////////////////////////////////////////////////////////
// IDMUSProdFramework */
#undef  INTERFACE
#define INTERFACE  IDMUSProdFramework
DECLARE_INTERFACE_(IDMUSProdFramework, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdFramework */
    STDMETHOD(FindComponent)			(THIS_ REFCLSID rclsid,
											   IDMUSProdComponent __RPC_FAR *__RPC_FAR *ppIComponent) PURE;
    STDMETHOD(GetFirstComponent)		(THIS_ IDMUSProdComponent __RPC_FAR *__RPC_FAR *ppIFirstComponent) PURE;
    STDMETHOD(GetNextComponent)			(THIS_ IDMUSProdComponent __RPC_FAR *pIComponent,
											   IDMUSProdComponent __RPC_FAR *__RPC_FAR *ppINextComponent) PURE;
    STDMETHOD(AddDocType)				(THIS_ IDMUSProdDocType __RPC_FAR *pIDocType) PURE;
    STDMETHOD(FindDocTypeByExtension)	(THIS_ BSTR bstrExt,
											   IDMUSProdDocType __RPC_FAR *__RPC_FAR *ppIDocType) PURE;
    STDMETHOD(FindDocTypeByNodeId)		(THIS_ REFGUID rguid,
											   IDMUSProdDocType __RPC_FAR *__RPC_FAR *ppIDocType) PURE;
    STDMETHOD(GetFirstDocType)			(THIS_ IDMUSProdDocType __RPC_FAR *__RPC_FAR *ppIFirstDocType) PURE;
    STDMETHOD(GetNextDocType)			(THIS_ IDMUSProdDocType __RPC_FAR *pIDocType,
											   IDMUSProdDocType __RPC_FAR *__RPC_FAR *ppINextDocType) PURE;
    STDMETHOD(CreateNewFile)			(THIS_ IDMUSProdDocType __RPC_FAR *pIDocType,
											   IDMUSProdNode __RPC_FAR *pITreePositionNode,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    STDMETHOD(OpenFile)					(THIS_ IDMUSProdDocType __RPC_FAR *pIDocType,
											   BSTR bstrTitle,
											   IDMUSProdNode __RPC_FAR *pITreePositionNode,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    STDMETHOD(CopyFile)					(THIS_ IDMUSProdNode __RPC_FAR *pIDocRootNode,
											   IDMUSProdNode __RPC_FAR *pITreePositionNode,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    STDMETHOD(ShowFile)					(THIS_ BSTR bstrFileName) PURE;
    STDMETHOD(RegisterClipFormatForFile)(THIS_ UINT uClipFormat,
											   BSTR bstrExt) PURE;
    STDMETHOD(SaveClipFormat)			(THIS_ UINT uClipFormat,
											   IDMUSProdNode __RPC_FAR *pINode,
											   IStream __RPC_FAR *__RPC_FAR *ppIStream) PURE;
    STDMETHOD(GetDocRootNodeFromData)	(THIS_ IDataObject __RPC_FAR *pIDataObject,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    STDMETHOD(AllocFileStream)			(THIS_ BSTR bstrFileName,
											   DWORD dwDesiredAccess,
											   FileType ftFileType,
											   GUID guidDataFormat,
											   IDMUSProdNode __RPC_FAR *pITargetFolderNode,
											   IStream __RPC_FAR *__RPC_FAR *ppIStream) PURE;
    STDMETHOD(AllocMemoryStream)		(THIS_ FileType ftFileType,
											   GUID guidDataFormat,
											   IStream __RPC_FAR *__RPC_FAR *ppIStream) PURE;
    STDMETHOD(GetFirstProject)			(THIS_ IDMUSProdProject __RPC_FAR *__RPC_FAR *ppIFirstProject) PURE;
    STDMETHOD(GetNextProject)			(THIS_ IDMUSProdProject __RPC_FAR *pIProject,
											   IDMUSProdProject __RPC_FAR *__RPC_FAR *ppINextProject) PURE;
    STDMETHOD(FindProject)				(THIS_ IDMUSProdNode __RPC_FAR *pINode,
											   IDMUSProdProject __RPC_FAR *__RPC_FAR *ppIProject) PURE;
    STDMETHOD(IsProjectEqual)			(THIS_ IDMUSProdNode __RPC_FAR *pIDocRootNode1,
											   IDMUSProdNode __RPC_FAR *pIDocRootNode2) PURE;
    STDMETHOD(AddNodeImageList)			(THIS_ HANDLE hImageList,
											   short __RPC_FAR *pnNbrFirstImage) PURE;
    STDMETHOD(GetNodeFileName)			(THIS_ IDMUSProdNode __RPC_FAR *pINode,
											   BSTR __RPC_FAR *pbstrFileName) PURE;
    STDMETHOD(GetNodeFileGUID)			(THIS_ IDMUSProdNode __RPC_FAR *pINode,
											   GUID __RPC_FAR *pguidFile) PURE;
    STDMETHOD(RevertFileToSaved)		(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(SaveNode)					(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(SaveNodeAsNewFile)		(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(AddNode)					(THIS_ IDMUSProdNode __RPC_FAR *pINode,
											   IDMUSProdNode __RPC_FAR *pIParentNode) PURE;
    STDMETHOD(RemoveNode)				(THIS_ IDMUSProdNode __RPC_FAR *pINode,
											   BOOL fPromptUser) PURE;
    STDMETHOD(FindDocRootNode)			(THIS_ GUID guidProject,
											   IDMUSProdDocType __RPC_FAR *pIDocType,
											   BSTR bstrNodeName,
											   BSTR bstrNodeDescriptor,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    STDMETHOD(FindDocRootNodeByFileGUID)(THIS_ GUID guidFile,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    STDMETHOD(GetBestGuessDocRootNode)	(THIS_ IDMUSProdDocType __RPC_FAR *pIDocType,
											   BSTR bstrNodeName,
											   IDMUSProdNode __RPC_FAR *pITreePositionNode,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    STDMETHOD(GetSelectedNode)			(THIS_ IDMUSProdNode __RPC_FAR *__RPC_FAR *ppINode) PURE;
    STDMETHOD(SetSelectedNode)			(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(RefreshNode)				(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(SortChildNodes)			(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(EditNodeLabel)			(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(OpenEditor)				(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(CloseEditor)				(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    STDMETHOD(AddToNotifyList)			(THIS_ IDMUSProdNode __RPC_FAR *pIDocRootNode,
											   IDMUSProdNode __RPC_FAR *pINotifyThisNode) PURE;
    STDMETHOD(RemoveFromNotifyList)		(THIS_ IDMUSProdNode __RPC_FAR *pIDocRootNode,
											   IDMUSProdNode __RPC_FAR *pINotifyThisNode) PURE;
    STDMETHOD(NotifyNodes)				(THIS_ IDMUSProdNode __RPC_FAR *pIChangedDocRootNode,
											   GUID guidUpdateType,
											   void __RPC_FAR *pData) PURE;
    STDMETHOD(AddMenuItem)				(THIS_ IDMUSProdMenu __RPC_FAR *pIMenu) PURE;
    STDMETHOD(RemoveMenuItem)			(THIS_ IDMUSProdMenu __RPC_FAR *pIMenu) PURE;
    STDMETHOD(AddToolBar)				(THIS_ IDMUSProdToolBar __RPC_FAR *pIToolBar) PURE;
    STDMETHOD(RemoveToolBar)			(THIS_ IDMUSProdToolBar __RPC_FAR *pIToolBar) PURE;
    STDMETHOD(SetNbrStatusBarPanes)		(THIS_ int nCount,
											   short nLifeSpan,
											   HANDLE __RPC_FAR *phKey) PURE;
    STDMETHOD(SetStatusBarPaneInfo)		(THIS_ HANDLE hKey,
											   int nIndex,
											   StatusBarStyle sbStyle,
											   int nMaxChars) PURE;
    STDMETHOD(SetStatusBarPaneText)		(THIS_ HANDLE hKey,
											   int nIndex,
											   BSTR bstrText,
											   BOOL bUpdate) PURE;
    STDMETHOD(RestoreStatusBar)			(THIS_ HANDLE hKey) PURE;
    STDMETHOD(StartProgressBar)			(THIS_ int nLower,
											   int nUpper,
											   BSTR bstrPrompt,
											   HANDLE __RPC_FAR *phKey) PURE;
    STDMETHOD(SetProgressBarPos)		(THIS_ HANDLE hKey,
											   int nPos) PURE;
    STDMETHOD(SetProgressBarStep)		(THIS_ HANDLE hKey,
											   UINT nValue) PURE;
    STDMETHOD(StepProgressBar)			(THIS_ HANDLE hKey) PURE;
    STDMETHOD(EndProgressBar)			(THIS_ HANDLE hKey) PURE;
    STDMETHOD(GetSharedObject)			(THIS_ REFCLSID rclsid,
											   REFIID riid,
											   void __RPC_FAR *__RPC_FAR *ppvObject) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNode */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNode
DECLARE_INTERFACE_(IDMUSProdNode, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdNode */
    STDMETHOD(GetNodeImageIndex)		(THIS_ short __RPC_FAR *pnNbrFirstImage) PURE;
    
    STDMETHOD(UseOpenCloseImages)		(THIS_ BOOL __RPC_FAR *pfUseOpenCloseImages) PURE;
    
    STDMETHOD(GetFirstChild)			(THIS_ IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIFirstChildNode) PURE;
    
    STDMETHOD(GetNextChild)				(THIS_ IDMUSProdNode __RPC_FAR *pIChildNode,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppINextChildNode) PURE;
    
    STDMETHOD(GetComponent)				(THIS_ IDMUSProdComponent __RPC_FAR *__RPC_FAR *ppIComponent) PURE;
    
    STDMETHOD(GetDocRootNode)			(THIS_ IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    
    STDMETHOD(SetDocRootNode)			(THIS_ IDMUSProdNode __RPC_FAR *pIDocRootNode) PURE;
    
    STDMETHOD(GetParentNode)			(THIS_ IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIParentNode) PURE;
    
    STDMETHOD(SetParentNode)			(THIS_ IDMUSProdNode __RPC_FAR *pIParentNode) PURE;
    
    STDMETHOD(GetNodeId)				(THIS_ GUID __RPC_FAR *pguid) PURE;
    
    STDMETHOD(GetNodeName)				(THIS_ BSTR __RPC_FAR *pbstrName) PURE;
    
    STDMETHOD(GetNodeNameMaxLength)		(THIS_ short __RPC_FAR *pnMaxLength) PURE;
    
    STDMETHOD(ValidateNodeName)			(THIS_ BSTR bstrName) PURE;
    
    STDMETHOD(SetNodeName)				(THIS_ BSTR bstrName) PURE;
    
    STDMETHOD(GetNodeListInfo)			(THIS_ DMUSProdListInfo __RPC_FAR *pListInfo) PURE;
    
    STDMETHOD(GetEditorClsId)			(THIS_ CLSID __RPC_FAR *pclsidEditor) PURE;
    
    STDMETHOD(GetEditorTitle)			(THIS_ BSTR __RPC_FAR *pbstrName) PURE;
    
    STDMETHOD(GetEditorWindow)			(THIS_ HWND __RPC_FAR *hWndEditor) PURE;
    
    STDMETHOD(SetEditorWindow)			(THIS_ HWND hWndEditor) PURE;
    
    STDMETHOD(GetRightClickMenuId)		(THIS_ HINSTANCE __RPC_FAR *phInstance,
											   UINT __RPC_FAR *pnResourceId) PURE;
    
    STDMETHOD(OnRightClickMenuInit)		(THIS_ HMENU hMenu) PURE;
    
    STDMETHOD(OnRightClickMenuSelect)	(THIS_ long lCommandId) PURE;
    
    STDMETHOD(DeleteChildNode)			(THIS_ IDMUSProdNode __RPC_FAR *pIChildNode,
											   BOOL fPromptUser) PURE;
    
    STDMETHOD(InsertChildNode)			(THIS_ IDMUSProdNode __RPC_FAR *pIChildNode) PURE;
    
    STDMETHOD(DeleteNode)				(THIS_ BOOL fPromptUser) PURE;
    
    STDMETHOD(OnNodeSelChanged)			(THIS_ BOOL fSelected) PURE;
    
    STDMETHOD(CreateDataObject)			(THIS_ IDataObject __RPC_FAR *__RPC_FAR *ppIDataObject) PURE;
    
    STDMETHOD(CanCut)					(THIS) PURE;
    
    STDMETHOD(CanCopy)					(THIS) PURE;
    
    STDMETHOD(CanDelete)				(THIS) PURE;
    
    STDMETHOD(CanDeleteChildNode)		(THIS_ IDMUSProdNode __RPC_FAR *pIChildNode) PURE;
    
    STDMETHOD(CanPasteFromData)			(THIS_ IDataObject __RPC_FAR *pIDataObject,
											   BOOL __RPC_FAR *pfWillSetReference) PURE;
    
    STDMETHOD(PasteFromData)			(THIS_ IDataObject __RPC_FAR *pIDataObject) PURE;
    
    STDMETHOD(CanChildPasteFromData)	(THIS_ IDataObject __RPC_FAR *pIDataObject,
											   IDMUSProdNode __RPC_FAR *pIChildNode,
											   BOOL __RPC_FAR *pfWillSetReference) PURE;
    
    STDMETHOD(ChildPasteFromData)		(THIS_ IDataObject __RPC_FAR *pIDataObject,
											   IDMUSProdNode __RPC_FAR *pIChildNode) PURE;
    
    STDMETHOD(GetObject)				(THIS_ REFCLSID rclsid,
											   REFIID riid,
											   void __RPC_FAR *__RPC_FAR *ppvObject) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageManager */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPropPageManager
DECLARE_INTERFACE_(IDMUSProdPropPageManager, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdPropPageManager */
    STDMETHOD(GetPropertySheetTitle)	(THIS_ BSTR __RPC_FAR *pbstrTitle,
											   BOOL __RPC_FAR *pfAddPropertiesText) PURE;
    
    STDMETHOD(GetPropertySheetPages)	(THIS_ IDMUSProdPropSheet __RPC_FAR *pIPropSheet,
											   LONG __RPC_FAR *__RPC_FAR hPropSheetPage[  ],
											   short __RPC_FAR *pnNbrPages) PURE;
    
    STDMETHOD(OnRemoveFromPropertySheet)(THIS) PURE;
    
    STDMETHOD(SetObject)				(THIS_ IDMUSProdPropPageObject __RPC_FAR *pIPropPageObject) PURE;
    
    STDMETHOD(RemoveObject)				(THIS_ IDMUSProdPropPageObject __RPC_FAR *pIPropPageObject) PURE;
    
    STDMETHOD(IsEqualObject)			(THIS_ IDMUSProdPropPageObject __RPC_FAR *pIPropPageObject) PURE;
    
    STDMETHOD(RefreshData)				(THIS) PURE;
    
    STDMETHOD(IsEqualPageManagerGUID)	(THIS_ REFGUID rguidPageManager) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPropPageObject
DECLARE_INTERFACE_(IDMUSProdPropPageObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdPropPageObject */
    STDMETHOD(GetData)					(THIS_ void __RPC_FAR *__RPC_FAR *ppData) PURE;
    
    STDMETHOD(SetData)					(THIS_ void __RPC_FAR *pData) PURE;
    
    STDMETHOD(OnShowProperties)			(THIS) PURE;
    
    STDMETHOD(OnRemoveFromPageManager)	(THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdProject */
#undef  INTERFACE
#define INTERFACE  IDMUSProdProject
DECLARE_INTERFACE_(IDMUSProdProject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdProject */
    STDMETHOD(GetName)					(THIS_ BSTR __RPC_FAR *pbstrName) PURE;
    
    STDMETHOD(GetGUID)					(THIS_ GUID __RPC_FAR *pguid) PURE;
    
    STDMETHOD(GetFirstFileByDocType)	(THIS_ IDMUSProdDocType __RPC_FAR *pIDocType,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIFirstFileNode) PURE;
    
    STDMETHOD(GetNextFileByDocType)		(THIS_ IDMUSProdNode __RPC_FAR *pIFileNode,
											   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppINextFileNode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdComponent */
#undef  INTERFACE
#define INTERFACE  IDMUSProdComponent
DECLARE_INTERFACE_(IDMUSProdComponent, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)		(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
    STDMETHOD_(ULONG,Release)		(THIS) PURE;

    /* IDMUSProdComponent */
    STDMETHOD(Initialize)			(THIS_ IDMUSProdFramework __RPC_FAR *pIFramework,
										   BSTR __RPC_FAR *pbstrErrMsg) PURE;
    
    STDMETHOD(CleanUp)				(THIS) PURE;
    
    STDMETHOD(GetName)				(THIS_ BSTR __RPC_FAR *pbstrName) PURE;
    
    STDMETHOD(AllocReferenceNode)	(THIS_ GUID guidRefNodeId,
										   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIRefNode) PURE;
    
    STDMETHOD(OnActivateApp)		(THIS_ BOOL fActivate) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdRIFFExt */
#undef  INTERFACE
#define INTERFACE  IDMUSProdRIFFExt
DECLARE_INTERFACE_(IDMUSProdRIFFExt, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdRIFFExt */
    STDMETHOD(LoadRIFFChunk)	(THIS_ IStream __RPC_FAR *pIStream,
									   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppINode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPersistInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPersistInfo
DECLARE_INTERFACE_(IDMUSProdPersistInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdPersistInfo */
    STDMETHOD(GetFileName)		(THIS_ BSTR __RPC_FAR *pbstrFileName) PURE;
    
    STDMETHOD(GetStreamInfo)	(THIS_ DMUSProdStreamInfo __RPC_FAR *pStreamInfo) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdDocType */
#undef  INTERFACE
#define INTERFACE  IDMUSProdDocType
DECLARE_INTERFACE_(IDMUSProdDocType, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)		(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
    STDMETHOD_(ULONG,Release)		(THIS) PURE;

    /* IDMUSProdDocType */
    STDMETHOD(GetResourceId) (THIS_ HINSTANCE __RPC_FAR *phInstance,
        UINT __RPC_FAR *pnResourceId) PURE;
    
    STDMETHOD(DoesExtensionMatch)	(THIS_ BSTR bstrExt) PURE;
    
    STDMETHOD(DoesIdMatch)			(THIS_ REFGUID rguid) PURE;
    
    STDMETHOD(AllocNode)			(THIS_ REFGUID rguid,
										   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppINode) PURE;
    
    STDMETHOD(OnFileNew)			(THIS_ IDMUSProdProject __RPC_FAR *pITargetProject,
										   IDMUSProdNode __RPC_FAR *pITargetDirectoryNode,
										   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    
    STDMETHOD(OnFileOpen)			(THIS_ IStream __RPC_FAR *pIStream,
										   IDMUSProdProject __RPC_FAR *pITargetProject,
										   IDMUSProdNode __RPC_FAR *pITargetDirectoryNode,
										   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    
    STDMETHOD(OnFileSave)			(THIS_ IStream __RPC_FAR *pIStream,
										   IDMUSProdNode __RPC_FAR *pIDocRootNode) PURE;
    
    STDMETHOD(GetListInfo)			(THIS_ IStream __RPC_FAR *pIStream,
										   DMUSProdListInfo __RPC_FAR *pListInfo) PURE;
    
    STDMETHOD(IsFileTypeExtension)	(THIS_ FileType ftFileType,
										   BSTR bstrExt) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdEditor */
#undef  INTERFACE
#define INTERFACE  IDMUSProdEditor
DECLARE_INTERFACE_(IDMUSProdEditor, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)				(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
    STDMETHOD_(ULONG,Release)				(THIS) PURE;

    /* IDMUSProdEditor */
    STDMETHOD(AttachObjects)				(THIS_ IDMUSProdNode __RPC_FAR *pINode) PURE;
    
    STDMETHOD(OnInitMenuFilePrint)			(THIS_ HMENU hMenu,
												   UINT nMenuID) PURE;
    
    STDMETHOD(OnInitMenuFilePrintPreview)	(THIS_ HMENU hMenu,
        UINT nMenuID) PURE;
    
    STDMETHOD(OnFilePrint)					(THIS) PURE;
    
    STDMETHOD(OnFilePrintPreview)			(THIS) PURE;
    
    STDMETHOD(OnViewProperties)				(THIS) PURE;
    
    STDMETHOD(OnF1Help)						(THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdReferenceNode */
#undef  INTERFACE
#define INTERFACE  IDMUSProdReferenceNode
DECLARE_INTERFACE_(IDMUSProdReferenceNode, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)		(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
    STDMETHOD_(ULONG,Release)		(THIS) PURE;

    /* IDMUSProdReferenceNode */
    STDMETHOD(GetReferencedFile)	(THIS_ IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    
    STDMETHOD(SetReferencedFile)	(THIS_ IDMUSProdNode __RPC_FAR *pIDocRootNode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSortNode */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSortNode
DECLARE_INTERFACE_(IDMUSProdSortNode, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdSortNode */
    STDMETHOD(CompareNodes)		(THIS_ IDMUSProdNode __RPC_FAR *pINode1,
									   IDMUSProdNode __RPC_FAR *pINode2,
									   int __RPC_FAR *pnResult) PURE;
    
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdMenu */
#undef  INTERFACE
#define INTERFACE  IDMUSProdMenu
DECLARE_INTERFACE_(IDMUSProdMenu, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdMenu */
    STDMETHOD(GetMenuText)		(THIS_ BSTR __RPC_FAR *pbstrText) PURE;
    
    STDMETHOD(GetMenuHelpText)	(THIS_ BSTR __RPC_FAR *pbstrHelpText) PURE;
    
    STDMETHOD(OnMenuInit)		(THIS_ HMENU hMenu,
									   UINT nMenuID) PURE;
    
    STDMETHOD(OnMenuSelect)		(THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdToolBar */
#undef  INTERFACE
#define INTERFACE  IDMUSProdToolBar
DECLARE_INTERFACE_(IDMUSProdToolBar, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdToolBar */
    STDMETHOD(GetInfo)			(THIS_ HWND __RPC_FAR *phWndOwner,
									   HINSTANCE __RPC_FAR *phInstance,
									   UINT __RPC_FAR *pnResourceId,
									   BSTR __RPC_FAR *pbstrTitle) PURE;
    
    STDMETHOD(GetMenuText)		(THIS_ BSTR __RPC_FAR *pbstrText) PURE;
    
    STDMETHOD(GetMenuHelpText)	(THIS_ BSTR __RPC_FAR *pbstrHelpText) PURE;
    
    STDMETHOD(Initialize)		(THIS_ HWND hWndToolBar) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPropSheet */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPropSheet
DECLARE_INTERFACE_(IDMUSProdPropSheet, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)				(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
    STDMETHOD_(ULONG,Release)				(THIS) PURE;

    /* IDMUSProdPropSheet */
    STDMETHOD(SetPageManager)				(THIS_ IDMUSProdPropPageManager __RPC_FAR *pINewPageManager) PURE;
    
    STDMETHOD(RemovePageManager)			(THIS_ IDMUSProdPropPageManager __RPC_FAR *pIPageManager) PURE;
    
    STDMETHOD(RemovePageManagerByObject)	(THIS_ IDMUSProdPropPageObject __RPC_FAR *pIPropPageObject) PURE;
    
    STDMETHOD(RefreshTitleByObject)			(THIS_ IDMUSProdPropPageObject __RPC_FAR *pIPropPageObject) PURE;
    
    STDMETHOD(RefreshActivePageByObject)	(THIS_ IDMUSProdPropPageObject __RPC_FAR *pIPropPageObject) PURE;
    
    STDMETHOD(IsEqualPageManagerObject)		(THIS_ IDMUSProdPropPageObject __RPC_FAR *pIPropPageObject) PURE;
    
    STDMETHOD(RefreshTitle)					(THIS) PURE;
    
    STDMETHOD(RefreshActivePage)			(THIS) PURE;
    
    STDMETHOD(GetActivePage)				(THIS_ short __RPC_FAR *pnIndex) PURE;
    
    STDMETHOD(SetActivePage)				(THIS_ short nIndex) PURE;
    
    STDMETHOD(Show)							(THIS_ BOOL fShow) PURE;
    
    STDMETHOD(IsShowing)					(THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdFileRefChunk */
#undef  INTERFACE
#define INTERFACE  IDMUSProdFileRefChunk
DECLARE_INTERFACE_(IDMUSProdFileRefChunk, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdFileRefChunk */
    STDMETHOD(LoadRefChunk)		(THIS_ IStream __RPC_FAR *pIStream,
									   IDMUSProdNode __RPC_FAR *__RPC_FAR *ppIDocRootNode) PURE;
    
    STDMETHOD(SaveRefChunk)		(THIS_ IStream __RPC_FAR *pIStream,
									   IDMUSProdNode __RPC_FAR *pIRefNode) PURE;
    
    STDMETHOD(GetChunkSize)		(THIS_ DWORD __RPC_FAR *pdwSize) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdLoaderRefChunk */
#undef  INTERFACE
#define INTERFACE  IDMUSProdLoaderRefChunk
DECLARE_INTERFACE_(IDMUSProdLoaderRefChunk, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
    STDMETHOD_(ULONG,Release)			(THIS) PURE;

    /* IDMUSProdLoaderRefChunk */
    STDMETHOD(SaveRefChunkForLoader)	(THIS_ IStream __RPC_FAR *pIStream,
											   IDMUSProdNode __RPC_FAR *pIRefNode,
											   REFCLSID rclsid,
											   void __RPC_FAR *pObjectDesc,
											   WhichLoader wlWhichLoader) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNodeDrop */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNodeDrop
DECLARE_INTERFACE_(IDMUSProdNodeDrop, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdNodeDrop */
    STDMETHOD(OnDropFiles)		(THIS_ HANDLE hDropInfo) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNotifySink */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNotifySink
DECLARE_INTERFACE_(IDMUSProdNotifySink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdNotifySink */
    STDMETHOD(OnUpdate)			(THIS_ IDMUSProdNode __RPC_FAR *pIDocRootNode,
									   GUID guidUpdateType,
									   void __RPC_FAR *pData) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPChannelName */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPChannelName
DECLARE_INTERFACE_(IDMUSProdPChannelName, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
    STDMETHOD_(ULONG,Release)	(THIS) PURE;

    /* IDMUSProdPChannelName */
    STDMETHOD(GetPChannelName)	(THIS_ DWORD dwPChannel, WCHAR __RPC_FAR *pwszName) PURE;

    STDMETHOD(SetPChannelName)	(THIS_ DWORD dwPChannel, WCHAR __RPC_FAR *pwszName) PURE;
};

/* GUID's */
DEFINE_GUID(FRAMEWORK_FileDeleted, 0xd6e0ada0,0x30ce,0x11d1,0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29);
DEFINE_GUID(FRAMEWORK_FileReplaced, 0xd6e0ada1,0x30ce,0x11d1,0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29);
DEFINE_GUID(FRAMEWORK_FileClosed, 0x8743aec0,0x3338,0x11d1,0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29);
DEFINE_GUID(FRAMEWORK_FileNameChange, 0xdd581b01,0x5463,0x11d2,0x89,0xb7,0x0,0xc0,0x4f,0xd9,0x12,0xc8);
DEFINE_GUID(DOCROOT_GuidChange, 0x592f8420,0x643b,0x11d2,0x89,0xb7,0x0,0xc0,0x4f,0xd9,0x12,0xc8);
DEFINE_GUID(GUID_DirectMusicObject, 0x102125e0,0x98b7,0x11d1,0x89,0xaf,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(GUID_CurrentVersion, 0x5cbdd400,0x35cc,0x11d1,0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(GUID_CurrentVersion_OnlyUI, 0x0bf78e00,0x4484,0x11d1,0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(GUID_Bookmark, 0xed259580,0xb1ea,0x11d2,0x85,0x3a,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(GUID_AllZeros, 0x00000000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);

/* IID's */
DEFINE_GUID(IID_IDMUSProdFramework,0x3b8d0e01,0x46b1,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdNode,0xda821fc1,0x4cef,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdPropPageManager,0x3095F6E1,0xC160,0x11d0,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdPropPageObject,0x3095F6E2,0xC160,0x11d0,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdProject,0xA03AA040,0xE63B,0x11d0,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdComponent,0x9F3ED901,0x46B7,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdRIFFExt,0xD913AC41,0x8411,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdPersistInfo,0xA8AE1161,0x99FD,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdDocType,0x5c9a32a1,0x4c6d,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdEditor,0xee3402a1,0x5405,0x11d0,0x89,0xac,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdReferenceNode,0xC483EFC0,0xEC89,0x11d0,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdSortNode,0x5662F480,0x65D9,0x11d2,0x89,0xB7,0x00,0xC0,0x4F,0xD9,0x12,0xC8);
DEFINE_GUID(IID_IDMUSProdMenu,0xf5d7ce01,0x4cef,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdToolBar,0x44D1A761,0xC5FE,0x11d0,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdPropSheet,0x3095F6E0,0xC160,0x11d0,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdFileRefChunk,0x7B0FC840,0xE66D,0x11d0,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdLoaderRefChunk,0xA6403B00,0xB1D6,0x11d1,0x89,0xAF,0x00,0xC0,0x4F,0xD9,0x12,0xC8);
DEFINE_GUID(IID_IDMUSProdNodeDrop,0x24990B00,0xC287,0x11d2,0x85,0x45,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(IID_IDMUSProdNotifySink,0x28275880,0x2E9F,0x11d1,0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(IID_IDMUSProdPChannelName,0x69509a6b,0x1ff8,0x11d2,0x88,0xf4,0x00,0xc0,0x4f,0xbf,0x8d,0x15);
struct __declspec(uuid("{3095F6E2-C160-11d0-89AE-00A0C9054129}")) IDMUSProdPropPageObject;

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* __DMUSProd_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\libsrc\DMUSProdGUID.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
typedef IID GUID;
#endif // CLSID_DEFINED

const IID IID_IDMUSProdFramework = {0x3b8d0e01,0x46b1,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdNode = {0xda821fc1,0x4cef,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdPropPageManager = {0x3095F6E1,0xC160,0x11d0,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdPropPageObject = {0x3095F6E2,0xC160,0x11d0,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdProject = {0xA03AA040,0xE63B,0x11d0,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdComponent = {0x9F3ED901,0x46B7,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdRIFFExt = {0xD913AC41,0x8411,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdPersistInfo = {0xA8AE1161,0x99FD,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdDocType = {0x5c9a32a1,0x4c6d,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdEditor = {0xee3402a1,0x5405,0x11d0,{0x89,0xac,0x00,0xa0,0xc9,0x05,0x41,0x29}};


const IID IID_IDMUSProdReferenceNode = {0xC483EFC0,0xEC89,0x11d0,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdSortNode = {0x5662F480,0x65D9,0x11d2,{0x89,0xB7,0x00,0xC0,0x4F,0xD9,0x12,0xC8}};


const IID IID_IDMUSProdMenu = {0xf5d7ce01,0x4cef,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdToolBar = {0x44D1A761,0xC5FE,0x11d0,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdPropSheet = {0x3095F6E0,0xC160,0x11d0,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdFileRefChunk = {0x7B0FC840,0xE66D,0x11d0,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdLoaderRefChunk = {0xA6403B00,0xB1D6,0x11d1,{0x89,0xAF,0x00,0xC0,0x4F,0xD9,0x12,0xC8}};


const IID IID_IDMUSProdNodeDrop = {0x24990B00,0xC287,0x11d2,{0x85,0x45,0x00,0x10,0x5A,0x27,0x96,0xDE}};


const IID IID_IDMUSProdNotifySink = {0x28275880,0x2E9F,0x11d1,{0x89,0xAE,0x00,0xA0,0xC9,0x05,0x41,0x29}};


const IID IID_IDMUSProdSetPersistInfo = {0xD22B1160,0x3915,0x11d2,{0x89,0xB5,0x00,0xC0,0x4F,0xD9,0x12,0xC8}};

const GUID FRAMEWORK_FileDeleted = {0xd6e0ada0,0x30ce,0x11d1,{0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29}};  
const GUID FRAMEWORK_FileReplaced = {0xd6e0ada1,0x30ce,0x11d1,{0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29}};  
const GUID FRAMEWORK_FileClosed = {0x8743aec0,0x3338,0x11d1,{0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29}};  
const GUID FRAMEWORK_FileNameChange = {0xdd581b01,0x5463,0x11d2,{0x89,0xb7,0x0,0xc0,0x4f,0xd9,0x12,0xc8}};
const GUID DOCROOT_GuidChange = {0x592f8420,0x643b,0x11d2,{0x89,0xb7,0x0,0xc0,0x4f,0xd9,0x12,0xc8}};

const GUID GUID_DirectMusicObject = {0x102125e0,0x98b7,0x11d1,{0x89,0xaf,0x00,0xa0,0xc9,0x05,0x41,0x29}};
const GUID GUID_CurrentVersion = {0x5cbdd400,0x35cc,0x11d1,{0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29}};  
const GUID GUID_CurrentVersion_OnlyUI = {0x0bf78e00,0x4484,0x11d1,{0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29}};
const GUID GUID_Bookmark = {0xed259580,0xb1ea,0x11d2,{0x85,0x3a,0x00,0x10,0x5a,0x27,0x96,0xde}};  
const GUID GUID_AllZeros = {0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}};  


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\include\StripMgr.h ===
/************************************************************************
*                                                                       *
*   StripMgr.h -- This module contains the API for the                  *
*                 Strip Manager interfaces                              *
*                                                                       *
*   Copyright (c) 1998-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef __StripMgr_h__
#define __StripMgr_h__

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C"{
#endif 

typedef long            MUSIC_TIME;

/* Forward Declarations */ 
interface IDMUSProdStrip;
interface IDMUSProdStripFunctionBar;
interface IDMUSProdStripMgr;
#ifndef __cplusplus 
typedef interface IDMUSProdStrip IDMUSProdStrip;
typedef interface IDMUSProdStripFunctionBar IDMUSProdStripFunctionBar;
typedef interface IDMUSProdStripMgr IDMUSProdStripMgr;
#endif /* __cplusplus */

typedef enum enumSTRIPVIEW
{
	SV_NORMAL				 = 0,
	SV_MINIMIZED			 = SV_NORMAL + 1,
	SV_FUNCTIONBAR_NORMAL	 = SV_MINIMIZED + 1,
	SV_FUNCTIONBAR_MINIMIZED = SV_FUNCTIONBAR_NORMAL + 1
} STRIPVIEW;

typedef enum enumSTRIPPROPERTY
{
	SP_NAME						 = 0,
	SP_GUTTERSELECTABLE			 = SP_NAME + 1,
	SP_GUTTERSELECT				 = SP_GUTTERSELECTABLE + 1,
	SP_BEGINSELECT				 = SP_GUTTERSELECT + 1,
	SP_ENDSELECT				 = SP_BEGINSELECT + 1,
	SP_CURSOR_HANDLE			 = SP_ENDSELECT + 1,
	SP_DEFAULTHEIGHT			 = SP_CURSOR_HANDLE + 1,
	SP_RESIZEABLE				 = SP_DEFAULTHEIGHT + 1,
	SP_MAXHEIGHT				 = SP_RESIZEABLE + 1,
	SP_MINHEIGHT				 = SP_MAXHEIGHT + 1,
	SP_MINMAXABLE				 = SP_MINHEIGHT + 1,
	SP_MINIMIZE_HEIGHT			 = SP_MINMAXABLE + 1,
	SP_STRIPMGR					 = SP_MINIMIZE_HEIGHT + 1,
	SP_FUNCTIONBAR_EXCLUDE_WIDTH = SP_STRIPMGR + 1,
	SP_USER						 = 1024
} STRIPPROPERTY;

typedef enum enumSTRIPMGRPROPERTY
{
	SMP_ITIMELINECTL		= 0,
	SMP_IDIRECTMUSICTRACK	= SMP_ITIMELINECTL + 1,
	SMP_IDMUSPRODFRAMEWORK	= SMP_IDIRECTMUSICTRACK + 1,
	SMP_DMUSIOTRACKHEADER	= SMP_IDMUSPRODFRAMEWORK + 1,
	SMP_USER				= 1024
} STRIPMGRPROPERTY;

/*////////////////////////////////////////////////////////////////////
// IDMUSProdStrip */
#undef  INTERFACE
#define INTERFACE  IDMUSProdStrip
DECLARE_INTERFACE_(IDMUSProdStrip, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdStrip */
    STDMETHOD(Draw)				(THIS_ HDC hDC,
                                       STRIPVIEW stripView,
                                       LONG lXOffset) PURE;
    STDMETHOD(GetStripProperty) (THIS_ STRIPPROPERTY stripProperty,
                                       VARIANT __RPC_FAR *pVariant) PURE;
    STDMETHOD(SetStripProperty) (THIS_ STRIPPROPERTY stripProperty,
                                       VARIANT variant) PURE;
    STDMETHOD(OnWMMessage)      (THIS_ UINT nMsg,
                                       WPARAM wParam,
                                       LPARAM lParam,
                                       LONG lXPos,
                                       LONG lYPos) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdStripFunctionBar */
#undef  INTERFACE
#define INTERFACE  IDMUSProdStripFunctionBar
DECLARE_INTERFACE_(IDMUSProdStripFunctionBar, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdStripFunctionBar */
    STDMETHOD(FBDraw)			(THIS_ HDC hDC,
                                       STRIPVIEW stripView) PURE;
    STDMETHOD(FBOnWMMessage)    (THIS_ UINT nMsg,
                                       WPARAM wParam,
                                       LPARAM lParam,
                                       LONG lXPos,
                                       LONG lYPos) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdStripMgr */
#undef  INTERFACE
#define INTERFACE  IDMUSProdStripMgr
DECLARE_INTERFACE_(IDMUSProdStripMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)		(THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
    STDMETHOD_(ULONG,Release)		(THIS) PURE;

    /* IDMUSProdStripMgr */
    STDMETHOD(IsParamSupported)		(THIS_ REFGUID rguidType) PURE;
    STDMETHOD(GetParam)				(THIS_ REFGUID rguidType,
										   MUSIC_TIME mtTime,
										   MUSIC_TIME __RPC_FAR *pmtNext,
										   void __RPC_FAR *pData) PURE;
    STDMETHOD(SetParam)				(THIS_ REFGUID rguidType,
										   MUSIC_TIME mtTime,
										   void __RPC_FAR *pData) PURE;
    STDMETHOD(OnUpdate)				(THIS_ REFGUID rguidType,
										   DWORD dwGroupBits,
										   void __RPC_FAR *pData) PURE;
    STDMETHOD(GetStripMgrProperty)	(THIS_ STRIPMGRPROPERTY stripMgrProperty,
										   VARIANT __RPC_FAR *pVariant) PURE;
    STDMETHOD(SetStripMgrProperty)  (THIS_ STRIPMGRPROPERTY stripMgrProperty,
										   VARIANT variant) PURE;
};

/* IID's */
DEFINE_GUID(IID_IDMUSProdStrip, 0x893ee17a, 0x4a3, 0x11d3, 0x89, 0x4c, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdStripFunctionBar, 0x86d596cc, 0xb302, 0x11d1, 0x88, 0x8f, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdStripMgr, 0x893ee17b, 0x04a3, 0x11d3, 0x89, 0x4c, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
struct __declspec(uuid("{893EE17A-04A3-11d3-894C-00C04FBF8D15}")) IDMUSProdStrip;
struct __declspec(uuid("{86D596CC-B302-11d1-888F-00C04FBF8D15}")) IDMUSProdStripFunctionBar;
struct __declspec(uuid("{893EE17B-04A3-11d3-894C-00C04FBF8D15}")) IDMUSProdStripMgr;

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* __StripMgr_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Debug.h ===
#if !defined(AFX_DEBUG_H__34A9EE9F_9372_4036_92E8_54313BE6234C__INCLUDED_)
#define AFX_DEBUG_H__34A9EE9F_9372_4036_92E8_54313BE6234C__INCLUDED_

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _PSEUDO_DEBUG

#undef TRACE
#undef VERIFY
#undef ASSERT
#undef THIS_FILE
#undef TRACE0
#undef TRACE1
#undef TRACE2
#undef TRACE3


// Note: file names are still ANSI strings (filenames rarely need UNICODE)
BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);

void Trace(LPCTSTR lpszFormat, ...);

// by default, debug break is asm int 3, or a call to DebugBreak, or nothing
#if defined(_M_IX86)
#define CustomDebugBreak() _asm { int 3 }
#else
#define CustomDebugBreak() DebugBreak()
#endif

#define TRACE              ::Trace
#define THIS_FILE          __FILE__
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
		CustomDebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              ::Trace(_T(sz))
#define TRACE1(sz, p1)          ::Trace(_T(sz), p1)
#define TRACE2(sz, p1, p2)      ::Trace(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  ::Trace(_T(sz), p1, p2, p3)

#endif // !_PSEUDO_DEBUG


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEBUG_H__34A9EE9F_9372_4036_92E8_54313BE6234C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\libsrc\SegmentDesignerGUID.c ===
// SegmentDesignerGuids.c : Contains GUIDs not found in MIDL generated SegmentDesigner_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;
typedef IID CLSID;
typedef IID GUID;


const GUID GUID_SegmentNode = { 0xdfce8609, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

const CLSID CLSID_SegmentComponent = { 0xdfce860b, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

const CLSID CLSID_SegmentDesigner = {0xDFCE860E,0xA6FA,0x11d1,{0x88,0x81,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};

const IID IID_IDMUSProdSegmentEdit = {0x18250220,0xCFE0,0x11d2,{0x85,0x46,0x00,0x10,0x5A,0x27,0x96,0xDE}};

const GUID GUID_ChordIndividualChordSharpsFlats = { 0x7013c793, 0xfca, 0x11d3, 0xbc, 0xb5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e };

const GUID GUID_ChordKey = { 0x6f590ffb, 0xeb69, 0x11d1, 0x88, 0xc9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 };

const GUID GUID_ChordSharpsFlats = { 0x6f590ffc, 0xeb69, 0x11d1, 0x88, 0xc9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 };

const GUID GUID_Segment_AllTracksAdded = { 0x96a0a26c, 0xf4e7, 0x11d1, 0x88, 0xcb, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 };

const GUID GUID_DocRootNode = { 0xf9a03440, 0x38f3, 0x11d2, 0x89, 0xb5, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8 };

const GUID GUID_Segment_Undo_BSTR = { 0x178633a6, 0x4452, 0x11d2, 0x89, 0xc, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 };

const GUID GUID_Segment_Length_Change = { 0xa2aca78b, 0x4461, 0x11d2, 0xbc, 0x6d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e };

const GUID GUID_Segment_CreateTrack = { 0xb53892d4, 0x63b4, 0x11d2, 0x89, 0x18, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 };

const GUID GUID_Segment_DeletedTrack = { 0x1c3840d2, 0xe39, 0x11d3, 0xa7, 0xc, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_Segment_DisplayContextMenu = { 0xcf0c97fa, 0x679f, 0x11d2, 0xb0, 0x64, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_Segment_RecordButton = { 0x11cfe612, 0xa757, 0x11d2, 0xb0, 0xd2, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_Segment_WindowActive = { 0x18d7f8f0, 0xa757, 0x11d2, 0xb0, 0xd2, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_Segment_Start = { 0x71754743, 0xa98d, 0x11d2, 0xb0, 0xd3, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_Segment_Stop = { 0x71754744, 0xa98d, 0x11d2, 0xb0, 0xd3, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_Segment_Set_Tempo = { 0x1528eab8, 0xc518, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_Segment_NewStyleSelected = { 0x7cfd1ee0, 0xcbef, 0x11d2, 0x85, 0x45, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde };

const GUID GUID_Segment_FrameworkMsg = { 0x15cc2460, 0xdd85, 0x11d2, 0xb4, 0x3e, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde };

const GUID GUID_Segment_BandTrackChange = { 0x9b3f0be0, 0xedff, 0x11d2, 0xb4, 0x3f, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde };

const GUID GUID_TimelineShowTimeSig = { 0xf811ce10, 0x42a1, 0x11d2, 0x89, 0xb, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 };

const GUID GUID_TimelineShowRealTime = { 0x9f879f8a, 0xfda3, 0x11d2, 0xa6, 0xf8, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_TimelineSetSegStartTime = { 0x3e2c8b0, 0xc2f4, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

const GUID GUID_TimelineSetCursor = { 0xcb715b92, 0xc549, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Debug.cpp ===
#include "stdafx.h"

#ifdef _PSEUDO_DEBUG   // entire file

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LONG AssertBusy = -1;
LONG AssertReallyBusy = -1;

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
	TCHAR szMessage[_MAX_PATH*2];

	InterlockedDecrement(&AssertReallyBusy);

	// format message into buffer
	wsprintf(szMessage, _T("File %hs, Line %d"),
		lpszFileName, nLine);

	TCHAR szT[_MAX_PATH*2 + 20];
	wsprintf(szT, _T("Assertion Failed: %s\n"), szMessage);
	OutputDebugString(szT);

	if (InterlockedIncrement(&AssertBusy) > 0)
	{
		InterlockedDecrement(&AssertBusy);

		// assert within assert (examine call stack to determine first one)
		DebugBreak();
		return FALSE;
	}

	// active popup window for the current thread
	HWND hWndParent = GetActiveWindow();
	if (hWndParent != NULL)
		hWndParent = GetLastActivePopup(hWndParent);

	// display the assert
	int nCode = ::MessageBox(hWndParent, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

	// cleanup
	InterlockedDecrement(&AssertBusy);

	if (nCode == IDIGNORE)
		return FALSE;   // ignore

	if (nCode == IDRETRY)
		return TRUE;    // will cause DebugBreak

	AfxAbort();     // should not return (but otherwise DebugBreak)
	return TRUE;
}

void Trace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf(szBuffer, lpszFormat, args);
	ASSERT(nBuf < (sizeof(szBuffer)/sizeof(szBuffer[0])));

	CString strMessage;

	if (AfxGetApp() != NULL)
		strMessage = ((CString) (AfxGetApp()->m_pszExeName)) + _T(": ");
	strMessage += szBuffer;
	OutputDebugString(strMessage);

	va_end(args);
}


#endif // _PSEUDO_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	again.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\libsrc\TimelineGUID.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IDMUSProdTimelineDataObject = {0xD7D8A772,0x3171,0x11d2,{0x89,0x00,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};

const IID IID_IDMUSProdTimeline = {0x22B5869D,0x523E,0x11d2,{0x89,0x13,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};

const CLSID CLSID_TimelineCtl = {0xDB838A7C,0xB4F5,0x11D0,{0xA9,0x7F,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};

const IID IID_IDMUSProdTimelineCallback = {0x8FE7E6D5,0xF331,0x11d0,{0xBC,0x09,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};

const IID IID_IDMUSProdTimelineEdit = {0x8640F4B2,0x2B01,0x11d2,{0x88,0xF9,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};

const IID IID_IDMUSProdStrip = {0x893EE17A,0x04A3,0x11d3,{0x89,0x4C,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};

const IID IID_IDMUSProdStripFunctionBar = {0x86D596CC,0xB302,0x11d1,{0x88,0x8F,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};

const IID IID_IDMUSProdStripMgr = {0x893EE17B,0x04A3,0x11d3,{0x89,0x4C,0x00,0xC0,0x4F,0xBF,0x8D,0x15}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by StripWizard.rc
//

#define IDI_STRIPWIZARD               1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                1
#define _APS_NEXT_RESOURCE_VALUE        117
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\StdAfx.h ===
#if !defined(AFX_STDAFX_H__C6FADD41_41F2_4223_AA78_CE41501FDD89__INCLUDED_)
#define AFX_STDAFX_H__C6FADD41_41F2_4223_AA78_CE41501FDD89__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#include "debug.h"			// For ASSERT, VERIFY, and TRACE
#include <customaw.h>		// Custom AppWizard interface

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C6FADD41_41F2_4223_AA78_CE41501FDD89__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\StripWizardAw.cpp ===
// StripWizardaw.cpp : implementation file
//

#include "stdafx.h"
#include "StripWizard.h"
#include "StripWizardaw.h"

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This is called immediately after the custom AppWizard is loaded.  Initialize
//  the state of the custom AppWizard here.
void CStripWizardAppWiz::InitCustomAppWiz()
{
	// There are no steps in this custom AppWizard.
	SetNumberOfSteps(0);

	// Add build step to .hpj if there is one
	m_Dictionary[_T("HELP")] = _T("1");

	// Inform AppWizard that we're making a DLL.
	m_Dictionary[_T("PROJTYPE_DLL")] = _T("1");

	// TODO: Add any other custom AppWizard-wide initialization here.
}

// This is called just before the custom AppWizard is unloaded.
void CStripWizardAppWiz::ExitCustomAppWiz()
{
	// TODO: Add code here to deallocate resources used by the custom AppWizard
}

// This is called when the user clicks "Create..." on the New Project dialog
CAppWizStepDlg* CStripWizardAppWiz::Next(CAppWizStepDlg* pDlg)
{
	ASSERT(pDlg == NULL);	// By default, this custom AppWizard has no steps

	// Set template macros based on the project name entered by the user.

	// Get value of $$root$$ (already set by AppWizard)
	CString strRoot;
	m_Dictionary.Lookup(_T("root"), strRoot);
	
	// Set value of $$Doc$$, $$DOC$$
	CString strDoc = strRoot.Left(6);
	m_Dictionary[_T("Doc")] = strDoc;
	strDoc.MakeUpper();
	m_Dictionary[_T("DOC")] = strDoc;

	// Set value of $$MAC_TYPE$$
	strRoot = strRoot.Left(4);
	int nLen = strRoot.GetLength();
	if (strRoot.GetLength() < 4)
	{
		CString strPad(_T(' '), 4 - nLen);
		strRoot += strPad;
	}
	strRoot.MakeUpper();
	m_Dictionary[_T("MAC_TYPE")] = strRoot;

	// Generate GUIDs for the different interfaces/tracks/libraries/classes
	GUID guidLibrary, clsidTrack, guidInterface, clsidStripMgr;
	if( SUCCEEDED( CoCreateGuid( &guidLibrary ) ) 
	&&	SUCCEEDED( CoCreateGuid( &clsidTrack ) )
	&&	SUCCEEDED( CoCreateGuid( &guidInterface ) )
	&&	SUCCEEDED( CoCreateGuid( &clsidStripMgr ) ))
	{
		CString strGuid;
		strGuid.Format( _T("%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X"),		
			guidLibrary.Data1, guidLibrary.Data2, guidLibrary.Data3,
			guidLibrary.Data4[0], guidLibrary.Data4[1], guidLibrary.Data4[2], guidLibrary.Data4[3],
			guidLibrary.Data4[4], guidLibrary.Data4[5], guidLibrary.Data4[6], guidLibrary.Data4[7]);
		m_Dictionary[_T("LIBRARY_GUID")] = strGuid;

		strGuid.Format( _T("0x%lx, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"),		
			clsidTrack.Data1, clsidTrack.Data2, clsidTrack.Data3,
			clsidTrack.Data4[0], clsidTrack.Data4[1], clsidTrack.Data4[2], clsidTrack.Data4[3],
			clsidTrack.Data4[4], clsidTrack.Data4[5], clsidTrack.Data4[6], clsidTrack.Data4[7]);
		m_Dictionary[_T("TRACK_CLSID")] = strGuid;

		strGuid.Format( _T("%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X"),		
			guidInterface.Data1, guidInterface.Data2, guidInterface.Data3,
			guidInterface.Data4[0], guidInterface.Data4[1], guidInterface.Data4[2], guidInterface.Data4[3],
			guidInterface.Data4[4], guidInterface.Data4[5], guidInterface.Data4[6], guidInterface.Data4[7]);
		m_Dictionary[_T("INTERFACE_GUID")] = strGuid;

		strGuid.Format( _T("%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X"),		
			clsidStripMgr.Data1, clsidStripMgr.Data2, clsidStripMgr.Data3,
			clsidStripMgr.Data4[0], clsidStripMgr.Data4[1], clsidStripMgr.Data4[2], clsidStripMgr.Data4[3],
			clsidStripMgr.Data4[4], clsidStripMgr.Data4[5], clsidStripMgr.Data4[6], clsidStripMgr.Data4[7]);
		m_Dictionary[_T("STRIPMGR_CLSID")] = strGuid;
	}

	// Return NULL to indicate there are no more steps.  (In this case, there are
	//  no steps at all.)
	return NULL;
}

void CStripWizardAppWiz::CustomizeProject(IBuildProject* pProject)
{
	// TODO: Add code here to customize the project.  If you don't wish
	//  to customize project, you may remove this virtual override.
	
	// This is called immediately after the default Debug and Release
	//  configurations have been created for each platform.  You may customize
	//  existing configurations on this project by using the methods
	//  of IBuildProject and IConfiguration such as AddToolSettings,
	//  RemoveToolSettings, and AddCustomBuildStep. These are documented in
	//  the Developer Studio object model documentation.

	// WARNING!!  IBuildProject and all interfaces you can get from it are OLE
	//  COM interfaces.  You must be careful to release all new interfaces
	//  you acquire.  In accordance with the standard rules of COM, you must
	//  NOT release pProject, unless you explicitly AddRef it, since pProject
	//  is passed as an "in" parameter to this function.  See the documentation
	//  on CCustomAppWiz::CustomizeProject for more information.

	// Add shared files
	VARIANT varReserved = {0, 0, 0, 0};
	CString strFileName = _T("..\\shared\\BaseMgr.cpp");
	pProject->AddFile( strFileName.AllocSysString(), varReserved );
	strFileName = _T("..\\shared\\BasePropPageManager.cpp");
	pProject->AddFile( strFileName.AllocSysString(), varReserved );
	strFileName = _T("..\\shared\\BaseStrip.cpp");
	pProject->AddFile( strFileName.AllocSysString(), varReserved );
	strFileName = _T("..\\shared\\GroupBitsPPG.cpp");
	pProject->AddFile( strFileName.AllocSysString(), varReserved );
	strFileName = _T("..\\shared\\RiffStrm.cpp");
	pProject->AddFile( strFileName.AllocSysString(), varReserved );
	strFileName = _T("..\\shared\\SelectedRegion.cpp");
	pProject->AddFile( strFileName.AllocSysString(), varReserved );
	strFileName = _T("..\\shared\\StaticPropPageManager.cpp");
	pProject->AddFile( strFileName.AllocSysString(), varReserved );

	IConfigurations *pConfigurations;
	if( SUCCEEDED( pProject->get_Configurations( &pConfigurations ) ) )
	{
		IConfiguration *pIConfiguration;
		VARIANT varIndex;
		varIndex.vt = VT_I4;
		V_I4( &varIndex ) = 1;

		while( SUCCEEDED( pConfigurations->Item( varIndex, &pIConfiguration ) ) )
		{
			// Add linker settings
			strFileName = _T("link.exe");
			CString strSettings = _T("DMUSProdGUID.lib TimelineGUID.lib SegmentDesignerGUID.lib dxguid.lib /libpath:\"..\\lib\"");
			pIConfiguration->AddToolSettings( strFileName.AllocSysString(), strSettings.AllocSysString(), varReserved );

			// Add compiler settings
			strFileName = _T("cl.exe");
			strSettings = _T("/I \"..\\include\" /I \"..\\shared\" /I \".\"");
			pIConfiguration->AddToolSettings( strFileName.AllocSysString(), strSettings.AllocSysString(), varReserved );


			// Get value of $$Safe_root$$ (already set by AppWizard)
			CString strSafeRoot;
			m_Dictionary.Lookup(_T("Safe_root"), strSafeRoot);

			strFileName = strSafeRoot + _T("StripMgr.idl");

			strSettings.Format(_T("/tlb \"%sStripMgr.tlb\" /h \"%sStripMgr.h\""), strSafeRoot, strSafeRoot);

			// Add .idl settings
			pIConfiguration->AddFileSettings( strFileName.AllocSysString(), strSettings.AllocSysString(), varReserved );

			// Add DLL registration step
			CString strDescription = _T("Registering DLL...");
			strFileName = _T("$(OutDir)\\regsvr.tmp");
			strSettings = _T("regsvr32 /s /c \"$(TargetPath)\" > $(OutDir)\\regsvr.tmp");
			pIConfiguration->AddCustomBuildStep( strSettings.AllocSysString(), strFileName.AllocSysString(), strDescription.AllocSysString(), varReserved );

			pIConfiguration->Release();
			V_I4( &varIndex)++;
		}
		pConfigurations->Release();
	}
}


// Here we define one instance of the CStripWizardAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global StripWizardaw.
CStripWizardAppWiz StripWizardaw;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\StripWizard.cpp ===
// StripWizard.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>
#include "StripWizard.h"
#include "StripWizardaw.h"

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE StripWizardDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("STRIPWIZARD.AWX Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(StripWizardDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(StripWizardDLL);

		// Register this custom AppWizard with MFCAPWZ.DLL
		SetCustomAppWizClass(&StripWizardaw);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("STRIPWIZARD.AWX Terminating!\n");

		// Terminate the library before destructors are called
		AfxTermExtensionModule(StripWizardDLL);
	}
	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\StripWizard.h ===
#if !defined(AFX_STRIPWIZARD_H__5C49A3D7_B87E_4D68_B461_606077B56476__INCLUDED_)
#define AFX_STRIPWIZARD_H__5C49A3D7_B87E_4D68_B461_606077B56476__INCLUDED_

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

// TODO: You may add any other custom AppWizard-wide declarations here.


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STRIPWIZARD_H__5C49A3D7_B87E_4D68_B461_606077B56476__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\StripWizardAw.h ===
#if !defined(AFX_STRIPWIZARDAW_H__EE6B614A_1416_4F02_A5FA_2515EEB789C6__INCLUDED_)
#define AFX_STRIPWIZARDAW_H__EE6B614A_1416_4F02_A5FA_2515EEB789C6__INCLUDED_

// StripWizardaw.h : header file
//

class CDialogChooser;

// All function calls made by mfcapwz.dll to this custom AppWizard (except for
//  GetCustomAppWizClass-- see StripWizard.cpp) are through this class.  You may
//  choose to override more of the CCustomAppWiz virtual functions here to
//  further specialize the behavior of this custom AppWizard.
class CStripWizardAppWiz : public CCustomAppWiz
{
public:
	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
		
	virtual void InitCustomAppWiz();
	virtual void ExitCustomAppWiz();
	virtual void CustomizeProject(IBuildProject* pProject);
};

// This declares the one instance of the CStripWizardAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global StripWizardaw.  (Its definition is in StripWizardaw.cpp.)
extern CStripWizardAppWiz StripWizardaw;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STRIPWIZARDAW_H__EE6B614A_1416_4F02_A5FA_2515EEB789C6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\LyricItem.cpp ===
#include "stdafx.h"
#include "$$Safe_root$$Item.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

C$$Safe_root$$Item::C$$Safe_root$$Item()
{
	Clear();
}

C$$Safe_root$$Item::C$$Safe_root$$Item(const C$$Safe_root$$Item& item)
{
	// Copy the passed-in item
	Copy( &item );
}

void C$$Safe_root$$Item::Clear()
{
	m_lMeasure = 0;
	m_lBeat = 0;
	m_strText.Empty();
	m_dwBits = 0;
	m_fSelected = FALSE;
}

void C$$Safe_root$$Item::Copy( const C$$Safe_root$$Item* pItem )
{
	ASSERT( pItem != NULL );
	if ( pItem == NULL )
	{
		return;
	}

	if( pItem == this )
	{
		return;
	}

	m_lMeasure = pItem->m_lMeasure;
	m_lBeat = pItem->m_lBeat;
	m_strText = pItem->m_strText;
	m_dwBits = pItem->m_dwBits;
	m_fSelected = pItem->m_fSelected;
}

BOOL C$$Safe_root$$Item::After(const C$$Safe_root$$Item& item)
{
	// Check if this item is after the one passed in.

	// Check if our measure number is greater.
	if( m_lMeasure > item.m_lMeasure )
	{
		// Our measure number is greater - we're after the item
		return TRUE;
	}
	// Check if our measure number is equal
	else if( m_lMeasure == item.m_lMeasure )
	{
		// Check if our beat number is greater
		if( m_lBeat > item.m_lBeat )
		{
			// Our beat number is greater - we're after the item
			return TRUE;
		}
	}

	// We're either before the item, or on the same beat.
	return FALSE;
}

BOOL C$$Safe_root$$Item::Before(const C$$Safe_root$$Item& item)
{
	// Check if this lyric is before the one passed in.

	// Check if our measure number is lesser.
	if( m_lMeasure < item.m_lMeasure )
	{
		// Our measure number is lesser - we're before the item
		return TRUE;
	}
	// Check if our measure number is equal.
	else if( m_lMeasure == item.m_lMeasure )
	{
		// Check if our measure number is lesser.
		if( m_lBeat < item.m_lBeat )
		{
			// Our measure number is lesser - we're before the item
			return TRUE;
		}
	}

	// We're either after the item, or on the same beat.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\LyricMgr.cpp ===
// $$Safe_root$$Mgr.cpp : implementation file
//

/*--------------
@doc $$SAFE_ROOT$$SAMPLE
--------------*/

#include "stdafx.h"
#include "$$Safe_root$$Mgr.h"
#include "PropPageMgr.h"
#include <RiffStrm.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Set information about this strip manager
const CLSID C$$Safe_root$$Mgr::m_clsid = CLSID_$$Safe_root$$Track;
const DWORD C$$Safe_root$$Mgr::m_ckid = NULL;
const DWORD C$$Safe_root$$Mgr::m_fccType = FOURCC_$$SAFE_ROOT$$_LIST;

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr constructor/destructor 

C$$Safe_root$$Mgr::C$$Safe_root$$Mgr() : CBaseMgr()
{
	// Create a $$Safe_root$$Strip
	m_p$$Safe_root$$Strip = new C$$Safe_root$$Strip(this);
	ASSERT( m_p$$Safe_root$$Strip );

	// Copy the pointer to the base strip manager
	m_pBaseStrip = m_p$$Safe_root$$Strip;
}

C$$Safe_root$$Mgr::~C$$Safe_root$$Mgr()
{
	// Clean up our references
	if( m_p$$Safe_root$$Strip )
	{
		m_p$$Safe_root$$Strip->Release();
		m_p$$Safe_root$$Strip = NULL;
	}

	// Clear the base strip manager's pointer to the strip
	m_pBaseStrip = NULL;

	// Delete all the items in m_lst$$Safe_root$$s
	Empty$$Safe_root$$List( m_lst$$Safe_root$$s );
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr I$$Safe_root$$Mgr implementation

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::IsMeasureBeatOpen
// Returns S_OK if the specified measure and beat is empty.
// Returns S_FALSE if the specified measure and beat already has an item

HRESULT STDMETHODCALLTYPE C$$Safe_root$$Mgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item;
		p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

		// Since the list is sorted, if this item is later than the specified time, we can exit
		if( p$$Safe_root$$Item->m_lMeasure > lMeasure )
		{
			// The measure and beat are empty
			return S_OK;
		}
		// Check if the measure and beat values match
		else if( p$$Safe_root$$Item->m_lMeasure == lMeasure &&
				 p$$Safe_root$$Item->m_lBeat == lBeat )
		{
			// They match - return that the measure and beat are already occupied
			return S_FALSE;
		}
	}

	// The measure and beat are empty
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::Load

HRESULT C$$Safe_root$$Mgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing items
	Empty$$Safe_root$$List( m_lst$$Safe_root$$s );

	// Variables used when loading the $$Safe_root$$ track
	MMCKINFO	ckList;
	MMCKINFO	ck;
	DWORD		dwByteCount;
	DMUS_IO_$$SAFE_ROOT$$ i$$Safe_root$$;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case FOURCC_LIST:
			// Only look into LIST chunks
			switch( ck.fccType )
			{
			case FOURCC_$$SAFE_ROOT$$_LIST:
				// Found the $$Safe_root$$ list chunk - descend into it
				while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
				{
					switch( ckList.ckid )
					{
					case FOURCC_$$SAFE_ROOT$$_ITEM:
						// Found the $$Safe_root$$ item chunk - read it
						{
							// Read in a $$Safe_root$$ item structure
							hr = pIStream->Read( &i$$Safe_root$$, sizeof(DMUS_IO_$$SAFE_ROOT$$), &dwByteCount );

							// Handle any I/O error by returning a failure code
							if( FAILED( hr ) || dwByteCount != sizeof(DMUS_IO_$$SAFE_ROOT$$) )
							{
								hr = E_FAIL;
								goto ON_ERROR;
							}

							// Create a new item
							C$$Safe_root$$Item* pItem = new C$$Safe_root$$Item;

							// Double-check that the memory was allocated
							if ( pItem == NULL )
							{
								hr = E_OUTOFMEMORY;
								goto ON_ERROR;
							}

							// Read the text from the stream into pItem->m_strText
							ReadMBSfromWCS( pIStream, i$$Safe_root$$.dwLength, &pItem->m_strText );

							// Initialize the measure and beat members of the C$$Safe_root$$Item
							pItem->m_lMeasure = i$$Safe_root$$.dwMeasure;
							pItem->m_lBeat = i$$Safe_root$$.bBeat;

							// Insert the item into the list, if one is not already there
							if( IsMeasureBeatOpen( pItem->m_lMeasure, pItem->m_lBeat ) == S_OK )
							{
								// Nothing exists in the beat, go ahead and insert the item
								InsertByAscendingTime( pItem );
							}
							else
							{
								// Something already exists, delete the item and don't insert it
								delete pItem;
							}
						}
						break;
					}

					// Ascend out of the chunk in the $$Safe_root$$ list chunk
					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;
			}
		}

		// Ascend out of the main chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	// Release the RIFF stream pointer
	pIRiffStream->Release();

	// Return the success/failure status
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::Save

HRESULT C$$Safe_root$$Mgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic $$Safe_root$$ track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the $$Safe_root$$ list isn't empty, save it
	if ( !m_lst$$Safe_root$$s.IsEmpty() )
	{
		// Create a LIST chunk to store the $$Safe_root$$ data
		MMCKINFO ckMain;
		ckMain.fccType = FOURCC_$$SAFE_ROOT$$_LIST;
		if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the $$Safe_root$$ list
		POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			C$$Safe_root$$Item* p$$Safe_root$$Item;
			p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

			// Create a chunk to store the item in
			MMCKINFO ck;
			ck.ckid = FOURCC_$$SAFE_ROOT$$_ITEM;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				// If unable to create the chunk, return E_FAIL
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Convert the Measure and Beat of each item to a MusicTime value
			MUSIC_TIME mtTime;
			if( (m_pTimeline == NULL) || FAILED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, &mtTime ) ) )
			{
				// This shouldn't happen, but if it does, just set the time to 0
				mtTime = 0;
			}

			// Clear out the structure (clears out the padding bytes as well).
			DMUS_IO_$$SAFE_ROOT$$ o$$Safe_root$$;
			ZeroMemory( &o$$Safe_root$$, sizeof(DMUS_IO_$$SAFE_ROOT$$) );

			// Fill in the members of the DMUS_IO_$$SAFE_ROOT$$ structure
			o$$Safe_root$$.mtTime = mtTime;
			o$$Safe_root$$.dwMeasure = p$$Safe_root$$Item->m_lMeasure;
			o$$Safe_root$$.bBeat = BYTE( min(p$$Safe_root$$Item->m_lBeat, 255) ); // Ensure the beat value doesn't overflow
			o$$Safe_root$$.dwLength = p$$Safe_root$$Item->m_strText.GetLength() + 1;
			o$$Safe_root$$.dwLength *= sizeof(wchar_t);

			// Write the structure out to the stream
			DWORD dwBytesWritten;
			hr = pIStream->Write( &o$$Safe_root$$, sizeof(DMUS_IO_$$SAFE_ROOT$$), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_$$SAFE_ROOT$$) )
			{
				// Handle I/O errors by return an error code
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write out the $$Safe_root$$ text as a Wide Character String
			hr = SaveMBStoWCS( pIStream, &p$$Safe_root$$Item->m_strText );
			if( FAILED( hr ) )
			{
				// Handle I/O errors by return an error code
				goto ON_ERROR;
			}

			// Ascend out of the $$Safe_root$$ chunk.
			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				// Handle I/O errors by return an error code
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
		// Ascend out of the $$Safe_root$$ LIST chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
	}

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( fClearDirty )
	{
		m_fDirty = false;
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::GetData

// This method is called by C$$Safe_root$$PropPageMgr to get data to send to the
// $$Safe_root$$ property page.
// The C$$Safe_root$$Strip::GetData() method is called by CGroupBitsPropPageMgr
// to get the strip's properties (currently just Group Bits)
HRESULT STDMETHODCALLTYPE C$$Safe_root$$Mgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the ppData pointer
	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Flag set to TRUE if more than one item is selected
	BOOL fMultipleSelect = FALSE;

	// Initialize the pointer to the first selected item to NULL
	C$$Safe_root$$Item* pFirstSelected$$Safe_root$$Item = NULL;

	// Start iterating through the item list
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item;
		p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

		// Check if the item is selected
		if ( p$$Safe_root$$Item->m_fSelected )
		{
			// $$Safe_root$$ is selected - save a pointer to it in pFirstSelected$$Safe_root$$Item
			pFirstSelected$$Safe_root$$Item = p$$Safe_root$$Item;

			// Now, continue through the list to see if any other items are selected
			while( pos )
			{
				// Get a pointer to each item
				p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

				// Check if the item is selected
				if ( p$$Safe_root$$Item->m_fSelected )
				{
					// More than one item is selected - set fMultipleSelect to TRUE
					// and break out of this loop
					fMultipleSelect = TRUE;
					break;
				}
			}

			// Found a selected item - break out of the main while loop
			break;
		}
	}

	// If at least one item is selected
	if( pFirstSelected$$Safe_root$$Item )
	{
		// Copy the first selected item to a C$$Safe_root$$Item class
		m_Selected$$Safe_root$$Item.Copy( pFirstSelected$$Safe_root$$Item );

		// If more than one item was selected, set UD_MULTIPLESELECT
		if( fMultipleSelect )
		{
			m_Selected$$Safe_root$$Item.m_dwBits |= UD_MULTIPLESELECT;
		}
		else
		{
			// Only one item selected, clear UD_MULTIPLESELECT
			m_Selected$$Safe_root$$Item.m_dwBits &= ~UD_MULTIPLESELECT;
		}

		// Set the passed in pointer to point to the C$$Safe_root$$Item class
		*ppData = &m_Selected$$Safe_root$$Item;

		// Return a success code
		return S_OK;
	}

	// Nothing selected, so clear the passed in pointer
	*ppData = NULL;

	// Return a success code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::SetData

// This method is called by C$$Safe_root$$PropPageMgr in response to user actions
// in the $$Safe_root$$ Property page.  It changes the currenly selected $$Safe_root$$. 
HRESULT STDMETHODCALLTYPE C$$Safe_root$$Mgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the pData pointer
	if ( pData == NULL )
	{
		return E_POINTER;
	}

	// Get a pointer to the first selected item.
	C$$Safe_root$$Item* p$$Safe_root$$Item = FirstSelected$$Safe_root$$();

	// If a selected item was found
	if ( p$$Safe_root$$Item )
	{
		// Convert the passed-in pointer to a C$$Safe_root$$Item*
		C$$Safe_root$$Item* pNew$$Safe_root$$ = static_cast<C$$Safe_root$$Item*>(pData);

		// Check to see if the time position of the item changed
		if( (pNew$$Safe_root$$->m_lBeat != p$$Safe_root$$Item->m_lBeat) ||
			(pNew$$Safe_root$$->m_lMeasure != p$$Safe_root$$Item->m_lMeasure) )
		{
			// Update measure and beat position
			p$$Safe_root$$Item->m_lBeat = pNew$$Safe_root$$->m_lBeat;
			p$$Safe_root$$Item->m_lMeasure = pNew$$Safe_root$$->m_lMeasure;

			// Convert measure and beat position to a time value
			MUSIC_TIME mtTime;
			if( SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0,
								pNew$$Safe_root$$->m_lMeasure, pNew$$Safe_root$$->m_lBeat, &mtTime ) ) )
			{
				// Get the length of the segment
				VARIANT varLength;
				m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength );

				// Ensure the item doesn't move past the end of the segment
				mtTime = min( mtTime, V_I4(&varLength) - 1 );

				// Convert time value to a measure and beat position
				long lBeat, lMeasure;
				if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0,
								mtTime, &lMeasure, &lBeat ) ) )
				{
					if( lMeasure < 0 )
					{
						// If the measure is negative, set the measure and beat #s to 0
						p$$Safe_root$$Item->m_lMeasure = 0;
						p$$Safe_root$$Item->m_lBeat = 0;
					}
					else
					{
						// Check that the beat value is valid
						ASSERT( lBeat <= UCHAR_MAX );

						// Set the Measure and beat values
						p$$Safe_root$$Item->m_lBeat = BYTE(lBeat);
						p$$Safe_root$$Item->m_lMeasure = lMeasure;
					}
				}
			}

			// We just moved the item
			m_nLastEdit = IDS_UNDO_MOVE;

			// Remove the $$Safe_root$$Item from the list
			C$$Safe_root$$Item* p$$Safe_root$$Tmp;
			POSITION pos2, pos1 = m_lst$$Safe_root$$s.GetHeadPosition();
			while( pos1 )
			{
				pos2 = pos1;
				p$$Safe_root$$Tmp = m_lst$$Safe_root$$s.GetNext( pos1 );
				if ( p$$Safe_root$$Tmp == p$$Safe_root$$Item )
				{
					m_lst$$Safe_root$$s.RemoveAt( pos2 );
					break;
				}
			}

			// Re-add the item at its new position - this will overwrite any existing
			// item at this position
			InsertByAscendingTime( p$$Safe_root$$Item );

			// Clear all selections
			m_p$$Safe_root$$Strip->m_pSelectedRegions->Clear();

			// Select just the changed item
			CListSelectedRegion_AddRegion(*m_p$$Safe_root$$Strip->m_pSelectedRegions, *p$$Safe_root$$Item);

		}

		// Check to see if the text of the item changed
		else if( pNew$$Safe_root$$->m_strText != p$$Safe_root$$Item->m_strText )
		{
			// Update the item's text
			p$$Safe_root$$Item->m_strText = pNew$$Safe_root$$->m_strText;

			// We just changed the item
			m_nLastEdit = IDS_UNDO_CHANGE;
		}

		// Nothing changed
		else
		{
			// Return a success code saying that nothing happened
			return S_FALSE;
		}

		// Redraw the $$Safe_root$$ strip
		m_pTimeline->StripInvalidateRect( m_p$$Safe_root$$Strip, NULL, TRUE );

		// Let our hosting editor know about the changes
		OnDataChanged();

		// Refresh the property page with new values
		m_pPropPageMgr->RefreshData();

		return S_OK;
	}
	// No items selected - nothing to change
	else
	{
		// Return a success code saying that nothing happened
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::OnShowProperties

HRESULT STDMETHODCALLTYPE C$$Safe_root$$Mgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new $$Safe_root$$ property page manager
		C$$Safe_root$$PropPageMgr* pPPM = new C$$Safe_root$$PropPageMgr;

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Return a success code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr implementation

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::DeleteSelected$$Safe_root$$s

void C$$Safe_root$$Mgr::DeleteSelected$$Safe_root$$s()
{
	// Start iterating through the list of items
	POSITION pos1 = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos1 );

		// Check if the current item is selected
		if ( p$$Safe_root$$Item->m_fSelected )
		{
			// This item is selected, remove it from the list
			m_lst$$Safe_root$$s.RemoveAt( pos2 );

			// Now, delete this item
			delete p$$Safe_root$$Item;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::SaveSelected$$Safe_root$$s

HRESULT C$$Safe_root$$Mgr::SaveSelected$$Safe_root$$s(LPSTREAM pIStream, C$$Safe_root$$Item* p$$Safe_root$$AtDragPoint)
{
	// if p$$Safe_root$$AtDragPoint is valid, set mtOffset and dwMeasureOffset so that the time p$$Safe_root$$AtDragPoint is 0.
	// if p$$Safe_root$$AtDragPoint is NULL, set mtOffset and dwMeasureOffset so that the time of the first $$Safe_root$$ is 0.

	// Verify pIStream is valid
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// If the $$Safe_root$$ list has anything in it, look for selected $$Safe_root$$s
	if ( !m_lst$$Safe_root$$s.IsEmpty() )
	{
		// Initialize the beat offset to an invalid value
		long lBeatOffset = -1;

		// If p$$Safe_root$$AtDragPoint is valid, just use the measure and beat information from it
		if( p$$Safe_root$$AtDragPoint )
		{
			// Verify that this item is selected
			ASSERT( p$$Safe_root$$AtDragPoint->m_fSelected );

			// Compute how many beats from the start it is
			MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, p$$Safe_root$$AtDragPoint->m_lMeasure, p$$Safe_root$$AtDragPoint->m_lBeat, lBeatOffset );
		}
		// Otherwise look for the first selected item
		else
		{
			POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
			while( pos )
			{
				C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );
				if ( p$$Safe_root$$Item->m_fSelected )
				{
					// Found a selected item - compute how many beats from the start it is
					MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, lBeatOffset );
					break;
				}
			}
		}

		// p$$Safe_root$$AtDragPoint is NULL and there are no selected items - return with S_FALSE
		if ( lBeatOffset == -1 )
		{
			return S_FALSE;
		}

		// Now, actually save the items
		return SaveSelected$$Safe_root$$s( pIStream, lBeatOffset );
	}
	else
	{
		return S_FALSE; // Nothing in the list
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::MarkSelected$$Safe_root$$s

// ORs dwFlags with the m_dwBits of each selected item
void C$$Safe_root$$Mgr::MarkSelected$$Safe_root$$s( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

		// Check if the item is selected
		if ( p$$Safe_root$$Item->m_fSelected )
		{
			// It's selected - update m_dwBits
			p$$Safe_root$$Item->m_dwBits |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::DeleteMarked

// deletes items marked by given flag
void C$$Safe_root$$Mgr::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos1 = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this item
		if ( p$$Safe_root$$Item->m_dwBits & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the item
			m_lst$$Safe_root$$s.RemoveAt( pos2 );

			// Now, delete it
			delete p$$Safe_root$$Item;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::UnMark$$Safe_root$$s

// unmarks flag m_dwUndermined field C$$Safe_root$$Items in list
void C$$Safe_root$$Mgr::UnMark$$Safe_root$$s( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each item
		m_lst$$Safe_root$$s.GetNext( pos )->m_dwBits &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::UnselectAll

void C$$Safe_root$$Mgr::UnselectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each item
		m_lst$$Safe_root$$s.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_p$$Safe_root$$Strip->m_pSelectedRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::SelectAll

void C$$Safe_root$$Mgr::SelectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Set the selection flag for each item
		m_lst$$Safe_root$$s.GetNext( pos )->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::IsSelected

bool C$$Safe_root$$Mgr::IsSelected()
{
	// If anything is selected, return true
	
	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Check if this item is selected
		if ( m_lst$$Safe_root$$s.GetNext( pos )->m_fSelected )
		{
			// $$Safe_root$$ is selected - return true
			return true;
		}
	}

	// No items selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::IsEmpty

bool C$$Safe_root$$Mgr::IsEmpty()
{
	return m_lst$$Safe_root$$s.IsEmpty() ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::FirstSelected$$Safe_root$$

C$$Safe_root$$Item* C$$Safe_root$$Mgr::FirstSelected$$Safe_root$$()
{
	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

		// Check if the item is selected
		if ( p$$Safe_root$$Item->m_fSelected )
		{
			// $$Safe_root$$ is selected, return a pointer to it
			return p$$Safe_root$$Item;
		}
	}

	// No items are selected, return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::SelectSegment

// Return true if anything changed
bool C$$Safe_root$$Mgr::SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime)
{
	// Verify that we have a pointer to the Timeline
	if( !m_pTimeline )
	{
		ASSERT(FALSE);
		return false;
	}

	// Convert the start position from clocks to a measure and beat value
	long lMeasure, lBeat;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0,
									  mtBeginTime, &lMeasure, &lBeat );

	
	// Convert back to a clock value
	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0,
									  lMeasure, lBeat, &mtBeginTime );

	// Convert the end position from clocks to a measure and beat value
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0,
									  mtEndTime, &lMeasure, &lBeat );

	
	// Increment the beat so the last beat is selected
	lBeat++;

	// Convert back to a clock value
	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0,
									  lMeasure, lBeat, &mtEndTime );

	// Convert the passed in times to a generic time class
	CMusicTimeConverter cmtBeg(mtBeginTime);
	CMusicTimeConverter cmtEnd(mtEndTime);

	// Create a region that contains the selected time
	CSelectedRegion region(cmtBeg, cmtEnd);

	// Add the region to the list of selected regions
	m_p$$Safe_root$$Strip->m_pSelectedRegions->AddRegion(region);

	// Select all items in the list of selected regions
	// This will return true if the selection state of any item changed
	return m_p$$Safe_root$$Strip->SelectItemsInSelectedRegions();
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::InsertByAscendingTime

void C$$Safe_root$$Mgr::InsertByAscendingTime( C$$Safe_root$$Item *p$$Safe_root$$ToInsert )
{
	// Ensure the p$$Safe_root$$ToInsert pointer is valid
	if ( p$$Safe_root$$ToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Iterate through the list of items
	POSITION pos1 = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos1 );

		// Check if the current item is in the same measure as the one to be inserted
		if ( p$$Safe_root$$Item->m_lMeasure == p$$Safe_root$$ToInsert->m_lMeasure )
		{
			//  Check if the current item is in the same beat or later than the one to be inserted
			if ( p$$Safe_root$$Item->m_lBeat >= p$$Safe_root$$ToInsert->m_lBeat )
			{
				// insert before pos2 (current position of p$$Safe_root$$Item)
				m_lst$$Safe_root$$s.InsertBefore( pos2, p$$Safe_root$$ToInsert );

				// If we've overwritten an existing $$Safe_root$$, remove and delete the existing item
				if( p$$Safe_root$$Item->m_lBeat == p$$Safe_root$$ToInsert->m_lBeat )
				{
					m_lst$$Safe_root$$s.RemoveAt( pos2 );
					delete p$$Safe_root$$Item;
				}

				// Return, since we found the position to insert the item in
				return;
			}
		}

		// Check if the current item is later than the one to be inserted
		if ( p$$Safe_root$$Item->m_lMeasure > p$$Safe_root$$ToInsert->m_lMeasure )
		{
			// insert before pos2 (current position of p$$Safe_root$$Item)
			m_lst$$Safe_root$$s.InsertBefore( pos2, p$$Safe_root$$ToInsert );

			// Return, since we found the position to insert the item in
			return;
		}
	}

	// p$$Safe_root$$ToInsert is later than all items in the list, add it at the end of the list
	m_lst$$Safe_root$$s.AddTail( p$$Safe_root$$ToInsert );

	// Return, since we found the position to insert the item in
	return;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::RemoveItem

bool C$$Safe_root$$Mgr::RemoveItem( C$$Safe_root$$Item* pItem )
{
	// Find the given item
	POSITION posToRemove = m_lst$$Safe_root$$s.Find( pItem, NULL );

	// If item wasn't found, return false
	if( posToRemove == NULL )
	{
		return false;
	}

	// Remove the item from the list - the caller must delete it
	m_lst$$Safe_root$$s.RemoveAt( posToRemove );

	// Return true since we found the item
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::GetNextGreatestUniqueTime

bool C$$Safe_root$$Mgr::GetNextGreatestUniqueTime( long lMeasure, long lBeat, MUSIC_TIME* pmtTime )
{
	// Iterate throught the $$Safe_root$$ list
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

		// If this item is beyond the measure we're looking for, exit
		// since the passed in lMeasure and lBeat are empty
		if( p$$Safe_root$$Item->m_lMeasure > lMeasure )
		{
			break;
		}

		// If this item is in the same measure as the passed in lMeasure
		if( p$$Safe_root$$Item->m_lMeasure == lMeasure )
		{
			// If this item is after the passed in lBeat, exit
			// since the passed in lMeasure and lBeat are empty
			if( p$$Safe_root$$Item->m_lBeat > lBeat )
			{
				break;
			}

			// If this item is in the same beat as the passed in lBeat
			if( p$$Safe_root$$Item->m_lBeat == lBeat )
			{
				// Look in the next beat
				lBeat++;

				// Check to see if we've rolled over to the next measure
				m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, pmtTime );
				m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, *pmtTime, &lMeasure, &lBeat );
				
				// Check if measure rolled over
				if( p$$Safe_root$$Item->m_lMeasure != lMeasure )
				{
					// No more beats in this measure so discard the item
					return false;
				}
			}
		}
	}

	// Found an empty lBeat for the new item - update pmtTime with the time
	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, pmtTime );

	// Return that we were able to find a spot for the new item
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::RecomputeTimes

bool C$$Safe_root$$Mgr::RecomputeTimes()
{
	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;

	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Save our current position
		POSITION pos2 = pos;

		// Get a pointer to the current item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_lst$$Safe_root$$s.GetNext( pos );

		// Using the item's current measure and beat settings, determine which measure and beat
		// the item will end up on
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, &mtTime );
		m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );

		// Check if either the measure or beat were changed
		if(	p$$Safe_root$$Item->m_lMeasure != lMeasure
		||	p$$Safe_root$$Item->m_lBeat != lBeat )
		{
			// Remove the itme from the list
			m_lst$$Safe_root$$s.RemoveAt( pos2 );

			// The measure the $$Safe_root$$ is in changed
			if( p$$Safe_root$$Item->m_lMeasure != lMeasure )
			{
				// This would happen when moving from 7/4 to 4/4, for example
				// $$Safe_root$$s on beat 7 would end up on next measure's beat 3
				while( p$$Safe_root$$Item->m_lMeasure != lMeasure )
				{
					// Keep moving back a beat until the measure does not change
					m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, --lBeat, &mtTime );
					m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
				}
			}

			// Try and find an empty beat in this measure on or after lBeat
			if( GetNextGreatestUniqueTime( lMeasure, lBeat, &mtTime ) )
			{
				// Found an empty beat, find out what it is
				m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );

				// Update the item with the new measure and beat
				p$$Safe_root$$Item->m_lMeasure = lMeasure;
				p$$Safe_root$$Item->m_lBeat = lBeat;

				// Flag that something changed
				fChanged = true;

				// Reinsert it into the list
				InsertByAscendingTime( p$$Safe_root$$Item );
			}
			else
			{
				// Couldn't find a spot for the item - delete it
				delete p$$Safe_root$$Item;

				// Flag that something changed
				fChanged = true;
			}
		}
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::DeleteBetweenMeasureBeats

bool C$$Safe_root$$Mgr::DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd )
{
	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current item
		C$$Safe_root$$Item* pItem = m_lst$$Safe_root$$s.GetNext(pos);

		// Check if the item's measure value is before the start measure
		if( pItem->m_lMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( pItem->m_lMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat > lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item
		m_lst$$Safe_root$$s.RemoveAt(posTemp);
		delete pItem;
		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr::SaveSelected$$Safe_root$$s

HRESULT C$$Safe_root$$Mgr::SaveSelected$$Safe_root$$s( IStream* pStream, long lBeatOffset )
// save selected items and adjust by "offset"
{
	// Verify that the pStream pointer is valid
	if(pStream == NULL)
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Create a list to store the items to save in
	CTypedPtrList<CPtrList, C$$Safe_root$$Item*> lst$$Safe_root$$sToSave;

	// Iterate throught the list of items
	POSITION pos = m_lst$$Safe_root$$s.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$ = m_lst$$Safe_root$$s.GetNext(pos);

		// Check if the item is selected
		if( p$$Safe_root$$->m_fSelected )
		{
			// Add the item to the list of items to save
			lst$$Safe_root$$sToSave.AddTail(new C$$Safe_root$$Item(*p$$Safe_root$$));
		}
	}


	//check that anything is selected
	if( lst$$Safe_root$$sToSave.IsEmpty() )
	{
		return S_FALSE;
	}

	// For each item in lst$$Safe_root$$sToSave, convert to a number of beats and subtract lBeatOffset
	Normalize$$Safe_root$$List( m_pTimeline, m_dwGroupBits, lst$$Safe_root$$sToSave, lBeatOffset );

	// Save the list of items into pStream
	HRESULT hr = Save$$Safe_root$$List( lst$$Safe_root$$sToSave, pStream );

	// Empty the temporary list of items
	Empty$$Safe_root$$List(lst$$Safe_root$$sToSave);

	// Return whether or not the save succeeded
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Normalize$$Safe_root$$List

void Normalize$$Safe_root$$List( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list, long lBeatOffset )
{
	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$ = list.GetNext(pos);

		// Convert the start time to a number of beats
		MeasureBeatToBeats( pITimeline, dwGroupBits, 0, p$$Safe_root$$->m_lMeasure, p$$Safe_root$$->m_lBeat, p$$Safe_root$$->m_lBeat );
		p$$Safe_root$$->m_lMeasure = 0;

		// Offset the beat value
		p$$Safe_root$$->m_lBeat -= lBeatOffset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// Save$$Safe_root$$List

HRESULT Save$$Safe_root$$List( CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list, IStream* pIStream )
{
	// Try and allocate an IDMUSProdRIFFStream from the IStream pointer
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Couldn't allocate an IDMUSProdRIFFStream, return a failure code
		return hr;
	}

	// Create the list chunk to store the $$Safe_root$$ data inside
	MMCKINFO ckMain;
	ckMain.fccType = FOURCC_$$SAFE_ROOT$$_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
	{
		// Couldn't create the chunk, exit with a failure code
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Iterate through the list of items
	POSITION pos;
	pos = list.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item = list.GetNext( pos );

		// Create a chunk to store each item inside
		MMCKINFO ck;
		ck.ckid = FOURCC_$$SAFE_ROOT$$_ITEM;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// Couldn't create the chunk, exit with a failure code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Initialize a DMUS_IO_$$SAFE_ROOT$$ structure to store the information about the $$Safe_root$$
		DMUS_IO_$$SAFE_ROOT$$ o$$Safe_root$$;
		ZeroMemory( &o$$Safe_root$$, sizeof( DMUS_IO_$$SAFE_ROOT$$ ) );

		// No need to set the mtTime member, since it's not used when pasting or dropping
		// o$$Safe_root$$.mtTime = 0;

		// Copy the measure and beat information to the DMUS_IO_$$SAFE_ROOT$$ structure
		// Since this is only for doing a copy/paste or drag/drop, store the beat
		// offset into dwMeasure
		o$$Safe_root$$.dwMeasure = p$$Safe_root$$Item->m_lBeat;
		o$$Safe_root$$.bBeat = 0;

		// Set the length of the text
		o$$Safe_root$$.dwLength = (p$$Safe_root$$Item->m_strText.GetLength() + 1) * sizeof(wchar_t);

		// Write out the DMUS_IO_$$SAFE_ROOT$$ structure
		DWORD dwBytesWritten;
		hr = pIStream->Write( &o$$Safe_root$$, sizeof(DMUS_IO_$$SAFE_ROOT$$), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_$$SAFE_ROOT$$) )
		{
			// An I/O error occurred, so exit with a failure code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Save the text as a Wide Character String
		hr = SaveMBStoWCS( pIStream, &p$$Safe_root$$Item->m_strText );
		if( FAILED( hr ) )
		{
			// An I/O error occurred, so exit with a failure code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out the $$Safe_root$$ item's chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// An I/O error occurred, so exit with a failure code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the main $$Safe_root$$ LIST chunk
	pIRiffStream->Ascend( &ckMain, 0 );

ON_ERROR:
	// Release the IDMUSProdRIFFStream interface
	pIRiffStream->Release();

	// Return the success or failure code
    return hr;
}

HRESULT Load$$Safe_root$$List( CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list, IStream* pIStream )
{
	// Try and allocate an IDMUSProdRIFFStream interface from the pIStream
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr;
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Couldn't allocate an IDMUSProdRIFFStream interface, return an error code
		return hr;
	}

	// Descend into the $$Safe_root$$ LIST chunk
	MMCKINFO ck;
	ck.fccType = FOURCC_$$SAFE_ROOT$$_LIST;
	if( pIRiffStream->Descend(&ck, NULL, MMIO_FINDLIST) == 0)
	{
		// Now, descend into each chunk in this LIST chunk
		MMCKINFO ckList;
		while(pIRiffStream->Descend(&ckList, &ck, 0) == 0)
		{
			switch(ckList.ckid)
			{
			// We can only read FOURCC_$$SAFE_ROOT$$_ITEM chunks
			case FOURCC_$$SAFE_ROOT$$_ITEM:
				// Create a DMUS_IO_$$SAFE_ROOT$$ structure to store the data in
				DMUS_IO_$$SAFE_ROOT$$ i$$Safe_root$$;

				// Try and read the DMUS_IO_$$SAFE_ROOT$$ structure
				DWORD dwByteCount;
				hr = pIStream->Read(&i$$Safe_root$$, sizeof(DMUS_IO_$$SAFE_ROOT$$), &dwByteCount);
				if(FAILED(hr) || dwByteCount != sizeof(DMUS_IO_$$SAFE_ROOT$$))
				{
					// An I/O error occurred, so exit with a failure code
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Create a new C$$Safe_root$$Item to store the data in
				C$$Safe_root$$Item* pItem = new C$$Safe_root$$Item;
				if( pItem == NULL)
				{
					// If the allocation failed, return an error code
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				// Read in the text from a Wide Character String to a MultiByte String
				ReadMBSfromWCS(pIStream, i$$Safe_root$$.dwLength, &pItem->m_strText);

				// Set the C$$Safe_root$$Item's data members
				pItem->m_lMeasure = i$$Safe_root$$.dwMeasure;
				pItem->m_lBeat = i$$Safe_root$$.bBeat;

				// By default, the item is selected when it is pasted or dropped
				pItem->m_fSelected = TRUE;

				// Add the item to list passed in
				list.AddTail(pItem);

				// Finished reading the FOURCC_$$SAFE_ROOT$$_ITEM chunk
				break;
			}

			// Ascend out of the chunk inside the FOURCC_$$SAFE_ROOT$$_LIST chunk
			pIRiffStream->Ascend(&ckList, 0);
		}

		// Ascend out of the FOURCC_$$SAFE_ROOT$$_LIST chunk
		pIRiffStream->Ascend(&ck, 0);
	}

ON_ERROR:
	// Release the IDMUSProdRIFFStream interface
	pIRiffStream->Release();

	// Return the success or failure code
    return hr;
}

void Empty$$Safe_root$$List( CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list )
{
	// Remove and delete all the C$$Safe_root$$Items from the given list
	while( !list.IsEmpty() )
	{
		delete list.RemoveHead();
	}
}

HRESULT GetBoundariesOf$$Safe_root$$s( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long &lStartTime, long &lEndTime, CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list)
{
	// Validate the given pTimeline pointer
	if( pTimeline == NULL )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Initialize the start and end times to -1
	lStartTime = -1;
	lEndTime = -1;

	// No items in list, return S_FALSE since there's nothing to do
	if( list.IsEmpty() )
	{
		return S_FALSE;
	}

	// Initialize our return value to S_OK
	HRESULT hr = S_OK;
	MUSIC_TIME mtTime;

	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* pItem = list.GetNext(pos);

		// Try and convert the measure and beat of the item to a value in number of clocks
		hr = pTimeline->MeasureBeatToClocks( dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, &mtTime );

		// If the conversion failed, break out of the while loop
		if(FAILED(hr))
		{
			break;
		}

		// If the start time is not yet set, or the item's time is earlier
		// than any other item, update lStartTime.
		if( ( lStartTime == -1 )
		||	( mtTime < lStartTime ) )
		{
			lStartTime = mtTime;
		}

		// If the end time is not yet set, or the item's time is later
		// than any other item, update lEnd.
		if( ( lEndTime == -1 )
		||	( mtTime > lEndTime ) )
		{
			lEndTime = mtTime;
		}
	}

	// If the conversions (MeasureBeatToClocks) succeeded
	if( SUCCEEDED(hr) )
	{
		// The start and end times should be set to valid values
		ASSERT( lStartTime != -1 );
		ASSERT( lEndTime != -1 );

		// Get the measure and beat of the last item
		long lMeasure, lBeat;
		CMusicTimeConverter cmt = lEndTime;
		hr = cmt.GetMeasureBeat( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Increment the beat value
		lBeat++;

		// Convert from measure and beat back to clocks
		hr = cmt.SetTime( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Set the end time to one tick before the next beat
		lEndTime = cmt - 1;
	}

	// Return the success or failure code
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\LyricMgr.h ===
// $$Safe_root$$Mgr.h : Declaration of the C$$Safe_root$$Mgr

#ifndef __$$SAFE_ROOT$$MGR_H_
#define __$$SAFE_ROOT$$MGR_H_

#include "resource.h"		// main symbols
#include "$$Safe_root$$StripMgr.h"
#include "$$Safe_root$$Item.h"
#include "selectedregion.h"
#include "BaseMgr.h"

#define FOURCC_$$SAFE_ROOT$$_LIST		mmioFOURCC('l','y','r','l')
#define FOURCC_$$SAFE_ROOT$$_ITEM		mmioFOURCC('l','y','r','c')

class C$$Safe_root$$Strip;
class C$$Safe_root$$Item;
class CDllJazzDataObject;
interface IDirectMusicTrack;

void	Empty$$Safe_root$$List( CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list );
HRESULT Load$$Safe_root$$List( CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list, IStream* pIStream);
HRESULT Save$$Safe_root$$List(	CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list, IStream* pIStream);
void Normalize$$Safe_root$$List( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list, long lBeatOffset );
HRESULT GetBoundariesOf$$Safe_root$$s( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long & lStartTime, long & lEndTime, CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list);

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Mgr
class ATL_NO_VTABLE C$$Safe_root$$Mgr : 
	public CBaseMgr,
	public CComCoClass<C$$Safe_root$$Mgr, &CLSID_$$Safe_root$$Mgr>,
	public I$$Safe_root$$Mgr
{
friend C$$Safe_root$$Strip;

public:
	C$$Safe_root$$Mgr();
	~C$$Safe_root$$Mgr();

DECLARE_REGISTRY_RESOURCEID(IDR_$$SAFE_ROOT$$MGR)

BEGIN_COM_MAP(C$$Safe_root$$Mgr)
	COM_INTERFACE_ENTRY(I$$Safe_root$$Mgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides

// I$$Safe_root$$Mgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes(); // Returns true if anything changed
	bool	SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime);
	bool	IsSelected(); // Returns true if any items are selected
	bool	IsEmpty(); // Returns false if there are any items
	
	void DeleteSelected$$Safe_root$$s();
	HRESULT SaveSelected$$Safe_root$$s(LPSTREAM, C$$Safe_root$$Item* p$$Safe_root$$AtDragPoint);
	HRESULT	SaveSelected$$Safe_root$$s(IStream* pStream, long lBeatOffset);

// general helpers
	void	MarkSelected$$Safe_root$$s(DWORD flags);
	void	UnMark$$Safe_root$$s(DWORD flags);
	void	DeleteMarked(DWORD flags);
	void	UnselectAll();
	void	SelectAll();
	bool	RemoveItem( C$$Safe_root$$Item* pItem );
	void	InsertByAscendingTime(C$$Safe_root$$Item *p$$Safe_root$$);
	bool	GetNextGreatestUniqueTime( long lMeasure, long lBeat, MUSIC_TIME* pmtTime );
	C$$Safe_root$$Item* FirstSelected$$Safe_root$$();
	bool	DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd );

protected:
	CTypedPtrList<CPtrList, C$$Safe_root$$Item*> m_lst$$Safe_root$$s;
	C$$Safe_root$$Item					m_Selected$$Safe_root$$Item;

	C$$Safe_root$$Strip*				m_p$$Safe_root$$Strip;

};


class C$$Safe_root$$Strip :
	public CBaseStrip
{
friend C$$Safe_root$$Mgr;

public:
	C$$Safe_root$$Strip( C$$Safe_root$$Mgr* p$$Safe_root$$Mgr );
	~C$$Safe_root$$Strip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDMUSProdPropPageObject functions

protected:
	void		UnselectGutterRange( void );

// IDropTarget helpers
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long position);
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos);

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);

	C$$Safe_root$$Mgr*			m_p$$Safe_root$$Mgr;

	C$$Safe_root$$Item* Get$$Safe_root$$FromPoint( long lPos );
	C$$Safe_root$$Item* Get$$Safe_root$$FromMeasureBeat( long lMeasure, long lBeat );
	bool SelectItemsInSelectedRegions();
	void SelectRegionsFromSelected$$Safe_root$$s();	

	UINT		m_cf$$Safe_root$$List;			// Clipboard format
	bool		m_fLeftMouseDown;
	C$$Safe_root$$Item*	m_p$$Safe_root$$ItemToToggle;
};

inline void CListSelectedRegion_AddRegion(CListSelectedRegion& csrList, C$$Safe_root$$Item& item)
{
	CMusicTimeConverter cmtBeg(item.m_lMeasure, item.m_lBeat, csrList.Timeline(), csrList.GroupBits());
	CMusicTimeConverter cmtEnd = cmtBeg;
	cmtEnd.AddOffset(0,1, csrList.Timeline(), csrList.GroupBits());
	CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
	csrList.AddHead(psr);
}


#endif //__$$SAFE_ROOT$$MGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\LyricItem.h ===
#ifndef __$$SAFE_ROOT$$ITEM_H_
#define __$$SAFE_ROOT$$ITEM_H_

#include <dmusici.h>

typedef struct _DMUS_IO_$$SAFE_ROOT$$
{
	MUSIC_TIME	mtTime;		// Time of event
	DWORD		dwMeasure;	// Measure event occurs in
	BYTE		bBeat;		// Beat event occurs in
	BYTE		bPad[3];	// Padding
	DWORD		dwLength;	// Length of text of WCHARS (in # of bytes) that follows the structure
} DMUS_IO_$$SAFE_ROOT$$;

#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002

class C$$Safe_root$$Item
{
public:
	C$$Safe_root$$Item();
	C$$Safe_root$$Item(const C$$Safe_root$$Item&);

	void Clear();
	void Copy( const C$$Safe_root$$Item* pItem );

	BOOL After(const C$$Safe_root$$Item& item);
	BOOL Before(const C$$Safe_root$$Item& item);

    long		m_lMeasure;	// What measure this item falls on
    long		m_lBeat;	// What beat this item falls on
	DWORD		m_dwBits;	// Various bits
	BOOL		m_fSelected;// This item is currently selected.
	CString		m_strText;	// Text contained in this event
};

#endif // __$$SAFE_ROOT$$ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\PropPageLyric.h ===
#if !defined(AFX_PROPPAGE$$SAFE_ROOT$$_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGE$$SAFE_ROOT$$_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

class C$$Safe_root$$PropPageMgr;
class CTabOnReturnEdit;

// PropPage$$Safe_root$$.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$ dialog
class C$$Safe_root$$PropPageMgr;

class PropPage$$Safe_root$$ : public CPropertyPage
{
	friend C$$Safe_root$$PropPageMgr;
	DECLARE_DYNCREATE(PropPage$$Safe_root$$)

// Construction
public:
	PropPage$$Safe_root$$();
	~PropPage$$Safe_root$$();

// Dialog Data
	//{{AFX_DATA(PropPage$$Safe_root$$)
	enum { IDD = IDD_$$SAFE_ROOT$$_PROPPAGE };
	CEdit	m_editBeat;
	CEdit	m_edit$$Safe_root$$;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPage$$Safe_root$$)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPage$$Safe_root$$)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEdit$$Safe_root$$();
	afx_msg void OnKillfocusEditMeasure();
	virtual void OnOK();
	//DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void Set$$Safe_root$$( const C$$Safe_root$$Item * p$$Safe_root$$ );

protected:
	void UpdateObject( void );
	void EnableControls( BOOL fEnable );
	void HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal );
	void HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );

	BOOL					m_fNeedToDetach;
	BOOL					m_fValid$$Safe_root$$;
	C$$Safe_root$$Item				m_$$Safe_root$$;
	C$$Safe_root$$PropPageMgr *		m_pPropPageMgr;
	IDMUSProdTimeline*		m_pTimeline; // Weak timeline reference
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGE$$SAFE_ROOT$$_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\LyricStrip.cpp ===
// $$Safe_root$$Strip.cpp : Implementation of C$$Safe_root$$Strip
#include "stdafx.h"
#include "$$Safe_root$$Item.h"
#include "$$Safe_root$$StripMgr.h"
#include "$$Safe_root$$Mgr.h"
#include "PropPageMgr.h"
#include "GroupBitsPPG.h"
#include <RiffStrm.h>
#include "BaseMgr.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This sets the strip's height
#define DEFAULT_STRIP_HEIGHT 20

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip constructor/destructor

C$$Safe_root$$Strip::C$$Safe_root$$Strip( C$$Safe_root$$Mgr* p$$Safe_root$$Mgr ) : CBaseStrip( p$$Safe_root$$Mgr )
{
	// Validate the pointer to our strip manager
	ASSERT( p$$Safe_root$$Mgr );
	if ( p$$Safe_root$$Mgr == NULL )
	{
		return;
	}

	// Set our pointer to our strip manager
	m_p$$Safe_root$$Mgr = p$$Safe_root$$Mgr;

	// Initialize our clipboard format to 0
	m_cf$$Safe_root$$List = 0;

	// Initialize our state variables to false
	m_fLeftMouseDown = false;

	// Initialize the $$Safe_root$$ to toggle (when CTRL-clicking) to NULL
	m_p$$Safe_root$$ItemToToggle = NULL;
}

C$$Safe_root$$Strip::~C$$Safe_root$$Strip()
{
	// Clear our pointer to our strip manager
	ASSERT( m_p$$Safe_root$$Mgr );
	if ( m_p$$Safe_root$$Mgr )
	{
		m_p$$Safe_root$$Mgr = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelected$$Safe_root$$ - helper method for Draw()

void GetNextSelected$$Safe_root$$( CTypedPtrList<CPtrList, C$$Safe_root$$Item*>& list, POSITION &pos$$Safe_root$$ )
{
	// Note that if the item at pos$$Safe_root$$ is selected, this method doesn't do anything useful.
	if( pos$$Safe_root$$ )
	{
		// Save the current position
		POSITION posToSave = pos$$Safe_root$$;

		// Check if we have not run off the end of the list, and if the currently item is unselected
		while( pos$$Safe_root$$ && !list.GetNext( pos$$Safe_root$$ )->m_fSelected )
		{
			// Current item is unselected, save the position of the next item
			posToSave = pos$$Safe_root$$;
		}

		// Check if we found a selected item
		if( posToSave )
		{
			// Save the position of the selected item
			pos$$Safe_root$$ = posToSave;
		}
		// Otherwise both posToSave and pos$$Safe_root$$ are NULL
	}
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Draw

HRESULT	STDMETHODCALLTYPE C$$Safe_root$$Strip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_p$$Safe_root$$Mgr == NULL
	||	m_p$$Safe_root$$Mgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Draw bar and beat lines
	CBaseStrip::Draw( hDC, sv, lXOffset );

	// Set a flag if we should use the gutter range for our selection
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);

	// Get our clipping rectange
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Initialize the top and bottom of the highlight rectangle
	// (it is always the entire strip height).
	RECT rectHighlight;
	rectHighlight.top = 0;
	rectHighlight.bottom = DEFAULT_STRIP_HEIGHT;

	// Find the first time that we are asked to draw
	long lStartTime;
	m_p$$Safe_root$$Mgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

	// A structure to store the size of each item in
	SIZE sizeText;

	////
	// Draw the unselected $$Safe_root$$s first

	// Iterate through the list of $$Safe_root$$s
	POSITION pos$$Safe_root$$ = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos$$Safe_root$$ )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetNext( pos$$Safe_root$$ );

		// If this item is selected and we are not using the gutter selection, skip it
		if( !fUseGutterSelectRange && p$$Safe_root$$Item->m_fSelected )
		{
			continue;
		}

		// Convert the measure and beat of each item to a pixel position
		long lPosition;
		m_p$$Safe_root$$Mgr->m_pTimeline->MeasureBeatToPosition( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, &lPosition );

		// Offset the position by the horizontal offset,
		// and increment it by one pixel so we don't overwrite the bar or beat line
		lPosition += -lXOffset + 1;

		// Check if the left edge of the $$Safe_root$$ text is beyond the region we're displaying
		if( lPosition > rectClip.right )
		{
			// We've gone beyond the right edge of the clipping region - break out of the loop
			break;
		}

		// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
		rectHighlight.left = lPosition;

		// Check if there is a item after this one
		if (pos$$Safe_root$$) 
		{
			// Get the size of the $$Safe_root$$ text to be written
			::GetTextExtentPoint32( hDC, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength(), &sizeText );

			// Get a pointer to the next item
			C$$Safe_root$$Item* pNext$$Safe_root$$ = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetAt( pos$$Safe_root$$ );

			// Get the start position of the next item
			m_p$$Safe_root$$Mgr->m_pTimeline->MeasureBeatToPosition( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, pNext$$Safe_root$$->m_lMeasure, pNext$$Safe_root$$->m_lBeat, &(rectHighlight.right) );

			// Offset this position with lXOffset
			rectHighlight.right -= lXOffset;

			// Check if the current item will run into the next item
			if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
			{
				// Yes, it will run into the next item - clip it
				::DrawText( hDC, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength(), &rectHighlight, DT_LEFT );
			}
			else
			{
				// It won't run into the next item - just draw it
				::TextOut( hDC, lPosition, 0, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength() );
			}
		}
		else
		{
			// No more items after this one - just draw it
			::TextOut( hDC, lPosition, 0, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength() );
		}
	}

	////
	// Now, draw the selected $$Safe_root$$s

	// Iterate through the list of $$Safe_root$$s, but only if we're not using the gutter selection
	pos$$Safe_root$$ = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetHeadPosition();
	while( !fUseGutterSelectRange && pos$$Safe_root$$ )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetNext( pos$$Safe_root$$ );

		// If this item is unselected, skip it
		if( !p$$Safe_root$$Item->m_fSelected )
		{
			continue;
		}

		// Convert the measure and beat of each $$Safe_root$$ to a pixel position
		long lPosition;
		m_p$$Safe_root$$Mgr->m_pTimeline->MeasureBeatToPosition( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, &lPosition );

		// Offset the position by the horizontal offset,
		// and increment it by one pixel so we don't overwrite the bar or beat line
		lPosition += -lXOffset + 1;

		// Check if the left edge of the $$Safe_root$$ text is beyond the region we're displaying
		if( lPosition > rectClip.right )
		{
			// We've gone beyond the right edge of the clipping region - break out of the loop
			break;
		}

		// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
		rectHighlight.left = lPosition;

		// Get the position of the next selected item (it may be the one at pos$$Safe_root$$
		GetNextSelected$$Safe_root$$( m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s, pos$$Safe_root$$ );

		// Check if there is a selected item after the current one
		if( pos$$Safe_root$$ )
		{
			// Get the size of the text to be written
			::GetTextExtentPoint32( hDC, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength(), &sizeText );

			// Get a pointer to the next item
			C$$Safe_root$$Item* pNext$$Safe_root$$ = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetAt( pos$$Safe_root$$ );

			// Get the start position of the next item
			m_p$$Safe_root$$Mgr->m_pTimeline->MeasureBeatToPosition( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, pNext$$Safe_root$$->m_lMeasure, pNext$$Safe_root$$->m_lBeat, &(rectHighlight.right) );

			// Offset this position with lXOffset
			rectHighlight.right -= lXOffset;

			// Check if the current item will run into the next item
			if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
			{
				// Yes, it will run into the next item - clip it
				::DrawText( hDC, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength(), &rectHighlight, DT_LEFT );
			}
			else
			{
				// It won't run into the next item - just draw it
				::TextOut( hDC, lPosition, 0, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength() );
			}
		}
		// No more selected items
		else
		{
			// Just draw the $$Safe_root$$
			::TextOut( hDC, lPosition, 0, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength() );
		}
	}

	// Now, invert the selected regions
	if( m_pSelectedRegions )
	{
		// Keep a running count of the furthest right position we've inverted.
		// This ensures we don't double-invert.
		long lRightMostInvert = 0;

		// Sort the list of selected regions
		m_pSelectedRegions->Sort();

		// Get the start position of the $$Safe_root$$ list
		pos$$Safe_root$$ = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetHeadPosition();

		// Get the start position of the region list
		POSITION posRegion = m_pSelectedRegions->GetHeadPosition();
		while(posRegion)
		{
			// Get a pointer to the current $$Safe_root$$, but only when not using the gutter selection
			C$$Safe_root$$Item* p$$Safe_root$$Item = NULL;
			if( !fUseGutterSelectRange && pos$$Safe_root$$ )
			{
				// Get the position of the next selected item (it may be the one at pos$$Safe_root$$)
				GetNextSelected$$Safe_root$$( m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s, pos$$Safe_root$$ );

				// Check if we found a selected item
				if( pos$$Safe_root$$ )
				{
					// Get a pointer to the selected item
					p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetAt( pos$$Safe_root$$ );
				}
			}

			// Get a pointer to this region
			CSelectedRegion* psr = m_pSelectedRegions->GetNext(posRegion);

			// Get the start and end positions for this region
			rectHighlight.left = psr->BeginPos(m_p$$Safe_root$$Mgr->m_pTimeline) - lXOffset;
			rectHighlight.right = psr->EndPos(m_p$$Safe_root$$Mgr->m_pTimeline) - lXOffset;

			// Check if we have a pointer to a selected item and if we're not using gutter selection
			if( p$$Safe_root$$Item && !fUseGutterSelectRange )
			{
				// Get the clock position of this item
				long l$$Safe_root$$ClockPos;
				m_p$$Safe_root$$Mgr->m_pTimeline->MeasureBeatToClocks( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
					p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, &l$$Safe_root$$ClockPos );

				while( pos$$Safe_root$$ && (l$$Safe_root$$ClockPos < psr->End()) )
				{
					// Check if the current item is within this selected region
					if( l$$Safe_root$$ClockPos >= psr->Beg() )
					{
						// Compute the left side of the $$Safe_root$$'s text display
						long l$$Safe_root$$Pos;
						m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToPosition( l$$Safe_root$$ClockPos, &l$$Safe_root$$Pos );

						// Get the size of the text to be written
						::GetTextExtentPoint32( hDC, p$$Safe_root$$Item->m_strText, p$$Safe_root$$Item->m_strText.GetLength(), &sizeText );

						// Add the size of the text and subtract the offset to
						// determine the right side of the $$Safe_root$$'s text display.
						l$$Safe_root$$Pos += sizeText.cx - lXOffset;

						// Move pos$$Safe_root$$ so we check the next item
						m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetNext( pos$$Safe_root$$ );

						// Get the position of the next selected item (it may be the one at pos$$Safe_root$$)
						GetNextSelected$$Safe_root$$( m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s, pos$$Safe_root$$ );

						// Check if we found a selected item
						if( pos$$Safe_root$$ )
						{
							// Get a pointer to the selected item
							p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetAt( pos$$Safe_root$$ );

							// Get the clock position of this $$Safe_root$$
							m_p$$Safe_root$$Mgr->m_pTimeline->MeasureBeatToClocks( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
								p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, &l$$Safe_root$$ClockPos );

							// Compute the start position of the next selected item
							long lNextStartPos;
							m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToPosition( l$$Safe_root$$ClockPos, &lNextStartPos );

							// Ensure that we only exent the selection region up to the
							// start of the next selected item
							l$$Safe_root$$Pos = min( lNextStartPos, l$$Safe_root$$Pos );
						}

						// Update rectHighlight.right, if necessary
						rectHighlight.right = max( l$$Safe_root$$Pos, rectHighlight.right );
					}
					else
					{
						// Move pos$$Safe_root$$ so we check the next item
						m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetNext( pos$$Safe_root$$ );

						// Get the position of the next selected item (it may be the one at pos$$Safe_root$$)
						GetNextSelected$$Safe_root$$( m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s, pos$$Safe_root$$ );

						// Check if we found a selected item
						if( pos$$Safe_root$$ )
						{
							// Get a pointer to the selected item
							p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetAt( pos$$Safe_root$$ );

							// Get the clock position of this $$Safe_root$$
							m_p$$Safe_root$$Mgr->m_pTimeline->MeasureBeatToClocks( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
								p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat, &l$$Safe_root$$ClockPos );
						}
					}
				}
			}

			// Check if we've not already inverted beyond this selection region
			if( lRightMostInvert < rectHighlight.right )
			{
				// Update the left side of the region so we don't double-invert
				rectHighlight.left = max( lRightMostInvert, rectHighlight.left );

				// Now, invert the rect
				::InvertRect( hDC, &rectHighlight );

				// Save the new right side boundary
				lRightMostInvert = rectHighlight.right;
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Get$$Safe_root$$FromMeasureBeat

C$$Safe_root$$Item *C$$Safe_root$$Strip::Get$$Safe_root$$FromMeasureBeat( long lMeasure, long lBeat )
{
	// Iterate through the list
	POSITION pos = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetNext( pos );

		// Check if it is in the measure and beat we're looking for
		if ( p$$Safe_root$$Item->m_lMeasure == lMeasure &&
			 p$$Safe_root$$Item->m_lBeat == lBeat )
		{
			// We found the item to return
			return p$$Safe_root$$Item;
		}
		// Check if we've passed the measure yet
		else if ( p$$Safe_root$$Item->m_lMeasure > lMeasure )
		{
			// We've passed the measure - break out of the loop
			break;
		}
	}

	// Didn't find an item - return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Get$$Safe_root$$FromPoint

C$$Safe_root$$Item *C$$Safe_root$$Strip::Get$$Safe_root$$FromPoint( long lPos )
{
	// Validate our timeline pointer
	if( m_p$$Safe_root$$Mgr->m_pTimeline )
	{
		// Convert the position to a measure and beat value
		long lMeasure, lBeat;
		if( SUCCEEDED( m_p$$Safe_root$$Mgr->m_pTimeline->PositionToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			// Conversion was successful, look for an item on that measure and beat
			return Get$$Safe_root$$FromMeasureBeat( lMeasure, lBeat );
		}
	}

	// Conversion failed (or there is no Timeline) - return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::OnWMMessage

HRESULT STDMETHODCALLTYPE C$$Safe_root$$Strip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	// Validate our timeline pointer
	if( m_p$$Safe_root$$Mgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Call a function to handle the left mouse button press
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		m_lXPos = lXPos;	// need to start drag drop from where selection started
		break;

	case WM_RBUTTONDOWN:
		// Call a function to handle the right mouse button press
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		// Check if the left mouse button is downp$$Safe_root$$
		if(m_fLeftMouseDown)
		{
			// The user moved the mouse while the left mouse button was down -
			// do a drag-drop operation.
			hr = DoDragDrop( m_p$$Safe_root$$Mgr->m_pTimeline, wParam, m_lXPos);

			// The above method returns after a drop, or after the user
			// cancels the operation.  In either case, we don't want to do
			// a drag-drop operation again.
			m_fLeftMouseDown = false;

			// If the drag-drop operatoin didn't complete
			if(hr != S_OK || m_dwDropEffect == DROPEFFECT_NONE)
			{
				// Store the position that the drag started at, because drag drop eats mouse up
				m_lXPos = lXPos;

				// Check if the control key was down
				if(wParam & MK_CONTROL)
				{
					// Finish the toggle operation on the item that was clicked on
					// when the left mouse button was pressed.
					if( m_p$$Safe_root$$ItemToToggle )
					{
						m_pSelectedRegions->ToggleRegion( m_p$$Safe_root$$ItemToToggle->m_lMeasure, m_p$$Safe_root$$ItemToToggle->m_lBeat );
						m_p$$Safe_root$$ItemToToggle = NULL;

						// Update the selection state of the $$Safe_root$$s
						SelectItemsInSelectedRegions();
					}
				}
				// Check if the shift key was not down
				else if( !(wParam & MK_SHIFT) )
				{
					// If an item was clicked on
					if(Get$$Safe_root$$FromPoint( lXPos ))
					{
						// Update the selection regions to include only the selected items
						SelectRegionsFromSelected$$Safe_root$$s();
					}
				}

				// Redraw the strip
				m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

				// Switch the property page to the $$Safe_root$$ property page
				m_p$$Safe_root$$Mgr->OnShowProperties();
			}
			else
			{
				// successful drag drop--make sure that only the regions with
				// selected items are selected
				SelectRegionsFromSelected$$Safe_root$$s();
			}

			// Refresh the $$Safe_root$$ property page, if it exists
			if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
			{
				m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case WM_LBUTTONUP:
		// Clear the flag so we don't start a drag-drop operation when the mouse moved
		m_fLeftMouseDown = false;

		// Check if the Ctrl key was pressed
		if(wParam & MK_CONTROL)
		{
			// Ctrl key pressed - toggle the selection state of the item that was clicked on
			if( m_p$$Safe_root$$ItemToToggle )
			{
				m_pSelectedRegions->ToggleRegion( m_p$$Safe_root$$ItemToToggle->m_lMeasure, m_p$$Safe_root$$ItemToToggle->m_lBeat );
				m_p$$Safe_root$$ItemToToggle = NULL;

				// Select all items that are in the selection regions
				SelectItemsInSelectedRegions();
			}
		}
		// Check if the Shift key was not pressed
		else if( !(wParam & MK_SHIFT) )
		{
			// Look for an item at the position clicked on
			C$$Safe_root$$Item* p$$Safe_root$$ = Get$$Safe_root$$FromPoint( lXPos );
			if(p$$Safe_root$$)
			{
				// Found an item
				// Unselect all items
				m_p$$Safe_root$$Mgr->UnselectAll();

				// Mark the clicked on item as selected
				p$$Safe_root$$->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelected$$Safe_root$$s();
			}
		}

		// Update the position to inset at
		m_lXPos = lXPos;

		// Ensure all other strips are unselected
		UnselectGutterRange();

		// Redraw ourself
		m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

		// Refresh the $$Safe_root$$ property page, if it exists
		if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
		{
			m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case WM_CREATE:
		// Register our clipboard format, if it hasn't been registered yet
		if( m_cf$$Safe_root$$List == 0 )
		{
			m_cf$$Safe_root$$List = RegisterClipboardFormat( CF_$$SAFE_ROOT$$LIST );
		}

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_RBUTTONUP, WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Copy

HRESULT C$$Safe_root$$Strip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr;
	hr = CanCopy();
	if( hr != S_OK )
	{
		// Nothing to copy - return error code
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Validate our pointer to the timeline
	if( (m_p$$Safe_root$$Mgr == NULL)
	||	(m_p$$Safe_root$$Mgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cf$$Safe_root$$List == 0 )
	{
		m_cf$$Safe_root$$List = RegisterClipboardFormat( CF_$$SAFE_ROOT$$LIST );
		if( m_cf$$Safe_root$$List == 0 )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected $$Safe_root$$s in.
	IStream* pStreamCopy;
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );

	// Verify that we were able to create a stream
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Get the span of the selected $$Safe_root$$s
	long lStartTime, lEndTime;
	m_pSelectedRegions->GetSpan(lStartTime, lEndTime);

	// Convert the start time to a measure and beat
	long lMeasure, lBeats;
	m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
								lStartTime, &lMeasure, &lBeats );

	// Convert the start time to a number of beats
	MeasureBeatToBeats( m_p$$Safe_root$$Mgr->m_pTimeline, m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, lMeasure, lBeats, lBeats );

	// Convert the end time to a measure and beat
	long lEndBeats;
	m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
								lEndTime, &lMeasure, &lEndBeats );

	// Convert the end time to a number of beats
	MeasureBeatToBeats( m_p$$Safe_root$$Mgr->m_pTimeline, m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, lMeasure, lEndBeats, lEndBeats );

	// Compute the span of the region we're copying
	lEndBeats -= lBeats;

	// Save the number of beats in the region we're copying
	pStreamCopy->Write( &lEndBeats, sizeof(long), NULL );

	// Save the selected $$Safe_root$$s into the stream
	hr = m_p$$Safe_root$$Mgr->SaveSelected$$Safe_root$$s( pStreamCopy, lBeats );

	// Check if the save succeeded
	if( FAILED( hr ))
	{
		// Save failed
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyDataToClipboard( pITimelineDataObject, pStreamCopy, m_cf$$Safe_root$$List, m_p$$Safe_root$$Mgr, this );

	// Release our pointer to the stream
	pStreamCopy->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::PasteAt

HRESULT C$$Safe_root$$Strip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize the return code to a failure code
	HRESULT hr = E_FAIL;

	// If we're in a drag-drop operation, check if we're dragging from and dropping to this strip
	if( bDropNotPaste
	&&	(m_pITargetDataObject == m_pISourceDataObject) )
	{
		// Ensure we have a valid timeline pointer
		if( m_p$$Safe_root$$Mgr->m_pTimeline )
		{
			// Determine the measure and beat we're dropping in
			long lMeasure1, lBeat1;
			if(SUCCEEDED(m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, lPasteTime, &lMeasure1, &lBeat1 )))
			{
				// Compute the measure and beat the drag started from
				long lMeasure2, lBeat2;
				if(SUCCEEDED(m_p$$Safe_root$$Mgr->m_pTimeline->PositionToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, m_lStartDragPosition, &lMeasure2, &lBeat2 )))
				{
					// Check if we dropped in the same measure we started the drag from.
					if(lMeasure1 == lMeasure2 && lBeat1 == lBeat2)
					{
						// Didn't move - exit early
						goto Leave;
					}
				}
			}
		}
	}

	// Check if there is a $$Safe_root$$ list avilable for us
	if( pITimelineDataObject->IsClipFormatAvailable( m_cf$$Safe_root$$List ) == S_OK )
	{
		// Try and read the stream that contains the $$Safe_root$$s
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cf$$Safe_root$$List, &pIStream)))
		{
			// If we're pasting, read in the number of beats that this selection covers
			long lBeatsToPaste = -1;
			if( !bDropNotPaste )
			{
				pIStream->Read( &lBeatsToPaste, sizeof(long), NULL );
			}

			// Load the stream into a list of items
			CTypedPtrList<CPtrList, C$$Safe_root$$Item*> list;
			hr = Load$$Safe_root$$List(list, pIStream);

			// Check if the load operation succeeded
			if ( SUCCEEDED(hr) )
			{
				if( m_p$$Safe_root$$Mgr->m_pTimeline )
				{
					// Get the measure and beat of the drop or paste position
					long lMeasurePaste, lBeatPaste;
					if(FAILED(m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, 
																	max( lPasteTime, 0 ), &lMeasurePaste, &lBeatPaste )))
					{
						hr = E_FAIL;
						goto Leave_1;
					}

					long lBeatStart;
					MeasureBeatToBeats( m_p$$Safe_root$$Mgr->m_pTimeline, m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, lMeasurePaste, lBeatPaste, lBeatStart );

					// The length of the segment, in beats
					long lBeatSegmentLength = LONG_MAX;

					// Check if there are any items to paste
					if( !list.IsEmpty() )
					{
						// Unselect all existing $$Safe_root$$s in this strip so the only selected $$Safe_root$$s are the dropped
						// or pasted ones
						m_p$$Safe_root$$Mgr->UnselectAll();

						// Make sure the last item lands in the last beat or sooner
						// Retrieve the clock length of the segment
						VARIANT varLength;
						if( SUCCEEDED( m_p$$Safe_root$$Mgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
						{
							// Compute the measure and beat length of the segment
							long lMeasure, lBeat;
							if( SUCCEEDED( m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, 
																			V_I4(&varLength), &lMeasure, &lBeat ) ) )
							{
								// Compute the beat length of the segment
								MeasureBeatToBeats( m_p$$Safe_root$$Mgr->m_pTimeline, m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
									lMeasure, lBeat, lBeatSegmentLength );

								// Make sure the last item lands in the last beat or sooner
								if( list.GetTail()->m_lMeasure + lBeatStart >= lBeatSegmentLength )
								{
									lBeatStart = lBeatSegmentLength - list.GetTail()->m_lMeasure - 1;
								}
							}
						}

						// Make sure the first item lands in beat 0 or later
						if( list.GetHead()->m_lMeasure + lBeatStart < 0 )
						{
							lBeatStart = -list.GetHead()->m_lMeasure;
						}
					}

					// Check if we're doing a paste
					if(!bDropNotPaste)
					{
						// We're doing a paste, so get the paste type
						TIMELINE_PASTE_TYPE tlPasteType;
						if( FAILED( m_p$$Safe_root$$Mgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
						{
							// Failed to get the paste type, so return with error code
							hr = E_FAIL;
							goto Leave_1;
						}

						// Check if we're doing a paste->overwrite
						if( tlPasteType == TL_PASTE_OVERWRITE )
						{
							// Count lBeatsToPaste beats from lBeatStart and convert to a measure and beat value
							long lmEnd, lbEnd;
							BeatsToMeasureBeat( m_p$$Safe_root$$Mgr->m_pTimeline, m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
								lBeatStart + lBeatsToPaste, lmEnd, lbEnd );

							// Now, delete any items that fall between the first and last beats we're pasting in
							fChanged = m_p$$Safe_root$$Mgr->DeleteBetweenMeasureBeats(lMeasurePaste, lBeatPaste, lmEnd, lbEnd );
						}
					}

					// Iterate throught the list of $$Safe_root$$s we loaded
					while( !list.IsEmpty() )
					{
						// Remove the head of the list
						C$$Safe_root$$Item* pItem = list.RemoveHead();

						// Check if the item will land before the end of the segment
						if( pItem->m_lMeasure + lBeatStart < lBeatSegmentLength )
						{
							// Convert from a number of beats to a measure and beat value
							// When we saved this to a stream in C$$Safe_root$$Mgr::SaveSelected$$Safe_root$$s, we stored
							// the beat offset into m_dwMeasure.
							BeatsToMeasureBeat( m_p$$Safe_root$$Mgr->m_pTimeline, m_p$$Safe_root$$Mgr->m_dwGroupBits, 0,
								pItem->m_lMeasure + lBeatStart, pItem->m_lMeasure, pItem->m_lBeat );

							// When pasted or dropped, each item is selected
							pItem->m_fSelected = TRUE;

							// This will overwrite any item that already exists on the measure and
							// beat where pItem will be inserted
							m_p$$Safe_root$$Mgr->InsertByAscendingTime( pItem );

							// We changed
							fChanged = TRUE;
						}
						else
						{
							// Item would be pasted beyond the end of the segment - delete it
							delete pItem;
						}
					}
				}
			}
Leave_1:
			pIStream->Release();
		}
	}

Leave:
	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same $$Safe_root$$ strip
		m_nStripIsDragDropSource = 2;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Paste

HRESULT C$$Safe_root$$Strip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our $$Safe_root$$Mgr and Timeline pointers
	if( (m_p$$Safe_root$$Mgr == NULL)
	||	(m_p$$Safe_root$$Mgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, m_p$$Safe_root$$Mgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks;
	if( FAILED( m_p$$Safe_root$$Mgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks) ) )
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt(pITimelineDataObject, lClocks, false, fChanged);

	// Check if the paste succeeded AND if something was actually pasted
	if( SUCCEEDED(hr) && fChanged )
	{
		// Update the selection regions to only include the selected items
		SelectRegionsFromSelected$$Safe_root$$s();

		// Notify the Segment Designer that we did a paste operation
		m_p$$Safe_root$$Mgr->m_nLastEdit = IDS_PASTE;
		m_p$$Safe_root$$Mgr->OnDataChanged();

		// Redraw our strip
		m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the $$Safe_root$$ property page is visible
		m_p$$Safe_root$$Mgr->OnShowProperties();

		// Refresh the $$Safe_root$$ property page
		if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
		{
			m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
		}
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Insert

HRESULT C$$Safe_root$$Strip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that our timeline pointer is valid
	if( (m_p$$Safe_root$$Mgr == NULL)
	||	(m_p$$Safe_root$$Mgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Unselect all items in this strip 
	m_p$$Safe_root$$Mgr->UnselectAll();

	// Unselect all items in other strips
	UnselectGutterRange();

	// Convert the insert position to a measure and beat value
	long	lMeasure, lBeat;
	if( FAILED( m_p$$Safe_root$$Mgr->m_pTimeline->PositionToMeasureBeat( m_p$$Safe_root$$Mgr->m_dwGroupBits, 0, max( 0, m_lXPos ), &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}

	C$$Safe_root$$Item* p$$Safe_root$$ = new C$$Safe_root$$Item;
	if(p$$Safe_root$$ == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Try and load the default text
	if( !p$$Safe_root$$->m_strText.LoadString( IDS_DEFAULT_$$SAFE_ROOT$$_TEXT ) )
	{
		// Failed to load the text, just use a default english string
		p$$Safe_root$$->m_strText = _T("Empty");
	}

	// Set the measure and beat the item was inserted in
	p$$Safe_root$$->m_lMeasure = lMeasure;
	p$$Safe_root$$->m_lBeat = lBeat;

	// By default, a newly selected item is selected
	p$$Safe_root$$->m_fSelected = TRUE;

	// Insert the item into our list of $$Safe_root$$s, overwriting any existing one
	m_p$$Safe_root$$Mgr->InsertByAscendingTime(p$$Safe_root$$);

	// If it's not already selected, add the beat the item was inserted on
	// to the list of selected regions
	if( !m_pSelectedRegions->Contains( lMeasure, lBeat ) )
	{
		m_pSelectedRegions->AddRegion(m_lXPos);
	}

	// Redraw our strip
	m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	// Show the property sheet
	ShowPropertySheet();

	// Switch to the $$Safe_root$$ property page
	m_p$$Safe_root$$Mgr->OnShowProperties();

	// Refresh the $$Safe_root$$ property page
	if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
	{
		m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that an insert occurred
	m_p$$Safe_root$$Mgr->m_nLastEdit = IDS_INSERT;
	m_p$$Safe_root$$Mgr->OnDataChanged();

	// Return the success/failure code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Delete

HRESULT C$$Safe_root$$Strip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	// Verify that we have a valid timeline pointer
	if( (m_p$$Safe_root$$Mgr == NULL)
	||	(m_p$$Safe_root$$Mgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Delete all selected items
	m_p$$Safe_root$$Mgr->DeleteSelected$$Safe_root$$s();

	// Clear all selection ranges
	m_pSelectedRegions->Clear();

	// Redraw our strip
	m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	// Refresh the $$Safe_root$$ property page, if it exists
	if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
	{
		m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that a delete operation occurred
	m_p$$Safe_root$$Mgr->m_nLastEdit = IDS_DELETE;
	m_p$$Safe_root$$Mgr->OnDataChanged();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::CanPaste

HRESULT C$$Safe_root$$Strip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_p$$Safe_root$$Mgr == NULL)
	||	(m_p$$Safe_root$$Mgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cf$$Safe_root$$List == 0 )
	{
		m_cf$$Safe_root$$List = RegisterClipboardFormat( CF_$$SAFE_ROOT$$LIST );
		if( m_cf$$Safe_root$$List == 0 )
		{
			return E_FAIL;
		}
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_p$$Safe_root$$Mgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard format
	hr = pITimelineDataObject->IsClipFormatAvailable( m_cf$$Safe_root$$List );

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// If we found our clipboard format, return S_OK
	if (hr == S_OK)
	{
		return S_OK;
	}

	// Otherwise, return S_FALSE
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::CanInsert

HRESULT C$$Safe_root$$Strip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid Timeline pointer
	if( (m_p$$Safe_root$$Mgr == NULL)
	||	(m_p$$Safe_root$$Mgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime;
	if( FAILED( m_p$$Safe_root$$Mgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime) ) )
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if( m_fInFunctionBarMenu || (lInsertTime < 0) )
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition;
	if( FAILED( m_p$$Safe_root$$Mgr->m_pTimeline->ClocksToPosition( lInsertTime, &lPosition ) ) )
	{
		return E_UNEXPECTED;
	}

	// Check to see if there is an existing item at the insert position
	C$$Safe_root$$Item* p$$Safe_root$$ = Get$$Safe_root$$FromPoint( lPosition );

	// Check if we found an item
	if( p$$Safe_root$$ != NULL )
	{
		// We found an item - return S_FALSE since we can't insert here
		return S_FALSE;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_p$$Safe_root$$Mgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if( lInsertTime >= V_I4(&var) )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::Drop

HRESULT C$$Safe_root$$Strip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_p$$Safe_root$$Mgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_p$$Safe_root$$Mgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected items
						SelectRegionsFromSelected$$Safe_root$$s();

						// Notify the SegmentDesigner that a paste operation occurred
						m_p$$Safe_root$$Mgr->m_nLastEdit = IDS_PASTE;
						m_p$$Safe_root$$Mgr->OnDataChanged();

						// Redraw our strip
						m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the $$Safe_root$$ property page
						m_p$$Safe_root$$Mgr->OnShowProperties();

						// Update the $$Safe_root$$ property page, if it exists
						if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
						{
							m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
						}
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::CanPasteFromData

HRESULT C$$Safe_root$$Strip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_p$$Safe_root$$Mgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check if our clipboard format is available in the data object
	hr = S_FALSE;
	if( pITimelineDataObject->IsClipFormatAvailable( m_cf$$Safe_root$$List ) == S_OK )
	{
		// Our format is available = return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::OnLButtonDown

HRESULT C$$Safe_root$$Strip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Validate our timeline pointer
	if( (m_p$$Safe_root$$Mgr == NULL)
	||	(m_p$$Safe_root$$Mgr->m_pTimeline == NULL) )
	{
		return E_UNEXPECTED;
	}

	// Initialize the item to toggle to NULL
	m_p$$Safe_root$$ItemToToggle = NULL;
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_p$$Safe_root$$Mgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Flag that the left mouse button is pressed
	m_fLeftMouseDown = true;

	// Show the $$Safe_root$$ property page
	m_fShowItemProps = true;

	// Check if the shift key is pressed
	if(wParam & MK_SHIFT)
	{
		m_pSelectedRegions->ShiftAddRegion(lXPos);
		SelectItemsInSelectedRegions();
	}
	else
	{
		// See if there is an item under the cursor.
		C$$Safe_root$$Item* p$$Safe_root$$ = Get$$Safe_root$$FromPoint( lXPos );
		if( p$$Safe_root$$ )
		{
			// Found an item under the cursor

			// Check if the control key is down
			if(wParam & MK_CONTROL)
			{
				// Check if the item is not yet selected
				if( !p$$Safe_root$$->m_fSelected )
				{
					// Not yet selected - select the beat just clicked on
					m_pSelectedRegions->AddRegion(lXPos);
				}
				else
				{
					// Set up to unselect this item later, either when we receive a
					// left-button up, or when the user completes a drag-drop operation
					// that does nothing.
					m_p$$Safe_root$$ItemToToggle = p$$Safe_root$$;
				}
			}
			// Check if the item is unselected (the shift key is up)
			else if( !p$$Safe_root$$->m_fSelected )
			{
				// Clear all selection regions
				m_pSelectedRegions->Clear();

				// Select only the beat clicked on
				m_pSelectedRegions->AddRegion(lXPos);
			}
		}
		// Didn't find an item - check if the Ctrl key is down
		else if(wParam & MK_CONTROL)
		{
			// Toggle the selection state in the region under the cursor
			m_pSelectedRegions->ToggleRegion(lXPos);
		}
		// The shift key is up
		else
		{
			// The user left-clicked on blank space without holding the shift or Ctrl keys down

			// Clear all selection regions
			m_pSelectedRegions->Clear();

			// Select only the beat clicked on
			m_pSelectedRegions->AddRegion(lXPos);
		}

		// Ensure all items are now unselected
		SelectItemsInSelectedRegions();
	}

	// Redraw our strip
	m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the $$Safe_root$$ property page
	m_p$$Safe_root$$Mgr->OnShowProperties();

	// Refresh the $$Safe_root$$ property page, if it exists
	if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
	{
		m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::OnRButtonDown

HRESULT C$$Safe_root$$Strip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	ASSERT( m_p$$Safe_root$$Mgr->m_pTimeline != NULL );

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	C$$Safe_root$$Item* p$$Safe_root$$ = Get$$Safe_root$$FromPoint( lXPos );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if an item was clicked on
		if( p$$Safe_root$$ )
		{
			// Check if the item is selected
			if( p$$Safe_root$$->m_fSelected == FALSE )
			{
				// $$Safe_root$$ is not selected, unselect all items
				m_p$$Safe_root$$Mgr->UnselectAll();

				// Select just this item
				p$$Safe_root$$->m_fSelected = TRUE;

				// Add just this beat to the list of selected regions
				m_pSelectedRegions->AddRegion(lXPos);
			}
			// If the item was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure and beat
			long lMeasure, lBeat;
			if( SUCCEEDED( m_p$$Safe_root$$Mgr->m_pTimeline->PositionToMeasureBeat(m_p$$Safe_root$$Mgr->m_dwGroupBits,
															0,lXPos, &lMeasure, &lBeat) ) )
			{
				// Check if this beat is not already selected
				if( !m_pSelectedRegions->Contains(lMeasure, lBeat))
				{
					// This beat is not selected - unselect all beats
					m_p$$Safe_root$$Mgr->UnselectAll();

					// Now, select just this beat
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
		}
	}

	// Redraw our strip
	m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch to the $$Safe_root$$ property page
	m_fShowItemProps = true;
	m_p$$Safe_root$$Mgr->OnShowProperties(); 
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::UnselectGutterRange

void C$$Safe_root$$Strip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_p$$Safe_root$$Mgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_p$$Safe_root$$Mgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::CreateDataObject

HRESULT	C$$Safe_root$$Strip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_p$$Safe_root$$Mgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}


	// Save Selected $$Safe_root$$s into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream;
	if( SUCCEEDED ( m_p$$Safe_root$$Mgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Get the item at the drag point
		C$$Safe_root$$Item* p$$Safe_root$$AtDragPoint = Get$$Safe_root$$FromPoint( lPosition );

		// mark the $$Safe_root$$s as being dragged: this used later for deleting $$Safe_root$$s in drag move
		m_p$$Safe_root$$Mgr->MarkSelected$$Safe_root$$s(UD_DRAGSELECT);

		// Save the selected items into a stream
		if( SUCCEEDED ( m_p$$Safe_root$$Mgr->SaveSelected$$Safe_root$$s( pIStream, p$$Safe_root$$AtDragPoint ) ) )
		{
			// Add the stream to the Timeline DataObject
			if( SUCCEEDED ( pITimelineDataObject->AddExternalClipFormat( m_cf$$Safe_root$$List, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::DoDragDrop

HRESULT C$$Safe_root$$Strip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos)
{
	// Do a drag'n'drop operation

	// Get the item at the point we're dragging from
	C$$Safe_root$$Item* p$$Safe_root$$ = Get$$Safe_root$$FromPoint( lXPos );

	// Check that we found a item, and that it is selected
	if(!p$$Safe_root$$ || !p$$Safe_root$$->m_fSelected)
	{
		// Didn't find a selected item - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected items
		hr = CreateDataObject( &m_pISourceDataObject, lXPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy $$Safe_root$$s.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut $$Safe_root$$s
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the $$Safe_root$$s as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some $$Safe_root$$s - delete the $$Safe_root$$s we marked earlier
					m_p$$Safe_root$$Mgr->DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the $$Safe_root$$s somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_p$$Safe_root$$Mgr->m_nLastEdit = IDS_UNDO_MOVE;
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_p$$Safe_root$$Mgr->m_nLastEdit = IDS_INSERT;
					}

					// Notify the Segment Designer that we changed
					m_p$$Safe_root$$Mgr->OnDataChanged();

					// Update the selection regions to include the selected items
					SelectRegionsFromSelected$$Safe_root$$s();

					// If visible, switch the property sheet to the $$Safe_root$$ property page
					m_p$$Safe_root$$Mgr->OnShowProperties();

					// If it exists, refresh the $$Safe_root$$ property page
					if( m_p$$Safe_root$$Mgr->m_pPropPageMgr )
					{
						m_p$$Safe_root$$Mgr->m_pPropPageMgr->RefreshData();
					}
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move operation to another strip - use the 'Delete' undo text
						m_p$$Safe_root$$Mgr->m_nLastEdit = IDS_DELETE;

						// Notify the Segment Designer that we changed
						m_p$$Safe_root$$Mgr->OnDataChanged();
					}
					else
					{
						// Unselect all items, since the user did a copy operation
						m_p$$Safe_root$$Mgr->UnselectAll();
					}
				}

				// Refresh our strip display
				m_p$$Safe_root$$Mgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all items
		m_p$$Safe_root$$Mgr->UnMark$$Safe_root$$s(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource flag
	m_nStripIsDragDropSource = 0;

	// Return a success or failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::SelectItemsInSelectedRegions

bool C$$Safe_root$$Strip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetNext( pos );

		// Check if this item is within a selection region
		if(m_pSelectedRegions->Contains(p$$Safe_root$$Item->m_lMeasure, p$$Safe_root$$Item->m_lBeat))
		{
			// Check if the item is not selected
			if( !p$$Safe_root$$Item->m_fSelected )
			{
				// $$Safe_root$$ isn't yet selected - select it and set fChanged to true
				p$$Safe_root$$Item->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the item is selected
			if( p$$Safe_root$$Item->m_fSelected )
			{
				// $$Safe_root$$ is selected - deselect it and set fChagned to true
				p$$Safe_root$$Item->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any items
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$Strip::SelectRegionsFromSelected$$Safe_root$$s

void C$$Safe_root$$Strip::SelectRegionsFromSelected$$Safe_root$$s()
{
	// Clear the list of selected regions
	m_pSelectedRegions->Clear();

	// Iterate through the list of items
	POSITION pos = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		C$$Safe_root$$Item* p$$Safe_root$$Item = m_p$$Safe_root$$Mgr->m_lst$$Safe_root$$s.GetNext( pos );

		// Check if the item is selected
		if(p$$Safe_root$$Item->m_fSelected)
		{
			// Add the beat the item is in to the list of selected regions.
			CListSelectedRegion_AddRegion(*m_pSelectedRegions, *p$$Safe_root$$Item);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <staticproppagemanager.h>

class PropPage$$Safe_root$$;

class C$$Safe_root$$PropPageMgr : public CStaticPropPageManager
{
	friend PropPage$$Safe_root$$;
public:
	C$$Safe_root$$PropPageMgr();
	~C$$Safe_root$$PropPageMgr();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	PropPage$$Safe_root$$*			m_pPropPage$$Safe_root$$;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\PropPageLyric.cpp ===
// PropPage$$Safe_root$$.cpp : implementation file
//

#include "stdafx.h"
#include "$$Safe_root$$Item.h"
#include "PropPageMgr.h"
#include "PropPage$$Safe_root$$.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$PropPageMgr constructor/destructor

C$$Safe_root$$PropPageMgr::C$$Safe_root$$PropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize our pointer to NULL
	m_pPropPage$$Safe_root$$ = NULL;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

C$$Safe_root$$PropPageMgr::~C$$Safe_root$$PropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the $$Safe_root$$ property page exists, delete it
	if( m_pPropPage$$Safe_root$$ )
	{
		delete m_pPropPage$$Safe_root$$;
		m_pPropPage$$Safe_root$$ = NULL;
	}

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$PropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$PropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE C$$Safe_root$$PropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_$$SAFE_ROOT$$ ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$PropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE C$$Safe_root$$PropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// If it doesn't exist yet, create the property page
	if( m_pPropPage$$Safe_root$$ == NULL )
	{
		m_pPropPage$$Safe_root$$ = new PropPage$$Safe_root$$();
	}

	// If the property page now exists, add the property page
	if( m_pPropPage$$Safe_root$$ )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPage$$Safe_root$$->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pPropPage$$Safe_root$$->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// C$$Safe_root$$PropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE C$$Safe_root$$PropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a C$$Safe_root$$Item
	C$$Safe_root$$Item* p$$Safe_root$$;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		p$$Safe_root$$ = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&p$$Safe_root$$ ) ) )
	{
		return E_FAIL;
	}

	// Update the property page, if it exists
	if (m_pPropPage$$Safe_root$$ )
	{
		// p$$Safe_root$$ may be NULL, meaning nothing is selected
		m_pPropPage$$Safe_root$$->Set$$Safe_root$$( p$$Safe_root$$ );
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$ property page

IMPLEMENT_DYNCREATE(PropPage$$Safe_root$$, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$ constructor/destructor

PropPage$$Safe_root$$::PropPage$$Safe_root$$(): CPropertyPage(PropPage$$Safe_root$$::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_$$SAFE_ROOT$$_PROPPAGE);
	//{{AFX_DATA_INIT(PropPage$$Safe_root$$)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValid$$Safe_root$$ = FALSE;
	m_fNeedToDetach = FALSE;
}

PropPage$$Safe_root$$::~PropPage$$Safe_root$$()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::DoDataExchange

void PropPage$$Safe_root$$::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPage$$Safe_root$$)
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_$$SAFE_ROOT$$, m_edit$$Safe_root$$);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPage$$Safe_root$$, CPropertyPage)
	//{{AFX_MSG_MAP(PropPage$$Safe_root$$)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_$$SAFE_ROOT$$, OnKillfocusEdit$$Safe_root$$)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$ custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::Set$$Safe_root$$

void PropPage$$Safe_root$$::Set$$Safe_root$$( const C$$Safe_root$$Item* p$$Safe_root$$ )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no $$Safe_root$$s selected, so disable the property page
	if ( p$$Safe_root$$ == NULL )
	{
		m_fValid$$Safe_root$$ = FALSE;
		m_$$Safe_root$$.Clear();
		EnableControls( FALSE );
		return;
	}

	// Update our timeline pointer

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pinter to our Property Page Object
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid $$Safe_root$$
	m_fValid$$Safe_root$$ = TRUE;

		// Copy the information from the new $$Safe_root$$
	m_$$Safe_root$$.Copy( p$$Safe_root$$ );

	long lMaxMeasure, lMaxBeat; // Maximum measure and beat values
	// Get the maximum measure value
	if( m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
	}
	else
	{
		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
										  V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
												  V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		// If the $$Safe_root$$ is not in the last measure
		if( m_$$Safe_root$$.m_lMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, m_$$Safe_root$$.m_lMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the $$Safe_root$$ is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Check if the edit control has a valid window handle.
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_$$Safe_root$$.m_dwBits & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the edit controls
	EnableControls( TRUE );

	// Get the currently displayed text
	CString strTemp;
	m_edit$$Safe_root$$.GetWindowText( strTemp );

	// If it's different from what we were passed or the item was previously invalid, update the display
	if ( !m_fValid$$Safe_root$$ || (p$$Safe_root$$->m_strText != strTemp) )
	{
		m_edit$$Safe_root$$.SetWindowText( p$$Safe_root$$->m_strText );
	}

	// If the item was previously invalid, update the measure and beat display
	if( !m_fValid$$Safe_root$$ )
	{
		SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_$$Safe_root$$.m_lMeasure + 1 );
		SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_$$Safe_root$$.m_lBeat + 1 );
	}
	// Otherwise, check if the values displayed don't match the new ones
	else
	{
		// Get text from measure edit control
		TCHAR tcstrTmp[DIALOG_EDIT_LEN];
		m_editMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		BOOL fTransSuccess;
		long lCurValue = GetDlgItemInt( m_editMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess || (tcstrTmp[0] == NULL) || (lCurValue != m_$$Safe_root$$.m_lMeasure + 1) )
		{
			// Update the displayed measure number
			SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_$$Safe_root$$.m_lMeasure + 1 );
		}


		// Get text from beat edit control
		m_editBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess || (tcstrTmp[0] == NULL) || (lCurValue != m_$$Safe_root$$.m_lBeat + 1) )
		{
			// Update the displayed beat number
			SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_$$Safe_root$$.m_lBeat + 1 );
		}
	}

	// Update the range for the measure spin control
	m_spinMeasure.SetRange( 1, lMaxMeasure );

	// Update the range for the beat spin control
	m_spinBeat.SetRange( 1, lMaxBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$ message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnCreate

int PropPage$$Safe_root$$::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnDestroy

void PropPage$$Safe_root$$::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnInitDialog

BOOL PropPage$$Safe_root$$::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	// Limit the measure number to positive numbers
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Limit the beat number to 1-256
	m_spinBeat.SetRange( 1, 256 );
	m_editBeat.LimitText( 3 );

	// If we have valid information
	if(	m_fValid$$Safe_root$$ )
	{
		// Force update of the controls
		m_fValid$$Safe_root$$ = FALSE;

		// Update the dialog
		Set$$Safe_root$$( &m_$$Safe_root$$ );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnDeltaposSpinBeat

void PropPage$$Safe_root$$::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, m_$$Safe_root$$.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnDeltaposSpinMeasure

void PropPage$$Safe_root$$::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, m_$$Safe_root$$.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::HandleDeltaChange
//
// Generic handler for deltapos changes
void PropPage$$Safe_root$$::HandleDeltaChange( NMHDR* pNMHDR,
									   LRESULT* pResult,
									   long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// If the value changed - update the selected $$Safe_root$$
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;

		// Now, update the object with the new value
		UpdateObject();
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnKillfocusEditBeat

void PropPage$$Safe_root$$::OnKillfocusEditBeat() 
{
	HandleKillFocus( m_spinBeat, m_$$Safe_root$$.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnKillfocusEditMeasure

void PropPage$$Safe_root$$::OnKillfocusEditMeasure() 
{
	HandleKillFocus( m_spinMeasure, m_$$Safe_root$$.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::HandleKillFocus
//
// Generic handler for KillFocus changes
void PropPage$$Safe_root$$::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( 1 );

		// Check if the value changed
		if( 0 != lUpdateVal )
		{
			// Update the item with the new value
			lUpdateVal = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + 1 );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lNewValue - 1 != lUpdateVal )
			{
				// Update the item with the new value
				lUpdateVal = lNewValue - 1;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnKillfocusEdit$$Safe_root$$

void PropPage$$Safe_root$$::OnKillfocusEdit$$Safe_root$$() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get the new text
	CString strText;
	m_edit$$Safe_root$$.GetWindowText( strText );

	// Check if the text is empty
	if( strText.IsEmpty() )
	{
		// Check if the existing text is empty
		if( m_$$Safe_root$$.m_strText != _T("") )
		{
			// Nope - update the $$Safe_root$$ strip manager with the new text
			m_$$Safe_root$$.m_strText = "";
			UpdateObject();
		}
	}
	else
	{
		// Check if the text is different from the existing text.
		if( strText != m_$$Safe_root$$.m_strText )
		{
			// Yep - update the $$Safe_root$$ strip manager with the new text
			m_$$Safe_root$$.m_strText = strText;
			UpdateObject();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::UpdateObject

void PropPage$$Safe_root$$::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		// Update the Property Page Object with the new $$Safe_root$$
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_$$Safe_root$$);
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::EnableControls

void PropPage$$Safe_root$$::EnableControls( BOOL fEnable )
{
	// Check if the Beat edit control exists
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the beat, measure, and text controls with the new window state
	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_edit$$Safe_root$$.EnableWindow( fEnable );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_$$Safe_root$$.m_dwBits & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				m_edit$$Safe_root$$.SetWindowText( strText );
				return;
			}
		}

		// No items are selected, so clear the edit controls
		m_edit$$Safe_root$$.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editMeasure.SetWindowText( NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPage$$Safe_root$$::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void PropPage$$Safe_root$$::OnOK() 
{
	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by $$Safe_root$$StripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_$$SAFE_ROOT$$              101
#define IDR_$$SAFE_ROOT$$MGR                    102
#define IDS_DELETE                      103
#define IDS_PASTE                       104
#define IDS_INSERT                      105
#define IDD_$$SAFE_ROOT$$_PROPPAGE              106
#define IDS_TRACK_NAME                  107
#define IDS_PROPPAGE_GROUP_BITS         108
#define IDS_MULTIPLE_SELECT             109
#define IDS_UNDO_CHANGE                 110
#define IDS_UNDO_MOVE                   111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_STRIP_NAME                  113
#define IDS_DEFAULT_$$SAFE_ROOT$$_TEXT          114
#define IDD_PROPPAGE_GROUP_BITS         200
#define IDC_EDIT_$$SAFE_ROOT$$                  201
#define IDC_EDIT_BEAT                   202
#define IDC_SPIN_BEAT                   203
#define IDC_EDIT_MEASURE                204
#define IDC_SPIN_MEASURE                205
#define IDR_EDITMENU                    206
#define IDM_DRAG_RMENU                  207
#define IDC_CHECK_GROUP1                223
#define IDC_CHECK_GROUP2                224
#define IDC_CHECK_GROUP3                225
#define IDC_CHECK_GROUP4                226
#define IDC_CHECK_GROUP5                227
#define IDC_CHECK_GROUP6                228
#define IDC_CHECK_GROUP7                229
#define IDC_CHECK_GROUP8                230
#define IDC_CHECK_GROUP9                231
#define IDC_CHECK_GROUP10               232
#define IDC_CHECK_GROUP11               233
#define IDC_CHECK_GROUP12               234
#define IDC_CHECK_GROUP13               235
#define IDC_CHECK_GROUP14               236
#define IDC_CHECK_GROUP15               237
#define IDC_CHECK_GROUP16               238
#define IDC_CHECK_GROUP17               239
#define IDC_CHECK_GROUP18               240
#define IDC_CHECK_GROUP19               241
#define IDC_CHECK_GROUP20               242
#define IDC_CHECK_GROUP21               243
#define IDC_CHECK_GROUP22               244
#define IDC_CHECK_GROUP23               245
#define IDC_CHECK_GROUP24               246
#define IDC_CHECK_GROUP25               247
#define IDC_CHECK_GROUP26               248
#define IDC_CHECK_GROUP27               249
#define IDC_CHECK_GROUP28               250
#define IDC_CHECK_GROUP29               251
#define IDC_CHECK_GROUP30               252
#define IDC_CHECK_GROUP31               253
#define IDC_CHECK_GROUP32               254
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        255
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         208
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\root.cpp ===
// $$Safe_root$$StripMgr.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#include "$$Safe_root$$StripMgr.h"
#include <AFXCTL.H>
#include "$$Safe_root$$Mgr.h"

#include <initguid.h>
#include "$$Safe_root$$StripMgr_i.c"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ATL Stuff follows
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_$$Safe_root$$Mgr, C$$Safe_root$$Mgr)
END_OBJECT_MAP()

class C$$Safe_root$$StripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

C$$Safe_root$$StripMgrApp theApp;

BOOL C$$Safe_root$$StripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int C$$Safe_root$$StripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Convert the $$Safe_root$$ Strip Manager's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_$$Safe_root$$Mgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the $$Safe_root$$ Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_$$Safe_root$$Track, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the $$Safe_root$$ Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_$$Safe_root$$Track, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	if ( _Module.RegisterServer(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( !AfxOleUnregisterTypeLib( LIBID_$$SAFE_ROOT$$STRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	// unregisters object, typelib and all interfaces in typelib
	if ( _Module.UnregisterServer() )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\LyricItem.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricMgr.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CLyricItem::CLyricItem( void )
{
	m_pLyricMgr = NULL;

	Clear();
}

CLyricItem::CLyricItem( CLyricMgr* pLyricMgr )
{
	ASSERT( pLyricMgr != NULL );
	m_pLyricMgr = pLyricMgr;

	Clear();
}

CLyricItem::CLyricItem( CLyricMgr* pLyricMgr, const CLyricItem& lyric )
{
	ASSERT( pLyricMgr != NULL );
	m_pLyricMgr = pLyricMgr;

	// Copy the passed-in lyric
	Copy( &lyric );
}

void CLyricItem::Clear()
{
	m_dwTimingFlagsDM = DMUS_PMSGF_TOOL_ATTIME;
	m_mtTimeLogical = 0;
	m_mtTimePhysical = 0;
	m_strText.Empty();

	m_lMeasure = 0;
	m_lBeat = 0;
	m_lTick = 0;
	m_lLogicalMeasure = 0;
	m_lLogicalBeat = 0;

	m_dwBitsUI = 0;
	m_wFlagsUI = 0;
	m_fSelected = FALSE;
}

void CLyricItem::Copy( const CLyricItem* pLyricItem )
{
	ASSERT( pLyricItem != NULL );
	if ( pLyricItem == NULL )
	{
		return;
	}

	if( pLyricItem == this )
	{
		return;
	}

	m_dwTimingFlagsDM = pLyricItem->m_dwTimingFlagsDM;
	m_mtTimeLogical = pLyricItem->m_mtTimeLogical;
	m_mtTimePhysical = pLyricItem->m_mtTimePhysical;
	m_strText = pLyricItem->m_strText;

	m_lMeasure = pLyricItem->m_lMeasure;
	m_lBeat = pLyricItem->m_lBeat;
	m_lTick = pLyricItem->m_lTick;
	m_lLogicalMeasure = pLyricItem->m_lLogicalMeasure;
	m_lLogicalBeat = pLyricItem->m_lLogicalBeat;

	m_dwBitsUI = pLyricItem->m_dwBitsUI;
	m_wFlagsUI = pLyricItem->m_wFlagsUI;
	m_fSelected = pLyricItem->m_fSelected;
}

BOOL CLyricItem::After(const CLyricItem& Lyric)
{
	// Check if this lyric is after the one passed as Lyric.

	// Check if our measure number is greater.
	if( m_lMeasure > Lyric.m_lMeasure )
	{
		// Our measure number is greater - we're after Lyric
		return TRUE;
	}
	// Check if our measure number is equal
	else if( m_lMeasure == Lyric.m_lMeasure )
	{
		// Check if our beat number is greater
		if( m_lBeat > Lyric.m_lBeat )
		{
			// Our beat number is greater - we're after Lyric
			return TRUE;
		}
		// Check if our beat number is equal
		else if( m_lBeat == Lyric.m_lBeat )
		{
			// Check if our tick number is greater
			if( m_lTick > Lyric.m_lTick )
			{
				// Our tick number is greater - we're after the item
				return TRUE;
			}
		}
	}

	// We're either before Lyric, or on the same measure, beat, tick.
	return FALSE;
}

BOOL CLyricItem::Before(const CLyricItem& Lyric)
{
	// Check if this lyric is before the one passed as Lyric.

	// Check if our measure number is lesser.
	if( m_lMeasure < Lyric.m_lMeasure )
	{
		// Our measure number is lesser - we're before Lyric
		return TRUE;
	}
	// Check if our measure number is equal.
	else if( m_lMeasure == Lyric.m_lMeasure )
	{
		// Check if our measure number is lesser.
		if( m_lBeat < Lyric.m_lBeat )
		{
			// Our measure number is lesser - we're before Lyric
			return TRUE;
		}
		// Check if our beat number is equal.
		else if( m_lBeat == Lyric.m_lBeat )
		{
			// Check if our tick number is lesser.
			if( m_lTick < Lyric.m_lTick )
			{
				// Our tick number is lesser - we're before the item
				return TRUE;
			}
		}
	}

	// We're either after Lyric, or on the same measure, beat, tick.
	return FALSE;
}
	
HRESULT CLyricItem::SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction )
{
	ASSERT( m_pLyricMgr != NULL );
	if( m_pLyricMgr == NULL )
	{
		// Will be NULL when CLyricItem used for properties!
		return E_FAIL;
	}

	// Set item's physical time
	MUSIC_TIME mtOrigTimePhysical = m_mtTimePhysical;
	m_mtTimePhysical = mtTimePhysical;

	if( m_pLyricMgr == NULL 
	||  m_pLyricMgr->m_pTimeline == NULL )
	{
		if( nAction == STP_LOGICAL_NO_ACTION )
		{
			return S_OK;
		}
		else
		{
			ASSERT( 0 );
			return E_UNEXPECTED;
		}
	}

	// Set item's measure, beat, tick
	long lMeasure, lBeat, lTick;
	m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
	m_lMeasure = lMeasure;
	m_lBeat = lBeat;
	m_lTick = lTick;

	// Set item's logical time
	switch( nAction )
	{
		case STP_LOGICAL_NO_ACTION:
			// Simply recalc item's logical measure/beat
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			break;

		case STP_LOGICAL_SET_DEFAULT:
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pLyricMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;

		case STP_LOGICAL_ADJUST:
		{
			// Get track GroupBits
			DWORD dwGroupBits = m_pLyricMgr->GetGroupBits();

			// Snap original physical time to number of beats
			long lPhysicalBeats;
			m_pLyricMgr->ClocksToMeasureBeatTick( mtOrigTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Convert logical time to number of beats
			long lLogicalBeats;
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Compute difference between original physical time and original logical time
			long lBeatDiff = lLogicalBeats - lPhysicalBeats;

			// Snap new physical time to number of beats
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + lBeatDiff;
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pLyricMgr->ForceBoundaries( lMeasure, lBeat, 0, &m_mtTimeLogical );
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pLyricMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;
		}

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	// Make sure item's logical time is not less than zero
	if( m_mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		m_mtTimeLogical = 0;
	}
	ASSERT( m_lLogicalMeasure >= 0 );
	ASSERT( m_lLogicalBeat >= 0 );

	return S_OK;
}
	
HRESULT CLyricItem::SetTimeLogical( MUSIC_TIME mtTimeLogical )
{
	ASSERT( m_pLyricMgr != NULL );
	if( m_pLyricMgr == NULL )
	{
		// Will be NULL when CLyricItem used for properties!
		return E_FAIL;
	}

	// Make sure item's logical time is not less than zero
	if( mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		mtTimeLogical = 0;
	}

	// Set item's logical time
	m_mtTimeLogical = mtTimeLogical;

	if( m_pLyricMgr == NULL 
	||  m_pLyricMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Set item's logical measure, beat
	long lTick;
	m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
	m_pLyricMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\private\StripWizard\Template\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\LyricItem.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef __LYRICITEM_H_
#define __LYRICITEM_H_

#include <dmusici.h>

typedef struct _DMUS_IO_LYRIC
{
	MUSIC_TIME	mtTime;		// Time of lyric event
	DWORD		dwMeasure;	// Measure event occurs in
	BYTE		bBeat;		// Beat event occurs in
	BYTE		bPad[3];	// Padding
	DWORD		dwLength;	// Length of text of WCHARS (in # of bytes) that follows the structure
} DMUS_IO_LYRIC;


// m_dwBitsUI
#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002


// m_wFlagsUI
#define RF_TOP_ITEM		0x0001


// Flags for SetTimePhysical()
#define STP_LOGICAL_NO_ACTION	1
#define STP_LOGICAL_SET_DEFAULT	2
#define STP_LOGICAL_ADJUST		3


class CLyricMgr;

class CLyricItem
{
public:
	CLyricItem();	// Only used by classes that embed CLyricItem
	CLyricItem( CLyricMgr* pLyricMgr );
	CLyricItem( CLyricMgr* pLyricMgr, const CLyricItem& );

	void Clear();
	void Copy( const CLyricItem* pLyricItem );

	BOOL After( const CLyricItem& Lyric );
	BOOL Before( const CLyricItem& Lyric );

	HRESULT	SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction );
	HRESULT	SetTimeLogical( MUSIC_TIME mtTimeLogical );

	// Fields that are persisted
	DWORD		m_dwTimingFlagsDM;	// DirectMusic DMUS_PMSGF_TOOL_ flags
	MUSIC_TIME	m_mtTimeLogical;	// Time of measure/beat 
	MUSIC_TIME	m_mtTimePhysical;	// Time of measure/beat/tick
	CString		m_strText;			// Text contained in this lyric event

	// Runtime only fields
	CLyricMgr*	m_pLyricMgr;
    long		m_lMeasure;			// What measure this lyric falls on
    long		m_lBeat;			// What beat this lyric falls on
    long		m_lTick;			// What tick this lyric falls on
    long		m_lLogicalMeasure;	// What measure this lyric belongs to
    long		m_lLogicalBeat;		// What beat this lyric belongs to
	DWORD		m_dwBitsUI;			// Various bits
	WORD		m_wFlagsUI;			// Various flags
	BOOL		m_fSelected;		// This lyric is currently selected.
};

#endif // __LYRICITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\LyricMgr.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-2001 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// LyricMgr.h : Declaration of the CLyricMgr

#ifndef __LYRICMGR_H_
#define __LYRICMGR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"		// main symbols
#include "LyricStripMgr.h"
#include "LyricItem.h"
#include "selectedregion.h"
#include "BaseMgr.h"
#include "SegmentGUIDs.h"

#define FOURCC_LYRIC_LIST					mmioFOURCC('l','y','r','l')
#define FOURCC_LYRIC_ITEM					mmioFOURCC('l','y','r','c')
#define DMUS_FOURCC_COPYPASTE_UI_CHUNK		mmioFOURCC('c','p','c','u')

#define MAX_TICK (DMUS_PPQ << 1)

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_ENABLED)

class CLyricMgr;
class CLyricStrip;
class CLyricItem;
class CDllJazzDataObject;
interface IDirectMusicTrack;

void	EmptyLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list );
HRESULT LoadLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream, CLyricMgr* pLyricMgr );
HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CLyricMgr* pLyricMgr, CLyricItem** ppItem );
HRESULT SaveLyricList(	CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream);
HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem );
void NormalizeLyricList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CLyricItem*>& list, long lBeatOffset );
HRESULT GetBoundariesOfLyrics( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long & lStartTime, long & lEndTime, CTypedPtrList<CPtrList, CLyricItem*>& list);


struct ioCopyPasteUI
{
	ioCopyPasteUI()
	{
		lTick = 0;
	}

	long	lTick;		// Tick offset of first item in list
};


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr
class ATL_NO_VTABLE CLyricMgr : 
	public CBaseMgr,
	public CComCoClass<CLyricMgr, &CLSID_LyricMgr>,
	public ILyricMgr
{
friend CLyricStrip;

public:
	CLyricMgr();
	~CLyricMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_LYRICMGR)

BEGIN_COM_MAP(CLyricMgr)
	COM_INTERFACE_ENTRY_IID(IID_ILyricMgr,ILyricMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides
	virtual STDMETHODIMP SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// ILyricMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes(); // Returns true if anything changed
	void	RecomputeMeasureBeats();
	
	void DeleteSelectedLyrics();
	HRESULT SaveSelectedLyrics(LPSTREAM, CLyricItem* pLyricAtDragPoint);
	HRESULT	SaveSelectedLyrics(IStream* pStream, long lBeatOffset);
	HRESULT LoadLyricItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CLyricItem** ppItem );
	HRESULT SaveLyricItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem );

// general helpers
	void	MarkSelectedLyrics(DWORD flags);
	void	UnMarkLyrics(DWORD flags);
	void	DeleteMarked(DWORD flags);
	void	UnselectAll();
	void	SelectAll();
	bool	RemoveItem( CLyricItem* pItem );
	void	InsertByAscendingTime(CLyricItem *pLyric, BOOL fPaste);
	MUSIC_TIME GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick );
	CLyricItem* FirstSelectedLyric();
	bool	DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd );
	HRESULT CycleItems( long lXPos );

public:
	HRESULT	ClocksToMeasureBeatTick( MUSIC_TIME mTime, long* plMeasure, long* plBeat, long* plTick );
	HRESULT	MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmTime );
	HRESULT ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime );
	DWORD	GetGroupBits();
	bool    IsRefTimeTrack();

protected:
	CTypedPtrList<CPtrList, CLyricItem*> m_lstLyrics;
	CLyricItem					m_SelectedLyricItem;

	CLyricStrip*				m_pLyricStrip;

};


class CLyricStrip :
	public CBaseStrip
{
friend CLyricMgr;

public:
	CLyricStrip( CLyricMgr* pLyricMgr );
	~CLyricStrip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// General helper overrides
	HRESULT	PostRightClickMenu( POINT pt );

protected:
	void	UnselectGutterRange( void );
	BOOL	CanCycle();

// IDropTarget helpers
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long position);
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos);

// Overrides of CBaseStrip
	bool	SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime);
	bool	IsSelected(); // Returns true if any items are selected
	bool	IsEmpty(); // Returns false if there are any items

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);

	CLyricMgr*			m_pLyricMgr;

	CLyricItem* GetLyricFromPoint( long lPos );
	CLyricItem* GetLyricFromMeasureBeat( long lMeasure, long lBeat );
	bool SelectItemsInSelectedRegions();
	void SelectRegionsFromSelectedLyrics();	
	CLyricItem* GetTopItemFromMeasureBeat( long lMeasure, long lBeat );
	CLyricItem* GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	CLyricItem* GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	void AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );

	UINT		m_cfLyricList;			// Clipboard format
	bool		m_fLeftMouseDown;
	CLyricItem*	m_pLyricItemToToggle;
};

inline void CListSelectedRegion_AddRegion(CListSelectedRegion& csrList, CLyricItem& lyric)
{
	CMusicTimeConverter cmtBeg(lyric.m_lMeasure, lyric.m_lBeat, csrList.Timeline(), csrList.GroupBits());
	CMusicTimeConverter cmtEnd = cmtBeg;
	cmtEnd.AddOffset(0,1, csrList.Timeline(), csrList.GroupBits());
	CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
	csrList.AddHead(psr);
}


#endif //__LYRICMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\LyricMgr.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// LyricMgr.cpp : implementation file
//

/*--------------
@doc LYRICSAMPLE
--------------*/

#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricMgr.h"
#include "PropPageMgr.h"
#include <dmusicf.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Set information about this strip manager
const CLSID CLyricMgr::m_clsid = CLSID_DirectMusicLyricsTrack;
const DWORD CLyricMgr::m_ckid = NULL;
const DWORD CLyricMgr::m_fccType = DMUS_FOURCC_LYRICSTRACK_LIST;

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr constructor/destructor 

CLyricMgr::CLyricMgr() : CBaseMgr()
{
	// Create a LyricStrip
	m_pLyricStrip = new CLyricStrip(this);
	ASSERT( m_pLyricStrip );

	// Copy the pointer to the base strip manager
	m_pBaseStrip = m_pLyricStrip;

	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
}

CLyricMgr::~CLyricMgr()
{
	// Clean up our references
	if( m_pLyricStrip )
	{
		m_pLyricStrip->Release();
		m_pLyricStrip = NULL;
	}

	// Clear the base strip manager's pointer to the strip
	m_pBaseStrip = NULL;

	// Delete all the lyrics in m_lstLyrics
	EmptyLyricList( m_lstLyrics );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr ILyricMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::IsMeasureBeatOpen
// Returns S_OK if the specified measure and beat is empty.
// Returns S_FALSE if the specified measure and bear already has a lyric

HRESULT STDMETHODCALLTYPE CLyricMgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric
		CLyricItem* pLyricItem;
		pLyricItem = m_lstLyrics.GetNext( pos );

		// Since the list is sorted, if this lyric is later than the specified time, we can exit
		if( pLyricItem->m_lMeasure > lMeasure )
		{
			// The measure and beat are empty
			return S_OK;
		}
		// Check if the measure and beat values match
		else if( pLyricItem->m_lMeasure == lMeasure &&
				 pLyricItem->m_lBeat == lBeat )
		{
			// They match - return that the measure and beat are already occupied
			return S_FALSE;
		}
	}

	// The measure and beat are empty
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CLyricMgr::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Fix measure/beat of all lyrics
		RecomputeMeasureBeats();
		SyncWithDirectMusic();

		m_pTimeline->StripInvalidateRect( m_pLyricStrip, NULL, TRUE );
		return S_OK;
	}

	// We don't handle whichever notification was passed to us
	return CBaseMgr::OnUpdate( rguidType, dwGroupBits, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CLyricMgr::SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
		case SMP_DMUSIOTRACKEXTRASHEADER:
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
				if( pioTrackExtrasHeader == NULL )
				{
					return E_POINTER;
				}

				m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
			}
			return S_OK;
	}

	// Let CBaseMgr handle
	return CBaseMgr::SetStripMgrProperty( stripMgrProperty, variant );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::Load

HRESULT CLyricMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing lyrics
	EmptyLyricList( m_lstLyrics );

	// Variables used when loading the Lyric track
	MMCKINFO ckTrack;
	MMCKINFO ckLyricList;
	MMCKINFO ckItem;
	CLyricItem* pNewItem;
	DWORD dwByteCount;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == 0 )
	{
		switch( ckTrack.ckid )
		{
			case FOURCC_LIST:
				switch( ckTrack.fccType )
				{
					// DX8 format
					case DMUS_FOURCC_LYRICSTRACK_LIST:
						while( pIRiffStream->Descend( &ckLyricList, &ckTrack, 0 ) == 0 )
						{
							switch( ckLyricList.ckid )
							{
								case FOURCC_LIST:
									switch( ckLyricList.fccType )
									{
										case DMUS_FOURCC_LYRICSTRACKEVENTS_LIST:
											while( pIRiffStream->Descend( &ckItem, &ckLyricList, 0 ) == 0 )
											{
												switch( ckItem.ckid )
												{
													case FOURCC_LIST:
														switch( ckItem.fccType )
														{
															case DMUS_FOURCC_LYRICSTRACKEVENT_LIST:
																hr = LoadLyricItem( pIRiffStream, &ckItem, &pNewItem );
																if( FAILED ( hr ) )
																{
																	goto ON_ERROR;
																}
																InsertByAscendingTime( pNewItem, FALSE );
																break;
														}
														break;
												}

												pIRiffStream->Ascend( &ckItem, 0 );
											}
											break;
									}
									break;
							}

							pIRiffStream->Ascend( &ckLyricList, 0 );
						}
						break;

					// DX7 format
					case FOURCC_LYRIC_LIST:
						while( pIRiffStream->Descend( &ckLyricList, &ckTrack, 0 ) == 0 )
						{
							switch( ckLyricList.ckid )
							{
								case FOURCC_LYRIC_ITEM:
								{
									DMUS_IO_LYRIC iLyric;

									// Read in a Lyric item structure
									hr = pIStream->Read( &iLyric, sizeof(DMUS_IO_LYRIC), &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != sizeof(DMUS_IO_LYRIC) )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									// Create a new item
									CLyricItem* pItem = new CLyricItem( this );
									if( pItem == NULL )
									{
										hr = E_OUTOFMEMORY;
										goto ON_ERROR;
									}

									// Read the text from the stream into pItem->m_strText
									ReadMBSfromWCS( pIStream, iLyric.dwLength, &pItem->m_strText );

									// Initialize members of CLyricItem
									pItem->m_lMeasure = iLyric.dwMeasure;
									pItem->m_lBeat = iLyric.bBeat;
									pItem->m_lTick = 0;
									pItem->m_mtTimePhysical = iLyric.mtTime;
									if( m_pTimeline )
									{
										MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, 0, &pItem->m_mtTimeLogical );
									}
									else
									{
										pItem->m_mtTimeLogical = iLyric.mtTime;
									}

									// Insert the item into the list, if one is not already there
									if( IsMeasureBeatOpen( pItem->m_lMeasure, pItem->m_lBeat ) == S_OK )
									{
										// Nothing exists in the beat, go ahead and insert the item
										InsertByAscendingTime( pItem, FALSE );
									}
									else
									{
										// Something already exists, delete the item and don't insert it
										delete pItem;
									}
								}
								break;
							}

							// Ascend out of the chunk in the Lyric list chunk
							pIRiffStream->Ascend( &ckLyricList, 0 );
						}
						break;

				}
				break;
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	SyncWithDirectMusic();

ON_ERROR:
	// Release the RIFF stream pointer
	pIRiffStream->Release();

	// Return the success/failure status
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::LoadLyricItem

HRESULT CLyricMgr::LoadLyricItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CLyricItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	HRESULT			hr = E_FAIL;

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CLyricItem* pNewItem = new CLyricItem( this );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Load the Lyric item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
			{
				DMUS_IO_LYRICSTRACK_EVENTHEADER iEventHeader;

				// Read in the Lyric item's header structure
				dwSize = min( sizeof( DMUS_IO_LYRICSTRACK_EVENTHEADER ), ck.cksize );
				hr = pIStream->Read( &iEventHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_dwTimingFlagsDM = iEventHeader.dwTimingFlags;
				pNewItem->m_mtTimeLogical = iEventHeader.lTimeLogical;
				pNewItem->m_mtTimePhysical = iEventHeader.lTimePhysical;
				pNewItem->SetTimePhysical( iEventHeader.lTimePhysical, STP_LOGICAL_NO_ACTION );
				break;
			}

			case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strText );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SaveLyricItem

HRESULT CLyricMgr::SaveLyricItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_LYRICSTRACKEVENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_LYRICSTRACK_EVENTHEADER oEventHeader;
		ZeroMemory( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) );

		// Fill in the members of the DMUS_IO_LYRICSTRACK_EVENTHEADER structure
		oEventHeader.dwFlags = 0;	// Reserved - must be zero
		oEventHeader.dwTimingFlags = pItem->m_dwTimingFlagsDM;		
		oEventHeader.lTimeLogical = pItem->m_mtTimeLogical;
		oEventHeader.lTimePhysical = pItem->m_mtTimePhysical;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write out the Lyric text as a Wide Character String
		hr = SaveMBStoWCS( pIStream, &pItem->m_strText);
		if( FAILED( hr ) )
		{
			// Handle I/O errors by return an error code
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::Save

HRESULT CLyricMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Lyric track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Lyric list isn't empty, save it
	if ( !m_lstLyrics.IsEmpty() )
	{
		// Create a LIST chunk to store the Lyric data
		MMCKINFO ckTrack;
		ckTrack.fccType = DMUS_FOURCC_LYRICSTRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckLyricList;
		ckLyricList.fccType = DMUS_FOURCC_LYRICSTRACKEVENTS_LIST;
		if( pIRiffStream->CreateChunk( &ckLyricList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the Lyric list
		POSITION pos = m_lstLyrics.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

			// Save each item
			hr = SaveLyricItem( pIRiffStream, pLyricItem );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}

		// Ascend out of the Lyric LIST chunk.
		pIRiffStream->Ascend( &ckLyricList, 0 );

		// Ascend out of the Lyric track LIST chunk.
		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( fClearDirty )
	{
		m_fDirty = false;
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::GetData

// This method is called by CLyricPropPageMgr to get data to send to the
// Lyric property page.
// The CLyricStrip::GetData() method is called by CGroupBitsPropPageMgr
// to get the strip's properties (currently just Group Bits)
HRESULT STDMETHODCALLTYPE CLyricMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the ppData pointer
	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Flag set to TRUE if more than one lyric is selected
	BOOL fMultipleSelect = FALSE;

	// Initialize the pointer to the first selected lyric to NULL
	CLyricItem* pFirstSelectedLyricItem = NULL;

	// Start iterating through the lyric list
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric
		CLyricItem* pLyricItem;
		pLyricItem = m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// Lyric is selected - save a pointer to it in pFirstSelectedLyricItem
			pFirstSelectedLyricItem = pLyricItem;

			// Now, continue through the list to see if any other lyric are selected
			while( pos )
			{
				// Get a pointer to each lyric
				pLyricItem = m_lstLyrics.GetNext( pos );

				// Check if the lyric is selected
				if ( pLyricItem->m_fSelected )
				{
					// More than one lyric is selected - set fMultipleSelect to TRUE
					// and break out of this loop
					fMultipleSelect = TRUE;
					break;
				}
			}

			// Found a selected lyric - break out of the main while loop
			break;
		}
	}

	// If at least one lyric is selected
	if( pFirstSelectedLyricItem )
	{
		// Copy the first selected lyric to a CLyricItem class
		m_SelectedLyricItem.Copy( pFirstSelectedLyricItem );

		// If more than one lyric was selected, set UD_MULTIPLESELECT
		if( fMultipleSelect )
		{
			m_SelectedLyricItem.m_dwBitsUI |= UD_MULTIPLESELECT;
		}
		else
		{
			// Only one lyric selected, clear UD_MULTIPLESELECT
			m_SelectedLyricItem.m_dwBitsUI &= ~UD_MULTIPLESELECT;
		}

		// Set the passed in pointer to point to the CLyricItem class
		*ppData = &m_SelectedLyricItem;

		// Return a success code
		return S_OK;
	}

	// Nothing selected, so clear the passed in pointer
	*ppData = NULL;

	// Return a success code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SetData

// This method is called by CLyricPropPageMgr in response to user actions
// in the Lyric Property page.  It changes the currenly selected Lyric. 
HRESULT STDMETHODCALLTYPE CLyricMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the pData pointer
	if ( pData == NULL )
	{
		return E_POINTER;
	}

	// Get a pointer to the first selected lyric.
	CLyricItem* pLyricItem = FirstSelectedLyric();

	// If a selected lyric was found
	if ( pLyricItem )
	{
		// Convert the passed-in pointer to a CLyricItem*
		CLyricItem* pNewLyric = static_cast<CLyricItem*>(pData);

		// m_mtTimePhysical
		if( (pNewLyric->m_lTick != pLyricItem->m_lTick)
		||  (pNewLyric->m_lBeat != pLyricItem->m_lBeat) 
		||  (pNewLyric->m_lMeasure != pLyricItem->m_lMeasure) )
		{
			MUSIC_TIME mtNewTimePhysical;
			if( SUCCEEDED ( ForceBoundaries( pNewLyric->m_lMeasure, pNewLyric->m_lBeat, pNewLyric->m_lTick, &mtNewTimePhysical ) ) )
			{
				if( mtNewTimePhysical != pLyricItem->m_mtTimePhysical )
				{
					m_nLastEdit = IDS_UNDO_MOVE;
					pLyricItem->SetTimePhysical( mtNewTimePhysical, STP_LOGICAL_ADJUST );

					// Remove the LyricItem from the list
					CLyricItem* pLyricTmp;
					POSITION pos2, pos1 = m_lstLyrics.GetHeadPosition();
					while( pos1 )
					{
						pos2 = pos1;
						pLyricTmp = m_lstLyrics.GetNext( pos1 );
						if ( pLyricTmp == pLyricItem )
						{
							m_lstLyrics.RemoveAt( pos2 );
							break;
						}
					}

					// Re-add the lyric at its new position - this will overwrite any existing
					// lyric at this position
					InsertByAscendingTime( pLyricItem, FALSE );

					// Clear all selections
					m_pLyricStrip->m_pSelectedRegions->Clear();

					// Select just the changed lyric
					CListSelectedRegion_AddRegion(*m_pLyricStrip->m_pSelectedRegions, *pLyricItem);
				}
			}
		}

		// m_mtTimeLogical
		else if( pNewLyric->m_lLogicalMeasure != pLyricItem->m_lLogicalMeasure
			 ||  pNewLyric->m_lLogicalBeat != pLyricItem->m_lLogicalBeat )
		{
			MUSIC_TIME mtNewTimeLogical;
			if( SUCCEEDED ( ForceBoundaries( pNewLyric->m_lLogicalMeasure, pNewLyric->m_lLogicalBeat, 0, &mtNewTimeLogical ) ) )
			{
				if( mtNewTimeLogical != pLyricItem->m_mtTimeLogical )
				{
					m_nLastEdit = IDS_UNDO_LOGICAL_TIME;
					pLyricItem->SetTimeLogical( mtNewTimeLogical );
				}
			}
		}

		// m_strText
		else if( pNewLyric->m_strText != pLyricItem->m_strText )
		{
			// Update the lyric's text
			pLyricItem->m_strText = pNewLyric->m_strText;

			// We just changed the lyric
			m_nLastEdit = IDS_UNDO_CHANGE;
		}

		// m_dwTimingFlagsDM
		else if( pNewLyric->m_dwTimingFlagsDM != pLyricItem->m_dwTimingFlagsDM )
		{
			// Update the item's flags
			pLyricItem->m_dwTimingFlagsDM = pNewLyric->m_dwTimingFlagsDM;

			// We just changed the item
			m_nLastEdit = IDS_UNDO_CHANGE_TIMING;
		}

		// Nothing changed
		else
		{
			// Return a success code saying that nothing happened
			return S_FALSE;
		}

		// Redraw the lyric strip
		m_pTimeline->StripInvalidateRect( m_pLyricStrip, NULL, TRUE );

		// Let our hosting editor know about the changes
		OnDataChanged();

		// Refresh the property page with new values
		m_pPropPageMgr->RefreshData();

		// Sync track with DirectMusic
		SyncWithDirectMusic();

		return S_OK;
	}
	// No lyrics selected - nothing to change
	else
	{
		// Return a success code saying that nothing happened
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CLyricMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new Lyric property page manager
		CLyricPropPageMgr* pPPM = new CLyricPropPageMgr( this );

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Return a success code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::DeleteSelectedLyrics

void CLyricMgr::DeleteSelectedLyrics()
{
	// Start iterating through the list of lyrics
	POSITION pos1 = m_lstLyrics.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos1 );

		// Check if the current lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// This lyric is selected, remove it from the list
			m_lstLyrics.RemoveAt( pos2 );

			// Now, delete this lyric
			delete pLyricItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SaveSelectedLyrics

HRESULT CLyricMgr::SaveSelectedLyrics(LPSTREAM pIStream, CLyricItem* pLyricAtDragPoint)
{
	// if pLyricAtDragPoint is valid, set mtOffset and dwMeasureOffset so that the time pLyricAtDragPoint is 0.
	// if pLyricAtDragPoint is NULL, set mtOffset and dwMeasureOffset so that the time of the first Lyric is 0.

	// Verify pIStream is valid
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// If the Lyric list has anything in it, look for selected Lyrics
	if ( !m_lstLyrics.IsEmpty() )
	{
		// Initialize the beat offset to an invalid value
		long lBeatOffset = -1;
		
		// If pLyricAtDragPoint is valid, just use the measure and beat information from it
		if( pLyricAtDragPoint )
		{
			// Verify that this lyric is selected
			ASSERT( pLyricAtDragPoint->m_fSelected );

			// Compute how many beats from the start it is
			MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, pLyricAtDragPoint->m_lMeasure, pLyricAtDragPoint->m_lBeat, lBeatOffset );
		}
		// Otherwise look for the first selected lyric
		else
		{
			POSITION pos = m_lstLyrics.GetHeadPosition();
			while( pos )
			{
				CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );
				if ( pLyricItem->m_fSelected )
				{
					// Found a selected lyric - compute how many beats from the start it is
					MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, pLyricItem->m_lMeasure, pLyricItem->m_lBeat, lBeatOffset );
					break;
				}
			}
		}

		// pLyricAtDragPoint is NULL and there are no selected lyrics - return with S_FALSE
		if ( lBeatOffset == -1 )
		{
			return S_FALSE;
		}

		// Now, actually save the lyrics
		return SaveSelectedLyrics( pIStream, lBeatOffset );
	}
	else
	{
		return S_FALSE; // Nothing in the list
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::MarkSelectedLyrics

// ORs dwFlags with the m_dwBitsUI of each selected lyric item
void CLyricMgr::MarkSelectedLyrics( DWORD dwFlags )
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// It's selected - update m_dwBitsUI
			pLyricItem->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::DeleteMarked

// deletes lyrics marked by given flag
void CLyricMgr::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of lyrics
	POSITION pos1 = m_lstLyrics.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this lyric
		if ( pLyricItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the lyric
			m_lstLyrics.RemoveAt( pos2 );

			// Now, delete it
			delete pLyricItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::UnMarkLyrics

// unmarks flag m_dwUndermined field CLyricItems in list
void CLyricMgr::UnMarkLyrics( DWORD dwFlags )
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each lyric
		m_lstLyrics.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::UnselectAll

void CLyricMgr::UnselectAll()
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each lyric
		m_lstLyrics.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_pLyricStrip->m_pSelectedRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SelectAll

void CLyricMgr::SelectAll()
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Set the selection flag for each lyric
		m_lstLyrics.GetNext( pos )->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::FirstSelectedLyric

CLyricItem* CLyricMgr::FirstSelectedLyric()
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// Lyric is selected, return a pointer to it
			return pLyricItem;
		}
	}

	// No lyrics are selected, return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::InsertByAscendingTime

void CLyricMgr::InsertByAscendingTime( CLyricItem *pLyricToInsert, BOOL fPaste )
{
	// Ensure the pLyricToInsert pointer is valid
	if( pLyricToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CLyricItem* pItem;
	POSITION posCurrent, posNext = m_lstLyrics.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pItem = m_lstLyrics.GetNext( posNext );

		if( fPaste )
		{
			if( pItem->m_mtTimePhysical == pLyricToInsert->m_mtTimePhysical )
			{
				// Replace item
				m_lstLyrics.InsertBefore( posCurrent, pLyricToInsert );
				m_lstLyrics.RemoveAt( posCurrent );
				delete pItem;
				return;
			}
		}

		if( pItem->m_mtTimePhysical > pLyricToInsert->m_mtTimePhysical )
		{
			// insert before posCurrent (which is the position of pItem)
			m_lstLyrics.InsertBefore( posCurrent, pLyricToInsert );
			return;
		}
	}

	// pLyricToInsert is later than all items in the list, add it at the end of the list
	m_lstLyrics.AddTail( pLyricToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::RemoveItem

bool CLyricMgr::RemoveItem( CLyricItem* pItem )
{
	// Find the given item
	POSITION posToRemove = m_lstLyrics.Find( pItem, NULL );

	// If item wasn't found, return false
	if( posToRemove == NULL )
	{
		return false;
	}

	// Remove the item from the list - the caller must delete it
	m_lstLyrics.RemoveAt( posToRemove );

	// Return true since we found the item
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::RecomputeMeasureBeats

void CLyricMgr::RecomputeMeasureBeats()
{
	// Recompute measure/beat of all items
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		CLyricItem* pItem = m_lstLyrics.GetNext( pos );

		if( ((pItem->m_lMeasure > 0) || (pItem->m_lBeat > 0))
		&&  pItem->m_lTick == 0 
		&&  pItem->m_mtTimePhysical == 0 )
		{
			// Should only happen when loading pre-release DX7 files
			MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lTick, &pItem->m_mtTimePhysical );  
		}

		pItem->SetTimePhysical( pItem->m_mtTimePhysical, STP_LOGICAL_ADJUST );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::GetNextGreatestUniqueTime

MUSIC_TIME CLyricMgr::GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick )
{
	DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime;

	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		CLyricItem* pItem = m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}

		MeasureBeatTickToClocks( pItem->m_lMeasure, 0, 0, &mtTime );
		m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig );
		if( pItem->m_lBeat > dmTimeSig.bBeatsPerMeasure )
		{
			break;
		}

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			lTick = pItem->m_lTick + 1;

			// Take care of measure/beat rollover
			MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );  
		}
	}

	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::RecomputeTimes

bool CLyricMgr::RecomputeTimes()
{
	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;
	long lTick;

	bool fChanged = false;

	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Save our current position
		POSITION pos2 = pos;

		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

		// Make sure measure and beat are valid
		if( pLyricItem->m_lMeasure >= 0
		&&  pLyricItem->m_lBeat >= 0 )
		{
			// Using the lyric's current measure and beat settings, determine which measure and beat
			// the lyric will end up on
			MeasureBeatTickToClocks( pLyricItem->m_lMeasure, pLyricItem->m_lBeat, pLyricItem->m_lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 

			// Check if either the measure, beat or tick of the lyric changed
			if( pLyricItem->m_mtTimePhysical != mtTime
			||	pLyricItem->m_lMeasure != lMeasure
			||	pLyricItem->m_lBeat != lBeat
			||	pLyricItem->m_lTick != lTick )
			{
				// Remove the lyric from the list of lyrics
				m_lstLyrics.RemoveAt( pos2 );

				// The measure the lyric is in changed
				if( pLyricItem->m_lMeasure != lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// Lyrics on beat 7 would end up on next measure's beat 3
					while( pLyricItem->m_lMeasure != lMeasure )
					{
						// Keep moving back a beat until the measure does not change
						MeasureBeatTickToClocks( lMeasure, --lBeat, lTick, &mtTime );  
						ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 
					}
				}

				mtTime = GetNextGreatestUniqueTime( lMeasure, lBeat, lTick ); 
				pLyricItem->SetTimePhysical( mtTime, STP_LOGICAL_ADJUST );
				fChanged = TRUE;

				InsertByAscendingTime( pLyricItem, FALSE );
			}
			else
			{
				// Recompute logical time measure/beat
				pLyricItem->SetTimeLogical( pLyricItem->m_mtTimeLogical );
			}
		}
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::DeleteBetweenMeasureBeats

bool CLyricMgr::DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd )
{
	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current lyric
		CLyricItem* pItem = m_lstLyrics.GetNext(pos);

		// Check if the item's measure value is before the start measure
		if( pItem->m_lMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( pItem->m_lMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat > lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item
		m_lstLyrics.RemoveAt(posTemp);
		delete pItem;
		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::CycleItems

HRESULT CLyricMgr::CycleItems( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		CLyricItem* pFirstItem = NULL;
		CLyricItem* pSecondItem = NULL;
		CLyricItem* pItem;

		hr = E_FAIL;

		POSITION pos = m_lstLyrics.GetHeadPosition();
		while( pos )
		{
			pItem = m_lstLyrics.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( pFirstItem == NULL )
				{
					pFirstItem = pItem;
				}
				else if( pSecondItem == NULL )
				{
					pSecondItem = pItem;
				}

				if( pItem->m_wFlagsUI & RF_TOP_ITEM )
				{
					if( pos )
					{
						// Cycle to next Routine if on same measure/beat
						CLyricItem* pNextItem = m_lstLyrics.GetNext( pos );

						if( pNextItem->m_lMeasure == lMeasure
						&&  pNextItem->m_lBeat == lBeat )
						{
							UnselectAll();
							pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
							pNextItem->m_fSelected = TRUE;
							pNextItem->m_wFlagsUI |= RF_TOP_ITEM;
							hr = S_OK;
							break;
						}
					}

					// Cycle to first Routine on same measure/beat
					UnselectAll();
					pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
					break;
				}
			}

			if( pItem->m_lMeasure > lMeasure
			||  pos == NULL )
			{
				UnselectAll();
				if( pSecondItem )
				{
					pSecondItem->m_fSelected = TRUE;
					pSecondItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				else if( pFirstItem )
				{
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				break;
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Update the selection regions to include just this selected item
		m_pLyricStrip->SelectRegionsFromSelectedLyrics();

		// Redraw the Lyric strip
		m_pTimeline->StripInvalidateRect( m_pLyricStrip, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SaveSelectedLyrics

HRESULT CLyricMgr::SaveSelectedLyrics( IStream* pStream, long lBeatOffset )
// save selected lyrics and adjust by "offset"
{
	// Verify that the pStream pointer is valid
	if(pStream == NULL)
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Create a list to store the lyrics to save in
	CTypedPtrList<CPtrList, CLyricItem*> lstLyricsToSave;

	// Iterate throught the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each lyric
		CLyricItem* pLyric = m_lstLyrics.GetNext(pos);

		// Check if the lyric is selected
		if( pLyric->m_fSelected )
		{
			// Add the lyric to the list of lyrics to save
			lstLyricsToSave.AddTail(new CLyricItem(*pLyric));
		}
	}


	//check that anything is selected
	if( lstLyricsToSave.IsEmpty() )
	{
		return S_FALSE;
	}

	// For each lyric in lstLyricsToSave, convert to a number of beats and subtract lBeatOffset
	NormalizeLyricList( m_pTimeline, m_dwGroupBits, lstLyricsToSave, lBeatOffset );

	// Save the list of lyrics into pStream
	HRESULT hr = SaveLyricList( lstLyricsToSave, pStream );

	// Empty the temporary list of lyrics
	EmptyLyricList(lstLyricsToSave);

	// Return whether or not the save succeeded
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// NormalizeLyricList

void NormalizeLyricList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CLyricItem*>& list, long lBeatOffset )
{
	long lBeat;

	// Iterate through the list of lyrics
	POSITION pos = list.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric
		CLyricItem* pLyric = list.GetNext( pos );

		// This method only called for drag/drop and cut/copy/paste
		// so it is safe to mess with the values that are stored in time fields

		// Use m_mtTimePhysical to store beat offset 
		MeasureBeatToBeats( pITimeline, dwGroupBits, 0, pLyric->m_lMeasure, pLyric->m_lBeat, lBeat );
		pLyric->m_mtTimePhysical = lBeat - lBeatOffset;

		// Use m_mtTimeLogical to store beat offset 
		MeasureBeatToBeats( pITimeline, dwGroupBits, 0, pLyric->m_lLogicalMeasure, pLyric->m_lLogicalBeat, lBeat );
		pLyric->m_mtTimeLogical = lBeat - lBeatOffset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SaveListItem

HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_LYRICSTRACKEVENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_LYRICSTRACK_EVENTHEADER oEventHeader;
		ZeroMemory( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) );

		// Fill in the members of the DMUS_IO_LYRICSTRACK_EVENTHEADER structure
		oEventHeader.dwFlags = 0;	// Reserved - must be zero
		oEventHeader.dwTimingFlags = pItem->m_dwTimingFlagsDM;		
		oEventHeader.lTimePhysical = pItem->m_mtTimePhysical;
		oEventHeader.lTimeLogical = pItem->m_mtTimeLogical;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioCopyPasteUI oCopyPasteUI;
		ZeroMemory( &oCopyPasteUI, sizeof(ioCopyPasteUI) );

		// Fill in the members of the DMUS_IO_LYRICSTRACK_EVENTHEADER structure
		oCopyPasteUI.lTick = pItem->m_lTick;	// Need to save tick offset

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oCopyPasteUI, sizeof(ioCopyPasteUI), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioCopyPasteUI) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write out the Lyric text as a Wide Character String
		hr = SaveMBStoWCS( pIStream, &pItem->m_strText );
		if( FAILED( hr ) )
		{
			// Handle I/O errors by return an error code
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// SaveLyricList

HRESULT SaveLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream )
{
	// Try and allocate an IDMUSProdRIFFStream from the IStream pointer
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Couldn't allocate an IDMUSProdRIFFStream, return a failure code
		return hr;
	}

	// If the Lyrics list isn't empty, save it
	if( !list.IsEmpty() )
	{
		// Create a LIST chunk to store the Lyrics track data
		MMCKINFO ckTrack;
		ckTrack.fccType = DMUS_FOURCC_LYRICSTRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckLyricList;
		ckLyricList.fccType = DMUS_FOURCC_LYRICSTRACKEVENTS_LIST;
		if( pIRiffStream->CreateChunk( &ckLyricList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the Lyric list
		POSITION pos = list.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CLyricItem* pItem = list.GetNext( pos );

			// Save each item
			hr = SaveListItem( pIRiffStream, pItem );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		// Ascend out of the Lyric LIST chunk.
		pIRiffStream->Ascend( &ckLyricList, 0 );

		// Ascend out of the Lyrics track LIST chunk.
		pIRiffStream->Ascend( &ckTrack, 0 );
	}

ON_ERROR:
	// Release the IDMUSProdRIFFStream interface
	pIRiffStream->Release();

	// Return the success or failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadListItem

HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent,
					  CLyricMgr* pLyricMgr, CLyricItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	HRESULT			hr = E_FAIL;

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CLyricItem* pNewItem = new CLyricItem( pLyricMgr );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Load the Lyric item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
			{
				DMUS_IO_LYRICSTRACK_EVENTHEADER iEventHeader;

				// Read in the Lyric item's header structure
				dwSize = min( sizeof( DMUS_IO_LYRICSTRACK_EVENTHEADER ), ck.cksize );
				hr = pIStream->Read( &iEventHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_dwTimingFlagsDM = iEventHeader.dwTimingFlags;

				pNewItem->m_mtTimePhysical = iEventHeader.lTimePhysical;	// lTimePhysical stores beat offset
				pNewItem->m_mtTimeLogical = iEventHeader.lTimeLogical;		// lTimeLogical stores beat offset
				
				// Will recalc mtTime fields after paste (or drop)
				pNewItem->m_lMeasure = 0;
				pNewItem->m_lBeat = 0;
				pNewItem->m_lTick = 0;		// DMUS_FOURCC_COPYPASTE_UI_CHUNK stores tick offset
				break;
			}

			case DMUS_FOURCC_COPYPASTE_UI_CHUNK:
			{
				ioCopyPasteUI iCopyPasteUI;

				// Read in the Lyric item's copy/paste structure
				dwSize = min( sizeof( ioCopyPasteUI ), ck.cksize );
				hr = pIStream->Read( &iCopyPasteUI, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_lTick = iCopyPasteUI.lTick;
				break;
			}

			case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strText );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadLyricList

HRESULT LoadLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream, CLyricMgr* pLyricMgr )
{
	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Try and allocate an IDMUSProdRIFFStream interface from the pIStream
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr;
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Couldn't allocate an IDMUSProdRIFFStream interface, return an error code
		return hr;
	}

	// Variables used when loading the Lyric track
	MMCKINFO ckTrack;
	MMCKINFO ckLyricList;
	MMCKINFO ckItem;
	CLyricItem* pNewItem;

	// Descend into the Lyric LIST chunk
	ckTrack.fccType = DMUS_FOURCC_LYRICSTRACK_LIST;
	if( pIRiffStream->Descend(&ckTrack, NULL, MMIO_FINDLIST) == 0)
	{
		// Now, descend into each chunk in this LIST chunk
		while( pIRiffStream->Descend( &ckLyricList, &ckTrack, 0 ) == 0 )
		{
			switch( ckLyricList.ckid )
			{
				case FOURCC_LIST:
					switch( ckLyricList.fccType )
					{
						case DMUS_FOURCC_LYRICSTRACKEVENTS_LIST:
							while( pIRiffStream->Descend( &ckItem, &ckLyricList, 0 ) == 0 )
							{
								switch( ckItem.ckid )
								{
									case FOURCC_LIST:
										switch( ckItem.fccType )
										{
											case DMUS_FOURCC_LYRICSTRACKEVENT_LIST:
												hr = LoadListItem( pIRiffStream, &ckItem, pLyricMgr, &pNewItem );
												if( FAILED ( hr ) )
												{
													goto ON_ERROR;
												}
												list.AddTail( pNewItem );
												break;
										}
										break;
								}

								pIRiffStream->Ascend( &ckItem, 0 );
							}
							break;
					}
					break;
			}

			pIRiffStream->Ascend( &ckLyricList, 0 );
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

ON_ERROR:
	// Release the IDMUSProdRIFFStream interface
	pIRiffStream->Release();

	// Return the success or failure code
    return hr;
}

void EmptyLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list )
{
	// Remove and delete all the CLyricItems from the given list
	while( !list.IsEmpty() )
	{
		delete list.RemoveHead();
	}
}

HRESULT GetBoundariesOfLyrics( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long &lStartTime, long &lEndTime, CTypedPtrList<CPtrList, CLyricItem*>& list)
{
	// Validate the given pTimeline pointer
	if( pTimeline == NULL )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Initialize the start and end times to -1
	lStartTime = -1;
	lEndTime = -1;

	// No lyrics in list, return S_FALSE since there's nothing to do
	if( list.IsEmpty() )
	{
		return S_FALSE;
	}

	// Initialize our return value to S_OK
	HRESULT hr = S_OK;
	MUSIC_TIME mtTime;

	// Iterate through the list of lyrics
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each lyric item
		CLyricItem* pItem = list.GetNext(pos);

		// Try and convert the measure and beat of the lyric to a value in number of clocks
		hr = pTimeline->MeasureBeatToClocks( dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, &mtTime );

		// If the conversion failed, break out of the while loop
		if(FAILED(hr))
		{
			break;
		}

		// If the start time is not yet set, or the item's time is earlier
		// than any other lyric, update lStartTime.
		if( ( lStartTime == -1 )
		||	( mtTime < lStartTime ) )
		{
			lStartTime = mtTime;
		}

		// If the end time is not yet set, or the item's time is later
		// than any other lyric, update lEnd.
		if( ( lEndTime == -1 )
		||	( mtTime > lEndTime ) )
		{
			lEndTime = mtTime;
		}
	}

	// If the conversions (MeasureBeatToClocks) succeeded
	if( SUCCEEDED(hr) )
	{
		// The start and end times should be set to valid values
		ASSERT( lStartTime != -1 );
		ASSERT( lEndTime != -1 );

		// Get the measure and beat of the last lyric
		long lMeasure, lBeat;
		CMusicTimeConverter cmt = lEndTime;
		hr = cmt.GetMeasureBeat( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Increment the beat value
		lBeat++;

		// Convert from measure and beat back to clocks
		hr = cmt.SetTime( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Set the end time to one tick before the next beat
		lEndTime = cmt - 1;
	}

	// Return the success or failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::ClocksToMeasureBeatTick

HRESULT CLyricMgr::ClocksToMeasureBeatTick( MUSIC_TIME mtTime,
										    long* plMeasure, long* plBeat, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lTick = -1;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lTick = mtTime - lClocks;

					// Try and preserve negative tick offsets
					if( lTick > 0 )
					{
						long lNewClocks;
						long lClocksPerBeat;

						hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat+1, &lNewClocks );
						if( SUCCEEDED ( hr ) )
						{
							lClocksPerBeat = lNewClocks - lClocks;

							if( lTick >= (lClocksPerBeat >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lTick -= lClocksPerBeat;

									hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lNewClocks, &lMeasure, &lBeat );
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::MeasureBeatTickToClocks

HRESULT CLyricMgr::MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick,
											MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			mtTime = lClocks + lTick;
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::ForceBoundaries

HRESULT CLyricMgr::ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime )
{
	// Get length of segment
	MUSIC_TIME mtMaxTimelineLength;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	mtMaxTimelineLength = V_I4( &var );

	// Get maximum number of measures, beats
	long lMaxMeasure;
	long lMaxBeat;
	long lMaxTick;
	long lClocks;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength - 1, &lMaxMeasure, &lMaxBeat );
	lMaxMeasure = max( 0, lMaxMeasure );
	lMaxBeat = max( 0, lMaxBeat );
	MeasureBeatTickToClocks( lMaxMeasure, lMaxBeat, 0, &lClocks );
	lMaxTick = mtMaxTimelineLength - lClocks; 

	// Force boundaries 
	MUSIC_TIME mtTime;
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );

	// Enforce measure boundary
	if( lMeasure > lMaxMeasure )
	{
		lMeasure = lMaxMeasure;
		lBeat = lMaxBeat;
	}

	// Enforce beat boundary (must catch incomplete last measures - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat > lMaxBeat )
	{
		lBeat = lMaxBeat;
	}

	// Enforce tick boundary (must catch incomplete last beats - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat == lMaxBeat 
	&&  lTick > lMaxTick )
	{
		lTick = lMaxTick;
	}
	if( lTick < -MAX_TICK )
	{
		lTick = -MAX_TICK;
	}

	// Make sure mtTime matches adjusted measure, tick
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	*pmtTime = mtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::GetGroupBits

DWORD CLyricMgr::GetGroupBits( void )
{
	return m_dwGroupBits;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::IsRefTimeTrack

bool CLyricMgr::IsRefTimeTrack( void )
{
	return (m_dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? true : false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\LyricStripMgr.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// LyricStripMgr.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#include "LyricStripMgr.h"
#include <AFXCTL.H>
#include "LyricMgr.h"

#include <initguid.h>
#include "LyricStripMgr_i.c"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ATL Stuff follows
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LyricMgr, CLyricMgr)
END_OBJECT_MAP()

class CLyricStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CLyricStripMgrApp theApp;

BOOL CLyricStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CLyricStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Convert the Lyric Strip Manager's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_LyricMgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the Lyric Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_LyricTrack, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the Lyric Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_LyricTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	if ( _Module.RegisterServer(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( !AfxOleUnregisterTypeLib( LIBID_LYRICSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	// unregisters object, typelib and all interfaces in typelib
	if ( _Module.UnregisterServer() )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\PropPageLyric.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#if !defined(AFX_PROPPAGELYRIC_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGELYRIC_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

class CLyricPropPageMgr;
class CTabOnReturnEdit;

// PropPageLyric.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric dialog
class CLyricPropPageMgr;

class PropPageLyric : public CPropertyPage
{
	friend CLyricPropPageMgr;
	DECLARE_DYNCREATE(PropPageLyric)

// Construction
public:
	PropPageLyric();
	~PropPageLyric();

// Dialog Data
	//{{AFX_DATA(PropPageLyric)
	enum { IDD = IDD_LYRIC_PROPPAGE };
	CSpinButtonCtrl	m_spinLogicalMeasure;
	CSpinButtonCtrl	m_spinLogicalBeat;
	CEdit	m_editLogicalMeasure;
	CEdit	m_editLogicalBeat;
	CButton	m_radioTimingQuick;
	CButton	m_radioTimingBeforeTime;
	CButton	m_radioTimingAtTime;
	CSpinButtonCtrl	m_spinTick;
	CEdit	m_editTick;
	CEdit	m_editBeat;
	CEdit	m_editLyric;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageLyric)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageLyric)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditLyric();
	afx_msg void OnKillfocusEditMeasure();
	virtual void OnOK();
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTimingQuick();
	afx_msg void OnDoubleClickedTimingQuick();
	afx_msg void OnTimingBeforeTime();
	afx_msg void OnDoubleClickedTimingBeforeTime();
	afx_msg void OnTimingAtTime();
	afx_msg void OnDoubleClickedTimingAtTime();
	afx_msg void OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusEditLogicalBeat();
	afx_msg void OnKillFocusEditLogicalMeasure();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetLyric( const CLyricItem * pLyric );

protected:
	void UpdateObject( void );
	void EnableControls( BOOL fEnable );
	void HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal );
	void HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidLyric;
	CLyricItem				m_Lyric;
	CLyricPropPageMgr *		m_pPropPageMgr;
	IDMUSProdTimeline*		m_pTimeline; // Weak timeline reference
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGELYRIC_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\PropPageLyric.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// PropPageLyric.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricMgr.h"
#include "PropPageMgr.h"
#include "PropPageLyric.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

// {694073F0-9948-11d3-B474-00105A2796DE}
static const GUID GUID_LyricPPGMgr = 
{ 0x694073f0, 0x9948, 0x11d3, { 0xb4, 0x74, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr constructor/destructor

CLyricPropPageMgr::CLyricPropPageMgr( CLyricMgr* pLyricMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pLyricMgr != NULL );
	m_pLyricMgr = pLyricMgr;

	// Initialize our pointer to NULL
	m_pPropPageLyric = NULL;

	// Store GUID
	m_GUIDManager = GUID_LyricPPGMgr;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CLyricPropPageMgr::~CLyricPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the Lyric property page exists, delete it
	if( m_pPropPageLyric )
	{
		delete m_pPropPageLyric;
		m_pPropPageLyric = NULL;
	}

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CLyricPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_LYRIC ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CLyricPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// If it doesn't exist, create the lyric property page
	if( m_pPropPageLyric == NULL )
	{
		m_pPropPageLyric = new PropPageLyric();
	}

	// If it exists, add the lyric property page
	if( m_pPropPageLyric )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageLyric->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the lyric property page back to this property page manager
		m_pPropPageLyric->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CLyricPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a CLyricItem
	CLyricItem* pLyric;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		pLyric = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pLyric ) ) )
	{
		return E_FAIL;
	}

	// Update the lyric property page, if it exists
	if (m_pPropPageLyric )
	{
		// pLyric may be NULL, meaning nothing is selected
		m_pPropPageLyric->SetLyric( pLyric );
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric property page

IMPLEMENT_DYNCREATE(PropPageLyric, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric constructor/destructor

PropPageLyric::PropPageLyric(): CPropertyPage(PropPageLyric::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_LYRIC_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageLyric)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidLyric = FALSE;
	m_fNeedToDetach = FALSE;
}

PropPageLyric::~PropPageLyric()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::DoDataExchange

void PropPageLyric::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageLyric)
	DDX_Control(pDX, IDC_SPIN_BELONGS_MEASURE, m_spinLogicalMeasure);
	DDX_Control(pDX, IDC_SPIN_BELONGS_BEAT, m_spinLogicalBeat);
	DDX_Control(pDX, IDC_EDIT_BELONGS_MEASURE, m_editLogicalMeasure);
	DDX_Control(pDX, IDC_EDIT_BELONGS_BEAT, m_editLogicalBeat);
	DDX_Control(pDX, IDC_TIMING_QUICK, m_radioTimingQuick);
	DDX_Control(pDX, IDC_TIMING_BEFORE_TIME, m_radioTimingBeforeTime);
	DDX_Control(pDX, IDC_TIMING_AT_TIME, m_radioTimingAtTime);
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_LYRIC, m_editLyric);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageLyric, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageLyric)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LYRIC, OnKillfocusEditLyric)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_BN_CLICKED(IDC_TIMING_QUICK, OnTimingQuick)
	ON_BN_DOUBLECLICKED(IDC_TIMING_QUICK, OnDoubleClickedTimingQuick)
	ON_BN_CLICKED(IDC_TIMING_BEFORE_TIME, OnTimingBeforeTime)
	ON_BN_DOUBLECLICKED(IDC_TIMING_BEFORE_TIME, OnDoubleClickedTimingBeforeTime)
	ON_BN_CLICKED(IDC_TIMING_AT_TIME, OnTimingAtTime)
	ON_BN_DOUBLECLICKED(IDC_TIMING_AT_TIME, OnDoubleClickedTimingAtTime)
	ON_WM_KILLFOCUS()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_BEAT, OnDeltaPosSpinLogicalBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_MEASURE, OnDeltaPosSpinLogicalMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_BEAT, OnKillFocusEditLogicalBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_MEASURE, OnKillFocusEditLogicalMeasure)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::SetLyric

void PropPageLyric::SetLyric( const CLyricItem* pLyric )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the lyric pointer is null, there are no Lyrics selected, so disable the property page
	if ( pLyric == NULL )
	{
		m_fValidLyric = FALSE;
		m_Lyric.Clear();
		EnableControls( FALSE );
		return;
	}

	// Update our timeline pointer

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pointer to our Property Page Object
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid lyric
	m_fValidLyric = TRUE;

		// Copy the information from the new lyric
	m_Lyric.Copy( pLyric );

	long lMaxMeasure, lMaxBeat; // Maximum measure and beat values
	// Get the maximum measure value
	if( m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
	}
	else
	{
		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
										  V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
												  V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		// If the lyric is not in the last measure
		if( m_Lyric.m_lMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, m_Lyric.m_lMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the lyric is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Check if the edit control has a valid window handle.
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the lyric text
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_Lyric.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the edit controls
	EnableControls( TRUE );

	// Get the currently displayed lyric text
	CString strTemp;
	m_editLyric.GetWindowText( strTemp );

	// If it's different from what we were passed or the lyric was previously invalid, update the display
	if ( !m_fValidLyric || (pLyric->m_strText != strTemp) )
	{
		m_editLyric.SetWindowText( pLyric->m_strText );
	}

	// If the lyric was previously invalid, update the measure and beat display
	if( !m_fValidLyric )
	{
		SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_Lyric.m_lMeasure + 1 );
		SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_Lyric.m_lBeat + 1 );
		SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_Lyric.m_lTick );
		m_radioTimingQuick.SetCheck( 0 );
		m_radioTimingBeforeTime.SetCheck( 0 );
		m_radioTimingAtTime.SetCheck( 0 );

		if( m_pPropPageMgr
		&&  m_pPropPageMgr->m_pLyricMgr
		&&  m_pPropPageMgr->m_pLyricMgr->IsRefTimeTrack() == false )
		{
			SetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), m_Lyric.m_lLogicalMeasure + 1 );
			SetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), m_Lyric.m_lLogicalBeat + 1 );
		}
		else
		{
			m_editLogicalMeasure.SetWindowText( NULL );
			m_editLogicalBeat.SetWindowText( NULL );
		}
	}
	// Otherwise, check if the values displayed don't match the new ones
	else
	{
		TCHAR tcstrTmp[DIALOG_EDIT_LEN];
		long lCurValue;
		BOOL fTransSuccess;

		// MEASURE
		{
			m_editMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			||  (tcstrTmp[0] == NULL)
			||  (lCurValue != m_Lyric.m_lMeasure + 1) )
			{
				// Update the displayed measure number
				SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_Lyric.m_lMeasure + 1 );
			}
		}

		// BEAT
		{
			m_editBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			||  (tcstrTmp[0] == NULL)
			||  (lCurValue != m_Lyric.m_lBeat + 1) )
			{
				// Update the displayed beat number
				SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_Lyric.m_lBeat + 1 );
			}
		}

		// TICK
		{
			m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editTick.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			|| (tcstrTmp[0] == NULL)
			|| (lCurValue != m_Lyric.m_lTick) )
			{
				// Update the displayed tick number
				SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_Lyric.m_lTick );
			}
		}

		if( m_pPropPageMgr
		&&  m_pPropPageMgr->m_pLyricMgr
		&&  m_pPropPageMgr->m_pLyricMgr->IsRefTimeTrack() == false )
		{
			// LOGICAL MEASURE
			{
				m_editLogicalMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

				// Convert from text to an integer
				long lCurValue = GetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

				// Check if the conversion failed, the text is empty, or if the values are different
				if( !fTransSuccess
				||  (tcstrTmp[0] == NULL)
				||  (lCurValue != m_Lyric.m_lLogicalMeasure + 1) )
				{
					// Update the displayed logical measure number
					SetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), m_Lyric.m_lLogicalMeasure + 1 );
				}
			}

			// LOGICAL BEAT
			{
				m_editLogicalBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

				// Convert from text to an integer
				lCurValue = GetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

				// Check if the conversion failed, the text is empty, or if the values are different
				if( !fTransSuccess
				||  (tcstrTmp[0] == NULL)
				||  (lCurValue != m_Lyric.m_lLogicalBeat + 1) )
				{
					// Update the displayed logical beat number
					SetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), m_Lyric.m_lLogicalBeat + 1 );
				}
			}
		}

		// Set 'Timing' radio buttons
		if( m_Lyric.m_dwTimingFlagsDM & DMUS_PMSGF_TOOL_IMMEDIATE )
		{
			if( m_radioTimingQuick.GetCheck() == 0 )
			{
				m_radioTimingQuick.SetCheck( 1 );
				m_radioTimingBeforeTime.SetCheck( 0 );
				m_radioTimingAtTime.SetCheck( 0 );
			}
		}
		if( m_Lyric.m_dwTimingFlagsDM & DMUS_PMSGF_TOOL_QUEUE )
		{
			if( m_radioTimingBeforeTime.GetCheck() == 0 )
			{
				m_radioTimingQuick.SetCheck( 0 );
				m_radioTimingBeforeTime.SetCheck( 1 );
				m_radioTimingAtTime.SetCheck( 0 );
			}
		}
		if( m_Lyric.m_dwTimingFlagsDM & DMUS_PMSGF_TOOL_ATTIME )
		{
			if( m_radioTimingAtTime.GetCheck() == 0 )
			{
				m_radioTimingQuick.SetCheck( 0 );
				m_radioTimingBeforeTime.SetCheck( 0 );
				m_radioTimingAtTime.SetCheck( 1 );
			}
		}
	}

	// Update the control ranges
	m_spinMeasure.SetRange( 1, lMaxMeasure );
	m_spinBeat.SetRange( 1, lMaxBeat );
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_spinLogicalMeasure.SetRange( 1, lMaxMeasure );
	m_spinLogicalBeat.SetRange( 1, lMaxBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnCreate

int PropPageLyric::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDestroy

void PropPageLyric::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnInitDialog

BOOL PropPageLyric::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	// Limit the measure number to positive numbers
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Limit the beat number to 1-256
	m_spinBeat.SetRange( 1, 256 );
	m_editBeat.LimitText( 3 );

	// Limit the tick number to MAX_TICK
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editTick.LimitText( 5 );

	// Limit the logical measure number to positive numbers
	m_spinLogicalMeasure.SetRange( 1, 32767 );
	m_editLogicalMeasure.LimitText( 5 );

	// Limit the logical beat number to 1-256
	m_spinLogicalBeat.SetRange( 1, 256 );
	m_editLogicalBeat.LimitText( 3 );

	// If we have valid lyric information
	if(	m_fValidLyric )
	{
		// Force update of the controls
		m_fValidLyric = FALSE;

		// Update the dialog
		SetLyric( &m_Lyric );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaposSpinTick

void PropPageLyric::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditTick();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lTick );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaposSpinBeat

void PropPageLyric::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditBeat();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaposSpinMeasure

void PropPageLyric::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaPosSpinLogicalBeat

void PropPageLyric::OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalBeat();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lLogicalBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaPosSpinLogicalMeasure

void PropPageLyric::OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lLogicalMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::HandleDeltaChange
//
// Generic handler for deltapos changes
void PropPageLyric::HandleDeltaChange( NMHDR* pNMHDR,
									   LRESULT* pResult,
									   long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// If the value changed - update the selected Lyric
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;

		// Now, update the object with the new value
		UpdateObject();
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditTick

void PropPageLyric::OnKillfocusEditTick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(m_spinTick.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		m_spinTick.SetPos( 0 );

		// Check if the value changed
		if( m_Lyric.m_lTick != 0 )
		{
			// Update the item with the new value
			m_Lyric.m_lTick = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( IDC_EDIT_TICK, &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( IDC_EDIT_TICK, m_Lyric.m_lTick );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			m_spinTick.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( IDC_EDIT_TICK, iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( m_Lyric.m_lTick != lNewValue )
			{
				// Update the item with the new value
				m_Lyric.m_lTick = lNewValue;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditBeat

void PropPageLyric::OnKillfocusEditBeat() 
{
	HandleKillFocus( m_spinBeat, m_Lyric.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditMeasure

void PropPageLyric::OnKillfocusEditMeasure() 
{
	HandleKillFocus( m_spinMeasure, m_Lyric.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillFocusEditLogicalBeat

void PropPageLyric::OnKillFocusEditLogicalBeat() 
{
	HandleKillFocus( m_spinLogicalBeat, m_Lyric.m_lLogicalBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillFocusEditLogicalMeasure

void PropPageLyric::OnKillFocusEditLogicalMeasure() 
{
	HandleKillFocus( m_spinLogicalMeasure, m_Lyric.m_lLogicalMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::HandleKillFocus
//
// Generic handler for KillFocus changes
void PropPageLyric::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( 1 );

		// Check if the value changed
		if( 0 != lUpdateVal )
		{
			// Update the lyric with the new value
			lUpdateVal = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + 1 );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lNewValue - 1 != lUpdateVal )
			{
				// Update the lyric with the new value
				lUpdateVal = lNewValue - 1;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditLyric

void PropPageLyric::OnKillfocusEditLyric() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get the new lyric text
	CString strText;
	m_editLyric.GetWindowText( strText );

	// Check if the text is empty
	if( strText.IsEmpty() )
	{
		// Check if the existing text is empty
		if( m_Lyric.m_strText != _T("") )
		{
			// Nope - update the Lyric strip manager with the new text
			m_Lyric.m_strText = "";
			UpdateObject();
		}
	}
	else
	{
		// Check if the text is different from the existing text.
		if( strText != m_Lyric.m_strText )
		{
			// Yep - update the Lyric strip manager with the new text
			m_Lyric.m_strText = strText;
			UpdateObject();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::UpdateObject

void PropPageLyric::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		// Update the Property Page Object with the new Lyric
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Lyric);
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::EnableControls

void PropPageLyric::EnableControls( BOOL fEnable )
{
	// Check if the Beat edit control exists
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the beat, measure, and lyric controls with the new window state
	m_spinTick.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_editLyric.EnableWindow( fEnable );
	m_radioTimingQuick.EnableWindow( fEnable );
	m_radioTimingBeforeTime.EnableWindow( fEnable );
	m_radioTimingAtTime.EnableWindow( fEnable );
	
	BOOL fEnableBelongsTo = FALSE;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pLyricMgr
	&&  m_pPropPageMgr->m_pLyricMgr->IsRefTimeTrack() == false )
	{
		fEnableBelongsTo = fEnable;
	}

	m_spinLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_spinLogicalMeasure.EnableWindow( fEnableBelongsTo );
	m_editLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_editLogicalMeasure.EnableWindow( fEnableBelongsTo );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_Lyric.m_dwBitsUI & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				m_editLyric.SetWindowText( strText );
				return;
			}
		}

		// No items are selected, so clear the edit controls
		m_editLyric.SetWindowText( NULL );
		m_editTick.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editMeasure.SetWindowText( NULL );
		m_radioTimingQuick.SetCheck( 0 );
		m_radioTimingBeforeTime.SetCheck( 0 );
		m_radioTimingAtTime.SetCheck( 0 );
	}

	if( fEnableBelongsTo == FALSE )
	{
		m_editLogicalMeasure.SetWindowText( NULL );
		m_editLogicalBeat.SetWindowText( NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnTimingQuick

void PropPageLyric::OnTimingQuick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingQuick.GetCheck() )
	{
		m_Lyric.m_dwTimingFlagsDM &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
		m_Lyric.m_dwTimingFlagsDM |= DMUS_PMSGF_TOOL_IMMEDIATE;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDoubleClickedTimingQuick

void PropPageLyric::OnDoubleClickedTimingQuick() 
{
	OnTimingQuick();
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnTimingBeforeTime

void PropPageLyric::OnTimingBeforeTime() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingBeforeTime.GetCheck() )
	{
		m_Lyric.m_dwTimingFlagsDM &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
		m_Lyric.m_dwTimingFlagsDM |= DMUS_PMSGF_TOOL_QUEUE;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDoubleClickedTimingBeforeTime

void PropPageLyric::OnDoubleClickedTimingBeforeTime() 
{
	OnTimingBeforeTime();
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnTimingAtTime

void PropPageLyric::OnTimingAtTime() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingAtTime.GetCheck() )
	{
		m_Lyric.m_dwTimingFlagsDM &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
		m_Lyric.m_dwTimingFlagsDM |= DMUS_PMSGF_TOOL_ATTIME;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDoubleClickedTimingAtTime

void PropPageLyric::OnDoubleClickedTimingAtTime() 
{
	OnTimingAtTime();
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void PropPageLyric::OnOK() 
{
	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\StdAfx.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\StdAfx.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\LyricStrip.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// LyricStrip.cpp : Implementation of CLyricStrip
#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricStripMgr.h"
#include "LyricMgr.h"
#include "PropPageMgr.h"
#include "TrackFlagsPPG.h"
#include "BaseMgr.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This sets the strip's height
#define DEFAULT_STRIP_HEIGHT 20

// This sets the masks for the track flags property page
const DWORD g_dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
const DWORD g_dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip constructor/destructor

CLyricStrip::CLyricStrip( CLyricMgr* pLyricMgr ) : CBaseStrip( pLyricMgr )
{
	// Validate the pointer to our strip manager
	ASSERT( pLyricMgr );
	if ( pLyricMgr == NULL )
	{
		return;
	}

	// Set our pointer to our strip manager
	m_pLyricMgr = pLyricMgr;

	// Initialize our clipboard format to 0
	m_cfLyricList = 0;

	// Initialize our state variables to false
	m_fLeftMouseDown = false;

	// Initialize the lyric to toggle (when CTRL-clicking) to NULL
	m_pLyricItemToToggle = NULL;
}

CLyricStrip::~CLyricStrip()
{
	// Clear our pointer to our strip manager
	ASSERT( m_pLyricMgr );
	if ( m_pLyricMgr )
	{
		m_pLyricMgr = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetTopItemFromMeasureBeat

CLyricItem* CLyricStrip::GetTopItemFromMeasureBeat( long lMeasure, long lBeat )
{
	CLyricItem* pTheItem = NULL;
	CLyricItem* pFirstItem = NULL;
	CLyricItem* pItem;

	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			if( pFirstItem == NULL )
			{
				pFirstItem = pItem;
			}

			if( pItem->m_wFlagsUI & RF_TOP_ITEM )
			{
				pTheItem = pItem;
				break;
			}
		}

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}
	}

	if( pTheItem == NULL )
	{
		pTheItem = pFirstItem;
	}

	return pTheItem;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelectedLyric - helper method for Draw()

void GetNextSelectedLyric( CTypedPtrList<CPtrList, CLyricItem*>& list, POSITION &posLyric )
{
	// Note that if the lyric at posLyric is selected, this method doesn't do anything useful.
	if( posLyric )
	{
		// Save the current position
		POSITION posToSave = posLyric;

		// Check if we have not run off the end of the list, and if the currently lyric is unselected
		while( posLyric && !list.GetNext( posLyric )->m_fSelected )
		{
			// Current lyric is unselected, save the position of the next lyric
			posToSave = posLyric;
		}

		// Check if we found a selected lyric
		if( posToSave )
		{
			// Save the position of the selected lyric
			posLyric = posToSave;
		}
		// Otherwise both posToSave and posLyric are NULL
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::AdjustTopItem - helper method for Draw()

void CLyricStrip::AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CLyricItem* pFirstSelectedItem = NULL;
	CLyricItem* pTopItem = NULL;
	CLyricItem* pItem;

	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			break;
		}

		if( pItem->m_fSelected )
		{
			if( pFirstSelectedItem == NULL )
			{
				pFirstSelectedItem = pItem;
			}
		}

		if( pItem->m_wFlagsUI & RF_TOP_ITEM )
		{
			if( pTopItem == NULL )
			{
				pTopItem = pItem;
			}
			else
			{
				// Can only have one top item
				pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
			}
		}
	}

	if( pTopItem )
	{
		if( pTopItem->m_fSelected == FALSE )
		{
			if( pFirstSelectedItem )
			{
				// pTopItem is NOT selected so it shouldn't be the top item
				pTopItem->m_wFlagsUI &= ~RF_TOP_ITEM;
						
				// pFirstSelectedItem IS selected so make it the top item
				pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
			}
		}
	}
	else if( pFirstSelectedItem )
	{
		// Make the selected item the top item
		pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetNextSelectedTopItem - helper method for Draw()

CLyricItem* CLyricStrip::GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CLyricItem* pNextItem = NULL;
	CLyricItem* pItem;

	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_fSelected )
		{
			if( pItem->m_lMeasure != lCurrentMeasure
			||  pItem->m_lBeat != lCurrentBeat )
			{
				pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
				ASSERT( pNextItem != NULL );	// Should not happen!
				break;
			}
		}
	}

	return pNextItem;
}

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetNextTopItem - helper method for Draw()

CLyricItem* CLyricStrip::GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CLyricItem* pNextItem = NULL;
	CLyricItem* pItem;

	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
			ASSERT( pNextItem != NULL );	// Should not happen!
			break;
		}
	}

	return pNextItem;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Draw

HRESULT	STDMETHODCALLTYPE CLyricStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_pLyricMgr == NULL
	||	m_pLyricMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Draw bar and beat lines
	CBaseStrip::Draw( hDC, sv, lXOffset );

	// Set a flag if we should use the gutter range for our selection
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);

	// Get our clipping rectange
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Initialize the top and bottom of the highlight rectangle
	// (it is always the entire strip height).
	RECT rectHighlight;
	rectHighlight.top = 0;
	rectHighlight.bottom = DEFAULT_STRIP_HEIGHT;

	// Find the first time that we are asked to draw
	long lStartTime;
	m_pLyricMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

	// Create Italics font
	HFONT hFontItalics = NULL;
	HFONT hFont = (HFONT)::GetCurrentObject( hDC, OBJ_FONT );
	if( hFont )
	{
		LOGFONT logfont;

		::GetObject( hFont, sizeof(LOGFONT), &logfont );
		logfont.lfItalic = TRUE;
		hFontItalics = CreateFontIndirect( &logfont );
	}

	// A structure to store the size of each lyric in
	SIZE sizeText;

	// Fields to keep track of top item on current measure/beat
	CLyricItem* pTopItem;

	////
	// Draw the unselected lyrics first

	// Iterate through the list of lyrics
	long lPosition;
	long lCurrentMeasure = -1;
	long lCurrentBeat = -1;
	POSITION posLyric = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( posLyric )
	{
		// Save position
		POSITION posLast = posLyric;

		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( posLyric );

		if( pLyricItem->m_lMeasure != lCurrentMeasure
		||  pLyricItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pLyricItem->m_lMeasure;
			lCurrentBeat = pLyricItem->m_lBeat;

			// Cleanup
			AdjustTopItem( posLast, lCurrentMeasure, lCurrentBeat );

			// Get the "top" item on this beat
			pTopItem = GetTopItemFromMeasureBeat( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// If this lyric is selected and we are not using the gutter selection, skip it
			if( !fUseGutterSelectRange
			&&  pTopItem->m_fSelected )
			{
				continue;
			}

			// Convert the measure and beat of each lyric to a pixel position
			m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, lCurrentMeasure, lCurrentBeat, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the lyric text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Use italics if more than one routine is on this beat
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pLyricItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posLyric )
					{
						POSITION posNext = posLyric;
						CLyricItem* pNextItem = m_pLyricMgr->m_lstLyrics.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Get a pointer to the next "top" item occuring AFTER this beat
			CLyricItem* pNextItem = GetNextTopItem( posLyric, lCurrentMeasure, lCurrentBeat );

			// Check if there is a lyric after this one
			if( pNextItem ) 
			{
				// Get the size of the lyric text to be written
				::GetTextExtentPoint32( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &sizeText );

				// Get the start position of the next item
				m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, pNextItem->m_lMeasure, pNextItem->m_lBeat, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current lyric will run into the next lyric
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next lyric - clip it
					::DrawText( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next lyric - just draw it
					::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
				}
			}
			else
			{
				// No more lyrics after this one - just draw it
				::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}
		}
	}

	////
	// Now, draw the selected lyrics

	// Iterate through the list of lyrics, but only if we're not using the gutter selection
	lCurrentMeasure = -1;
	lCurrentBeat = -1;
	posLyric = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( !fUseGutterSelectRange && posLyric )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( posLyric );

		if( pLyricItem->m_lMeasure != lCurrentMeasure
		||  pLyricItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pLyricItem->m_lMeasure;
			lCurrentBeat = pLyricItem->m_lBeat;

			// Get the "top" item on this beat
			pTopItem = GetTopItemFromMeasureBeat( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// If this item is unselected, skip it
			if( !pTopItem->m_fSelected )
			{
				continue;
			}

			// Convert the measure and beat of each lyric to a pixel position
			m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, lCurrentMeasure, lCurrentBeat, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the lyric text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Use italics if more than one routine is on this beat
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pLyricItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posLyric )
					{
						POSITION posNext = posLyric;
						CLyricItem* pNextItem = m_pLyricMgr->m_lstLyrics.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Get a pointer to the next selected "top" item occuring AFTER this beat
			CLyricItem* pNextItem = GetNextSelectedTopItem( posLyric, lCurrentMeasure, lCurrentBeat );

			// Check if there is a selected lyric after the current one
			if( pNextItem )
			{
				// Get the size of the lyric text to be written
				::GetTextExtentPoint32( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &sizeText );

				// Get the start position of the next lyric
				m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, pNextItem->m_lMeasure, pNextItem->m_lBeat, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current lyric will run into the next lyric
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next lyric - clip it
					::DrawText( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next lyric - just draw it
					::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
				}
			}
			// No more selected lyrics
			else
			{
				// Just draw the lyric
				::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}
		}
	}

	// Now, invert the selected regions
	if( m_pSelectedRegions )
	{
		// Keep a running count of the furthest right position we've inverted.
		// This ensures we don't double-invert.
		long lRightMostInvert = 0;

		// Sort the list of selected regions
		m_pSelectedRegions->Sort();

		// Get the start position of the lyric list
		posLyric = m_pLyricMgr->m_lstLyrics.GetHeadPosition();

		// Get the start position of the region list
		POSITION posRegion = m_pSelectedRegions->GetHeadPosition();
		while( posRegion )
		{
			// Get a pointer to the current lyric, but only when not using the gutter selection
			CLyricItem* pLyricItem = NULL;

			if( !fUseGutterSelectRange
			&&  posLyric )
			{
				// Get the position of the next selected lyric (it may be the one at posLyric)
				GetNextSelectedLyric( m_pLyricMgr->m_lstLyrics, posLyric );

				// Check if we found a selected lyric
				if( posLyric )
				{
					// Get a pointer to the selected lyric
					pLyricItem = m_pLyricMgr->m_lstLyrics.GetAt( posLyric );

					// Make sure we have the top selected item!
					CLyricItem* pTopItem = GetNextSelectedTopItem( posLyric, pLyricItem->m_lMeasure, (pLyricItem->m_lBeat - 1) );

					// Check if there is a item after this one
					if( pTopItem->m_lMeasure == pLyricItem->m_lMeasure
					&&  pTopItem->m_lBeat == pLyricItem->m_lBeat ) 
					{
						pLyricItem = pTopItem;
					}
				}
			}

			// Get a pointer to this region
			CSelectedRegion* psr = m_pSelectedRegions->GetNext(posRegion);

			// Get the start and end positions for this region
			rectHighlight.left = psr->BeginPos(m_pLyricMgr->m_pTimeline) - lXOffset;
			rectHighlight.right = psr->EndPos(m_pLyricMgr->m_pTimeline) - lXOffset;

			// Check if we have a pointer to a selected lyric and if we're not using gutter selection
			if( !fUseGutterSelectRange
			&&  pLyricItem )
			{
				// Get the clock position of this lyric
				long lLyricClockPos;
				m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
					pLyricItem->m_lMeasure, pLyricItem->m_lBeat, &lLyricClockPos );

				while( posLyric && (lLyricClockPos < psr->End()) )
				{
					// Check if the current lyric item is within this selected region
					if( lLyricClockPos >= psr->Beg() )
					{
						// Compute the left side of the lyric's text display
						long lLyricPos;
						m_pLyricMgr->m_pTimeline->ClocksToPosition( lLyricClockPos, &lLyricPos );

						// Get the size of the lyric text to be written
						::GetTextExtentPoint32( hDC, pLyricItem->m_strText, pLyricItem->m_strText.GetLength(), &sizeText );

						// Add the size of the lyric text and subtract the offset to
						// determine the right side of the lyric's text display.
						lLyricPos += sizeText.cx - lXOffset;

						// Make sure we have the top selected item!
						pLyricItem = GetNextSelectedTopItem( posLyric, pLyricItem->m_lMeasure, pLyricItem->m_lBeat );

						// Check if we found a selected item
						if( pLyricItem )
						{
							posLyric = m_pLyricMgr->m_lstLyrics.Find( pLyricItem, posLyric );

							// Get the clock position of this lyric
							m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
								pLyricItem->m_lMeasure, pLyricItem->m_lBeat, &lLyricClockPos );

							// Compute the start position of the next selected lyric
							long lNextStartPos;
							m_pLyricMgr->m_pTimeline->ClocksToPosition( lLyricClockPos, &lNextStartPos );

							// Ensure that we only exent the selection region up to the
							// start of the next selected lyric
							lLyricPos = min( lNextStartPos, lLyricPos );
						}
						else
						{
							posLyric = NULL;
						}

						// Update rectHighlight.right, if necessary
						rectHighlight.right = max( lLyricPos, rectHighlight.right );
					}
					else
					{
						// Move posLyric so we check the next lyric item
						m_pLyricMgr->m_lstLyrics.GetNext( posLyric );

						// Get the position of the next selected lyric (it may be the one at posLyric)
						GetNextSelectedLyric( m_pLyricMgr->m_lstLyrics, posLyric );

						// Check if we found a selected lyric
						if( posLyric )
						{
							// Get a pointer to the selected lyric
							pLyricItem = m_pLyricMgr->m_lstLyrics.GetAt( posLyric );

							// Get the clock position of this lyric
							m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
								pLyricItem->m_lMeasure, pLyricItem->m_lBeat, &lLyricClockPos );
						}
					}
				}
			}

			// Check if we've not already inverted beyond this selection region
			if( lRightMostInvert < rectHighlight.right )
			{
				// Update the left side of the region so we don't double-invert
				rectHighlight.left = max( lRightMostInvert, rectHighlight.left );

				// Now, invert the rect
				GrayOutRect( hDC, &rectHighlight );

				// Save the new right side boundary
				lRightMostInvert = rectHighlight.right;
			}
		}
	}

	if( hFontItalics )
	{
		::DeleteObject( hFontItalics );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetLyricFromMeasureBeat

CLyricItem *CLyricStrip::GetLyricFromMeasureBeat( long lMeasure, long lBeat )
{
	// Iterate through the lyric list
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		// Check if it is in the measure and beat we're looking for
		if ( pLyricItem->m_lMeasure == lMeasure &&
			 pLyricItem->m_lBeat == lBeat )
		{
			// We found the lyric to return
			return pLyricItem;
		}
		// Check if we've passed the measure yet
		else if ( pLyricItem->m_lMeasure > lMeasure )
		{
			// We've passed the measure - break out of the loop
			break;
		}
	}

	// Didn't find a lyric - return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetLyricFromPoint

CLyricItem *CLyricStrip::GetLyricFromPoint( long lPos )
{
	CLyricItem* pItemReturn = NULL;

	// Validate our timeline pointer
	if( m_pLyricMgr->m_pTimeline )
	{
		// Convert the position to a measure and beat value
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			// Conversion was successful, look for a lyric on that measure and beat
			pItemReturn = GetTopItemFromMeasureBeat( lMeasure, lBeat );
		}
	}

	return pItemReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CLyricStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	// Validate our timeline pointer
	if( m_pLyricMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Call a function to handle the left mouse button press
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		m_lXPos = lXPos;	// need to start drag drop from where selection started
		break;

	case WM_RBUTTONDOWN:
		// Call a function to handle the right mouse button press
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		// Check if the left mouse button is downpLyric
		if(m_fLeftMouseDown)
		{
			// The user moved the mouse while the left mouse button was down -
			// do a drag-drop operation.
			hr = DoDragDrop( m_pLyricMgr->m_pTimeline, wParam, m_lXPos);

			// The above method returns after a drop, or after the user
			// cancels the operation.  In either case, we don't want to do
			// a drag-drop operation again.
			m_fLeftMouseDown = false;

			// If the drag-drop operatoin didn't complete
			if(hr != S_OK || m_dwDropEffect == DROPEFFECT_NONE)
			{
				// Store the position that the drag started at, because drag drop eats mouse up
				m_lXPos = lXPos;

				// Check if the control key was down
				if(wParam & MK_CONTROL)
				{
					// Finish the toggle operation on the lyric that was clicked on
					// when the left mouse button was pressed.
					if( m_pLyricItemToToggle )
					{
						m_pSelectedRegions->ToggleRegion( m_pLyricItemToToggle->m_lMeasure, m_pLyricItemToToggle->m_lBeat );
						m_pLyricItemToToggle = NULL;

						// Update the selection state of the lyrics
						SelectItemsInSelectedRegions();
					}
				}
				// Check if the shift key was not down
				else if( !(wParam & MK_SHIFT) )
				{
					// If a lyric was clicked on
					if(GetLyricFromPoint( lXPos ))
					{
						// Update the selection regions to include only the selected lyrics
						SelectRegionsFromSelectedLyrics();
					}
				}

				// Redraw the strip
				m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

				// Switch the property page to the lyric property page
				m_pLyricMgr->OnShowProperties();
			}
			else
			{
				// successful drag drop--make sure that only the regions with
				// selected lyrics are selected
				SelectRegionsFromSelectedLyrics();
			}

			// Refresh the lyric property page, if it exists
			if( m_pLyricMgr->m_pPropPageMgr )
			{
				m_pLyricMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case WM_LBUTTONUP:
		// Clear the flag so we don't start a drag-drop operation when the mouse moved
		m_fLeftMouseDown = false;

		// Check if the Ctrl key was pressed
		if(wParam & MK_CONTROL)
		{
			// Ctrl key pressed - toggle the selection state of the lyric that was clicked on
			if( m_pLyricItemToToggle )
			{
				m_pSelectedRegions->ToggleRegion( m_pLyricItemToToggle->m_lMeasure, m_pLyricItemToToggle->m_lBeat );
				m_pLyricItemToToggle = NULL;

				// Update the selection regions from which lyric are selected
				SelectItemsInSelectedRegions();
			}
		}
		// Check if the Shift key was not pressed
		else if( !(wParam & MK_SHIFT) )
		{
			// Look for a lyric at the position clicked on
			CLyricItem* pLyric = GetLyricFromPoint( lXPos );
			if(pLyric)
			{
				// Found a lyric
				// Unselect all lyrics
				m_pLyricMgr->UnselectAll();

				// Mark the clicked on lyric as selected
				pLyric->m_fSelected = TRUE;

				// Update the selection regions to include just this selected lyric
				SelectRegionsFromSelectedLyrics();
			}
		}

		// Update the position to inset at
		m_lXPos = lXPos;

		// Ensure all other strips are unselected
		UnselectGutterRange();

		// Redraw ourself
		m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

		// Refresh the lyric property page, if it exists
		if( m_pLyricMgr->m_pPropPageMgr )
		{
			m_pLyricMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case WM_COMMAND:
	{
		// We should only get this message in response to a selection in the right-click context menu.
//		WORD wNotifyCode = HIWORD( wParam );	// notification code 
		WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
			case IDM_CYCLE_LYRICS:
				hr = m_pLyricMgr->CycleItems( m_lXPos );
				break;
			default:
				// Try the default message handler
				CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		}
		break;
	}

	case WM_CREATE:
		// Register our clipboard format, if it hasn't been registered yet
		if( m_cfLyricList == 0 )
		{
			m_cfLyricList = RegisterClipboardFormat( CF_LYRICLIST );
		}

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_RBUTTONUP, WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Copy

HRESULT CLyricStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr;
	hr = CanCopy();
	if( hr != S_OK )
	{
		// Nothing to copy - return error code
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Validate our pointer to the timeline
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfLyricList == 0 )
	{
		m_cfLyricList = RegisterClipboardFormat( CF_LYRICLIST );
		if( m_cfLyricList == 0 )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected lyrics in.
	IStream* pStreamCopy;
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );

	// Verify that we were able to create a stream
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Get the span of the selected lyrics
	long lStartTime, lEndTime;
	m_pSelectedRegions->GetSpan(lStartTime, lEndTime);

	// Convert the start time to a measure and beat
	long lMeasure, lBeats;
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
								lStartTime, &lMeasure, &lBeats );

	// Convert the start time to a number of beats
	MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0, lMeasure, lBeats, lBeats );

	// Convert the end time to a measure and beat
	long lEndBeats;
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
								lEndTime, &lMeasure, &lEndBeats );

	// Convert the end time to a number of beats
	MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0, lMeasure, lEndBeats, lEndBeats );

	// Compute the span of the region we're copying
	lEndBeats -= lBeats;

	// Save the number of beats in the region we're copying
	pStreamCopy->Write( &lEndBeats, sizeof(long), NULL );

	// Save the selected lyrics into the stream
	hr = m_pLyricMgr->SaveSelectedLyrics( pStreamCopy, lBeats );

	// Check if the save succeeded
	if( FAILED( hr ))
	{
		// Save failed
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyDataToClipboard( pITimelineDataObject, pStreamCopy, m_cfLyricList, m_pLyricMgr, this );

	// Release our pointer to the stream
	pStreamCopy->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::PasteAt

HRESULT CLyricStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize the return code to a failure code
	HRESULT hr = E_FAIL;

	// If we're in a drag-drop operation, check if we're dragging from and dropping to this strip
	if( bDropNotPaste
	&&	(m_pITargetDataObject == m_pISourceDataObject) )
	{
		// Ensure we have a valid timeline pointer
		if( m_pLyricMgr->m_pTimeline )
		{
			// Determine the measure and beat we're dropping in
			long lMeasure1, lBeat1;
			if(SUCCEEDED(m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, lPasteTime, &lMeasure1, &lBeat1 )))
			{
				// Compute the measure and beat the drag started from
				long lMeasure2, lBeat2;
				if(SUCCEEDED(m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, m_lStartDragPosition, &lMeasure2, &lBeat2 )))
				{
					// Check if we dropped in the same measure we started the drag from.
					if(lMeasure1 == lMeasure2 && lBeat1 == lBeat2)
					{
						// Didn't move - exit early
						goto Leave;
					}
				}
			}
		}
	}

	// Check if there is a lyric list avilable for us
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfLyricList ) == S_OK )
	{
		// Try and read the stream that contains the lyrics
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfLyricList, &pIStream)))
		{
			// If we're pasting, read in the number of beats that this selection covers
			long lBeatsToPaste = -1;
			if( !bDropNotPaste )
			{
				pIStream->Read( &lBeatsToPaste, sizeof(long), NULL );
			}

			// Load the stream into a list of lyric items
			CTypedPtrList<CPtrList, CLyricItem*> list;
			hr = LoadLyricList(list, pIStream, m_pLyricMgr);

			// Check if the load operation succeeded
			if ( SUCCEEDED(hr) )
			{
				if( m_pLyricMgr->m_pTimeline )
				{
					// Get the measure and beat of the drop or paste position
					long lMeasurePaste, lBeatPaste;
					if(FAILED(m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, 
																	max( lPasteTime, 0 ), &lMeasurePaste, &lBeatPaste )))
					{
						hr = E_FAIL;
						goto Leave_1;
					}

					long lBeatStart;
					MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0, lMeasurePaste, lBeatPaste, lBeatStart );

					// The length of the segment, in beats
					long lBeatSegmentLength = LONG_MAX;

					// Check if there are any lyrics to paste
					if( !list.IsEmpty() )
					{
						// Unselect all existing lyrics in this strip so the only selected lyrics are the dropped
						// or pasted ones
						m_pLyricMgr->UnselectAll();

						// Make sure the last lyric lands in the last beat or sooner
						// Retrieve the clock length of the segment
						VARIANT varLength;
						if( SUCCEEDED( m_pLyricMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
						{
							// Compute the measure and beat length of the segment
							long lMeasure, lBeat;
							if( SUCCEEDED( m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, 
																			V_I4(&varLength), &lMeasure, &lBeat ) ) )
							{
								// Compute the beat length of the segment
								MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
									lMeasure, lBeat, lBeatSegmentLength );

								// Make sure the last lyric lands in the last beat or sooner
								if( list.GetTail()->m_mtTimePhysical + lBeatStart >= lBeatSegmentLength )
								{
									lBeatStart = lBeatSegmentLength - list.GetTail()->m_mtTimePhysical - 1;
								}
							}
						}

						// Make sure the first lyric lands in beat 0 or later
						if( list.GetHead()->m_mtTimePhysical + lBeatStart < 0 )
						{
							lBeatStart = -list.GetHead()->m_mtTimePhysical;
						}
					}

					// Check if we're doing a paste
					if(!bDropNotPaste)
					{
						// We're doing a paste, so get the paste type
						TIMELINE_PASTE_TYPE tlPasteType;
						if( FAILED( m_pLyricMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
						{
							// Failed to get the paste type, so return with error code
							hr = E_FAIL;
							goto Leave_1;
						}

						// Check if we're doing a paste->overwrite
						if( tlPasteType == TL_PASTE_OVERWRITE )
						{
							// Count lBeatsToPaste beats from lBeatStart and convert to a measure and beat value
							long lmEnd, lbEnd;
							BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
								lBeatStart + lBeatsToPaste, lmEnd, lbEnd );

							// Now, delete any lyrics that fall between the first and last beats we're pasting in
							fChanged = m_pLyricMgr->DeleteBetweenMeasureBeats(lMeasurePaste, lBeatPaste, lmEnd, lbEnd );
						}
					}

					// Iterate throught the list of lyrics we loaded
					while( !list.IsEmpty() )
					{
						// Remove the head of the list
						CLyricItem* pItem = list.RemoveHead();

						// Check if the item will land before the end of the segment
						if( pItem->m_mtTimePhysical + lBeatStart < lBeatSegmentLength )
						{
							MUSIC_TIME mtTime;
							long lMeasure, lBeat;

							// m_mtTimeLogical
							// When we saved this to a stream in CLyricMgr::SaveSelectedLyrics, we stored
							// the beat offset into m_mtTimeLogical.
							BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
												max( 0, pItem->m_mtTimeLogical + lBeatStart), lMeasure, lBeat );
							m_pLyricMgr->ForceBoundaries( lMeasure, lBeat, 0, &mtTime );
							pItem->SetTimeLogical( mtTime );

							// m_mtTimePhysical
							// When we saved this to a stream in CLyricMgr::SaveSelectedLyrics, we stored
							// the beat offset into m_mtTimePhysical.
							// m_lTick should already contain correct value 
							BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
												pItem->m_mtTimePhysical + lBeatStart, lMeasure, lBeat );
							m_pLyricMgr->MeasureBeatTickToClocks( lMeasure, lBeat, pItem->m_lTick, &mtTime );
							pItem->SetTimePhysical( mtTime, STP_LOGICAL_NO_ACTION );

							// When pasted or dropped, each lyric is selected
							pItem->m_fSelected = TRUE;

							// This will overwrite any lyric that already exists on the measure, beat, and
							// tick where pItem will be inserted
							m_pLyricMgr->InsertByAscendingTime( pItem, TRUE );

							// We changed
							fChanged = TRUE;
						}
						else
						{
							// Item would be pasted beyond the end of the segment - delete it
							delete pItem;
						}
					}
				}
			}
Leave_1:
			pIStream->Release();
		}
	}

Leave:
	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same Lyric strip
		m_nStripIsDragDropSource = 2;
	}

	if( CLyricStrip::m_pIDocRootOfDragDropSource
	&&  CLyricStrip::m_pIDocRootOfDragDropSource == m_pLyricMgr->m_pIDocRootNode )
	{
		// Drag/drop Target and Source are the same file (i.e. Segment)
		CLyricStrip::m_fDragDropIntoSameDocRoot = TRUE;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Paste

HRESULT CLyricStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our LyricMgr and Timeline pointers
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, m_pLyricMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks;
	if( FAILED( m_pLyricMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks) ) )
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt(pITimelineDataObject, lClocks, false, fChanged);

	// Check if the paste succeeded AND if something was actually pasted
	if( SUCCEEDED(hr) && fChanged )
	{
		// Update the selection regions to only include the selected lyrics
		SelectRegionsFromSelectedLyrics();

		// Notify the Segment Designer that we did a paste operation
		m_pLyricMgr->m_nLastEdit = IDS_PASTE;
		m_pLyricMgr->OnDataChanged();

		// Redraw our strip
		m_pLyricMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the lyric property page is visible
		m_pLyricMgr->OnShowProperties();

		// Refresh the lyric property page
		if( m_pLyricMgr->m_pPropPageMgr )
		{
			m_pLyricMgr->m_pPropPageMgr->RefreshData();
		}

		// Sync with DirectMusic
		m_pLyricMgr->SyncWithDirectMusic();
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Insert

HRESULT CLyricStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that our timeline pointer is valid
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	if( m_lXPos < 0 )
	{
		return E_FAIL;
	}

	// Unselect all items in this strip 
	m_pLyricMgr->UnselectAll();

	// Unselect all items in other strips
	UnselectGutterRange();

	// Convert the insert position to a measure and beat value
	long	lMeasure, lBeat;
	if( FAILED( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, max( 0, m_lXPos ), &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}

	CLyricItem* pLyric = new CLyricItem( m_pLyricMgr );
	if(pLyric == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Try and load the default text
	if( !pLyric->m_strText.LoadString( IDS_DEFAULT_LYRIC_TEXT ) )
	{
		// Failed to load the text, just use a default english string
		pLyric->m_strText = _T("Empty");
	}

	// Set the time that the lyric was inserted in
	MUSIC_TIME mtTime;
	m_pLyricMgr->MeasureBeatTickToClocks( lMeasure, lBeat, 0, &mtTime );
	pLyric->SetTimePhysical( mtTime, STP_LOGICAL_SET_DEFAULT );

	// By default, a newly selected lyric is selected
	pLyric->m_fSelected = TRUE;

	// Insert the lyric into our list of lyics, overwriting any existing one
	m_pLyricMgr->InsertByAscendingTime( pLyric, FALSE );

	// If it's not already selected, add the beat the lyric was inserted on
	// to the list of selected regions
	if( !m_pSelectedRegions->Contains( lMeasure, lBeat ) )
	{
		m_pSelectedRegions->AddRegion(m_lXPos);
	}

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	// Show the property sheet
	ShowPropertySheet();

	// Switch to the lyric property page
	m_pLyricMgr->OnShowProperties();

	// Refresh the lyric property page
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that an insert occurred
	m_pLyricMgr->m_nLastEdit = IDS_INSERT;
	m_pLyricMgr->OnDataChanged();

	// No need to sync with DirectMusic - the lyric starts out as empty

	// Return the success/failure code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Delete

HRESULT CLyricStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	// Verify that we have a valid timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Delete all selected lyrics
	m_pLyricMgr->DeleteSelectedLyrics();

	// Clear all selection ranges
	m_pSelectedRegions->Clear();

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	// Refresh the lyric property page, if it exists
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that a delete operation occurred
	m_pLyricMgr->m_nLastEdit = IDS_DELETE;
	m_pLyricMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pLyricMgr->SyncWithDirectMusic();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanPaste

HRESULT CLyricStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfLyricList == 0 )
	{
		m_cfLyricList = RegisterClipboardFormat( CF_LYRICLIST );
		if( m_cfLyricList == 0 )
		{
			return E_FAIL;
		}
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pLyricMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard format
	hr = pITimelineDataObject->IsClipFormatAvailable( m_cfLyricList );

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// If we found our clipboard format, return S_OK
	if (hr == S_OK)
	{
		return S_OK;
	}

	// Otherwise, return S_FALSE
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanInsert

HRESULT CLyricStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid Timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime;
	if( FAILED( m_pLyricMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime) ) )
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if( m_fInFunctionBarMenu || (lInsertTime < 0) )
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition;
	if( FAILED( m_pLyricMgr->m_pTimeline->ClocksToPosition( lInsertTime, &lPosition ) ) )
	{
		return E_UNEXPECTED;
	}

	// Check to see if there is an existing lyric at the insert position
	CLyricItem* pLyric = GetLyricFromPoint( lPosition );

	// Check if we found a lyric
	if( pLyric != NULL )
	{
		// We found a lyric - return S_FALSE since we can't insert here
		return S_FALSE;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_pLyricMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if( lInsertTime >= V_I4(&var) )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Drop

HRESULT CLyricStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pLyricMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_pLyricMgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected lyrics
						SelectRegionsFromSelectedLyrics();

						if( CLyricStrip::m_fDragDropIntoSameDocRoot == FALSE
						||  m_dwOverDragEffect != DROPEFFECT_MOVE )
						{
							// Either we are dropping into a different file,
							// or we are doing a "copy" and there will be no change to the source strip, so....
							// Notify the SegmentDesigner that a paste operation occurred
							m_pLyricMgr->m_nLastEdit = IDS_PASTE;
							m_pLyricMgr->OnDataChanged();
						}

						// Redraw our strip
						m_pLyricMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the lyric property page
						m_pLyricMgr->OnShowProperties();

						// Update the lyric property page, if it exists
						if( m_pLyricMgr->m_pPropPageMgr )
						{
							m_pLyricMgr->m_pPropPageMgr->RefreshData();
						}

						// Sync with DirectMusic
						m_pLyricMgr->SyncWithDirectMusic();
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanPasteFromData

HRESULT CLyricStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pLyricMgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check if our clipboard format is available in the data object
	hr = S_FALSE;
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfLyricList ) == S_OK )
	{
		// Our format is available = return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::OnLButtonDown

HRESULT CLyricStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Validate our timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		return E_UNEXPECTED;
	}

	// Initialize the lyric to toggle to NULL
	m_pLyricItemToToggle = NULL;
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pLyricMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Flag that the left mouse button is pressed
	m_fLeftMouseDown = true;

	// Show the Lyric property page
	m_fShowItemProps = true;

	// Check if the shift key is pressed
	if( wParam & MK_SHIFT )
	{
		m_pSelectedRegions->ShiftAddRegion( lXPos );
		SelectItemsInSelectedRegions();
	}
	else
	{
		// See if there is a lyric under the cursor.
		CLyricItem* pLyric = GetLyricFromPoint( lXPos );
		if( pLyric )
		{
			// Found a lyric under the cursor

			// Check if the control key is down
			if( wParam & MK_CONTROL )
			{
				// Check if the lyric is not yet selected
				if( pLyric->m_fSelected )
				{
					// Set up to unselect this item later, either when we receive a
					// left-button up, or when the user completes a drag-drop operation
					// that does nothing.
					m_pLyricItemToToggle = pLyric;
				}
				else
				{
					// Mark the clicked on item as selected
					pLyric->m_fSelected = TRUE;
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
			// Check if the lyric is unselected (the shift key is up)
			else if( !pLyric->m_fSelected )
			{
				// Mark the clicked on item as selected
				m_pLyricMgr->UnselectAll();
				pLyric->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedLyrics();
			}
		}
		// Didn't find a lyric - check if the Ctrl key is down
		else if( wParam & MK_CONTROL )
		{
			// Toggle the selection state in the region under the cursor
			m_pSelectedRegions->ToggleRegion( lXPos );
		}
		// The shift key is up
		else
		{
			// The user left-clicked on blank space without holding the shift or Ctrl keys down

			// Clear all selection regions
			m_pSelectedRegions->Clear();
			m_pLyricMgr->UnselectAll();

			// Select only the beat clicked on
			m_pSelectedRegions->AddRegion( lXPos );
		}

		// Set anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( lXPos );
	}

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the lyric property page
	m_pLyricMgr->OnShowProperties();

	// Refresh the lyric property page, if it exists
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::OnRButtonDown

HRESULT CLyricStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	ASSERT( m_pLyricMgr->m_pTimeline != NULL );

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	CLyricItem* pLyric = GetLyricFromPoint( lXPos );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if a lyric was clicked on
		if( pLyric )
		{
			// Check if the lyric is selected
			if( pLyric->m_fSelected == FALSE )
			{
				// Lyric is not selected, unselect all lyrics
				m_pLyricMgr->UnselectAll();

				// Select just this lyric
				pLyric->m_fSelected = TRUE;

				// Add just this beat to the list of selected regions
				m_pSelectedRegions->AddRegion(lXPos);
			}
			// If the lyric was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure and beat
			long lMeasure, lBeat;
			if( SUCCEEDED( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat(m_pLyricMgr->m_dwGroupBits,
															0,lXPos, &lMeasure, &lBeat) ) )
			{
				// Check if this beat is not already selected
				if( !m_pSelectedRegions->Contains(lMeasure, lBeat))
				{
					// This beat is not selected - unselect all beats
					m_pLyricMgr->UnselectAll();

					// Now, select just this beat
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
		}
	}

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch to the lyric property page
	m_fShowItemProps = true;
	m_pLyricMgr->OnShowProperties(); 

	// Refresh the lyric property page, if it exists
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanCycle

BOOL CLyricStrip::CanCycle( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pLyricMgr->m_pTimeline != NULL );
	if( m_pLyricMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;

	if( SUCCEEDED ( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat ) ) )
	{
		int nCount = 0;
		CLyricItem* pItem;

		POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
		while( pos )
		{
			pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( ++nCount > 1 )
				{
					return TRUE;
				}
			}

			if( pItem->m_lMeasure > lMeasure )
			{
				break;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::PostRightClickMenu

HRESULT CLyricStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;

	HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
			MF_GRAYED | MF_BYPOSITION );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( IsEmpty() ) ? MF_GRAYED :
			MF_ENABLED );
	::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
	::EnableMenuItem( hMenuPopup, IDM_CYCLE_LYRICS, ( CanCycle() == TRUE ) ? MF_ENABLED :
			MF_GRAYED );

	m_pLyricMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
	::DestroyMenu( hMenu );

	m_fInRightClickMenu = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::UnselectGutterRange

void CLyricStrip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_pLyricMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pLyricMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CreateDataObject

HRESULT	CLyricStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_pLyricMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}


	// Save Selected Lyrics into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream;
	if( SUCCEEDED ( m_pLyricMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Get the lyric at the drag point
		CLyricItem* pLyricAtDragPoint = GetLyricFromPoint( lPosition );

		// mark the lyrics as being dragged: this used later for deleting lyrics in drag move
		m_pLyricMgr->MarkSelectedLyrics(UD_DRAGSELECT);

		// Save the selected lyrics into a stream
		if( SUCCEEDED ( m_pLyricMgr->SaveSelectedLyrics( pIStream, pLyricAtDragPoint ) ) )
		{
			// Add the stream to the Timeline DataObject
			if( SUCCEEDED ( pITimelineDataObject->AddExternalClipFormat( m_cfLyricList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CLyricStrip::DoDragDrop

HRESULT CLyricStrip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos)
{
	// Do a drag'n'drop operation

	// Get the lyric at the point we're dragging from
	CLyricItem* pLyric = GetLyricFromPoint( lXPos );

	// Check that we found a lyric item, and that it is selected
	if(!pLyric || !pLyric->m_fSelected)
	{
		// Didn't find a selected lyric - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected lyrics
		hr = CreateDataObject( &m_pISourceDataObject, lXPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy lyrics.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut lyrics
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the lyrics as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Initialize our DragDropSource DocRoot fields
			CLyricStrip::m_pIDocRootOfDragDropSource = m_pLyricMgr->m_pIDocRootNode;
			CLyricStrip::m_fDragDropIntoSameDocRoot = FALSE;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some lyrics - delete the lyrics we marked earlier
					m_pLyricMgr->DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the lyrics somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_pLyricMgr->m_nLastEdit = IDS_UNDO_MOVE;
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_pLyricMgr->m_nLastEdit = IDS_INSERT;
					}

					// Notify the Segment Designer that we changed
					m_pLyricMgr->OnDataChanged();

					// Update the selection regions to include the selected lyrics
					SelectRegionsFromSelectedLyrics();

					// If visible, switch the property sheet to the lyric property page
					m_pLyricMgr->OnShowProperties();

					// If it exists, refresh the lyric property page
					if( m_pLyricMgr->m_pPropPageMgr )
					{
						m_pLyricMgr->m_pPropPageMgr->RefreshData();
					}

					// Sync with DirectMusic
					m_pLyricMgr->SyncWithDirectMusic();
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// Check if we dropped in the same segment
						if( CLyricStrip::m_fDragDropIntoSameDocRoot == TRUE )
						{
							// We did a move operation to another strip in the same segment - use the 'Move' undo text
							m_pLyricMgr->m_nLastEdit = IDS_UNDO_MOVE;
						}
						else
						{
							// We did a move operation to another strip in a different segment - use the 'Delete' undo text
							m_pLyricMgr->m_nLastEdit = IDS_DELETE;
						}

						// Notify the Segment Designer that we changed
						m_pLyricMgr->OnDataChanged();

						// Sync with DirectMusic
						m_pLyricMgr->SyncWithDirectMusic();
					}
					else
					{
						// Unselect all lyrics, since the user did a copy operation
						m_pLyricMgr->UnselectAll();
					}
				}

				// Refresh our strip display
				m_pLyricMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all lyrics
		m_pLyricMgr->UnMarkLyrics(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource flag
	m_nStripIsDragDropSource = 0;
	CLyricStrip::m_pIDocRootOfDragDropSource = NULL;
	CLyricStrip::m_fDragDropIntoSameDocRoot = FALSE;

	// Return a success or failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CLyricStrip::SelectItemsInSelectedRegions

bool CLyricStrip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of lyrics
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		// Check if this lyric is within a selection region
		if(m_pSelectedRegions->Contains(pLyricItem->m_lMeasure, pLyricItem->m_lBeat))
		{
			// Check if the lyric is not selected
			if( !pLyricItem->m_fSelected )
			{
				// Lyric isn't yet selected - select it and set fChanged to true
				pLyricItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the lyric is selected
			if( pLyricItem->m_fSelected )
			{
				// Lyric is selected - deselect it and set fChagned to true
				pLyricItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any lyrics
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// CLyricStrip::SelectRegionsFromSelectedLyrics

void CLyricStrip::SelectRegionsFromSelectedLyrics()
{
	// Clear the list of selected regions
	m_pSelectedRegions->Clear();

	// Iterate through the list of lyrics
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if(pLyricItem->m_fSelected)
		{
			// Add the beat the lyric is in to the list of selected regions.
			CListSelectedRegion_AddRegion(*m_pSelectedRegions, *pLyricItem);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::IsSelected

bool CLyricStrip::IsSelected()
{
	if( m_pLyricMgr == NULL )
	{
		ASSERT( 0 );
		return false;
	}

	// If anything is selected, return true
	
	// Iterate through the list of lyrics
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Check if this lyric is selected
		if( m_pLyricMgr->m_lstLyrics.GetNext( pos )->m_fSelected )
		{
			// Lyric is selected - return true
			return true;
		}
	}

	// No lyrics selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::IsEmpty

bool CLyricStrip::IsEmpty()
{
	if( m_pLyricMgr == NULL )
	{
		ASSERT( 0 );
		return true;
	}

	return m_pLyricMgr->m_lstLyrics.IsEmpty() ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::SelectSegment

// Return true if anything changed
bool CLyricStrip::SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime)
{
	// Verify that we have a pointer to the Timeline
	if( m_pLyricMgr == NULL 
	||  m_pLyricMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return false;
	}

	// Convert the start position from clocks to a measure and beat value
	long lMeasure, lBeat;
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
												   mtBeginTime, &lMeasure, &lBeat );

	
	// Convert back to a clock value
	m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
												   lMeasure, lBeat, &mtBeginTime );

	// Convert the end position from clocks to a measure and beat value
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
												   mtEndTime, &lMeasure, &lBeat );

	
	// Increment the beat so the last beat is selected
	lBeat++;

	// Convert back to a clock value
	m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
												   lMeasure, lBeat, &mtEndTime );

	// Convert the passed in times to a generic time class
	CMusicTimeConverter cmtBeg(mtBeginTime);
	CMusicTimeConverter cmtEnd(mtEndTime);

	// Create a region that contains the selected time
	CSelectedRegion region(cmtBeg, cmtEnd);

	// Add the region to the list of selected regions
	m_pSelectedRegions->AddRegion(region);

	// Select all items in the list of selected regions
	// This will return true if the selection state of any lyric changed
	return SelectItemsInSelectedRegions();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\PropPageMgr.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <staticproppagemanager.h>

class PropPageLyric;
class CLyricMgr;

class CLyricPropPageMgr : public CStaticPropPageManager
{
	friend PropPageLyric;
public:
	CLyricPropPageMgr( CLyricMgr* pLyricMgr );
	~CLyricPropPageMgr();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	PropPageLyric*		m_pPropPageLyric;
	CLyricMgr*			m_pLyricMgr;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\LyricStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LyricStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_LYRIC              101
#define IDR_LYRICMGR                    102
#define IDS_DELETE                      103
#define IDS_PASTE                       104
#define IDS_INSERT                      105
#define IDD_LYRIC_PROPPAGE              106
#define IDS_TRACK_NAME                  107
#define IDS_PROPPAGE_GROUP_BITS         108
#define IDS_MULTIPLE_SELECT             109
#define IDS_UNDO_CHANGE                 110
#define IDS_UNDO_MOVE                   111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_STRIP_NAME                  113
#define IDS_DEFAULT_LYRIC_TEXT          114
#define IDS_UNDO_CHANGE_TIMING          115
#define IDS_UNDO_LOGICAL_TIME           116
#define IDC_EDIT_LYRIC                  201
#define IDR_EDIT_RMENU                  201
#define IDC_EDIT_BEAT                   202
#define IDC_SPIN_BEAT                   203
#define IDC_EDIT_MEASURE                204
#define IDC_SPIN_MEASURE                205
#define IDR_EDITMENU                    206
#define IDC_EDIT_TICK                   206
#define IDM_DRAG_RMENU                  207
#define IDC_SPIN_TICK                   207
#define IDC_TIMING_QUICK                210
#define IDC_TIMING_BEFORE_TIME          211
#define IDC_TIMING_AT_TIME              212
#define IDC_EDIT_BELONGS_MEASURE        227
#define IDC_EDIT_BELONGS_BEAT           228
#define IDC_SPIN_BELONGS_MEASURE        232
#define IDC_SPIN_BELONGS_BEAT           233
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_LYRICS                32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        255
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         208
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\BaseMgr.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BaseMgr.cpp : implementation file
//

#include "stdafx.h"
#include "BaseMgr.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "SegmentGuids.h"
#include "SegmentIO.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr constructor/destructor 

CBaseMgr::CBaseMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pIDocRootNode = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pIDMTrack = NULL;
	m_pBaseStrip = NULL;

	// By default, belong to Group 1 only
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// Initially, no edits have happened
	m_nLastEdit = 0;

	// Initalize track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
	m_dwProducerOnlyFlags = 0;

	// TODO: Derived class must create a strip and assign it to m_pBaseStrip
	// OR: Derived class must override all methods referencing m_pBaseStrip
}

CBaseMgr::~CBaseMgr()
{
	// Clean up our references
	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pBaseStrip == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}

	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IDMUSProdStripMgr implementation


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetParam

HRESULT STDMETHODCALLTYPE CBaseMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	// Check if the segment is asking for a string to display in the Undo and Redo edit menu items
	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		// Try and load our current undo string
		CComBSTR comBSTR;
		if( comBSTR.LoadString( m_nLastEdit ) )
		{
			// Succeeded - return the BSTR
			*(BSTR*)pData = comBSTR.Detach();
			return S_OK;
		}
		return E_FAIL;
	}

	// Get DocRoot node of StripMgr's file (i.e. the Segment)
	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode** ppIDocRootNode = (IDMUSProdNode **)pData;

		*ppIDocRootNode = m_pIDocRootNode;
		if( m_pIDocRootNode )
		{
			m_pIDocRootNode->AddRef();
		}
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::SetParam

HRESULT STDMETHODCALLTYPE CBaseMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);

	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode* pIDocRootNode = (IDMUSProdNode *)pData;

		m_pIDocRootNode = pIDocRootNode;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CBaseMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// We support returning text to display in the Undo and Redo edit menu items.
	// We support GUID_DocRootNode for maintaining pointer to our DocRoot node.
	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) 
	||  ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		return S_OK;
	}
	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CBaseMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pData);

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Update the m_mtTime value of all items
		if( RecomputeTimes() )
		{
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}
			OnDataChanged();
		}

		// Redraw our strip
		if( m_pBaseStrip )
		{
			m_pTimeline->StripInvalidateRect( m_pBaseStrip, NULL, TRUE );
		}
		return S_OK;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Update the m_mtTime value of all items
		RecomputeTimes();

		// Redraw our strip
		if( m_pBaseStrip )
		{
			m_pTimeline->StripInvalidateRect( m_pBaseStrip, NULL, TRUE );
		}
		return S_OK;
	}

	// We don't handle whichever notification was passed to us
	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CBaseMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		// Return a copy of our timeline pointer
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			return m_pTimeline->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		// Return a copy of our DirectMusic track pointer
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		// Return a copy of our framework pointer
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		// Check that the caller passed in a reference
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			// The reference passed by the caller is a pointer to a DMUS_TRACK_HEADER structure.
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			// Fill in the structure with our data
			pioTrackHeader->guidClassID = m_clsid;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = m_ckid;
			pioTrackHeader->fccType = m_fccType;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = g_dwTrackExtrasMask;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CBaseMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		// Check that the caller passed in an IUnknown pointer
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we were previously attached to a timeline
		if( m_pTimeline )
		{
			// Make sure our property page isn't displayed
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);

			// Release our reference on our property page manager
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->Release();
				m_pPropPageMgr = NULL;
			}

			// Remove our strip from the Timeline
			if ( m_pBaseStrip )
			{
				// Make sure our strip's property page isn't displayed
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pBaseStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pBaseStrip );
			}

			// Remove ourself from the Timeline's notification list
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );

			// Release our reference on the Timeline
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		// If a non-NULL pointer was passed in
		if( V_UNKNOWN( &variant ) )
		{
			// Query the pointer for a Timeline interface
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				// Add the strip to the timeline
				ASSERT( m_pBaseStrip );
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pBaseStrip, m_clsid, m_dwGroupBits, 0 );

				// Add ourself to the Timeline's notification list
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		// Check that the caller passed in an IUnknown pointer
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we have an existing DirectMusic track pointer, release it
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
			m_pIDMTrack = NULL;
		}

		// If we were passed a non-NULL pointer, query it for an IDirectMusicTrack interface
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		// Check that the caller passed in an IUnknown pointer
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we have an existing Framework pointer, release it
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}

		// If we were passed a non-NULL pointer, query it for an IDMUSProdFramework interface
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		// Check that the caller passed in a reference
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			// The reference should be a pointer to a DMUS_IO_TRACK_HEADER structure
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			// Update our group bits settings
			// If your strip does not support changing its group bits, you must override
			// this method so that m_dwGroupBits and m_dwOldGroupBits do not get updated.
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;

			// Ignore everything else in the structure, since we don't care about it
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = pioTrackExtrasHeader->dwFlags;
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		// We don't support whichever property was given
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetClassID

HRESULT CBaseMgr::GetClassID( CLSID* pClsId )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate pClsId
	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &m_clsid, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::IsDirty

HRESULT CBaseMgr::IsDirty()
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK; // Dirty
	}
	else
	{
		return S_FALSE; // Clean
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetSizeMax

HRESULT CBaseMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pcbSize);

	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CBaseMgr::OnRemoveFromPageManager( void)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::OnDataChanged

void CBaseMgr::OnDataChanged( void )
{
	// Verify that we have a valid pointer to the Timeline
	if ( m_pTimeline == NULL )
	{
		return;
	}

	// Let our hosting editor know about the change
	IUnknown *punkStripMgr;
	if( SUCCEEDED( QueryInterface( IID_IUnknown, (void **)&punkStripMgr ) ) )
	{
		m_pTimeline->OnDataChanged( punkStripMgr );
		punkStripMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::SyncWithDirectMusic

HRESULT CBaseMgr::SyncWithDirectMusic( void )
{
	// If there is no DirectMusic Track, return S_FALSE
	if( m_pIDMTrack == NULL )
	{
		return S_FALSE;
	}

	// Create a memory stream to use
	IStream* pIMemStream = NULL;
	HRESULT hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		// Ensure the stream is at the beginning
		const LARGE_INTEGER liStart = {0,0};
		pIMemStream->Seek( liStart, STREAM_SEEK_SET, NULL );

		// Save our self
		hr = Save(pIMemStream, FALSE);
		if ( SUCCEEDED( hr ) )
		{
			// Query the DirectMusic Track for its IPersistStream interface
			IPersistStream* pIPersistStream = NULL;
			hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
			if ( SUCCEEDED( hr ) )
			{
				// Seek back to the beginning of the stream
				pIMemStream->Seek( liStart, STREAM_SEEK_SET, NULL );

				// Load the DirectMusic Track with the new data
				hr = pIPersistStream->Load(pIMemStream);

				// If we have a Segment DocRoot Node pointer, initialize the DirectMusic Track
				if( m_pIDocRootNode )
				{
					// Get a pointer to the DirectMusic segment the track is in
					IDirectMusicSegment *pSegment;
					if( SUCCEEDED( m_pIDocRootNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
					{
						// Now, initialize the track.
						m_pIDMTrack->Init( pSegment );
						pSegment->Release();
					}
				}

				// Release the track's IPersistStream interface reference
				pIPersistStream->Release();
			}
		}

		// Release the reference to the memory stream
		pIMemStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// MeasureBeatToBeats

HRESULT MeasureBeatToBeats( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long &lNumBeats )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lMeasure >= 0 );
	ASSERT( lBeat >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	HRESULT hr;
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;

	// Initialize value to return
	lNumBeats = 0;

	// Loop until lMeasure is zero
	do
	{
		// Get the time signature at mtTSCur
		hr = pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig );
		if ( FAILED( hr ) )
		{
			return E_UNEXPECTED;
		}

		// Check if this time signature is valid forever
		if( mtTSNext == 0 )
		{
			// Just compute the number of beats to add and break out of the loop
			lNumBeats += lMeasure * TimeSig.bBeatsPerMeasure;
			break;
		}
		else
		{
			// Compute the number of clocks in a measure
			long lMeasureClocks = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// Compute the number of measures until the next time signature
			long lTmpMeasures = mtTSNext / lMeasureClocks;

			// If we won't reach the next time signature
			if( lMeasure <= lTmpMeasures )
			{
				// Just compute the number of beats to add and break out of the loop
				lNumBeats += lMeasure * TimeSig.bBeatsPerMeasure;
				break;
			}
			else
			{
				// Compute when to look for the next time signature
				mtTSCur += lMeasureClocks * lTmpMeasures;

				// Compute the number of beats to add
				lNumBeats += lTmpMeasures * TimeSig.bBeatsPerMeasure;

				// Update the number of measures we have left to traverse
				lMeasure -= lTmpMeasures;
			}
		}
	}
	while( lMeasure > 0 );

	// We've compute all the beats from the lMeasure paramter - now just add lBeat
	lNumBeats += lBeat;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// BeatsToMeasureBeat

HRESULT BeatsToMeasureBeat( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumBeats, long &lMeasure, long &lBeat )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lNumBeats >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext;
	lBeat = 0;
	lMeasure = 0;

	do
	{
		// Try and get the current time signature
		if ( FAILED( pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig ) ) )
		{
			return E_UNEXPECTED;
		}

		// If there is no next time signature, do the math to find how many more measures to add
		if( mtTSNext == 0 )
		{
			lMeasure += lNumBeats / TimeSig.bBeatsPerMeasure;
			lNumBeats %= TimeSig.bBeatsPerMeasure;
			break;
		}
		// Otherwise it's more complicated
		else
		{
			// Compute the number of clocks in a beat
			long lBeatClocks = NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// If the next time signature is after the time we're looking for
			if( lNumBeats < mtTSNext / lBeatClocks )
			{
				// Add the number of complete measures between here and there
				lMeasure += lNumBeats / TimeSig.bBeatsPerMeasure;

				// lNumBeats now stores an offset from the beginning of the measure
				lNumBeats %= TimeSig.bBeatsPerMeasure;
				break;
			}
			// The next time signature is before the time we're looking for
			else
			{
				// Compute how many complete measures there are between now and the next Time signature
				long lMeasureDiff= mtTSNext / (TimeSig.bBeatsPerMeasure * lBeatClocks);

				// Add them to lMeasure
				lMeasure += lMeasureDiff;

				// Subtract off the number of beats between mtTSCur and mtTSNext
				lNumBeats -= lMeasureDiff * TimeSig.bBeatsPerMeasure;

				// Change lMeasureDiff from measures to clocks
				lMeasureDiff *= TimeSig.bBeatsPerMeasure * lBeatClocks;

				// Add the clocks of the measures between mtTSCur and mtTSNext to mtTSCur
				mtTSCur += lMeasureDiff;
			}
		}
	}
	// While the beats left is greater than 0
	while ( lNumBeats > 0 );

	// Any leftover beats are assigned to lBeat
	lBeat = lNumBeats;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\BasePropPageManager.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1997-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BasePropPageManager.cpp: implementation of CBasePropPageManager
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <afxole.h>         // MFC OLE classes

#include "BasePropPageManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CBasePropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBasePropPageManager::CBasePropPageManager()
{
	m_dwRef				= 0;
	AddRef();
	m_pIPropPageObject	= NULL;
	m_pIPropSheet		= NULL;
}

CBasePropPageManager::~CBasePropPageManager()
{
	if( m_pIPropSheet )
	{
		m_pIPropSheet->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IUnknown implementation

HRESULT CBasePropPageManager::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	if(::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	|| ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL; 
    return E_NOINTERFACE; 
}

ULONG CBasePropPageManager::AddRef()
{
    return ++m_dwRef;
}

ULONG CBasePropPageManager::Release()
{
    ASSERT(m_dwRef != 0);

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager::RemoveCurrentObject

void CBasePropPageManager::RemoveCurrentObject()
{
	if(m_pIPropPageObject == NULL)
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CBasePropPageManager::OnRemoveFromPropertySheet()
{
	RemoveCurrentObject();

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CBasePropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( S_OK == IsEqualObject(pINewPropPageObject) )
	{
//	    RefreshData();

	    if( m_pIPropSheet )
	    {
		    m_pIPropSheet->RefreshTitle();
		    m_pIPropSheet->RefreshActivePage();
	    }
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CBasePropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CBasePropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT FAR EXPORT CBasePropPageManager::IsEqualPageManagerGUID(REFGUID rguidPageManager)
{
	if(::IsEqualGUID(rguidPageManager, m_GUIDManager))
	{
		return S_OK;
	}

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\BasePropPageManager.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1997-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BasePropPageManager.h: interface for the CBasePropPageManager class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __BASEPROPPAGEMANAGER_H__
#define __BASEPROPPAGEMANAGER_H__

#include "DMUSProd.h"

//////////////////////////////////////////////////////////////////////
//  CBasePropPageManager

class CBasePropPageManager : public IDMUSProdPropPageManager 
{
public:
	CBasePropPageManager();
	virtual ~CBasePropPageManager();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText ) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages ) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    virtual HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    virtual HRESULT STDMETHODCALLTYPE RefreshData() = 0;
    virtual HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
protected:
	void RemoveCurrentObject();

	// Member variables
protected:
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	GUID						m_GUIDManager;
private:
	DWORD						m_dwRef;
};

#endif //__BASEPROPPAGEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\BaseStrip.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BaseStrip.cpp : Implementation of CBaseStrip
#include "stdafx.h"
#include "BaseMgr.h"
#include "selectedregion.h"
#include "resource.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DEFAULT_STRIP_HEIGHT 20

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}


IDMUSProdNode*	CBaseStrip::m_pIDocRootOfDragDropSource = NULL;
BOOL			CBaseStrip::m_fDragDropIntoSameDocRoot = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip constructor/destructor

CBaseStrip::CBaseStrip( CBaseMgr* pBaseMgr )
{
	ASSERT( pBaseMgr );
	if ( pBaseMgr == NULL )
	{
		return;
	}

	m_pBaseMgr = pBaseMgr;

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_bGutterSelected = FALSE;
	m_lGutterBeginSelect = 0;
	m_lGutterEndSelect = 0;

	m_fSelecting = FALSE;
	m_nStripIsDragDropSource = 0;

	m_lXPos = 0;
	m_pSelectedRegions = NULL;

	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_lStartDragPosition = 0;
	m_fPropPageActive = FALSE;
	m_dwDropEffect = DROPEFFECT_NONE;
	m_fInRightClickMenu = false;
	m_pPropPageMgr = NULL;
	m_fInFunctionBarMenu = false;
}

CBaseStrip::~CBaseStrip()
{
	ASSERT( m_pBaseMgr );
	if ( m_pBaseMgr )
	{
		//m_pBaseMgr->Release();
		m_pBaseMgr = NULL;
	}
	if ( m_pISourceDataObject )
	{
		m_pISourceDataObject->Release();
		m_pISourceDataObject = NULL;
	}
	if ( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}
	if ( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}

	if(m_pSelectedRegions)
	{
		delete m_pSelectedRegions;
		m_pSelectedRegions = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::QueryInterface

STDMETHODIMP CBaseStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::AddRef

STDMETHODIMP_(ULONG) CBaseStrip::AddRef(void)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Release

STDMETHODIMP_(ULONG) CBaseStrip::Release(void)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Draw

HRESULT	STDMETHODCALLTYPE CBaseStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	// Validate our pointer to the Timeline
	if( m_pBaseMgr->m_pTimeline )
	{
		// Draw Measure and Beat lines in our strip
		m_pBaseMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pBaseMgr->m_dwGroupBits, 0, lXOffset );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CBaseStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = DEFAULT_STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			BSTR bstr;
			CString strStripName;
			strStripName.LoadString( IDS_STRIP_NAME );

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = GetName(m_pBaseMgr->m_dwGroupBits, strStripName).AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pBaseMgr )
		{
			m_pBaseMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CBaseStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	bool fRefresh = false;

	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		// Verify that we're passed an integer
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}

		// Update the appropriate member variables with the new information
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		// This flag will be true iff we're trying to clear the selections in all other strips
		if( m_fSelecting )
		{
			break;
		}

		// Initialize anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( 0 );

		// If the start time and the end time are identical, unselect everything
		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			// Clear all selections
			if( m_pSelectedRegions )
			{
				fRefresh = m_pSelectedRegions->Clear();
			}

			// Deselect all items
			if( SelectItemsInSelectedRegions() || fRefresh )
			{
				// If any items become unselected, redraw the strip
				m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			break;
		}

		// If our gutter is selected
		if( m_bGutterSelected )
		{
			// Clear all current selections
			if( m_pSelectedRegions )
			{
				m_pSelectedRegions->Clear();
			}

			// Always need to refresh the display
			fRefresh = true;

			// Select all items between the new time range, and deselect all items
			// outside the new time range
			SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			// Our gutter is not selected
			// Clear all current selections
			if( m_pSelectedRegions )
			{
				fRefresh = m_pSelectedRegions->Clear();
			}

			// If any items become unselected, set fRefresh to true
			fRefresh |= SelectItemsInSelectedRegions();
		}

		// If the selection state of any item was changed
		if( fRefresh )
		{
			// Redraw the strip
			m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

			// Update the item property page
			if( m_pBaseMgr->m_pPropPageMgr != NULL )
			{
				m_pBaseMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case SP_GUTTERSELECT:
		// Check if the gutter selection state changed
		if( m_bGutterSelected != V_BOOL(&var) )
		{
			// Save the new state of the gutter selection
			m_bGutterSelected = V_BOOL(&var);

			// If the time range is empty
			if( m_lGutterBeginSelect == m_lGutterEndSelect )
			{	
				// Clear all current selections
				if( m_pSelectedRegions )
				{
					m_pSelectedRegions->Clear();
				}

				// If any items become unselected, redraw the strip
				if( SelectItemsInSelectedRegions() )
				{
					m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
				}
				break;
			}

			// Check if the gutter became selected
			if( m_bGutterSelected )
			{
				// Clear the list of selected regions
				if( m_pSelectedRegions )
				{
					m_pSelectedRegions->Clear();
				}

				// Select the segment of the timeline
				// This will return true if the selection state of any item changed
				fRefresh = SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
			}
			else
			{
				// Clear the list of selected regions
				if( m_pSelectedRegions )
				{
					m_pSelectedRegions->Clear();
				}

				// Clear the selection state of all items
				// This will return true if the selection state of any item changed
				fRefresh = SelectItemsInSelectedRegions();
			}

			// Since the gutter state changed, we need to redraw the strip
			m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

			// However, only update the property page if the selection state of any items
			// changed
			if( fRefresh )
			{
				// Update the property page
				if( m_pBaseMgr->m_pPropPageMgr != NULL )
				{
					m_pBaseMgr->m_pPropPageMgr->RefreshData();
				}
			}
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CBaseStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Process the window message
	HRESULT hr = S_OK;
	if( m_pBaseMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_RBUTTONUP:
		// Display a right-click context menu.

		// Get the cursor position (To put the menu there)
		POINT pt;
		if( !GetCursorPos( &pt ) )
		{
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			break;
		}

		// Save the position of the click so we know where to insert a Lyric. if Insert is selected.
		m_lXPos = lXPos;

		// Display the menu
		PostRightClickMenu( pt );
		hr = S_OK;
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = ShowPropertySheet();
			if (m_fShowItemProps)
			{
				// Change to the lyric property page
				m_pBaseMgr->OnShowProperties();

				// Update the property page, if it exists
				if( m_pBaseMgr->m_pPropPageMgr )
				{
					m_pBaseMgr->m_pPropPageMgr->RefreshData();
				}
			}
			else
			{
				// Change to our property page
				OnShowProperties();

				// Update the property page, if it exists
				if( m_pPropPageMgr )
				{
					m_pPropPageMgr->RefreshData();
				}
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE_OVERWRITE:
		case ID_EDIT_PASTE:
			// TODO: Paste->Merge vs. Paste->Overwrite distinction?
			hr = Paste();
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_CREATE:
		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
		m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );

		if(!m_pSelectedRegions)
		{
			m_pSelectedRegions = new CListSelectedRegion(m_pBaseMgr->m_pTimeline, m_pBaseMgr->m_dwGroupBits);
		}
		else
		{
			m_pSelectedRegions->Timeline() = m_pBaseMgr->m_pTimeline;
			m_pSelectedRegions->GroupBits() = m_pBaseMgr->m_dwGroupBits;
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::FBDraw

HRESULT CBaseStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(hDC);
	UNREFERENCED_PARAMETER(sv);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::FBOnWMMessage

HRESULT CBaseStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Change the property page to the strip (group bits) property page
		m_fShowItemProps = FALSE;
		OnShowProperties();
		break;

	case WM_RBUTTONUP:
		// Change the property page to the strip (group bits) property page
		m_fShowItemProps = FALSE;
		OnShowProperties();

		// Set the cursor position for the insert operation to -1
		m_lXPos = -1;

		// Get the cursor position (To put the menu there)
		POINT pt;
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Display a right-click context menu.
		m_fInFunctionBarMenu = true;
		hr = PostRightClickMenu( pt );
		m_fInFunctionBarMenu = false;
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Cut

HRESULT CBaseStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that we can actually cut
	if( CanCut() != S_OK )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	HRESULT hr = Copy(pITimelineDataObject);

	// If the copy succeeded, do the delete
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Copy

// Pure virtual
// HRESULT CBaseStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Paste

// Pure virtual
// HRESULT CBaseStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Insert

// Pure virtual
// HRESULT CBaseStrip::Insert( void ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Delete

// Pure virtual
// HRESULT CBaseStrip::Delete( void ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::SelectAll

HRESULT CBaseStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pBaseMgr != NULL );
	if( m_pBaseMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBaseMgr->m_pTimeline != NULL );
	if( m_pBaseMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Select everything
	m_pSelectedRegions->SelectAll();

	// Update the selection state of the items
	if( SelectItemsInSelectedRegions() )
	{
		// If an an item became selected, redraw the strip
		m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Update the item property page
		if( m_pBaseMgr->m_pPropPageMgr != NULL )
		{
			m_pBaseMgr->m_pPropPageMgr->RefreshData();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanCut

HRESULT CBaseStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pBaseMgr != NULL );
	if( m_pBaseMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pBaseMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	// Otherwise, Cut is simply a Copy followed by a Delete
	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanCopy

HRESULT CBaseStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pBaseMgr != NULL );
	if( m_pBaseMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pBaseMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	// Otherwise, check if anything is selected
	return IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanPaste

// Pure virtual
// HRESULT CBaseStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanInsert

// Pure virtual
// HRESULT CBaseStrip::CanInsert( void ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanDelete

HRESULT CBaseStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if anything is selected
	return IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanSelectAll

HRESULT CBaseStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fInRightClickMenu == FALSE )
	{
		// Always enable when gutter is selected
		if( m_bGutterSelected )
		{
			return S_OK;
		}
	}

	if( IsEmpty() )
	{
		return S_FALSE;
	}

	return S_OK;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::QueryContinueDrag

HRESULT CBaseStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GiveFeedback

HRESULT CBaseStrip::GiveFeedback( DWORD dwEffect )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwEffect);

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::DragEnter

HRESULT CBaseStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIDataObject == NULL )
	{
		ASSERT(FALSE); // This shouldn't happen
		return E_POINTER;
	}

	if( m_pITargetDataObject )
	{
		ASSERT(FALSE); // This shouldn't happen

		m_pITargetDataObject->Release();
		// No need - it's overwritten just below
		// m_pITargetDataObject = NULL;
	}

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::DragOver

HRESULT CBaseStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pt);

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if(m_pITargetDataObject == NULL)
	{
		ASSERT( FALSE ); // Shouldn't happen - CanPasteFromData will return E_POINTER.
	}

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::DragLeave

HRESULT CBaseStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Drop

// Pure virtual
//HRESULT CBaseStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect) = 0;


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GetData

HRESULT CBaseStrip::GetData( void **ppData )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pBaseMgr->m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pBaseMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = g_dwTrackExtrasMask;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pBaseMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = g_dwProducerOnlyMask;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::SetData

HRESULT CBaseStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	// Check which property page is setting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_pBaseMgr->m_dwGroupBits )
		{
			m_pBaseMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;

			// Time signature may have changed
			m_pBaseMgr->OnUpdate( GUID_TimeSignature, m_pBaseMgr->m_dwGroupBits, NULL );

			// Notify our editor that we've changed
			m_pBaseMgr->m_nLastEdit = IDS_UNDO_TRACK_GROUP;
			m_pBaseMgr->OnDataChanged();

			// Update m_dwOldGroupBits after the call to OnDataChanged, because it is needed
			// to ensure the StripMgre removes itself correctly from the Timeline's notification
			// list.
			m_pBaseMgr->m_dwOldGroupBits = pPPGTrackParams->dwGroupBits;
		}
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pBaseMgr->m_dwTrackExtrasFlags )
		{
			m_pBaseMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_pBaseMgr->m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pBaseMgr->OnDataChanged();
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pBaseMgr->m_dwProducerOnlyFlags )
		{
			m_pBaseMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_pBaseMgr->m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pBaseMgr->OnDataChanged();
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::OnShowProperties

HRESULT CBaseStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate our Timeline pointer
	if( m_pBaseMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Validate our Framework pointer
	if( m_pBaseMgr->m_pDMProdFramework == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pBaseMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Check if our property page manager exists yet
	if( m_pPropPageMgr == NULL )
	{
		// Nope, need to create it
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;

		// Check if the creation succeeded.
		if( pPPM == NULL )
		{
			pIPropSheet->Release();
			return E_OUTOFMEMORY;
		}

		// Set m_pPropPageMgr with a reference to the IDMUSProdPropPageManager interface
		HRESULT hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );

		// Release our original reference on the property page manager (added when it
		// was created).
		m_pPropPageMgr->Release();

		// If the QueryInterface failed, return.
		if( FAILED(hr) )
		{
			pIPropSheet->Release();
			// Nothing to release for pPPM, since no reference was added by the call to QueryInterface.
			return hr;
		}
	}

	// Store the current active tab
	short nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;

	// Set the property page to refer to the group bits property page.
	m_pBaseMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Flag that the group bits property page is active
	m_fPropPageActive = TRUE;

	// Reset the active tab
	pIPropSheet->SetActivePage( nActiveTab ); 

	// release our reference to the property sheet
	pIPropSheet->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::OnRemoveFromPageManager

HRESULT CBaseStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Clear our property page manager
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}

	// Flag thar the group bits property page is not active
	m_fPropPageActive = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::ShowPropertySheet

HRESULT CBaseStrip::ShowPropertySheet( void )
{
	HRESULT hr = E_UNEXPECTED;

	// Get a pointer to the property sheet and show it
	IDMUSProdPropSheet*	pIPropSheet;
	if( m_pBaseMgr->m_pDMProdFramework )
	{
		hr = m_pBaseMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
		ASSERT( SUCCEEDED( hr ));
		if( SUCCEEDED( hr ))
		{
			pIPropSheet->Show( TRUE );
			pIPropSheet->Release();
			hr = S_OK;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::PostRightClickMenu

HRESULT CBaseStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;
	HRESULT hr = m_pBaseMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
	m_fInRightClickMenu = FALSE;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GetTimelineHWND

HWND CBaseStrip::GetTimelineHWND()
{
	HWND hwnd = NULL;
	IOleWindow *pOleWindow;
	if( m_pBaseMgr->m_pTimeline
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pOleWindow) ) )
	{
		pOleWindow->GetWindow( &hwnd );
		pOleWindow->Release();
	}

	return hwnd;
}


/////////////////////////////////////////////////////////////////////////////
// Helper methods

/////////////////////////////////////////////////////////////////////////////
// CopyDataToClipboard

HRESULT CopyDataToClipboard( IDMUSProdTimelineDataObject* pITimelineDataObject, IStream* pStreamCopy, UINT uiClipFormat, CBaseMgr *pBaseMgr, CBaseStrip *pBaseStrip )
{
	HRESULT hr;
	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed IDMUSProdTimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( uiClipFormat, pStreamCopy );
		if ( hr != S_OK )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}
	else
	{
		// There is no existing data object, so just create a new one
		hr = pBaseMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if(hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lRegionStart, lRegionEnd;
		pBaseStrip->m_pSelectedRegions->GetSpan(lRegionStart, lRegionEnd);
		hr = pITimelineDataObject->SetBoundaries(lRegionStart, (lRegionEnd - 1));

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( uiClipFormat, pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );
		if( hr != S_OK )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a pBaseMgr->m_pCopyDataObject, release it
		if(pBaseMgr->m_pCopyDataObject)
		{
			pBaseMgr->m_pCopyDataObject->Release();
		}

		// set pBaseMgr->m_pCopyDataObject to the object we just copied to the clipboard
		pBaseMgr->m_pCopyDataObject = pIDataObject;

		// Not needed = Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// pBaseMgr->m_pCopyDataObject->AddRef
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetTimelineDataObject

HRESULT GetTimelineDataObject( IDMUSProdTimelineDataObject* &pITimelineDataObject, IDMUSProdTimeline* pTimeline, IDataObject *pIDataObject )
{
	if(pITimelineDataObject == NULL)
	{
		if( pIDataObject == NULL )
		{
			// Get the IDataObject from the clipboard
			HRESULT hr = OleGetClipboard(&pIDataObject);
			if(FAILED(hr) || (pIDataObject == NULL))
			{
				return E_FAIL;
			}
		}
		else
		{
			pIDataObject->AddRef();
		}

		// Create a new TimelineDataObject
		HRESULT hr = pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			pITimelineDataObject = NULL;
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\BaseMgr.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-2001 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BaseMgr.h : Declaration of the CBaseMgr

#ifndef __BASEMGR_H_
#define __BASEMGR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <DMUSProd.h>

class CDllJazzDataObject;
interface IDirectMusicTrack;
class CBaseMgr;
class CBaseStrip;
class CListSelectedRegion;

extern const DWORD g_dwTrackExtrasMask;
extern const DWORD g_dwProducerOnlyMask;

#define NOTE_TO_CLOCKS(note, ppq) ( (ppq)*4 /(note) )

CString GetName(DWORD dwGroupBits, CString strName);
HRESULT CopyDataToClipboard( IDMUSProdTimelineDataObject* pITimelineDataObject, IStream* pStreamCopy, UINT uiClipFormat, CBaseMgr *pBaseMgr, CBaseStrip *pBaseStrip );
HRESULT GetTimelineDataObject( IDMUSProdTimelineDataObject* &pITimelineDataObject, IDMUSProdTimeline* pTimeline, IDataObject *pIDataObject = NULL );
HRESULT MeasureBeatToBeats( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long &lNumBeats );
HRESULT BeatsToMeasureBeat( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumBeats, long &lMeasure, long &lBeat );

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr
class ATL_NO_VTABLE CBaseMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CBaseStrip;

public:
	CBaseMgr();
	virtual ~CBaseMgr();

BEGIN_COM_MAP(CBaseMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	virtual STDMETHODIMP IsParamSupported( REFGUID guidType );
	virtual STDMETHODIMP GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	virtual STDMETHODIMP SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	virtual STDMETHODIMP OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	virtual STDMETHODIMP GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	virtual STDMETHODIMP SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist methods
	virtual STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream methods
	virtual HRESULT STDMETHODCALLTYPE IsDirty();
	virtual HRESULT STDMETHODCALLTYPE Load( IStream* pIStream ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Save( IStream* pIStream, BOOL fClearDirty ) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	virtual HRESULT STDMETHODCALLTYPE GetData( void **ppData) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetData( void *pData) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnShowProperties( void) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

protected:
	virtual void	OnDataChanged( void );
	virtual bool	RecomputeTimes( void ) = 0; // Returns true if anything changed
	virtual HRESULT	SyncWithDirectMusic( void ); // Returns S_OK if succeeded, S_FALSE if no track, E_* if failed.

public:
	IDMUSProdNode* GetDocRootNode()
	{
		return m_pIDocRootNode;
	}

public:
	IDMUSProdTimeline*			m_pTimeline;
	IDataObject*				m_pCopyDataObject;

protected:
	IDMUSProdFramework* 		m_pDMProdFramework;
	IDMUSProdNode*		 		m_pIDocRootNode;		// strip mgr belongs to this file (i.e. segment)
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDirectMusicTrack*			m_pIDMTrack;
	CBaseStrip*					m_pBaseStrip;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	bool						m_fDirty;
	UINT						m_nLastEdit;			// resource id of last edit
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;

protected:
	static const CLSID			m_clsid;
	static const DWORD			m_fccType;
	static const DWORD			m_ckid;
};


class CBaseStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CBaseMgr;

public:
	CBaseStrip( CBaseMgr* pLyricMgr );
	virtual ~CBaseStrip();

// IUnknown
	virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	virtual HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	virtual HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	virtual HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	virtual HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	virtual HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	virtual HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	virtual HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	virtual HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Insert( void ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Delete( void ) = 0;
	virtual HRESULT STDMETHODCALLTYPE SelectAll( void );
	virtual HRESULT STDMETHODCALLTYPE CanCut( void );
	virtual HRESULT STDMETHODCALLTYPE CanCopy( void );
	virtual HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject ) = 0;
	virtual HRESULT STDMETHODCALLTYPE CanInsert( void ) = 0;
	virtual HRESULT STDMETHODCALLTYPE CanDelete( void );
	virtual HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	virtual HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	virtual HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropTarget methods
	virtual HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	virtual HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	virtual HRESULT STDMETHODCALLTYPE DragLeave( void );
	virtual HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect) = 0;

// IDMUSProdPropPageObject functions
	virtual HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	virtual HRESULT STDMETHODCALLTYPE SetData( void *pData );
	virtual HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
// General helpers
	virtual bool	SelectItemsInSelectedRegions( void ) = 0;
	virtual bool	IsSelected( void ) = 0; // Returns true if any items are selected
	virtual bool	IsEmpty( void ) = 0;	// Returns false if there are any items
	virtual bool	SelectSegment(long begintime, long endtime) = 0; // Returns true if anything changed
	virtual HRESULT	ShowPropertySheet( void );
	virtual HRESULT	PostRightClickMenu( POINT pt );
	virtual HWND	GetTimelineHWND();

// IDropTarget helper
	virtual HRESULT CanPasteFromData(IDataObject* pIDataObject) = 0;

protected:
	long		m_cRef;
	CBaseMgr*	m_pBaseMgr;

public:
	CListSelectedRegion*	m_pSelectedRegions;

protected:
	LONG		m_lGutterBeginSelect;
	LONG		m_lGutterEndSelect;
	BOOL		m_bGutterSelected;		// whether the gutter select is selected, use
	
	BOOL		m_fSelecting;
	short		m_nStripIsDragDropSource;	
	static IDMUSProdNode*	m_pIDocRootOfDragDropSource;
	static BOOL				m_fDragDropIntoSameDocRoot;

	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*m_pISourceDataObject;	// Object being dragged 
	IDataObject*m_pITargetDataObject;
	DWORD		m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu
	LONG		m_lStartDragPosition;	// xpos where drag was started
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	DWORD		m_dwDropEffect;			// temp storage of whether drag/drop completed or aborted
	bool		m_fInRightClickMenu;
	bool		m_fShowItemProps;
	bool		m_fInFunctionBarMenu;	// true if the user right-clicked in the function bar
	IDMUSProdPropPageManager*	m_pPropPageMgr;
};


#endif //__LYRICMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\GroupBitsPPG.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {18E70D80-EA88-4224-8EA2-F336F24C053B}
const GUID GUID_GroupBitsPPGMgr = 
{ 0x18e70d80, 0xea88, 0x4224, { 0x8e, 0xa2, 0xf3, 0x36, 0xf2, 0x4c, 0x5, 0x3b } };

short CGroupBitsPropPageMgr::sm_nActiveTab = 0;
short* CGroupBitsPPG::sm_pnActiveTab = NULL;

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
	m_GUIDManager = GUID_GroupBitsPPGMgr;
	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Group bits tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	if( NULL == m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG = new CGroupBitsPPG();
	}
	if( m_pGroupBitsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_pIPropSheet = NULL;
	m_fNeedToDetach = FALSE;
	m_PPGTrackParams.dwPageIndex = GROUPBITSPPG_INDEX;
	m_PPGTrackParams.dwGroupBits = 0;
	m_PPGTrackParams.dwPropPageFlags = 0;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Copy the fEnable flag to a private flag for setting the group bits checkboxes
	BOOL fGroupBitsEnable = fEnable;

	// If the read-only flag is set, set fGroupBitsEnable to FALSE
	if( m_PPGTrackParams.dwPropPageFlags & GROUPBITSPPG_GROUPBITS_RO )
	{
		fGroupBitsEnable = FALSE;
	}

	// Now, enable or disable the group bits checkboxes
	for( int i = IDC_CHECK_GROUP1 ;  i <= IDC_CHECK_GROUP32 ;  i++ )
	{
		EnableItem( i, fGroupBitsEnable );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CGroupBitsPPG::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	PPGTrackParams *pPPGTrackParams = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pPPGTrackParams ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	CWnd* pWnd;

	// Group Bits check boxes
	int nState;
	int j;

	for( int i = IDC_CHECK_GROUP1 ;  i <= IDC_CHECK_GROUP32 ;  i++ )
	{
		pWnd = GetDlgItem( i );
		if( pWnd )
		{
			j = i - IDC_CHECK_GROUP1;

			if( m_PPGTrackParams.dwGroupBits & (1 << j) )
			{
				nState = 1;
			}
			else
			{
				nState = 0;
			}

			CheckDlgButton( i, nState );
		}
	}

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

BOOL CGroupBitsPPG::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nControlID = LOWORD( wParam );
	int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		if( nControlID >= IDC_CHECK_GROUP1
		&&  nControlID <= IDC_CHECK_GROUP32 )
		{
			CWnd* pWnd = GetDlgItem( nControlID );
			if( pWnd )
			{
				int nVariation = nControlID - IDC_CHECK_GROUP1;

				switch( IsDlgButtonChecked( nControlID ) )
				{
					case 0:		// Currently unchecked
						CheckDlgButton( nControlID, 1 );
						m_PPGTrackParams.dwGroupBits |= (1 << nVariation);
						UpdatePPO();
						break;

					case 1:		// Currently checked
						{
							// Don't allow ourself to be removed from all groups
							DWORD dwNewGroupBits = m_PPGTrackParams.dwGroupBits & ~(1 << nVariation);
							if( dwNewGroupBits == 0 )
							{
								CheckDlgButton( nControlID, 1 );
							}
							else
							{
								CheckDlgButton( nControlID, 0 );
								m_PPGTrackParams.dwGroupBits = dwNewGroupBits;
								UpdatePPO();
							}
						}
						break;
				}
			}

			return TRUE;
		}
	}
	
	return CPropertyPage::OnCommand( wParam, lParam );
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		m_pPPO->SetData( (void *)&m_PPGTrackParams );
	}
}

void CGroupBitsPPG::EnableItem(int nItem, BOOL fEnable)
{
	CWnd* pWnd;
	pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		pWnd->EnableWindow(fEnable);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\GroupBitsPPG.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-2001 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include <afxdlgs.h>
#include "GroupBitsPPGresource.h"

extern const GUID GUID_GroupBitsPPGMgr;


// GroupBitsPPG.h : header file
//

#define GROUPBITSPPG_INDEX 0

#define GROUPBITSPPG_GROUPBITS_RO 0x1

typedef struct _PPGTrackParams
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
	DWORD	dwPropPageFlags;
} PPGTrackParams;

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : public CStaticPropPageManager
{
public:
	CGroupBitsPropPageMgr();
	~CGroupBitsPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	class CGroupBitsPPG*	m_pGroupBitsPPG;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;

public:
	static short			sm_nActiveTab;
};

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_GROUP_BITS };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();
	void EnableItem(int nItem, BOOL fEnable);

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	PPGTrackParams				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\LockoutNotification.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#if !defined(AFX_LOCKOUTNOTIFICATION_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
#define AFX_LOCKOUTNOTIFICATION_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_

// CLockoutNotification class

class CLockoutNotification
{
public:
	CLockoutNotification( HWND hWnd)
	{
		// prevent control notifications from being dispatched
		m_pThreadState = AfxGetThreadState();
		m_hWndOldLockout = m_pThreadState->m_hLockoutNotifyWindow;
		m_fReset = FALSE;
		if( m_hWndOldLockout != hWnd )
		{
			m_fReset = TRUE;
			m_pThreadState->m_hLockoutNotifyWindow = hWnd;
		}
	}
	~CLockoutNotification()
	{
		// Reinstate control notifications
		if( m_fReset )
		{
			m_pThreadState->m_hLockoutNotifyWindow = m_hWndOldLockout;
		}
	}

	BOOL				m_fReset;
	_AFX_THREAD_STATE*	m_pThreadState;
	HWND				m_hWndOldLockout;

};

#endif // !defined(AFX_LOCKOUTNOTIFICATION_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\StaticPropPageManager.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1997-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// StaticPropPageManager.h: interface for the CStaticPropPageManager class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __STATICPROPPAGEMANAGER_H__
#define __STATICPROPPAGEMANAGER_H__

#include "BasePropPageManager.h"

//////////////////////////////////////////////////////////////////////
//  CStaticPropPageManager

class CStaticPropPageManager : public CBasePropPageManager 
{
public:
	CStaticPropPageManager();
	virtual ~CStaticPropPageManager();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText ) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages ) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    virtual HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    virtual HRESULT STDMETHODCALLTYPE RefreshData() = 0;
    virtual HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );
};

#endif //__STATICPROPPAGEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\SelectedRegion.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#include "stdafx.h"
#include <dmusici.h>
#include <dmusicf.h>

#include "SelectedRegion.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CListSelectedRegion::CListSelectedRegion(IDMUSProdTimeline* pTimeline, DWORD dwGroupbits)
: m_dwGroupbits(dwGroupbits), m_pTimeline(pTimeline)
{
//	m_pTimeline->AddRef();
	lShiftSelectAnchorPosition = 0;
}

CListSelectedRegion::~CListSelectedRegion()
{
	Clear();
//	m_pTimeline->Release();
}

// methods to add and modify region list

// add a region at position(converted to a time) whose duration = measure:beat
void CListSelectedRegion::AddRegion(long position, long measure, long beat)
{
	// now create and add this one
	CSelectedRegion* psr = new CSelectedRegion(position, measure, beat, m_pTimeline, m_dwGroupbits);
	AddHead(psr);
}

void CListSelectedRegion::AddRegion(const CSelectedRegion& csr)
{
	CSelectedRegion* psr = new CSelectedRegion(csr);
	AddHead(psr);
}


// toggle a region that contains the region formed by the given position
void CListSelectedRegion::ToggleRegion(long position)
{
	POSITION pos = FindContainingRegion(position);
	if(pos == NULL)
	{
		AddRegion(position, 0, 1);
	}
	else
	{
		CMusicTimeConverter mtcPos;
		mtcPos.SetTimeUsingPosition( position, m_pTimeline, m_dwGroupbits );
		CSelectedRegion* psr = GetAt(pos);
		if( (psr->m_mtcEnd == mtcPos) && (psr->m_mtcBeg == mtcPos) )
		{
			// Only this beat is in the selected regions, delete it
			RemoveAt(pos);
			delete psr;
		}
		else if( psr->m_mtcEnd == mtcPos )
		{
			// The region to toggle is at the end of psr - shorten psr
			psr->m_mtcEnd = psr->m_mtcEnd - 1;
			long lMeasure, lBeat;
			psr->m_mtcEnd.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			psr->m_mtcEnd.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else if( psr->m_mtcBeg == mtcPos )
		{
			// The region to toggle is at the start of psr - shorten psr
			long lMeasure, lBeat;
			psr->m_mtcBeg.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else
		{
			// Create a new CSelectedRegion for the first half
			CSelectedRegion *psrNew = new CSelectedRegion( psr->m_mtcBeg, mtcPos );
			InsertBefore( pos, psrNew );

			// Modify the existing CSelectedRegion to display the second half
			long lMeasure, lBeat;
			mtcPos.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
		}
	}
}


// toggle a region that contains the region formed by the given measure and beat
void CListSelectedRegion::ToggleRegion(long lMeasure, long lBeat)
{
	POSITION pos = FindContainingRegion(lMeasure, lBeat);
	if(pos == NULL)
	{
		CSelectedRegion *pSelectedRegion = new CSelectedRegion;
		if( pSelectedRegion )
		{
			pSelectedRegion->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			pSelectedRegion->m_mtcEnd.SetTime( lMeasure, lBeat + 1, m_pTimeline, m_dwGroupbits );
			AddRegion( *pSelectedRegion );
		}
	}
	else
	{
		CMusicTimeConverter mtcPos;
		mtcPos.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
		CSelectedRegion* psr = GetAt(pos);
		if( (psr->m_mtcEnd == mtcPos) && (psr->m_mtcBeg == mtcPos) )
		{
			// Only this beat is in the selected regions, delete it
			RemoveAt(pos);
			delete psr;
		}
		else if( psr->m_mtcEnd == mtcPos )
		{
			// The region to toggle is at the end of psr - shorten psr
			psr->m_mtcEnd = psr->m_mtcEnd - 1;
			long lMeasure, lBeat;
			psr->m_mtcEnd.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			psr->m_mtcEnd.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else if( psr->m_mtcBeg == mtcPos )
		{
			// The region to toggle is at the start of psr - shorten psr
			long lMeasure, lBeat;
			psr->m_mtcBeg.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else
		{
			// Create a new CSelectedRegion for the first half
			CSelectedRegion *psrNew = new CSelectedRegion( psr->m_mtcBeg, mtcPos );
			InsertBefore( pos, psrNew );

			// Modify the existing CSelectedRegion to display the second half
			long lMeasure, lBeat;
			mtcPos.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
		}
	}
}

// delay toggle: complete after drag by calling CompleteToggle
// behavior: (if not selected before and drag aborted, deselect)
void CListSelectedRegion::DelayToggle(long position, long measure, long beat)
{
	POSITION pos = FindContainingRegion(position);
	if(pos == NULL)
	{
		// unconditional add
		AddRegion(position, measure, beat);
	}
	else
	{
		CSelectedRegion* psr = GetAt(pos);
		psr->Flags() |= CSelectedRegion::WasToggleSelected;
	}
}
void CListSelectedRegion::CompleteToggle()
{
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		POSITION tmpPos = pos;
		CSelectedRegion* psr = GetNext(pos);
		if(psr->Flags() & CSelectedRegion::WasToggleSelected)
		{
			RemoveAt(tmpPos);
			delete psr;
		}
	}
}

// select, but delay deselecting so that multiple selected regions can be dragged.
// call CompleteDeselect after drop to complete
void CListSelectedRegion::AddAndDelayDeselect(long position, long measure, long beat)
{
	POSITION pos = FindContainingRegion(position);
	if(pos == NULL)
	{
		// mark other selected regions so they can be removed later if drop was aborted
		pos = GetHeadPosition();
		while(pos)
		{
			CSelectedRegion* psr = GetNext(pos);
			psr->Flags() |= CSelectedRegion::WasSelected;
		}
		// now add region
		AddRegion(position, measure, beat);
	}
	else
	{
		CSelectedRegion* pCur = GetNext(pos);
		// mark all regions except for this one
		pos = GetHeadPosition();
		while(pos)
		{
			CSelectedRegion* psr = GetNext(pos);
			if(psr != pCur)
			{
				psr->Flags() |= CSelectedRegion::WasSelected;
			}
		}
	}
}

void CListSelectedRegion::CompleteDeselect()
{
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		POSITION tmpPos = pos;
		CSelectedRegion* psr = GetNext(pos);
		if(psr->Flags() & CSelectedRegion::WasSelected)
		{
			RemoveAt(tmpPos);
			delete psr;
		}
	}
}

// select all between current position and anchor region (first region in list).  If list is empty
// then just do an add region from first measure first beat to current position
void CListSelectedRegion::ShiftAddRegion(long position, long measure, long beat)
{
	if(IsEmpty())
	{
		lShiftSelectAnchorPosition = 0;
	}

	CSelectedRegion* psrAnchor = NULL;

	// Get the shift-select anchor
	POSITION pos = FindContainingRegion(lShiftSelectAnchorPosition);
	if(pos)
	{
		psrAnchor = GetAt(pos);
		RemoveAt(pos);
	}
	else
	{
		psrAnchor = new CSelectedRegion(0, 0, 0, m_pTimeline, m_dwGroupbits);
	}

	// Delete all items in the list
	while(!IsEmpty())
	{
		CSelectedRegion* psr = RemoveHead();
		delete psr;
	}

	// Rebuild the selected region list
	CSelectedRegion* psrX = new CSelectedRegion(position, measure, beat, m_pTimeline, m_dwGroupbits);
	if(psrX->m_mtcBeg >= psrAnchor->m_mtcEnd)
	{
		psrX->m_mtcBeg = psrAnchor->m_mtcEnd;
	}
	if(psrX->m_mtcEnd <= psrAnchor->m_mtcBeg)
	{
		psrX->m_mtcEnd = psrAnchor->m_mtcBeg;
	}
	AddHead(psrAnchor);
	AddTail(psrX);
}

void CListSelectedRegion::SetShiftSelectAnchor(long position)
{
	// Set shift-select anchor
	lShiftSelectAnchorPosition = position;
}

long CListSelectedRegion::GetShiftSelectAnchor(void)
{
	// Get shift-select anchor
	return lShiftSelectAnchorPosition;
}

POSITION CListSelectedRegion::FindContainingRegion(long lPosition)
{
	CSelectedRegion srTarget(lPosition, 0, 1, m_pTimeline, m_dwGroupbits);

	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Save a pointer to this item
		POSITION posMatch = pos;

		// Get a pointer to the data in this item
		CSelectedRegion* psrTest = GetNext(pos);

		// Check if this selected range is the one we want
		if(psrTest->Contains(srTarget))
		{
			// Found it - return it.
			return posMatch;
		}
	}

	// Didn't find it - return NULL
	return NULL;
}

POSITION CListSelectedRegion::FindContainingRegion(long lMeasure, long lBeat)
{
	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Save a pointer to this item
		POSITION posMatch = pos;

		// Get a pointer to the data in this item
		CSelectedRegion* psrTest = GetNext(pos);

		// Check if this selected range is the one we want
		if(psrTest->Contains(lMeasure, lBeat, m_pTimeline, m_dwGroupbits))
		{
			// Found it - return it.
			return posMatch;
		}
	}

	return NULL;
}

bool CListSelectedRegion::Clear()
{
	// Check if there's anything to remove
	if( IsEmpty() )
	{
		// Nothing to remove - return false
		return false;
	}

	// Delete all items in the list
	while(!IsEmpty())
	{
		CSelectedRegion* psr = RemoveHead();
		delete psr;
	}

	// Found something to remove - return true
	return true;
}

HRESULT CListSelectedRegion::Load(IStream* pIStream)
{
	// Initialize shift-select anchor
	lShiftSelectAnchorPosition = 0;

	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	// check if anything to read
	DWORD nRegion, cb;
	hr = pIStream->Read(&nRegion, sizeof(DWORD), &cb);
	if(FAILED(hr))
	{
		return hr;
	}
	else if(cb == 0)
	{
		return S_FALSE;
	}
	else
	{
		Clear();
		for(unsigned int i = 0; i < nRegion && hr == S_OK; i++)
		{
			CSelectedRegion* psr = new CSelectedRegion;
			hr = psr->Load(pIStream);
		}
	}

	return hr;
}

HRESULT CListSelectedRegion::Save(IStream* pIStream)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	DWORD nRegion = static_cast<DWORD>(GetCount());
	DWORD cb;
	hr = pIStream->Write(&nRegion, sizeof(DWORD), &cb);

	hr = cb == sizeof(DWORD) && SUCCEEDED(hr) ? S_OK : E_FAIL;

	POSITION pos = GetHeadPosition();
	while(pos)
	{
		CSelectedRegion* psr = GetNext(pos);
		hr = psr->Save(pIStream);
	}
	return hr;
}

CListSelectedRegion& CListSelectedRegion::operator=(const CListSelectedRegion& list)
{
	if(&list != this)
	{
		Clear();
		POSITION pos = list.GetHeadPosition();
		while(pos)
		{
			CSelectedRegion* psr = list.GetNext(pos);
			AddTail(new CSelectedRegion(*psr));
		}
	}
	return *this;
}

void CListSelectedRegion::GetSpan(long& beg, long& end)
{
	beg = LONG_MAX;
	end = LONG_MIN;

	POSITION pos = GetHeadPosition();
	while(pos)
	{
		CSelectedRegion* psr = GetNext(pos);
		if(psr->m_mtcBeg.Time() < beg)
		{
			beg = psr->m_mtcBeg.Time();
		}
		if(psr->m_mtcEnd.Time() > end)
		{
			end = psr->m_mtcEnd.Time();
		}
	}
}

HRESULT CListSelectedRegion::SelectAll()
{
	VARIANT var;
	long ltime;
	HRESULT hr = m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	if(hr == S_OK)
	{
		ltime = V_I4(&var);
		CMusicTimeConverter cmtBeg(0);
		CMusicTimeConverter cmtEnd(ltime);
		CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
		Clear();
		AddHead(psr);
	}
	return hr;
}

bool CListSelectedRegion::Contains(long measure, long beat)
{
	return FindContainingRegion((short)measure, (BYTE)beat) != NULL;
}

bool CListSelectedRegion::Contains(long lTime)
{
	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Get a pointer to the data in this item
		CSelectedRegion* psrTest = GetNext(pos);

		if(lTime >= psrTest->m_mtcBeg.Time() && lTime < psrTest->m_mtcEnd.Time())
		{
			return true;
		}
	}

	return false;
}

void CListSelectedRegion::Sort(void)
{
	// Do a simple bubble sort on the list of selected regions
	// Order them by their start time

	// Initialize fChange to true so we go through the sort at least once
	bool fChange = true;

	// Continue while something changed the last time through
	while( fChange )
	{
		// Now initialize fChange to false, since nothing's changed
		fChange = false;

		// Get a pointer to the head of the list
		POSITION posRegion = GetHeadPosition();

		// Continue until there are no more items to look at
		while( posRegion )
		{
			// Save the current position
			POSITION posPrev = posRegion;

			// Get the next position
			GetNext( posRegion );

			// If there is a next position, and the current item should be
			// after the next item
			if( posRegion && (GetAt(posPrev)->Beg() > GetAt(posRegion)->Beg()) )
			{
				// Get a pointer to the current item
				CSelectedRegion* psr = GetAt(posPrev);

				// Remove it from the list
				RemoveAt( posPrev );

				// Insert it after the next item, and update our list pointer to point at it
				posRegion = InsertAfter( posRegion, psr );

				// Note that we changed so we go through the list again
				fChange = true;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\MusicTimeConverter.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef MusicTimeConverter_H
#define MusicTimeConverter_H

#include "timeline.h"
#include "dmusici.h"

#define PPQ DMUS_PPQ

#define NOTE_CLOCKS(note, ppq) ( (ppq)*4 /(note) )



// draw helper function
inline long LeftMargin(IDMUSProdTimeline* pTimeline)
{
	long lClocks, lPosition;
	pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
	pTimeline->ClocksToPosition(lClocks, &lPosition);
	return --lPosition;
}



class CMusicTimeConverter
// conversions as functions of timesig, measure, beat, 
{
	long	m_lTime;
public:
	CMusicTimeConverter()
	{
		m_lTime = 0;
	}
	CMusicTimeConverter(long time) : m_lTime(time)
	{
	}
	CMusicTimeConverter(long lMeasure, long lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		SetTime( lMeasure, lBeat, pTimeline, dwGroupBits, dwIndex );
	}
	CMusicTimeConverter(long lPosition,IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		SetTimeUsingPosition( lPosition, pTimeline, dwGroupBits, dwIndex );
	}
	CMusicTimeConverter(const CMusicTimeConverter& cmt)
	{
		m_lTime = cmt.m_lTime;
	}
	CMusicTimeConverter& operator=(const CMusicTimeConverter& cmt)
	{
		m_lTime = cmt.m_lTime;
		return *this;
	}
	HRESULT GetMeasure(long& lMeasure, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, &lMeasure, NULL);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT GetBeat(long& lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, NULL, &lBeat);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT GetMeasureBeat(long& lMeasure, long& lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, &lMeasure, &lBeat);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT GetMeasureBeat(long& lMeasureReturn, long& lBeatReturn, long lBeatsPerMeasure, long lBeat)
	{
		lBeatReturn = (m_lTime * lBeat) / (4 * PPQ);
		lMeasureReturn = lBeatReturn / lBeatsPerMeasure;
		lBeatReturn = lBeatReturn % lBeatsPerMeasure;
		return S_OK;
	}
	HRESULT GetTimeSig(DMUS_TIMESIGNATURE& dmTimeSig, IDMUSProdTimeline* pTimeline, 
						DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		return pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, m_lTime, NULL, &dmTimeSig);
	}
	HRESULT SetTime(long lMeasure, long lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->MeasureBeatToClocks(dwGroupBits, dwIndex, lMeasure, lBeat, &m_lTime);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT SetTimeUsingPosition(long lPosition, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT (pTimeline);
		long lMeasure, lBeat;
		HRESULT hr = pTimeline->PositionToMeasureBeat(dwGroupBits, dwIndex, lPosition, &lMeasure, &lBeat);
		ASSERT(hr == S_OK);
		hr = pTimeline->MeasureBeatToClocks(dwGroupBits, dwIndex, lMeasure, lBeat, &m_lTime);
		ASSERT(hr == S_OK);
		return hr;
	}
	// dangerous because allows adding cmusictimeconverters by adding times which could be wrong in multimeters
	// useful for relational ops
	operator long()
	{
		return m_lTime;
	}
	/*
	bool operator < (const CMusicTimeConverter& cmt)
	{
		return m_lTime < cmt.m_lTime;
	}
	bool operator > (const CMusicTimeConverter& cmt)
	{
		return m_lTime > cmt.m_lTime;
	}
	*/
	long& Time()
	{
		return m_lTime;
	}
	CMusicTimeConverter& operator=(long lTime)
	{
		m_lTime = lTime;
		return *this;
	}
	HRESULT AddOffset(long lMeasure, long lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		// find time sig at m_lTime
		DMUS_TIMESIGNATURE dmTimeSig;
		HRESULT hr;
		hr = GetTimeSig(dmTimeSig, pTimeline, dwGroupBits, dwIndex);
		if(SUCCEEDED(hr))
		{
			// find our measure and beat
			long lTmpMeasure, lTmpBeat;
			hr = GetMeasureBeat(lTmpMeasure,lTmpBeat, pTimeline, dwGroupBits, dwIndex);
			if(SUCCEEDED(hr))
			{
				long lTmpBeat2 = (lTmpBeat + lBeat) % dmTimeSig.bBeatsPerMeasure;
				lTmpMeasure = lTmpMeasure + lMeasure + (lTmpBeat + lBeat) / dmTimeSig.bBeatsPerMeasure;
				hr = SetTime(lTmpMeasure, lTmpBeat2, pTimeline, dwGroupBits, dwIndex);
			}
		}
		return hr;
	}
};



inline CMusicTimeConverter operator+(CMusicTimeConverter& a, CMusicTimeConverter& b)
{
	CMusicTimeConverter t(a);
	t.Time() += b.Time();
	return t;
}

inline CMusicTimeConverter operator-(CMusicTimeConverter& a, CMusicTimeConverter& b)
{
	CMusicTimeConverter t(a);
	t.Time() -= b.Time();
	return t;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\RiffStrm.h ===
/************************************************************************
*                                                                       *
*   Contains the definition of CRIFFStream                              *
*                                                                       *
*   Copyright (c) 1995-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef _CRIFFStream_
#define _CRIFFStream_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )
#include <ole2.h>

// {F809DCE1-859D-11d0-89AC-00A0C9054129}
DEFINE_GUID( IID_IDMUSProdRIFFStream, 0xf809dce1, 0x859d, 0x11d0, 0x89, 0xac, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 );

#undef INTERFACE
#define INTERFACE IDMUSProdRIFFStream
DECLARE_INTERFACE_(IDMUSProdRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IDMUSProdRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)() PURE;
};


// **************************************
//
// Platform Independent RIFF Tags
//
// **************************************

// **************************************
//
// CRIFFStream
//
// Implementation of IDMUSProdRIFFStream interface, and IUnknown
//
// **************************************


STDAPI AllocRIFFStream( IStream* pIStream, IDMUSProdRIFFStream** ppIRiffStream );
HRESULT SaveMBStoWCS( IStream* pIStream, const CString* pstrText );
void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, CString* pstrText );



struct CRIFFStream : IDMUSProdRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		m_pStream = NULL;

        SetStream( pStream );
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IDMUSProdRIFFStream ) )
        {
            *ppvObj = (IDMUSProdRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IDMUSProdRIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};


// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}


// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef _DEBUG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef _DEBUG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

#ifndef _GetMLong_Defined_
#define _GetMLong_Defined_


// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
	union uLong
	{
		unsigned char buf[4];
	DWORD dw;
	} u;

	if( S_OK != pStream->Read( u.buf, 4, NULL ) )
	{
	return FALSE;
	}


#ifndef _MAC
	// swap bytes
	unsigned char ch;
	ch = u.buf[0];
	u.buf[0] = u.buf[3];
	u.buf[3] = ch;

	ch = u.buf[1];
	u.buf[1] = u.buf[2];
	u.buf[2] = ch;
#endif

	dw = u.dw;
	return TRUE;
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\SelectedRegion.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef SELECTED_REGION_H
#define SELECTED_REGION_H

#include "stdafx.h"
#include <afxtempl.h>
#include "..\shared\musictimeconverter.h"

class CListSelectedRegion;

class CSelectedRegion
{
	friend class CListSelectedRegion;
	CMusicTimeConverter m_mtcBeg;
	CMusicTimeConverter m_mtcEnd;
	DWORD	m_dwFlags;
public:
	// if m_dwFlags == WasSelected, then region was selected before click select.  If successful drag drop
	// then remains selected, otherwise its deselected.  
	// Used by the pair CSelectedRegionList::DelayToggle/CompleteToggle
	enum { WasToggleSelected=1, WasSelected=2 };
	CSelectedRegion()
	{
		m_dwFlags = 0;
	}
	~CSelectedRegion()
	{
	}
	CSelectedRegion(CMusicTimeConverter beg, CMusicTimeConverter end)
		: m_mtcBeg(beg), m_mtcEnd(end)
	{
		m_dwFlags = 0;
	}
	CSelectedRegion(const CSelectedRegion& sel)
	{
		m_mtcBeg = sel.m_mtcBeg;
		m_mtcEnd = sel.m_mtcEnd;
		m_dwFlags = sel.m_dwFlags;
	}
	CSelectedRegion& operator=(const CSelectedRegion& sel)
	{
		m_mtcBeg = sel.m_mtcBeg;
		m_mtcEnd = sel.m_mtcEnd;
		m_dwFlags = sel.m_dwFlags;
		return *this;
	}
	CMusicTimeConverter& Beg()
	{
		return m_mtcBeg;
	}
	CMusicTimeConverter& End()
	{
		return m_mtcEnd;
	}
	DWORD& Flags()
	{
		return m_dwFlags;
	}
	// create
	CSelectedRegion(long position, long measure, long beat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits)
	{
		m_mtcBeg.SetTimeUsingPosition(position, pTimeline, dwGroupBits);
		DMUS_TIMESIGNATURE dmTimeSig;
		m_mtcBeg.GetTimeSig(dmTimeSig, pTimeline, dwGroupBits);
		long m,b;
		m_mtcBeg.GetMeasureBeat(m, b, pTimeline, dwGroupBits);
		long beats = beat + b;
		beat = beats % dmTimeSig.bBeatsPerMeasure;
		measure += m + beats/dmTimeSig.bBeatsPerMeasure;
		m_mtcEnd.SetTime(measure, beat, pTimeline, dwGroupBits);
		m_dwFlags = 0;
	}
	bool Contains(CSelectedRegion& sel)
	{
		if(m_mtcBeg <= sel.m_mtcBeg && m_mtcEnd >= sel.m_mtcEnd)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool Contains(long measure, long beat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits)
	{
		long ltime;
		HRESULT hr = pTimeline->MeasureBeatToClocks(dwGroupBits, 0, measure, beat, &ltime);
		if(hr == S_OK)
		{
			if(ltime >= m_mtcBeg.Time() && ltime < m_mtcEnd.Time())
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	bool Intersects(CSelectedRegion& sel)
	{
		long b = sel.m_mtcBeg > m_mtcBeg ? sel.m_mtcBeg : m_mtcBeg; // b = max(beginning times)
		long e = sel.m_mtcEnd < m_mtcEnd ? sel.m_mtcEnd : m_mtcEnd; // e = min(ending times)
		// intersection is empty if min(ending times) <= max(beginning times)
		return e <= b ? false : true;
	}
	bool IsNull()
	{
		return m_mtcEnd < m_mtcBeg;
	}

	long BeginPos(IDMUSProdTimeline* pTimeline)
	{
		long pos;
		pTimeline->ClocksToPosition( m_mtcBeg.Time(), &pos);
		return pos;
	}
	long EndPos(IDMUSProdTimeline* pTimeline)
	{
		long pos;
		pTimeline->ClocksToPosition( m_mtcEnd.Time(), &pos);
		return pos;
	}
	HRESULT Load(IStream* pIStream)
	{
		HRESULT hr, hrBeg, hrEnd, hrFlags;
		DWORD cbBeg, cbEnd, cbFlags;
		hrBeg = pIStream->Read(&m_mtcBeg, sizeof(CMusicTimeConverter), &cbBeg);
		hrEnd = pIStream->Read(&m_mtcEnd, sizeof(CMusicTimeConverter), &cbEnd);
		hrFlags = pIStream->Read(&m_dwFlags, sizeof(DWORD), &cbFlags);
		hr = (cbBeg == sizeof(CMusicTimeConverter)) && (cbEnd == sizeof(CMusicTimeConverter)
				&& (cbFlags == sizeof(DWORD))
				&& SUCCEEDED(hrBeg) && SUCCEEDED(hrEnd) && SUCCEEDED(hrFlags))
			? S_OK : E_FAIL;
		return hr;
	}
	HRESULT Save(IStream* pIStream)
	{
		HRESULT hr, hrBeg, hrEnd, hrFlags;
		DWORD cbBeg, cbEnd, cbFlags;
		hrBeg = pIStream->Write(&m_mtcBeg, sizeof(CMusicTimeConverter), &cbBeg);
		hrEnd = pIStream->Write(&m_mtcEnd, sizeof(CMusicTimeConverter), &cbEnd);
		hrFlags = pIStream->Write(&m_dwFlags, sizeof(DWORD), &cbFlags);
		hr = (cbBeg == sizeof(CMusicTimeConverter)) && (cbEnd == sizeof(CMusicTimeConverter))
				&& (cbFlags == sizeof(DWORD))
				&& SUCCEEDED(hrBeg) && SUCCEEDED(hrEnd) && SUCCEEDED(hrFlags)
			? S_OK : E_FAIL;
		return hr;
	}

};

// list handles memory for regions
class CListSelectedRegion : public CTypedPtrList<CPtrList, CSelectedRegion *>
{
	friend class CChordStrip;
	DWORD m_dwGroupbits;
	IDMUSProdTimeline*	m_pTimeline;
	long lShiftSelectAnchorPosition;
public:
	HRESULT SelectAll();
	CListSelectedRegion(IDMUSProdTimeline* pTimeline, DWORD dwGroupbits);
	~CListSelectedRegion();

	IDMUSProdTimeline*& Timeline()
	{
		return m_pTimeline;
	}

	DWORD& GroupBits()
	{
		return m_dwGroupbits;
	}

	CListSelectedRegion& operator=(const CListSelectedRegion& list);
	// methods to add and modify region list
	// add a region at position(converted to a time) whose duration = measure:beat
	void AddRegion(long position, long measure=0, long beat=1);
	void AddRegion(const CSelectedRegion& csr);
	// select, but delay deselecting so that multiple selected regions can be dragged.
	void AddAndDelayDeselect(long position, long measure=0, long beat=1);
	// completes above by deselecting and removing
	void CompleteDeselect();
	// toggle the beat that contains the specified position
	void ToggleRegion(long position);
	// toggle the specified measure and beat
	void ToggleRegion(long measure, long beat);
	// delay toggle: complete after drag by calling CompleteToggle
	// behavior: (if not selected before and drag aborted, deselect)
	void DelayToggle(long position, long measure=0, long beat=1);
	void CompleteToggle();
	// delay select
	// select all between current position and anchor region (first region in list).  If list is empty
	// then just do an add region
	void ShiftAddRegion(long position, long measure=0, long beat=1);
	void SetShiftSelectAnchor(long position);
	long GetShiftSelectAnchor();
	bool Clear();
	void Sort(void);

	// methods to access list (by draw and cut, copy, paste, etc)
	// can also use CList methods
	POSITION FindContainingRegion(long lPosition);
	POSITION FindContainingRegion(long lMeasure, long lBeat);
	bool Contains(long measure, long beat);
	bool Contains(long lTime);
	HRESULT Load(IStream* pIStream);
	HRESULT Save(IStream* pIStream);
	void Copy(CListSelectedRegion& list)
	{
		*this = list;
	}
	void GetSpan(long& beg, long& end);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\ADSREnvelope.cpp ===
// ADSREnvelope.cpp : Implementation of CADSREnvelopeApp and DLL registration.

#include "stdafx.h"
#include "ADSREnvelope.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CADSREnvelopeApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x71ae3623, 0xa9bd, 0x11d0, { 0xbc, 0xba, 0, 0xaa, 0, 0xc0, 0x81, 0x46 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeApp::InitInstance - DLL initialization

BOOL CADSREnvelopeApp::InitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeApp::ExitInstance - DLL termination

int CADSREnvelopeApp::ExitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\StaticPropPageManager.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1997-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// StaticPropPageManager.cpp: implementation of CStaticPropPageManager
//
// Identical to AppBasePropPageManager except that this calls
// AfxGetStaticModuleState instead of AfxGetAppModuleState.
// This is used by objects such as the Timeline Control, which is
// an independant ATL object embedded in a Jazz Component.
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <afxole.h>         // MFC OLE classes

#include "StaticPropPageManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CStaticPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CStaticPropPageManager::CStaticPropPageManager() : CBasePropPageManager()
{
}

CStaticPropPageManager::~CStaticPropPageManager()
{
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IUnknown implementation

HRESULT CStaticPropPageManager::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::QueryInterface(riid, ppvObj);
}

ULONG CStaticPropPageManager::AddRef()
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    return CBasePropPageManager::AddRef();
}

ULONG CStaticPropPageManager::Release()
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::Release();
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CStaticPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::OnRemoveFromPropertySheet();
}


/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CStaticPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::SetObject( pINewPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CStaticPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::RemoveObject( pIPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CStaticPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::IsEqualObject( pIPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT FAR EXPORT CStaticPropPageManager::IsEqualPageManagerGUID(REFGUID rguidPageManager)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::IsEqualPageManagerGUID( rguidPageManager );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\3rdParty\samples\Shared\RiffStrm.cpp ===
/************************************************************************
*                                                                       *
*   Contains the implementation of CRIFFStream                          *
*                                                                       *
*   Copyright (c) 1995-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#include "stdafx.h"
#include <ole2.h>
#include <initguid.h>
#include "RiffStrm.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// this takes care of a ton of compiler complaints
#ifndef WIN32
#define E_FAIL	(void __far *)MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
#endif


/////////////////////////////////////////////////////////////////////////////
// AllocRIFFStream

// Allocate an IDMUSProdRIFFStream from an IStream
STDAPI AllocRIFFStream( IStream* pIStream, IDMUSProdRIFFStream** ppIRiffStream )
{
	// Validate arguments
	if( (pIStream == NULL) || (ppIRiffStream == NULL) )
	{
		return E_POINTER;
	}

	// Create a new CRIFFStream that wraps the IStream
    if( ( *ppIRiffStream = (IDMUSProdRIFFStream*) new CRIFFStream( pIStream ) ) == NULL )
    {
		// Couldn't create the CRIFFStream object, probably out of memory
        return E_OUTOFMEMORY;
    }

	// Succeeded
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// MyRead, MyWrite, MySeek
//
// These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
// except for the absence of the HMMIO parameter.

/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MyRead

// Read a chunk of data from m_pStream.
long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MyWrite

// Write a chunk of data to m_pStream.
long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MySeek

// Seek to a different position in m_pStream
long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::Descend

// Descend into a RIFF chunk and return information about the chunk in the lpck parameter.
UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    // figure out what chunk id and form/list type to search for
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        // read the chunk header
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;

        // store the offset of the data part of the chunk
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        // see if the chunk is within the parent chunk (if given)
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        // if the chunk if a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        // if this is the chunk we're looking for, stop looking
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        // ascend out of the chunk and try again
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::Ascend

// Ascend out of a RIFF chunk and update its size from the size in the lpck parameter.
UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            // chunk size is odd -- write a null pad byte
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        // fix the chunk header
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))
            return MMIOERR_CANNOTWRITE;
    }

    // seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::CreateChunk

// Create a RIFF chunk, passed in as lpck.
UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    // store the offset of the data part of the chunk
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    // write the chunk header
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)
        return MMIOERR_CANNOTWRITE;

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}


//////////////////////////////////
// Save routines
//////////////////////////////////
HRESULT SaveMBStoWCS( IStream* pIStream, const CString* pstrText )
{
	HRESULT		hr = S_OK;
	wchar_t*	wstrText = NULL;
	DWORD		dwLength;
	DWORD		dwBytesWritten;
		
	if( pstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	dwLength = pstrText->GetLength() + 1;
	wstrText = new wchar_t[dwLength];
	if( wstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

    MultiByteToWideChar( CP_ACP, 0, *pstrText, -1, wstrText, (size_t)dwLength );
	dwLength *= sizeof(wchar_t);

	hr = pIStream->Write( wstrText, dwLength, &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != dwLength )
	{
		goto ON_ERR;
	}

ON_ERR:
	if( wstrText )
		delete wstrText;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, CString* pstrText )
{
	HRESULT		hr = S_OK;
	wchar_t*	wstrText = NULL;
	DWORD		dwBytesRead;
	
	pstrText->Empty();
	
	wstrText = new wchar_t[dwSize];
	if( wstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
	if( FAILED( hr )
	||  dwBytesRead != dwSize )
	{
		goto ON_ERR;
	}

	*pstrText = wstrText;
	
ON_ERR:
	if( wstrText )
		delete wstrText;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ADSREnvelope.rc
//

#define IDS_ADSRENVELOPE               1
#define IDS_ADSRENVELOPE_PPG           2

#define IDS_ADSRENVELOPE_PPG_CAPTION   200

#define IDD_PROPPAGE_ADSRENVELOPE      200

#define IDD_ABOUTBOX_ADSRENVELOPE      1

#define IDB_ADSRENVELOPE               1

#define IDI_ABOUTDLL				1

#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#define _APS_NEXT_COMMAND_VALUE         32768
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\StdAfx.h ===
#if !defined(AFX_STDAFX_H__71AE362A_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_)
#define AFX_STDAFX_H__71AE362A_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__71AE362A_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\ADSREnvelope.h ===
#if !defined(AFX_ADSRENVELOPE_H__71AE362C_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_)
#define AFX_ADSRENVELOPE_H__71AE362C_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// ADSREnvelope.h : main header file for ADSRENVELOPE.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeApp : See ADSREnvelope.cpp for implementation.

class CADSREnvelopeApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADSRENVELOPE_H__71AE362C_A9BD_11D0_BCBA_00AA00C08146__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\ADSREnvelopePpg.h ===
#if !defined(AFX_ADSRENVELOPEPPG_H__71AE3636_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_)
#define AFX_ADSRENVELOPEPPG_H__71AE3636_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// ADSREnvelopePpg.h : Declaration of the CADSREnvelopePropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CADSREnvelopePropPage : See ADSREnvelopePpg.cpp.cpp for implementation.

class CADSREnvelopePropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CADSREnvelopePropPage)
	DECLARE_OLECREATE_EX(CADSREnvelopePropPage)

// Constructor
public:
	CADSREnvelopePropPage();

// Dialog Data
	//{{AFX_DATA(CADSREnvelopePropPage)
	enum { IDD = IDD_PROPPAGE_ADSRENVELOPE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CADSREnvelopePropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADSRENVELOPEPPG_H__71AE3636_A9BD_11D0_BCBA_00AA00C08146__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\Utilities.cpp ===
// Utilities.cpp
//

#include "stdafx.h"
#include "Utilities.h"

TCENT Mils2TimeCents(DWORD dwMils)
{
	TCENT	tcTimeCent;
	double		dTime;

	if (dwMils < 1) dwMils = 1;
	dTime = dwMils;
	dTime /= 1000.0;
	dTime = log10(dTime) / 0.301;
	dTime *= 1200;
	tcTimeCent = (TCENT) (dTime + 0.5);
	return tcTimeCent;
}

DWORD TimeCents2Mils(TCENT tcTime)
{
    DWORD dwMils;
    double dTime = tcTime;
    dTime /= 1200;
    dTime = pow(2.0,dTime);
    dTime *= 1000;
    dwMils = (DWORD) (dTime + 0.5);
	if (dwMils > 40000) dwMils = 40000;
    return(dwMils);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\ADSREnvelopeCtl.h ===
#if !defined(AFX_ADSRENVELOPECTL_H__71AE3634_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_)
#define AFX_ADSRENVELOPECTL_H__71AE3634_A9BD_11D0_BCBA_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "Utilities.h"

#define SEGMENTS		6				// Delay, Attack, Hold, Decay, Sustain and Release
#define SEGMENT_THUMBS	SEGMENTS - 1	// Boxes to drag the segments

#define DELAY_COLOR		RGB(0, 0, 0)		// Delay segment color
#define ATTACK_COLOR	RGB(255, 0, 0)		// Attack segment color
#define HOLD_COLOR		RGB(255, 0, 255)	// Hold segment color
#define DECAY_COLOR		RGB(0, 128, 64)		// Decay segment color
#define	SUSTAIN_COLOR	RGB(0, 0, 0)		// Sustain segment color same as the delay color
#define RELEASE_COLOR	RGB(0, 0, 255)		// Release segment color

// ADSREnvelopeCtl.h : Declaration of the CADSREnvelopeCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl : See ADSREnvelopeCtl.cpp for implementation.

class CADSREnvelopeCtrl : public COleControl
{
	DECLARE_DYNCREATE(CADSREnvelopeCtrl)

// Constructor
public:
	CADSREnvelopeCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CADSREnvelopeCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CADSREnvelopeCtrl();

	void UpdateADSREnvelope(CDC *pDC, const CRect* rcBounds = NULL);	
	
	DECLARE_OLECREATE_EX(CADSREnvelopeCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CADSREnvelopeCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CADSREnvelopeCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CADSREnvelopeCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CADSREnvelopeCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CADSREnvelopeCtrl)`
	afx_msg long GetReleaseTime();
	afx_msg void SetReleaseTime(long nNewValue);
	afx_msg long GetAttackTime();
	afx_msg void SetAttackTime(long nNewValue);
	afx_msg long GetDecayTime();
	afx_msg void SetDecayTime(long nNewValue);
	afx_msg long GetSustainLevel();
	afx_msg void SetSustainLevel(long nNewValue);
	afx_msg long GetDelayTime();
	afx_msg void SetDelayTime(long nNewValue);
	afx_msg long GetHoldTime();
	afx_msg void SetHoldTime(long nNewValue);
	afx_msg void SetDLS1(BOOL bDLS1);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CADSREnvelopeCtrl)
	void FireADSREDecayTimeChanged(long NewDecayTime)
		{FireEvent(eventidADSREDecayTimeChanged,EVENT_PARAM(VTS_I4), NewDecayTime);}
	void FireADSREAttackTimeChanged(long NewAttackTime)
		{FireEvent(eventidADSREAttackTimeChanged,EVENT_PARAM(VTS_I4), NewAttackTime);}
	void FireADSREReleaseTimeChanged(long NewReleaseTime)
		{FireEvent(eventidADSREReleaseTimeChanged,EVENT_PARAM(VTS_I4), NewReleaseTime);}
	void FireADSRESustainLevelChanged(long NewSustainLevel)
		{FireEvent(eventidADSRESustainLevelChanged,EVENT_PARAM(VTS_I4), NewSustainLevel);}
	void FireRealDecayChanged(long lNewRealDecay)
		{FireEvent(eventidRealDecayChanged,EVENT_PARAM(VTS_I4), lNewRealDecay);}
	void FireRealReleaseChanged(long lNewRealRelease)
		{FireEvent(eventidRealReleaseChanged,EVENT_PARAM(VTS_I4), lNewRealRelease);}
	void FireADSRMouseMoveStart()
		{FireEvent(eventidADSRMouseMoveStart,EVENT_PARAM(VTS_NONE));}
	void FireADSRHoldTimeChanged(long lNewHoldTime)
		{FireEvent(eventidADSRHoldTimeChanged,EVENT_PARAM(VTS_I4), lNewHoldTime);}
	void FireADSREDelayTimeChanged(long lNewDelayTime)
		{FireEvent(eventidADSREDelayTimeChanged,EVENT_PARAM(VTS_I4), lNewDelayTime);}
	void FireADSREHoldTimeChanged(long lNewHoldTime)
		{FireEvent(eventidADSREHoldTimeChanged,EVENT_PARAM(VTS_I4), lNewHoldTime);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CADSREnvelopeCtrl)
	dispidReleaseTime = 1L,
	dispidAttackTime = 2L,
	dispidDecayTime = 3L,
	dispidSustainLevel = 4L,
	dispidDelayTime = 5L,
	dispidHoldTime = 6L,
	dispidSetDLS1 = 7L,
	eventidADSREDecayTimeChanged = 1L,
	eventidADSREAttackTimeChanged = 2L,
	eventidADSREReleaseTimeChanged = 3L,
	eventidADSRESustainLevelChanged = 4L,
	eventidRealDecayChanged = 5L,
	eventidRealReleaseChanged = 6L,
	eventidADSRMouseMoveStart = 7L,
	eventidADSRHoldTimeChanged = 8L,
	eventidADSREDelayTimeChanged = 9L,
	eventidADSREHoldTimeChanged = 10L,
	//}}AFX_DISP_ID
	};

private:
	void UpdateRealReleaseTime() { FireRealReleaseChanged(TimeCents2Mils(m_lRTime) * m_lSLevel / 1000); }
	void UpdateRealDecayTime() { FireRealDecayChanged(TimeCents2Mils(m_lDTime) * (1000 - m_lSLevel) / 1000); }
	enum { START, DELAY, ATTACK, HOLD, DECAY, RELEASE, END, TIMECENTS_MIN = -11960, TIMECENTS_RANGE =  18347};

	/* returns whether the given handle (DELAY, ATTACK, etc) is visible given the DLS1 setting. */
	bool ADRVisible(BYTE btLevel);
	
	bool	m_bHasCapture;
	POINT	m_ptADRPts[SEGMENTS + 1];		
	CRect	m_rcADRPosBox[SEGMENT_THUMBS];
	int		m_nSelPB;			// Currently selected PosBox
	int		m_nOnTop;
	CPoint	m_ptPrevMousePos;
	bool	m_bFireUndoNotify;


	long m_lDelayTime;		// Delay Time in TIMECENTS
	long m_lATime;			// Attack Time in TIMECENTS
	long m_lHTime;			// Hold Time in TIMECENTS
	long m_lDTime;			// Decay Time in TIMECENTS
	long m_lRTime;			// Release Time in TIMECENTS
	long m_lSLevel;			// Sustain Level in tenths of a percent

	int m_nDelayPixels;		// Delay Position calculated from Delay Time
	int	m_nAPixels;			// Attack Position calculated from Attack Time
	int m_nHPixels;			// Hole Position calculated from Hold Time
	int m_nDPixels;			// Decay Position calculated from Decay Time
	int m_nRPixels;			// Release Position calculated from Release Time

	int	m_nWidth;
	int m_nHeight;
	int	m_nMaxPixels;		
	int m_nSegmentLength;	// Each segment can have this max length

	BOOL m_bDLS1;			// DLS1 envelope

	double m_TimeCentsPerPixel;
	double m_PixelsPerTenthPercent;

};	

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADSRENVELOPECTL_H__71AE3634_A9BD_11D0_BCBA_00AA00C08146__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\ADSREnvelopePpg.cpp ===
// ADSREnvelopePpg.cpp : Implementation of the CADSREnvelopePropPage property page class.

#include "stdafx.h"
#include "ADSREnvelope.h"
#include "ADSREnvelopePpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CADSREnvelopePropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CADSREnvelopePropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CADSREnvelopePropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CADSREnvelopePropPage, "ADSRENVELOPE.ADSREnvelopePropPage.1",
	0x71ae3627, 0xa9bd, 0x11d0, 0xbc, 0xba, 0, 0xaa, 0, 0xc0, 0x81, 0x46)


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopePropPage::CADSREnvelopePropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CADSREnvelopePropPage

BOOL CADSREnvelopePropPage::CADSREnvelopePropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_ADSRENVELOPE_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopePropPage::CADSREnvelopePropPage - Constructor

CADSREnvelopePropPage::CADSREnvelopePropPage() :
	COlePropertyPage(IDD, IDS_ADSRENVELOPE_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CADSREnvelopePropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopePropPage::DoDataExchange - Moves data between page and properties

void CADSREnvelopePropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	//{{AFX_DATA_MAP(CADSREnvelopePropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopePropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\ADSREnvelopeCtl.cpp ===
// ADSREnvelopeCtl.cpp : Implementation of the CADSREnvelopeCtrl ActiveX Control class.

#include "stdafx.h"
#include "ADSREnvelope.h"
#include "ADSREnvelopeCtl.h"
#include "ADSREnvelopePpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CADSREnvelopeCtrl, COleControl)
const int HALF_POS_BOX_HW = 4;
const int UI_MARGIN = HALF_POS_BOX_HW;
static const COLORREF arrPositionBoxColors[SEGMENT_THUMBS] = {DELAY_COLOR, ATTACK_COLOR, HOLD_COLOR, DECAY_COLOR, RELEASE_COLOR};

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CADSREnvelopeCtrl, COleControl)
	//{{AFX_MSG_MAP(CADSREnvelopeCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_RBUTTONDOWN()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CADSREnvelopeCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CADSREnvelopeCtrl)
	DISP_PROPERTY_EX(CADSREnvelopeCtrl, "ReleaseTime", GetReleaseTime, SetReleaseTime, VT_I4)
	DISP_PROPERTY_EX(CADSREnvelopeCtrl, "AttackTime", GetAttackTime, SetAttackTime, VT_I4)
	DISP_PROPERTY_EX(CADSREnvelopeCtrl, "DecayTime", GetDecayTime, SetDecayTime, VT_I4)
	DISP_PROPERTY_EX(CADSREnvelopeCtrl, "SustainLevel", GetSustainLevel, SetSustainLevel, VT_I4)
	DISP_PROPERTY_EX(CADSREnvelopeCtrl, "DelayTime", GetDelayTime, SetDelayTime, VT_I4)
	DISP_PROPERTY_EX(CADSREnvelopeCtrl, "HoldTime", GetHoldTime, SetHoldTime, VT_I4)
	DISP_FUNCTION(CADSREnvelopeCtrl, "SetDLS1", SetDLS1, VT_EMPTY, VTS_BOOL)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CADSREnvelopeCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CADSREnvelopeCtrl, COleControl)
	//{{AFX_EVENT_MAP(CADSREnvelopeCtrl)
	EVENT_CUSTOM("ADSREDecayTimeChanged", FireADSREDecayTimeChanged, VTS_I4)
	EVENT_CUSTOM("ADSREAttackTimeChanged", FireADSREAttackTimeChanged, VTS_I4)
	EVENT_CUSTOM("ADSREReleaseTimeChanged", FireADSREReleaseTimeChanged, VTS_I4)
	EVENT_CUSTOM("ADSRESustainLevelChanged", FireADSRESustainLevelChanged, VTS_I4)
	EVENT_CUSTOM("RealDecayChanged", FireRealDecayChanged, VTS_I4)
	EVENT_CUSTOM("RealReleaseChanged", FireRealReleaseChanged, VTS_I4)
	EVENT_CUSTOM("ADSRMouseMoveStart", FireADSRMouseMoveStart, VTS_NONE)
	EVENT_CUSTOM("ADSRHoldTimeChanged", FireADSRHoldTimeChanged, VTS_I4)
	EVENT_CUSTOM("ADSREDelayTimeChanged", FireADSREDelayTimeChanged, VTS_I4)
	EVENT_CUSTOM("ADSREHoldTimeChanged", FireADSREHoldTimeChanged, VTS_I4)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CADSREnvelopeCtrl, 1)
	PROPPAGEID(CADSREnvelopePropPage::guid)
END_PROPPAGEIDS(CADSREnvelopeCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CADSREnvelopeCtrl, "ADSRENVELOPE.ADSREnvelopeCtrl.1",
	0x71ae3626, 0xa9bd, 0x11d0, 0xbc, 0xba, 0, 0xaa, 0, 0xc0, 0x81, 0x46)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CADSREnvelopeCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DADSREnvelope =
		{ 0x71ae3624, 0xa9bd, 0x11d0, { 0xbc, 0xba, 0, 0xaa, 0, 0xc0, 0x81, 0x46 } };
const IID BASED_CODE IID_DADSREnvelopeEvents =
		{ 0x71ae3625, 0xa9bd, 0x11d0, { 0xbc, 0xba, 0, 0xaa, 0, 0xc0, 0x81, 0x46 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwADSREnvelopeOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CADSREnvelopeCtrl, IDS_ADSRENVELOPE, _dwADSREnvelopeOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl::CADSREnvelopeCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CADSREnvelopeCtrl

BOOL CADSREnvelopeCtrl::CADSREnvelopeCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_ADSRENVELOPE,
			IDB_ADSRENVELOPE,
			afxRegApartmentThreading,
			_dwADSREnvelopeOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl::CADSREnvelopeCtrl - Constructor

CADSREnvelopeCtrl::CADSREnvelopeCtrl() : 
				   m_bHasCapture(false), 
				   m_nSelPB(0), 
				   m_nOnTop(ATTACK),
				   m_bFireUndoNotify(false),
				   m_lDelayTime(0),
				   m_lATime(0), 
				   m_lHTime(0),
				   m_lDTime(0),
				   m_lSLevel(0),
				   m_lRTime(0), 
				   m_nDelayPixels(0),
				   m_nAPixels(0),
				   m_nHPixels(0),
				   m_nDPixels(0), 
				   m_nRPixels(0), 
				   m_nMaxPixels(0),
				   m_nSegmentLength(0),
				   m_TimeCentsPerPixel(0),
				   m_PixelsPerTenthPercent(0),
				   m_bDLS1(FALSE)
{
	InitializeIIDs(&IID_DADSREnvelope, &IID_DADSREnvelopeEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl::~CADSREnvelopeCtrl - Destructor

CADSREnvelopeCtrl::~CADSREnvelopeCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl::OnDraw - Drawing function

void CADSREnvelopeCtrl::OnDraw(CDC* pdc, 
							   const CRect& rcBounds, 
							   const CRect& rcInvalid)
{
	// MFC based containers call OnDraw multiple times with different DC's.
	// We only want to paint once and when DC is client area of control.
	// This should happen when both rcBounds.top = 0 and rcBounds.left = 0
	if(rcBounds.top != 0 && rcBounds.left != 0)
	{
		//TRACE0("Returning from ADSREnvelope control's OnDraw call without drawing\n");
		return;
	}

	//TRACE0("ADSREnvelope control's OnDraw call and going to draw\n");
	UpdateADSREnvelope(pdc, &rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl::DoPropExchange - Persistence support

void CADSREnvelopeCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl::OnResetState - Reset control to default state

void CADSREnvelopeCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl::AboutBox - Display an "About" box to the user

void CADSREnvelopeCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog dlgAbout(IDD_ABOUTBOX_ADSRENVELOPE);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelopeCtrl message handlers

void CADSREnvelopeCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
	int nOverlappedBoxes = 0;
	int nLastBox = 0;
	for(int nBoxNo = 0; nBoxNo < SEGMENT_THUMBS; nBoxNo++)
	{
		if (ADRVisible(START+1+nBoxNo) && m_rcADRPosBox[nBoxNo].PtInRect(point))
		{
			nLastBox = nBoxNo;
			nOverlappedBoxes++;
		}
	}
	if (nOverlappedBoxes == 0)
		return;
	ASSERT((m_nOnTop > START) && (m_nOnTop < END));
	if ((nOverlappedBoxes <= 1) || !m_rcADRPosBox[m_nOnTop-1].PtInRect(point))
		m_nOnTop = nLastBox + 1;
	ASSERT((m_nOnTop > START) && (m_nOnTop < END));
	ASSERT(m_rcADRPosBox[m_nOnTop-1].PtInRect(point));
	SetCapture();
	m_bHasCapture = true;
	m_nSelPB = m_nOnTop;

	ASSERT(ADRVisible(m_nSelPB)); // handle shouldn't be visible or selectable
	m_ptPrevMousePos = point;
	m_bFireUndoNotify = true;
}

void CADSREnvelopeCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	if(m_bHasCapture)
	{
		ReleaseCapture();
		m_bHasCapture = false;
		m_nSelPB = 0;
		m_ptPrevMousePos = (0,0);
	}

	int nBoxCount = m_nOnTop;

	for(int nCount = 0; nCount < SEGMENT_THUMBS; nCount++)
	{
		if(nBoxCount >= SEGMENT_THUMBS || nBoxCount < 0)
		{
			nBoxCount = 0;
		}
		if(ADRVisible(nBoxCount+1) && m_rcADRPosBox[nBoxCount].PtInRect(point))
		{
			m_nOnTop = nBoxCount+1;
			break;
		}
		nBoxCount++;
	}

	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);
}

void CADSREnvelopeCtrl::OnMouseMove(UINT nFlags, CPoint point) 
{
	long newX = 0;
	long newY = 0;
	long newRealPixels = 0;
	long delta_x = 0;
	long delta_y = 0;

	if(!m_bHasCapture)
	{
		return;
	}

	ASSERT((m_nSelPB > 0 && m_nSelPB < SEGMENTS));

	if (m_bFireUndoNotify)
	{
		FireADSRMouseMoveStart();
		m_bFireUndoNotify = false;
	}
	
	delta_x = point.x - m_ptPrevMousePos.x;
	delta_y = point.y - m_ptPrevMousePos.y;

	switch(m_nSelPB)
	{
		case DELAY:
		{
			// Can't change delay for DLS1 envelop
			if(m_bDLS1)
			{
				ASSERT(FALSE); // shouldn't be visible or selectable
				break;
			}

			// No response to y changes
			newX = m_nDelayPixels + delta_x;
			if(newX > m_nSegmentLength) 
			{
				newX = m_nSegmentLength;
				delta_x = newX - m_nDelayPixels;
			}
			else if (newX < 0) 
			{
				newX = 0;
				delta_x = -m_nDelayPixels;
			}

			m_nDelayPixels = newX;
			m_ptADRPts[DELAY].x = newX;

			// Attack drag point shifts with Delay
			if(m_ptADRPts[ATTACK].x != m_ptADRPts[DELAY].x)
			{
				m_ptADRPts[ATTACK].x += delta_x;
				m_nAPixels = m_ptADRPts[ATTACK].x;
				
				// The hold drag point shifts with attack
				m_ptADRPts[HOLD].x += delta_x;
				m_nHPixels = m_ptADRPts[HOLD].x;

				// The decay drag point shifts with hold
				m_ptADRPts[DECAY].x += delta_x;
			}

			m_lDelayTime = (long) (m_nDelayPixels * m_TimeCentsPerPixel + 0.5) + TIMECENTS_MIN;
			FireADSREDelayTimeChanged(TimeCents2Mils(m_lDelayTime));

			break;
		}

		// Attack changes a straightfoward. The x component of the drag point IS the Attack time
		case ATTACK:
		{
			int nMaxAttackLength = m_nDelayPixels + m_nSegmentLength;

			// There is no response to y changes
			newX = m_nAPixels + delta_x;
			newX = newX > nMaxAttackLength ? nMaxAttackLength : newX;
			newX = newX < m_nDelayPixels ? m_nDelayPixels : newX;
			newX = newX < 0 ? 0 : newX;
			
			delta_x = newX - m_nAPixels;
			m_nAPixels = newX;
			m_ptADRPts[ATTACK].x = newX;
			
			// The hold drag point shifts with attack
			if(m_ptADRPts[HOLD].x != m_ptADRPts[ATTACK].x)
			{
				m_ptADRPts[HOLD].x += delta_x;
				m_nHPixels = m_ptADRPts[HOLD].x;

				// The decay drag point shifts with hold
				m_ptADRPts[DECAY].x += delta_x;
			}

			m_lATime = (long) ((m_nAPixels - m_nDelayPixels) * m_TimeCentsPerPixel + 0.5) + TIMECENTS_MIN;
			FireADSREAttackTimeChanged(TimeCents2Mils(m_lATime));

			break;
		}

		case HOLD:
		{
			// Can't change delay for DLS1 envelop
			if(m_bDLS1)
			{
				ASSERT(FALSE); // shouldn't be visible or selectable
				break;
			}

			int nMaxHoldLength = m_nAPixels + m_nSegmentLength;

			// There is no response to y changes
			newX = m_nHPixels + delta_x;
			newX = newX > nMaxHoldLength ? nMaxHoldLength : newX;
			newX = newX < m_nAPixels ? m_nAPixels : newX;
			newX = newX < 0 ? 0 : newX;
			
			delta_x = newX - m_nHPixels;
			m_nHPixels = newX;
			m_ptADRPts[HOLD].x = newX;
			
			// The decay drag point shifts with hold
			if(m_ptADRPts[DECAY].x != m_ptADRPts[HOLD].x)
			{
				m_ptADRPts[DECAY].x += delta_x;
			}

			m_lHTime = (long) ((m_nHPixels - m_nAPixels) * m_TimeCentsPerPixel + 0.5) + TIMECENTS_MIN;
			FireADSREHoldTimeChanged(TimeCents2Mils(m_lHTime));

			break;
		}

		case DECAY:
		{
			int nMaxDecayLength = (m_nHPixels + m_nSegmentLength) / 2;

			newX = m_ptADRPts[DECAY].x + delta_x;
			newY = m_ptADRPts[DECAY].y + delta_y;
			if (newY > m_nHeight)
			{
				newY = m_nHeight;
			}
			if (newY < 0)
			{
				newY = 0;
			}

			m_ptADRPts[RELEASE].y = m_ptADRPts[DECAY].y = newY;
			
			// We have to extrapolate the actual (DLS spec) Decay Time from the drag point.
			if(newY)
			{
				newRealPixels = MUL_DIV(m_nHeight, newX - m_nHPixels, newY);
			}
			else // avoid divide-by-zero error
			{
				newRealPixels = MUL_DIV(m_nHeight, newX - m_nHPixels, 1);
			}

			if(TimeCents2Mils(m_lDTime) < 40000 && newRealPixels >= m_nSegmentLength)
			{
				newRealPixels = m_nSegmentLength;
			}
			if(TimeCents2Mils(m_lDTime) > 00000 && newX  <= m_nHPixels)
			{
				newRealPixels = 0;
				newX = m_nHPixels;
			}
			
			if ((newRealPixels <= m_nSegmentLength) && (newX >= m_nHPixels))
			{
				m_nDPixels = newRealPixels;
				m_ptADRPts[DECAY].x = newX;
				m_lDTime = (long) (m_nDPixels * m_TimeCentsPerPixel + 0.5) + TIMECENTS_MIN;
				FireADSREDecayTimeChanged(TimeCents2Mils(m_lDTime));
				//calculate the TimeCent value of the x component of the drag point.
				//this is the "real" time in terms of the sound of the instruments articulation
				UpdateRealDecayTime();
			}
			else if (delta_y)//even if we are maxed/mined out on the x we may have had a change in y. So
			{//the drag point must "slide" down its line
				m_ptADRPts[DECAY].x = m_nHPixels + MUL_DIV(m_ptADRPts[DECAY].y, m_nDPixels, m_nHeight);
				UpdateRealDecayTime();
			}
			if (delta_y)//in either case changes in y (i.e. sustain level) require
			{//the release drag point to "slide" down its line
				m_ptADRPts[RELEASE].x = (m_nWidth - 1) - MUL_DIV(m_nHeight - newY, m_nRPixels, m_nHeight);
				UpdateRealReleaseTime();
				m_lSLevel = (long) (((m_nHeight - m_ptADRPts[DECAY].y) / m_PixelsPerTenthPercent) + 0.5);
				FireADSRESustainLevelChanged(m_lSLevel);
			}
			break;
		}

		case RELEASE:
		{
			int nMaxReleaseLength = (m_nHPixels + m_nSegmentLength) / 2;

			newX = m_ptADRPts[RELEASE].x + delta_x;
			newY = m_ptADRPts[RELEASE].y + delta_y;

			if (newY > m_nHeight)
			{
				newY = m_nHeight;
			}
			if (newY < 0)
			{
				newY = 0;
			}

			m_ptADRPts[DECAY].y = m_ptADRPts[RELEASE].y = newY;
			
			// We have to extrapolate the actual (DLS spec) Release Time from the drag point.
			if(newY < m_nHeight)
			{
				newRealPixels = MUL_DIV((m_nWidth - 1) - newX, m_nHeight, m_nHeight - newY);
			}
			else
			{
				newRealPixels = MUL_DIV((m_nWidth - 1) - newX, m_nHeight, 1);
			}

			if(TimeCents2Mils(m_lRTime) < 40000 && newRealPixels > m_nSegmentLength)
			{
				newRealPixels = m_nSegmentLength;
			}
			
			if(TimeCents2Mils(m_lRTime) > 00000 && newX  < m_nDPixels)
			{
				newRealPixels = m_nDPixels;
				newX = m_nDPixels;
			}

			if((newRealPixels <= m_nSegmentLength) && (newX < m_nWidth))
			{
				m_nRPixels = newRealPixels;
				m_ptADRPts[RELEASE].x = newX;
				m_lRTime = (long) (m_nRPixels * m_TimeCentsPerPixel + 0.5) + TIMECENTS_MIN;
				FireADSREReleaseTimeChanged(TimeCents2Mils(m_lRTime));
				
				// Calculate the TimeCent value of the x component of the drag point.
				// This is the "real" time in terms of the sound of the instruments articulation
				UpdateRealReleaseTime();
			}
			// Even if we are maxed/mined out on the x we may have had a change in y. So
			// the drag point must "slide" down its line
			else if(delta_y)
			{
				m_ptADRPts[RELEASE].x = (m_nWidth-1)- MUL_DIV(m_nHeight - newY, m_nRPixels, m_nHeight);
				UpdateRealReleaseTime();
			}
			
			// In either case changes in y (i.e. sustain level) require the release drag point to "slide" down its line
			if(delta_y)	
			{				
				m_ptADRPts[DECAY].x = m_nHPixels + MUL_DIV(m_ptADRPts[DECAY].y, m_nDPixels, m_nHeight);
				UpdateRealDecayTime();
				m_lSLevel = (long) (((m_nHeight - m_ptADRPts[RELEASE].y) / m_PixelsPerTenthPercent) + 0.5);
				FireADSRESustainLevelChanged(m_lSLevel);
			}
			break;
		}
	}
	m_ptPrevMousePos = point;

	CClientDC* pCtrlDC = new CClientDC(this);
	UpdateADSREnvelope(pCtrlDC);
	delete pCtrlDC;
}


void CADSREnvelopeCtrl::UpdateADSREnvelope(CDC *pDC, const CRect* rcBounds)
{
	// background: white box with a margin colored like the dialog
	CRect rcClient, rcDraw;
	const COLORREF rgbMargin = GetSysColor(COLOR_BTNFACE);
	GetClientRect(&rcClient);
	rcDraw.SetRect(rcClient.left, rcClient.top, rcClient.right, rcClient.top+UI_MARGIN);
	pDC->FillSolidRect(&rcDraw, rgbMargin);
	rcDraw.SetRect(rcClient.left, rcClient.top+UI_MARGIN, rcClient.left+UI_MARGIN, rcClient.bottom-UI_MARGIN);
	pDC->FillSolidRect(&rcDraw, rgbMargin);
	rcDraw.SetRect(rcClient.right-UI_MARGIN, rcClient.top+UI_MARGIN, rcClient.right, rcClient.bottom-UI_MARGIN);
	pDC->FillSolidRect(&rcDraw, rgbMargin);
	rcDraw.SetRect(rcClient.left, rcClient.bottom-UI_MARGIN, rcClient.right, rcClient.bottom);
	pDC->FillSolidRect(&rcDraw, rgbMargin);
	rcClient.InflateRect(-UI_MARGIN, -UI_MARGIN);
	pDC->FillSolidRect(&rcClient, PALETTERGB(255, 255, 255));

	// articulation segments
	int nPrevMode = pDC->SetROP2(R2_COPYPEN);
	pDC->MoveTo(UI_MARGIN+m_ptADRPts[0].x, UI_MARGIN+m_ptADRPts[0].y);
	for (int i = 0; i < SEGMENTS; i++)
		{
		BYTE iY = (i == DELAY-1) ? 0 : i+1;
		COLORREF cr;
		switch (i)
			{
		case 5:
			cr = RELEASE_COLOR;
			break;

		case 4:
			cr = SUSTAIN_COLOR;
			break;
		
		default:
			ASSERT(i <= 3);
			cr = arrPositionBoxColors[i];
			break;
			}
		
		CPen pen(PS_SOLID, 1, cr);
		CPen *pOldPen = pDC->SelectObject(&pen);
		pDC->LineTo(UI_MARGIN+m_ptADRPts[i+1].x , UI_MARGIN+m_ptADRPts[iY].y);
		pDC->SelectObject(pOldPen);
		}
	pDC->SetROP2(nPrevMode);

	// Create handle used to adjust ADR times
	for (i = 0; i < SEGMENT_THUMBS; i++)
		{
		int iY = (i == DELAY-1) ? 0 : i+1;
		m_rcADRPosBox[i].SetRect(
			UI_MARGIN + m_ptADRPts[i+1].x - HALF_POS_BOX_HW, 
			UI_MARGIN + m_ptADRPts[iY].y - HALF_POS_BOX_HW, 
			UI_MARGIN + m_ptADRPts[i+1].x + HALF_POS_BOX_HW, 
			UI_MARGIN + m_ptADRPts[iY].y + HALF_POS_BOX_HW);
		}

	for (i = 0; i < SEGMENT_THUMBS; i++)
	{
		// don't draw handles that can't be drawn
		if (!ADRVisible(i+1))
			continue;

		pDC->FillSolidRect(m_rcADRPosBox[i], arrPositionBoxColors[i]);
	}

	// draw the one on top
	if(m_nOnTop > 0)
		pDC->FillSolidRect(m_rcADRPosBox[m_nOnTop - 1], arrPositionBoxColors[m_nOnTop - 1]);
}

int CADSREnvelopeCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}

	m_lDelayTime = -11960;
	m_lATime = 173;
	m_lHTime = 6387;
	m_lDTime = -10000;
	m_lRTime = 347;
	m_lSLevel = 750;

	RECT rect;
	GetClientRect(&rect);
	InflateRect(&rect, -UI_MARGIN, -UI_MARGIN);

	m_nWidth = rect.right;
	m_nHeight = rect.bottom;

	m_nMaxPixels = m_nWidth / 2;
	m_nSegmentLength = m_nWidth / 4;

	m_TimeCentsPerPixel = (double)TIMECENTS_RANGE / m_nSegmentLength;
	m_PixelsPerTenthPercent = m_nHeight / 1000.0;

	m_nDelayPixels = (long) (((m_lDelayTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nAPixels = (long) (((m_lATime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nHPixels = (long) (((m_lHTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nDPixels = (long) (((m_lDTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nRPixels = (long) (((m_lRTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);

	m_ptADRPts[START].x = 0;
	m_ptADRPts[START].y = m_nHeight - 1;

	m_ptADRPts[DELAY].x = m_nDelayPixels;
	m_ptADRPts[DELAY].y = 0;

	m_ptADRPts[ATTACK].x = m_nAPixels;
	m_ptADRPts[ATTACK].y = 0;

	m_ptADRPts[HOLD].x = m_nHPixels;
	m_ptADRPts[HOLD].y = 0;
	
	m_ptADRPts[DECAY].y = m_nHeight - (long)((m_lSLevel * m_PixelsPerTenthPercent) + 0.5);
	m_ptADRPts[DECAY].x = m_nAPixels + MUL_DIV(m_ptADRPts[DECAY].y, m_nDPixels, m_nHeight);
	
	m_ptADRPts[RELEASE].y = m_ptADRPts[DECAY].y;
	m_ptADRPts[RELEASE].x = (m_nWidth-1) - MUL_DIV(m_nHeight - m_ptADRPts[RELEASE].y, m_nRPixels, m_nHeight );
	
	m_ptADRPts[END].x = m_nWidth - 1;
	m_ptADRPts[END].y = m_nHeight - 1;

	return 0;
}

long CADSREnvelopeCtrl::GetAttackTime() 
{
	return (long) TimeCents2Mils(m_lATime);
}

void CADSREnvelopeCtrl::SetAttackTime(long nNewValue) 
{
	ASSERT(nNewValue >= 1 && nNewValue <= 40000);		
	
	m_lATime = Mils2TimeCents(nNewValue);

	m_nAPixels = m_nDelayPixels + (long) (((m_lATime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	int nDeltaX = m_nAPixels - m_ptADRPts[ATTACK].x; 

	m_ptADRPts[ATTACK].x = m_nAPixels;

	// Hold drag point changes with attack
	m_ptADRPts[HOLD].x += nDeltaX;
	m_nHPixels = m_ptADRPts[HOLD].x;

	// The decay drag point shifts with hold
	m_ptADRPts[DECAY].x += nDeltaX;
	m_nDPixels = m_ptADRPts[DECAY].x;
	
	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);

	SetModifiedFlag();
	
	FireADSREAttackTimeChanged(nNewValue);
}

long CADSREnvelopeCtrl::GetDecayTime() 
{
	return (long) TimeCents2Mils(m_lDTime);
}

void CADSREnvelopeCtrl::SetDecayTime(long nNewValue) 
{

	ASSERT(nNewValue >= 1 && nNewValue <= 40000);		
	
	m_lDTime = Mils2TimeCents(nNewValue);

	m_nDPixels = (long) (((m_lDTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_ptADRPts[DECAY].x = m_nHPixels + MUL_DIV(m_ptADRPts[DECAY].y, m_nDPixels, m_nHeight);

	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);

	SetModifiedFlag();
	
	UpdateRealDecayTime();

	FireADSREDecayTimeChanged(nNewValue);
}

long CADSREnvelopeCtrl::GetSustainLevel() 
{
	return m_lSLevel;
}

void CADSREnvelopeCtrl::SetSustainLevel(long nNewValue) 
{
	ASSERT(nNewValue >= 0 && nNewValue <= 1000);

	m_lSLevel = nNewValue;

	m_ptADRPts[DECAY].y = m_nHeight - (long)((m_lSLevel * m_PixelsPerTenthPercent) + 0.5);
	m_ptADRPts[DECAY].x = m_nHPixels + MUL_DIV(m_ptADRPts[DECAY].y, m_nDPixels, m_nHeight);

	m_ptADRPts[RELEASE].y = m_ptADRPts[DECAY].y;
	m_ptADRPts[RELEASE].x = (m_nWidth-1) - MUL_DIV(m_nHeight - m_ptADRPts[RELEASE].y, m_nRPixels, m_nHeight);

	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);

	FireADSRESustainLevelChanged(nNewValue);
	UpdateRealDecayTime();
	UpdateRealReleaseTime();
}

long CADSREnvelopeCtrl::GetReleaseTime() 
{
	return (long) TimeCents2Mils(m_lRTime);
}

void CADSREnvelopeCtrl::SetReleaseTime(long nNewValue) 
{

	ASSERT(nNewValue >= 1 && nNewValue <= 40000);		
	
	m_lRTime = Mils2TimeCents(nNewValue);

	m_nRPixels = (long) (((m_lRTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_ptADRPts[RELEASE].x = (m_nWidth-1) - MUL_DIV(m_nHeight - m_ptADRPts[RELEASE].y, m_nRPixels, m_nHeight );
	
	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);

	SetModifiedFlag();
	UpdateRealReleaseTime();
	FireADSREReleaseTimeChanged(nNewValue);
}

void CADSREnvelopeCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);

	cx -= UI_MARGIN*2;
	cy -= UI_MARGIN*2;

	m_nWidth = cx;
	m_nHeight = cy;

	m_nMaxPixels = m_nWidth / 2;
	m_nSegmentLength = m_nWidth / 4;

	m_TimeCentsPerPixel = (double)TIMECENTS_RANGE / m_nSegmentLength;
	m_PixelsPerTenthPercent = m_nHeight / 1000.0;

	m_nDelayPixels = (long) (((m_lDelayTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nAPixels = (long) (((m_lATime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nHPixels = (long) (((m_lHTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nDPixels = (long) (((m_lDTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);
	m_nRPixels = (long) (((m_lRTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);

	m_ptADRPts[START].y = m_nHeight - 1;

	m_ptADRPts[DELAY].x = m_nDelayPixels;
	m_ptADRPts[ATTACK].x = m_nAPixels;
	m_ptADRPts[HOLD].x = m_nHPixels;

	m_ptADRPts[DECAY].y = m_nHeight - (long)((m_lSLevel * m_PixelsPerTenthPercent) + 0.5);
	m_ptADRPts[DECAY].x = m_nHPixels + MUL_DIV(m_ptADRPts[DECAY].y, m_nDPixels, m_nHeight);

	m_ptADRPts[RELEASE].y = m_ptADRPts[DECAY].y;
	m_ptADRPts[RELEASE].x = (m_nWidth-1) - MUL_DIV(m_nHeight - m_ptADRPts[RELEASE].y, m_nRPixels, m_nHeight);

	m_ptADRPts[END].x = m_nWidth - 1;
	m_ptADRPts[END].y = m_nHeight - 1;

}



void CADSREnvelopeCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
		/*int nOverlappedBoxes = 0;
	int nLastBox = 0;
	// If there's no overlap return
	for(int nBoxNo = 0; nBoxNo < 3; nBoxNo++)
	{
		if(m_rcADRPosBox[nBoxNo].PtInRect(point))
		{
			nLastBox = nBoxNo;
			nOverlappedBoxes++;
		}
	}
	if(nOverlappedBoxes <= 1)
	{
		m_nOnTop = nLastBox + 1;
		return;
	}

	// -1 is no overlap
	int nOnTop = -1;
	for(nBoxNo = 0; nBoxNo < 3; nBoxNo++)
	{
		if(m_rcADRPosBox[nBoxNo].PtInRect(point) && m_nOnTop != nBoxNo + 1)
		{
			nOnTop = nBoxNo + 1;
			break;
		}
	}
	m_nOnTop = nOnTop;*/
	

	COleControl::OnLButtonDblClk(nFlags, point);
}


long CADSREnvelopeCtrl::GetDelayTime() 
{
	return (long) TimeCents2Mils(m_lDelayTime);
	return 0;
}

void CADSREnvelopeCtrl::SetDelayTime(long nNewValue) 
{
	ASSERT(nNewValue >= 1 && nNewValue <= 40000);		
	
	m_lDelayTime = Mils2TimeCents(nNewValue);


	m_nDelayPixels = (long) (((m_lDelayTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);

	int nDeltaX = m_nDelayPixels - m_ptADRPts[DELAY].x; 
	m_ptADRPts[DELAY].x = m_nDelayPixels;


	// Attack drag point shifts with Delay
	m_ptADRPts[ATTACK].x += nDeltaX;
	m_nAPixels = m_ptADRPts[ATTACK].x;
	
	// The hold drag point shifts with attack
	m_ptADRPts[HOLD].x += nDeltaX;
	m_nHPixels = m_ptADRPts[HOLD].x;

	// The decay drag point shifts with hold
	m_ptADRPts[DECAY].x += nDeltaX;
	m_nDPixels = m_ptADRPts[DECAY].x;
	
	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);

	SetModifiedFlag();
	
	FireADSREDelayTimeChanged(nNewValue);
}

long CADSREnvelopeCtrl::GetHoldTime() 
{
	return (long) TimeCents2Mils(m_lHTime);
	return 0;
}

void CADSREnvelopeCtrl::SetHoldTime(long nNewValue) 
{
	ASSERT(nNewValue >= 1 && nNewValue <= 40000);		
	
	m_lHTime = Mils2TimeCents(nNewValue);

	m_nHPixels = m_nAPixels + (long)(((m_lHTime - TIMECENTS_MIN) / m_TimeCentsPerPixel) + 0.5);

	int nDeltaX = m_nHPixels - m_ptADRPts[HOLD].x; 
	m_ptADRPts[HOLD].x = m_nHPixels;

	// The decay drag point shifts with hold
	m_ptADRPts[DECAY].x += nDeltaX;
	m_nDPixels = m_ptADRPts[DECAY].x;

	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);

	SetModifiedFlag();
	
	FireADSREHoldTimeChanged(nNewValue);
}

void CADSREnvelopeCtrl::OnRButtonDown(UINT nFlags, CPoint point) 
{
	OnLButtonUp(nFlags, point) ;
	
	COleControl::OnRButtonDown(nFlags, point);
}

void CADSREnvelopeCtrl::SetDLS1(BOOL bDLS1) 
{
	m_bDLS1 = bDLS1;

	// change selected handle if it was DLS2 and we're switching to DLS1
	if (bDLS1)
		if ((m_nOnTop == DELAY) || (m_nOnTop == HOLD))
			m_nOnTop = ATTACK;

	// update envelope control to display/hide DLS1 controls
	CClientDC ctrlDC(this);
	UpdateADSREnvelope(&ctrlDC);
}

/* returns whether the given handle (DELAY, ATTACK, etc) is visible given the DLS1 setting. */
bool CADSREnvelopeCtrl::ADRVisible(BYTE btLevel)
{
	ASSERT((btLevel > START) && (btLevel < END));
	return (!m_bDLS1 || ((btLevel != DELAY) && (btLevel != HOLD)));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ADSREnvelope\Utilities.h ===
// Utilities.h
//

#ifndef _UTILITIES_
#define _UTILITIES_

#include <math.h>

typedef long    TCENT;

TCENT Mils2TimeCents(DWORD dwMils);
DWORD TimeCents2Mils(TCENT tcTime);

#define DEF_ROUND_MULDIV

#ifdef DEF_ROUND_MULDIV

#define MUL_DIV(x,y,z) (long) ( ((x) * (y) / (float) (z)) + 0.5 )

#else

#define MUL_DIV(x,y,z) MulDiv((x),(y),(z))

#endif //DEF_ROUND_MULDIV
#endif //_UTILITIES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathComponent.h ===
#ifndef __AUDIOPATHCOMPONENT_H__
#define __AUDIOPATHCOMPONENT_H__

// AudioPathComponent.h : header file
//

#include <Conductor.h>

class CDirectMusicAudioPath;
interface IDirectMusicPerformance8;
interface IDirectMusic;
class EffectInfo;
struct PortOptions;

class CAudioPathComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt
{
friend class CDlgNewAudiopath;
friend class CTabEffectInfo;
public:
    CAudioPathComponent();
	~CAudioPathComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists();
	BOOL RegisterClipboardFormats();
	void ReleaseAll();

public:
    HRESULT STDMETHODCALLTYPE GetAudioPathImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetAudioPathRefImageIndex( short* pnNbrFirstImage );
	void AddToAudioPathFileList( CDirectMusicAudioPath* pAudioPath );
	void RemoveFromAudioPathFileList( CDirectMusicAudioPath* pAudioPath );

public:
	IDMUSProdFramework*			m_pIFramework;
	IDirectMusicPerformance8*	m_pIDMPerformance;
	IDirectMusic*				m_pIDMusic;
	IDMUSProdConductor8*		m_pIConductor;
	IDMUSProdComponent*			m_pIToolGraphComponent;
	short						m_nNextAudioPath;		// appended to name of new AudioPath
	UINT						m_cfProducerFile;		// CF_DMUSPROD_FILE clipboard format
	UINT						m_cfAudioPath;			// CF_AUDIOPATH clipboard format
	UINT						m_cfAudioPathList;		// CF_AUDIOPATHLIST clipboard format
	UINT						m_cfGraph;				// CF_GRAPH clipboard format
	IDMUSProdPropPageManager	*m_pIAudioPathPageManager;
	IDMUSProdPropPageManager	*m_pIEffectPageManager;
	IDMUSProdPropPageManager	*m_pIMixGroupPageManager;
	IDMUSProdPropPageManager	*m_pIBufferPageManager;

private:
    DWORD						m_dwRef;
	IDMUSProdDocType8*			m_pIAudioPathDocType8;
	short						m_nFirstImage;

	CTypedPtrList<CPtrList, CDirectMusicAudioPath*> m_lstAudioPaths;
};

#endif // __AUDIOPATHCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathCtl.cpp ===
// AudioPathCtl.cpp : Implementation of the CAudioPathCtrl ActiveX Control class.

#include "stdafx.h"
#include "AudioPathDesignerDLL.h"
#include "AudioPath.h"
#include "AudioPathCtl.h"
#include "AudioPathRef.h"
#include "AudioPathDlg.h"
#include "EffectListDlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CAudioPathCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CAudioPathCtrl, COleControl)
	//{{AFX_MSG_MAP(CAudioPathCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CAudioPathCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CAudioPathCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CAudioPathCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CAudioPathCtrl, COleControl)
	//{{AFX_EVENT_MAP(CAudioPathCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl Interface map

BEGIN_INTERFACE_MAP(CAudioPathCtrl, COleControl)
    INTERFACE_PART(CAudioPathCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CAudioPathCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CAudioPathCtrl, 1)
//	PROPPAGEID(CAudioPathPropPage::guid)
END_PROPPAGEIDS(CAudioPathCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CAudioPathCtrl, "AUDIOPATHDESIGNER.AudioPathCtrl.1", 
	0xC466D59C, 0xCD47, 0x4b38, 0x99, 0x64, 0x4d, 0xe3, 0x73, 0xaf, 0x48, 0x30);


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CAudioPathCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DAudioPath = 
		{ 0xC08121D8, 0x06A9, 0x4e07, { 0x80, 0x32, 0x5f, 0x11, 0x51, 0x86, 0x53, 0xbd } };
const IID BASED_CODE IID_DAudioPathEvents =
		{ 0xA1C0DB37, 0x2e71, 0x48d8, { 0xbd, 0x15, 0x4a, 0xe9, 0x41, 0xd8, 0x21, 0xe2 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwAudioPathOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CAudioPathCtrl, IDS_AUDIOPATH, _dwAudioPathOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::CAudioPathCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CAudioPathCtrl

BOOL CAudioPathCtrl::CAudioPathCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_AUDIOPATH,
			IDB_AUDIOPATH,
			afxRegApartmentThreading,
			_dwAudioPathOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::CAudioPathCtrl - Constructor

CAudioPathCtrl::CAudioPathCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DAudioPath, &IID_DAudioPathEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DAudioPath;
	m_piidEvents = &IID_DAudioPathEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pAudioPathDlg = NULL;
	m_pEffectListDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_pAudioPath = NULL;
	m_hAcceleratorTable = NULL;
	m_dlgFocus = FOC_NONE;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::~CAudioPathCtrl - Destructor

CAudioPathCtrl::~CAudioPathCtrl()
{
	RELEASE( m_pAudioPath );
	if( m_pAudioPathDlg )
	{
		delete m_pAudioPathDlg;
		m_pAudioPathDlg = NULL;
	}
	if( m_pEffectListDlg )
	{
		delete m_pEffectListDlg;
		m_pEffectListDlg = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CAudioPathCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CAudioPathCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CAudioPathCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CAudioPathCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::QueryInterface

STDMETHODIMP CAudioPathCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CAudioPathCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::AttachObjects implementation

HRESULT CAudioPathCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	GUID guidNode;

	pINode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_AudioPathRefNode ) )
	{
		CAudioPathRef* pAudioPathRef = (CAudioPathRef *)pINode;
		ASSERT( pAudioPathRef->m_pAudioPath != NULL );
		pThis->m_pAudioPath = pAudioPathRef->m_pAudioPath;
	}
	else
	{
		pThis->m_pAudioPath = (CDirectMusicAudioPath *)pINode;
	}

	ASSERT( pThis->m_pAudioPath != NULL );
	pThis->m_pAudioPath->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::OnInitMenuFilePrint

HRESULT CAudioPathCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::OnFilePrint

HRESULT CAudioPathCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CAudioPathCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::OnFilePrintPreview

HRESULT CAudioPathCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::OnViewProperties

HRESULT CAudioPathCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, Editor )

	HRESULT hr = E_FAIL;

	if( pThis->m_pAudioPathDlg )
	{
		if( pThis->m_pAudioPathDlg->OnViewProperties() )
		{
			hr = S_OK;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XEditor::OnF1Help

HRESULT CAudioPathCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/AudioPathDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CAudioPathCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CAudioPathCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	
	// Translate only if we have focus
	if( pThis->m_pAudioPathDlg && pThis->m_pEffectListDlg )
	{
		const HWND hWndMixGroup = pThis->m_pAudioPathDlg->GetSafeHwnd();
		const HWND hWndEffectList = pThis->m_pEffectListDlg->GetSafeHwnd();
		const HWND hWndFocus = ::GetFocus();
		const HWND hWndFocusParent = ::GetParent( hWndFocus );

		// Only check one level, so that we don't try and translate accelerators
		// in the edit control in the PChannel tree (used for editing the Mix
		// Group name).
		if( hWndFocus == hWndMixGroup
		||	hWndFocus == hWndEffectList
		||	hWndFocusParent == hWndMixGroup
		||	hWndFocusParent == hWndEffectList )
		{
			if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
			{
				return S_OK;
			}
		}
	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CAudioPathCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CAudioPathCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnDraw - Drawing function

void CAudioPathCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
{
	UNREFERENCED_PARAMETER(pdc);
	UNREFERENCED_PARAMETER(rcBounds);
	UNREFERENCED_PARAMETER(rcInvalid);
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::DoPropExchange - Persistence support

void CAudioPathCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnResetState - Reset control to default state

void CAudioPathCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAudioPathAbout dialog used for AudioPath Editor About Box

class CAudioPathAbout : public CDialog
{
public:
	CAudioPathAbout();

// Dialog Data
	//{{AFX_DATA(CAudioPathAbout)
	enum { IDD = IDD_ABOUTBOX_AUDIOPATH };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAudioPathAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAudioPathAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAudioPathAbout::CAudioPathAbout() : CDialog(CAudioPathAbout::IDD)
{
	//{{AFX_DATA_INIT(CAudioPathAbout)
	//}}AFX_DATA_INIT
}

void CAudioPathAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAudioPathAbout)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAudioPathAbout, CDialog)
	//{{AFX_MSG_MAP(CAudioPathAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CAudioPathAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achExeName, FILENAME_MAX ) )
	{
		if( theApp.GetFileVersion( achExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_AUDIOPATH_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::AboutBox - Display an "About" box to the user

void CAudioPathCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CAudioPathAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnHideToolBars

void CAudioPathCtrl::OnHideToolBars() 
{
	COleControl::OnHideToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnShowToolBars

void CAudioPathCtrl::OnShowToolBars() 
{
	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	COleControl::OnShowToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnGetInPlaceMenu

HMENU CAudioPathCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnCreate

int CAudioPathCtrl::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( COleControl::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_AUDIOPATH_EDITOR) );

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_AUDIOPATH_ACCELS) );

	// Create the Splitter and position it in the Editor
	// (temporary values added until coords are saved to design-time file)
	RECT rect;
	GetClientRect(&rect);
	rect.left = lpCreateStruct->cx;
	rect.right = rect.left + DefaultSplitterWidth;
	rect.bottom = lpCreateStruct->cy;
	rect.top = lpCreateStruct->y;

	m_wndSplitter.Create( (CWnd*)this, &rect );

	// Create the PChannel dialog and position it in the First Splitter Pane
	m_pAudioPathDlg = new CAudioPathDlg;
	if( m_pAudioPathDlg == NULL )
	{
		return -1;
	}

	// Point the AudioPath dialog back to us and at the AudioPath object
	m_pAudioPathDlg->m_pAudioPath = m_pAudioPath;
	m_pAudioPathDlg->m_pAudioPathCtrl = this;
	m_pAudioPathDlg->Create( IDD_DLG_AUDIOPATH, this );
	m_pAudioPathDlg->ShowWindow( SW_SHOW );
	m_wndSplitter.SetFirstPane( m_pAudioPathDlg );

	// Create the effect list and position it in the Second Splitter Pane
	m_pEffectListDlg = new CEffectListDlg;
	if( m_pEffectListDlg == NULL )
	{
		return -1;
	}

	// Point the EffectList dialog back to us and at the AudioPath object
	m_pEffectListDlg->m_pAudioPath = m_pAudioPath;
	m_pEffectListDlg->m_pAudioPathCtrl = this;
	m_pEffectListDlg->Create( IDD_DLG_EFFECTLIST, this );
	m_pEffectListDlg->ShowWindow( SW_SHOW );
	m_wndSplitter.SetSecondPane( m_pEffectListDlg );

	// Point the AudioPath at us
	m_pAudioPath->m_pAudioPathCtrl = this;

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnDestroy

void CAudioPathCtrl::OnDestroy() 
{
	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}

	if( m_hAcceleratorTable )
	{
		::DestroyAcceleratorTable( m_hAcceleratorTable );
		m_hAcceleratorTable = NULL;
	}

	ASSERT( m_pAudioPath != NULL );

	m_pAudioPath->m_pAudioPathCtrl = NULL;

	// Delete the dialog windows in the destructor, not here!
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnSize

void CAudioPathCtrl::OnSize( UINT nType, int cx, int cy ) 
{
	COleControl::OnSize( nType, cx, cy );

	// get splitter position from audio path
	WORD pos = m_pAudioPath->GetSplitterPos();

	// calculate where splitter should be
	if(pos == 0)
	{
		// Don't update the AudioPath if the window width is 200, since that is
		// the size set before the window is initialized
		if( cx != 200 )
		{
			// Calculate size of effect palette columns
			if( m_pEffectListDlg )
			{
				int nWidth = m_pEffectListDlg->m_listEffects.GetColumnWidth( 0 );

				// If the effect palette is less than half the width of the display
				if( nWidth < (cx - DefaultSplitterWidth)/2 )
				{
					// Give the effect palette just enough space to display itself
					pos = WORD(min( USHRT_MAX, nWidth ));
				}
			}

			// If the effect pallete is more than half the width of the display,
			// or if there is no effect palette
			if( pos == 0 )
			{
				// put it right in the middle
				pos = WORD(min( USHRT_MAX, (cx - DefaultSplitterWidth)/2 ));
			}

			// tell audio path where it is so it can save it
			m_pAudioPath->SetSplitterPos(pos, false);
		}
	}

	// Update splitter position, if it's non-zero and the width is not 200
	if( (pos != 0) || (cx != 200) )
	{
		// splitter is right side of chord dialog and left side
		// of signpost dialog
		RECT rect;
		GetClientRect(&rect);
		MoveWindow(0,0,cx,cy);
		rect.right = max( DefaultSplitterWidth, cx - pos );
		rect.left = rect.right - DefaultSplitterWidth;
		m_wndSplitter.SetTracker(rect);
		m_wndSplitter.MoveWindow( &rect, TRUE );
		m_pAudioPathDlg->MoveWindow(0,0,rect.left, rect.bottom);
		m_pEffectListDlg->MoveWindow(rect.right, 0, cx - rect.right, rect.bottom);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditUndo

void CAudioPathCtrl::OnUpdateEditUndo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pAudioPath  )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pAudioPath->m_pUndoMgr != NULL );

		if( m_pAudioPath->m_pUndoMgr )
		{
			if( m_pAudioPath->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditUndo

void CAudioPathCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	if( m_pAudioPath )
	{
		ASSERT( m_pAudioPath->m_pUndoMgr != NULL );

		if( m_pAudioPath->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pAudioPath->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				m_pAudioPath->m_pUndoMgr->Undo( m_pAudioPath );
				m_pAudioPath->SetModified( TRUE );

				// Get a pointer to the property sheet
				IDMUSProdPropSheet* pIPropSheet;
				if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
				{
					// Check if property sheet is visible
					if( pIPropSheet->IsShowing() == S_OK )
					{
						SwitchToCorrectPropertyPage();
					}

					pIPropSheet->Release();
				}

				m_pAudioPath->SyncAudiopathsInUse( AUDIOPATH_UNLOAD_DOWNLOAD_WAVES );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditRedo

void CAudioPathCtrl::OnUpdateEditRedo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pAudioPath )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pAudioPath->m_pUndoMgr != NULL );

		if( m_pAudioPath->m_pUndoMgr )
		{
			if( m_pAudioPath->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditRedo

void CAudioPathCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	if( m_pAudioPath )
	{
		ASSERT( m_pAudioPath->m_pUndoMgr != NULL );

		if( m_pAudioPath->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pAudioPath->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				m_pAudioPath->m_pUndoMgr->Redo( m_pAudioPath );
				m_pAudioPath->SetModified( TRUE );

				// Get a pointer to the property sheet
				IDMUSProdPropSheet* pIPropSheet;
				if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
				{
					// Check if property sheet is visible
					if( pIPropSheet->IsShowing() == S_OK )
					{
						SwitchToCorrectPropertyPage();
					}

					pIPropSheet->Release();
				}

				m_pAudioPath->SyncAudiopathsInUse( AUDIOPATH_UNLOAD_DOWNLOAD_WAVES );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditCut

void CAudioPathCtrl::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnUpdateEditCut( pCmdUI );
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnUpdateEditCut( pCmdUI );
			return;
		}
		break;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditCut

void CAudioPathCtrl::OnEditCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnEditCut();
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnEditCut();
			return;
		}
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditCopy

void CAudioPathCtrl::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnUpdateEditCopy( pCmdUI );
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnUpdateEditCopy( pCmdUI );
			return;
		}
		break;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditCopy

void CAudioPathCtrl::OnEditCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnEditCopy();
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnEditCopy();
			return;
		}
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditPaste

void CAudioPathCtrl::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnUpdateEditPaste( pCmdUI );
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnUpdateEditPaste( pCmdUI );
			return;
		}
		break;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditPaste

void CAudioPathCtrl::OnEditPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnEditPaste();
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnEditPaste();
			return;
		}
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditInsert

void CAudioPathCtrl::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnUpdateEditInsert( pCmdUI );
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnUpdateEditInsert( pCmdUI );
			return;
		}
		break;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditInsert

void CAudioPathCtrl::OnEditInsert() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnEditInsert();
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnEditInsert();
			return;
		}
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditDelete

void CAudioPathCtrl::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnUpdateEditDelete( pCmdUI );
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnUpdateEditDelete( pCmdUI );
			return;
		}
		break;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditDelete

void CAudioPathCtrl::OnEditDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnEditDelete();
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnEditDelete();
			return;
		}
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnUpdateEditSelectAll

void CAudioPathCtrl::OnUpdateEditSelectAll(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnUpdateEditSelectAll( pCmdUI );
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnUpdateEditSelectAll( pCmdUI );
			return;
		}
		break;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnEditSelectAll

void CAudioPathCtrl::OnEditSelectAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		if( m_pAudioPathDlg )
		{
			m_pAudioPathDlg->OnEditSelectAll();
			return;
		}
		break;
	case FOC_EFFECT:
		if( m_pEffectListDlg )
		{
			m_pEffectListDlg->OnEditSelectAll();
			return;
		}
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::OnHelpFinder

void CAudioPathCtrl::OnHelpFinder() 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::EndTrack

void CAudioPathCtrl::EndTrack( int nWidth )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	RECT rect;
	GetWindowRect( &rect );

	// tell AudioPath the new splitter width
	m_pAudioPath->SetSplitterPos( WORD(min( USHRT_MAX, max( 0, rect.right - rect.left - nWidth - DefaultSplitterWidth) )) );

	CalcWindowRect( &rect );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::SetLastFocus

void CAudioPathCtrl::SetLastFocus(DialogFocus dlgFocus)
{
	m_dlgFocus = dlgFocus;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl::SwitchToCorrectPropertyPage

void CAudioPathCtrl::SwitchToCorrectPropertyPage( void )
{
	IDMUSProdPropSheet* pIPropSheet;

	switch( m_dlgFocus )
	{
	case FOC_MIXGROUP:
		m_pAudioPathDlg->SwitchToCorrectPropertyPage();
		break;

	default:
		// Show the AudioPath properties
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			short nActiveTab = CAudioPathPropPageManager::sm_nActiveTab;

			if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIAudioPathPageManager) ) )
			{
				theApp.m_pAudioPathComponent->m_pIAudioPathPageManager->SetObject( m_pAudioPath );
				pIPropSheet->SetActivePage( nActiveTab ); 
			}

			pIPropSheet->Release();
		}
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathComponent.cpp ===
// AudioPathComponent.cpp : implementation file
//

#include "stdafx.h"

#include "AudioPathDesignerDLL.h"
#include "AudioPath.h"
#include "AudioPathRef.h"
#include "ItemInfo.h"
#include "EffectInfo.h"
#include "EffectPPGMgr.h"
#include "MixGroupPPGMgr.h"
#include "BufferPPGMgr.h"
#include "ToolGraphDesigner.h"


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent constructor/destructor 

CAudioPathComponent::CAudioPathComponent()
{
    m_dwRef = 0;
	
	m_pIFramework = NULL;
	m_pIDMPerformance = NULL;
	m_pIDMusic = NULL;

	m_pIAudioPathDocType8 = NULL;
	m_pIConductor = NULL;
	m_pIToolGraphComponent	= NULL;
	m_nFirstImage = 0;

	m_nNextAudioPath = 0;

	m_cfProducerFile = 0;
	m_cfAudioPath = 0;
	m_cfAudioPathList = 0;
	m_cfGraph= 0;

	m_pIAudioPathPageManager = NULL;
	m_pIEffectPageManager = NULL;
	m_pIMixGroupPageManager = NULL;
	m_pIBufferPageManager = NULL;
}

CAudioPathComponent::~CAudioPathComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::ReleaseAll

void CAudioPathComponent::ReleaseAll( void )
{
 	CDirectMusicAudioPath *pAudioPath;

	while( !m_lstAudioPaths.IsEmpty() )
	{
		pAudioPath = static_cast<CDirectMusicAudioPath*>( m_lstAudioPaths.RemoveHead() );
		RELEASE( pAudioPath );
	}

	if( m_pIFramework )
	{
		if( m_pIAudioPathPageManager || m_pIEffectPageManager
		||	m_pIMixGroupPageManager || m_pIBufferPageManager )
		{
			IDMUSProdPropSheet *pIPropSheet;
			if(SUCCEEDED(m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void **) &pIPropSheet)))
			{
				pIPropSheet->RemovePageManager(m_pIAudioPathPageManager);
				pIPropSheet->RemovePageManager(m_pIEffectPageManager);
				pIPropSheet->RemovePageManager(m_pIMixGroupPageManager);
				pIPropSheet->RemovePageManager(m_pIBufferPageManager);
				pIPropSheet->Release();
			}
		}
	}

	RELEASE( m_pIToolGraphComponent );
	RELEASE( m_pIAudioPathPageManager );
	RELEASE( m_pIEffectPageManager );
	RELEASE( m_pIMixGroupPageManager );
	RELEASE( m_pIBufferPageManager );
	RELEASE( m_pIFramework );
	RELEASE( m_pIAudioPathDocType8 );
	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIDMusic );
	RELEASE( m_pIConductor );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent IUnknown implementation

HRESULT CAudioPathComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdRIFFExt *)this;
        return S_OK;
    }
	
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CAudioPathComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CAudioPathComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent IDMUSProdComponent::Initialize

HRESULT CAudioPathComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	ASSERT( pIFramework != NULL );
	ASSERT( pbstrErrMsg != NULL );

	if( pbstrErrMsg == NULL )
	{
		return E_POINTER;
	}

	if( pIFramework == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	theApp.m_pAudioPathComponent = this;
//	theApp.m_pAudioPathComponent->AddRef();	intentionally missing

	// Get IConductor interface pointer
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor8, (void**)&m_pIConductor ) ) )
	{
		ReleaseAll();
		RELEASE( pIComponent );
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIComponent );

	// It's ok if we don't find the Toolgraph component, since Xbox doesn't support it
	pIFramework->FindComponent( CLSID_ToolGraphComponent, &m_pIToolGraphComponent );

	// Get the DirectMusic object
	if( FAILED( pIFramework->GetSharedObject( CLSID_DirectMusic, IID_IDirectMusic, (LPVOID*)&m_pIDMusic) ) )
	{
		if( FAILED( CoCreateInstance(CLSID_DirectMusic,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IDirectMusic,
								  (LPVOID*)&m_pIDMusic) ) )
		{
			ReleaseAll();
			::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_DX8, achErrMsg, MID_BUFFER );
			strErrMsg = achErrMsg;
			*pbstrErrMsg = strErrMsg.AllocSysString();
			return E_FAIL;
		}
	}

	// Get IDirectMusicPerformance8 interface pointer
	IUnknown *punkPerformance = NULL;
	if( FAILED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&punkPerformance ) )
	||	FAILED ( punkPerformance->QueryInterface( IID_IDirectMusicPerformance8, (void**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		RELEASE(punkPerformance);
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_DX8, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE(punkPerformance);

	// Add applicable images to the Project Tree control's image list 
	if( FAILED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .aup file 
	CString strExt = _T(".aup");
	BSTR bstrExt = strExt.AllocSysString();
	if( FAILED ( pIFramework->RegisterClipFormatForFile(m_cfAudioPath, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pIAudioPathDocType8 = new CAudioPathDocType;
    if( m_pIAudioPathDocType8 == NULL )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_OUTOFMEMORY;
	}

	m_pIAudioPathDocType8->AddRef();

	if( FAILED ( pIFramework->AddDocType(m_pIAudioPathDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	if(!m_pIAudioPathPageManager)
	{
		CAudioPathPropPageManager *pPageManager;

		pPageManager = new CAudioPathPropPageManager();
		pPageManager->QueryInterface(IID_IDMUSProdPropPageManager, (void **) &m_pIAudioPathPageManager);
		pPageManager->Release();
	}

	if(!m_pIEffectPageManager)
	{
		CEffectPPGMgr *pPageManager;

		pPageManager = new CEffectPPGMgr();
		pPageManager->QueryInterface(IID_IDMUSProdPropPageManager, (void **) &m_pIEffectPageManager);
		pPageManager->Release();
	}

	if(!m_pIMixGroupPageManager)
	{
		CMixGroupPPGMgr *pPageManager;

		pPageManager = new CMixGroupPPGMgr();
		pPageManager->QueryInterface(IID_IDMUSProdPropPageManager, (void **) &m_pIMixGroupPageManager);
		pPageManager->Release();
	}

	if(!m_pIBufferPageManager)
	{
		CBufferPPGMgr *pPageManager;

		pPageManager = new CBufferPPGMgr();
		pPageManager->QueryInterface(IID_IDMUSProdPropPageManager, (void **) &m_pIBufferPageManager);
		pPageManager->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent IDMUSProdComponent::CleanUp

HRESULT CAudioPathComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicAudioPath *pAudioPath;

	while( !m_lstAudioPaths.IsEmpty() )
	{
		pAudioPath = static_cast<CDirectMusicAudioPath*>( m_lstAudioPaths.RemoveHead() );
		RELEASE( pAudioPath );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent IDMUSProdComponent::GetName

HRESULT CAudioPathComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_AUDIOPATH_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::IDMUSProdComponent::AllocReferenceNode

HRESULT CAudioPathComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_AudioPathRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create AudioPathRefNode
	CAudioPathRef* pAudioPathRef = new CAudioPathRef;
	if( pAudioPathRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pAudioPathRef;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent IDMUSProdComponent::OnActivateApp

HRESULT CAudioPathComponent::OnActivateApp( BOOL fActivate )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CAudioPathComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicAudioPath* pAudioPath;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new AudioPath 
	pAudioPath = new CDirectMusicAudioPath;
	if( pAudioPath == NULL )
	{
		return E_OUTOFMEMORY ;
	}
			
	// Create the Undo Manager
	if( pAudioPath->CreateUndoMgr() == FALSE )
	{
		pAudioPath->Release();
		return E_OUTOFMEMORY;
	}

	// Load the AudioPath file
	hr = pAudioPath->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		pAudioPath->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pAudioPath;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::AddNodeImageLists

HRESULT CAudioPathComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 4, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_AUDIOPATH_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_AUDIOPATH_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_AUDIOPATHREF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_AUDIOPATHREF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstImage ) ) )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::RegisterClipboardFormats

BOOL CAudioPathComponent::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfAudioPath = ::RegisterClipboardFormat( CF_AUDIOPATH );
	m_cfAudioPathList = ::RegisterClipboardFormat( CF_AUDIOPATHLIST );
	m_cfGraph = ::RegisterClipboardFormat( CF_GRAPH );

	if( m_cfProducerFile == 0
	||  m_cfAudioPath == 0
	||  m_cfAudioPathList == 0 
	||  m_cfGraph == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::GetAudioPathImageIndex

HRESULT CAudioPathComponent::GetAudioPathImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_AUDIOPATH_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::GetAudioPathRefImageIndex

HRESULT CAudioPathComponent::GetAudioPathRefImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_AUDIOPATHREF_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::AddToAudioPathFileList

void CAudioPathComponent::AddToAudioPathFileList( CDirectMusicAudioPath* pAudioPath )
{
	if( pAudioPath )
	{
		GUID guidAudioPath;
		pAudioPath->GetGUID( &guidAudioPath );

		// Prevent duplicate object GUIDs
		GUID guidAudioPathList;
		POSITION pos = m_lstAudioPaths.GetHeadPosition();
		while( pos )
		{
			CDirectMusicAudioPath* pAudioPathList = m_lstAudioPaths.GetNext( pos );

			pAudioPathList->GetGUID( &guidAudioPathList );
			if( ::IsEqualGUID( guidAudioPathList, guidAudioPath ) )
			{
				::CoCreateGuid( &guidAudioPath );
				pAudioPath->SetGUID( guidAudioPath );
				break;
			}
		}

		// Add to list
		pAudioPath->AddRef();
		m_lstAudioPaths.AddTail( pAudioPath );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathComponent::RemoveFromAudioPathFileList

void CAudioPathComponent::RemoveFromAudioPathFileList( CDirectMusicAudioPath* pAudioPath )
{
	if( pAudioPath )
	{
		// Remove from list
		POSITION pos = m_lstAudioPaths.Find( pAudioPath );
		if( pos )
		{
			m_lstAudioPaths.RemoveAt( pos );
			pAudioPath->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPath.h ===
#ifndef __AUDIOPATH_H__
#define __AUDIOPATH_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// AudioPath.h : header file
//

#include "AudioPathDesignerDLL.h"
#include "AudioPathComponent.h"
#include "AudioPathDocType.h"
#include "AudioPathDesigner.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include "dmusici.h"
#pragma warning( pop )
#include "DllBasePropPageManager.h"
#include "dmusicf.h"

#define DMUSPROD_FOURCC_AUDIOPATH_DESIGN_LIST mmioFOURCC('p','a','p','d')
#define DMUSPROD_FOURCC_AUDIOPATH_UI_CHUNK mmioFOURCC('p','a','u','i')
#define DMUSPROD_FOURCC_PORT_DESIGN_LIST mmioFOURCC('p','d','l','d')
#define DMUSPROD_FOURCC_PORT_DESIGN_MIXGROUP_CHUNK mmioFOURCC('p','d','m','g')
#define DMUSPROD_FOURCC_EFFECT_GUID_CHUNK mmioFOURCC('p','e','g','d')
#define DMUSPROD_FOURCC_BUFFER_DESIGN_GUID_CHUNK mmioFOURCC('p','b','g','d')

class CDirectMusicAudioPath;
class CJazzUndoMan;
class ItemInfo;
class EffectInfo;
struct BufferOptions;
struct BusEffectInfo;
struct PortOptions;
struct ioPortConfig;
struct ioPChannelToBuffer;
struct ioDesignMixGroup;
struct ioDSoundBuffer;
struct ioDSoundEffect;
interface IDMUSProdRIFFStream;

bool ItemAndBufferSupportEffects( const ItemInfo *pItemInfo, const BufferOptions *pBufferOptions );
bool ItemSupportsBuffers( const ItemInfo *pItemInfo );

struct ioAudioPathUI
{
	WORD wSplitterPos;
	WORD wMixGroupWidth;
	WORD wBusWidth;
	WORD wBufferWidth;
	WORD wEffectWidth;
};

//////////////////////////////////////////////////////////////////////
//  CAudioPathPropPageManager

class CAudioPathPropPageManager : public CDllBasePropPageManager 
{
friend class CTabAudioPathAudioPath;
friend class CTabAudioPathInfo;

public:
	CAudioPathPropPageManager();
	virtual ~CAudioPathPropPageManager();

	/*
    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
	*/

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    //HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    //HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	//void RemoveCurrentObject();

	// Member variables
private:
	/*
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	*/
	
	CTabAudioPathAudioPath*			m_pTabAudioPath;
	CTabAudioPathInfo*				m_pTabInfo;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CDirectMusicAudioPath

class CDirectMusicAudioPath : public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject,
							  public IDMUSProdAudioPathInUse, public IDMUSProdNotifySink, public IDMUSProdDMOInfo
{
friend class CAudioPathCtrl;
friend class CAudioPathDlg;
friend class CEffectListDlg;
friend class CTabAudioPathAudioPath;
friend class CTabAudioPathInfo;

public:
    CDirectMusicAudioPath();
	~CDirectMusicAudioPath();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdAudioPathInUse
	HRESULT STDMETHODCALLTYPE UsingAudioPath( IUnknown *punkAudioPath, BOOL fActive );
        
	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData);

	// IDMUSProdDMOInfo
	HRESULT STDMETHODCALLTYPE EnumDMOInfo( DWORD dwIndex, DMUSProdDMOInfo *pDMOInfo );

	//Additional functions
protected:
	CString GetNewMixgroupName( void ) const;
	void	EnumeratePorts( void );
	PortOptions *FindPort( REFGUID rGUIDPort );
	void	GetUniqueEffectInstanceNameIfNecessary( EffectInfo *pEffectInfo );
	HRESULT SaveToConfigObject ( IUnknown *punkAudioPathConfig );
	HRESULT DM_SaveAudioPath( IStream *pIStream );
	HRESULT DM_SaveUIDesign( IDMUSProdRIFFStream *pIRiffStream );
	void	DM_SaveDSBC_Form( IDMUSProdRIFFStream *pRiffStream, ioDSoundBuffer *pioDSoundBuffer, DMUSProdStreamInfo &StreamInfo );
	HRESULT DM_LoadAudioPath( IStream *pIStream );
	HRESULT DM_LoadDesignInfo( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk );
	HRESULT DM_LoadPortConfig( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk, CTypedPtrList< CPtrList, ioPortConfig*> &lstPortConfigs );
	HRESULT DM_LoadBuffer( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk, DMUS_IO_BUFFER_ATTRIBUTES_HEADER &ioBufferHeader, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers );
	ioDSoundEffect *DM_LoadEffect( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk );
	void	DM_CreateItems( CTypedPtrList< CPtrList, ioPortConfig*> &lstPortConfigs, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers );
	PortOptions *CreatePortOptions( const DMUS_IO_PORTCONFIG_HEADER &ioPortConfigHeader, const DMUS_PORTPARAMS8 &ioPortParams, const CString &strPortName );
	void	CreateItemInfos( ioPortConfig *pioPortConfig, PortOptions *pPortOptions, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstUsedDSoundBuffers, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers );
	void	CreateItemFromPChannelToBuffer( ioPChannelToBuffer *pioPChannelToBuffer, PortOptions *pPortOptions, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstUsedDSoundBuffers, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers );
	void	CreateItemFromDesignInfo( ioDesignMixGroup *pioDesignMixGroup, PortOptions *pPortOptions );
	void	CreateItemFromPChannelArray( CDWordArray &adwPChannelsToAdd, PortOptions *pPortOptions );
	void	InsertItemInfo( ItemInfo *pItemInfo );
	ItemInfo *GetItemForPChannel( DWORD dwPChannel );
	HRESULT SaveInfoList( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveVersion( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveGUID( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT AllAudioPaths_InsertToolGraph( void );
	HRESULT AllAudioPaths_RemoveToolGraph( void );
	HRESULT InsertToolGraph( IDirectMusicAudioPath* pIAudioPath );
	HRESULT RemoveToolGraph( IDirectMusicAudioPath* pIAudioPath );
	ItemInfo *CreateStandardItem( REFGUID rGuidBuffer1, REFGUID rGuidBuffer2, DWORD dwBufferFlags );

public:
    HRESULT GetObjectDescriptor( void* pObjectDesc );
	HRESULT CreateEmptyToolGraph();
	BSTR	GetNameForConductor( void );
	void	CopyFrom( CDirectMusicAudioPath *pAudioPath );
	void	CopyFrom( DWORD dwStandardID );
	HRESULT EnumBufferInfo( DWORD dwIndex, WCHAR wcstr[DMUS_MAX_NAME + 1], GUID *pGuid );
	void	ConnectAllSendEffects( void );
	void	UpdateConnectedSendEffects( const ItemInfo *pItem );
	void	DisconnectSendEffects( const ItemInfo *pItem );
	void	UpdateDisplayIndexes( void );

public:
	BOOL	CreateUndoMgr();
	void	SetModified( BOOL fModified );
	void	SyncAudioPathEditor();
	void	SyncAudiopathsInUse( DWORD dwFlags );
	void	UpdateDMOs( BusEffectInfo *pBusEffectInfo );
//	HRESULT UnRegisterWithTransport();
//	HRESULT RegisterWithTransport();
	void	SaveUndoState( bool &fIgnoreChange, const int nStringID, const bool fSetModified = true );
	void	SaveUndoState( const int nStringID, const bool fSetModified = true );
	EffectInfo *LoadEffect( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent );
	EffectInfo *LoadEffect( IStream *pIStream );
	PortOptions *GetDefaultPort( void );
	PortOptions *PastePortOptionsHelper( PortOptions *pPortOptions );

	void GetGUID( GUID* pguidAudioPath );
	void SetGUID( GUID guidAudioPath );

	// Dialog Sizing Functions
	inline WORD GetSplitterPos() const
	{
		return m_wSplitterPos;
	}
	void	SetSplitterPos( WORD pos, bool bMarkAsDirty=true );
	void	GetUniqueEffectInstanceName( EffectInfo *pEffectInfo );
	void	GetUniqueMixGroupName( ItemInfo *pItemInfo );

	bool	IsMixgroupNameUnique( const ItemInfo *pItemInfo, const CString cstrName ) const;
	bool	IsEffectNameUnique( const EffectInfo *pEffectInfo, const CString cstrName ) const;
	bool	IsInSegment( void );

private:
    DWORD				m_dwRef;
	BOOL				m_fModified;

	CJazzUndoMan*		m_pUndoMgr;

	CTypedPtrList< CPtrList, IDirectMusicAudioPath *> m_lstDMAudioPaths;

	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*	    m_pIParentNode;
	IDMUSProdNode*		m_pIToolGraphNode;

	HWND				m_hWndEditor;

public:
	CString				m_strOrigFileName;
	CAudioPathCtrl*		m_pAudioPathCtrl;
	IDMUSProdNode*		m_pINodeBeingDeleted;
	static CLIPFORMAT m_scfPChannel;
	static CLIPFORMAT m_scfEffect;
	static CLIPFORMAT m_scfBuffer;
	CTypedPtrList< CPtrList, ItemInfo *> m_lstItems;
	CTypedPtrList< CPtrList, PortOptions *> m_lstPortOptions;

private:
	WORD				m_wSplitterPos;
	WORD				m_wMixGroupWidth;
	WORD				m_wBusWidth;
	WORD				m_wBufferWidth;
	WORD				m_wEffectWidth;

    // AudioPath info block
public:
    CString				m_strName;
private:
	GUID				m_guidAudioPath;
	DMUS_VERSION        m_vVersion;
    CString				m_strAuthor;
    CString				m_strCopyright;
    CString				m_strSubject;
};

#endif // __AUDIOPATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathCtl.h ===
#if !defined(AFX_AUDIOPATHCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_AUDIOPATHCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// AudioPathCtl.h : Declaration of the CAudioPathCtrl ActiveX Control class.

#include "Splitter.h"

class CAudioPathDlg;
class CEffectListDlg;
class CDirectMusicAudioPath;

typedef enum { FOC_NONE = 0, FOC_MIXGROUP = 1, FOC_EFFECT = 2 } DialogFocus;

/////////////////////////////////////////////////////////////////////////////
// CAudioPathCtrl : See AudioPathCtl.cpp for implementation.

class CAudioPathCtrl : public COleControl
{
	DECLARE_DYNCREATE(CAudioPathCtrl)

// Constructor
public:
	CAudioPathCtrl();

// Attributes
public:
	enum {DefaultSplitterWidth=6, MinSplitterXPos = 300 };
	CAudioPathDlg*	m_pAudioPathDlg;
	CEffectListDlg*	m_pEffectListDlg;
	DialogFocus		m_dlgFocus;
	HWND				m_hWndContainer;

private:
	HMENU				m_hMenuInPlace;
	CDirectMusicAudioPath*	m_pAudioPath;
	CSplitter			m_wndSplitter;
	HACCEL				m_hAcceleratorTable;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAudioPathCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual HMENU OnGetInPlaceMenu();
	//}}AFX_VIRTUAL

// Implementation
public:
	void EndTrack( int nWidth );
	void SetLastFocus(DialogFocus dlgFocus);
	void SwitchToCorrectPropertyPage( void );

protected:
	~CAudioPathCtrl();

	DECLARE_OLECREATE_EX(CAudioPathCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CAudioPathCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CAudioPathCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CAudioPathCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CAudioPathCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditDelete();
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnEditInsert();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditRedo();
	afx_msg void OnHelpFinder();
	afx_msg void OnEditSelectAll();
	afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CAudioPathCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CAudioPathCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CAudioPathCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUDIOPATHCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPath.cpp ===
// AudioPath.cpp : implementation file
//

#include "stdafx.h"
#include "dsoundp.h"
#include "AudioPathDesignerDLL.h"

#include "RiffStrm.h"
#include "AudioPath.h"
#include "SegmentDesigner.h"
#include <mmreg.h>
#include <math.h>
#include <dmusicf.h>
#include "TabAudioPathAudioPath.h"
#include "TabAudioPathInfo.h"
#include "AudioPathCtl.h"
#include "AudioPathDlg.h"
#include "EffectListDlg.h"
#include "ItemInfo.h"
#include "EffectInfo.h"
#include "ToolGraphDesigner.h"
#define _SYS_GUID_OPERATORS_
#include "dmoreg.h"
#include "uuids.h"

// Define the WaveSame DMO GUID so we can strip it out for runtime saves
#include <initguid.h>
// {2D6D1411-DCD7-45e7-ADDE-ACAC85A2425D}
DEFINE_GUID(GUID_DSFX_STANDARD_DUMP, 0x2d6d1411, 0xdcd7, 0x45e7, 0xad, 0xde, 0xac, 0xac, 0x85, 0xa2, 0x42, 0x5d);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Keep around for importing pre-DX8 RC0 files.
static const GUID REMOVED_GUID_Buffer_3D= {0x186cc543, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74};

// {F078ACC0-67AA-11d3-B45D-00105A2796DE}
static const GUID GUID_AudioPathPropPageManager = 
{ 0xf078acc0, 0x67aa, 0x11d3, { 0xb4, 0x5d, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };

struct EnumEffectStruct
{
	GUID	guidEffect;
	DWORD	dwRefCount;
};

short CAudioPathPropPageManager::sm_nActiveTab = 0;

CLIPFORMAT CDirectMusicAudioPath::m_scfEffect = 0;
CLIPFORMAT CDirectMusicAudioPath::m_scfPChannel = 0;
CLIPFORMAT CDirectMusicAudioPath::m_scfBuffer = 0;

extern long GetLongFromStream( IStream *pStream );

// Old fileformat (DX8 beta 1) chunks
struct DX8_BETA1_DSOUND_IO_DSBUFFERDESC
{
	DSBUFFERDESC dsbd;
	WAVEFORMATEX wfx;
    LONG lPan;          /* Initial pan; only used if CTRL_PAN is specified */
	WORD wReserved;
};

struct DX8_BETA1_DSOUND_IO_3D
{
    DS3DBUFFER ds3d;    /* Only used if DSBCAPS_CTRL3D is specified */
};

struct DX8_BETA1_DSOUND_IO_DXDMO_HEADER
{
	DSEFFECTDESC dsfxd;
};

bool ItemAndBufferSupportEffects( const ItemInfo *pItemInfo, const BufferOptions *pBufferOptions )
{
	if( pItemInfo
	&&	pBufferOptions
	&& ItemSupportsBuffers( pItemInfo )
	&&	!(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
	{
		return true;
	}
	return false;
}

bool ItemSupportsBuffers( const ItemInfo *pItemInfo )
{
	if( pItemInfo
	&&	(pItemInfo->nNumPChannels == 0 ||
		 pItemInfo->pPortOptions->m_fAudioPath) )
	{
		return true;
	}
	return false;
}


//////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAudioPathPropPageManager::CAudioPathPropPageManager() : CDllBasePropPageManager()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_GUIDManager	= GUID_AudioPathPropPageManager;

	m_pTabAudioPath = NULL;
	m_pTabInfo = NULL;
}

CAudioPathPropPageManager::~CAudioPathPropPageManager()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pTabAudioPath )
	{
		delete m_pTabAudioPath;
	}

	if( m_pTabInfo )
	{
		delete m_pTabInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CAudioPathPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||	(pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_AUDIOPATH_TEXT );

	CDirectMusicAudioPath *pAudioPath;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pAudioPath))) )
	{
		CString strNodeName;
		BSTR bstrNodeName;

		if( SUCCEEDED ( pAudioPath->GetNodeName( &bstrNodeName ) ) )
		{
			strNodeName = bstrNodeName;
			::SysFreeString( bstrNodeName );
		}
		strTitle = strNodeName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CAudioPathPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||	(pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add AudioPath tab
	if( m_pTabAudioPath == NULL )
	{
		m_pTabAudioPath = new CTabAudioPathAudioPath( this );
	}
	if( m_pTabAudioPath )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabAudioPath->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Info tab
	if( m_pTabInfo == NULL )
	{
		m_pTabInfo = new CTabAudioPathInfo( this );
	}
	if( m_pTabInfo )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabInfo->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CAudioPathPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	if(m_pIPropSheet)
	{
		m_pIPropSheet->GetActivePage( &CAudioPathPropPageManager::sm_nActiveTab );
	}

	HRESULT hr = CBasePropPageManager::OnRemoveFromPropertySheet();

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	RefreshData();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CAudioPathPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CAudioPathPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = CDllBasePropPageManager::RemoveObject(pIPropPageObject);
	if(SUCCEEDED(hr))
	{
		RefreshData();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CAudioPathPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pTabAudioPath == NULL)
	{
		return S_OK;
	}

	CDirectMusicAudioPath* pAudioPath;
	
	if( m_pIPropPageObject == NULL )
	{
		pAudioPath = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pAudioPath ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current AudioPath are processed in OnKillFocus
	// messages before setting the new AudioPath
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabAudioPath->GetSafeHwnd() ? m_pTabAudioPath->GetParent() : NULL;

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new AudioPath
	m_pTabAudioPath->SetAudioPath( pAudioPath);
	m_pTabInfo->SetAudioPath( pAudioPath);

	// Restore focus
	if( pWndHadFocus
	&&	pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath constructor/destructor

CDirectMusicAudioPath::CDirectMusicAudioPath()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );

	// AudioPath needs AudioPath Component
	theApp.m_pAudioPathComponent->AddRef();

	m_dwRef = 0;
	AddRef();

	m_pUndoMgr = NULL;
	m_fModified = FALSE;

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pIToolGraphNode = NULL;

	m_hWndEditor = NULL;
	m_pAudioPathCtrl = NULL;
	m_pINodeBeingDeleted = NULL;

	m_wSplitterPos = 0;
	m_wMixGroupWidth = 0;
	m_wBusWidth = 0;
	m_wBufferWidth = 0;
	m_wEffectWidth = 0;

// AudioPath info block
	TCHAR achName[SMALL_BUFFER];
	::LoadString( theApp.m_hInstance, IDS_AUDIOPATH_TEXT, achName, SMALL_BUFFER );
	m_strName.Format( "%s%d", achName, ++theApp.m_pAudioPathComponent->m_nNextAudioPath );

	CoCreateGuid( &m_guidAudioPath ); 
	m_vVersion.dwVersionMS = 0x00010000;
	m_vVersion.dwVersionLS = 0x00000000;

	CDirectMusicAudioPath::m_scfPChannel = static_cast<CLIPFORMAT>(::RegisterClipboardFormat( CF_AUDIOPATH_PCHANNEL ));
	CDirectMusicAudioPath::m_scfEffect = static_cast<CLIPFORMAT>(::RegisterClipboardFormat( CF_AUDIOPATH_EFFECT ));
	CDirectMusicAudioPath::m_scfBuffer = static_cast<CLIPFORMAT>(::RegisterClipboardFormat( CF_AUDIOPATH_BUFFER ));

	EnumeratePorts();
}

CDirectMusicAudioPath::~CDirectMusicAudioPath()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	// Clear out m_lstItems
	while( !m_lstItems.IsEmpty() )
	{
		delete m_lstItems.RemoveHead();
	}

	// Clear out m_lstPortOptions
	while( !m_lstPortOptions.IsEmpty() )
	{
		delete m_lstPortOptions.RemoveHead();
	}

	// Remove AudioPath from clipboard
	theApp.FlushClipboard( this );

	// Remove AudioPath from property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		if(theApp.m_pAudioPathComponent->m_pIAudioPathPageManager)
		{
			theApp.m_pAudioPathComponent->m_pIAudioPathPageManager->RemoveObject(this);
		}
		RELEASE( pIPropSheet );
	}

	if ( m_pIToolGraphNode )
	{
		m_pIToolGraphNode->Release();
		m_pIToolGraphNode = NULL;
	}

	// Cleanup the Undo Manager
	if( m_pUndoMgr )
	{
		delete m_pUndoMgr;
	}

	// Cleanup DirectMusic references
	while( !m_lstDMAudioPaths.IsEmpty() )
	{
		m_lstDMAudioPaths.RemoveHead()->Release();
	}

	// AudioPath no longer needs AudioPath Component
	theApp.m_pAudioPathComponent->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreateUndoMgr

BOOL CDirectMusicAudioPath::CreateUndoMgr()
{
	// Should only be called once - after AudioPath first created
	ASSERT( m_pUndoMgr == NULL );

	ASSERT( theApp.m_pAudioPathComponent != NULL ); 
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL ); 

	m_pUndoMgr = new CJazzUndoMan( theApp.m_pAudioPathComponent->m_pIFramework );
	if( m_pUndoMgr )
	{
		m_pUndoMgr->SetStreamAttributes( FT_DESIGN, GUID_CurrentVersion );
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreateEmptyToolGraph

HRESULT CDirectMusicAudioPath::CreateEmptyToolGraph( void )
{
	IDMUSProdNode* pIToolGraphNode;
	IDMUSProdDocType* pIDocType;

	ASSERT( theApp.m_pAudioPathComponent != NULL ); 
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL ); 

	// Do not call if Segment already has a tool graph!
	ASSERT( m_pIToolGraphNode == NULL );
	if( m_pIToolGraphNode )
	{
		return S_OK;
	}

	// Create the tool graph
	HRESULT hr = theApp.m_pAudioPathComponent->m_pIFramework->FindDocTypeByNodeId( GUID_ToolGraphNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_ToolGraphNode, &pIToolGraphNode );
		if( SUCCEEDED ( hr ) )
		{
			// Set name
			CString strName;
			strName.LoadString( IDS_TOOLGRAPH_TEXT );
			BSTR bstrName = strName.AllocSysString();
			pIToolGraphNode->SetNodeName( bstrName );

			InsertChildNode( pIToolGraphNode );
			pIToolGraphNode->Release();
		}

		RELEASE( pIDocType );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::IsInSegment

bool CDirectMusicAudioPath::IsInSegment( void )
{
	bool fInSegment = false;

	if( m_pIParentNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( m_pIParentNode->GetNodeId( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_SegmentNode ) )
			{
				fInSegment = true;
			}
		}
	}

	return fInSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SyncAudioPathEditor

void CDirectMusicAudioPath::SyncAudioPathEditor( void )
{
	if( m_pAudioPathCtrl )
	{
		if( m_pAudioPathCtrl->m_pAudioPathDlg )
		{
			m_pAudioPathCtrl->m_pAudioPathDlg->RefreshControls();
		}
		/* No need - effect list only contains the registered effects
		if( m_pAudioPathCtrl->m_pEffectListDlg )
		{
			m_pAudioPathCtrl->m_pEffectListDlg->RefreshControls();
		}
		*/
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SyncAudiopathsInUse

void CDirectMusicAudioPath::SyncAudiopathsInUse( DWORD dwFlags )
{
	// Notify connected nodes that AudioPath has changed
	theApp.m_pAudioPathComponent->m_pIFramework->NotifyNodes( this, AUDIOPATH_NeedToRebuildNotification, &dwFlags );
}


////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::UpdateDMOs

void CDirectMusicAudioPath::UpdateDMOs( BusEffectInfo *pBusEffectInfo )
{
	if( m_lstDMAudioPaths.IsEmpty() )
	{
		return;
	}

	if( !pBusEffectInfo
	||	!pBusEffectInfo->m_EffectInfo.m_pIStream )
	{
		return;
	}

	IStream *pIStream;
	if( FAILED( pBusEffectInfo->m_EffectInfo.m_pIStream->Clone( &pIStream ) ) )
	{
		return;
	}

	// Keep a count of the number of MixIn buffers we've seen
	DWORD dwMixInBufferIndex = 0;

	// Iterate through the list of items
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pItemInfo = m_lstItems.GetNext( posItem );

		// If the port doesn't support buffers, skip it
		if( !ItemSupportsBuffers( pItemInfo ) )
		{
			continue;
		}

		// Keep a count of the number of normal buffers we've seen
		DWORD dwBufferIndex = 0;

		// Iterate through the list of buffers
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Keep a count of the number of effects we've seen
			DWORD dwEffectIndex = 0;

			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			// Iterate through the list of effects
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();

			// If the buffer does not support effects, don't check any of the effects in the buffer
			if( !ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
			{
				posEffect = NULL;
			}

			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfoInList = pBufferOptions->lstEffects.GetNext( posEffect );

				// Check if this is the effect we're looking for
				if( pBusEffectInfoInList == pBusEffectInfo )
				{
					// Found an effect to update

					// Iterate through the audio paths
					POSITION posAudioPath = m_lstDMAudioPaths.GetHeadPosition();
					while( posAudioPath )
					{
						DWORD dwPChannel, dwPathLocation, dwBufNum;
						if( pItemInfo->nNumPChannels > 0 )
						{
							dwPChannel = pItemInfo->adwPChannels[0];
							dwPathLocation = DMUS_PATH_BUFFER_DMO;
							dwBufNum = dwBufferIndex;
						}
						else
						{
							dwPChannel = 0;
							dwPathLocation = DMUS_PATH_MIXIN_BUFFER_DMO;
							dwBufNum = dwMixInBufferIndex;
						}

						if( GUID_DSFX_SEND == pBusEffectInfo->m_EffectInfo.m_clsidObject )
						{
							IDirectSoundFXSend *pIDirectSoundFXSend;
							if( SUCCEEDED( m_lstDMAudioPaths.GetNext( posAudioPath )->GetObjectInPath( dwPChannel,
								dwPathLocation, dwBufNum, GUID_All_Objects, dwEffectIndex,
								IID_IDirectSoundFXSend, (void **)&pIDirectSoundFXSend ) ) )
							{
								DSFXSend dsfxSend;
								dsfxSend.lSendLevel = GetLongFromStream( pBusEffectInfo->m_EffectInfo.m_pIStream );
								pIDirectSoundFXSend->SetAllParameters( &dsfxSend );
								pIDirectSoundFXSend->Release();
							}
						}
						else
						{
							IPersistStream *pIPersistStream;
							if( SUCCEEDED( m_lstDMAudioPaths.GetNext( posAudioPath )->GetObjectInPath( dwPChannel,
								dwPathLocation, dwBufNum, GUID_All_Objects, dwEffectIndex,
								IID_IPersistStream, (void **)&pIPersistStream ) ) )
							{
								StreamSeek( pIStream, 0, STREAM_SEEK_SET );
								pIPersistStream->Load( pIStream );
								pIPersistStream->Release();
							}
						}
					}
				}

				// Increment the effect index
				dwEffectIndex++;
			}

			// Increment the buffer index
			dwBufferIndex++;
		}

		if( pItemInfo->nNumPChannels == 0 )
		{
			dwMixInBufferIndex++;
		}
	}

	pIStream->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SetModified

void CDirectMusicAudioPath::SetModified( BOOL fModified )
{
	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IUnknown implementation

HRESULT CDirectMusicAudioPath::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||	::IsEqualIID(riid, IID_IUnknown) )
	{
		*ppvObj = (IDMUSProdNode *)this;
	}
	else if( ::IsEqualIID(riid, IID_IPersist) )
	{
		*ppvObj = (IPersist *)this;
	}
	else if( ::IsEqualIID(riid, IID_IPersistStream) )
	{
		*ppvObj = (IPersistStream *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
	{
		*ppvObj = (IDMUSProdPropPageObject *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdAudioPathInUse) )
	{
		*ppvObj = (IDMUSProdAudioPathInUse *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink) )
	{
		*ppvObj = (IDMUSProdNotifySink *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdDMOInfo) )
	{
		*ppvObj = (IDMUSProdDMOInfo *)this;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDirectMusicAudioPath::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
	return ++m_dwRef;
}

ULONG CDirectMusicAudioPath::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
	--m_dwRef;

	if( m_dwRef == 0 )
	{
		delete this;
		return 0;
	}

	return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectMusicAudioPath::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );

	return( theApp.m_pAudioPathComponent->GetAudioPathImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetFirstChild

HRESULT CDirectMusicAudioPath::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}

	if( m_pIToolGraphNode )
	{
		*ppIFirstChildNode = m_pIToolGraphNode;
		(*ppIFirstChildNode)->AddRef();
	}
	else
	{
		*ppIFirstChildNode = NULL;
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetNextChild

HRESULT CDirectMusicAudioPath::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	*ppINextChildNode = NULL;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetComponent

HRESULT CDirectMusicAudioPath::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );

	return theApp.m_pAudioPathComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetDocRootNode

HRESULT CDirectMusicAudioPath::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::SetDocRootNode

HRESULT CDirectMusicAudioPath::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetParentNode

HRESULT CDirectMusicAudioPath::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::SetParentNode

HRESULT CDirectMusicAudioPath::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetNodeId

HRESULT CDirectMusicAudioPath::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_AudioPathNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetNodeName

HRESULT CDirectMusicAudioPath::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectMusicAudioPath::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::ValidateNodeName

HRESULT CDirectMusicAudioPath::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	::SysFreeString( bstrName );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::SetNodeName

HRESULT CDirectMusicAudioPath::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_strName == strName )
	{
		return S_OK;
	}

	if( !IsInSegment() )
	{
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_AUDIOPATH_NAME );
	}

	m_strName = strName;

	// Sync change with property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		RELEASE( pIPropSheet );
	}

	if( !IsInSegment() )
	{
		SetModified( TRUE );
	}

	// Notify connected nodes that AudioPath name has changed
	theApp.m_pAudioPathComponent->m_pIFramework->NotifyNodes( this, AUDIOPATH_NameChange, NULL );

	// Notify Conductor that the Audiopath name has changed
	theApp.m_pAudioPathComponent->m_pIConductor->SetAudiopathName( this, GetNameForConductor() );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetNodeListInfo

HRESULT CDirectMusicAudioPath::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strDescriptor;

	pListInfo->bstrName = m_strName.AllocSysString();
	pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidAudioPath, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetEditorClsId

HRESULT CDirectMusicAudioPath::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

   *pClsId = CLSID_AudioPathEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetEditorTitle

HRESULT CDirectMusicAudioPath::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;

	strTitle.LoadString( IDS_AUDIOPATH_TEXT );
	strTitle += _T(": " );
	strTitle += m_strName;

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetEditorWindow

HRESULT CDirectMusicAudioPath::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::SetEditorWindow

HRESULT CDirectMusicAudioPath::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectMusicAudioPath::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectMusicAudioPath::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;

	if(	IsInSegment() )
	{
		*pnMenuId = IDM_AUDIOPATH_NODE_RMENU;
	}
	else
	{
		*pnMenuId = IDM_AUDIOPATH_DOCROOT_RMENU;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectMusicAudioPath::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( IsInSegment() )
	{
		// IDM_CUT
		if( CanCut() == S_OK )
		{
			::EnableMenuItem( hMenu, IDM_CUT, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			::EnableMenuItem( hMenu, IDM_CUT, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_COPY
		if( CanCopy() == S_OK )
		{
			::EnableMenuItem( hMenu, IDM_COPY, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			::EnableMenuItem( hMenu, IDM_COPY, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			::EnableMenuItem( hMenu, IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					::EnableMenuItem( hMenu, IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_DELETE
		if( CanDelete() == S_OK )
		{
			::EnableMenuItem( hMenu, IDM_DELETE, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			::EnableMenuItem( hMenu, IDM_DELETE, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_RENAME
		::EnableMenuItem( hMenu, IDM_RENAME, (MF_GRAYED | MF_BYCOMMAND) );
	}
	else
	{
		::EnableMenuItem( hMenu, IDM_RENAME, (MF_ENABLED | MF_BYCOMMAND) );
	}

	// IDM_NEW_TOOLGRAPH
#ifndef DMP_XBOX
	::EnableMenuItem( hMenu, IDM_NEW_TOOLGRAPH, m_pIToolGraphNode ? (MF_GRAYED | MF_BYCOMMAND) : (MF_ENABLED | MF_BYCOMMAND) );
#else
	::EnableMenuItem( hMenu, IDM_NEW_TOOLGRAPH, MF_GRAYED | MF_BYCOMMAND );
#endif

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectMusicAudioPath::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_CUT:
			if( CanCut() == S_OK )
			{
				IDataObject* pIDataObject;
				if( SUCCEEDED ( CreateDataObject( &pIDataObject ) ) )
				{
					if( theApp.PutDataInClipboard( pIDataObject, this ) )
					{
						DeleteNode( FALSE );
					}
					
					pIDataObject->Release();
					pIDataObject = NULL;
				}
			}
			break;

		case IDM_COPY:
			if( CanCopy() == S_OK )
			{
				IDataObject* pIDataObject;
				if( SUCCEEDED ( CreateDataObject( &pIDataObject ) ) )
				{
					theApp.PutDataInClipboard( pIDataObject, this );
					
					pIDataObject->Release();
					pIDataObject = NULL;
				}
			}
			break;

		case IDM_PASTE:
		{
			BOOL fWillSetReference;
			IDataObject* pIDataObject;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				pIDataObject->Release();
				pIDataObject = NULL;
			}
			break;
		}

		case IDM_DELETE:
			DeleteNode( TRUE );
			break;

		case IDM_NEW_TOOLGRAPH:
			hr = CreateEmptyToolGraph();
			if( m_pIToolGraphNode )
			{
				theApp.m_pAudioPathComponent->m_pIFramework->OpenEditor( m_pIToolGraphNode );
			}
			break;

		case IDM_RENAME:
			if( IsInSegment() == FALSE )
			{
				hr = theApp.m_pAudioPathComponent->m_pIFramework->EditNodeLabel( this );
			}
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::DeleteChildNode

HRESULT CDirectMusicAudioPath::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	CWaitCursor wait;

	if( pIChildNode == NULL 
	||  pIChildNode != m_pIToolGraphNode )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pAudioPathComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Remove from AudioPath
	if( pIChildNode == m_pIToolGraphNode )
	{
		AllAudioPaths_RemoveToolGraph();
		RELEASE( m_pIToolGraphNode );
	}

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::InsertChildNode

HRESULT CDirectMusicAudioPath::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	pIChildNode->AddRef();

	// AudioPaths can only have one Tool Graph
	GUID guidNode;
	if( FAILED( pIChildNode->GetNodeId( &guidNode ) ) )
	{
		return E_INVALIDARG;
	}

	if( guidNode == GUID_ToolGraphNode )
	{
		if( m_pIToolGraphNode )
		{
			DeleteChildNode( m_pIToolGraphNode, FALSE );
		}

		// Set the AudioPath's Tool Graph
		ASSERT( m_pIToolGraphNode == NULL );
		m_pIToolGraphNode = pIChildNode;
		AllAudioPaths_InsertToolGraph();

		// Set root and parent node of ALL children
		theApp.SetNodePointers( m_pIToolGraphNode, m_pIDocRootNode, (IDMUSProdNode *)this );

		// Add node to Project Tree
		if( !SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->AddNode(m_pIToolGraphNode, (IDMUSProdNode *)this) ) )
		{
			DeleteChildNode( m_pIToolGraphNode, FALSE );
			return E_FAIL;
		}
	}
	else
	{
		return E_INVALIDARG;
	}

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::DeleteNode

HRESULT CDirectMusicAudioPath::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIParentNode;

	// Let our parent delete us
    if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
			return hr;
		}
	}

	CWaitCursor wait;

	// No parent so we will delete ourself
	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	// Remove from Project Tree
	if( theApp.m_pAudioPathComponent->m_pIFramework->RemoveNode( this, fPromptUser ) == S_FALSE )
	{
		// User cancelled delete
		return E_FAIL;
	}

	// Release the AudioPath's ToolGraph
	RELEASE( m_pIToolGraphNode );

	// Remove from Component AudioPath list
	theApp.m_pAudioPathComponent->RemoveFromAudioPathFileList( this );

	// Remove from the Conductor's dropdown list
	theApp.m_pAudioPathComponent->m_pIConductor->UnRegisterAudiopath( this );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectMusicAudioPath::OnNodeSelChanged( BOOL fSelected )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::CreateDataObject

HRESULT CDirectMusicAudioPath::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save AudioPath into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_AUDIOPATH into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pAudioPathComponent->m_cfAudioPath, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->SaveClipFormat( theApp.m_pAudioPathComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// AudioPath nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pAudioPathComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::CanCut

HRESULT CDirectMusicAudioPath::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::CanCopy

HRESULT CDirectMusicAudioPath::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::CanDelete

HRESULT CDirectMusicAudioPath::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			return m_pIParentNode->CanDeleteChildNode( this );
		}
		else
		{
			return S_FALSE;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectMusicAudioPath::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIChildNode == NULL )
	{
		return E_POINTER;
	}

	if( pIChildNode == m_pIToolGraphNode )
	{
		return S_OK;
	}

	return S_FALSE;	
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::CanPasteFromData

HRESULT CDirectMusicAudioPath::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	if( pDataObject->IsClipFormatAvailable(pIDataObject, theApp.m_pAudioPathComponent->m_cfGraph) == S_OK )
	{
		RELEASE( pDataObject );
		return S_OK;
	}
	RELEASE( pDataObject );

	// Delegate to parent
	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			// Let Segment, for example, decide what can be dropped
			return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
		}
	}
	
	return S_FALSE; 	// Can't paste anything on a AudioPath node in the project tree
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::PasteFromData

HRESULT CDirectMusicAudioPath::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pAudioPathComponent->m_cfGraph ) ) )
	{
		// Handle CF_GRAPH 
		hr = PasteCF_GRAPH( pDataObject, pIDataObject );
	}
	RELEASE( pDataObject );
	if( hr == S_OK )
	{
		return hr;
	}

	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			// Let Segment, for example, handle paste
			return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
		}
	}

	return E_FAIL;	
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectMusicAudioPath::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												  BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;
	pIChildNode->GetNodeId( &guidNodeId );

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pAudioPathComponent->m_cfGraph ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_ToolGraphNode ) )
		{
			hr = S_OK;
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::ChildPasteFromData

HRESULT CDirectMusicAudioPath::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pAudioPathComponent->m_cfGraph ) ) )
	{
		// Handle CF_GRAPH format
		hr = PasteCF_GRAPH( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNode::GetObject

HRESULT CDirectMusicAudioPath::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DirectMusicAudioPathConfig object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicAudioPathConfig ) )
	{
		// Create an CLSID_DirectMusicAudioPathConfig object
		IUnknown *pSourceConfig;
		HRESULT hr = ::CoCreateInstance( CLSID_DirectMusicAudioPathConfig, NULL, CLSCTX_INPROC_SERVER,
								 IID_IUnknown, (void**)&pSourceConfig );
		if( SUCCEEDED( hr ) )
		{
			// Persist ourself into the config object
			hr = SaveToConfigObject( pSourceConfig );
			if( SUCCEEDED( hr ) )
			{
				// Finally, query the config object for the requested interface
				hr = pSourceConfig->QueryInterface( riid, ppvObject );
			}
			pSourceConfig->Release();
		}
		return hr;
	}
	else if( ::IsEqualCLSID( rclsid, GUID_ToolGraphNode ) )
	{
		if( m_pIToolGraphNode )
		{
			return m_pIToolGraphNode->QueryInterface( riid, ppvObject );
		}
	}

	*ppvObject = NULL;
	return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdPropPageObject::GetData

HRESULT CDirectMusicAudioPath::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdPropPageObject::SetData

HRESULT CDirectMusicAudioPath::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdPropPageObject::OnShowProperties

HRESULT CDirectMusicAudioPath::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	// Show the AudioPath properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CAudioPathPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIAudioPathPageManager) ) )
		{
			theApp.m_pAudioPathComponent->m_pIAudioPathPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CDirectMusicAudioPath::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdAudioPathInUse implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdAudioPathInUse::UsingAudioPath

HRESULT CDirectMusicAudioPath::UsingAudioPath( IUnknown *punkAudioPath, BOOL fActive )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( punkAudioPath == NULL )
	{
		return E_POINTER;
	}

	IDirectMusicAudioPath *pDMAudioPath;
	if( FAILED( punkAudioPath->QueryInterface( IID_IDirectMusicAudioPath, (void **)&pDMAudioPath ) ) )
	{
		return E_INVALIDARG;
	}

	if( !fActive )
	{
		POSITION pos = m_lstDMAudioPaths.GetHeadPosition();
		while( pos )
		{
			POSITION posCurrent = pos;
			if( pDMAudioPath == m_lstDMAudioPaths.GetNext( pos ) )
			{
				// Remove the toolgraph
				RemoveToolGraph( pDMAudioPath );

				m_lstDMAudioPaths.RemoveAt( posCurrent );
				pDMAudioPath->Release(); // For the item in the list
				pDMAudioPath->Release(); // For the QueryInterface above
				return S_OK;
			}
		}

		// Didn't find the audio path
		pDMAudioPath->Release(); // For the QueryInterface above
		return E_INVALIDARG;
	}
	else
	{
		// Add the toolgraph
		InsertToolGraph( pDMAudioPath );

		// Just add the audio path to the end of the list
		m_lstDMAudioPaths.AddTail( pDMAudioPath );
		return S_OK;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdNotifySink implementation

///////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath :: OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData)

HRESULT CDirectMusicAudioPath::OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	if( pIDocRootNode == m_pIToolGraphNode )
	{
		// TOOLGRAPH_ChangeNotification
		if( ::IsEqualGUID(guidUpdateType, TOOLGRAPH_ChangeNotification ) )
		{
			SetModified( TRUE );
			return S_OK;
		}
	}
	else if( pIDocRootNode == this )
	{
		if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileNameChange)
		||	::IsEqualGUID(guidUpdateType, FRAMEWORK_AfterFileSave) )
		{
			// Notify Conductor that the Audiopath name has changed
			theApp.m_pAudioPathComponent->m_pIConductor->SetAudiopathName( this, GetNameForConductor() );
			return S_OK;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IDMUSProdDMOInfo implementation

// Helper function for CDirectMusicAudioPath :: EnumDMOInfo
void GetDMOName( CLSID clsidDMO, WCHAR *wcstrName )
{
	IEnumDMO *pEnumDMO;

	DMO_PARTIAL_MEDIATYPE dmoPMT;
	dmoPMT.type = MEDIATYPE_Audio;
	dmoPMT.subtype = MEDIASUBTYPE_PCM;

	if( SUCCEEDED( DMOEnum( DMOCATEGORY_AUDIO_EFFECT, 0, 1, &dmoPMT, 1, &dmoPMT, &pEnumDMO ) ) )
	{
		pEnumDMO->Reset();
		CLSID clsidItem;
		WCHAR *pwcName;
		DWORD dwItemsFetched;
		while( S_OK == pEnumDMO->Next( 1, &clsidItem, &pwcName, &dwItemsFetched ) )
		{
			if( clsidItem == clsidDMO )
			{
				wcsncpy( wcstrName, pwcName, 64 );
				::CoTaskMemFree( pwcName );
				break;
			}

			::CoTaskMemFree( pwcName );
		}
		pEnumDMO->Release();
	}
}

DWORD AddRefEffectToList( REFGUID rguidEffect, CTypedPtrList< CPtrList, EnumEffectStruct *> &lstEffectStruct )
{
	POSITION pos = lstEffectStruct.GetHeadPosition();
	while( pos )
	{
		EnumEffectStruct *pEnumEffectStruct = lstEffectStruct.GetNext( pos );
		if( pEnumEffectStruct->guidEffect == rguidEffect )
		{
			pEnumEffectStruct->dwRefCount++;
			return pEnumEffectStruct->dwRefCount;
		}
	}

	EnumEffectStruct *pEnumEffectStruct = new EnumEffectStruct;
	pEnumEffectStruct->guidEffect = rguidEffect;
	pEnumEffectStruct->dwRefCount = 0;
	lstEffectStruct.AddHead( pEnumEffectStruct );
	return 0;
}

void CleanupEffectList( CTypedPtrList< CPtrList, EnumEffectStruct *> &lstEffectStruct )
{
	while( !lstEffectStruct.IsEmpty() )
	{
		delete lstEffectStruct.RemoveHead();
	}
}

///////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath :: EnumDMOInfo

HRESULT CDirectMusicAudioPath::EnumDMOInfo( DWORD dwIndex, DMUSProdDMOInfo *pDMOInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate arguments
	if( pDMOInfo == NULL
	||	pDMOInfo->dwSize != sizeof( DMUSProdDMOInfo ) )
	{
		return E_POINTER;
	}

	ZeroMemory( pDMOInfo->awchPChannelText, sizeof(WCHAR) * 65 );
	ZeroMemory( pDMOInfo->awchMixGroupName, sizeof(WCHAR) * 65 );
	ZeroMemory( pDMOInfo->awchBufferText, sizeof(WCHAR) * 65 );
	ZeroMemory( pDMOInfo->awchDMOName, sizeof(WCHAR) * 65 );
	ZeroMemory( &pDMOInfo->guidDesignGUID, sizeof(GUID) );

	// Keep a count of the number of MixIn buffers we've seen
	DWORD dwMixInBufferIndex = 0;

	// Iterate through all items
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Keep a count of the number of normal buffers we've seen
		DWORD dwBufferIndex = 0;

		// Get a pointer to each item
		ItemInfo *pItem = m_lstItems.GetNext( posItem );

		// If the port doesn't support buffers, skip it
		if( !ItemSupportsBuffers( pItem ) )
		{
			continue;
		}

		// Iterate through all buffers
		POSITION posBuffer = pItem->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Keep a count of the number of effects we've seen
			CTypedPtrList< CPtrList, EnumEffectStruct * > lstEffectStruct;

			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItem->lstBuffers.GetNext( posBuffer );

			// Iterate through all effects
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();

			// If the buffer does not support effects, don't check any of the effects in the buffer
			if( !ItemAndBufferSupportEffects( pItem, pBufferOptions ) )
			{
				posEffect = NULL;
			}

			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );

				// Check if this is the effect to return
				if( dwIndex == 0 )
				{
					// Yes - copy the CLSID and design-time GUID
					pDMOInfo->clsidDMO = pBusEffectInfo->m_EffectInfo.m_clsidObject;
					pDMOInfo->guidDesignGUID = pBusEffectInfo->m_guidEffectInfo;

					// Copy the mix group name and effect instance name
					if( 0 == MultiByteToWideChar( CP_ACP, 0, pItem->strBandName, -1, pDMOInfo->awchMixGroupName, 65 ) )
					{
						CleanupEffectList( lstEffectStruct );
						return E_FAIL;
					}
					if( 0 == MultiByteToWideChar( CP_ACP, 0, pBusEffectInfo->m_EffectInfo.m_strInstanceName, -1, pDMOInfo->awchDMOName, 65 ) )
					{
						CleanupEffectList( lstEffectStruct );
						return E_FAIL;
					}

					// Copy the approprate information, depending on if this is a MixIn buffer or not
					if( pItem->nNumPChannels == 0 )
					{
						pDMOInfo->dwStage = DMUS_PATH_MIXIN_BUFFER_DMO;
						pDMOInfo->dwBufferIndex = dwMixInBufferIndex;
						pDMOInfo->dwPChannel = 0;
						pDMOInfo->awchPChannelText[0] = NULL;
						pDMOInfo->awchBufferText[0] = NULL;
					}
					else
					{
						pDMOInfo->dwStage = DMUS_PATH_BUFFER_DMO;
						pDMOInfo->dwBufferIndex = dwBufferIndex;
						pDMOInfo->dwPChannel = pItem->adwPChannels[0];
						CString strText;
						PChannelArrayToString( pItem->adwPChannels, pItem->nNumPChannels, strText );
						strText = strText.Left( 64 );
						if( 0 == MultiByteToWideChar( CP_ACP, 0, strText, -1, pDMOInfo->awchPChannelText, 65 ) )
						{
							CleanupEffectList( lstEffectStruct );
							return E_FAIL;
						}
						BusListToString( pItem, pBufferOptions , strText );
						if( 0 == MultiByteToWideChar( CP_ACP, 0, strText, -1, pDMOInfo->awchBufferText, 65 ) )
						{
							CleanupEffectList( lstEffectStruct );
							return E_FAIL;
						}

					}
					pDMOInfo->dwEffectIndex = AddRefEffectToList( pDMOInfo->clsidDMO, lstEffectStruct );
					CleanupEffectList( lstEffectStruct );
					return S_OK;
				}
				else
				{
					dwIndex--;

					AddRefEffectToList( pBusEffectInfo->m_EffectInfo.m_clsidObject, lstEffectStruct );
				}
			}

			CleanupEffectList( lstEffectStruct );

			if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
			{
				/*
				if( pBufferOptions->guidBuffer == GUID_Buffer_3D )
				{
					if( dwIndex == 0 )
					{
						// Yes - copy the CLSID
						pDMOInfo->clsidDMO = GUID_DSFX_STANDARD_I3DL2SOURCE;

						// Set the design-time GUID
						pDMOInfo->guidDesignGUID = pBufferOptions->guidDesignEffectGUID;

						// This must not be a MixIn buffer
						ASSERT( pItem->nNumPChannels != 0 );

						pDMOInfo->dwStage = DMUS_PATH_BUFFER_DMO;
						pDMOInfo->dwBufferIndex = dwBufferIndex;
						pDMOInfo->dwPChannel = pItem->adwPChannels[0];

						CString strText;
						PChannelArrayToString( pItem->adwPChannels, pItem->nNumPChannels, strText );
						strText = strText.Left( 64 );
						if( 0 == MultiByteToWideChar( CP_ACP, 0, strText, -1, pDMOInfo->awchPChannelText, 65 ) )
						{
							return E_FAIL;
						}

						BusListToString( pItem, pBufferOptions , strText );
						if( 0 == MultiByteToWideChar( CP_ACP, 0, strText, -1, pDMOInfo->awchBufferText, 65 ) )
						{
							return E_FAIL;
						}

						if( 0 == MultiByteToWideChar( CP_ACP, 0, pItem->strBandName, -1, pDMOInfo->awchMixGroupName, 65 ) )
						{
							return E_FAIL;
						}
						GetDMOName( GUID_DSFX_STANDARD_I3DL2SOURCE, pDMOInfo->awchDMOName );
						pDMOInfo->dwEffectIndex = 0;
						return S_OK;
					}
					else
					{
						dwIndex--;
					}
				}
				else*/ if( pBufferOptions->guidBuffer == GUID_Buffer_EnvReverb )
				{
					if( dwIndex == 0 )
					{
						// Yes - copy the CLSID
						pDMOInfo->clsidDMO = GUID_DSFX_STANDARD_I3DL2REVERB;

						// Set the design-time GUID
						pDMOInfo->guidDesignGUID = GUID_DSFX_STANDARD_I3DL2REVERB;

						// This must be a MixIn buffer
						ASSERT( pItem->nNumPChannels == 0 );
						pDMOInfo->dwStage = DMUS_PATH_MIXIN_BUFFER_DMO;
						pDMOInfo->dwBufferIndex = dwMixInBufferIndex;
						pDMOInfo->dwPChannel = 0;
						pDMOInfo->awchPChannelText[0] = NULL;
						pDMOInfo->awchBufferText[0] = NULL;

						if( 0 == MultiByteToWideChar( CP_ACP, 0, pItem->strBandName, -1, pDMOInfo->awchMixGroupName, 65 ) )
						{
							return E_FAIL;
						}

						GetDMOName( GUID_DSFX_STANDARD_I3DL2REVERB, pDMOInfo->awchDMOName );
						pDMOInfo->dwEffectIndex = 0;
						return S_OK;
					}
					else
					{
						dwIndex--;
					}
				}
				else if( pBufferOptions->guidBuffer == GUID_Buffer_Reverb )
				{
					if( dwIndex == 0 )
					{
						// Yes - copy the CLSID
						pDMOInfo->clsidDMO = GUID_DSFX_WAVES_REVERB;

						// Set the design-time GUID
						pDMOInfo->guidDesignGUID = pBufferOptions->guidDesignEffectGUID;

						// This must not be a MixIn buffer
						ASSERT( pItem->nNumPChannels != 0 );

						pDMOInfo->dwStage = DMUS_PATH_BUFFER_DMO;
						pDMOInfo->dwBufferIndex = dwBufferIndex;
						pDMOInfo->dwPChannel = pItem->adwPChannels[0];

						CString strText;
						PChannelArrayToString( pItem->adwPChannels, pItem->nNumPChannels, strText );
						strText = strText.Left( 64 );
						if( 0 == MultiByteToWideChar( CP_ACP, 0, strText, -1, pDMOInfo->awchPChannelText, 65 ) )
						{
							return E_FAIL;
						}

						BusListToString( pItem, pBufferOptions , strText );
						if( 0 == MultiByteToWideChar( CP_ACP, 0, strText, -1, pDMOInfo->awchBufferText, 65 ) )
						{
							return E_FAIL;
						}

						if( 0 == MultiByteToWideChar( CP_ACP, 0, pItem->strBandName, -1, pDMOInfo->awchMixGroupName, 65 ) )
						{
							return E_FAIL;
						}
						GetDMOName( GUID_DSFX_WAVES_REVERB, pDMOInfo->awchDMOName );
						pDMOInfo->dwEffectIndex = 0;
						return S_OK;
					}
					else
					{
						dwIndex--;
					}
				}
			}
			dwBufferIndex++;
		}

		if( pItem->nNumPChannels == 0 )
		{
			dwMixInBufferIndex++;
		}
	}
	return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath :: EnumBufferInfo

HRESULT CDirectMusicAudioPath::EnumBufferInfo( DWORD dwIndex, WCHAR wcstr[DMUS_MAX_NAME + 1], GUID *pGuid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate arguments
	if( wcstr == NULL
	||	pGuid == NULL )
	{
		return E_POINTER;
	}

	ZeroMemory( wcstr, sizeof(WCHAR) * DMUS_MAX_NAME + 1 );

	// Iterate through all items
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pItem = m_lstItems.GetNext( posItem );

		if( pItem->nNumPChannels == 0 )
		{
			if( dwIndex == 0 )
			{
				if( pItem->lstBuffers.GetCount() == 0 ) 
				{
					return E_UNEXPECTED;
				}

				if( 0 == MultiByteToWideChar( CP_ACP, 0, pItem->strBandName, -1, wcstr, DMUS_MAX_NAME ) )
				{
					return E_FAIL;
				}
				*pGuid = pItem->lstBuffers.GetHead()->guidBuffer;
				return S_OK;
			}

			dwIndex--;
		}
	}
	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IPersist::GetClassID

HRESULT CDirectMusicAudioPath::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pClsId != NULL );

	memset( pClsId, 0, sizeof( CLSID ) );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IPersistStream::IsDirty

HRESULT CDirectMusicAudioPath::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fModified )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IPersistStream::Load

HRESULT CDirectMusicAudioPath::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = DM_LoadAudioPath( pIStream );
	if( FAILED( hr ) )
	{
		return hr;
	}

	// Update the display indexes
	UpdateDisplayIndexes();

	if( m_pIDocRootNode )
	{
		// Already in Project Tree so sync changes
		// Refresh AudioPath editor (when open)
		SyncAudioPathEditor();

		// Sync change with property sheet
		if(theApp.m_pAudioPathComponent->m_pIAudioPathPageManager)
		{
			theApp.m_pAudioPathComponent->m_pIAudioPathPageManager->RefreshData();
		}
	}

	// Notify Conductor that the Audiopath name has changed
	theApp.m_pAudioPathComponent->m_pIConductor->SetAudiopathName( this, GetNameForConductor() );

	if( SUCCEEDED( hr ) )
	{
		hr = S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IPersistStream::Save

HRESULT CDirectMusicAudioPath::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	HRESULT hr = S_OK;

	// Validate requested data format
	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
	||	IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
	{
		hr = DM_SaveAudioPath( pIStream );
		if( SUCCEEDED ( hr ) )
		{
			if( fClearDirty )
			{
				SetModified( FALSE );
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath IPersistStream::GetSizeMax

HRESULT CDirectMusicAudioPath::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath Additional functions


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetObjectDescriptor

HRESULT CDirectMusicAudioPath::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_guidAudioPath, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicAudioPathConfig, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_strName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_LoadAudioPath

HRESULT CDirectMusicAudioPath::DM_LoadAudioPath( IStream *pIStream )
{
	// Save the current list of items and ports
	CTypedPtrList< CPtrList, ItemInfo *> lstOldItems;
	CTypedPtrList< CPtrList, PortOptions *> lstOldPortOptions;

	// Empty the current list of items
	while( !m_lstItems.IsEmpty() )
	{
		lstOldItems.AddHead( m_lstItems.RemoveHead() );
	}

	// Empty the current list of ports
	while( !m_lstPortOptions.IsEmpty() )
	{
		lstOldPortOptions.AddHead( m_lstPortOptions.RemoveHead() );
	}

	// Synchronize the display
	SyncAudioPathEditor();

	// Now, delete the items and ports
	while( !lstOldItems.IsEmpty() )
	{
		delete lstOldItems.RemoveHead();
	}
	while( !lstOldPortOptions.IsEmpty() )
	{
		delete lstOldPortOptions.RemoveHead();
	}

	// Initialize the list of ports
	EnumeratePorts();

	// Initialize other variables
	m_strAuthor.Empty();
	m_strCopyright.Empty();
	m_strSubject.Empty();

	// Allocate a RIFF stream
	IDMUSProdRIFFStream *pRiffStream;
	AllocRIFFStream( pIStream, &pRiffStream );

	// Save the current position
	DWORD dwPos = StreamTell( pIStream );

	// Initialize the result to S_FALSE
	HRESULT hr = S_FALSE;

	CTypedPtrList< CPtrList, ioPortConfig*> lstPortConfigs;
	CTypedPtrList< CPtrList, ioDSoundBuffer*> lstDSoundBuffers;

	// Find the main audiopath chunk
	MMCKINFO ckMain;
	ckMain.fccType = DMUS_FOURCC_AUDIOPATH_FORM;
	if( 0 == pRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) )
	{
		// Now, descend into each child chunk
		MMCKINFO ckChunk, ckList;
		DWORD cbSize, cbRead;
		while( SUCCEEDED(hr)
			&& (0 == pRiffStream->Descend( &ckChunk, &ckMain, 0 )) )
		{
			switch( ckChunk.ckid )
			{
			case DMUS_FOURCC_GUID_CHUNK:
				cbSize = min( ckChunk.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guidAudioPath, cbSize, &cbRead );
				if( FAILED( hr )
				||  cbRead != cbSize )
				{
					hr = E_FAIL;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusVersionIO;

				cbSize = min( ckChunk.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusVersionIO, cbSize, &cbRead );
				if( FAILED( hr )
				||  cbRead != cbSize )
				{
					hr = E_FAIL;
				}

				m_vVersion.dwVersionMS = dmusVersionIO.dwVersionMS;
				m_vVersion.dwVersionLS = dmusVersionIO.dwVersionLS;
				break;
			}
			case FOURCC_RIFF:
				switch( ckChunk.fccType )
				{
					case DMUS_FOURCC_TOOLGRAPH_FORM:
					if( theApp.m_pAudioPathComponent->m_pIToolGraphComponent )
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = theApp.m_pAudioPathComponent->m_pIToolGraphComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( SUCCEEDED ( hr ) )
						{
							StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
							hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
							RELEASE( pIRIFFExt );
							if( SUCCEEDED ( hr ) )
							{
								if( m_pIToolGraphNode )
								{
									InsertChildNode( pINode);
									pINode->Release();
								}
								else
								{
									m_pIToolGraphNode = pINode;
									AllAudioPaths_InsertToolGraph();
								}
							}
						}
						break;
					}
				}
				break;

			case FOURCC_LIST:
				switch( ckChunk.fccType )
				{
				case DMUSPROD_FOURCC_AUDIOPATH_DESIGN_LIST:
					// Load in the effect palette UI info
					DM_LoadDesignInfo( pRiffStream, ckChunk );
					break;

				case DMUS_FOURCC_UNFO_LIST:
					while( pRiffStream->Descend( &ckList, &ckChunk, 0 ) == 0 )
					{
						switch( ckList.ckid )
						{
							case DMUS_FOURCC_UNAM_CHUNK:
							{
								CString strName;

								ReadMBSfromWCS( pIStream, ckList.cksize, &strName );
								if( strName.CompareNoCase( m_strName ) != 0 )
								{
									m_strName = strName;
									theApp.m_pAudioPathComponent->m_pIFramework->RefreshNode( this );

									theApp.m_pAudioPathComponent->m_pIFramework->NotifyNodes( this, AUDIOPATH_NameChange, NULL );
								}
								break;
							}

							case DMUS_FOURCC_UART_CHUNK:
								ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
								break;

							case DMUS_FOURCC_UCOP_CHUNK:
								ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
								break;

							case DMUS_FOURCC_USBJ_CHUNK:
								ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
								break;
						}
					    pRiffStream->Ascend( &ckList, 0 );
					}
					break;

				case DMUS_FOURCC_PORTCONFIGS_LIST:
					while( 0 == pRiffStream->Descend( &ckList, &ckChunk, 0 ) )
					{
						switch( ckList.ckid )
						{
						case FOURCC_LIST:
							switch( ckList.fccType )
							{
							case DMUS_FOURCC_PORTCONFIG_LIST:
								// Load in the port configuration list
								DM_LoadPortConfig( pRiffStream, ckList, lstPortConfigs );
								break;
							}
							break;
						}
						pRiffStream->Ascend( &ckList, 0 );
					}
					break;

				case DMUS_FOURCC_DSBUFFER_LIST:
					{
						bool fHeaderLoaded = false;

						// Initialize ioBufferHeader, in case the DSBUFFATTR_ITEM chunk is not found
						DMUS_IO_BUFFER_ATTRIBUTES_HEADER ioBufferHeader;
						ZeroMemory( &ioBufferHeader, sizeof( DMUS_IO_BUFFER_ATTRIBUTES_HEADER ) );

						// The buffer name - only used when using a predefined buffer
						CString strBufferName;

						while( 0 == pRiffStream->Descend( &ckList, &ckChunk, 0 ) )
						{
							switch( ckList.ckid )
							{
							case DMUS_FOURCC_DSBUFFATTR_ITEM:
								ZeroMemory( &ioBufferHeader, sizeof( DMUS_IO_BUFFER_ATTRIBUTES_HEADER ) );
								cbSize = min( sizeof( DMUS_IO_BUFFER_ATTRIBUTES_HEADER ), ckList.cksize );
								hr = pIStream->Read( &ioBufferHeader, cbSize, &cbRead );
								if( FAILED( hr )
								||  cbRead != cbSize )
								{
									hr = E_FAIL;
								}
								else
								{
									fHeaderLoaded = true;
									if( ioBufferHeader.guidBufferID == GUID_AllZeros )
									{
										CoCreateGuid( &ioBufferHeader.guidBufferID );

										// Flag that we loaded in an old-format file
										SetModified( TRUE );
									}
								}
								break;

							case FOURCC_LIST:
								switch( ckList.fccType )
								{
								case DMUS_FOURCC_UNFO_LIST:
									MMCKINFO ckUnfo;
									while( 0 == pRiffStream->Descend( &ckUnfo, &ckList, 0 ) )
									{
										switch( ckUnfo.ckid )
										{
										case DMUS_FOURCC_UNAM_CHUNK:
											// Read in the name of the DSound buffer
											ReadMBSfromWCS( pIStream, ckUnfo.cksize, &strBufferName );
											break;
										}
										pRiffStream->Ascend( &ckUnfo, 0 );
									}
									break;
								}
								break;

							case FOURCC_RIFF:
								switch( ckList.fccType )
								{
								case DMUS_FOURCC_DSBC_FORM:
									// Load in a DirectSound buffer

									// Assert that the header has been loaded
									ASSERT( fHeaderLoaded );

									// Assert that we're not using a predefined buffer
									ASSERT( !(ioBufferHeader.dwFlags & DMUS_BUFFERF_DEFINED) );

									// Load the buffer
									DM_LoadBuffer( pRiffStream, ckList, ioBufferHeader, lstDSoundBuffers );
									break;
								}
								break;
							}

							pRiffStream->Ascend( &ckList, 0 );
						}

						// Check if we're using a predefined buffer
						if( ioBufferHeader.dwFlags & DMUS_BUFFERF_DEFINED )
						{
							// Using a predefined buffer - need to add the header info to lstDSoundBuffer

							// Create a new stucture to store the buffer in
							ioDSoundBuffer *pioDSoundBuffer = new ioDSoundBuffer;

							// Verify that we didn't run out of memory
							if( pioDSoundBuffer != NULL )
							{
								// Change the GUID if we're using an outdated one
								if( REMOVED_GUID_Buffer_3D == ioBufferHeader.guidBufferID )
								{
									ioBufferHeader.guidBufferID = GUID_Buffer_3D_Dry;
									SetModified( TRUE );
								}

								// Copy the header information
								pioDSoundBuffer->ioBufferHeader = ioBufferHeader;

								// Verify we have a valid GUID
								if( (ioBufferHeader.guidBufferID != GUID_Buffer_Reverb)
								&&	(ioBufferHeader.guidBufferID != GUID_Buffer_EnvReverb)
								/*&&	(ioBufferHeader.guidBufferID != GUID_Buffer_3D)*/
								&&	(ioBufferHeader.guidBufferID != GUID_Buffer_3D_Dry)
								&&	(ioBufferHeader.guidBufferID != GUID_Buffer_Mono)
								&&	(ioBufferHeader.guidBufferID != GUID_Buffer_Stereo) )
								{
									ASSERT(FALSE);
								}

								// Set the name of the buffer
								if( ioBufferHeader.guidBufferID == GUID_Buffer_EnvReverb )
								{
									pioDSoundBuffer->strName.LoadString( IDS_BUFFER_ENVREVERB );
								}
								else
								{
									pioDSoundBuffer->strName = strBufferName;
								}

								// Add the buffer to the end of the list of buffers
								lstDSoundBuffers.AddTail( pioDSoundBuffer );
							}

						}
					}
					break;
				}
				break;
			}

			// Ascend out of the child chunk
			pRiffStream->Ascend( &ckChunk, 0 );
		    dwPos = StreamTell( pIStream );
		}

		// Need to connect up the port configurations with the directsound buffers to make items.
		// Also, any DirectSound buffers that don't match up need to be made into their own items
		DM_CreateItems( lstPortConfigs, lstDSoundBuffers );

		// Connect up all the send effects with their destination mix groups
		ConnectAllSendEffects();

		// No need to ascend out of the main chunk
	}

	// Release the RIFF stream
	pRiffStream->Release();

	// Return the result
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_CreateItems

void CDirectMusicAudioPath::DM_CreateItems( CTypedPtrList< CPtrList, ioPortConfig*> &lstPortConfigs, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers )
{
	CTypedPtrList< CPtrList, ioDSoundBuffer*> lstUsedDSoundBuffers;

	// Iterate through all ioPortConfig structures
	while( !lstPortConfigs.IsEmpty() )
	{
		ioPortConfig *pioPortConfig = lstPortConfigs.RemoveHead();

		// Create a PortOptions, if necessary, from the information in pioPortConfig
		PortOptions *pPortOptions = CreatePortOptions( pioPortConfig->ioPortConfigHeader, pioPortConfig->ioPortParams, pioPortConfig->strPortName );

		// Create the mix groups for this PortConfig
		CreateItemInfos( pioPortConfig, pPortOptions, lstUsedDSoundBuffers, lstDSoundBuffers );

		delete pioPortConfig;
	}

	// Delete all DirectSound buffers that are used by the items we created above
	while( !lstUsedDSoundBuffers.IsEmpty() )
	{
		ioDSoundBuffer *pioDSoundBuffer = lstUsedDSoundBuffers.RemoveHead();
		pioDSoundBuffer->lstBusIDs.RemoveAll();
		while( !pioDSoundBuffer->lstDSoundEffects.IsEmpty() )
		{
			ioDSoundEffect *pioDSoundEffect = pioDSoundBuffer->lstDSoundEffects.RemoveHead();

			delete pioDSoundEffect;
		}

		delete pioDSoundBuffer;
	}

	while( !lstDSoundBuffers.IsEmpty() )
	{
		// Also need to create items from the unused buffers
		ioDSoundBuffer *pioDSoundBuffer = lstDSoundBuffers.RemoveHead();

		ItemInfo *pItemInfo = new ItemInfo;
		if( pItemInfo )
		{
			pItemInfo->strBandName = pioDSoundBuffer->strName;

			// Create a BufferOptions for this buffer
			BufferOptions *pBufferOptions = new BufferOptions;

			if( pBufferOptions )
			{
				pBufferOptions->lstBusIDs.Copy( pioDSoundBuffer->lstBusIDs );
				pBufferOptions->guidBuffer = pioDSoundBuffer->ioBufferHeader.guidBufferID;
				pBufferOptions->dwHeaderFlags = pioDSoundBuffer->ioBufferHeader.dwFlags;
				pBufferOptions->dwBufferFlags = pioDSoundBuffer->ioDSBufferDesc.dwFlags;
				pBufferOptions->lPan = pioDSoundBuffer->ioDSBufferDesc.lPan;
				pBufferOptions->lVolume = pioDSoundBuffer->ioDSBufferDesc.lVolume;
				pBufferOptions->wChannels = pioDSoundBuffer->ioDSBufferDesc.nChannels;

				pBufferOptions->guid3DAlgorithm = pioDSoundBuffer->ioDS3D.guid3DAlgorithm;
				pBufferOptions->ds3DBuffer = pioDSoundBuffer->ioDS3D.ds3d;

				// If using a standard buffer, copy the buffer's GUID
				if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
				{

					// If the buffer has no busIDs, add the dynamic 0 bus
					if( pBufferOptions->lstBusIDs.GetSize() == 0 )
					{
						pBufferOptions->lstBusIDs.Add( DSBUSID_LEFT );
						pBufferOptions->lstBusIDs.Add( DSBUSID_RIGHT );
						pBufferOptions->wChannels = max( WORD(2), pBufferOptions->wChannels );
					}
				}

				// Create effect list
				POSITION posEffect = pioDSoundBuffer->lstDSoundEffects.GetHeadPosition();
				while( posEffect )
				{
					// Get a pointer to the ioDSoundEffect structure
					ioDSoundEffect *pioDSoundEffect = pioDSoundBuffer->lstDSoundEffects.GetNext( posEffect );

					// Create a new BusEffectInfo to wrap this effect
					BusEffectInfo *pBusEffectInfo = new BusEffectInfo( pioDSoundEffect );
					if( pBusEffectInfo )
					{
						// Add the BusEffectInfo to the list of effects
						pBufferOptions->lstEffects.AddTail( pBusEffectInfo );
					}
				}

				// Attach the buffer to the item
				pItemInfo->lstBuffers.AddTail( pBufferOptions );
			}

			// Add the item to the list of items we manage
			InsertItemInfo( pItemInfo );
		}

		// Delete all the effects in this buffer
		while( !pioDSoundBuffer->lstDSoundEffects.IsEmpty() )
		{
			// Get a pointer to the ioDSoundEffect structure
			ioDSoundEffect *pioDSoundEffect = pioDSoundBuffer->lstDSoundEffects.RemoveHead();

			// Delete the effect
			delete pioDSoundEffect;
		}

		// Delete the buffer itself
		delete pioDSoundBuffer;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::ConnectAllSendEffects

void CDirectMusicAudioPath::ConnectAllSendEffects( void )
{

	// Iterate through the list of items
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pItemInfo = m_lstItems.GetNext( posItem );

		/* Update hidden buffers
		// If the port doesn't support buffers, skip it
		if( !ItemSupportsBuffers( pItemInfo ) )
		{
			continue;
		}
		*/

		// Iterate through the list of buffers
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			/* Update hidden effects
			// If the buffer does not support effects, skip it
			if( !ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
			{
				continue;
			}
			*/

			// Iterate through the list of effects
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfoInList = pBufferOptions->lstEffects.GetNext( posEffect );

				// Check if this is a sending effect
				if( (GUID_DSFX_SEND == pBusEffectInfoInList->m_EffectInfo.m_clsidObject)
				/*||	(GUID_DSFX_STANDARD_I3DL2SOURCE == pBusEffectInfoInList->m_EffectInfo.m_clsidObject)*/ )
				{
					// Initialize the mixgroup pointer to NULL
					pBusEffectInfoInList->m_EffectInfo.m_pSendDestinationMixGroup = NULL;

					// Check if we're not using the standard Env. Reverb GUID
					if( GUID_Buffer_EnvReverb != pBusEffectInfoInList->m_EffectInfo.m_clsidSendBuffer )
					{
						// Check to see if the effect is now pointed at any of our mix groups
						POSITION pos = m_lstItems.GetHeadPosition();
						while( pos )
						{
							// Get a pointer to each item
							ItemInfo *pTmpItem = m_lstItems.GetNext( pos );

							// Check if this item is the one with the buffer we want to use
							if( (pTmpItem->nNumPChannels == 0)
							&&	(pTmpItem->lstBuffers.GetCount() > 0)
							&&	(pTmpItem->lstBuffers.GetHead()->guidBuffer == pBusEffectInfoInList->m_EffectInfo.m_clsidSendBuffer) )
							{
								// Yes - set the pointer and break out of the loop
								pBusEffectInfoInList->m_EffectInfo.m_pSendDestinationMixGroup = pTmpItem;
								break;
							}
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::InsertItemInfo

void CDirectMusicAudioPath::InsertItemInfo( ItemInfo *pItemInfo )
{
	ASSERT( pItemInfo );
	if( pItemInfo )
	{
		// Ensure the MixGroup name exists, and is unique
		if( pItemInfo->strBandName.IsEmpty() )
		{
			pItemInfo->strBandName = GetNewMixgroupName();
		}
		else
		{
			GetUniqueMixGroupName( pItemInfo );
		}

		// Add Item to the list of items we manage
		m_lstItems.AddTail( pItemInfo );

		// Now, ensure all the effect instance names are unique
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			if( !pBufferOptions->lstEffects.IsEmpty() )
			{
				POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();

				// Skip the first effect
				pBufferOptions->lstEffects.GetNext( posEffect );

				// Iterate through the effects
				while( posEffect )
				{
					BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );
					// Now, check if the effect already exists
					GetUniqueEffectInstanceNameIfNecessary( &pBusEffectInfo->m_EffectInfo );
				}

				// Now, check the first effect
				GetUniqueEffectInstanceNameIfNecessary( &(pBufferOptions->lstEffects.GetHead()->m_EffectInfo) );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetItemForPChannel

ItemInfo *CDirectMusicAudioPath::GetItemForPChannel( DWORD dwPChannel )
{
	// Iterate through the list of items
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pItem = m_lstItems.GetNext( posItem );

		// Iterate through the array of PChannels
		for( int i=0; i< pItem->nNumPChannels; i++ )
		{
			// Check if this PChannel is the one we're looking for
			if( pItem->adwPChannels[i] == dwPChannel )
			{
				// Yes - return pItem
				return pItem;
			}
		}
	}
	
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreateItemInfos

void CDirectMusicAudioPath::CreateItemInfos( ioPortConfig *pioPortConfig, PortOptions *pPortOptions, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstUsedDSoundBuffers, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers )
{
	// Create a mix group for each item in lstPChannelToBuffer
	while( !pioPortConfig->lstPChannelToBuffer.IsEmpty() )
	{
		ioPChannelToBuffer *pioPChannelToBuffer = pioPortConfig->lstPChannelToBuffer.RemoveHead();

		CreateItemFromPChannelToBuffer( pioPChannelToBuffer, pPortOptions, lstUsedDSoundBuffers, lstDSoundBuffers );

		delete pioPChannelToBuffer;
	}

	// Create a mix group for each item in lstDesignMixGroup
	while( !pioPortConfig->lstDesignMixGroup.IsEmpty() )
	{
		ioDesignMixGroup *pioDesignMixGroup = pioPortConfig->lstDesignMixGroup.RemoveHead();

		CreateItemFromDesignInfo( pioDesignMixGroup, pPortOptions );

		delete pioDesignMixGroup;
	}

	// Create an array of any left over PChannels
	CDWordArray adwPChannelsToAdd;
	for( DWORD dwPChannel = 0; dwPChannel < pioPortConfig->ioPortConfigHeader.dwPChannelCount; dwPChannel++ )
	{
		if( GetItemForPChannel( dwPChannel + pioPortConfig->ioPortConfigHeader.dwPChannelBase ) == NULL )
		{
			adwPChannelsToAdd.Add( dwPChannel + pioPortConfig->ioPortConfigHeader.dwPChannelBase );
		}
	}

	// Finally, create a mix group for any left over PChannels
	if( adwPChannelsToAdd.GetSize() > 0 )
	{
		CreateItemFromPChannelArray( adwPChannelsToAdd, pPortOptions );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreateItemFromPChannelToBuffer

void CDirectMusicAudioPath::CreateItemFromPChannelToBuffer( ioPChannelToBuffer *pioPChannelToBuffer, PortOptions *pPortOptions, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstUsedDSoundBuffers, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers )
{
	// Look for an existing item with the same port and buffer
	POSITION pos = m_lstItems.GetHeadPosition();
	while( pos )
	{
		ItemInfo *pItemInfo = m_lstItems.GetNext( pos );

		// Check if the ports are the same
		if( pItemInfo->pPortOptions
		&&	pItemInfo->pPortOptions->IsEqual( pPortOptions ) )
		{
			bool fEqual = true;
			POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
			POSITION posGuids = pioPChannelToBuffer->lstGuids.GetHeadPosition();
			while( posBuffer && posGuids)
			{
				BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );
				GUID *pGuid = pioPChannelToBuffer->lstGuids.GetNext( posGuids );
				if( pBufferOptions->guidBuffer != *pGuid )
				{
					fEqual = false;
					break;
				}
			}

			// If all the GUIDs are equal, and the lists are the same length (both end at the same time)
			if( fEqual && !posBuffer && !posGuids )
			{
				// Just add the PChannels to this pItemInfo
				DWORD *adwNewPChannels = NULL;
				if( pItemInfo->nNumPChannels > 0 )
				{
					adwNewPChannels = new DWORD[pItemInfo->nNumPChannels + pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount];
					if( adwNewPChannels )
					{
						// Copy existing PChannels
						memcpy( adwNewPChannels, pItemInfo->adwPChannels, sizeof(DWORD) * pItemInfo->nNumPChannels );

						// Copy new PChannels
						for( DWORD i = 0; i < pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount; i++ )
						{
							adwNewPChannels[ pItemInfo->nNumPChannels + i ] = pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelBase + i;
						}

						// delete old array
						delete[] pItemInfo->adwPChannels;

					}
				}
				else
				{
					adwNewPChannels = new DWORD[pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount];
					if( adwNewPChannels )
					{
						// Copy new PChannels
						for( DWORD i = 0; i < pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount; i++ )
						{
							adwNewPChannels[ i ] = pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelBase + i;
						}
					}
				}

				if( adwNewPChannels )
				{
					// Point to new array
					pItemInfo->adwPChannels = adwNewPChannels;

					// Update count of PChannels
					pItemInfo->nNumPChannels += pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount;
				}

				// Return
				return;
			}
		}
	}

	// Didn't find an existing Item - must create a new one
	ItemInfo *pItemInfo = new ItemInfo;
	if( pItemInfo )
	{
		// Create an array to store these PChannels in
		pItemInfo->adwPChannels = new DWORD[pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount];
		if( pItemInfo->adwPChannels )
		{
			// Copy new PChannels
			for( DWORD i = 0; i < pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount; i++ )
			{
				pItemInfo->adwPChannels[ i ] = pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelBase + i;
			}

			// Set count of PChannels
			pItemInfo->nNumPChannels = pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount;
		}

		// Set the mix group name
		pItemInfo->strBandName = pioPChannelToBuffer->strMixGroupName;

		// Copy the port settings
		pItemInfo->pPortOptions = pPortOptions;

		// Now, connect the item to the DirectSound buffers
		while( !pioPChannelToBuffer->lstGuids.IsEmpty() )
		{
			GUID *pGuid = pioPChannelToBuffer->lstGuids.RemoveHead();

			// Iterate through the existing DSound buffers
			POSITION posBuffer = lstUsedDSoundBuffers.GetHeadPosition();
			while( posBuffer )
			{
				ioDSoundBuffer *pioDSoundBuffer = lstUsedDSoundBuffers.GetNext( posBuffer );
				if( pioDSoundBuffer->ioBufferHeader.guidBufferID == *pGuid )
				{
					// Shouldn't re-use any buffers
					ASSERT(FALSE);
				}
			}

			// Iterate through the unused DSound buffers
			posBuffer = lstDSoundBuffers.GetHeadPosition();
			while( posBuffer )
			{
				ioDSoundBuffer *pioDSoundBuffer = lstDSoundBuffers.GetNext( posBuffer );

				// Check if this is the buffer to connect to
				if( pioDSoundBuffer->ioBufferHeader.guidBufferID == *pGuid )
				{
					// Create a BufferOptions for this buffer
					BufferOptions *pBufferOptions = new BufferOptions;

					if( pBufferOptions )
					{
						pBufferOptions->lstBusIDs.Copy( pioDSoundBuffer->lstBusIDs );
						pBufferOptions->dwBufferFlags = pioDSoundBuffer->ioDSBufferDesc.dwFlags;
						pBufferOptions->dwHeaderFlags = pioDSoundBuffer->ioBufferHeader.dwFlags;
						pBufferOptions->wChannels = pioDSoundBuffer->ioDSBufferDesc.nChannels;
						pBufferOptions->lPan = pioDSoundBuffer->ioDSBufferDesc.lPan;
						pBufferOptions->lVolume = pioDSoundBuffer->ioDSBufferDesc.lVolume;

						pBufferOptions->guid3DAlgorithm = pioDSoundBuffer->ioDS3D.guid3DAlgorithm;
						pBufferOptions->ds3DBuffer = pioDSoundBuffer->ioDS3D.ds3d;

						// Copy the buffer's GUID
						pBufferOptions->guidBuffer = pioDSoundBuffer->ioBufferHeader.guidBufferID;

						// Create effect list
						POSITION posEffect = pioDSoundBuffer->lstDSoundEffects.GetHeadPosition();
						while( posEffect )
						{
							// Get a pointer to the ioDSoundEffect structure
							ioDSoundEffect *pioDSoundEffect = pioDSoundBuffer->lstDSoundEffects.GetNext( posEffect );

							// Create a new BusEffectInfo to wrap this effect
							BusEffectInfo *pBusEffectInfo = new BusEffectInfo( pioDSoundEffect );
							if( pBusEffectInfo )
							{
								// Add the BusEffectInfo to the list of effects
								pBufferOptions->lstEffects.AddTail( pBusEffectInfo );
							}
						}

						// Attach the buffer to the item
						pItemInfo->lstBuffers.AddTail( pBufferOptions );

						// Move the ioBuffer into the list of used buffers
						lstUsedDSoundBuffers.AddTail( pioDSoundBuffer );

						// See if this buffer has an effect design GUID
						if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
						{
							// Initialize the GUID to a random value
							CoCreateGuid( &pBufferOptions->guidDesignEffectGUID );

							// Iterate through the list of GUIDs
							POSITION pos = pioPChannelToBuffer->lstDesignGuids.GetHeadPosition();
							while( pos )
							{
								// Save the current position
								const POSITION posCurrent = pos;

								// Get the current GUID
								GUID *pGUID = pioPChannelToBuffer->lstDesignGuids.GetNext( pos );

								// Is this the GUID we're looking for?
								if( *pGUID == pBufferOptions->guidBuffer )
								{
									// Yes - delete it from the list
									delete pGUID;
									pioPChannelToBuffer->lstDesignGuids.RemoveAt( posCurrent );

									// Get the next GUID
									pGUID = pioPChannelToBuffer->lstDesignGuids.GetAt( pos );

									// Use it as the design GUID
									pBufferOptions->guidDesignEffectGUID = *pGUID;

									// delete it from the list
									delete pGUID;
									pioPChannelToBuffer->lstDesignGuids.RemoveAt( pos );
									break;
								}
							}
						}

						// Remove the ioBuffer from the list of unused buffers
						posBuffer = lstDSoundBuffers.Find( pioDSoundBuffer );
						ASSERT( posBuffer );
						if( posBuffer )
						{
							lstDSoundBuffers.RemoveAt( posBuffer );
							break;
						}
					}
				}
			}

			// Delete the GUID
			delete pGuid;
		}

		// Add Item to the list of items we manage
		InsertItemInfo( pItemInfo );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreateItemFromPChannelArray

void CDirectMusicAudioPath::CreateItemFromPChannelArray( CDWordArray &adwPChannelsToAdd, PortOptions *pPortOptions )
{
	// Didn't find an existing Item - must create a new one
	ItemInfo *pItemInfo = new ItemInfo;
	if( pItemInfo )
	{
		// Create an array to store these PChannels in
		pItemInfo->adwPChannels = new DWORD[adwPChannelsToAdd.GetSize()];
		if( pItemInfo->adwPChannels )
		{
			// Copy new PChannels
			for( DWORD i = 0; i < (unsigned)adwPChannelsToAdd.GetSize(); i++ )
			{
				pItemInfo->adwPChannels[ i ] = adwPChannelsToAdd[ i ];
			}

			// Set count of PChannels
			pItemInfo->nNumPChannels = adwPChannelsToAdd.GetSize();
		}

		// Set the mix group name
		pItemInfo->strBandName = GetNewMixgroupName();

		// Copy the port settings
		pItemInfo->pPortOptions = pPortOptions;

		// Add Item to the list of items we manage
		InsertItemInfo( pItemInfo );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreateItemFromDesignInfo

void CDirectMusicAudioPath::CreateItemFromDesignInfo( ioDesignMixGroup *pioDesignMixGroup, PortOptions *pPortOptions )
{
	// Look for an existing item with the same port and no buffers
	POSITION pos = m_lstItems.GetHeadPosition();
	while( pos )
	{
		ItemInfo *pItemInfo = m_lstItems.GetNext( pos );

		// Check if the item's buffer list is empty
		// Check if the ports are the same
		// Check if the mix group name is the same
		if( pItemInfo->lstBuffers.IsEmpty()
		&&	pItemInfo->pPortOptions
		&&	pItemInfo->pPortOptions->IsEqual( pPortOptions )
		&&	pItemInfo->strBandName == pioDesignMixGroup->strMixGroupName )
		{
			// Just add the PChannels to this pItemInfo
			DWORD *adwNewPChannels = NULL;
			if( pItemInfo->nNumPChannels > 0 )
			{
				adwNewPChannels = new DWORD[pItemInfo->nNumPChannels + pioDesignMixGroup->dwPChannelSpan];
				if( adwNewPChannels )
				{
					// Copy existing PChannels
					memcpy( adwNewPChannels, pItemInfo->adwPChannels, sizeof(DWORD) * pItemInfo->nNumPChannels );

					// Copy new PChannels
					for( DWORD i = 0; i < pioDesignMixGroup->dwPChannelSpan; i++ )
					{
						adwNewPChannels[ pItemInfo->nNumPChannels + i ] = pioDesignMixGroup->dwPChannelStart + i;
					}

					// delete old array
					delete[] pItemInfo->adwPChannels;
				}
			}
			else
			{
				adwNewPChannels = new DWORD[pioDesignMixGroup->dwPChannelSpan];
				if( adwNewPChannels )
				{
					// Copy new PChannels
					for( DWORD i = 0; i < pioDesignMixGroup->dwPChannelSpan; i++ )
					{
						adwNewPChannels[ i ] = pioDesignMixGroup->dwPChannelStart + i;
					}
				}
			}

			if( adwNewPChannels )
			{
				// Point to new array
				pItemInfo->adwPChannels = adwNewPChannels;

				// Update count of PChannels
				pItemInfo->nNumPChannels += pioDesignMixGroup->dwPChannelSpan;
			}

			// Return
			return;
		}
	}

	// Didn't find an existing Item - must create a new one
	ItemInfo *pItemInfo = new ItemInfo;
	if( pItemInfo )
	{
		// Create an array to store these PChannels in
		pItemInfo->adwPChannels = new DWORD[pioDesignMixGroup->dwPChannelSpan];
		if( pItemInfo->adwPChannels )
		{
			// Copy new PChannels
			for( DWORD i = 0; i < pioDesignMixGroup->dwPChannelSpan; i++ )
			{
				pItemInfo->adwPChannels[ i ] = pioDesignMixGroup->dwPChannelStart + i;
			}

			// Set count of PChannels
			pItemInfo->nNumPChannels = pioDesignMixGroup->dwPChannelSpan;
		}

		// Set the mix group name
		pItemInfo->strBandName = pioDesignMixGroup->strMixGroupName;

		// Copy the port settings
		pItemInfo->pPortOptions = pPortOptions;

		// Add Item to the list of items we manage
		InsertItemInfo( pItemInfo );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_LoadDesignInfo

HRESULT CDirectMusicAudioPath::DM_LoadDesignInfo( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk )
{
	IStream *pIStream = pIRiffStream->GetStream();
	if( pIStream == NULL )
	{
		return E_FAIL;
	}

	// Look through all chunks within ckChunk
	MMCKINFO ckSubChunk;
	while( 0 == pIRiffStream->Descend( &ckSubChunk, &ckChunk, 0 ) )
	{
		switch( ckSubChunk.ckid )
		{
		case DMUSPROD_FOURCC_AUDIOPATH_UI_CHUNK:
			{
				// Read the UI data
				ioAudioPathUI iAudioPathUI;
				ZeroMemory( &iAudioPathUI, sizeof(ioAudioPathUI) );

				DWORD cbRead, cbToRead = min( ckSubChunk.cksize, sizeof(ioAudioPathUI) );
				if( SUCCEEDED( pIStream->Read( &iAudioPathUI, cbToRead, &cbRead ) )
				&&	(cbRead == cbToRead) )
				{
					m_wSplitterPos = iAudioPathUI.wSplitterPos;
					m_wMixGroupWidth = iAudioPathUI.wMixGroupWidth;
					m_wBusWidth = iAudioPathUI.wBusWidth;
					m_wBufferWidth = iAudioPathUI.wBufferWidth;
					m_wEffectWidth = iAudioPathUI.wEffectWidth;
				}
			}
			break;
		}

		// Ascend out of the sub chunk
		pIRiffStream->Ascend( &ckSubChunk, 0 );
	}

	// Release the IStream interface
	pIStream->Release();

	// We succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ValidateEffectFlags

bool ValidateEffectFlags( REFGUID clsidEffect, DWORD &dwEffectFlags )
{
	bool fChanged = false;

	// If a send effect, ensure that neither of the DSFX_LOC* flags are set
	if( (GUID_DSFX_SEND == clsidEffect)
	/*||	(GUID_DSFX_STANDARD_I3DL2SOURCE == clsidEffect)*/ )
	{
		if( dwEffectFlags & (DSFX_LOCSOFTWARE | DSFX_LOCHARDWARE) )
		{
			dwEffectFlags &= ~(DSFX_LOCSOFTWARE | DSFX_LOCHARDWARE);
			fChanged = true;
		}
	}

	// Verify that DSFX_LOCHARDWARE is not set
	if( dwEffectFlags & DSFX_LOCHARDWARE )
	{
		dwEffectFlags &= ~DSFX_LOCHARDWARE;
		fChanged = true;
	}

	// Verify that DSFX_OPTIONAL is not set
	if( dwEffectFlags & DSFX_OPTIONAL )
	{
		dwEffectFlags &= ~DSFX_OPTIONAL;
		fChanged = true;
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_LoadEffect

ioDSoundEffect *CDirectMusicAudioPath::DM_LoadEffect( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk )
{
	// Create a new ioDSoundEffect structure
	ioDSoundEffect *pioDSoundEffect = new ioDSoundEffect;
	if( pioDSoundEffect == NULL )
	{
		// Check that the allocation succeeded
		return NULL;
	}

	// Get a pointer to the IStream
	IStream *pStream = pIRiffStream->GetStream();

	DWORD cbToRead, cbRead;
	MMCKINFO ckSubChunk, ckList;
	while( 0 == pIRiffStream->Descend( &ckSubChunk, &ckChunk, 0 ) )
	{
		switch( ckSubChunk.ckid )
		{
		case DMUS_FOURCC_DSFX_CHUNK:
			if( ckSubChunk.cksize == sizeof( DX8_BETA1_DSOUND_IO_DXDMO_HEADER ) )
			{
				// Load in the DX8 Beta1 structure
				DX8_BETA1_DSOUND_IO_DXDMO_HEADER ioDMOHeader;
				pStream->Read( &ioDMOHeader, sizeof( DX8_BETA1_DSOUND_IO_DXDMO_HEADER ), &cbRead );
				pioDSoundEffect->ioFXHeader.dwEffectFlags = ioDMOHeader.dsfxd.dwFlags;
				pioDSoundEffect->ioFXHeader.guidDSFXClass = ioDMOHeader.dsfxd.guidDSFXClass;

				// Flag that we loaded in an old-format file
				SetModified( TRUE );
			}
			else
			{
				// Read in the effect header information
				cbToRead = min( ckSubChunk.cksize, sizeof( DSOUND_IO_DXDMO_HEADER ) );
				pStream->Read( &pioDSoundEffect->ioFXHeader, cbToRead, &cbRead );
			}
			break;

		case FOURCC_DMUS_EFFECT_DATA_CHUNK:
			// Release any existing data
			if( pioDSoundEffect->pStreamData )
			{
				pioDSoundEffect->pStreamData->Release();
				pioDSoundEffect->pStreamData = NULL;
			}

			// Try and allocate a new stream to store the data in
			if( SUCCEEDED( theApp.m_pAudioPathComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pioDSoundEffect->pStreamData ) ) )
			{
				// Copy the data to the new stream
				ULARGE_INTEGER uliRead, uliWritten, uliToCopy;
				uliToCopy.QuadPart = ckSubChunk.cksize;
				pStream->CopyTo( pioDSoundEffect->pStreamData, uliToCopy, &uliRead, &uliWritten );
			}
			break;

		case DMUSPROD_FOURCC_EFFECT_GUID_CHUNK:
			if( ckSubChunk.cksize >= sizeof(GUID) )
			{
				pStream->Read( &(pioDSoundEffect->guidDesignGUID), sizeof(GUID), NULL );
			}
			break;

		case FOURCC_LIST:
			switch( ckSubChunk.fccType )
			{
			case DMUS_FOURCC_UNFO_LIST:
				while( 0 == pIRiffStream->Descend( &ckList, &ckSubChunk, 0 ) )
				{
					switch( ckList.ckid )
					{
					case DMUS_FOURCC_UNAM_CHUNK:
						// Read in the effect's instance name
						ReadMBSfromWCS( pStream, ckList.cksize, &pioDSoundEffect->strInstanceName );
						break;

					case FOURCC_EFFECT_NAME_CHUNK:
						// Read in the effect's standard name
						ReadMBSfromWCS( pStream, ckList.cksize, &pioDSoundEffect->strEffectName );
						break;
					}

					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;
			}
			break;
		}

		pIRiffStream->Ascend( &ckSubChunk, 0 );
	}

	// Release the IStream
	pStream->Release();

	// Double-check the effect flags to make sure they are valid
	if( ValidateEffectFlags( pioDSoundEffect->ioFXHeader.guidDSFXClass, pioDSoundEffect->ioFXHeader.dwEffectFlags ) )
	{
		SetModified( TRUE );
	}

	// Make sure the design-time guid is not all zeros
	if( GUID_AllZeros == pioDSoundEffect->guidDesignGUID )
	{
		::CoCreateGuid( &pioDSoundEffect->guidDesignGUID );
	}

	// Make sure strEffectName is not empty
	if( pioDSoundEffect->strEffectName.IsEmpty() )
	{
		WCHAR awchDMOName[65];
		awchDMOName[0] = 0;
		GetDMOName( pioDSoundEffect->ioFXHeader.guidDSFXClass, awchDMOName );
		if( awchDMOName[0] == 0 )
		{
			if( pioDSoundEffect->ioFXHeader.guidDSFXClass == GUID_DSFX_SEND )
			{
				pioDSoundEffect->strEffectName.LoadString( IDS_SEND_TEXT );
			}
			else
			{
				// TODO: Change this to IDS_UNKNOWN_EFFECT_NAME
				pioDSoundEffect->strEffectName.LoadString( IDS_UNKNOWN_SYNTH_NAME );
			}
		}
		else
		{
			pioDSoundEffect->strEffectName = awchDMOName;
		}
	}

	// Make sure strInstanceName is not empty
	if( pioDSoundEffect->strInstanceName.IsEmpty() )
	{
		CString strNbr;
		strNbr.Format( "%d", 1 ); 
		pioDSoundEffect->strInstanceName = pioDSoundEffect->strEffectName + strNbr;
	}

	return pioDSoundEffect;
}


/////////////////////////////////////////////////////////////////////////////
// ValidateBufferFlags

bool ValidateBufferFlags( DWORD &dwBufferFlags )
{
	bool fChanged = false;

	// Verify that DSBCAPS_PRIMARYBUFFER is not set
	if( dwBufferFlags & DSBCAPS_PRIMARYBUFFER )
	{
		dwBufferFlags &= ~DSBCAPS_PRIMARYBUFFER;
		fChanged = true;
	}

	// Verify that none of DSBCAPS_STATIC,
	// DSBCAPS_CTRLPOSITIONNOTIFY, or DSBCAPS_GETCURRENTPOSITION2 are set
	if( dwBufferFlags & (DSBCAPS_STATIC | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_GETCURRENTPOSITION2) )
	{
		dwBufferFlags &= ~(DSBCAPS_STATIC | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_GETCURRENTPOSITION2);
		fChanged = true;
	}

	// Verify that DSBCAPS_MUTE3DATMAXDISTANCE is only set when DSBCAPS_CTRL3D is also set
	if( dwBufferFlags & DSBCAPS_MUTE3DATMAXDISTANCE )
	{
		if( (dwBufferFlags & DSBCAPS_CTRL3D) == 0 )
		{
			dwBufferFlags &= ~DSBCAPS_MUTE3DATMAXDISTANCE;
			fChanged = true;
		}
	}

	// Verify that if DSBCAPS_MIXIN is set, DSBCAPS_LOCDEFER is not set
	if( dwBufferFlags & DSBCAPS_MIXIN )
	{
		if( dwBufferFlags & DSBCAPS_LOCDEFER )
		{
			dwBufferFlags &= ~DSBCAPS_LOCDEFER;
			fChanged = true;
		}
	}

	// Verify that if DSBCAPS_LOCHARDWARE is set, neither DSBCAPS_LOCSOFTWARE nor DSBCAPS_LOCDEFER is set
	if( (dwBufferFlags & DSBCAPS_LOCHARDWARE)
	&&	(dwBufferFlags & (DSBCAPS_LOCSOFTWARE | DSBCAPS_LOCDEFER)) )
	{
		dwBufferFlags &= ~(DSBCAPS_LOCSOFTWARE | DSBCAPS_LOCDEFER);
		fChanged = true;
	}

	// Verify that if DSBCAPS_LOCSOFTWARE is set, DSBCAPS_LOCDEFER is not set
	if( (dwBufferFlags & DSBCAPS_LOCSOFTWARE)
	&&	(dwBufferFlags & DSBCAPS_LOCDEFER) )
	{
		dwBufferFlags &= ~DSBCAPS_LOCDEFER;
		fChanged = true;
	}

	// Verify that if DSBCAPS_GLOBALFOCUS is set, DSBCAPS_STICKYFOCUS is not set
	if( (dwBufferFlags & DSBCAPS_GLOBALFOCUS)
	&&	(dwBufferFlags & DSBCAPS_STICKYFOCUS) )
	{
		dwBufferFlags &= ~DSBCAPS_STICKYFOCUS;
		fChanged = true;
	}

	// Verify that if DSBCAPS_CTRL3D is set, DSBCAPS_CTRLPAN is not set
	if( (dwBufferFlags & DSBCAPS_CTRL3D)
	&&	(dwBufferFlags & DSBCAPS_CTRLPAN) )
	{
		dwBufferFlags &= ~DSBCAPS_CTRLPAN;
		fChanged = true;
	}

	// Verify that either DSBCAPS_CTRL3D or DSBCAPS_CTRLPAN is set
	if( !(dwBufferFlags & DSBCAPS_CTRL3D)
	&&	!(dwBufferFlags & DSBCAPS_CTRLPAN) )
	{
		dwBufferFlags |= DSBCAPS_CTRLPAN;
		fChanged = true;
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_LoadBuffer

HRESULT CDirectMusicAudioPath::DM_LoadBuffer( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk, DMUS_IO_BUFFER_ATTRIBUTES_HEADER &ioBufferHeader, CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers )
{
	// Create a new stucture to store the buffer in
	ioDSoundBuffer *pioDSoundBuffer = new ioDSoundBuffer;

	// Verify that we didn't run out of memory
	if( pioDSoundBuffer == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Copy the buffer header information
	pioDSoundBuffer->ioBufferHeader = ioBufferHeader;

	// Get a pointer to the IStream
	IStream *pStream = pIRiffStream->GetStream();

	MMCKINFO ckSubChunk, ckList;
	DWORD cbToRead, cbRead;
	while( 0 == pIRiffStream->Descend( &ckSubChunk, &ckChunk, 0 ) )
	{
		switch( ckSubChunk.ckid )
		{
		case DMUS_FOURCC_GUID_CHUNK:
			// Read in the GUID for the buffer
			if( ckSubChunk.cksize >= sizeof(GUID) )
			{
				GUID guidBuffer;
				pStream->Read( &guidBuffer, sizeof(GUID), &cbRead );

				// Just verify that it is the same as the GUID in the header
				ASSERT( guidBuffer == ioBufferHeader.guidBufferID );
			}
			else
			{
				ASSERT(FALSE);
			}
			break;

		case DMUS_FOURCC_DSBD_CHUNK:
			if( ckSubChunk.cksize == sizeof( DX8_BETA1_DSOUND_IO_DSBUFFERDESC ) )
			{
				// Load in the DX8 Beta1 structure
				DX8_BETA1_DSOUND_IO_DSBUFFERDESC ioDSBufferDesc;
				pStream->Read( &ioDSBufferDesc, sizeof( DX8_BETA1_DSOUND_IO_DSBUFFERDESC ), &cbRead );
				pioDSoundBuffer->ioDSBufferDesc.dwFlags = ioDSBufferDesc.dsbd.dwFlags;
				pioDSoundBuffer->ioDSBufferDesc.nChannels = ioDSBufferDesc.wfx.nChannels;
				pioDSoundBuffer->ioDSBufferDesc.lVolume = 0;
				pioDSoundBuffer->ioDSBufferDesc.lPan = ioDSBufferDesc.lPan;
				pioDSoundBuffer->ioDSBufferDesc.dwReserved = 0;
				pioDSoundBuffer->ioDS3D.guid3DAlgorithm = ioDSBufferDesc.dsbd.guid3DAlgorithm;

				// Flag that we loaded in an old-format file
				SetModified( TRUE );
			}
			else
			{
				// Read in the buffer descriptor
				cbToRead = min( ckSubChunk.cksize, sizeof( DSOUND_IO_DSBUFFERDESC ) );
				pStream->Read( &pioDSoundBuffer->ioDSBufferDesc, cbToRead, &cbRead );
			}

			// Double-check the buffer flags to make sure they are valid
			if( ValidateBufferFlags( pioDSoundBuffer->ioDSBufferDesc.dwFlags ) )
			{
				SetModified( TRUE );
			}

			// Double-check that the 3D parameter size is set correctly
			if( pioDSoundBuffer->ioDS3D.ds3d.dwSize != sizeof( DS3DBUFFER ) )
			{
				pioDSoundBuffer->ioDS3D.ds3d.dwSize = sizeof( DS3DBUFFER );
				SetModified( TRUE );
			}

			// Double-check that the number of channels is valid
			if( pioDSoundBuffer->ioDSBufferDesc.nChannels > 99 )
			{
				pioDSoundBuffer->ioDSBufferDesc.nChannels = 99;
				SetModified( TRUE );
			}
			break;

		case DMUS_FOURCC_BSID_CHUNK:
			{
				// Read in an array of DWORDs, representing the bus IDs
				DWORD dwTemp;
				long lSize = ckSubChunk.cksize;
				while( lSize >= sizeof(DWORD) )
				{
					pStream->Read( &dwTemp, sizeof(DWORD), &cbRead );

					pioDSoundBuffer->lstBusIDs.Add( dwTemp );
					lSize -= sizeof(DWORD);
				}

				// Fix 46903: DMP: Order of busses not correct if users does not list them in ascending order
				// Bubble sort the BusIDs
				bool fContinue = true;
				while( fContinue )
				{
					fContinue = false;

					for( int nIndex = pioDSoundBuffer->lstBusIDs.GetSize() - 1; nIndex > 0; nIndex-- )
					{
						// nIndex is at least 1
						ASSERT( nIndex > 0 );

						// If the items are out of order
						if( pioDSoundBuffer->lstBusIDs.GetAt( nIndex ) < pioDSoundBuffer->lstBusIDs.GetAt( nIndex - 1 ) )
						{
							// Set fContinue
							fContinue = true;

							// Reverse the items
							DWORD dwTemp = pioDSoundBuffer->lstBusIDs.GetAt( nIndex );
							pioDSoundBuffer->lstBusIDs.SetAt( nIndex, pioDSoundBuffer->lstBusIDs.GetAt( nIndex - 1 ) );
							pioDSoundBuffer->lstBusIDs.SetAt( nIndex - 1, dwTemp );

							// Flag that something changed
							SetModified( TRUE );
						}
					}
				}
			}
			break;

		case DMUS_FOURCC_DS3D_CHUNK:
			if( ckSubChunk.cksize == sizeof( DX8_BETA1_DSOUND_IO_3D ) )
			{
				// Load in the DX8 Beta1 structure
				DX8_BETA1_DSOUND_IO_3D ioDSound3D;
				pStream->Read( &ioDSound3D, sizeof( DX8_BETA1_DSOUND_IO_3D ), &cbRead );
				pioDSoundBuffer->ioDS3D.ds3d = ioDSound3D.ds3d;
				// The 3D guid was loaded from the DMUS_FOURCC_DSBD_CHUNK chunk

				// Flag that we loaded in an old-format file
				SetModified( TRUE );
			}
			else
			{
				// Read in the 3D position
				cbToRead = min( ckSubChunk.cksize, sizeof( DSOUND_IO_3D ) );
				pStream->Read( &pioDSoundBuffer->ioDS3D, cbToRead, &cbRead );
			}
			break;


		case FOURCC_LIST:
			switch( ckSubChunk.fccType )
			{
			case DMUS_FOURCC_UNFO_LIST:
				while( 0 == pIRiffStream->Descend( &ckList, &ckSubChunk, 0 ) )
				{
					switch( ckList.ckid )
					{
					case DMUS_FOURCC_UNAM_CHUNK:
						// Read in the name of the DSound buffer
						ReadMBSfromWCS( pStream, ckList.cksize, &pioDSoundBuffer->strName );
						break;
					}
					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;

			case DMUS_FOURCC_DSBC_LIST:
				while( 0 == pIRiffStream->Descend( &ckList, &ckSubChunk, 0 ) )
				{
					switch( ckList.ckid )
					{
					case FOURCC_RIFF:
						switch( ckList.fccType )
						{
						case DMUS_FOURCC_DSFX_FORM:
							// Load an effect
							ioDSoundEffect *pNewEffect = DM_LoadEffect( pIRiffStream, ckList );
							if( pNewEffect )
							{
								// If the load succeeded, add the effect to the end of the effect chain
								pioDSoundBuffer->lstDSoundEffects.AddTail( pNewEffect );
							}
							break;
						}
						break;
					}
					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;
			}
			break;
		}

		pIRiffStream->Ascend( &ckSubChunk, 0 );
	}

	// Release the IStream
	pStream->Release();

	lstDSoundBuffers.AddTail( pioDSoundBuffer );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_LoadPortConfig

HRESULT CDirectMusicAudioPath::DM_LoadPortConfig( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO &ckChunk, CTypedPtrList< CPtrList, ioPortConfig*> &lstPortConfigs )
{
	// Try and create a new ioPortConfig structure
	ioPortConfig *pioPortConfig = new ioPortConfig;
	if( pioPortConfig == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Get a pointer to the IStream
	IStream *pStream = pIRiffStream->GetStream();

	// Now, descend into each chunk
	MMCKINFO ckSubChunk, ckList;
	DWORD cbRead, cbToRead;
	while( 0 == pIRiffStream->Descend( &ckSubChunk, &ckChunk, 0 ) )
	{
		switch( ckSubChunk.ckid )
		{
		case DMUS_FOURCC_PORTCONFIG_ITEM:
			// Load in the port config data
			cbToRead = min( ckSubChunk.cksize, sizeof( DMUS_IO_PORTCONFIG_HEADER ) );
			pStream->Read( &pioPortConfig->ioPortConfigHeader, cbToRead, &cbRead );
			if( pioPortConfig->ioPortConfigHeader.guidPort == GUID_NULL )
			{
				pioPortConfig->ioPortConfigHeader.guidPort = GUID_Synth_Default;

				// Flag that we loaded in an old-format file
				SetModified( TRUE );
			}
			break;

		case DMUS_FOURCC_PORTPARAMS_ITEM:
			// Load in the port parameters
			cbToRead = min( ckSubChunk.cksize, sizeof( DMUS_PORTPARAMS8 ) );
			pStream->Read( &pioPortConfig->ioPortParams, cbToRead, &cbRead );
			break;

		case FOURCC_LIST:
			switch( ckSubChunk.fccType )
			{
			case DMUS_FOURCC_UNFO_LIST:
				while( 0 == pIRiffStream->Descend( &ckList, &ckSubChunk, 0 ) )
				{
					switch( ckList.ckid )
					{
					case FOURCC_PORT_NAME_CHUNK:
						// Load in the standard name of the port
						ReadMBSfromWCS( pStream, ckList.cksize, &pioPortConfig->strPortName );
						break;
					}
					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;

			case DMUS_FOURCC_PCHANNELS_LIST:
				{
					// Initialize the pointer to the strucutre that stores information for a range of PChannels
					ioPChannelToBuffer *pioPChannelToBuffer = NULL;

					while( 0 == pIRiffStream->Descend( &ckList, &ckSubChunk, 0 ) )
					{
						switch( ckList.ckid )
						{
						case DMUS_FOURCC_PCHANNELS_ITEM:
							// Create a new structure to store the PChannel->Buffer information in
							pioPChannelToBuffer = new ioPChannelToBuffer;

							// Verify that the structure was created
							if( pioPChannelToBuffer )
							{
								// Calculate how much of the structure to read
								cbToRead = min( ckList.cksize, sizeof( DMUS_IO_PCHANNELTOBUFFER_HEADER ) );
								pStream->Read( &pioPChannelToBuffer->ioPChannelToBufferHeader, cbToRead, &cbRead );

								// Check if we read in all of the PChannel->Buffer structure
								if( cbToRead == sizeof( DMUS_IO_PCHANNELTOBUFFER_HEADER ) )
								{
									// Read in the GUIDs stored after the structure
									long lSize = ckList.cksize - cbToRead;

									// Continue while we can read at least one more GUID
									while( lSize >= sizeof(GUID) )
									{
										// Create a new GUID
										GUID *pGuid = new GUID;
										if( pGuid )
										{
											// Verify that the memory allocation succeeded
											pStream->Read( pGuid, sizeof(GUID), &cbRead );

											// Change the GUID if we're using an outdated one
											if( REMOVED_GUID_Buffer_3D == *pGuid )
											{
												*pGuid = GUID_Buffer_3D_Dry;
												SetModified( TRUE );
											}

											pioPChannelToBuffer->lstGuids.AddTail( pGuid );
										}

										// Subtract off the amount of data we read
										lSize -= sizeof(GUID);
									}
								}

								// Add the PChannel->Buffer configuration data to the port configuration
								pioPortConfig->lstPChannelToBuffer.AddTail( pioPChannelToBuffer );
							}
							break;

						case DMUSPROD_FOURCC_BUFFER_DESIGN_GUID_CHUNK:
							if( pioPChannelToBuffer )
							{
								// Read in the GUIDs
								long lSize = ckList.cksize;
								while( lSize >= sizeof( GUID ) )
								{
									GUID *pGUID = new GUID;
									pStream->Read( pGUID, sizeof(GUID), NULL );
									lSize -= sizeof( GUID );
									pioPChannelToBuffer->lstDesignGuids.AddTail( pGUID );
								}
							}
							break;

						case FOURCC_LIST:
							switch( ckList.fccType )
							{
							case DMUS_FOURCC_UNFO_LIST:
								MMCKINFO ckSubList;
								while( 0 == pIRiffStream->Descend( &ckSubList, &ckList, 0 ) )
								{
									switch( ckSubList.ckid )
									{
									case DMUS_FOURCC_UNAM_CHUNK:
										// If the PChannel->Buffer structure was created (it should have been)
										if( pioPChannelToBuffer )
										{
											// Read in the name of the Mix Group that created this
											// range of PChannels
											ReadMBSfromWCS( pStream, ckList.cksize, &pioPChannelToBuffer->strMixGroupName );
										}
										break;
									}
									pIRiffStream->Ascend( &ckList, 0 );
								}
								break;
							}
							break;
						}

						pIRiffStream->Ascend( &ckList, 0 );
					}
				}
				break;

			case DMUSPROD_FOURCC_PORT_DESIGN_LIST:
				{
					// Initialize the pointer to the strucutre that stores information for a range of PChannels
					ioDesignMixGroup *pioDesignMixGroup = NULL;

					while( 0 == pIRiffStream->Descend( &ckList, &ckSubChunk, 0 ) )
					{
						switch( ckList.ckid )
						{
						case DMUSPROD_FOURCC_PORT_DESIGN_MIXGROUP_CHUNK:
							// Create a new structure to store the PChannel->Buffer information in
							pioDesignMixGroup = new ioDesignMixGroup;

							// Verify that the structure was created
							if( pioDesignMixGroup )
							{
								// Calculate how much of the structure to read
								cbToRead = min( ckList.cksize, sizeof( DWORD ) * 2 );
								pStream->Read( &pioDesignMixGroup->dwPChannelStart, min( sizeof(DWORD), cbToRead ), &cbRead );
								pStream->Read( &pioDesignMixGroup->dwPChannelSpan, min( sizeof(DWORD), cbToRead - sizeof(DWORD) ), &cbRead );

								// Add the PChannel->MixGroup configuration data to the port configuration
								pioPortConfig->lstDesignMixGroup.AddTail( pioDesignMixGroup );
							}
							break;

						case FOURCC_LIST:
							switch( ckList.fccType )
							{
							case DMUS_FOURCC_UNFO_LIST:
								MMCKINFO ckSubList;
								while( 0 == pIRiffStream->Descend( &ckSubList, &ckList, 0 ) )
								{
									switch( ckSubList.ckid )
									{
									case DMUS_FOURCC_UNAM_CHUNK:
										// If the PChannel->MixGroup structure was created (it should have been)
										if( pioDesignMixGroup )
										{
											// Read in the name of the Mix Group that created this
											// range of PChannels
											ReadMBSfromWCS( pStream, ckList.cksize, &pioDesignMixGroup->strMixGroupName );
										}
										break;
									}
									pIRiffStream->Ascend( &ckList, 0 );
								}
								break;
							}
							break;
						}

						pIRiffStream->Ascend( &ckList, 0 );
					}
				}
				break;
			}
		}

		pIRiffStream->Ascend( &ckSubChunk, 0 );
	}

	// Release the IStream
	pStream->Release();

	// Add the port configuration to the list that was passed in
	lstPortConfigs.AddTail( pioPortConfig );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SetSplitterPos

void CDirectMusicAudioPath::SetSplitterPos( WORD pos, bool bMarkAsDirty )
{
	m_wSplitterPos = pos;
	if(bMarkAsDirty)
	{
		m_fModified = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetNewMixgroupName

CString CDirectMusicAudioPath::GetNewMixgroupName( void ) const
{
	// Load the default mixgroup name
	CString strOrigName;
	strOrigName.LoadString( IDS_DEFAULT_MIXGROUP_NAME );

	// Get the length of the default mixgroup name
	int nOrigNameLength = strOrigName.GetLength();

	// Start with mix group 1
	int i = 0;

	// Temporary variable for the mixgroup number
	CString strNbr;
	
	// Temporary variable for the mixgroup name
	CString strNewName	= strOrigName;

	// Make sure name is unique
	while( !IsMixgroupNameUnique( NULL, strNewName ) )
	{
		strNbr.Format( "%d", ++i ); 
		int nNbrLength = strNbr.GetLength();
		
		if( (nOrigNameLength + nNbrLength) <= DMUS_MAX_NAME )
		{
			strNewName = strOrigName + strNbr;
		}
		else
		{
			strNewName = strOrigName.Left(DMUS_MAX_NAME - nNbrLength) + strNbr;
		}
	}

	return strNewName;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::IsMixgroupNameUnique

bool CDirectMusicAudioPath::IsMixgroupNameUnique( const ItemInfo *pItemInfo, const CString cstrName ) const
{
	POSITION pos = m_lstItems.GetHeadPosition();
	while( pos )
	{
		ItemInfo *pTmpItemInfo = m_lstItems.GetNext( pos );
		if( pTmpItemInfo != pItemInfo
		&&	pTmpItemInfo->strBandName == cstrName )
		{
			return false;
		}
	}

	// Ensure the reserved "Standard Env. Reverb" name isn't used
	CString strEnvReverb;
	if( strEnvReverb.LoadString( IDS_BUFFER_ENVREVERB )
	&&	cstrName == strEnvReverb )
	{
		return false;
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::IsEffectNameUnique

bool CDirectMusicAudioPath::IsEffectNameUnique( const EffectInfo *pEffectInfo, const CString cstrName ) const
{
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pItemInfo = m_lstItems.GetNext( posItem );

		// If the port doesn't support buffers, skip it
		if( !ItemSupportsBuffers( pItemInfo ) )
		{
			continue;
		}

		// Iterate through the list of buffers
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			// If the buffer does not support effects, skip it
			if( !ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
			{
				continue;
			}

			// Iterate through the list of effects
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );

				// Check if this is the effect we're looking for
				if( (&(pBusEffectInfo->m_EffectInfo) != pEffectInfo)
				&&	(pBusEffectInfo->m_EffectInfo.m_strInstanceName == cstrName) )
				{
					// Found a matching effect
					return false;
				}
			}
		}
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SaveUndoState

void CDirectMusicAudioPath::SaveUndoState( bool &fIgnoreChange, const int nStringID, const bool fSetModified )
{
	if( !fIgnoreChange )
	{
		fIgnoreChange = true;
		SaveUndoState( nStringID, fSetModified );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SaveUndoState

void CDirectMusicAudioPath::SaveUndoState( const int nStringID, const bool fSetModified )
{
	m_pUndoMgr->SaveState( this, theApp.m_hInstance, nStringID );
	if( fSetModified )
	{
		SetModified( fSetModified );

		// Notify connected nodes that AudioPath name has changed
		theApp.m_pAudioPathComponent->m_pIFramework->NotifyNodes( this, AUDIOPATH_DirtyNotification, NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::EnumeratePorts

void CDirectMusicAudioPath::EnumeratePorts( void )
{
	// Iterate through all ports
	DMUS_PORTCAPS dmpc;
	for(DWORD dwIndex = 0; ; dwIndex++)
	{
		// Initialize dmpc
		ZeroMemory(&dmpc, sizeof(dmpc));
		dmpc.dwSize = sizeof(DMUS_PORTCAPS);

		// Get the port's capabilities
		const HRESULT hr = theApp.m_pAudioPathComponent->m_pIDMusic->EnumPort(dwIndex, &dmpc);

		// If we succeeded and didn't hit the end of the list
		if(SUCCEEDED(hr) && (hr != S_FALSE) )
		{
			// Only add the output ports
			if( dmpc.dwClass == DMUS_PC_OUTPUTCLASS )
			{
				PortOptions *pPortOptions = new PortOptions;
				pPortOptions->m_dwEffects = 0;
				pPortOptions->m_dwSupportedEffects = dmpc.dwEffectFlags;
				pPortOptions->m_dwSampleRate = 22050;
				if( dmpc.dwMaxVoices == 0xFFFFFFFF )
				{
					pPortOptions->m_dwVoices = 0xFFFFFFFF;
					pPortOptions->m_dwMaxVoices = 0xFFFFFFFF;
				}
				else
				{
					pPortOptions->m_dwVoices = max( DEFAULT_NUM_VOICES, dmpc.dwMaxVoices );
					pPortOptions->m_dwMaxVoices = dmpc.dwMaxVoices;
				}
				pPortOptions->m_guidPort = dmpc.guidPort;
				pPortOptions->m_strName = dmpc.wszDescription;
				pPortOptions->m_fAudioPath = dmpc.dwFlags & DMUS_PC_AUDIOPATH ? true : false;
				m_lstPortOptions.AddTail( pPortOptions );
			}
		}
		else
		{
			break;
		}
	}

	// Add the default port
	PortOptions *pPortOptions = new PortOptions;
	pPortOptions->m_dwEffects = 0;
	pPortOptions->m_dwSupportedEffects = 0;
	pPortOptions->m_dwSampleRate = 22050;
	pPortOptions->m_dwVoices = 0xFFFFFFFF;
	pPortOptions->m_dwMaxVoices = 0xFFFFFFFF;
	pPortOptions->m_guidPort = GUID_Synth_Default;
	pPortOptions->m_strName.LoadString( IDS_DEFAULT_PORT );
	pPortOptions->m_fAudioPath = true;
	m_lstPortOptions.AddTail( pPortOptions );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetUniqueEffectInstanceNameIfNecessary

void CDirectMusicAudioPath::GetUniqueEffectInstanceNameIfNecessary( EffectInfo *pEffectInfo )
{
	// Iterate through the items in the tree
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pItemInfo = m_lstItems.GetNext( posItem );

		// If the port doesn't support buffers, skip it
		if( !ItemSupportsBuffers( pItemInfo ) )
		{
			continue;
		}

		// Iterate through the list of buffers
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			// If the buffer does not support effects, skip it
			if( !ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
			{
				continue;
			}

			// Iterate through the list of effects
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );

				// Check if this is the effect we're looking for
				if( pBusEffectInfo->m_EffectInfo.IsEqualExceptName( pEffectInfo )
				&&	(pEffectInfo != &pBusEffectInfo->m_EffectInfo)
				&&	(pBusEffectInfo->m_EffectInfo.m_strInstanceName == pEffectInfo->m_strInstanceName)
				&&	(pBusEffectInfo->m_EffectInfo.m_strName == pEffectInfo->m_strName) )
				{
					// Matching effect already exists, so don't change the effect's name
					return;
				}
			}
		}
	}

	// Ensure the effect's name is unique
	GetUniqueEffectInstanceName( pEffectInfo );

	return;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::PastePortOptionsHelper

PortOptions *CDirectMusicAudioPath::PastePortOptionsHelper( PortOptions *pPortOptions )
{
	// Iterate through the list of ports
	POSITION pos = m_lstPortOptions.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each port
		PortOptions *pTmpPortOptions = m_lstPortOptions.GetNext( pos );

		// Check if the ports have the same GUID
		if( pTmpPortOptions->m_guidPort == pPortOptions->m_guidPort )
		{
			// Delete pPortOptions, since it's not necessary
			delete pPortOptions;

			// Port already exists, so just use pTmpPortOptions
			// (don't copy the data from pPortOptions)
			return pTmpPortOptions;
		}
	}

	// Iinsert the new port in our list and return it
	m_lstPortOptions.AddTail( pPortOptions );

	return pPortOptions;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::FindPort

PortOptions *CDirectMusicAudioPath::FindPort( REFGUID rGUIDPort )
{
	// Iterate through the list of ports
	POSITION pos = m_lstPortOptions.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each port
		PortOptions *pTmpPortOptions = m_lstPortOptions.GetNext( pos );

		// Check if we found the GUID
		if( pTmpPortOptions->m_guidPort == rGUIDPort )
		{
			// Port exists, so return pTmpPortOptions
			return pTmpPortOptions;
		}
	}

	// Not found
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::LoadEffect

EffectInfo *CDirectMusicAudioPath::LoadEffect( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent )
{
	// Create a new EffectInfo structure
	EffectInfo *pNewEffectInfo = new EffectInfo();

	// Try and read in the effect
	if( SUCCEEDED(pNewEffectInfo->Read( pIRiffStream, pckParent )) )
	{
		// If the read succeeded, return the effect we read
		// The caller is responsible for making sure the effect's name is unique
		return pNewEffectInfo;
	}
	else
	{
		// Otherwise, delete the effect
		delete pNewEffectInfo;
		return NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::LoadEffect

EffectInfo *CDirectMusicAudioPath::LoadEffect( IStream *pIStream )
{
	// Create a new EffectInfo structure
	EffectInfo *pNewEffectInfo = new EffectInfo();

	// Try and read in the effect
	if( SUCCEEDED(pNewEffectInfo->Read( pIStream )) )
	{
		// If the read succeeded, return the effect we read
		// The caller is responsible for making sure the effect's name is unique
		return pNewEffectInfo;
	}
	else
	{
		// Otherwise, delete the effect
		delete pNewEffectInfo;
		return NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetUniqueMixGroupName

void CDirectMusicAudioPath::GetUniqueMixGroupName( ItemInfo *pItemInfo )
{
	// Skip Env Reverb items
	if( IsItemEnvReverb( pItemInfo ) )
	{
		return;
	}

	// Ensure the name isn't already too long
	if( pItemInfo->strBandName.GetLength() > DMUS_MAX_NAME )
	{
		pItemInfo->strBandName = pItemInfo->strBandName.Left( DMUS_MAX_NAME );
		pItemInfo->strBandName.TrimRight();
	}

	// Copy the original name
	CString	strOrigName = pItemInfo->strBandName;

	// The string to store the number in
	CString	strNbr;
	while( !strOrigName.IsEmpty()  &&  _istdigit(strOrigName[strOrigName.GetLength() - 1]) )
	{
		strNbr = strOrigName.Right(1) + strNbr;
		strOrigName = strOrigName.Left( strOrigName.GetLength() - 1 );
	}

	// Save the length of the textual part of the original name
	const int nOrigNameLength = strOrigName.GetLength();

	// Set the first number to use
	int	i = _ttoi( strNbr );

	// Continue until we find a unique mix group name
	while( IsMixgroupNameUnique( pItemInfo, pItemInfo->strBandName ) == FALSE )
	{
		// Convert from a number to a string
		strNbr.Format( "%d", ++i ); 

		// Get the length of the number text
		int	nNbrLength = strNbr.GetLength();

		// Ensure the name doesn't go longer than DMUS_MAX_NAME
		if( (nOrigNameLength + nNbrLength) <= DMUS_MAX_NAME )
		{
			pItemInfo->strBandName = strOrigName + strNbr;
		}
		else
		{
			pItemInfo->strBandName = strOrigName.Left(DMUS_MAX_NAME - nNbrLength) + strNbr;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetUniqueEffectInstanceName

void CDirectMusicAudioPath::GetUniqueEffectInstanceName( EffectInfo *pEffectInfo )
{
	// Make sure the instance name and effect name don't match
	if( pEffectInfo->m_strInstanceName == pEffectInfo->m_strName )
	{
		CString strNum;
		strNum.Format("%d",1);
		pEffectInfo->m_strInstanceName += strNum;
	}

	// Ensure the name isn't already too long
	if( pEffectInfo->m_strInstanceName.GetLength() > DMUS_MAX_NAME )
	{
		pEffectInfo->m_strInstanceName = pEffectInfo->m_strInstanceName.Left( DMUS_MAX_NAME );
		pEffectInfo->m_strInstanceName.TrimRight();
	}

	// Copy the original name
	CString	strOrigName = pEffectInfo->m_strInstanceName;

	// If the original name is empty, copy the effect name
	if( strOrigName.IsEmpty() )
	{
		pEffectInfo->m_strInstanceName = pEffectInfo->m_strName;
		strOrigName = pEffectInfo->m_strName;
	}

	// The string to store the number in
	CString	strNbr;
	while( !strOrigName.IsEmpty()  &&  _istdigit(strOrigName[strOrigName.GetLength() - 1]) )
	{
		strNbr = strOrigName.Right(1) + strNbr;
		strOrigName = strOrigName.Left( strOrigName.GetLength() - 1 );
	}

	// Save the length of the textual part of the original name
	const int nOrigNameLength = strOrigName.GetLength();

	// Set the first number to use
	int	i = _ttoi( strNbr );

	// Continue until we find a unique effect
	while( (pEffectInfo->m_strInstanceName == pEffectInfo->m_strName)
		||	IsEffectNameUnique( pEffectInfo, pEffectInfo->m_strInstanceName ) == FALSE )
	{
		// Convert from a number to a string
		strNbr.Format( "%d", ++i ); 

		// Get the length of the number text
		int	nNbrLength = strNbr.GetLength();

		// Ensure the name doesn't go longer than DMUS_MAX_NAME
		if( (nOrigNameLength + nNbrLength) <= DMUS_MAX_NAME )
		{
			pEffectInfo->m_strInstanceName = strOrigName + strNbr;
		}
		else
		{
			pEffectInfo->m_strInstanceName = strOrigName.Left(DMUS_MAX_NAME - nNbrLength) + strNbr;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SaveToConfigObject

HRESULT CDirectMusicAudioPath::SaveToConfigObject ( IUnknown *punkAudioPathConfig )
{
	ASSERT( punkAudioPathConfig );
	if( punkAudioPathConfig == NULL )
	{
		return E_POINTER;
	}

	//CWaitCursor wait;

	// Try and create a memory stream
	IStream* pIMemStream;
	HRESULT hr = theApp.m_pAudioPathComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		// Save ourself to the memory stream
		hr = DM_SaveAudioPath( pIMemStream );
		if( SUCCEEDED ( hr ) )
		{
			// Query the config object for an IPersistStream interface
			IPersistStream* pIPersistStream;
			hr = punkAudioPathConfig->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
			if( SUCCEEDED ( hr ) )
			{
				// Seek back to the start of the stream
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );

				// Try and load the config object with the stream
				hr = pIPersistStream->Load( pIMemStream );

				RELEASE( pIPersistStream );
			}
		}

		RELEASE( pIMemStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// RemoveDuplicateBuffers

void RemoveDuplicateBuffers( CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers )
{
	POSITION pos = lstDSoundBuffers.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		const POSITION posCurrent = pos;

		// Get a pointer to the current buffer
		ioDSoundBuffer *pBuffer = lstDSoundBuffers.GetNext( pos );

		// Iterate through all the buffers before ours
		POSITION posTmp = lstDSoundBuffers.GetHeadPosition();
		while( posCurrent != posTmp )
		{
			// Save the position 
			// Get a pointer to the buffer
			ioDSoundBuffer *pTmpBuffer = lstDSoundBuffers.GetNext( posTmp );

			// If the buffer GUIDs are identical
			if( pTmpBuffer->ioBufferHeader.guidBufferID == pBuffer->ioBufferHeader.guidBufferID )
			{
				// Delete and remove pBuffer
				delete pBuffer;
				lstDSoundBuffers.RemoveAt( posCurrent );

				// Break out of the while loop
				break;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_SaveAudioPath

HRESULT CDirectMusicAudioPath::DM_SaveAudioPath( IStream *pIStream )
{
	ASSERT( pIStream );
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Allocate a RIFF stream
	IDMUSProdRIFFStream *pRiffStream;
	HRESULT hr = AllocRIFFStream( pIStream, &pRiffStream );
	if( FAILED( hr ) )
	{
		return hr;
	}

	// Find out what type of save to do (runtime vs. design-time)
	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Create the main audiopath chunk
	MMCKINFO ckMain;
	ckMain.fccType = DMUS_FOURCC_AUDIOPATH_FORM;
	if( 0 == pRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) )
	{
		// Save the AudioPath's GUID
		SaveGUID( pRiffStream );

		// Check if we're writing a design file
		if( StreamInfo.ftFileType == FT_DESIGN )
		{
			// Create the design-time list chunk
			MMCKINFO ckDesign;
			ckDesign.fccType = DMUSPROD_FOURCC_AUDIOPATH_DESIGN_LIST;
			if( 0 == pRiffStream->CreateChunk( &ckDesign, MMIO_CREATELIST ) )
			{
				// Save out the UI information
				DM_SaveUIDesign( pRiffStream );

				// Ascend out of the design-time list chunk
				pRiffStream->Ascend( &ckDesign, 0 );
			}
		}

		// Save the AudioPath's version
		SaveVersion( pRiffStream );

		// Save the AudioPath's UNFO list
		SaveInfoList( pRiffStream );

		// Save optional toolgraph, but only if we're not saving to an AudioPathConfig object
		if( m_pIToolGraphNode
		&& (StreamInfo.guidDataFormat != GUID_DirectMusicObject) )
		{
			IPersistStream* pIPersistStream;
			hr = m_pIToolGraphNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( FAILED( hr ) )
			{
				return hr;
			}

			hr = pIPersistStream->Save( pIStream, FALSE );
			pIPersistStream->Release();
			if( FAILED( hr ) )
			{
				return hr;
			}
		}

		CTypedPtrList< CPtrList, ioPortConfig*> lstPortConfigs;
		CTypedPtrList< CPtrList, ioDSoundBuffer*> lstDSoundBuffers;

		// Iterate through all mix groups
		DWORD dwDisplayIndex = 0;
		while( dwDisplayIndex < unsigned(m_lstItems.GetCount()) )
		{
			POSITION pos = m_lstItems.GetHeadPosition();
			while( pos )
			{
				const ItemInfo *pItemInfo = m_lstItems.GetNext( pos );
				if( dwDisplayIndex == pItemInfo->dwDisplayIndex )
				{
					// Convert mix group (this adds the buffers at the end of lstDSoundBuffers)
					pItemInfo->ConvertToDMusic( lstPortConfigs, lstDSoundBuffers );
					break;
				}
			}
			dwDisplayIndex++;
		}

		// Remove duplicate buffers
		RemoveDuplicateBuffers( lstDSoundBuffers );

		// TODO: Look through lstPortConfigs for adjacent ports that can be
		// merged together (ConvertToDMusic can't catch them all).

		// Check if there are any ports to create
		if( !lstPortConfigs.IsEmpty() )
		{
			// Create the port configs list chunk
			MMCKINFO ckPortConfigsList;
			ckPortConfigsList.fccType = DMUS_FOURCC_PORTCONFIGS_LIST;
			if( 0 == pRiffStream->CreateChunk( &ckPortConfigsList, MMIO_CREATELIST ) )
			{
				// Now, save all port config chunks
				while( !lstPortConfigs.IsEmpty() )
				{
					ioPortConfig *pioPortConfig = lstPortConfigs.RemoveHead();

					// Create the port config list chunk
					MMCKINFO ckPortConfigList;
					ckPortConfigList.fccType = DMUS_FOURCC_PORTCONFIG_LIST;
					if( 0 == pRiffStream->CreateChunk( &ckPortConfigList, MMIO_CREATELIST ) )
					{
						// Create the port config header chunk
						MMCKINFO ckSubChunk;
						ckSubChunk.ckid = DMUS_FOURCC_PORTCONFIG_ITEM;
						if( 0 == pRiffStream->CreateChunk( &ckSubChunk, 0 ) )
						{
							DWORD cbWritten;
							pIStream->Write( &(pioPortConfig->ioPortConfigHeader), sizeof(DMUS_IO_PORTCONFIG_HEADER), &cbWritten );

							// Ascend out of the port config header chunk
							pRiffStream->Ascend( &ckSubChunk, 0 );
						}

						// Create the port params chunk
						ckSubChunk.ckid = DMUS_FOURCC_PORTPARAMS_ITEM;
						if( 0 == pRiffStream->CreateChunk( &ckSubChunk, 0 ) )
						{
							DWORD cbWritten;
							pIStream->Write( &(pioPortConfig->ioPortParams), sizeof(DMUS_PORTPARAMS8), &cbWritten );

							// Ascend out of the port params chunk
							pRiffStream->Ascend( &ckSubChunk, 0 );
						}

						// Check if the port name is not empty and we're writing a design file
						if( !pioPortConfig->strPortName.IsEmpty()
						&&	StreamInfo.ftFileType == FT_DESIGN )
						{
							// The port name is not empty, so create an UNFO list
							ckSubChunk.fccType = DMUS_FOURCC_UNFO_LIST;
							if( 0 == pRiffStream->CreateChunk( &ckSubChunk, MMIO_CREATELIST ) )
							{
								// Store port name in a PORT_NAME chunk
								MMCKINFO ckName;
								ckName.ckid = FOURCC_PORT_NAME_CHUNK;
								if( 0 == pRiffStream->CreateChunk( &ckName, 0 ) )
								{
									SaveMBStoWCS( pIStream, &(pioPortConfig->strPortName) );

									// Ascend out of the PORT_NAME chunk
									pRiffStream->Ascend( &ckName, 0 );
								}

								// Ascend out of the UNFO list
								pRiffStream->Ascend( &ckSubChunk, 0 );
							}
						}

						if( (pioPortConfig->ioPortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH)
						&&	!pioPortConfig->lstPChannelToBuffer.IsEmpty() )
						{
							// At least one PChannel->Buffer assignment,
							// create the list of PChannel to buffer assignments,
							ckSubChunk.fccType = DMUS_FOURCC_PCHANNELS_LIST;
							if( 0 == pRiffStream->CreateChunk( &ckSubChunk, MMIO_CREATELIST ) )
							{
								// Save out each PChannel to buffer assignment in its own chunk
								while( !pioPortConfig->lstPChannelToBuffer.IsEmpty() )
								{
									// Get a pointer to the PChannel->Buffer assigment information
									ioPChannelToBuffer *pioPChannelToBuffer = pioPortConfig->lstPChannelToBuffer.RemoveHead();

									// Create a PChannel->Buffer assignment chunk
									MMCKINFO ckPChannel;
									ckPChannel.ckid = DMUS_FOURCC_PCHANNELS_ITEM;
									if( 0 == pRiffStream->CreateChunk( &ckPChannel, 0 ) )
									{
										// Write the header information
										DWORD cbWritten;
										pIStream->Write( &pioPChannelToBuffer->ioPChannelToBufferHeader, sizeof(DMUS_IO_PCHANNELTOBUFFER_HEADER), &cbWritten );

										// Write out the list of GUIDs
										while( !pioPChannelToBuffer->lstGuids.IsEmpty() )
										{
											// Get a pointer to each GUID
											GUID *pGuid = pioPChannelToBuffer->lstGuids.RemoveHead();

											// Write out the GUID
											pIStream->Write( pGuid, sizeof(GUID), &cbWritten );

											// Delete the GUID
											delete pGuid;
										}

										// Ascend out of the PChannel->Buffer assignment chunk
										pRiffStream->Ascend( &ckPChannel, 0 );
									}

									// Check if we're writing a design-time file
									if( StreamInfo.ftFileType == FT_DESIGN )
									{
										// Check if there is a Mix Group name
										if( !pioPChannelToBuffer->strMixGroupName.IsEmpty() )
										{
											// There is a Mix Group name - create an UNFO list
											MMCKINFO ckUnfo;
											ckUnfo.fccType = DMUS_FOURCC_UNFO_LIST;
											if( 0 == pRiffStream->CreateChunk( &ckUnfo, MMIO_CREATELIST ) )
											{
												// Create an UNAM chunk to store the name in
												MMCKINFO ckName;
												ckName.ckid = DMUS_FOURCC_UNAM_CHUNK;
												if( 0 == pRiffStream->CreateChunk( &ckName, 0 ) )
												{
													// Write out the Mix Group name
													SaveMBStoWCS( pIStream, &(pioPChannelToBuffer->strMixGroupName) );

													// Ascend out of the UNAM chunk
													pRiffStream->Ascend( &ckName, 0 );
												}

												// Ascend out of the UNFO list
												pRiffStream->Ascend( &ckUnfo, 0 );
											}
										}

										// Write out the design GUID array, if necessary
										if( !pioPChannelToBuffer->lstDesignGuids.IsEmpty() )
										{
											// Create an chunk to store the list of GUIDS in
											MMCKINFO ckDesignGUID;
											ckDesignGUID.ckid = DMUSPROD_FOURCC_BUFFER_DESIGN_GUID_CHUNK;
											if( 0 == pRiffStream->CreateChunk( &ckDesignGUID, 0 ) )
											{
												// Write out the GUIDs
												POSITION pos = pioPChannelToBuffer->lstDesignGuids.GetHeadPosition();
												while( pos )
												{
													pIStream->Write( pioPChannelToBuffer->lstDesignGuids.GetNext( pos ), sizeof(GUID), NULL );
												}

												// Ascend out of the UNAM chunk
												pRiffStream->Ascend( &ckDesignGUID, 0 );
											}
										}
									}

									// Delete the PChannel->Buffer assignment information
									delete pioPChannelToBuffer;
								}

								// Ascend out of the PChannel->Buffer assignment list
								pRiffStream->Ascend( &ckSubChunk, 0 );
							}
						}

						if( !pioPortConfig->lstDesignMixGroup.IsEmpty() )
						{
							// At least one PChannel->MixGroup assignment,
							// create the list of PChannel to buffer assignments,
							ckSubChunk.fccType = DMUSPROD_FOURCC_PORT_DESIGN_LIST;
							if( 0 == pRiffStream->CreateChunk( &ckSubChunk, MMIO_CREATELIST ) )
							{
								// Save out each PChannel to MixGroup assignment in its own chunk
								while( !pioPortConfig->lstDesignMixGroup.IsEmpty() )
								{
									// Get a pointer to the PChannel->MixGroup assigment information
									ioDesignMixGroup *pioDesignMixGroup = pioPortConfig->lstDesignMixGroup.RemoveHead();

									// Create a PChannel->MixGroup assignment chunk
									MMCKINFO ckPChannel;
									ckPChannel.ckid = DMUSPROD_FOURCC_PORT_DESIGN_MIXGROUP_CHUNK;
									if( 0 == pRiffStream->CreateChunk( &ckPChannel, 0 ) )
									{
										// Write the header information
										DWORD cbWritten;
										pIStream->Write( &pioDesignMixGroup->dwPChannelStart, sizeof(DWORD), &cbWritten );
										pIStream->Write( &pioDesignMixGroup->dwPChannelSpan, sizeof(DWORD), &cbWritten );

										// Ascend out of the PChannel->Buffer assignment chunk
										pRiffStream->Ascend( &ckPChannel, 0 );
									}

									// Check if there is a Mix Group name and we're writing a design-time file
									if( !pioDesignMixGroup->strMixGroupName.IsEmpty()
									&&	StreamInfo.ftFileType == FT_DESIGN )
									{
										// There is a Mix Group name - create an UNFO list
										MMCKINFO ckUnfo;
										ckUnfo.fccType = DMUS_FOURCC_UNFO_LIST;
										if( 0 == pRiffStream->CreateChunk( &ckUnfo, MMIO_CREATELIST ) )
										{
											// Create an UNAM chunk to store the name in
											MMCKINFO ckName;
											ckName.ckid = DMUS_FOURCC_UNAM_CHUNK;
											if( 0 == pRiffStream->CreateChunk( &ckName, 0 ) )
											{
												// Write out the Mix Group name
												SaveMBStoWCS( pIStream, &(pioDesignMixGroup->strMixGroupName) );

												// Ascend out of the UNAM chunk
												pRiffStream->Ascend( &ckName, 0 );
											}

											// Ascend out of the UNFO list
											pRiffStream->Ascend( &ckUnfo, 0 );
										}
									}

									// Delete the PChannel->MixGroup assignment information
									delete pioDesignMixGroup;
								}

								// Ascend out of the PChannel->MixGroup assignment list
								pRiffStream->Ascend( &ckSubChunk, 0 );
							}
						}

						// Ascend out of the port config list chunk
						pRiffStream->Ascend( &ckPortConfigList, 0 );
					}

					// Delete the port config information
					delete pioPortConfig;
				}

				// Ascend out of the port configs list chunk
				pRiffStream->Ascend( &ckPortConfigsList, 0 );
			}
		}

		// Write out the buffer list
		while( !lstDSoundBuffers.IsEmpty() )
		{
			ioDSoundBuffer *pioDSoundBuffer = lstDSoundBuffers.RemoveHead();

			MMCKINFO ckBufferList;
			ckBufferList.fccType = DMUS_FOURCC_DSBUFFER_LIST;
			if( 0 == pRiffStream->CreateChunk( &ckBufferList, MMIO_CREATELIST ) )
			{
				MMCKINFO ckBufferAttrib;
				ckBufferAttrib.ckid = DMUS_FOURCC_DSBUFFATTR_ITEM;
				if( 0 == pRiffStream->CreateChunk( &ckBufferAttrib, 0 ) )
				{
					// Write out the buffer header
					DWORD cbWritten;
					pIStream->Write( &pioDSoundBuffer->ioBufferHeader, sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER), &cbWritten );

					pRiffStream->Ascend( &ckBufferAttrib, 0 );
				}

				// If not using a standard buffer
				if( !(pioDSoundBuffer->ioBufferHeader.dwFlags & DMUS_BUFFERF_DEFINED) )
				{
					// Save out the buffer information
					DM_SaveDSBC_Form( pRiffStream, pioDSoundBuffer, StreamInfo );
				}

				// Check if the name is not empty and we're writing a design file
				if( !pioDSoundBuffer->strName.IsEmpty()
				&&	StreamInfo.ftFileType == FT_DESIGN )
				{
					MMCKINFO ckBufferUnfo;
					ckBufferUnfo.fccType = DMUS_FOURCC_UNFO_LIST;
					if( 0 == pRiffStream->CreateChunk( &ckBufferUnfo, MMIO_CREATELIST ) )
					{
						MMCKINFO ckBufferName;
						ckBufferName.ckid = DMUS_FOURCC_UNAM_CHUNK;
						if( 0 == pRiffStream->CreateChunk( &ckBufferName, 0 ) )
						{
							SaveMBStoWCS( pIStream, &(pioDSoundBuffer->strName) );

							pRiffStream->Ascend( &ckBufferName, 0 );
						}

						pRiffStream->Ascend( &ckBufferUnfo, 0 );
					}
				}

				pRiffStream->Ascend( &ckBufferList, 0 );
			}

			delete pioDSoundBuffer;
		}

		// Ascend out of the main chunk
		pRiffStream->Ascend( &ckMain, 0 );

		// We succeeded
		hr = S_OK;
	}
	else
	{
		// Unable to create chunk - return failure code
		hr = E_FAIL;
	}

	// Release the RIFF stream
	pRiffStream->Release();

	// Return the result
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DM_SaveUIDesign

HRESULT CDirectMusicAudioPath::DM_SaveUIDesign( IDMUSProdRIFFStream *pIRiffStream )
{
	IStream *pIStream = pIRiffStream->GetStream();
	if( pIStream == NULL )
	{
		return E_FAIL;
	}

	// Create a chunk to store the UI information in 
	MMCKINFO ckUI;
	ckUI.ckid = DMUSPROD_FOURCC_AUDIOPATH_UI_CHUNK;
	if( 0 == pIRiffStream->CreateChunk( &ckUI, 0 ) )
	{
		// Write the UI data
		ioAudioPathUI oAudioPathUI;
		ZeroMemory( &oAudioPathUI, sizeof(ioAudioPathUI) );

		oAudioPathUI.wSplitterPos = m_wSplitterPos;
		oAudioPathUI.wMixGroupWidth = m_wMixGroupWidth;
		oAudioPathUI.wBusWidth = m_wBusWidth;
		oAudioPathUI.wBufferWidth = m_wBufferWidth;
		oAudioPathUI.wEffectWidth = m_wEffectWidth;

		pIStream->Write( &oAudioPathUI, sizeof( ioAudioPathUI ), NULL );

		// Ascend out of the main effect palette LIST chunk
		pIRiffStream->Ascend( &ckUI, 0 );
	}

	// Release the IStream interface
	pIStream->Release();

	// We succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreatePortOptions

PortOptions *CDirectMusicAudioPath::CreatePortOptions( const DMUS_IO_PORTCONFIG_HEADER &ioPortConfigHeader, const DMUS_PORTPARAMS8 &ioPortParams, const CString &strPortName )
{
	// Iterate through the list of ports
	POSITION pos = m_lstPortOptions.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each port
		PortOptions *pTmpPortOptions = m_lstPortOptions.GetNext( pos );

		// Check if the ports have the same GUID
		if( pTmpPortOptions->m_guidPort == ioPortConfigHeader.guidPort )
		{
			// Port already exists, so copy information from ioPortConfigHeader
			// to pTmpPortOptions, and return pTmpPortOptions
			pTmpPortOptions->m_dwEffects = ioPortParams.dwEffectFlags;
			//pTmpPortOptions->m_dwSupportedEffects
			pTmpPortOptions->m_dwSampleRate = ioPortParams.dwSampleRate;
			pTmpPortOptions->m_dwVoices = ioPortParams.dwVoices;
			//pTmpPortOptions->m_dwMaxVoices
			//pTmpPortOptions->m_fSelected
			pTmpPortOptions->m_fAudioPath = (ioPortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH) ? true : false;

			// GUID already set - no need to update
			//pTmpPortOptions->m_guidPort = ioPortConfigHeader.guidPort;
			// Name already set - no need to update
			//pTmpPortOptions->m_strName = strPortName;

			return pTmpPortOptions;
		}
	}

	// Port not found - must create a new one
	PortOptions *pPortOptions = new PortOptions;
	pPortOptions->m_dwEffects = ioPortParams.dwEffectFlags;
	// Unknown port - assume it supports all effects
	pPortOptions->m_dwSupportedEffects = 0xFFFFFFFF;
	pPortOptions->m_dwSampleRate = ioPortParams.dwSampleRate;
	pPortOptions->m_dwVoices = ioPortParams.dwVoices;
	// Unknown port - assume it supports at least DEFAULT_NUM_VOICES voices
	pPortOptions->m_dwMaxVoices = max( DEFAULT_NUM_VOICES, ioPortParams.dwVoices );
	//pPortOptions->m_fSelected
	pPortOptions->m_fAudioPath = (ioPortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH) ? true : false;
	pPortOptions->m_guidPort = ioPortConfigHeader.guidPort;
	pPortOptions->m_strName = strPortName;

	// Iinsert the new port in our list and return it
	m_lstPortOptions.AddTail( pPortOptions );

	return pPortOptions;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath SaveInfoList
    
HRESULT CDirectMusicAudioPath::SaveInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr = S_FALSE;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strName.IsEmpty()
	&&  m_strAuthor.IsEmpty()
	&&  m_strCopyright.IsEmpty()
	&&  m_strSubject.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Script name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write script author
	if( !m_strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Script copyright
	if( !m_strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write script subject
	if( !m_strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath SaveVersion
    
HRESULT CDirectMusicAudioPath::SaveVersion( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Version chunk header
	ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusVersionIO.dwVersionMS = m_vVersion.dwVersionMS ;
	dmusVersionIO.dwVersionLS = m_vVersion.dwVersionLS;

	// Write Version chunk data
	hr = pIStream->Write( &dmusVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath SaveGUID
    
HRESULT CDirectMusicAudioPath::SaveGUID( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Script GUID
	hr = pIStream->Write( &m_guidAudioPath, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath DM_SaveDSBC_Form

void CDirectMusicAudioPath::DM_SaveDSBC_Form( IDMUSProdRIFFStream *pRiffStream, ioDSoundBuffer *pioDSoundBuffer, DMUSProdStreamInfo &StreamInfo )
{
	// Validate arguments
	ASSERT( pRiffStream );
	if( !pRiffStream )
	{
		return;
	}

	IStream *pIStream = pRiffStream->GetStream();

	MMCKINFO ckBuffer;
	ckBuffer.fccType = DMUS_FOURCC_DSBC_FORM;
	if( 0 == pRiffStream->CreateChunk( &ckBuffer, MMIO_CREATERIFF ) )
	{
		MMCKINFO ckSubChunk;

		// Write out the GUID for this buffer
		ckSubChunk.ckid = DMUS_FOURCC_GUID_CHUNK;
		if( 0 == pRiffStream->CreateChunk( &ckSubChunk, 0 ) )
		{
			DWORD cbWritten;
			pIStream->Write( &(pioDSoundBuffer->ioBufferHeader.guidBufferID), sizeof(GUID), &cbWritten );

			pRiffStream->Ascend( &ckSubChunk, 0 );
		}

		// Check if the name is not empty and we're writing a design file
		if( !pioDSoundBuffer->strName.IsEmpty()
		&&	StreamInfo.ftFileType == FT_DESIGN )
		{
			ckSubChunk.fccType = DMUS_FOURCC_UNFO_LIST;
			if( 0 == pRiffStream->CreateChunk( &ckSubChunk, MMIO_CREATELIST ) )
			{
				MMCKINFO ckName;
				ckName.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( 0 == pRiffStream->CreateChunk( &ckName, 0 ) )
				{
					SaveMBStoWCS( pIStream, &(pioDSoundBuffer->strName) );

					pRiffStream->Ascend( &ckName, 0 );
				}

				pRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		// Write out the DirectSound buffer description
		ckSubChunk.ckid = DMUS_FOURCC_DSBD_CHUNK;
		if( 0 == pRiffStream->CreateChunk( &ckSubChunk, 0 ) )
		{
			DWORD cbWritten;
			pIStream->Write( &pioDSoundBuffer->ioDSBufferDesc, sizeof(DSOUND_IO_DSBUFFERDESC), &cbWritten );

			pRiffStream->Ascend( &ckSubChunk, 0 );
		}

		// Write out the BUS IDs
		if( pioDSoundBuffer->lstBusIDs.GetSize() > 0 )
		{
			ckSubChunk.ckid = DMUS_FOURCC_BSID_CHUNK;
			if( 0 == pRiffStream->CreateChunk( &ckSubChunk, 0 ) )
			{
				DWORD cbWritten;
				pIStream->Write( pioDSoundBuffer->lstBusIDs.GetData(), sizeof(DWORD) * pioDSoundBuffer->lstBusIDs.GetSize(), &cbWritten );

				pRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		// Write out the 3D position
		if( pioDSoundBuffer->ioDSBufferDesc.dwFlags & DSBCAPS_CTRL3D )
		{
			ckSubChunk.ckid = DMUS_FOURCC_DS3D_CHUNK;
			if( 0 == pRiffStream->CreateChunk( &ckSubChunk, 0 ) )
			{
				DWORD cbWritten;
				pIStream->Write( &pioDSoundBuffer->ioDS3D, sizeof(DSOUND_IO_3D), &cbWritten );

				pRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		// Write out the effect list
		if( !pioDSoundBuffer->lstDSoundEffects.IsEmpty() )
		{
			ckSubChunk.fccType = DMUS_FOURCC_DSBC_LIST;
			if( 0 == pRiffStream->CreateChunk( &ckSubChunk, MMIO_CREATELIST ) )
			{
				// Iterate through the effect list
				while( !pioDSoundBuffer->lstDSoundEffects.IsEmpty() )
				{
					ioDSoundEffect *pioDSoundEffect = pioDSoundBuffer->lstDSoundEffects.RemoveHead();

					// If we're not writing a design-time file,
					// and we're not writing for the DirectMusic object,
					// and this is the wave save DMO
					if( StreamInfo.ftFileType != FT_DESIGN
					&&	StreamInfo.guidDataFormat != GUID_DirectMusicObject
					&&	GUID_DSFX_STANDARD_DUMP == pioDSoundEffect->ioFXHeader.guidDSFXClass )
					{
						// Don't save the DMO
						RELEASE( pioDSoundEffect->pStreamData );
						delete pioDSoundEffect;
						continue;
					}

					MMCKINFO ckFXForm;
					ckFXForm.fccType = DMUS_FOURCC_DSFX_FORM;
					if( 0 == pRiffStream->CreateChunk( &ckFXForm, MMIO_CREATERIFF ) )
					{
						// Write out the effect header
						MMCKINFO ckFXHeader;
						ckFXHeader.ckid = DMUS_FOURCC_DSFX_CHUNK;
						if( 0 == pRiffStream->CreateChunk( &ckFXHeader, 0 ) )
						{
							DWORD cbWritten;
							pIStream->Write( &pioDSoundEffect->ioFXHeader, sizeof( DSOUND_IO_DXDMO_HEADER ), &cbWritten );

							pRiffStream->Ascend( &ckFXHeader, 0 );
						}

						// If we're writing a design-time file
						if( StreamInfo.ftFileType == FT_DESIGN )
						{
							// Write out the effect instance name, if non-empty
							if( !(pioDSoundEffect->strInstanceName.IsEmpty() && pioDSoundEffect->strEffectName.IsEmpty()) )
							{
								MMCKINFO ckUNFOList;
								ckUNFOList.fccType = DMUS_FOURCC_UNFO_LIST;
								if( 0 == pRiffStream->CreateChunk( &ckUNFOList, MMIO_CREATELIST ) )
								{
									MMCKINFO ckName;
									if( !pioDSoundEffect->strInstanceName.IsEmpty() )
									{
										ckName.ckid = DMUS_FOURCC_UNAM_CHUNK;
										if( 0 == pRiffStream->CreateChunk( &ckName, 0 ) )
										{
											SaveMBStoWCS( pIStream, &(pioDSoundEffect->strInstanceName) );

											pRiffStream->Ascend( &ckName, 0 );
										}
									}

									if( !pioDSoundEffect->strEffectName.IsEmpty() )
									{
										ckName.ckid = FOURCC_EFFECT_NAME_CHUNK;
										if( 0 == pRiffStream->CreateChunk( &ckName, 0 ) )
										{
											SaveMBStoWCS( pIStream, &(pioDSoundEffect->strEffectName) );

											pRiffStream->Ascend( &ckName, 0 );
										}
									}

									pRiffStream->Ascend( &ckUNFOList, 0 );
								}
							}

							// Write out the effect's design guid
							MMCKINFO ckEffectGuid;
							ckEffectGuid.ckid = DMUSPROD_FOURCC_EFFECT_GUID_CHUNK;
							if( 0 == pRiffStream->CreateChunk( &ckEffectGuid, 0 ) )
							{
								pIStream->Write( &(pioDSoundEffect->guidDesignGUID), sizeof(GUID), NULL );

								pRiffStream->Ascend( &ckEffectGuid, 0 );
							}
						}

						// Write out the effect data, if necessary
						if( pioDSoundEffect->pStreamData )
						{
							StreamSeek( pioDSoundEffect->pStreamData, 0, SEEK_SET );
							STATSTG statStg;
							if( SUCCEEDED( pioDSoundEffect->pStreamData->Stat( &statStg, STATFLAG_NONAME ) ) )
							{
								MMCKINFO ckFXData;
								ckFXData.ckid = FOURCC_DMUS_EFFECT_DATA_CHUNK;
								if( 0 == pRiffStream->CreateChunk( &ckFXData, 0 ) )
								{
									ULARGE_INTEGER uliRead, uliWritten;
									pioDSoundEffect->pStreamData->CopyTo( pIStream, statStg.cbSize, &uliRead, &uliWritten );

									pRiffStream->Ascend( &ckFXData, 0 );
								}
							}
						}

						pRiffStream->Ascend( &ckFXForm, 0 );
					}

					RELEASE( pioDSoundEffect->pStreamData );
					delete pioDSoundEffect;
				}

				pRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		pRiffStream->Ascend( &ckBuffer, 0 );
	}

	pIStream->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetDefaultPort

PortOptions *CDirectMusicAudioPath::GetDefaultPort( void )
{
	// Return the user-mode software synth
	return FindPort( GUID_Synth_Default );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::InsertToolGraph

HRESULT CDirectMusicAudioPath::InsertToolGraph( IDirectMusicAudioPath* pIDMAudioPath )
{
	if( m_pIToolGraphNode == NULL 
	||  pIDMAudioPath == NULL )
	{
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	// Now get the IDMUSProdToolGraphInfo interface for m_pIToolGraphNode
	IDMUSProdToolGraphInfo* pIToolGraphInfo;
	if( SUCCEEDED ( m_pIToolGraphNode->QueryInterface( IID_IDMUSProdToolGraphInfo, (void**)&pIToolGraphInfo ) ) )
	{
		if( SUCCEEDED ( pIToolGraphInfo->AddToGraphUserList( pIDMAudioPath ) ) )
		{
			hr = S_OK;
		}

		RELEASE( pIToolGraphInfo );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::AllAudioPaths_InsertToolGraph

HRESULT CDirectMusicAudioPath::AllAudioPaths_InsertToolGraph( void )
{
	HRESULT hr = S_OK;

	POSITION pos = m_lstDMAudioPaths.GetHeadPosition();
	while( pos )
	{
		IDirectMusicAudioPath* pIDMAudioPath = m_lstDMAudioPaths.GetNext( pos );

		if( FAILED ( InsertToolGraph( pIDMAudioPath ) ) )
		{
			hr = E_FAIL;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::RemoveToolGraph

HRESULT CDirectMusicAudioPath::RemoveToolGraph( IDirectMusicAudioPath* pIDMAudioPath )
{
	if( m_pIToolGraphNode == NULL 
	||  pIDMAudioPath == NULL )
	{
		// Should not happen!
		ASSERT( 0 );
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	// Get the IDMUSProdToolGraphInfo interface for m_pIToolGraphNode
	IDMUSProdToolGraphInfo* pIToolGraphInfo;
	if( SUCCEEDED ( m_pIToolGraphNode->QueryInterface( IID_IDMUSProdToolGraphInfo, (void**)&pIToolGraphInfo ) ) )
	{
		// Remove the ToolGraph
		if( SUCCEEDED ( pIToolGraphInfo->RemoveFromGraphUserList( pIDMAudioPath ) ) )
		{
			hr = S_OK;
		}

		RELEASE( pIToolGraphInfo );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::AllAudioPaths_RemoveToolGraph

HRESULT CDirectMusicAudioPath::AllAudioPaths_RemoveToolGraph( void )
{
	HRESULT hr = S_OK;

	POSITION pos = m_lstDMAudioPaths.GetHeadPosition();
	while( pos )
	{
		IDirectMusicAudioPath* pIDMAudioPath = m_lstDMAudioPaths.GetNext( pos );

		if( FAILED ( RemoveToolGraph( pIDMAudioPath ) ) )
		{
			hr = E_FAIL;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::PasteCF_GRAPH

HRESULT CDirectMusicAudioPath::PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( theApp.m_pAudioPathComponent->m_pIToolGraphComponent
	&&	SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pAudioPathComponent->m_cfGraph, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Graph
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIToolGraphComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );
				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetGUID

void CDirectMusicAudioPath::GetGUID( GUID* pguidAudioPath )
{
	if( pguidAudioPath )
	{
		*pguidAudioPath = m_guidAudioPath;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::SetGUID

void CDirectMusicAudioPath::SetGUID( GUID guidAudioPath )
{
	m_guidAudioPath = guidAudioPath;
	SetModified( TRUE );

	// Notify connected nodes that AudioPath GUID has changed
	theApp.m_pAudioPathComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::GetNameForConductor

BSTR CDirectMusicAudioPath::GetNameForConductor( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	// Audiopath file name
	CString strName;
	BSTR bstrAudiopathFileName;

	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->GetNodeFileName( this, &bstrAudiopathFileName ) ) )
	{
		// Node is in the Project tree
		strName = bstrAudiopathFileName;
		::SysFreeString( bstrAudiopathFileName );
		int nFindPos = strName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strName = strName.Right( strName.GetLength() - nFindPos - 1 );
		}
		strName += _T(": ");
	}
	else
	{
		// Node has not yet been placed in the Project Tree
		// because the Audiopath is still in the process of being loaded
		strName = m_strOrigFileName;
		strName += _T(": ");
	}
	
	// Plus "name"
	strName += m_strName;

    return strName.AllocSysString();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CopyFrom

void CDirectMusicAudioPath::CopyFrom( CDirectMusicAudioPath *pAudioPath )
{
	// Remove any exising items, effects, and ports
	while( !m_lstItems.IsEmpty() )
	{
		delete m_lstItems.RemoveHead();
	}
	while( !m_lstPortOptions.IsEmpty() )
	{
		delete m_lstPortOptions.RemoveHead();
	}

	// Copy the ports
	POSITION pos = pAudioPath->m_lstPortOptions.GetHeadPosition();
	while( pos )
	{
		PortOptions *pPortOptions = pAudioPath->m_lstPortOptions.GetNext( pos );
		PortOptions *pNewPortOptions = new PortOptions;
		pNewPortOptions->Copy( pPortOptions );
		m_lstPortOptions.AddTail( pNewPortOptions );
	}

	// Copy the items
	pos = pAudioPath->m_lstItems.GetHeadPosition();
	while( pos )
	{
		ItemInfo *pItemInfo = pAudioPath->m_lstItems.GetNext( pos );
		ItemInfo *pNewItemInfo = new ItemInfo;
		pNewItemInfo->Copy( *pItemInfo );
		m_lstItems.AddTail( pNewItemInfo );
	}

	// Copy the UI data
	m_wSplitterPos = pAudioPath->m_wSplitterPos;
	m_wMixGroupWidth = pAudioPath->m_wMixGroupWidth;
	m_wBusWidth = pAudioPath->m_wBusWidth;
	m_wBufferWidth = pAudioPath->m_wBufferWidth;
	m_wEffectWidth = pAudioPath->m_wEffectWidth;
	m_strName = pAudioPath->m_strName;
	m_vVersion = pAudioPath->m_vVersion;
    m_strAuthor = pAudioPath->m_strAuthor;
    m_strCopyright = pAudioPath->m_strCopyright;
    m_strSubject = pAudioPath->m_strSubject;

	// Link up the send effects
	ConnectAllSendEffects();

	// Now, change the GUID for all user-defined buffers
	pos = m_lstItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		ItemInfo *pItemInfo = m_lstItems.GetNext( pos );

		// Iterate through the item's buffers
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			// Check if the buffer is not a defined buffer
			if( !(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
			{
				// If this is a shared buffer
				if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_SHARED )
				{
					// Update all buffers with this GUID

					// Create a new guid
					GUID guidNew;
					::CoCreateGuid( &guidNew );

					// Save the old guid
					const GUID guidOld = pBufferOptions->guidBuffer;

					// Iterate through all itmes
					POSITION posItem = m_lstItems.GetHeadPosition();
					while( posItem )
					{
						// Get a pointer to each item
						ItemInfo *pItemInfo2 = m_lstItems.GetNext( posItem );

						// Iterate through the item's buffers
						POSITION posBuffer2 = pItemInfo2->lstBuffers.GetHeadPosition();
						while( posBuffer2 )
						{
							// Get a pointer to each buffer
							BufferOptions *pBufferOptions2 = pItemInfo2->lstBuffers.GetNext( posBuffer2 );

							// Update the buffer's guid, if necessary
							if( pBufferOptions2->guidBuffer == guidOld )
							{
								pBufferOptions2->guidBuffer = guidNew;
							}
						}
					}
				}
				else
				{
					// Just create a new guid
					::CoCreateGuid( &pBufferOptions->guidBuffer );
				}

				// If this is a mixin buffer
				if( pItemInfo->nNumPChannels == 0 )
				{
					// Should only have one buffer per mix group for a mixin mix group
					ASSERT( pItemInfo->lstBuffers.GetCount() == 1 );

					// Update any send effects sending to this item/buffer
					UpdateConnectedSendEffects( pItemInfo );
				}
			}
		}
	}

}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CreateStandardItem

ItemInfo *CDirectMusicAudioPath::CreateStandardItem( REFGUID rGuidBuffer1, REFGUID rGuidBuffer2, DWORD dwBufferFlags )
{
	// Create a new item
	ItemInfo *pItemInfo = new ItemInfo;

	if( pItemInfo )
	{
		// Create a buffer
		BufferOptions *pBufferOptions = new BufferOptions;

		if( pBufferOptions )
		{
			// Add 128 PChannels to the item
			pItemInfo->adwPChannels = new DWORD[128];
			pItemInfo->nNumPChannels = 128;
			for( DWORD dwPChannel = 0; dwPChannel < 128; dwPChannel++ )
			{
				pItemInfo->adwPChannels[dwPChannel] = dwPChannel;
			}

			// Point the item at the default port
			pItemInfo->pPortOptions = GetDefaultPort();

			// Get a name for the item
			pItemInfo->strBandName = GetNewMixgroupName();

			// Remove all Bus IDs from the buffer
			pBufferOptions->lstBusIDs.RemoveAll();

			// Mark it as a EnvReverb buffer
			pBufferOptions->guidBuffer = rGuidBuffer1;
			pBufferOptions->dwHeaderFlags = dwBufferFlags;

			// Add the buffer to the item
			pItemInfo->lstBuffers.AddTail( pBufferOptions );

			if( rGuidBuffer2 != GUID_NULL )
			{
				// Create a buffer
				pBufferOptions = new BufferOptions;

				if( pBufferOptions )
				{
					// Remove all Bus IDs from the buffer
					pBufferOptions->lstBusIDs.RemoveAll();

					// Mark it as a EnvReverb buffer
					pBufferOptions->guidBuffer = rGuidBuffer2;
					pBufferOptions->dwHeaderFlags = dwBufferFlags;

					// Add the buffer to the item
					pItemInfo->lstBuffers.AddTail( pBufferOptions );
				}
			}
		}
		else
		{
			delete pItemInfo;
			pItemInfo = NULL;
		}
	}

	return pItemInfo;
}

ItemInfo *CreateEnvironmentItem( void )
{
	// Create a new item
	ItemInfo *pItemInfo = new ItemInfo;

	if( pItemInfo )
	{
		// Get a mix group name for the PChannel
		pItemInfo->strBandName.LoadString( IDS_BUFFER_ENVREVERB );

		// Mix Groups without PChannels don't belong to a port
		pItemInfo->pPortOptions = NULL;

		// Create a buffer
		BufferOptions *pBufferOptions = new BufferOptions;

		if( pBufferOptions )
		{
			// Remove all Bus IDs from the buffer
			pBufferOptions->lstBusIDs.RemoveAll();

			// Mark it as a EnvReverb buffer
			pBufferOptions->guidBuffer = GUID_Buffer_EnvReverb;
			pBufferOptions->dwHeaderFlags = DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_SHARED;

			// Add the buffer to the item
			pItemInfo->lstBuffers.AddTail( pBufferOptions );
		}
		else
		{
			delete pItemInfo;
			pItemInfo = NULL;
		}
	}

	return pItemInfo;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::CopyFrom

void CDirectMusicAudioPath::CopyFrom( DWORD dwStandardID )
{
	// Remove any exising items
	while( !m_lstItems.IsEmpty() )
	{
		delete m_lstItems.RemoveHead();
	}

	ItemInfo *pItemInfo;

	switch( dwStandardID )
	{
	case DMUS_APATH_SHARED_STEREOPLUSREVERB:
		pItemInfo = CreateStandardItem( GUID_Buffer_Stereo, GUID_Buffer_Reverb, DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED );
		if( pItemInfo )
		{
			// Add the item to the list of items
			m_lstItems.AddTail( pItemInfo );
		}
		break;
		/*
	case DMUS_APATH_DYNAMIC_ENV3D:
		pItemInfo = CreateStandardItem( GUID_Buffer_3D, GUID_NULL, DMUS_BUFFERF_DEFINED );
		if( pItemInfo )
		{
			// Add the item to the list of items
			m_lstItems.AddTail( pItemInfo );
		}
		pItemInfo = CreateEnvironmentItem();
		if( pItemInfo )
		{
			// Add the item to the list of items
			m_lstItems.AddTail( pItemInfo );
		}
		break;
		*/
	case DMUS_APATH_DYNAMIC_3D:
		pItemInfo = CreateStandardItem( GUID_Buffer_3D_Dry, GUID_NULL, DMUS_BUFFERF_DEFINED );
		if( pItemInfo )
		{
			// Add the item to the list of items
			m_lstItems.AddTail( pItemInfo );
		}
		break;
	case DMUS_APATH_DYNAMIC_MONO:
		pItemInfo = CreateStandardItem( GUID_Buffer_Mono, GUID_NULL, DMUS_BUFFERF_DEFINED );
		if( pItemInfo )
		{
			// Add the item to the list of items
			m_lstItems.AddTail( pItemInfo );
		}
		break;
	case DMUS_APATH_DYNAMIC_STEREO:
		pItemInfo = CreateStandardItem( GUID_Buffer_Stereo, GUID_NULL, DMUS_BUFFERF_DEFINED );
		if( pItemInfo )
		{
			// Add the item to the list of items
			m_lstItems.AddTail( pItemInfo );
		}
		break;
	default:
		ASSERT(FALSE);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::UpdateConnectedSendEffects

void CDirectMusicAudioPath::UpdateConnectedSendEffects( const ItemInfo *pItem )
{
	// Iterate through the list of items
	POSITION posItem = m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pItemInfo = m_lstItems.GetNext( posItem );

		/* Update hidden buffers
		// If the port doesn't support buffers, skip it
		if( !ItemSupportsBuffers( pItemInfo ) )
		{
			continue;
		}
		*/

		// Iterate through the list of buffers
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			/* Update hidden effects
			// If the buffer does not support effects, skip it
			if( !ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
			{
				continue;
			}
			*/

			// Iterate through the list of effects
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfoInList = pBufferOptions->lstEffects.GetNext( posEffect );

				// Check if this is a sending effect
				if( (GUID_DSFX_SEND == pBusEffectInfoInList->m_EffectInfo.m_clsidObject)
				/*||	(GUID_DSFX_STANDARD_I3DL2SOURCE == pBusEffectInfoInList->m_EffectInfo.m_clsidObject)*/ )
				{
					// Check if the effect is pointing at the given item
					if( pItem == pBusEffectInfoInList->m_EffectInfo.m_pSendDestinationMixGroup )
					{
						// Update the send effect's send GUID
						pBusEffectInfoInList->m_EffectInfo.m_clsidSendBuffer = pItem->lstBuffers.GetHead()->guidBuffer;
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::DisconnectSendEffects

void CDirectMusicAudioPath::DisconnectSendEffects( const ItemInfo *pItem )
{
	UNREFERENCED_PARAMETER(pItem);

	// Just reconnect all effects
	ConnectAllSendEffects();
}

bool IsItemSentTo( const ItemInfo *pItemInfo, CTypedPtrList< CPtrList, ItemInfo *> &lstItems )
{
	if( pItemInfo->lstBuffers.IsEmpty() )
	{
		return false;
	}

	const GUID guidToFind = pItemInfo->lstBuffers.GetHead()->guidBuffer;

	POSITION pos = lstItems.GetHeadPosition();
	while( pos )
	{
		ItemInfo *pTmpItemInfo = lstItems.GetNext( pos );
		if( pTmpItemInfo != pItemInfo )
		{
			POSITION posBuffer = pTmpItemInfo->lstBuffers.GetHeadPosition();
			while( posBuffer )
			{
				BufferOptions *pBufferOptions = pTmpItemInfo->lstBuffers.GetNext( posBuffer );
				if( ItemAndBufferSupportEffects( pTmpItemInfo, pBufferOptions ) )
				{
					POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
					while( posEffect )
					{
						BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );
						if( pBusEffectInfo->m_EffectInfo.m_clsidSendBuffer == guidToFind )
						{
							return true;
						}
					}
				}
			}
		}
	}

	return false;
}

int CompareItemsForSort( const ItemInfo *pItemInfo1, const ItemInfo *pItemInfo2 )
{
	if( pItemInfo1->nNumPChannels == 0 )
	{
		if( pItemInfo2->nNumPChannels == 0 )
		{
			// Neither have any PChannels - just compare their names
			return _tcscmp( pItemInfo1->strBandName, pItemInfo2->strBandName );
		}
		else
		{
			// Only #2 has PChannels, so it should go last
			return -1;
		}
	}
	else
	{
		if( pItemInfo2->nNumPChannels == 0 )
		{
			// Only #1 has PChannels, so it should go last
			return 1;
		}
		else
		{
			// Both have PChannels - just compare the first PChannel in the sorted array
			return pItemInfo1->adwPChannels[0] - pItemInfo2->adwPChannels[0];
		}
	}
}

void SortItemList( CTypedPtrList< CPtrList, ItemInfo *> &lstItems )
{
	bool fChanged = true;
	while( fChanged )
	{
		fChanged = false;

		POSITION pos = lstItems.GetHeadPosition();
		while( pos )
		{
			const POSITION posCurrent = pos;
			ItemInfo *pItemInfo1 = lstItems.GetNext( pos );
			if( pos )
			{
				ItemInfo *pItemInfo2 = lstItems.GetAt( pos );
				if( CompareItemsForSort( pItemInfo1, pItemInfo2 ) > 0 )
				{
					// Items out of order - rearrange them
					fChanged = true;
					lstItems.RemoveAt( posCurrent );
					lstItems.InsertAfter( pos, pItemInfo1 );
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicAudioPath::UpdateDisplayIndexes

void CDirectMusicAudioPath::UpdateDisplayIndexes( void )
{
	ConnectAllSendEffects();

	// Find all items in m_lstItems that have PChannels
	CTypedPtrList< CPtrList, ItemInfo *> lstItems;
	CTypedPtrList< CPtrList, ItemInfo *> lstItems2;
	POSITION pos = m_lstItems.GetHeadPosition();
	while( pos )
	{
		ItemInfo *pItemInfo = m_lstItems.GetNext( pos );
		if( pItemInfo->nNumPChannels > 0 )
		{
			// Add them to lstItem2 if they have PChannels
			lstItems2.AddHead( pItemInfo );
		}
		else
		{
			// Otherwise, add them to lstItems
			lstItems.AddHead( pItemInfo );
		}
	}

	// Sort lstItems2
	SortItemList( lstItems2 );

	bool fLoopFound = false;
	CTypedPtrList< CPtrList, ItemInfo *> lstItems3;
	while( !lstItems.IsEmpty() && !fLoopFound )
	{
		// Assume we find a loop
		fLoopFound = true;

		// Find all items in lstItems that are not being sent to
		pos = lstItems.GetHeadPosition();
		while( pos )
		{
			ItemInfo *pItemInfo = lstItems.GetNext( pos );
			if( !IsItemSentTo( pItemInfo, lstItems ) )
			{
				// Found an item that is not being sent to, so didn't find a loop
				// this time around
				fLoopFound = false;
				lstItems3.AddHead( pItemInfo );
			}
		}

		// Remove those items from lstItems
		pos = lstItems3.GetHeadPosition();
		while( pos )
		{
			lstItems.RemoveAt( lstItems.Find( lstItems3.GetNext( pos ), NULL ) );
		}

		// Sort them
		SortItemList( lstItems3 );

		// Add them (in order) to the head of lstItems2
		while( !lstItems3.IsEmpty() )
		{
			lstItems2.AddHead( lstItems3.RemoveTail() );
		}
	}

	// We shouldn't find a loop
	ASSERT( !fLoopFound );

	// Now, assign the display index to each item
	DWORD dwIndex = 0;
	while( !lstItems2.IsEmpty() )
	{
		lstItems2.RemoveHead()->dwDisplayIndex = dwIndex;
		dwIndex++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathEditorGuids.c ===
// StyleEditorGuids.c : Contains GUIDs not found in MIDL generated StyleEditor_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */

const GUID CLSID_AudioPathComponent = { 0x4adc2ad, 0x7ea5, 0x4260, { 0xa4, 0x5b, 0x75, 0xa6, 0xef, 0x85, 0x6e, 0x99 } };

const GUID GUID_AudioPathNode = { 0x2a2620e2, 0x2622, 0x4c12, { 0xaa, 0x77, 0xb3, 0xf3, 0x43, 0xd3, 0x3a, 0xa0 } };
const GUID GUID_AudioPathRefNode = { 0xa9ecf224, 0x7863, 0x4f41, { 0xaa, 0xc1, 0x22, 0x1a, 0x85, 0x6e, 0xee, 0x22 } };

const GUID AUDIOPATH_NameChange = { 0xc662f3ad, 0x423a, 0x417a, { 0xb8, 0xcc, 0x68, 0xa7, 0x46, 0x82, 0x84, 0x8e } };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathDocType.h ===
#ifndef __AUDIOPATHDOCTYPE_H__
#define __AUDIOPATHDOCTYPE_H__

// AudioPathDocType.h : header file
//


class CAudioPathDocType : public IDMUSProdDocType8
{
public:
    CAudioPathDocType();
	~CAudioPathDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );

	HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// Additional functions

	// Member variables
private:
    DWORD m_dwRef;
};

#endif // __AUDIOPATHDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathDesignerDLL.cpp ===
// AudioPathDesigner.cpp : Implementation of CAudioPathDesignerApp and DLL registration.

#include "stdafx.h"
#include <initguid.h>
#include "dsoundp.h"
#include "AudioPathDesignerDLL.h"
#include "AudioPathComponent.h"
#include "ToolGraphDesigner.h"
#include "PChannelName.h"
#include "SegmentDesigner.h"
#include "uuids.h"
#define _SYS_GUID_OPERATORS_
#define INITGUID
#include "dmoreg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CAudioPathDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xAE85C04E, 0x4DEA, 0x445c, { 0xa4, 0x11, 0x4d, 0xfc, 0xf4, 0xbd, 0xe6, 0xb9 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp::InitInstance - DLL initialization

BOOL CAudioPathDesignerApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	m_pAudioPathComponent = NULL;

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp::ExitInstance - DLL termination

int CAudioPathDesignerApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp::GetHelpFileName

BOOL CAudioPathDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp::SetNodePointers  (used by all components)

void CAudioPathDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		RELEASE( pIChild );
	}
}


////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp::PutDataInClipboard

BOOL CAudioPathDesignerApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			RELEASE( m_pIClipboardDataObject );

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp::FlushClipboard

void CAudioPathDesignerApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		RELEASE( m_pIClipboardDataObject );

		m_pClipboardObject = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp::GetFileVersion  (used by all components)

BOOL CAudioPathDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds registry entries for DMUS Producer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    CString  strName;
    TCHAR    szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD    dwSkip = 0;
    TCHAR    szContainerPath[MAX_BUFFER];
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );

	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	
// Register AudioPath Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_AudioPathEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_AUDIOPATH_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_AudioPathComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_AUDIOPATH_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		LPOLESTR psz2;
		LPOLESTR psz3;
		LPOLESTR psz4;
		TCHAR    szGuid2[MID_BUFFER];
		TCHAR    szGuid3[MID_BUFFER];
		TCHAR    szGuid4[MID_BUFFER];
		if( SUCCEEDED( StringFromIID(GUID_AudioPathNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_AudioPathRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_AudioPathComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicAudioPathConfig, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_AUDIOPATH_OBJECT_TEXT );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes registry entries for DMUS Producer components

static BOOL UnregisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
    TCHAR    szGuid[MID_BUFFER];
    TCHAR    szComponentPath[MAX_BUFFER];
    TCHAR    szContainerPath[MAX_BUFFER];
	TCHAR	 szRefNode[SMALL_BUFFER];
	BOOL	 fResult = TRUE;
    
	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	_tcscpy( szRefNode, _T("RefNode") );
	
// Unregister AudioPath Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_AudioPathEditor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			fResult = FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			fResult = FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_AudioPathComponent, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			fResult = FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			fResult = FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			fResult = FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_AudioPathNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				fResult = FALSE;
			}
		}
		else
		{
			fResult = FALSE;
		}
	}
	else
	{
		fResult = FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp(); 
        }
        else
        {
			AfxOleUnlockApp(); 
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CAudioPathComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_AudioPathComponent) )
	{
        pfunc = CAudioPathComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_AudioPathEditor) )
	{
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathDocType.cpp ===
// AudioPathDocType.cpp : implementation file
//

#include "stdafx.h"

#include "AudioPathDesignerDLL.h"
#include "AudioPath.h"
#include <mmreg.h>
#include "DlgNewAudiopath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType constructor/destructor

CAudioPathDocType::CAudioPathDocType()
{
    m_dwRef = 0;
}

CAudioPathDocType::~CAudioPathDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType IUnknown implementation

HRESULT CAudioPathDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||	::IsEqualIID(riid, IID_IUnknown) )
	{
		*ppvObj = (IDMUSProdDocType8 *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdDocType) )
	{
		*ppvObj = (IDMUSProdDocType *)this;
	}
	else
	{
		 *ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CAudioPathDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CAudioPathDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::GetResourceId

HRESULT CAudioPathDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_AUDIOPATH_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::DoesExtensionMatch

HRESULT CAudioPathDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_AUDIOPATH_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::DoesIdMatch

HRESULT CAudioPathDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_AudioPathNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::AllocNode

HRESULT STDMETHODCALLTYPE CAudioPathDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_AudioPathNode) )
	{
		// Create a new AudioPath 
		CDirectMusicAudioPath* pAudioPath = new CDirectMusicAudioPath;
		if( pAudioPath == NULL )
		{
			return E_OUTOFMEMORY ;
		}
			
		// Create the Undo Manager
		if( pAudioPath->CreateUndoMgr() == FALSE )
		{
			RELEASE( pAudioPath );
			return E_OUTOFMEMORY;
		}

		// Display a dialog to allow the user to choose which audiopath to base this one on
		CDlgNewAudiopath dlgNewAudiopath;
		dlgNewAudiopath.m_pAudioPathComponent = theApp.m_pAudioPathComponent;
		if( dlgNewAudiopath.DoModal() != IDOK )
		{
			// User hit cancel button - fail the create
			RELEASE( pAudioPath );
			return E_ABORT;
		}
		else
		{
			// User hit OK button - update the new audiopath
			if( dlgNewAudiopath.m_fBaseOnExistingAudiopath )
			{
				if( dlgNewAudiopath.m_pExistingAudiopath )
				{
					pAudioPath->CopyFrom( dlgNewAudiopath.m_pExistingAudiopath );
				}
				else
				{
					pAudioPath->CopyFrom( dlgNewAudiopath.m_dwDefaultAudiopathID );
				}
			}
		}

		*ppINode = (IDMUSProdNode *)pAudioPath;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType:::OnFileNew

HRESULT CAudioPathDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
								  IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pITargetDirectoryNode);
	UNREFERENCED_PARAMETER(pITargetProject);

	IDMUSProdNode* pIAudioPathNode;

	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new AudioPath 
	hr = AllocNode( GUID_AudioPathNode, &pIAudioPathNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pIAudioPathNode, pIAudioPathNode, NULL );

		// Add node to Project Tree
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->AddNode(pIAudioPathNode, NULL) ) )
		{
			CDirectMusicAudioPath* pAudioPath = (CDirectMusicAudioPath *)pIAudioPathNode;

			// Get the filename
			BSTR bstrName;

			if( SUCCEEDED ( pIAudioPathNode->GetNodeName( &bstrName ) ) )
			{
				pAudioPath->m_strOrigFileName = bstrName;
				pAudioPath->m_strOrigFileName += _T(".aup");
				::SysFreeString( bstrName );
			}

			// Add AudioPath to AudioPath component list 
			theApp.m_pAudioPathComponent->AddToAudioPathFileList( pAudioPath );

			// Advise the ConnectionPoint for this CDirectMusicAudioPath

			// Register CDirectMusicAudioPath with the Conductor.
			theApp.m_pAudioPathComponent->m_pIConductor->RegisterAudiopath( pAudioPath, pAudioPath->GetNameForConductor() );


			*ppIDocRootNode = pIAudioPathNode;
			pAudioPath->SetModified( TRUE );
			hr = S_OK;
		}
		else
		{
			RELEASE( pIAudioPathNode );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::OnFileOpen

HRESULT CAudioPathDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
								   IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pITargetDirectoryNode);
	UNREFERENCED_PARAMETER(pITargetProject);

	CWaitCursor wait;
	CDirectMusicAudioPath* pAudioPath;
	CString strFileName;
	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;
	// Create a new AudioPath 
	pAudioPath = new CDirectMusicAudioPath;
	if( pAudioPath == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	theApp.m_pAudioPathComponent->m_nNextAudioPath--;

	if( pAudioPath->CreateUndoMgr() == FALSE )
	{
		RELEASE( pAudioPath );
		return E_OUTOFMEMORY;
	}

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pAudioPath->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pAudioPath->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pAudioPath->m_strOrigFileName = pAudioPath->m_strOrigFileName.Right( pAudioPath->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}

	// Load the AudioPath file
	hr = pAudioPath->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		RELEASE( pAudioPath );
		return hr;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pAudioPath, pAudioPath, NULL );

	// Add node to Project Tree
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->AddNode(pAudioPath, NULL) ) )
	{
		pAudioPath->SetModified( FALSE );

		// Add AudioPath to AudioPath component list 
		theApp.m_pAudioPathComponent->AddToAudioPathFileList( pAudioPath );

		// Advise the ConnectionPoint for this CDirectMusicAudioPath

		// Register CDirectMusicAudioPath with the Conductor.
		theApp.m_pAudioPathComponent->m_pIConductor->RegisterAudiopath( pAudioPath, pAudioPath->GetNameForConductor() );

		*ppIDocRootNode = pAudioPath;

		hr = S_OK;
	}
	else
	{
		RELEASE( pAudioPath );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::OnFileSave

HRESULT CAudioPathDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDocRootNode);
	UNREFERENCED_PARAMETER(pIStream);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::GetListInfo

HRESULT CAudioPathDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Create temporary audio path object to retrieve list info
	CDirectMusicAudioPath* pAudioPath = new CDirectMusicAudioPath;
	if( pAudioPath )
	{
		// Create the Undo Manager
		if( pAudioPath->CreateUndoMgr() )
		{
			/* TODO: Enable when the DirectMusic Audiopath object exists
			hr = pAudioPath->ReadListInfoFromStream( pIStream, pListInfo );
			*/
		}

		RELEASE( pAudioPath );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::IsFileTypeExtension

HRESULT CAudioPathDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".aup") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".aud") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::GetObjectDescriptorFromNode

HRESULT CAudioPathDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a AudioPath Node
	CDirectMusicAudioPath* pAudioPath;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_AudioPathNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pAudioPath = (CDirectMusicAudioPath *)pIDocRootNode;

	return pAudioPath->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::GetObjectRiffId

HRESULT CAudioPathDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a AudioPath Node
	if( IsEqualGUID ( guidNodeId, GUID_AudioPathNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_AUDIOPATH_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDocType::GetObjectExt

HRESULT CAudioPathDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a AudioPath Node
	if( IsEqualGUID ( guidNodeId, GUID_AudioPathNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = _T(".aup");
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = _T(".aud");
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathDlg.h ===
#if !defined(AFX_AUDIOPATHDLG_H__FECD4365_2E75_47E3_BB7F_3195F9A9CDE3__INCLUDED_)
#define AFX_AUDIOPATHDLG_H__FECD4365_2E75_47E3_BB7F_3195F9A9CDE3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AudioPathDlg.h : header file
//

#include "TreeDropTarget.h"
#include "MultiTree.h"
#include "resource.h"
#include "MixGroupPPGMgr.h"
#include "BufferPPGMgr.h"
#include "EffectInfo.h"
#include "OlePropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg dialog

class CDirectMusicAudioPath;
class CAudioPathCtrl;
class CEffectListDlg;
class CMultiTree;

int CALLBACK ComparePChannelsInTree(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
void PChannelArrayToString( DWORD adwPChannels[], int nNumPChannels, CString &strText );
void BusListToString( const ItemInfo *pItem, const BufferOptions *pBufferOptions, CString &strText );
bool IsItemEnvReverb( const ItemInfo *pItemInfo );

class CAudioPathDlg : public CDialog, public IDMUSProdPropPageObject, public IDropSource, public IDMUSProdUpdateObjectNow
{
friend CAudioPathCtrl;
friend CEffectListDlg;
friend CTreeDropTarget;
friend CMultiTree;

// Construction
public:
	CAudioPathDlg(CWnd* pParent = NULL);   // standard constructor
	virtual ~CAudioPathDlg();

	// Additional methods
public:
	void RefreshControls();
	BOOL OnViewProperties();

	HRESULT DropOnTree( IDataObject* pIDataObject, DROPEFFECT dropEffect, POINT point);

	void InsertPChannel( POINT pointInsert );
	void InsertEnvReverb();
	void PastePChannelFromClipboard( POINT pointPaste );
	void PasteEffectFromClipboard( POINT pointPaste );
	void UpdateTreeItemName( const ItemInfo *pItemInfo );

	void SwitchToCorrectPropertyPage( void );

// Operations
public:
    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdUpdateObjectNow functions
    HRESULT STDMETHODCALLTYPE UpdateObjectNow(LPUNKNOWN punkObject);

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// Private attributes
private:
	long		m_cRef;
	bool		m_fEnteredSwitchTo;

public:
	CAudioPathCtrl*		m_pAudioPathCtrl;
	CDirectMusicAudioPath*	m_pAudioPath;

protected:
	CTreeDropTarget m_CTreeDropTarget;

	MixGroupInfoForPPG	m_MixGroupInfoForPPG;
	BufferInfoForPPG	m_BufferInfoForPPG;
	EffectInfoForPPG	m_EffectInfoForPPG;

	IDataObject *m_pISourceDataObject;
	DWORD		m_dwStartDragButton;

	void InsertPChannelIntoItem( ItemInfo *pItemInfo, DWORD dwPChannel );
	void DeletePChannel( DWORD dwPChannel );
	void UpdateTreeItemNames( void );
	void InsertItemIntoTree( ItemInfo *pItem );
	void PastePChannels( IStream *pIStream, POINT pointPaste );
	int FindItem( const ItemInfo *pItemInfo, const BufferOptions *pBufferOptions );
	bool HasEnvReverb( void );
	EffectInfo *CreateNewEffectInfoIfNecessary( EffectInfo *pEffectInfoToChange );
	bool GetColumnWidths( long &lMixGroup, long &lBus, long &lBuffer );
	void ResizeEffectColumn( void );
	int GetMinEffectWidth( void );

	void SwitchToMixGroupPPG( void );
	void SwitchToBufferPPG( void );
	void SwitchToEffectPPG( void );

	void UpdateMixGroupForPPG( void );
	void UpdateBufferForPPG( void );
	void UpdateEffectForPPG( void );

	//void SetI3DL2SrcDestinationIfNecessary( EffectInfo *pEffectInfoToChange );

	HRESULT SetData_MixGroup( MixGroupInfoForPPG *pMixGroupInfoForPPG );
	HRESULT SetData_Buffer( BufferInfoForPPG *pBufferInfoForPPG );
	HRESULT SetData_Effect( EffectInfoForPPG *pEffectInfoForPPG );

// Dialog Data
	//{{AFX_DATA(CAudioPathDlg)
	enum { IDD = IDD_DLG_AUDIOPATH };
	CMultiTree	m_tcTree;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAudioPathDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAudioPathDlg)
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSelchangedTreePchannels(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBegindragTreePchannels(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnEditDelete();
	afx_msg void OnEditInsert();
	afx_msg void OnEditPaste();
	virtual BOOL OnInitDialog();
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnEditSelectAll();
	afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
	/*
	afx_msg void OnBeginTrackHeader(NMHDR* pNMHDR, LRESULT* pResult);
	*/
	afx_msg void OnEndTrackHeader(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDividerDblClickHeader(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUDIOPATHDLG_H__FECD4365_2E75_47E3_BB7F_3195F9A9CDE3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathDesignerDLL.h ===
#if !defined(AFX_AUDIOPATHDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_AUDIOPATHDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// AudioPathDesigner.h : main header file for AUDIOPATHDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicc.h>
#include <dmusici.h>
#pragma warning( pop )
#include "DMUSProd.h"
#include "AudioPathDesigner.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "DllJazzDataObject.h"
#include "DllBasePropPageManager.h"
#include "JazzUndoMan.h"


/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define CF_AUDIOPATH "DMUSProd v.1 AudioPath"
#define CF_AUDIOPATHLIST "DMUSProd v.1 AudioPath List"

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256

#define FIRST_AUDIOPATH_IMAGE		0
#define FIRST_AUDIOPATHREF_IMAGE	2

class CAudioPathComponent;


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDesignerApp : See AudioPathDesigner.cpp for implementation.

class CAudioPathDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );

private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:
	CAudioPathComponent*			m_pAudioPathComponent;
};

extern CAudioPathDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUDIOPATHDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathDlg.cpp ===
// AudioPathDlg.cpp : implementation file
//

#include "stdafx.h"
#include <windowsx.h>
#include "dsoundp.h"
#include "AudioPathDesignerDLL.h"
#include "AudioPath.h"
#include "AudioPathCtl.h"
#include "AudioPathDlg.h"
#include "ItemInfo.h"
#include "EffectInfo.h"
#include "RiffStrm.h"
#include "PChannelName.h"
#include "DlgAddPChannel.h"
#include "EffectListDlg.h"
#include "EffectPPGMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern ItemInfo *CreateEnvironmentItem( void );

bool BufferSendsTo( const BufferOptions *pBufferOptions, const ItemInfo *pItemInfo )
{
	if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
	{
		return false;
	}

	POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
	while( posEffect )
	{
		BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );
		if( pItemInfo == pBusEffectInfo->m_EffectInfo.m_pSendDestinationMixGroup )
		{
			return true;
		}
	}

	return false;
}

int CALLBACK ComparePChannelsInTree(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	UNREFERENCED_PARAMETER(lParamSort);
	const ItemInfoWrapper *pItemInfoWrapper1 = (ItemInfoWrapper *)lParam1;
	const ItemInfoWrapper *pItemInfoWrapper2 = (ItemInfoWrapper *)lParam2;

	// If the same item
	if( pItemInfoWrapper1->pItemInfo == pItemInfoWrapper2->pItemInfo )
	{
		// Order by buffer index
		int nBufferIndex1 = 0;
		POSITION pos = pItemInfoWrapper1->pItemInfo->lstBuffers.GetHeadPosition();
		while( pos )
		{
			if( pItemInfoWrapper1->pBufferOptions == pItemInfoWrapper1->pItemInfo->lstBuffers.GetNext( pos ) )
			{
				break;
			}
			nBufferIndex1++;
		}

		int nBufferIndex2 = 0;
		pos = pItemInfoWrapper2->pItemInfo->lstBuffers.GetHeadPosition();
		while( pos )
		{
			if( pItemInfoWrapper2->pBufferOptions == pItemInfoWrapper2->pItemInfo->lstBuffers.GetNext( pos ) )
			{
				break;
			}
			nBufferIndex2++;
		}

		return nBufferIndex1 - nBufferIndex2;
	}

	// Otherwise, order by the display index
	// If item1's index is greater than item2's index, this returns a positive result,
	// which means that item1 should go last
	return pItemInfoWrapper1->pItemInfo->dwDisplayIndex - pItemInfoWrapper2->pItemInfo->dwDisplayIndex;

	/*
	if( pItemInfoWrapper1->pItemInfo->nNumPChannels == 0 )
	{
		if( pItemInfoWrapper2->pItemInfo->nNumPChannels == 0 )
		{
			if( BufferSendsTo( pItemInfoWrapper1->pBufferOptions, pItemInfoWrapper2->pItemInfo ) )
			{
				// #1 sends to #2, so it should go last
				return 1;
			}
			if( BufferSendsTo( pItemInfoWrapper2->pBufferOptions, pItemInfoWrapper1->pItemInfo ) )
			{
				// #2 sends to #1, so it should go last
				return -1;
			}

			// Neither have any PChannels - just compare their names
			return _tcscmp( pItemInfoWrapper1->pItemInfo->strBandName, pItemInfoWrapper2->pItemInfo->strBandName );
		}
		else
		{
			// Only #2 has PChannels, so it should go last
			return -1;
		}
	}
	else
	{
		if( pItemInfoWrapper2->pItemInfo->nNumPChannels == 0 )
		{
			// Only #1 has PChannels, so it should go last
			return 1;
		}
		else
		{
			// Both have PChannels - just compare the first PChannel in the sorted array
			return pItemInfoWrapper1->pItemInfo->adwPChannels[0] - pItemInfoWrapper2->pItemInfo->adwPChannels[0];
		}
	}
	*/
}

void PChannelArrayToString( DWORD adwPChannels[], int nNumPChannels, CString &strText )
{
	if( adwPChannels
	&&	nNumPChannels )
	{
		DWORD dwLastPChannel = adwPChannels[0];
		bool fInRange = false;

		char strTemp2[20];
		char strNum[10];
		_itoa( adwPChannels[0] + 1, strNum, 10 );
		strText = strNum;

		for( int iPChannelIndex = 1 ;  iPChannelIndex < nNumPChannels;  iPChannelIndex++ )
		{
			if( (dwLastPChannel + 1) == adwPChannels[iPChannelIndex] )
			{
				dwLastPChannel++;
				fInRange = true;
			}
			else
			{
				if( fInRange )
				{
					// No longer in range
					_itoa( dwLastPChannel + 1, strNum, 10 );
					strcpy( strTemp2, "-" );
					strcat( strTemp2, strNum );
					strcat( strTemp2, ", " );
					_itoa( adwPChannels[iPChannelIndex] + 1, strNum, 10 );
					strcat( strTemp2, strNum );
					strText += strTemp2;
					dwLastPChannel = adwPChannels[iPChannelIndex];
					fInRange = false;
				}
				else
				{
					// No longer in range
					_itoa( adwPChannels[iPChannelIndex] + 1, strNum, 10 );
					strcpy( strTemp2, ", " );
					strcat( strTemp2, strNum );
					strText += strTemp2;
					dwLastPChannel = adwPChannels[iPChannelIndex];
				}
			}
		}

		if( fInRange )
		{
			_itoa( dwLastPChannel + 1, strNum, 10 );
			strcpy( strTemp2, "-" );
			strcat( strTemp2, strNum );
			strText += strTemp2;
		}
	}
}

void BufferToString( const ItemInfo *pItem, const BufferOptions *pBufferOptions, CString &strText )
{
	if( !ItemSupportsBuffers( pItem ) )
	{
		// Try and load the text 'Unsupported'
		strText.LoadString( IDS_BUFFER_UNSUPPORTED );
	}
	else if( !pBufferOptions )
	{
		// Try and load the text 'None'
		strText.LoadString( IDS_BUFFER_NONE );
	}
	else if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
	{
		// Initialize the bus ID text from the GUID of the standard buffer
		if( pBufferOptions->guidBuffer == GUID_Buffer_Reverb )
		{
			strText.LoadString( IDS_BUFFER_REVERB );
		}
		else if( pBufferOptions->guidBuffer == GUID_Buffer_EnvReverb )
		{
			strText.LoadString( IDS_BUFFER_ENVREVERB );
		}
		/*
		else if( pBufferOptions->guidBuffer == GUID_Buffer_3D )
		{
			strText.LoadString( IDS_BUFFER_3D );
		}
		*/
		else if( pBufferOptions->guidBuffer == GUID_Buffer_3D_Dry )
		{
			strText.LoadString( IDS_BUFFER_3D_DRY );
		}
		else if( pBufferOptions->guidBuffer == GUID_Buffer_Mono )
		{
			strText.LoadString( IDS_BUFFER_MONO );
		}
		else if( pBufferOptions->guidBuffer == GUID_Buffer_Stereo )
		{
			strText.LoadString( IDS_BUFFER_STEREO );
		}
		else
		{
			ASSERT(FALSE);
		}
	}
	else
	{
		// Try and load the text 'User Defined'
		strText.LoadString(IDS_BUFFER_USER_DEFINED);
	}
}

void BusListToString( const ItemInfo *pItem, const BufferOptions *pBufferOptions, CString &strText )
{
	if( !ItemSupportsBuffers( pItem ) )
	{
		// Try and load the text 'Unsupported'
		strText.LoadString( IDS_BUFFER_UNSUPPORTED );
	}
	else if( pBufferOptions
	&&	pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
	{
		// Initialize the bus ID text with 'Default'
		strText.LoadString( IDS_BUSID_STANDARD );
	}
	else if( pBufferOptions
	&&	pItem->nNumPChannels > 0
	&&	pBufferOptions->lstBusIDs.GetSize() > 0 )
	{
		if( pBufferOptions->lstBusIDs.GetSize() == 1 )
		{
			// Try and load an engligh version of the bus ID
			if( strText.LoadString( IDS_BUSID0 + pBufferOptions->lstBusIDs[0] ) == 0 )
			{
				// No english version available, just use the number
				strText.Format( _T("%u"), pBufferOptions->lstBusIDs[0] );
			}
		}
		else if( (pBufferOptions->lstBusIDs.GetSize() == 2)
		&&	(pBufferOptions->lstBusIDs[0] == DSBUSID_LEFT)
		&&	(pBufferOptions->lstBusIDs[1] == DSBUSID_RIGHT) )
		{
			strText.LoadString(IDS_BUSID_STEREO);
		}
		else if( (pBufferOptions->lstBusIDs.GetSize() == 2)
		&&	(pBufferOptions->lstBusIDs[0] == DSBUSID_RIGHT)
		&&	(pBufferOptions->lstBusIDs[1] == DSBUSID_LEFT) )

		{
			strText.LoadString( IDS_BUSID_REV_STEREO );
		}
		else
		{
			strText.LoadString(IDS_BUSID_MULTIPLE);
		}

		/*
		CString strTmp;
		bool fHaveOne = false;
		for( int i=0; i < pBufferOptions->lstBusIDs.GetSize(); i++ )
		{
			// Add a comma separator, if necessary
			if( fHaveOne )
			{
				strText += CString(_T(", "));
			}
			else
			{
				fHaveOne = true;
			}

			// Try and load an engligh version of the bus ID
			if( strTmp.LoadString( IDS_BUSID0 + pBufferOptions->lstBusIDs[i] ) == 0 )
			{
				// No english version available, just use the number
				strTmp.Format( _T("%u"), pBufferOptions->lstBusIDs[i] );
			}

			// Add the Bus ID on to the end of the string
			strText += strTmp;
		}
		*/
	}
	else
	{
		// Try and load the text 'none'
		strText.LoadString(IDS_BUSID_NONE);
	}
}

void EffectListToString( const ItemInfo *pItem, const BufferOptions *pBufferOptions, CString &strText )
{
	// Clear the string
	strText.Empty();

	// Check if the item and buffer suppors effects, and if the effects list is non-empty
	if( ItemAndBufferSupportEffects( pItem, pBufferOptions )
	&&	!pBufferOptions->lstEffects.IsEmpty() )
	{
		// String to temporarily store the effect text
		CString strEffects;

		// Iterate through all the effects
		POSITION pos = pBufferOptions->lstEffects.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each effect
			BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( pos );

			// Check if this is a sending effect
			if( (GUID_DSFX_SEND == pBusEffectInfo->m_EffectInfo.m_clsidObject)
			/*||	(GUID_DSFX_STANDARD_I3DL2SOURCE == pBusEffectInfo->m_EffectInfo.m_clsidObject)*/ )
			{
				if( GUID_DSFX_SEND == pBusEffectInfo->m_EffectInfo.m_clsidObject )
				{
					// Load the "Send" text
					strEffects.LoadString( IDS_SEND_TEXT );
				}
				else
				{
					// Use the instance name
					strEffects = pBusEffectInfo->m_EffectInfo.m_strInstanceName;
				}

				if( NULL != pBusEffectInfo->m_EffectInfo.m_pSendDestinationMixGroup )
				{
					strEffects += _T(" (") + pBusEffectInfo->m_EffectInfo.m_pSendDestinationMixGroup->strBandName + _T(")");
				}
				else if( GUID_Buffer_EnvReverb == pBusEffectInfo->m_EffectInfo.m_clsidSendBuffer )
				{
					CString strReverb;
					strReverb.LoadString( IDS_BUFFER_ENVREVERB );
					strEffects += _T(" (") + strReverb + _T(")");
				}
				else
				{
					CString strExt;
					strExt.LoadString( IDS_SEND_EXTENAL );
					strEffects += strExt;
				}
			}
			else
			{
				strEffects = pBusEffectInfo->m_EffectInfo.m_strInstanceName;
			}

			strText += strEffects;
			if( pos )
			{
				strText += CString(" | ");
			}
		}
	}
}

bool IsItemEnvReverb( const ItemInfo *pItemInfo )
{
	return pItemInfo
		&&	(pItemInfo->lstBuffers.GetCount() == 1)
		&&	(pItemInfo->lstBuffers.GetHead()->guidBuffer == GUID_Buffer_EnvReverb);
}

/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg dialog


CAudioPathDlg::CAudioPathDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAudioPathDlg::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CAudioPathDlg)
	//}}AFX_DATA_INIT

	m_pAudioPathCtrl = NULL;
	m_pAudioPath = NULL;
	m_pISourceDataObject = NULL;
	m_fEnteredSwitchTo = false;
	m_dwStartDragButton = 0;
	m_cRef = 0;
	AddRef();
}

CAudioPathDlg::~CAudioPathDlg()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
}

HRESULT CAudioPathDlg::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject)
	||	::IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IDMUSProdPropPageObject *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDropSource) )
	{
		*ppv = (IDropSource *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdUpdateObjectNow) )
	{
		*ppv = (IDMUSProdUpdateObjectNow *)this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CAudioPathDlg::AddRef( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return InterlockedIncrement( &m_cRef );
}

ULONG CAudioPathDlg::Release( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	const long lRes = InterlockedDecrement( &m_cRef );
	if( lRes == 0 )
	{
		delete this;
	}

	return lRes;
}

HRESULT CAudioPathDlg::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	PPGItemBase *pPPGItemBase = (PPGItemBase *)ppData;

	if( pPPGItemBase == NULL )
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	switch( pPPGItemBase->m_ppgIndex )
	{
	case PPG_MIX_GROUP:
		{
			MixGroupInfoForPPG *pMixGroupInfoForPPG = (MixGroupInfoForPPG *)pPPGItemBase;
			pMixGroupInfoForPPG->Copy( m_MixGroupInfoForPPG );
		}
		break;
	case PPG_BUFFER:
		{
			BufferInfoForPPG *pBufferInfoForPPG = (BufferInfoForPPG *)pPPGItemBase;
			pBufferInfoForPPG->Copy( m_BufferInfoForPPG );
		}
		break;
	case PPG_EFFECT:
		{
			EffectInfoForPPG *pEffectInfoForPPG = (EffectInfoForPPG *)pPPGItemBase;
			pEffectInfoForPPG->Copy( m_EffectInfoForPPG );
		}
		break;
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
		break;
	}

	return S_OK;
}

HRESULT CAudioPathDlg::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	PPGItemBase *pPPGItemBase = (PPGItemBase *)pData;

	if( pPPGItemBase == NULL )
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	switch( pPPGItemBase->m_ppgIndex )
	{
	case PPG_MIX_GROUP:
		return SetData_MixGroup( (MixGroupInfoForPPG *)pPPGItemBase );
		break;
	case PPG_BUFFER:
		return SetData_Buffer( (BufferInfoForPPG *)pPPGItemBase );
		break;
	case PPG_EFFECT:
		return SetData_Effect( (EffectInfoForPPG *)pPPGItemBase );
		break;
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
		break;
	}

	return E_FAIL;
}

HRESULT CAudioPathDlg::SetData_MixGroup( MixGroupInfoForPPG *pMixGroupInfoForPPG )
{
	// Get a pointer to the item to change
	ItemInfo *pItemInfoToChange = NULL;
	int nItemSelected = -1;
	POSITION pos = m_tcTree.GetFirstSelectedItemPosition();
	if( pos )
	{
		// Get the index of the selected item
		nItemSelected = m_tcTree.GetNextSelectedItem( pos );
		if( nItemSelected >= 0 )
		{
			// Get a pointer to the selected item
			pItemInfoToChange = m_tcTree.GetItemInfo( nItemSelected );
		}
	}

	if( pItemInfoToChange == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Set to true once an undo state has been saved
	bool fChanged = false;

	// Set to true if the property page needs to be refreshed
	bool fRefreshPPG = false;

	if( pMixGroupInfoForPPG->m_dwChanged & CH_MIXGROUP_NAME )
	{
		// Check if the name is unique
		if( m_pAudioPath->IsMixgroupNameUnique( NULL, pMixGroupInfoForPPG->m_strMixGroupName ) )
		{
			// Name is unique - save undo state
			m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_MIXGROUP_NAME, true );

			// Update the name
			pItemInfoToChange->strBandName = pMixGroupInfoForPPG->m_strMixGroupName;
			m_MixGroupInfoForPPG.m_strMixGroupName = pMixGroupInfoForPPG->m_strMixGroupName;

			UpdateTreeItemName( pItemInfoToChange );

			// Sync change with property sheet title
			IDMUSProdPropSheet* pIPropSheet;
			if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				UpdateMixGroupForPPG();
				pIPropSheet->RefreshTitleByObject( this );
				pIPropSheet->Release();
			}
		}
		else
		{
			// Name is not unique - need to refresh property page
			fRefreshPPG = true;
		}
	}

	if( pMixGroupInfoForPPG->m_dwChanged & CH_MIXGROUP_SYNTH )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_MIXGROUP_SYNTH, true );

		// Update the synth settings
		if( pItemInfoToChange->pPortOptions )
		{
			// Check if we changed the port
			if( pItemInfoToChange->pPortOptions->m_guidPort != pMixGroupInfoForPPG->m_PortOptions.m_guidPort )
			{
				pItemInfoToChange->pPortOptions = m_pAudioPath->FindPort( pMixGroupInfoForPPG->m_PortOptions.m_guidPort );

				// If the port supports AudioPaths, ensure it has a buffer
				if( pItemInfoToChange->pPortOptions->m_fAudioPath
				&&	pItemInfoToChange->lstBuffers.IsEmpty() )
				{
					// Create a buffer
					BufferOptions *pBufferOptions = new BufferOptions;

					// Add the buffer to the item
					pItemInfoToChange->lstBuffers.AddTail( pBufferOptions );

					// Point this item at the buffer
					ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(m_tcTree.GetItemData( nItemSelected ));
					pItemInfoWrapper->pBufferOptions = pBufferOptions;
				}

				RECT rectItem;
				if( m_tcTree.GetItemRect( nItemSelected, &rectItem, LVIR_BOUNDS ) )
				{
					m_tcTree.InvalidateRect( &rectItem, TRUE );
				}

				// Need to refresh property page so it gets the correct flags set
				fRefreshPPG = true;
			}
			else
			{
				// Update the port's settings
				pItemInfoToChange->pPortOptions->Copy( &pMixGroupInfoForPPG->m_PortOptions );
			}

			m_pAudioPath->SyncAudiopathsInUse( AUDIOPATH_UNLOAD_DOWNLOAD_WAVES );
		}
		else
		{
			// Shouldn't happen, since you can't set the port for a mix group with no PChannels
			ASSERT(FALSE);
		}
	}

	if( fRefreshPPG )
	{
		UpdateMixGroupForPPG();
		theApp.m_pAudioPathComponent->m_pIMixGroupPageManager->RefreshData();
	}

	return S_OK;
}

HRESULT CAudioPathDlg::SetData_Buffer( BufferInfoForPPG *pBufferInfoForPPG )
{
	// Get a pointer to the first selected buffer
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	if( m_tcTree.GetFirstSelectedThing( &pItemInfo, &pBufferOptions, NULL ) != BUS_BUFFER_COL )
	{
		// No buffer selected, fail
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Set to true once an undo state has been saved
	bool fChanged = false;

	// Set to true if the property page title should be refreshed
	bool fRefreshTitle = false;

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_HEADERFLAGS )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_SETTINGS, true );

		pBufferOptions->dwHeaderFlags = pBufferInfoForPPG->m_dwHeaderFlags;

		// If the buffer is no longer using a defined buffer type,
		// and the buffer has zero Bus IDs
		if( !(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED)
		&&	(pBufferOptions->lstBusIDs.GetSize() == 0) )
		{
			// Ensure it has at least one Bus
			pBufferOptions->lstBusIDs.Add( DSBUSID_LEFT );
			pBufferOptions->lstBusIDs.Add( DSBUSID_RIGHT );
			pBufferOptions->wChannels = max( WORD(2), pBufferOptions->wChannels );
		}

		// Resort the display
		m_pAudioPath->UpdateDisplayIndexes();
		m_tcTree.SortItems( ComparePChannelsInTree, 0 );

		// Sync change with property sheet title
		fRefreshTitle = true;
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_STANDARDGUID )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_STANDARD_BUFFER_TYPE, true );

		pBufferOptions->guidBuffer = pBufferInfoForPPG->m_guidBufferID;
		pBufferOptions->dwHeaderFlags = pBufferInfoForPPG->m_dwHeaderFlags;

		// Sync change with property sheet title
		fRefreshTitle = true;
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_USERGUID )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_GUID, true );

		pBufferOptions->guidBuffer = pBufferInfoForPPG->m_guidBufferID;

		// Update any connected send effects
		m_pAudioPath->UpdateConnectedSendEffects( pItemInfo );
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_BUFFERFLAGS )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_SETTINGS, true );

		pBufferOptions->dwBufferFlags = pBufferInfoForPPG->m_dwBufferFlags;
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_BUFFER3DALG )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_3DALGORITHM, true );

		pBufferOptions->guid3DAlgorithm = pBufferInfoForPPG->m_clsid3dAlgorithm;
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_BUFFER3DPOS )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_3DPOSITION, true );

		pBufferOptions->ds3DBuffer = pBufferInfoForPPG->m_ds3DBuffer;
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_BUFFERCHANNELS )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_CHANNELS, true );

		ASSERT( pBufferInfoForPPG->m_dwNumChannels <= USHRT_MAX );
		pBufferOptions->wChannels = WORD(pBufferInfoForPPG->m_dwNumChannels);
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_BUFFERPAN )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_PAN, true );

		pBufferOptions->lPan = pBufferInfoForPPG->m_lPan;
	}

	if( pBufferInfoForPPG->m_dwChanged & CH_BUFFER_BUFFERVOLUME )
	{
		// Save undo state
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_BUFFER_VOLUME, true );

		pBufferOptions->lVolume = pBufferInfoForPPG->m_lVolume;
	}

	if( fRefreshTitle )
	{
		// Sync change with property sheet title
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			UpdateBufferForPPG();
			pIPropSheet->RefreshTitleByObject( this );
			pIPropSheet->Release();
		}
	}

	// If anything changed
	if( fChanged )
	{
		// Find the item we changed
		int nItem = FindItem( pItemInfo, pBufferOptions );
		ASSERT( nItem >= 0 );
		if( nItem >= 0 )
		{
			// Get the rect for the item we changed
			RECT rectInvalidate;
			m_tcTree.GetItemRect( nItem, &rectInvalidate, LVIR_BOUNDS );

			// Redraw the item we changed
			m_tcTree.InvalidateRect( &rectInvalidate, TRUE );
		}

		m_pAudioPath->SyncAudiopathsInUse( 0 );	
	}

	return S_OK;
}

HRESULT CAudioPathDlg::SetData_Effect( EffectInfoForPPG *pEffectInfoForPPG )
{
	// Get a pointer to the first selected effect
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	BusEffectInfo *pBusEffectInfo;
	if( m_tcTree.GetFirstSelectedThing( &pItemInfo, &pBufferOptions, &pBusEffectInfo ) != EFFECT_COL )
	{
		// No effect selected, fail
		ASSERT(FALSE);
		return E_FAIL;
	}


	bool fUndoSave = false;
	EffectInfo *pEffectInfoToChange = &(pBusEffectInfo->m_EffectInfo);

	if( pEffectInfoForPPG->m_dwChanged & CH_EFFECT_NAME )
	{
		if( pEffectInfoToChange->m_strInstanceName != pEffectInfoForPPG->m_strInstanceName )
		{
			// Ensure we're not changing the name of the default effect
			ASSERT(pEffectInfoToChange->m_strInstanceName != pEffectInfoToChange->m_strName);
			// Ensure the instance name is unique
			if( m_pAudioPath->IsEffectNameUnique( pEffectInfoToChange, pEffectInfoForPPG->m_strInstanceName ) )
			{
				// Save an undo state
				m_pAudioPath->SaveUndoState( fUndoSave, IDS_UNDO_EFFECT_NAME, true );

				// Copy the instance name
				pEffectInfoToChange->m_strInstanceName = pEffectInfoForPPG->m_strInstanceName;

				// Redraw the PChannel tree with the new instance name
				// TODO: Redraw less of the screen
				InvalidateRect( NULL, TRUE );

				// Sync change with property sheet title
				IDMUSProdPropSheet* pIPropSheet;
				if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
				{
					UpdateEffectForPPG();
					pIPropSheet->RefreshTitleByObject( this );
					pIPropSheet->Release();
				}
			}
			else
			{
				// Name already used - update the property page with the old name
				UpdateEffectForPPG();
				theApp.m_pAudioPathComponent->m_pIEffectPageManager->RefreshData();
			}
		}
	}

	if( pEffectInfoForPPG->m_dwChanged & CH_EFFECT_FLAGS )
	{
		if( pEffectInfoToChange->m_dwFlags != pEffectInfoForPPG->m_dwFlags )
		{
			// Rename the EffectInfo, if necessary
			CString strOldName = pEffectInfoToChange->m_strInstanceName;
			if( !m_pAudioPath->IsEffectNameUnique( pEffectInfoToChange, pEffectInfoToChange->m_strInstanceName ) )
			{
				m_pAudioPath->GetUniqueEffectInstanceName( pEffectInfoToChange );
			}

			// Save an undo state
			m_pAudioPath->SaveUndoState( fUndoSave, IDS_UNDO_EFFECT_FLAGS, true );

			// Copy the flags
			pEffectInfoToChange->m_dwFlags = pEffectInfoForPPG->m_dwFlags;

			// Update the PChannel tree, if necessary
			if( strOldName != pEffectInfoToChange->m_strInstanceName )
			{
				int nItem = FindItem( pItemInfo, pBufferOptions );
				if( nItem >= 0 )
				{
					RECT rectItem;
					if( m_tcTree.GetItemRect( nItem, &rectItem, LVIR_BOUNDS ) )
					{
						m_tcTree.InvalidateRect( &rectItem, TRUE );
					}
				}
			}

			m_pAudioPath->SyncAudiopathsInUse( 0 ); 
		}
	}

	if( pEffectInfoForPPG->m_dwChanged & CH_EFFECT_DATA )
	{
		if( pEffectInfoForPPG->m_pIStream
		&&	(pEffectInfoToChange->m_pIStream != pEffectInfoForPPG->m_pIStream) )
		{
			// Rename the EffectInfo, if necessary
			CString strOldName = pEffectInfoToChange->m_strInstanceName;
			if( !m_pAudioPath->IsEffectNameUnique( pEffectInfoToChange, pEffectInfoToChange->m_strInstanceName ) )
			{
				m_pAudioPath->GetUniqueEffectInstanceName( pEffectInfoToChange );
			}

			// Save an undo state
			m_pAudioPath->SaveUndoState( fUndoSave, IDS_UNDO_EFFECT_DATA, true );

			// Release our existing stream, if we have any
			RELEASE( pEffectInfoToChange->m_pIStream );
			
			// Clone the stream
			pEffectInfoForPPG->m_pIStream->Clone( &pEffectInfoToChange->m_pIStream );

			// Update the PChannel tree, if necessary
			if( strOldName != pEffectInfoToChange->m_strInstanceName )
			{
				int nItem = FindItem( pItemInfo, pBufferOptions );
				if( nItem >= 0 )
				{
					RECT rectItem;
					if( m_tcTree.GetItemRect( nItem, &rectItem, LVIR_BOUNDS ) )
					{
						m_tcTree.InvalidateRect( &rectItem, TRUE );
					}
				}
			}

			// Update any DMOs that are in use
			m_pAudioPath->UpdateDMOs( pBusEffectInfo );
		}
	}

	if( pEffectInfoForPPG->m_dwChanged & CH_EFFECT_SEND )
	{
		if( pEffectInfoToChange->m_clsidSendBuffer != pEffectInfoForPPG->m_clsidSendBuffer )
		{
			/* Never necessary to rename the effectinfo
			// Rename the EffectInfo, if necessary
			CString strOldName = pEffectInfoToChange->m_strInstanceName;
			GetUniqueEffectInstanceNameIfNecessary( pEffectInfoToChange );
			*/

			// Save an undo state
			m_pAudioPath->SaveUndoState( fUndoSave, IDS_UNDO_EFFECT_SEND, true );

			// Copy the send GUID
			pEffectInfoToChange->m_clsidSendBuffer = pEffectInfoForPPG->m_clsidSendBuffer;

			// Clear the mix group pointer
			pEffectInfoToChange->m_pSendDestinationMixGroup = NULL;

			// Check if we're not using the standard Env. Reverb GUID
			if( GUID_Buffer_EnvReverb != pEffectInfoToChange->m_clsidSendBuffer )
			{
				// Check to see if the effect is now pointed at any of our mix groups
				POSITION pos = m_pAudioPath->m_lstItems.GetHeadPosition();
				while( pos )
				{
					// Get a pointer to each item
					ItemInfo *pTmpItem = m_pAudioPath->m_lstItems.GetNext( pos );

					// Check if this item is the one with the buffer we want to use
					if( (pTmpItem->nNumPChannels == 0)
					&&	(pTmpItem->lstBuffers.GetCount() > 0)
					&&	(pTmpItem->lstBuffers.GetHead()->guidBuffer == pEffectInfoToChange->m_clsidSendBuffer) )
					{
						// Yes - set the pointer and break out of the loop
						pEffectInfoToChange->m_pSendDestinationMixGroup = pTmpItem;
						break;
					}
				}
			}

			// Update the PChannel tree to display the new send destination
			int nItem = FindItem( pItemInfo, pBufferOptions );
			if( nItem >= 0 )
			{
				RECT rectItem;
				if( m_tcTree.GetItemRect( nItem, &rectItem, LVIR_BOUNDS ) )
				{
					m_tcTree.InvalidateRect( &rectItem, TRUE );
				}
			}

			// Resort the display
			m_pAudioPath->UpdateDisplayIndexes();
			m_tcTree.SortItems( ComparePChannelsInTree, 0 );

			m_pAudioPath->SyncAudiopathsInUse( 0 );	
		}
	}

	return S_OK;
}

HRESULT CAudioPathDlg::OnShowProperties( void )
{
	return E_NOTIMPL;
}

HRESULT CAudioPathDlg::OnRemoveFromPageManager( void )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg IDMUSProdUpdateObjectNow implementation

/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg IDMUSProdUpdateObjectNow::UpdateObjectNow

HRESULT CAudioPathDlg::UpdateObjectNow( LPUNKNOWN punkObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate the object pointer
	if( punkObject == NULL )
	{
		return E_POINTER;
	}

	// Get a pointer to the first selected effect
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	BusEffectInfo *pBusEffectInfo;
	if( m_tcTree.GetFirstSelectedThing( &pItemInfo, &pBufferOptions, &pBusEffectInfo ) != EFFECT_COL )
	{
		// No effect selected, fail
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get an EffectInfo pointer
	EffectInfo *pEffectInfoToChange = &pBusEffectInfo->m_EffectInfo;
	if( pEffectInfoToChange == NULL )
	{
		return E_FAIL;
	}

	IPersistStream *pIPersistStream;
	if( SUCCEEDED( punkObject->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
	{
		// Create a stream to store the effect's data in
		IStream *pIStream;
		if( SUCCEEDED( ::CreateStreamOnHGlobal( NULL, TRUE, &pIStream ) ) )
		{
			// Try and save the effect to a stream
			if( SUCCEEDED( pIPersistStream->Save( pIStream, TRUE ) ) )
			{
				// Seek back to the start of the stream
				if( SUCCEEDED( StreamSeek( pIStream, 0 , STREAM_SEEK_SET ) ) )
				{
					// Always update the object(s) with the new stream

					// Save a pointer to the existing stream, if there is one
					IStream *pIOldStream = pEffectInfoToChange->m_pIStream;
					
					// Point the effect at the new stream
					pEffectInfoToChange->m_pIStream = pIStream;

					// Update only the DMOs that are in use for this BusEffectInfo
					m_pAudioPath->UpdateDMOs( pBusEffectInfo );

					// Point the effect back to the old stream
					pEffectInfoToChange->m_pIStream = pIOldStream;
				}
			}

			// Release the stream
			pIStream->Release();
		}

		// Release the object's IPersistStream interface
		pIPersistStream->Release();
	}

	return S_OK;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::QueryContinueDrag

HRESULT CAudioPathDlg::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::GiveFeedback

HRESULT CAudioPathDlg::GiveFeedback( DWORD dwEffect )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwEffect);

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

void CAudioPathDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAudioPathDlg)
	DDX_Control(pDX, IDC_TREE_PCHANNELS, m_tcTree);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAudioPathDlg, CDialog)
	//{{AFX_MSG_MAP(CAudioPathDlg)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_TREE_PCHANNELS, OnSelchangedTreePchannels)
	ON_NOTIFY(LVN_BEGINDRAG, IDC_TREE_PCHANNELS, OnBegindragTreePchannels)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_WM_HSCROLL()
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
	/*
	ON_NOTIFY(HDN_BEGINTRACK, 0, OnBeginTrackHeader)
	*/
	ON_NOTIFY(HDN_ENDTRACK, 0, OnEndTrackHeader)
	ON_NOTIFY(HDN_DIVIDERDBLCLICK, 0, OnDividerDblClickHeader)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::RefreshControls

void CAudioPathDlg::RefreshControls( void )
{
	ASSERT( m_pAudioPath != NULL );

	// Clear our item data pointers
	for( int i=0; i < m_tcTree.GetItemCount(); i++ )
	{
		// Delete wrappers
		m_tcTree.SetItemData( i, 0 );
		delete reinterpret_cast<ItemInfoWrapper *>(m_tcTree.GetItemData( i ));
	}

	// Remove all items from the tree
	m_tcTree.DeleteAllItems();

	// Repopulate the tree with the new items
	POSITION posItem = m_pAudioPath->m_lstItems.GetHeadPosition();
	while( posItem )
	{
		ItemInfo *pItemInfo = m_pAudioPath->m_lstItems.GetNext( posItem );
		InsertItemIntoTree( pItemInfo );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg message handlers

BOOL CAudioPathDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	ASSERT( m_pAudioPath != NULL );

	m_CTreeDropTarget.m_pAudioPathDlg = this;
	::RegisterDragDrop( m_tcTree.GetSafeHwnd(), &m_CTreeDropTarget );

	m_tcTree.SetDMAudioPathDlg( this );

	// Set up the header control
	CDC *pDC = GetDC();

	CString strTitle;
	CSize size;
	size.cx = 80;
	long lWidth;

	// Mix Group column
	strTitle.LoadString( IDS_MIXGROUP_COLUMN );
	if( pDC )
	{
		size = pDC->GetTextExtent( strTitle );
	}
	if( m_pAudioPath->m_wMixGroupWidth )
	{
		lWidth = m_pAudioPath->m_wMixGroupWidth;
	}
	else
	{
		lWidth = max( 115, size.cx );
		m_pAudioPath->m_wMixGroupWidth = WORD(lWidth);
	}
	m_tcTree.InsertColumn( 0, strTitle, LVCFMT_LEFT, lWidth, -1 );

	// Bus column
	strTitle.LoadString( IDS_BUS_COLUMN );
	if( pDC )
	{
		size = pDC->GetTextExtent( strTitle );
	}
	if( m_pAudioPath->m_wBusWidth )
	{
		lWidth = m_pAudioPath->m_wBusWidth;
	}
	else
	{
		lWidth = max( 65, size.cx );
		m_pAudioPath->m_wBusWidth = WORD(lWidth);
	}
	m_tcTree.InsertColumn( 1, strTitle, LVCFMT_LEFT, lWidth, 1 );

	// Buffer column
	strTitle.LoadString( IDS_BUFFER_COLUMN );
	if( pDC )
	{
		size = pDC->GetTextExtent( strTitle );
	}
	if( m_pAudioPath->m_wBufferWidth )
	{
		lWidth = m_pAudioPath->m_wBufferWidth;
	}
	else
	{
		lWidth = max( 110, size.cx );
		m_pAudioPath->m_wBufferWidth = WORD(lWidth);
	}
	m_tcTree.InsertColumn( 2, strTitle, LVCFMT_LEFT, lWidth, 2 );

	// Effects column
	strTitle.LoadString( IDS_EFFECTS_COLUMN );
	if( pDC )
	{
		size = pDC->GetTextExtent( strTitle );
	}
	if( m_pAudioPath->m_wEffectWidth )
	{
		lWidth = m_pAudioPath->m_wEffectWidth;
	}
	else
	{
		lWidth = max( 70, size.cx );
		m_pAudioPath->m_wEffectWidth = WORD(lWidth);
	}
	m_tcTree.InsertColumn( 3, strTitle, LVCFMT_LEFT, lWidth, 3 );

	if( pDC )
	{
		ReleaseDC( pDC );
	}

	POSITION posItem = m_pAudioPath->m_lstItems.GetHeadPosition();
	while( posItem )
	{
		ItemInfo *pItemInfo = m_pAudioPath->m_lstItems.GetNext( posItem );
		InsertItemIntoTree( pItemInfo );
	}

	ResizeEffectColumn();

	// If the audiopath is empty, open up the add/remove PChannels dialog
	if( m_pAudioPath->m_lstItems.IsEmpty() )
	{
		::PostMessage( m_tcTree.GetSafeHwnd(), WM_COMMAND, ID_EDIT_INSERT, 0 );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnDestroy

void CAudioPathDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Clear our item data pointers
	for( int i=0; i < m_tcTree.GetItemCount(); i++ )
	{
		// Delete wrappers
		ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(m_tcTree.GetItemData( i ));
		m_tcTree.SetItemData( i, 0 );
		delete pItemInfoWrapper;
	}

	// Remove MixGroup, Buffer, and Effect from property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		if(theApp.m_pAudioPathComponent->m_pIMixGroupPageManager)
		{
			theApp.m_pAudioPathComponent->m_pIMixGroupPageManager->RemoveObject(this);
		}
		if(theApp.m_pAudioPathComponent->m_pIBufferPageManager)
		{
			theApp.m_pAudioPathComponent->m_pIBufferPageManager->RemoveObject(this);
		}
		if(theApp.m_pAudioPathComponent->m_pIEffectPageManager)
		{
			theApp.m_pAudioPathComponent->m_pIEffectPageManager->RemoveObject(this);
		}
		pIPropSheet->Release();
	}

	CDialog::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnSize

void CAudioPathDlg::OnSize( UINT nType, int cx, int cy ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnSize(nType, cx, cy);
    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow( m_tcTree.GetSafeHwnd() ) )
	{
		return;
	}

	RECT rect;
	GetClientRect(&rect);
	m_tcTree.MoveWindow(&rect);

	ResizeEffectColumn();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnUpdateEditCut

void CAudioPathDlg::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL );
	if( (tColumn == PCHANNEL_COL)
	||	(tColumn == EFFECT_COL) )
	{
		pCmdUI->Enable( TRUE );
	}
	else //if( tColumn == BUS_BUFFER_COL )
	{
		pCmdUI->Enable( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnEditCut

void CAudioPathDlg::OnEditCut() 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL );
	switch( tColumn )
	{
	case PCHANNEL_COL:
		m_tcTree.OnEditPChannelCut();
		break;
	case EFFECT_COL:
		m_tcTree.OnEditEffectCut();
		break;
	case BUS_BUFFER_COL:
	default:
		ASSERT(FALSE);
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnUpdateEditCopy

void CAudioPathDlg::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL );
	if( (tColumn == PCHANNEL_COL)
	||	(tColumn == EFFECT_COL) )
	{
		pCmdUI->Enable( TRUE );
	}
	else //if( tColumn == BUS_BUFFER_COL )
	{
		pCmdUI->Enable( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnEditCopy

void CAudioPathDlg::OnEditCopy() 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL );
	switch( tColumn )
	{
	case PCHANNEL_COL:
		m_tcTree.OnEditPChannelCopy();
		break;
	case EFFECT_COL:
		m_tcTree.OnEditEffectCopy();
		break;
	case BUS_BUFFER_COL:
	default:
		ASSERT(FALSE);
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnUpdateEditPaste

void CAudioPathDlg::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pAudioPath != NULL );

	pCmdUI->Enable( (::IsClipboardFormatAvailable( CDirectMusicAudioPath::m_scfPChannel )
					 || ::IsClipboardFormatAvailable( CDirectMusicAudioPath::m_scfEffect ))? TRUE : FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnEditPaste

void CAudioPathDlg::OnEditPaste() 
{
	ASSERT( m_pAudioPath != NULL );

	if( ::IsClipboardFormatAvailable( CDirectMusicAudioPath::m_scfPChannel ) )
	{
		m_tcTree.OnEditPChannelPaste();
	}
	else if( ::IsClipboardFormatAvailable( CDirectMusicAudioPath::m_scfEffect ) )
	{
		m_tcTree.OnEditEffectPaste();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnUpdateEditInsert

void CAudioPathDlg::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pAudioPath != NULL );

	pCmdUI->Enable( TRUE );

	// Find out what is selected in the tree
	ItemInfo *pItemInfo = NULL;
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( &pItemInfo, NULL, NULL );
	switch( tColumn )
	{
	case BUS_BUFFER_COL:
		// Only can insert a new buffer if the # of pchannels is greater than zero
		pCmdUI->Enable( (pItemInfo->nNumPChannels > 0) ? TRUE : FALSE );
		break;
#ifndef DMP_XBOX
	// Always can insert a new mix group or effect
	default:
	/*
	case EFFECT_COL:
	case PCHANNEL_COL:
	*/
		pCmdUI->Enable( TRUE );
		break;
#else
	case EFFECT_COL:
		pCmdUI->Enable( FALSE );
		break;
	default:
	/*
	case PCHANNEL_COL:
	*/
		pCmdUI->Enable( TRUE );
		break;
#endif
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnEditInsert

void CAudioPathDlg::OnEditInsert() 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL );
	switch( tColumn )
	{
#ifndef DMP_XBOX
	case EFFECT_COL:
		m_tcTree.OnEditEffectInsert();
		break;
#endif
	case PCHANNEL_COL:
	default:
		// Map to inserting a MixGroup, not add/remove PChannels
		m_tcTree.OnEditInsertMixGroup();
		break;
	case BUS_BUFFER_COL:
		m_tcTree.OnEditBufferInsert();
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnUpdateEditDelete

void CAudioPathDlg::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	ItemInfo *pItemInfo;
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( &pItemInfo, NULL, NULL );
	if( (tColumn == PCHANNEL_COL)
	||	(tColumn == EFFECT_COL) )
	{
		pCmdUI->Enable( TRUE );
	}
	else if( tColumn == BUS_BUFFER_COL )
	{
		if(	IsItemEnvReverb( pItemInfo ) )
		{
			pCmdUI->Enable( FALSE );
		}
		else
		{
			pCmdUI->Enable( pItemInfo->lstBuffers.GetCount() > 0 );
		}
	}
	else
	{
		pCmdUI->Enable( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnEditDelete

void CAudioPathDlg::OnEditDelete() 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL );
	switch( tColumn )
	{
	case PCHANNEL_COL:
		m_tcTree.OnEditPChannelDelete();
		break;
	case EFFECT_COL:
		m_tcTree.OnEditEffectDelete();
		break;
	case BUS_BUFFER_COL:
		m_tcTree.OnEditBufferDelete();
		break;
	default:
		ASSERT(FALSE);
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathDlg::OnViewProperties

BOOL CAudioPathDlg::OnViewProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdPropSheet* pIPropSheet;

	ASSERT( m_pAudioPath != NULL );
	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	if( FAILED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return FALSE;
	}

	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return TRUE;
	}

	BOOL fSuccess = FALSE;
	if( SUCCEEDED ( m_pAudioPath->OnShowProperties() ) )
	{
		fSuccess = TRUE;
	}

	RELEASE( pIPropSheet );

	return fSuccess;
}

void CAudioPathDlg::OnSelchangedTreePchannels(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pResult = 0;

	static bool fEntered;
	if( fEntered )
	{
		return;
	}

	NMLISTVIEW *pNMLISTVIEW = (NMLISTVIEW*)pNMHDR;
	if( pNMLISTVIEW->iItem >= 0 )
	{
		if( pNMLISTVIEW->uChanged & LVIF_STATE )
		{
			if( (pNMLISTVIEW->uNewState & LVIS_SELECTED) != (pNMLISTVIEW->uOldState & LVIS_SELECTED) )
			{
				m_tcTree.InvalidateItem( m_tcTree.GetItemInfo( pNMLISTVIEW->iItem ) );
			}
		}
	}

	fEntered = true;

	m_pAudioPathCtrl->SwitchToCorrectPropertyPage();

	fEntered = false;
}

void CAudioPathDlg::OnBegindragTreePchannels(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pNMHDR);

	ASSERT(m_tcTree.GetSelectedCount() > 0);

	if( SUCCEEDED( m_tcTree.CreateDataObject( &m_pISourceDataObject ) ) )
	{
		// Begin Drag operation
		DWORD dwEffect = DROPEFFECT_NONE;
		m_dwStartDragButton = MK_LBUTTON;
		HRESULT hr = ::DoDragDrop( m_pISourceDataObject, this, DROPEFFECT_COPY | DROPEFFECT_MOVE, &dwEffect );

		switch( hr )
		{
			case DRAGDROP_S_DROP:
				if( dwEffect & DROPEFFECT_MOVE )
				{
					// TODO:
					//m_pTimeSigMgr->DeleteMarked( UD_DRAGSELECT );
				}
				break;

			default:
				dwEffect = DROPEFFECT_NONE;
				break;
		}

		RELEASE( m_pISourceDataObject );

		*pResult = 1;
		return;
	}

	*pResult = 0;
}

void CAudioPathDlg::UpdateTreeItemName( const ItemInfo *pItemInfo )
{
	if( pItemInfo == NULL )
	{
		return;
	}

	// Look for any effects that send to this item
	POSITION posItem = m_pAudioPath->m_lstItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		ItemInfo *pTmpItemInfo = m_pAudioPath->m_lstItems.GetNext( posItem );

		// If the port doesn't support buffers, skip it
		if( !ItemSupportsBuffers( pTmpItemInfo ) )
		{
			continue;
		}

		// Iterate through the list of buffers
		POSITION posBuffer = pTmpItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pTmpItemInfo->lstBuffers.GetNext( posBuffer );

			// If the buffer does not support effects, skip it
			if( !ItemAndBufferSupportEffects( pTmpItemInfo, pBufferOptions ) )
			{
				continue;
			}

			// Iterate through the list of effects
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );

				// Check if this effect sends to the mix group that changed
				if( pBusEffectInfo->m_EffectInfo.m_pSendDestinationMixGroup == pItemInfo )
				{
					// Redraw this item
					int nItem = FindItem( pTmpItemInfo, pBufferOptions );
					if( nItem >= 0 )
					{
						// Get the rect for the item we changed
						RECT rectInvalidate;
						m_tcTree.GetItemRect( nItem, &rectInvalidate, LVIR_BOUNDS );

						// Redraw the item we changed
						m_tcTree.InvalidateRect( &rectInvalidate, TRUE );
					}
					break;
				}
			}
		}
	}

	CString strItemName;

	if( pItemInfo->nNumPChannels )
	{
		PChannelArrayToString( pItemInfo->adwPChannels, pItemInfo->nNumPChannels, strItemName );

		strItemName += CString(_T(": "));

		strItemName += pItemInfo->strBandName;
	}
	else
	{
		strItemName = pItemInfo->strBandName;
	}

	// If the item has zero buffers
	if( pItemInfo->lstBuffers.IsEmpty() )
	{
		// Update the item's name
		int nItem = FindItem( pItemInfo, NULL );
		ASSERT( nItem >= 0 );
		m_tcTree.SetItemText( nItem, 0, strItemName );

		// Set the bus text
		CString strTemp;
		BusListToString( pItemInfo, NULL, strTemp );
		m_tcTree.SetItemText( nItem, 1, strTemp );

		// Set the buffer text
		BufferToString( pItemInfo, NULL, strTemp );
		m_tcTree.SetItemText( nItem, 2, strTemp );

		// Set the effect text
		m_tcTree.SetItemText( nItem, 3, NULL );
	}
	else
	{
		POSITION pos = pItemInfo->lstBuffers.GetHeadPosition();
		while( pos )
		{
			const BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( pos );
			int nItem = FindItem( pItemInfo, pBufferOptions );
			ASSERT( nItem >= 0 );
			m_tcTree.SetItemText( nItem, 0, strItemName );

			// Set the bus text
			CString strTemp;
			BusListToString( pItemInfo, pBufferOptions, strTemp );
			m_tcTree.SetItemText( nItem, 1, strTemp );

			// Set the buffer text
			BufferToString( pItemInfo, pBufferOptions, strTemp );
			m_tcTree.SetItemText( nItem, 2, strTemp );

			// Set the effect text
			EffectListToString( pItemInfo, pBufferOptions, strTemp );
			m_tcTree.SetItemText( nItem, 3, strTemp );
		}
	}
}

void CAudioPathDlg::UpdateTreeItemNames( void )
{
	// Iterate through all items
	POSITION pos = m_pAudioPath->m_lstItems.GetHeadPosition();
	while( pos )
	{
		// Update the name for each item
		UpdateTreeItemName( m_pAudioPath->m_lstItems.GetNext( pos ) );
	}
}

HRESULT ReadInItems( IStream *pStream, CTypedPtrList< CPtrList, ItemInfo *> &lstNewItems, CDirectMusicAudioPath *pAudioPath )
{
	STATSTG statStg;
	long lStreamSize = 0;
	if( FAILED( pStream->Stat( &statStg, STATFLAG_NONAME ) ) )
	{
		return E_FAIL;
	}

	lStreamSize = statStg.cbSize.LowPart;

	// Seek back to the start of the stream
	if( FAILED( StreamSeek( pStream, 0 , STREAM_SEEK_SET ) ) )
	{
		return E_FAIL;
	}

	// Allocate a RIFF stream
	IDMUSProdRIFFStream *pRiffStream;
	AllocRIFFStream( pStream, &pRiffStream );

	// Initialize the result to return
	HRESULT hr = S_OK;

	// Now, load in all items to paste
	while( lStreamSize > 0 )
	{
		// Find the DMUSPROD_FOURCC_ITEMINFO_LIST chunk
		MMCKINFO ckItemList;
		ckItemList.fccType = DMUSPROD_FOURCC_ITEMINFO_LIST;
		if( 0 == pRiffStream->Descend( &ckItemList, NULL, MMIO_FINDLIST ) )
		{
			ItemInfo *pItemInfo = new ItemInfo();
			hr = pItemInfo->Read( pRiffStream, &ckItemList, pAudioPath );
			if( SUCCEEDED( hr ) )
			{
				lstNewItems.AddTail( pItemInfo );
			}
			else
			{
				delete pItemInfo;
				break;
			}

			lStreamSize -= ckItemList.cksize + 8;

			pRiffStream->Ascend( &ckItemList, 0 );
		}
		else
		{
			hr = E_FAIL;
			break;
		}
	}

	pRiffStream->Release();

	if( FAILED(hr) )
	{
		while( !lstNewItems.IsEmpty() )
		{
			delete lstNewItems.RemoveHead();
		}
	}

	return hr;
}

HRESULT CAudioPathDlg::DropOnTree( IDataObject* pIDataObject, DROPEFFECT dropEffect, POINT point)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(dropEffect);

	// BUGBUG: Use dropEffect (creating a send effect)

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDllDataObject = new CDllJazzDataObject();
	if( !pDllDataObject )
	{
		return E_OUTOFMEMORY;
	}

	// Try and get data in the the PChannel format
	IStream *pIStream = NULL;
	if( SUCCEEDED( pDllDataObject->AttemptRead( pIDataObject, CDirectMusicAudioPath::m_scfPChannel, &pIStream ) ) )
	{
		// Check to see if the PChannel items is dropped on an existing item
		UINT flags;
		int nTargetItem = m_tcTree.HitTest(point, &flags);
		if( nTargetItem < 0 )
		{
			// Dropping a MixGroup from this tree into a blank spot in the tree - no result
			if( m_pISourceDataObject == pIDataObject )
			{
				delete pDllDataObject;
				pIStream->Release();
				return S_FALSE;
			}
		}

		PastePChannels( pIStream, point );
	}
	else if( SUCCEEDED( pDllDataObject->AttemptRead( pIDataObject, CDirectMusicAudioPath::m_scfEffect, &pIStream ) ) )
	{
		UINT flags;
		int nTargetItem = m_tcTree.HitTest(point, &flags);
		if( nTargetItem >= 0 )
		{
			// Save an undo state
			m_pAudioPath->SaveUndoState( IDS_UNDO_DROP_EFFECTS, true );

			BusEffectInfo *pDroppedOnBusEffectInfo;
			RECT rectDroppedOnEffect;
			m_tcTree.GetEffectRect( point, nTargetItem, &pDroppedOnBusEffectInfo, &rectDroppedOnEffect );

			ItemInfo *pItemInfo = m_tcTree.GetItemInfo( nTargetItem );

			CTypedPtrList<CPtrList, EffectInfo *> lstEffects;
			EffectInfo *pNewEffectInfo = m_pAudioPath->LoadEffect( pIStream );
			while( pNewEffectInfo )
			{
				//SetI3DL2SrcDestinationIfNecessary( pNewEffectInfo );
				lstEffects.AddTail( pNewEffectInfo );
				pNewEffectInfo = m_pAudioPath->LoadEffect( pIStream );
			}

			if( !lstEffects.IsEmpty() )
			{
				// Ensure only the dropped effects are selected
				m_tcTree.UnselectAll();
			}

			if( pItemInfo && pDroppedOnBusEffectInfo && !lstEffects.IsEmpty() )
			{
				POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
				while( posBuffer )
				{
					BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

					POSITION pos = pBufferOptions->lstEffects.Find( pDroppedOnBusEffectInfo );
					if( pos )
					{
						while( !lstEffects.IsEmpty() )
						{
							// Create a BusEffectInfo to wrap the dropped EffectInfo
							pNewEffectInfo = lstEffects.RemoveHead();
							BusEffectInfo *pBusEffectInfo = new BusEffectInfo(pNewEffectInfo);

							// Make this effect selected
							pBusEffectInfo->m_beiSelection = BEI_NORMAL;

							if( point.x + GetScrollPos(SB_HORZ) <= rectDroppedOnEffect.left + pDroppedOnBusEffectInfo->m_lPixelWidth / 2 )
							{
								pBufferOptions->lstEffects.InsertBefore( pos, pBusEffectInfo );
							}
							else
							{
								pBufferOptions->lstEffects.InsertAfter( pos, pBusEffectInfo );
							}

							// Ensure the effect name is really unique
							m_pAudioPath->GetUniqueEffectInstanceNameIfNecessary( &pBusEffectInfo->m_EffectInfo );

							// Only need the EffectInfo during the load
							delete pNewEffectInfo;
						}
						break;
					}
				}
			}
			else if( pItemInfo && !pItemInfo->lstBuffers.IsEmpty() && !lstEffects.IsEmpty() )
			{
				// Get the wrapper structure for the item
				// lstOldItems
				ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(m_tcTree.GetItemData( nTargetItem ));
				if( pItemInfoWrapper )
				{
					// Pointer to each buffer
					BufferOptions *pBufferOptions = pItemInfoWrapper->pBufferOptions;

					// Add the effect to the buffer, if it supports effects,
					// and we can get the column widths
					long lMixGroupWidth, lBusWidth, lBufferWidth;
					if( ItemAndBufferSupportEffects( pItemInfo, pBufferOptions )
					&&	GetColumnWidths( lMixGroupWidth, lBusWidth, lBufferWidth ) )
					{
						// Determine whether to add to the start or end of the effect list
						const bool fAddToStart = (point.x + GetScrollPos(SB_HORZ)) <= lMixGroupWidth + lBusWidth + lBufferWidth;

						while( !lstEffects.IsEmpty() )
						{
							// Create a BusEffectInfo to wrap the dropped EffectInfo
							if( fAddToStart )
							{
								pNewEffectInfo = lstEffects.RemoveTail();
							}
							else
							{
								pNewEffectInfo = lstEffects.RemoveHead();
							}
							BusEffectInfo *pBusEffectInfo = new BusEffectInfo(pNewEffectInfo);

							// Make this effect selected
							pBusEffectInfo->m_beiSelection = BEI_NORMAL;

							if( fAddToStart )
							{
								pBufferOptions->lstEffects.AddHead( pBusEffectInfo );
							}
							else
							{
								pBufferOptions->lstEffects.AddTail( pBusEffectInfo );
							}

							// Ensure the effect name is really unique
							m_pAudioPath->GetUniqueEffectInstanceNameIfNecessary( &pBusEffectInfo->m_EffectInfo );

							delete pNewEffectInfo;
						}
					}
				}
			}

			while( !lstEffects.IsEmpty() )
			{
				// Ensure we don't leak any memory
				delete lstEffects.RemoveHead();
			}

			if( pItemInfo )
			{
				// Update the internal names, so that column resize works correctly
				UpdateTreeItemName( pItemInfo );

				// Resize the effect column, since an effect may have been added
				ResizeEffectColumn();
			}

			m_tcTree.InvalidateItem( nTargetItem );

			// Resort the display
			m_pAudioPath->UpdateDisplayIndexes();
			m_tcTree.SortItems( ComparePChannelsInTree, 0 );

			m_pAudioPath->SyncAudiopathsInUse( 0 );	

			// Set the focus to the mix group
			m_pAudioPathCtrl->SetLastFocus( FOC_MIXGROUP );

			// Switch to the correct property page
			m_pAudioPathCtrl->SwitchToCorrectPropertyPage();
		}
	}

	// If necessary, release our reference to the stream
	if( pIStream )
	{
		pIStream->Release();
	}

	// Delete the DLLDataObject we used to read in the data
	delete pDllDataObject;

	return S_OK;
}

void CAudioPathDlg::InsertPChannel( POINT pointInsert )
{
	// Convert from screen to client coordinates
	m_tcTree.ScreenToClient( &pointInsert );

	// Get the item inserted on
	UINT uFlags;
	int nItem = m_tcTree.HitTest( pointInsert, &uFlags );

	// Check if we found an item
	ItemInfo *pItemInfoToEdit = NULL;
	if( nItem >= 0  )
	{
		pItemInfoToEdit = m_tcTree.GetItemInfo( nItem );
	}

	// Initialize the add PChannel dialog
	CDlgAddPChannel dlgAddPChannel;

	// Set the PChannelName pointer
	IDMUSProdProject *pIDMUSProdProject;
	if( SUCCEEDED( theApp.m_pAudioPathComponent->m_pIFramework->FindProject( m_pAudioPath, &pIDMUSProdProject ) ) )
	{
		pIDMUSProdProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&dlgAddPChannel.m_pIPChannelName );
		pIDMUSProdProject->Release();
	}

	// Set up the array of existing PChannels
	POSITION pos = m_pAudioPath->m_lstItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		const ItemInfo *pItemInfo = m_pAudioPath->m_lstItems.GetNext( pos );

		// Skip the item we're editing
		if( pItemInfo != pItemInfoToEdit )
		{
			// Iterate through all PChannels
			for( int i=0; i < pItemInfo->nNumPChannels; i++ )
			{
				// Add each PChannel to the array (order is irrelevant)
				dlgAddPChannel.m_adwExistingPChannels.Add( pItemInfo->adwPChannels[i] );
			}
		}
	}

	// Set up the array of PChannels for the item we're adding
	if( pItemInfoToEdit )
	{
		// Itrate through all PChannels
		for( int i=0; i < pItemInfoToEdit->nNumPChannels; i++ )
		{
			// Add each PChannel to the array (order is irrelevant)
			dlgAddPChannel.m_adwPChannels.Add( pItemInfoToEdit->adwPChannels[i] );
		}
	}

	if( dlgAddPChannel.DoModal() == IDOK )
	{
		bool fChanged = false;
		if( !pItemInfoToEdit )
		{
			// Create a new Mix Group with these PChannels
			m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_INSERT_MIXGROUP, true );

			// Create a new item
			pItemInfoToEdit = new ItemInfo();
			if( pItemInfoToEdit )
			{
				// Get a mix group name for the PChannel
				pItemInfoToEdit->strBandName = m_pAudioPath->GetNewMixgroupName();

				// Get the default port
				pItemInfoToEdit->pPortOptions = m_pAudioPath->GetDefaultPort();

				// Create a buffer
				BufferOptions *pBufferOptions = new BufferOptions;

#ifdef DMP_XBOX
				// If the buffer will have zero PChannels
				if( 0 == dlgAddPChannel.m_adwPChannels.GetSize() )
				{
					// Must be shared I3DL2 Reverb
					pBufferOptions->dwHeaderFlags |= DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_SHARED;

					// Change the buffer's GUID
					pBufferOptions->guidBuffer = GUID_Buffer_EnvReverb;

					// Verify that either DSBCAPS_CTRL3D or DSBCAPS_CTRLPAN is set
					if( !(pBufferOptions->dwBufferFlags & DSBCAPS_CTRL3D)
					&&	!(pBufferOptions->dwBufferFlags & DSBCAPS_CTRLPAN) )
					{
						pBufferOptions->dwBufferFlags |= DSBCAPS_CTRLPAN;
					}

					// Ensure neither DSBCAPS_STATIC nor DSBCAPS_LOCDEFER are set
					pBufferOptions->dwBufferFlags &= ~(DSBCAPS_STATIC | DSBCAPS_LOCDEFER);

					// Remove all Bus IDs
					pBufferOptions->lstBusIDs.RemoveAll();

					// Ensure it has two channels
					pBufferOptions->wChannels = 2;
				}
#endif //DMP_XBOX

				// Add the buffer to the item
				pItemInfoToEdit->lstBuffers.AddTail( pBufferOptions );

				// Add the item to the AudioPath
				m_pAudioPath->InsertItemInfo( pItemInfoToEdit );

				// Add the item to the tree
				InsertItemIntoTree( pItemInfoToEdit );
			}
		}

		// This handles both inserting a new MixGroup and inserting PChannels
		if( pItemInfoToEdit )
		{
			// Get the new number of PChannels
			const long lNewPChannelCount = dlgAddPChannel.m_adwPChannels.GetSize();

			// Check if anything changed
			if( (pItemInfoToEdit->nNumPChannels != lNewPChannelCount)
			||	(memcmp( pItemInfoToEdit->adwPChannels, dlgAddPChannel.m_adwPChannels.GetData(), sizeof(DWORD) * pItemInfoToEdit->nNumPChannels )) )
			{
				// Save an undo state
				m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_ADDREMOVE_PCHANNELS, true );

				// Create a new array to store the PChannels in
				DWORD *adwNewPChannels = NULL;
				if( lNewPChannelCount )
				{
					adwNewPChannels = new DWORD[lNewPChannelCount];
				}
				if( (lNewPChannelCount == 0)
				||	adwNewPChannels )
				{
					// Copy the PChannels into the new array
					if( lNewPChannelCount )
					{
						memcpy( adwNewPChannels, dlgAddPChannel.m_adwPChannels.GetData(), sizeof(DWORD) * lNewPChannelCount );
					}

					// Delete the old array
					delete[] pItemInfoToEdit->adwPChannels;

					// Save the old number of PChannels
					const long lOldNumPChannels = pItemInfoToEdit->nNumPChannels;

					// Set the size of, and point to the new array
					pItemInfoToEdit->adwPChannels = adwNewPChannels;
					pItemInfoToEdit->nNumPChannels = lNewPChannelCount;

					// Flag if we need to refresh the entire mixgroup list
					bool fRefreshControls = false;

					if( 0 == lOldNumPChannels )
					{
						// Going from zero PChannels - update all send effects in case this
						// mix group was sent to
						m_pAudioPath->DisconnectSendEffects( pItemInfoToEdit );
					}
					else if( 0 == lNewPChannelCount )
					{
						// Going to zero PChannels

						// Ensure that there are no standard buffers
						POSITION posBuffer = pItemInfoToEdit->lstBuffers.GetHeadPosition();
						while( posBuffer )
						{
							BufferOptions *pBufferOptions = pItemInfoToEdit->lstBuffers.GetNext( posBuffer );
							if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
							{
#ifdef DMP_XBOX
								// Must be shared I3DL2 Reverb
								pBufferOptions->dwHeaderFlags |= DMUS_BUFFERF_SHARED;

								// Change the buffer's GUID
								pBufferOptions->guidBuffer = GUID_Buffer_EnvReverb;

								// Verify that either DSBCAPS_CTRL3D or DSBCAPS_CTRLPAN is set
								if( !(pBufferOptions->dwBufferFlags & DSBCAPS_CTRL3D)
								&&	!(pBufferOptions->dwBufferFlags & DSBCAPS_CTRLPAN) )
								{
									pBufferOptions->dwBufferFlags |= DSBCAPS_CTRLPAN;
								}

								// If the buffer has zero Bus IDs
								if( pBufferOptions->lstBusIDs.GetSize() == 0 )
								{
									// Ensure it has at least two Buses
									pBufferOptions->lstBusIDs.Add( DSBUSID_LEFT );
									pBufferOptions->lstBusIDs.Add( DSBUSID_RIGHT );
									pBufferOptions->wChannels = 2;
								}
#else //DMP_XBOX
								pBufferOptions->dwHeaderFlags &= ~(DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_SHARED);

								// Change the buffer's GUID
								CoCreateGuid( &pBufferOptions->guidBuffer );

								// Verify that either DSBCAPS_CTRL3D or DSBCAPS_CTRLPAN is set
								if( !(pBufferOptions->dwBufferFlags & DSBCAPS_CTRL3D)
								&&	!(pBufferOptions->dwBufferFlags & DSBCAPS_CTRLPAN) )
								{
									pBufferOptions->dwBufferFlags |= DSBCAPS_CTRLPAN;
								}

								// If the buffer has zero Bus IDs
								if( pBufferOptions->lstBusIDs.GetSize() == 0 )
								{
									// Ensure it has at least two Buses
									pBufferOptions->lstBusIDs.Add( DSBUSID_LEFT );
									pBufferOptions->lstBusIDs.Add( DSBUSID_RIGHT );
									pBufferOptions->wChannels = max( WORD(2), pBufferOptions->wChannels );
								}
#endif //DMP_XBOX
							}
						}

						// Split off any buffers (other than the first one) into new mix groups
						posBuffer = pItemInfoToEdit->lstBuffers.GetHeadPosition();
						pItemInfoToEdit->lstBuffers.GetNext( posBuffer );
						while( posBuffer )
						{
							POSITION posCurrent = posBuffer;
							BufferOptions *pBufferOptions = pItemInfoToEdit->lstBuffers.GetNext( posBuffer );

							// Create a new item
							ItemInfo *pNewItemInfo = new ItemInfo();
							if( pNewItemInfo )
							{
								// Get a mix group name for the PChannel
								pNewItemInfo->strBandName = m_pAudioPath->GetNewMixgroupName();

								// Get the default port
								pNewItemInfo->pPortOptions = m_pAudioPath->GetDefaultPort();

								// Add the buffer to the item
								pNewItemInfo->lstBuffers.AddTail( pBufferOptions );

								// Add the item to the AudioPath
								m_pAudioPath->InsertItemInfo( pNewItemInfo );

								// Add the item to the tree
								InsertItemIntoTree( pNewItemInfo );

								// Remove the buffer from the main item
								pItemInfoToEdit->lstBuffers.RemoveAt( posCurrent );

								fRefreshControls = true;
							}
						}

						// Connect any send effects that were broken
						m_pAudioPath->ConnectAllSendEffects();
					}

					// If the item has PChannels
					if( pItemInfoToEdit->nNumPChannels )
					{
						// Ensure that all its buffers have BusIDs
						POSITION posBuffer = pItemInfoToEdit->lstBuffers.GetHeadPosition();
						while( posBuffer )
						{
							BufferOptions *pBufferOptions = pItemInfoToEdit->lstBuffers.GetNext( posBuffer );

							// If not using a defined buffer
							if( !(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
							{
								if( pBufferOptions->lstBusIDs.GetSize() == 0 )
								{
									pBufferOptions->lstBusIDs.Add( DSBUSID_LEFT );
									pBufferOptions->lstBusIDs.Add( DSBUSID_RIGHT );
									pBufferOptions->wChannels = max( WORD(2), pBufferOptions->wChannels );
								}
							}
						}

						// Ensure that it has a port
						if( pItemInfoToEdit->pPortOptions == NULL )
						{
							pItemInfoToEdit->pPortOptions = m_pAudioPath->GetDefaultPort();
						}
					}
					// If the item has zero PChannels
					else
					{
						// Ensure it doesn not have a port
						pItemInfoToEdit->pPortOptions = NULL;

						// Ensure all its buffers have zero Bus IDs
						POSITION posBuffer = pItemInfoToEdit->lstBuffers.GetHeadPosition();
						while( posBuffer )
						{
							BufferOptions *pBufferOptions = pItemInfoToEdit->lstBuffers.GetNext( posBuffer );
							
							// If the buffer has some Bus IDs
							if( pBufferOptions->lstBusIDs.GetSize() > 0 )
							{
								// Set the # of channels in the buffer
								pBufferOptions->wChannels = WORD(pBufferOptions->lstBusIDs.GetSize());

								// Remove all Bus IDs
								pBufferOptions->lstBusIDs.RemoveAll();
							}

							// Ensure neither DSBCAPS_STATIC nor DSBCAPS_LOCDEFER are set
							pBufferOptions->dwBufferFlags &= ~(DSBCAPS_STATIC | DSBCAPS_LOCDEFER);
						}
					}

					if( fRefreshControls )
					{
						RefreshControls();
					}
					else
					{
						// Update the name of the item
						UpdateTreeItemName( pItemInfoToEdit );

						// Resort the tree
						m_pAudioPath->UpdateDisplayIndexes();
						m_tcTree.SortItems( ComparePChannelsInTree, 0 );
					}
				}
			}
		}

		m_pAudioPath->SyncAudiopathsInUse( AUDIOPATH_UNLOAD_DOWNLOAD_WAVES );
	}
}

void CAudioPathDlg::InsertEnvReverb()
{
	if( m_pAudioPath )
	{
		// Save an undo state
		bool fChanged = false;
		m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_INSERT_MIXGROUP, true );

		// Create a new item
		ItemInfo *pItemInfo = CreateEnvironmentItem();

		if( pItemInfo )
		{
			// Add the item to the AudioPath
			m_pAudioPath->InsertItemInfo( pItemInfo );

			// Add the item to the tree
			InsertItemIntoTree( pItemInfo );

			m_pAudioPath->SyncAudiopathsInUse( 0 );
		}
	}
}

void CAudioPathDlg::PastePChannels( IStream *pIStream, POINT pointPaste )
{
	// The list of PChannels to insert
	CTypedPtrList< CPtrList, ItemInfo *> lstNewItems;

	// Try and read in the list of PChannel items to insert (make sure the list is non-empty).
	if( SUCCEEDED( ReadInItems( pIStream, lstNewItems, m_pAudioPath ) )
	&&	!lstNewItems.IsEmpty() )
	{
		// Save an undo state
		m_pAudioPath->SaveUndoState( IDS_UNDO_DROP_PCHANNELS, true );

		// Check to see if the PChannel items is dropped on an existing item
		UINT flags;
		int nTargetItem = m_tcTree.HitTest(pointPaste, &flags);
		if( nTargetItem >= 0 )
		{
			ItemInfo *pTargetItem = m_tcTree.GetItemInfo( nTargetItem );
			ASSERT( pTargetItem );

			// Yes - add the PChannel items to this item
			while( !lstNewItems.IsEmpty() )
			{
				// Get a pointer to each item
				ItemInfo *pNewItem = lstNewItems.RemoveHead();

				// Iterate through all PChannels in each new item
				for( int i=0; i < pNewItem->nNumPChannels; i++ )
				{
					// Check if the PChannel already exists in the target item
					bool fAlreadyInTargetItem = false;
					if( pTargetItem->adwPChannels != NULL
					&&	pTargetItem->nNumPChannels > 0 )
					{
						for( long lIndex = 0; lIndex < pTargetItem->nNumPChannels; lIndex++ )
						{
							if( pTargetItem->adwPChannels[lIndex] == pTargetItem->adwPChannels[i] )
							{
								fAlreadyInTargetItem = true;
								break;
							}
						}
					}

					if( !fAlreadyInTargetItem )
					{
						// Delete the PChannel, if it exists
						DeletePChannel( pNewItem->adwPChannels[i] );

						// Add each new PChannel to nTargetItem
						InsertPChannelIntoItem( pTargetItem, pNewItem->adwPChannels[i] );
					}
				}

				// Delete the new item, since it's no longer needed
				delete pNewItem;
			}
		}
		else
		{
			// No - just add the PChannel items to the main part of the tree
			while( !lstNewItems.IsEmpty() )
			{
				// Remove the item from the list of new items
				ItemInfo *pNewItem = lstNewItems.RemoveHead();

				// Ensure we don't insert Env. Reverb more than once.
				if( IsItemEnvReverb( pNewItem )
				&&	HasEnvReverb() )
				{
					continue;
				}

				// Iterate through all PChannels in each new item
				for( int i=0; i < pNewItem->nNumPChannels; i++ )
				{
					// Delete the PChannel, if it exists
					DeletePChannel( pNewItem->adwPChannels[i] );
				}

				// Iterate through the buffers and give new GUIDs to all non-shared and non-defined buffers
				POSITION posBuffer = pNewItem->lstBuffers.GetHeadPosition();
				while( posBuffer )
				{
					BufferOptions *pBufferOptions = pNewItem->lstBuffers.GetNext( posBuffer );
					if( 0 == (pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
					{
						CoCreateGuid( &pBufferOptions->guidBuffer );
					}
				}

				// Add the item to the list of items in the AudioPath
				m_pAudioPath->InsertItemInfo( pNewItem );

				// Add the item to the PChannel tree
				InsertItemIntoTree( pNewItem );
			}
		}

		m_pAudioPath->UpdateDisplayIndexes();
		m_tcTree.SortItems( ComparePChannelsInTree, 0 );

		m_pAudioPath->SyncAudiopathsInUse( AUDIOPATH_UNLOAD_DOWNLOAD_WAVES );
	}
}

void CAudioPathDlg::PastePChannelFromClipboard( POINT pointPaste )
{
	// Get the IDataObject from the clipboard
	IDataObject *pIDataObject = NULL;
	if( FAILED(OleGetClipboard(&pIDataObject))
	||	(pIDataObject == NULL) )
	{
		return;
	}

	FORMATETC formatEtc;
	STGMEDIUM stgMedium;

	formatEtc.cfFormat = CDirectMusicAudioPath::m_scfPChannel;
	formatEtc.ptd = NULL;
	formatEtc.dwAspect = DVASPECT_CONTENT;
	formatEtc.lindex = -1;
	formatEtc.tymed = TYMED_ISTREAM;

	// Try and get data in the the PChannel format, ensuring that it is of a stream type
	if( SUCCEEDED( pIDataObject->GetData( &formatEtc, &stgMedium ) )
	&&	(stgMedium.tymed == TYMED_ISTREAM) )
	{
		m_tcTree.ScreenToClient( &pointPaste );
		PastePChannels( stgMedium.pstm, pointPaste );
	}

	pIDataObject->Release();
}

void CAudioPathDlg::PasteEffectFromClipboard( POINT pointPaste )
{
	// Get the IDataObject from the clipboard
	IDataObject *pIDataObject = NULL;
	if( FAILED(OleGetClipboard(&pIDataObject))
	||	(pIDataObject == NULL) )
	{
		return;
	}

	// Convert from screen to client coordinates
	m_tcTree.ScreenToClient( &pointPaste );

	DropOnTree( pIDataObject, DROPEFFECT_COPY, pointPaste );

	pIDataObject->Release();
}

int CAudioPathDlg::FindItem( const ItemInfo *pItemInfo, const BufferOptions *pBufferOptions )
{
	ASSERT( pItemInfo );

	// Iterate through our items
	for( int i=0; i < m_tcTree.GetItemCount(); i++ )
	{
		// Check if this is the item we're looking for
		const ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(m_tcTree.GetItemData( i ));
		if( pItemInfoWrapper )
		{
			if( (pItemInfoWrapper->pItemInfo == pItemInfo)
			&&	(!pBufferOptions || (pItemInfoWrapper->pBufferOptions == pBufferOptions)) )
			{
				return i;
			}
		}
	}

	return -1;
}

void CAudioPathDlg::InsertItemIntoTree( ItemInfo *pItem )
{
	ASSERT( pItem );

	if( pItem->lstBuffers.IsEmpty() )
	{
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM | LVIF_TEXT;
		lvItem.iItem = 0;
		lvItem.iSubItem = 0;
		lvItem.pszText = pItem->strBandName.GetBuffer( 0 );
		lvItem.lParam = DWORD(new ItemInfoWrapper(pItem, 0));
		m_tcTree.InsertItem( &lvItem );
		pItem->strBandName.ReleaseBuffer( -1 );
	}
	else
	{
		POSITION pos = pItem->lstBuffers.GetHeadPosition();
		while( pos )
		{
			BufferOptions *pBufferOptions = pItem->lstBuffers.GetNext( pos );
			LVITEM lvItem;
			lvItem.mask = LVIF_PARAM | LVIF_TEXT;
			lvItem.iItem = 0;
			lvItem.iSubItem = 0;
			lvItem.pszText = pItem->strBandName.GetBuffer( 0 );
			lvItem.lParam = DWORD(new ItemInfoWrapper(pItem, pBufferOptions));
			m_tcTree.InsertItem( &lvItem );
			pItem->strBandName.ReleaseBuffer( -1 );
		}
	}

	UpdateTreeItemName( pItem );
	m_pAudioPath->UpdateDisplayIndexes();
	m_tcTree.SortItems( ComparePChannelsInTree, 0 );
}

void CAudioPathDlg::InsertPChannelIntoItem( ItemInfo *pItemInfo, DWORD dwPChannel )
{
	// Verify the pointer to the band item
	if( pItemInfo == NULL )
	{
		return;
	}

	// Create a new array of PChannels (since we added one)
	DWORD *adwPChannels = new DWORD[pItemInfo->nNumPChannels + 1];

	// Copy the old array of PChannels into the new array, inserting the new PChannel
	// where appropriate
	for( long i=0; i < pItemInfo->nNumPChannels; i++ )
	{
		if( pItemInfo->adwPChannels[i] > dwPChannel )
		{
			memcpy( adwPChannels, pItemInfo->adwPChannels, sizeof(DWORD) * max( 0, i ) );
			adwPChannels[i] = dwPChannel;
			memcpy( &(adwPChannels[i+1]), &(pItemInfo->adwPChannels[i]), sizeof(DWORD) * max( 0, pItemInfo->nNumPChannels - i ) );
			break;
		}
	}

	// New PChannel goes at the end of the array
	if( i == pItemInfo->nNumPChannels )
	{
		memcpy( adwPChannels, pItemInfo->adwPChannels, sizeof(DWORD) * i );
		adwPChannels[i] = dwPChannel;
	}

	// Delete old array
	delete[] pItemInfo->adwPChannels;

	// Point the parent to the new array
	pItemInfo->adwPChannels = adwPChannels;
	pItemInfo->nNumPChannels++;

	// Ensure that all the buffers of this item have BusIDs
	POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
	while( posBuffer )
	{
		BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

		// If not using a defined buffer
		if( !(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
		{
			if( pBufferOptions->lstBusIDs.GetSize() == 0 )
			{
				pBufferOptions->lstBusIDs.Add( DSBUSID_LEFT );
				pBufferOptions->lstBusIDs.Add( DSBUSID_RIGHT );
				pBufferOptions->wChannels = max( WORD(2), pBufferOptions->wChannels );
			}
		}
	}

	// Ensure that it has a port
	if( pItemInfo->pPortOptions == NULL )
	{
		pItemInfo->pPortOptions = m_pAudioPath->GetDefaultPort();
	}

	// Need to update the name of the parent
	UpdateTreeItemName( pItemInfo );

	m_pAudioPath->UpdateDisplayIndexes();
	m_tcTree.SortItems( ComparePChannelsInTree, 0 );
}

void CAudioPathDlg::DeletePChannel( DWORD dwPChannel )
{
	// Get a handle to the first item
	for( int iItemToDelete = 0; iItemToDelete < m_tcTree.GetItemCount(); iItemToDelete++ )
	{
		// Get a pointer to this mix group item
		ItemInfo *pItemRootInfo = m_tcTree.GetItemInfo( iItemToDelete );

		if( pItemRootInfo == NULL )
		{
			// Move on to check the next mix group item
			continue;
		}

		for( int i=0; i < pItemRootInfo->nNumPChannels; i++ )
		{
			if( pItemRootInfo->adwPChannels[i] == dwPChannel )
			{
				// Check if this is the only PChannel in the mix group
				if( pItemRootInfo->nNumPChannels == 1 )
				{
					// Only PChannel in mix group - remove the entire group.
					const POSITION posToRemove = m_pAudioPath->m_lstItems.Find( pItemRootInfo );
					ASSERT( posToRemove );
					m_pAudioPath->m_lstItems.RemoveAt( posToRemove );

					// Delete item from list control

					// Iterate through our items
					for( int iToDel=m_tcTree.GetItemCount() - 1; iToDel >= 0; iToDel-- )
					{
						// Check if this is the item we're looking for
						ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(m_tcTree.GetItemData( iToDel ));
						if( pItemInfoWrapper
						&&	pItemInfoWrapper->pItemInfo == pItemRootInfo )
						{
							// Yes - delete the item
							m_tcTree.DeleteItem( iToDel );
							delete pItemInfoWrapper;
						}
					}

					iItemToDelete = 0;
					delete pItemRootInfo;
				}
				else
				{
					// More than one PChannel in this mix group - remove only this PChannel

					// Decrement the number of PChannels in the mix group
					pItemRootInfo->nNumPChannels--;

					// Create a new array of PChannels
					DWORD *adwPChannels = new DWORD[pItemRootInfo->nNumPChannels];

					// Copy all but the PChannel we're deleting to the new array
					int j=0;
					for( int k=0; k < pItemRootInfo->nNumPChannels + 1; k++ )
					{
						if( pItemRootInfo->adwPChannels[k] != dwPChannel )
						{
							adwPChannels[j] = pItemRootInfo->adwPChannels[k];
							j++;
						}
					}

					// Delete the parent's existing array
					delete[] pItemRootInfo->adwPChannels;

					// Replace the parent's PChannel array
					pItemRootInfo->adwPChannels = adwPChannels;

					// Update the name of the parent
					UpdateTreeItemName( pItemRootInfo );
				}

				// Can only have one instance of a PChannel, so return
				return;
			}
		}
	}
}

void CAudioPathDlg::UpdateBufferForPPG( void )
{
	// Point the item at the correct audio path
	m_BufferInfoForPPG.m_pAudioPath = m_pAudioPath;
	m_BufferInfoForPPG.m_strAudioPathName = m_pAudioPath->m_strName;
	m_BufferInfoForPPG.m_dwChanged = 0;

	// Get a pointer to the first selected buffer
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	if( m_tcTree.GetFirstSelectedThing( &pItemInfo, &pBufferOptions, NULL ) == BUS_BUFFER_COL )
	{
		// If the item doesn't support buffers
		if( !ItemSupportsBuffers( pItemInfo ) )
		{
			m_BufferInfoForPPG.m_fValid = false;
		}
		else
		{
			m_BufferInfoForPPG.Import( pBufferOptions, pItemInfo->nNumPChannels > 0 );
			m_BufferInfoForPPG.m_fValid = true;
		}
	}
	else
	{
		m_BufferInfoForPPG.m_fValid = false;
	}
}

void CAudioPathDlg::SwitchToBufferPPG( void ) 
{
	// Fix 30394: Keep this method from being called from itself (or another SwitchTo() method)
	if( m_fEnteredSwitchTo )
	{
		return;
	}

	m_fEnteredSwitchTo = true;

	UpdateBufferForPPG();

	// Change to the buffer property page, if the property sheet is visible
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		// Check if property sheet is visible
		if( pIPropSheet->IsShowing() == S_OK )
		{
			// Change to the Buffer property page manager
			short nActiveTab = CBufferPPGMgr::sm_nActiveTab;
			if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIBufferPageManager) ) )
			{
				// Point the Buffer property page manager back at this
				theApp.m_pAudioPathComponent->m_pIBufferPageManager->SetObject( this );

				// Set the correct active property page tab
				pIPropSheet->SetActivePage( nActiveTab ); 
			}

			// Refresh the property sheet title
			pIPropSheet->RefreshTitleByObject( this );

			// Refresh the property sheet page
			pIPropSheet->RefreshActivePageByObject( this );
		}

		pIPropSheet->Release();
	}

	m_fEnteredSwitchTo = false;
}

void CAudioPathDlg::UpdateEffectForPPG( void )
{
	// Point the item at the correct audio path
	m_EffectInfoForPPG.m_pAudioPath = m_pAudioPath;
	m_EffectInfoForPPG.m_strAudioPathName = m_pAudioPath->m_strName;
	m_EffectInfoForPPG.m_dwChanged = 0;

	// Get a pointer to the first selected effect
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	BusEffectInfo *pBusEffectInfo;
	if( m_tcTree.GetFirstSelectedThing( &pItemInfo, &pBufferOptions, &pBusEffectInfo ) == EFFECT_COL )
	{
		// If the item doesn't support effects
		if( !ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
		{
			m_EffectInfoForPPG.m_fValid = false;
		}
		else
		{
			m_EffectInfoForPPG.Import( pBusEffectInfo->m_EffectInfo );
			m_EffectInfoForPPG.m_guidMyBuffer = pBufferOptions->guidBuffer;
			m_EffectInfoForPPG.m_fValid = true;
		}
	}
	else
	{
		m_EffectInfoForPPG.m_fValid = false;
	}
}

void CAudioPathDlg::SwitchToEffectPPG( void ) 
{
	// Fix 30394: Keep this method from being called from itself (or another SwitchTo() method)
	if( m_fEnteredSwitchTo )
	{
		return;
	}

	m_fEnteredSwitchTo = true;

	UpdateEffectForPPG();

	// Change to the effect property page, if the property sheet is visible
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		// Check if property sheet is visible
		if( pIPropSheet->IsShowing() == S_OK )
		{
			// Change to the Effect property page manager
			short nActiveTab = CEffectPPGMgr::sm_nActiveTab;
			if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIEffectPageManager) ) )
			{
				// Point the Effect property page manager back at this
				theApp.m_pAudioPathComponent->m_pIEffectPageManager->SetObject( this );

				// Set the correct active property page tab
				pIPropSheet->SetActivePage( nActiveTab ); 
			}

			// Refresh the property sheet title
			pIPropSheet->RefreshTitleByObject( this );

			// Refresh the property sheet page
			pIPropSheet->RefreshActivePageByObject( this );
		}

		pIPropSheet->Release();
	}

	m_fEnteredSwitchTo = false;
}

void CAudioPathDlg::UpdateMixGroupForPPG( void )
{
	// Get a pointer to the first selected item
	const ItemInfo *pItemInfo = m_tcTree.GetFirstSelectedMixGroupItem();

	// Point the item at the correct audio path
	m_MixGroupInfoForPPG.m_pAudioPath = m_pAudioPath;
	m_MixGroupInfoForPPG.m_strAudioPathName = m_pAudioPath->m_strName;
	m_MixGroupInfoForPPG.m_dwChanged = 0;

	// Check if there is a selected item
	if( pItemInfo )
	{
		// Copy the selected item to m_MixGroupInfoForPPG
		m_MixGroupInfoForPPG.m_strMixGroupName = pItemInfo->strBandName;
		m_MixGroupInfoForPPG.m_PortOptions.Copy( pItemInfo->pPortOptions );
		m_MixGroupInfoForPPG.m_dwFlags = pItemInfo->pPortOptions ? MGI_HAS_SYNTH : 0;
		m_MixGroupInfoForPPG.m_dwFlags |= ItemSupportsBuffers( pItemInfo ) ? 0 : MGI_CAN_EDIT_SYNTH;
		m_MixGroupInfoForPPG.m_dwFlags |= IsItemEnvReverb( pItemInfo ) ? MGI_DONT_EDIT_NAME : 0;
		m_MixGroupInfoForPPG.m_fValid = true;
	}
	else
	{
		m_MixGroupInfoForPPG.m_fValid = false;
	}
}

void CAudioPathDlg::SwitchToMixGroupPPG( void ) 
{
	// Fix 30394: Keep this method from being called from itself (or another SwitchTo() method)
	if( m_fEnteredSwitchTo )
	{
		return;
	}

	m_fEnteredSwitchTo = true;

	UpdateMixGroupForPPG();

	// Change to the mix group property page, if the property sheet is visible
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		// Check if property sheet is visible
		if( pIPropSheet->IsShowing() == S_OK )
		{
			// Change to the MixGroup property page manager
			short nActiveTab = CMixGroupPPGMgr::sm_nActiveTab;
			if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIMixGroupPageManager) ) )
			{
				// Point the MixGroup property page manager back at this
				theApp.m_pAudioPathComponent->m_pIMixGroupPageManager->SetObject( this );

				// Set the correct active property page tab
				pIPropSheet->SetActivePage( nActiveTab ); 
			}

			// Refresh the property sheet title
			pIPropSheet->RefreshTitleByObject( this );

			// Refresh the property sheet page
			pIPropSheet->RefreshActivePageByObject( this );
		}

		pIPropSheet->Release();
	}

	m_fEnteredSwitchTo = false;
}

void CAudioPathDlg::OnEditSelectAll() 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( &pItemInfo, &pBufferOptions, NULL );
	if( tColumn == EFFECT_COL )
	{
		// Make only these effects selected
		m_tcTree.UnselectAll();

		POSITION pos = pBufferOptions->lstEffects.GetHeadPosition();
		while( pos )
		{
			pBufferOptions->lstEffects.GetNext( pos )->m_beiSelection = BEI_NORMAL;
		}

		m_tcTree.InvalidateItem( pItemInfo );
	}
	else //if( (tColumn == PCHANNEL_COL) || (tColumn == BUS_BUFFER_COL) )
	{
		m_tcTree.SelectAll();
	}
}

void CAudioPathDlg::OnUpdateEditSelectAll(CCmdUI* pCmdUI) 
{
	ASSERT( m_pAudioPath != NULL );

	// Find out what is selected in the tree
	TreeColumn tColumn = m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL );
	if( tColumn == EFFECT_COL )
	{
		pCmdUI->Enable( TRUE );
	}
	else //if( (tColumn == PCHANNEL_COL) || (tColumn == BUS_BUFFER_COL) )
	{
		pCmdUI->Enable( (m_tcTree.GetItemCount() > 0) ? TRUE : FALSE );
	}
}

bool CAudioPathDlg::HasEnvReverb( void ) 
{
	// Search for EnvReverb
	POSITION posItem = m_pAudioPath->m_lstItems.GetHeadPosition();
	while( posItem )
	{
		ItemInfo *pItemInfo = m_pAudioPath->m_lstItems.GetNext( posItem );

		// Only need to check the first buffer
		if( pItemInfo->lstBuffers.GetCount() > 0 )
		{
			if( pItemInfo->lstBuffers.GetHead()->guidBuffer == GUID_Buffer_EnvReverb )
			{
				return true;
			}
		}
	}

	return false;
}

void CAudioPathDlg::SwitchToCorrectPropertyPage( void )
{
	// Find out what is selected in the tree
	switch( m_tcTree.GetFirstSelectedThing( NULL, NULL, NULL ) )
	{
	case PCHANNEL_COL:
		SwitchToMixGroupPPG();
		break;
	case EFFECT_COL:
		SwitchToEffectPPG();
		break;
	case BUS_BUFFER_COL:
		SwitchToBufferPPG();
		break;
	default:
		// Remove MixGroup, Buffer, and Effect from property sheet
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RemovePageManagerByObject( this );
			pIPropSheet->Release();
		}
		break;
	}
}

bool CAudioPathDlg::GetColumnWidths( long &lMixGroup, long &lBus, long &lBuffer )
{
	LVCOLUMN lvColumn;

	lvColumn.mask = LVCF_WIDTH;
	if( m_tcTree.GetColumn( 0, &lvColumn ) )
	{
		lMixGroup = lvColumn.cx;
		if( m_tcTree.GetColumn( 1, &lvColumn ) )
		{
			lBus = lvColumn.cx;
			if( m_tcTree.GetColumn( 2, &lvColumn ) )
			{
				lBuffer = lvColumn.cx;
				return true;
			}
		}
	}

	return false;
}

/*
void CAudioPathDlg::OnBeginTrackHeader(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NMHEADER *pNMHEADER = (NMHEADER *)pNMHDR;

	// Disable resizing Effects list header
	*pResult = (pNMHEADER->iItem == 3) ? 1 : 0;
}
*/

void CAudioPathDlg::OnEndTrackHeader(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NMHEADER *pNMHEADER = (NMHEADER *)pNMHDR;

	ResizeEffectColumn();

	*pResult = 0;

	if( pNMHEADER->pitem
	&&	(pNMHEADER->pitem->mask & HDI_WIDTH) )
	{
		switch( pNMHEADER->iItem )
		{
		case 0:
			if( m_pAudioPath->m_wMixGroupWidth != WORD(pNMHEADER->pitem->cxy) )
			{
				m_pAudioPath->SetModified( TRUE );
				m_pAudioPath->m_wMixGroupWidth = WORD(pNMHEADER->pitem->cxy);
			}
			break;
		case 1:
			if( m_pAudioPath->m_wBusWidth != WORD(pNMHEADER->pitem->cxy) )
			{
				m_pAudioPath->SetModified( TRUE );
				m_pAudioPath->m_wBusWidth = WORD(pNMHEADER->pitem->cxy);
			}
			break;
		case 2:
			if( m_pAudioPath->m_wBufferWidth != WORD(pNMHEADER->pitem->cxy) )
			{
				m_pAudioPath->SetModified( TRUE );
				m_pAudioPath->m_wBufferWidth = WORD(pNMHEADER->pitem->cxy);
			}
			break;
		case 3:
			if( m_tcTree.GetColumnWidth( 3 ) != pNMHEADER->pitem->cxy )
			{
				pNMHEADER->pitem->cxy = m_tcTree.GetColumnWidth( 3 );
			}
			*pResult = 1;
			break;
		}
	}
}

void CAudioPathDlg::OnDividerDblClickHeader(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NMHEADER *pNMHEADER = (NMHEADER *)pNMHDR;

	*pResult = 0;

	WORD wWidth = WORD(m_tcTree.GetColumnWidth( pNMHEADER->iItem ));

	switch( pNMHEADER->iItem )
	{
	case 0:
		if( m_pAudioPath->m_wMixGroupWidth != wWidth )
		{
			m_pAudioPath->SetModified( TRUE );
			m_pAudioPath->m_wMixGroupWidth = wWidth;
		}
		break;
	case 1:
		if( m_pAudioPath->m_wBusWidth != wWidth )
		{
			m_pAudioPath->SetModified( TRUE );
			m_pAudioPath->m_wBusWidth = wWidth;
		}
		break;
	case 2:
		if( m_pAudioPath->m_wBufferWidth != wWidth )
		{
			m_pAudioPath->SetModified( TRUE );
			m_pAudioPath->m_wBufferWidth = wWidth;
		}
		break;
		/*
	case 3:
		if( m_pAudioPath->m_wEffectWidth != wWidth )
		{
			m_pAudioPath->SetModified( TRUE );
			m_pAudioPath->m_wEffectWidth = wWidth;
		}
		break;
		*/
	}

	ResizeEffectColumn();
}

/*
void CAudioPathDlg::SetI3DL2SrcDestinationIfNecessary( EffectInfo *pEffectInfoToChange )
{
	if( pEffectInfoToChange
	&&	(pEffectInfoToChange->m_clsidObject == GUID_DSFX_STANDARD_I3DL2SOURCE )
	&&	(pEffectInfoToChange->m_clsidSendBuffer == GUID_NULL) )
	{
		// Iterate through the list of items
		POSITION posItem = m_pAudioPath->m_lstItems.GetHeadPosition();
		while( posItem )
		{
			// Get a pointer to each item
			ItemInfo *pItemInfo = m_pAudioPath->m_lstItems.GetNext( posItem );

			// If the port doesn't support buffers, skip it
			if( !ItemSupportsBuffers( pItemInfo ) )
			{
				continue;
			}

			// If the port has any PChannels, skip it
			if( pItemInfo->nNumPChannels > 0 )
			{
				continue;
			}

			// Iterate through the list of buffers
			POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
			DWORD dwBufferNum = 0;
			while( posBuffer )
			{
				// Get a pointer to each buffer
				BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

				// Iterate through the list of effects
				POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
				DWORD dwEffectNum = 0;

				// If the buffer does not support effects, don't check any of the effects in the buffer
				if( !ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
				{
					posEffect = NULL;
				}

				while( posEffect )
				{
					// Get a pointer to each effect
					BusEffectInfo *pBusEffectInfoInList = pBufferOptions->lstEffects.GetNext( posEffect );

					// Check if this is the effect we're looking for
					if( pBusEffectInfoInList->m_EffectInfo.m_clsidObject == GUID_DSFX_STANDARD_I3DL2REVERB )
					{
						// Found an I3DL2 reverb effect
						pEffectInfoToChange->m_clsidSendBuffer = pBufferOptions->guidBuffer;
						pEffectInfoToChange->m_pSendDestinationMixGroup = pItemInfo;
						return;
					}

					// Increment the effect index
					dwEffectNum++;
				}

				// Increment the buffer index
				dwBufferNum++;
			}
		}

		// Didn't find an I3DL2 reverb effect, just use the standard env. reverb buffer GUID
		pEffectInfoToChange->m_clsidSendBuffer = GUID_Buffer_EnvReverb;
		pEffectInfoToChange->m_pSendDestinationMixGroup = NULL;
	}
}
*/

void CAudioPathDlg::ResizeEffectColumn( void )
{
	// Resize the effect column to fill up the empty space
	long lMixGroup, lBus, lBuffer;
	if( GetColumnWidths( lMixGroup, lBus, lBuffer ) )
	{
		// Get the dialog's client rect
		RECT rect;
		GetClientRect(&rect);

		// Set the effect column's width
		m_tcTree.SetColumnWidth( 3, max( GetMinEffectWidth(), rect.right - rect.left + GetScrollPos(SB_HORZ) - lMixGroup - lBus - lBuffer ) );
	}
}

int CAudioPathDlg::GetMinEffectWidth( void )
{
	int nMaxWidth = 1;
	CString strEffectText;

	POSITION posItem = m_pAudioPath->m_lstItems.GetHeadPosition();
	while( posItem )
	{
		ItemInfo *pItemInfo = m_pAudioPath->m_lstItems.GetNext( posItem );

		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			EffectListToString( pItemInfo, pBufferOptions, strEffectText );

			const int nEffectWidth = m_tcTree.GetStringWidth( strEffectText );
			if( nEffectWidth > nMaxWidth )
			{
				nMaxWidth = nEffectWidth;
			}
		}
	}

	return nMaxWidth;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathRef.cpp ===
// AudioPathRef.cpp : implementation file
//

#include "stdafx.h"
#include "AudioPathDesignerDLL.h"

#include "AudioPath.h"
#include "AudioPathRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef constructor/destructor

CAudioPathRef::CAudioPathRef()
{
    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pAudioPath = NULL;
}

CAudioPathRef::~CAudioPathRef()
{
	RELEASE( m_pAudioPath );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IUnknown implementation

HRESULT CAudioPathRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CAudioPathRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CAudioPathRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetNodeImageIndex

HRESULT CAudioPathRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );

	return( theApp.m_pAudioPathComponent->GetAudioPathRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetFirstChild

HRESULT CAudioPathRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// AudioPathRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetNextChild

HRESULT CAudioPathRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// AudioPathRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetComponent

HRESULT CAudioPathRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );

	return theApp.m_pAudioPathComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetDocRootNode

HRESULT CAudioPathRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::SetDocRootNode

HRESULT CAudioPathRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetParentNode

HRESULT CAudioPathRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::SetParentNode

HRESULT CAudioPathRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetNodeId

HRESULT CAudioPathRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_AudioPathRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetNodeName

HRESULT CAudioPathRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath == NULL )
	{
		TCHAR achNoAudioPath[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_AUDIOPATH, achNoAudioPath, MID_BUFFER );
		CString strNoAudioPath = achNoAudioPath;
		*pbstrName = strNoAudioPath.AllocSysString();
		return S_OK;
	}

    return m_pAudioPath->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CAudioPathRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a AudioPathRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::ValidateNodeName

HRESULT CAudioPathRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a AudioPathRef node
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::SetNodeName

HRESULT CAudioPathRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a AudioPathRef node
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetNodeListInfo

HRESULT CAudioPathRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath == NULL )
	{
		return E_FAIL;
	}

    return m_pAudioPath->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetEditorClsId

HRESULT CAudioPathRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_AudioPathEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetEditorTitle

HRESULT CAudioPathRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath == NULL )
	{
		return E_FAIL;
	}

    return m_pAudioPath->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetEditorWindow

HRESULT CAudioPathRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath == NULL )
	{
		return E_FAIL;
	}

    return m_pAudioPath->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::SetEditorWindow

HRESULT CAudioPathRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath == NULL )
	{
		return E_FAIL;
	}

    return m_pAudioPath->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::UseOpenCloseImages

HRESULT CAudioPathRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetRightClickMenuId

HRESULT CAudioPathRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_AUDIOPATHREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CAudioPathRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CAudioPathRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pAudioPath )
			{
				return m_pAudioPath->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::DeleteChildNode

HRESULT CAudioPathRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// AudioPathRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::InsertChildNode

HRESULT CAudioPathRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// AudioPathRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::DeleteNode

HRESULT CAudioPathRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete AudioPathRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::OnNodeSelChanged

HRESULT CAudioPathRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::CreateDataObject

HRESULT CAudioPathRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pAudioPath )
	{
		// Let AudioPath create data object
		return m_pAudioPath->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::CanCut

HRESULT CAudioPathRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::CanCopy

HRESULT CAudioPathRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pAudioPath )
	{
		return S_OK;	// Will copy the AudioPath
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::CanDelete

HRESULT CAudioPathRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::CanDeleteChildNode

HRESULT CAudioPathRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// AudioPath Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::CanPasteFromData

HRESULT CAudioPathRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a AudioPath
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pAudioPathComponent->m_cfAudioPath );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a AudioPath
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pAudioPath )
	{
		// Let AudioPath decide what can be dropped
		return m_pAudioPath->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::PasteFromData

HRESULT CAudioPathRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a AudioPath
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pAudioPathComponent->m_cfAudioPath );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of AudioPath
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pAudioPath )
	{
		// Let AudioPath handle paste
		return m_pAudioPath->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::CanChildPasteFromData

HRESULT CAudioPathRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// AudioPath Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::ChildPasteFromData

HRESULT CAudioPathRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// AudioPath Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdNode::GetObject

HRESULT CAudioPathRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CAudioPathRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pAudioPath )
	{
		m_pAudioPath->AddRef();
		*ppIDocRootNode = m_pAudioPath;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CAudioPathRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a AudioPath Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_AudioPathNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pAudioPath );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pAudioPath = (CDirectMusicAudioPath *)pIDocRootNode;
		m_pAudioPath->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioPathRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\Dlg3DParam.cpp ===
// Dlg3DParam.cpp : implementation file
//

#include "stdafx.h"
#include "Dlg3DParam.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define POSITION_FORMAT _T("%.4f")

/*
// The amount to multiply the slider position by to get the actual position value
#define POSITION_FACTOR (1000000000 / 10000)

#define VELOCITY_FORMAT POSITION_FORMAT
#define VELOCITY_FACTOR POSITION_FACTOR

#define CONE_FORMAT POSITION_FORMAT
#define CONE_FACTOR POSITION_FACTOR
*/

#define DISTANCE_FORMAT POSITION_FORMAT

/////////////////////////////////////////////////////////////////////////////
// C3DEdit class


IMPLEMENT_DYNCREATE( C3DEdit, CEdit )

C3DEdit::C3DEdit() : CEdit()
{
	m_fMinusValid = true;
	m_fDotValid = true;
}

LRESULT C3DEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8:  // Backspace
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			break;
		case '.':
			if( !m_fDotValid )
			{
				return TRUE;
			}
			break;
		case '-':
			if( m_fMinusValid )
			{
				break;
			}
			// else return TRUE
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}


/////////////////////////////////////////////////////////////////////////////
// CDlg3DParam dialog


CDlg3DParam::CDlg3DParam(CWnd* pParent /*=NULL*/)
	: CDialog(CDlg3DParam::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CDlg3DParam)
	//}}AFX_DATA_INIT
}


void CDlg3DParam::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlg3DParam)
	DDX_Control(pDX, IDC_EDIT_CONE_OUTSIDE, m_editConeOutside);
	DDX_Control(pDX, IDC_EDIT_CONE_INSIDE, m_editConeInside);
	DDX_Control(pDX, IDC_EDIT_CONE_VOLUME, m_editConeVolume);
	DDX_Control(pDX, IDC_EDIT_MAX_DISTANCE, m_editMaxDistance);
	DDX_Control(pDX, IDC_EDIT_MIN_DISTANCE, m_editMinDistance);
	DDX_Control(pDX, IDC_EDIT_ZVEL, m_editZVel);
	DDX_Control(pDX, IDC_EDIT_YVEL, m_editYVel);
	DDX_Control(pDX, IDC_EDIT_XVEL, m_editXVel);
	DDX_Control(pDX, IDC_EDIT_ZPOS, m_editZPos);
	DDX_Control(pDX, IDC_EDIT_YPOS, m_editYPos);
	DDX_Control(pDX, IDC_EDIT_XPOS, m_editXPos);
	DDX_Control(pDX, IDC_EDIT_ZCONE, m_editZCone);
	DDX_Control(pDX, IDC_EDIT_YCONE, m_editYCone);
	DDX_Control(pDX, IDC_EDIT_XCONE, m_editXCone);
	DDX_Control(pDX, IDC_COMBO_MODE, m_comboMode);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlg3DParam, CDialog)
	//{{AFX_MSG_MAP(CDlg3DParam)
	ON_EN_KILLFOCUS(IDC_EDIT_CONE_INSIDE, OnKillfocusEditConeInside)
	ON_EN_KILLFOCUS(IDC_EDIT_CONE_OUTSIDE, OnKillfocusEditConeOutside)
	ON_EN_KILLFOCUS(IDC_EDIT_CONE_VOLUME, OnKillfocusEditConeVolume)
	ON_EN_KILLFOCUS(IDC_EDIT_MAX_DISTANCE, OnKillfocusEditMaxDistance)
	ON_EN_KILLFOCUS(IDC_EDIT_MIN_DISTANCE, OnKillfocusEditMinDistance)
	ON_EN_KILLFOCUS(IDC_EDIT_XCONE, OnKillfocusEditXcone)
	ON_EN_KILLFOCUS(IDC_EDIT_XPOS, OnKillfocusEditXpos)
	ON_EN_KILLFOCUS(IDC_EDIT_XVEL, OnKillfocusEditXvel)
	ON_EN_KILLFOCUS(IDC_EDIT_YCONE, OnKillfocusEditYcone)
	ON_EN_KILLFOCUS(IDC_EDIT_YPOS, OnKillfocusEditYpos)
	ON_EN_KILLFOCUS(IDC_EDIT_YVEL, OnKillfocusEditYvel)
	ON_EN_KILLFOCUS(IDC_EDIT_ZCONE, OnKillfocusEditZcone)
	ON_EN_KILLFOCUS(IDC_EDIT_ZPOS, OnKillfocusEditZpos)
	ON_EN_KILLFOCUS(IDC_EDIT_ZVEL, OnKillfocusEditZvel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlg3DParam message handlers

// Slider control helper function
/*
void OnHSCrollHelper( UINT nSBCode, UINT nPos, CSliderCtrl &sliderCtrl, C3DEdit &editCtrl )
{
	UNREFERENCED_PARAMETER(nPos);
	UNREFERENCED_PARAMETER(nSBCode);
	CString strText;
	strText.Format( POSITION_FORMAT, float(sliderCtrl.GetPos()) );
	editCtrl.SetWindowText( strText );
}

void CDlg3DParam::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pScrollBar )
	{
		switch( pScrollBar->GetDlgCtrlID() )
		{
		case IDC_SLIDER_XPOS:
			OnHSCrollHelper( nSBCode, nPos, m_sliderXPos, m_editXPos );
			break;
		case IDC_SLIDER_YPOS:
			OnHSCrollHelper( nSBCode, nPos, m_sliderYPos, m_editYPos );
			break;
		case IDC_SLIDER_ZPOS:
			OnHSCrollHelper( nSBCode, nPos, m_sliderZPos, m_editZPos );
			break;

		case IDC_SLIDER_XVEL:
			OnHSCrollHelper( nSBCode, nPos, m_sliderXVel, m_editXVel );
			break;
		case IDC_SLIDER_YVEL:
			OnHSCrollHelper( nSBCode, nPos, m_sliderYVel, m_editYVel );
			break;
		case IDC_SLIDER_ZVEL:
			OnHSCrollHelper( nSBCode, nPos, m_sliderZVel, m_editZVel );
			break;

		case IDC_SLIDER_XCONE:
			OnHSCrollHelper( nSBCode, nPos, m_sliderXCone, m_editXCone );
			break;
		case IDC_SLIDER_YCONE:
			OnHSCrollHelper( nSBCode, nPos, m_sliderYCone, m_editYCone );
			break;
		case IDC_SLIDER_ZCONE:
			OnHSCrollHelper( nSBCode, nPos, m_sliderZCone, m_editZCone );
			break;
		}
	}

	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}
*/

void CDlg3DParam::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/* Not necessary - updated on EN_KILLFOCUS notifications
	// Get Position
	if( !GetFloat( IDC_EDIT_XPOS, &m_ds3DBuffer.vPosition.x ) )
	{
		AfxMessageBox("Bad X Position.");
		return;
	}
	if( !GetFloat( IDC_EDIT_YPOS, &m_ds3DBuffer.vPosition.y ) )
	{
		AfxMessageBox("Bad Y Position.");
		return;
	}
	if( !GetFloat( IDC_EDIT_ZPOS, &m_ds3DBuffer.vPosition.z ) )
	{
		AfxMessageBox("Bad Z Position.");
		return;
	}

	// Get Velocity
	if( !GetFloat( IDC_EDIT_XVEL, &m_ds3DBuffer.vVelocity.x ) )
	{
		AfxMessageBox("Bad X Velocity.");
		return;
	}
	if( !GetFloat( IDC_EDIT_YVEL, &m_ds3DBuffer.vVelocity.y ) )
	{
		AfxMessageBox("Bad Y Velocity.");
		return;
	}
	if( !GetFloat( IDC_EDIT_ZVEL, &m_ds3DBuffer.vVelocity.z ) )
	{
		AfxMessageBox("Bad Z Velocity.");
		return;
	}

	// Get Cone Orientation
	if( !GetFloat( IDC_EDIT_XCONE, &m_ds3DBuffer.vConeOrientation.x ) )
	{
		AfxMessageBox("Bad X Cone Orientation.");
		return;
	}
	if( !GetFloat( IDC_EDIT_YCONE, &m_ds3DBuffer.vConeOrientation.y ) )
	{
		AfxMessageBox("Bad Y Cone Orientation.");
		return;
	}
	if( !GetFloat( IDC_EDIT_ZCONE, &m_ds3DBuffer.vConeOrientation.z ) )
	{
		AfxMessageBox("Bad Z Cone Orientation.");
		return;
	}

	// Get Cone angles
	BOOL fSuccess = FALSE;
	long lTemp;
	lTemp = GetDlgItemInt( IDC_EDIT_CONE_INSIDE, &fSuccess, FALSE );
	if( !fSuccess )
	{
		AfxMessageBox("Bad Cone Inside Angle.");
		return;
	}
	m_ds3DBuffer.dwInsideConeAngle = lTemp;
	lTemp = GetDlgItemInt( IDC_EDIT_CONE_OUTSIDE, &fSuccess, FALSE );
	if( !fSuccess )
	{
		AfxMessageBox("Bad Cone Outisde Angle.");
		return;
	}
	m_ds3DBuffer.dwOutsideConeAngle = lTemp;


	// Get Cone outside volume
	lTemp = GetDlgItemInt( IDC_EDIT_CONE_VOLUME, &fSuccess, TRUE );
	if( !fSuccess )
	{
		AfxMessageBox("Bad Cone Outside Volume.");
		return;
	}
	m_ds3DBuffer.lConeOutsideVolume = lTemp;


	// Get distance
	if( !GetFloat( IDC_EDIT_MIN_DISTANCE, &m_ds3DBuffer.flMinDistance ) )
	{
		AfxMessageBox("Bad Min Distance.");
		return;
	}
	if( !GetFloat( IDC_EDIT_MAX_DISTANCE, &m_ds3DBuffer.flMaxDistance ) )
	{
		AfxMessageBox("Bad Max Distance.");
		return;
	}
	*/


	// Get mode
	long lTemp = m_comboMode.GetCurSel();
	if( lTemp == CB_ERR )
	{
		AfxMessageBox("Bad Mode.");
		return;
	}
	m_ds3DBuffer.dwMode = lTemp;
	
	CDialog::OnOK();
}

void SliderInitHelper( /*CSliderCtrl &sliderCtrl,*/ C3DEdit &editCtrl, float fValue, int nLength )
{
	/*
	sliderCtrl.SetRangeMin( int(-DS3D_DEFAULTMAXDISTANCE), FALSE );
	sliderCtrl.SetRangeMax( int(DS3D_DEFAULTMAXDISTANCE), TRUE );
	sliderCtrl.SetLineSize( int(DS3D_DEFAULTMAXDISTANCE / 100) );
	sliderCtrl.SetPageSize( int(DS3D_DEFAULTMAXDISTANCE / 10) );
	sliderCtrl.SetPos( int(fValue) );
	*/
	CString strText;
	strText.Format( POSITION_FORMAT, fValue );
	editCtrl.SetWindowText( strText );
	editCtrl.SetLimitText( nLength );
}

BOOL CDlg3DParam::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	CString strText;
	int nLength;

	// Compute the maximum number of characters for the postition, velocity, and cone orientation
	strText.Format( _T("%f"), -DS3D_DEFAULTMAXDISTANCE );
	nLength = strText.GetLength();

	// Set Position
	SliderInitHelper( /*m_sliderXPos,*/ m_editXPos, m_ds3DBuffer.vPosition.x, nLength );
	SliderInitHelper( /*m_sliderYPos,*/ m_editYPos, m_ds3DBuffer.vPosition.y, nLength );
	SliderInitHelper( /*m_sliderZPos,*/ m_editZPos, m_ds3DBuffer.vPosition.z, nLength );


	// Set Velocity
	SliderInitHelper( /*m_sliderXVel,*/ m_editXVel, m_ds3DBuffer.vVelocity.x, nLength );
	SliderInitHelper( /*m_sliderYVel,*/ m_editYVel, m_ds3DBuffer.vVelocity.y, nLength );
	SliderInitHelper( /*m_sliderZVel,*/ m_editZVel, m_ds3DBuffer.vVelocity.z, nLength );


	// Set Cone Orientation
	SliderInitHelper( /*m_sliderXCone,*/ m_editXCone, m_ds3DBuffer.vConeOrientation.x, nLength );
	SliderInitHelper( /*m_sliderYCone,*/ m_editYCone, m_ds3DBuffer.vConeOrientation.y, nLength );
	SliderInitHelper( /*m_sliderZCone,*/ m_editZCone, m_ds3DBuffer.vConeOrientation.z, nLength );


	// Set Cone angles
	SetDlgItemInt( IDC_EDIT_CONE_INSIDE, m_ds3DBuffer.dwInsideConeAngle, FALSE );
	SetDlgItemInt( IDC_EDIT_CONE_OUTSIDE, m_ds3DBuffer.dwOutsideConeAngle, FALSE );
	strText.Format( _T("%d"), DS3D_MAXCONEANGLE );
	m_editConeInside.SetLimitText( strText.GetLength() );
	m_editConeOutside.SetLimitText( strText.GetLength() );


	// Set Cone outside volume
	m_editConeVolume.m_fDotValid = false;
	SetDlgItemInt( IDC_EDIT_CONE_VOLUME, m_ds3DBuffer.lConeOutsideVolume, TRUE );
	strText.Format( _T("%d"), DSBVOLUME_MIN );
	m_editConeVolume.SetLimitText( strText.GetLength() );


	// Set distance
	m_editMaxDistance.m_fMinusValid = false;
	m_editMinDistance.m_fMinusValid = false;
	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.flMinDistance );
	SetDlgItemText( IDC_EDIT_MIN_DISTANCE, strText );
	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.flMaxDistance );
	SetDlgItemText( IDC_EDIT_MAX_DISTANCE, strText );


	// Set mode
	m_comboMode.SetCurSel( m_ds3DBuffer.dwMode );


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

bool CDlg3DParam::GetFloat( int nControlID, float *pfValue )
{
	ASSERT( pfValue );

	CString strText;
	if( GetDlgItemText( nControlID, strText ) == 0 )
	{
		// If no text was copied, return false
		return false;
	}

	// Convert from text to float
	bool fResult = false;
	TCHAR *tcstrTmp = new TCHAR[strText.GetLength() + 1];
	tcstrTmp[0] = 0;
	if( _stscanf( strText, "%f%s", pfValue, tcstrTmp )
	&&	(tcstrTmp[0] == 0) )
	{
		fResult = true;
	}

	delete tcstrTmp;

	return fResult;
}

void CDlg3DParam::OnKillfocusEditConeInside() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL fSuccess = FALSE;
	DWORD dwTemp = GetDlgItemInt( IDC_EDIT_CONE_INSIDE, &fSuccess, FALSE );
	if( fSuccess )
	{
		if( dwTemp > DS3D_MAXCONEANGLE )
		{
			dwTemp = DS3D_MAXCONEANGLE;
		}

		if( dwTemp > m_ds3DBuffer.dwOutsideConeAngle )
		{
			m_ds3DBuffer.dwOutsideConeAngle = dwTemp;
			SetDlgItemInt( IDC_EDIT_CONE_OUTSIDE, dwTemp, FALSE );
		}

		m_ds3DBuffer.dwInsideConeAngle = dwTemp;
	}

	SetDlgItemInt( IDC_EDIT_CONE_INSIDE, m_ds3DBuffer.dwInsideConeAngle, FALSE );
}

void CDlg3DParam::OnKillfocusEditConeOutside() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL fSuccess = FALSE;
	DWORD dwTemp = GetDlgItemInt( IDC_EDIT_CONE_OUTSIDE, &fSuccess, FALSE );
	if( fSuccess )
	{
		if( dwTemp > DS3D_MAXCONEANGLE )
		{
			dwTemp = DS3D_MAXCONEANGLE;
		}

		if( dwTemp < m_ds3DBuffer.dwInsideConeAngle )
		{
			m_ds3DBuffer.dwInsideConeAngle = dwTemp;
			SetDlgItemInt( IDC_EDIT_CONE_INSIDE, dwTemp, FALSE );
		}

		m_ds3DBuffer.dwOutsideConeAngle = dwTemp;
	}

	SetDlgItemInt( IDC_EDIT_CONE_OUTSIDE, m_ds3DBuffer.dwOutsideConeAngle, FALSE );
}

void CDlg3DParam::OnKillfocusEditConeVolume() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL fSuccess = FALSE;
	long lTemp = GetDlgItemInt( IDC_EDIT_CONE_VOLUME, &fSuccess, TRUE );
	if( fSuccess )
	{
		if( lTemp < DSBVOLUME_MIN )
		{
			lTemp = DSBVOLUME_MIN;
		}
		else if( lTemp > DSBVOLUME_MAX )
		{
			lTemp = DSBVOLUME_MAX;
		}

		m_ds3DBuffer.lConeOutsideVolume = lTemp;
	}

	SetDlgItemInt( IDC_EDIT_CONE_VOLUME, m_ds3DBuffer.lConeOutsideVolume, TRUE );
}

void CDlg3DParam::OnKillfocusEditMaxDistance() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( !GetFloat( IDC_EDIT_MAX_DISTANCE, &fTemp ) )
	{
		strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.flMaxDistance );
		SetDlgItemText( IDC_EDIT_MAX_DISTANCE, strText );
		return;
	}

	if( fTemp <= 0.0 )
	{
		fTemp = 0.01f;
	}

	if( fTemp < m_ds3DBuffer.flMinDistance )
	{
		m_ds3DBuffer.flMinDistance = fTemp;
		strText.Format( DISTANCE_FORMAT, fTemp );
		SetDlgItemText( IDC_EDIT_MIN_DISTANCE, strText );
	}

	m_ds3DBuffer.flMaxDistance = fTemp;
	strText.Format( DISTANCE_FORMAT, fTemp );
	SetDlgItemText( IDC_EDIT_MAX_DISTANCE, strText );
}

void CDlg3DParam::OnKillfocusEditMinDistance() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( !GetFloat( IDC_EDIT_MIN_DISTANCE, &fTemp ) )
	{
		strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.flMinDistance );
		SetDlgItemText( IDC_EDIT_MIN_DISTANCE, strText );
		return;
	}

	if( fTemp <= 0.0 )
	{
		fTemp = 0.01f;
	}

	if( fTemp > m_ds3DBuffer.flMaxDistance )
	{
		m_ds3DBuffer.flMaxDistance = fTemp;
		strText.Format( DISTANCE_FORMAT, fTemp );
		SetDlgItemText( IDC_EDIT_MAX_DISTANCE, strText );
	}

	m_ds3DBuffer.flMinDistance = fTemp;
	strText.Format( DISTANCE_FORMAT, fTemp );
	SetDlgItemText( IDC_EDIT_MIN_DISTANCE, strText );
}

void CDlg3DParam::OnKillfocusEditXcone() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_XCONE, &fTemp ) )
	{
		if( (fTemp == 0.0)
		&&	(m_ds3DBuffer.vConeOrientation.y == 0.0)
		&&	(m_ds3DBuffer.vConeOrientation.z == 0.0) )
		{
			fTemp = 0.01f;
		}

		m_ds3DBuffer.vConeOrientation.x = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vConeOrientation.x );
	SetDlgItemText( IDC_EDIT_XCONE, strText );
}

void CDlg3DParam::OnKillfocusEditYcone() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_YCONE, &fTemp ) )
	{
		if( (fTemp == 0.0)
		&&	(m_ds3DBuffer.vConeOrientation.x == 0.0)
		&&	(m_ds3DBuffer.vConeOrientation.z == 0.0) )
		{
			fTemp = 0.01f;
		}

		m_ds3DBuffer.vConeOrientation.y = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vConeOrientation.y );
	SetDlgItemText( IDC_EDIT_YCONE, strText );
}

void CDlg3DParam::OnKillfocusEditZcone() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_ZCONE, &fTemp ) )
	{
		if( (fTemp == 0.0)
		&&	(m_ds3DBuffer.vConeOrientation.x == 0.0)
		&&	(m_ds3DBuffer.vConeOrientation.y == 0.0) )
		{
			fTemp = 0.01f;
		}

		m_ds3DBuffer.vConeOrientation.z = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vConeOrientation.z );
	SetDlgItemText( IDC_EDIT_ZCONE, strText );
}

void CDlg3DParam::OnKillfocusEditXpos() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_XPOS, &fTemp ) )
	{
		m_ds3DBuffer.vPosition.x = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vPosition.x );
	SetDlgItemText( IDC_EDIT_XPOS, strText );
}

void CDlg3DParam::OnKillfocusEditYpos() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_YPOS, &fTemp ) )
	{
		m_ds3DBuffer.vPosition.y = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vPosition.y );
	SetDlgItemText( IDC_EDIT_YPOS, strText );
}

void CDlg3DParam::OnKillfocusEditZpos() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_ZPOS, &fTemp ) )
	{
		m_ds3DBuffer.vPosition.z = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vPosition.z );
	SetDlgItemText( IDC_EDIT_ZPOS, strText );
}

void CDlg3DParam::OnKillfocusEditXvel() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_XVEL, &fTemp ) )
	{
		m_ds3DBuffer.vVelocity.x = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vVelocity.x );
	SetDlgItemText( IDC_EDIT_XVEL, strText );
}

void CDlg3DParam::OnKillfocusEditYvel() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_YVEL, &fTemp ) )
	{
		m_ds3DBuffer.vVelocity.y = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vVelocity.y );
	SetDlgItemText( IDC_EDIT_YVEL, strText );
}

void CDlg3DParam::OnKillfocusEditZvel() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	float fTemp;
	if( GetFloat( IDC_EDIT_ZVEL, &fTemp ) )
	{
		m_ds3DBuffer.vVelocity.z = fTemp;
	}

	strText.Format( DISTANCE_FORMAT, m_ds3DBuffer.vVelocity.z );
	SetDlgItemText( IDC_EDIT_ZVEL, strText );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgAddRemoveBuses.h ===
#if !defined(AFX_DLGADDREMOVEBUSES_H__19553BDD_5245_48A5_97EB_10978E4C04E6__INCLUDED_)
#define AFX_DLGADDREMOVEBUSES_H__19553BDD_5245_48A5_97EB_10978E4C04E6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgAddRemoveBuses.h : header file
//

#include "resource.h"

#define MAX_AUDIO_CHANNELS 2

/////////////////////////////////////////////////////////////////////////////
// CDlgAddRemoveBuses dialog

class CDlgAddRemoveBuses : public CDialog
{
// Construction
public:
	CDlgAddRemoveBuses(CWnd* pParent = NULL);   // standard constructor

	CDWordArray	m_adwBusIDs;

// Dialog Data
	//{{AFX_DATA(CDlgAddRemoveBuses)
	enum { IDD = IDD_DLG_ADD_BUSES };
	CButton	m_btnUp;
	CButton	m_btnDown;
	CButton	m_btnAdd;
	CButton	m_btnRemove;
	CListBox	m_listInUse;
	CListBox	m_listAvailable;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgAddRemoveBuses)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void AddStringToAvailableList( int nStringID, DWORD dwBusID );
	void AddBusIDToUsedList( DWORD dwBusID );
	void SortUsedList( void );

	// Generated message map functions
	//{{AFX_MSG(CDlgAddRemoveBuses)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonRemove();
	afx_msg void OnButtonReset();
	afx_msg void OnButtonUp();
	afx_msg void OnButtonDown();
	virtual void OnOK();
	afx_msg void OnDblclkListBusAvailble();
	afx_msg void OnDblclkListBusInuse();
	afx_msg void OnSelchangeListBusInuse();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADDREMOVEBUSES_H__19553BDD_5245_48A5_97EB_10978E4C04E6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\Dlg3DParam.h ===
#if !defined(AFX_DLG3DPARAM_H__CCAD8313_1528_4555_A4EF_AF3A9548FF1A__INCLUDED_)
#define AFX_DLG3DPARAM_H__CCAD8313_1528_4555_A4EF_AF3A9548FF1A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Dlg3DParam.h : header file
//

#include "resource.h"
#include "dsound.h"

/////////////////////////////////////////////////////////////////////////////
// C3DEdit class

class C3DEdit :
	public CEdit
{
	DECLARE_DYNCREATE(C3DEdit)
public:
	C3DEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	bool	m_fMinusValid;
	bool	m_fDotValid;

protected:
};

/////////////////////////////////////////////////////////////////////////////
// CDlg3DParam dialog

class CDlg3DParam : public CDialog
{
// Construction
public:
	CDlg3DParam(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlg3DParam)
	enum { IDD = IDD_DLG_3D_POS };
	CEdit	m_editConeOutside;
	CEdit	m_editConeInside;
	C3DEdit	m_editConeVolume;
	C3DEdit	m_editMaxDistance;
	C3DEdit	m_editMinDistance;
	C3DEdit	m_editZVel;
	C3DEdit	m_editYVel;
	C3DEdit	m_editXVel;
	C3DEdit	m_editZPos;
	C3DEdit	m_editYPos;
	C3DEdit	m_editXPos;
	C3DEdit	m_editZCone;
	C3DEdit	m_editYCone;
	C3DEdit	m_editXCone;
	CComboBox	m_comboMode;
	//}}AFX_DATA

	DS3DBUFFER m_ds3DBuffer;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlg3DParam)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	bool GetFloat( int nControlID, float *pfValue );

	// Generated message map functions
	//{{AFX_MSG(CDlg3DParam)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusEditConeInside();
	afx_msg void OnKillfocusEditConeOutside();
	afx_msg void OnKillfocusEditConeVolume();
	afx_msg void OnKillfocusEditMaxDistance();
	afx_msg void OnKillfocusEditMinDistance();
	afx_msg void OnKillfocusEditXcone();
	afx_msg void OnKillfocusEditXpos();
	afx_msg void OnKillfocusEditXvel();
	afx_msg void OnKillfocusEditYcone();
	afx_msg void OnKillfocusEditYpos();
	afx_msg void OnKillfocusEditYvel();
	afx_msg void OnKillfocusEditZcone();
	afx_msg void OnKillfocusEditZpos();
	afx_msg void OnKillfocusEditZvel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLG3DPARAM_H__CCAD8313_1528_4555_A4EF_AF3A9548FF1A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgEditSynth.cpp ===
// DlgEditSynth.cpp : implementation file
//

#include "stdafx.h"
#include "DlgEditSynth.h"
#include "dmusicc.h"
#include "ItemInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgEditSynth dialog


CDlgEditSynth::CDlgEditSynth(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgEditSynth::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CDlgEditSynth)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_dwEffects = 0;
	m_dwSupportedEffects = 0xFFFFFFFF;
	m_dwSampleRate = 22050;
	m_dwVoices = DEFAULT_NUM_VOICES;
	m_dwMaxVoices = DEFAULT_NUM_VOICES;
}


void CDlgEditSynth::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgEditSynth)
	DDX_Control(pDX, IDC_SPIN_VOICES, m_spinVoices);
	DDX_Control(pDX, IDC_EDIT_VOICES, m_editVoices);
	DDX_Control(pDX, IDC_EDIT_SYNTH_NAME, m_editSynthName);
	DDX_Control(pDX, IDC_CHECK_REVERB, m_checkReverb);
	DDX_Control(pDX, IDC_CHECK_CHORUS, m_checkChorus);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgEditSynth, CDialog)
	//{{AFX_MSG_MAP(CDlgEditSynth)
	ON_EN_KILLFOCUS(IDC_EDIT_VOICES, OnKillfocusEditVoices)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgEditSynth message handlers

void CDlgEditSynth::OnKillfocusEditVoices() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fSucceeded;
	int nNumVoices = GetDlgItemInt( IDC_EDIT_VOICES, &fSucceeded, FALSE );
	if( !fSucceeded
	||	nNumVoices < 1 )
	{
		// Set a minimum of 1
		nNumVoices = 1;

		// Reset the number of channels
		SetDlgItemInt( IDC_EDIT_VOICES, nNumVoices, FALSE );
		m_spinVoices.SetPos( nNumVoices );
	}
	else if( (unsigned) nNumVoices > m_dwMaxVoices )
	{
		// Set a maximum of m_dwMaxVoices
		nNumVoices = m_dwMaxVoices;

		// Reset the number of channels
		SetDlgItemInt( IDC_EDIT_VOICES, nNumVoices, FALSE );
		m_spinVoices.SetPos( nNumVoices );
	}
}

void CDlgEditSynth::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_dwVoices = m_spinVoices.GetPos();

	m_dwEffects = m_checkReverb.GetCheck() ? DMUS_EFFECT_REVERB : 0;
	m_dwEffects |= m_checkChorus.GetCheck() ? DMUS_EFFECT_CHORUS : 0;

	switch( GetCheckedRadioButton( IDC_11, IDC_48 ) )
	{
	case IDC_11:
		m_dwSampleRate = 11025;
		break;
	case IDC_44:
		m_dwSampleRate = 44100;
		break;
	case IDC_48:
		m_dwSampleRate = 48000;
		break;
	case IDC_22:
	default:
		m_dwSampleRate = 22050;
		break;
	}

	CDialog::OnOK();
}

BOOL CDlgEditSynth::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	if( m_dwMaxVoices == 0xFFFFFFFF )
	{
		m_spinVoices.EnableWindow( FALSE );
		m_editVoices.EnableWindow( FALSE );
		m_editVoices.SetWindowText( _T("---") );
	}
	else
	{
		TCHAR tcstrTmp[12];
		_itot( m_dwMaxVoices, tcstrTmp, 10 );
		m_editVoices.SetLimitText( _tcslen( tcstrTmp ) );
		m_spinVoices.SetRange( 1, m_dwMaxVoices );
		m_spinVoices.SetPos( m_dwVoices );
	}

	// Ensure that only supported effects are checked
	m_dwEffects &= m_dwSupportedEffects;

	m_checkReverb.EnableWindow( (m_dwSupportedEffects & DMUS_EFFECT_REVERB) ? TRUE : FALSE );
	m_checkReverb.SetCheck( (m_dwEffects & DMUS_EFFECT_REVERB) ? 1 : 0 );
	m_checkChorus.EnableWindow( (m_dwSupportedEffects & DMUS_EFFECT_CHORUS) ? TRUE : FALSE );
	m_checkChorus.SetCheck( (m_dwEffects & DMUS_EFFECT_CHORUS) ? 1 : 0 );

	switch( m_dwSampleRate )
	{
	case 11025:
		CheckRadioButton( IDC_11, IDC_48, IDC_11 );
		break;
	case 44100:
		CheckRadioButton( IDC_11, IDC_48, IDC_44 );
		break;
	case 48000:
		CheckRadioButton( IDC_11, IDC_48, IDC_48 );
		break;
	case 22050:
	default:
		CheckRadioButton( IDC_11, IDC_48, IDC_22 );
		break;
	}
	
	m_editSynthName.SetWindowText( m_strName );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgAddRemoveBuses.cpp ===
// DlgAddRemoveBuses.cpp : implementation file
//

#include "stdafx.h"
#include "DlgAddRemoveBuses.h"
#include "dmusicc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgAddRemoveBuses dialog

#define BUSID_STEREO 0xFFFFFFFF

CDlgAddRemoveBuses::CDlgAddRemoveBuses(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgAddRemoveBuses::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CDlgAddRemoveBuses)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgAddRemoveBuses::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgAddRemoveBuses)
	DDX_Control(pDX, IDC_BUTTON_UP, m_btnUp);
	DDX_Control(pDX, IDC_BUTTON_DOWN, m_btnDown);
	DDX_Control(pDX, IDC_BUTTON_ADD, m_btnAdd);
	DDX_Control(pDX, IDC_BUTTON_REMOVE, m_btnRemove);
	DDX_Control(pDX, IDC_LIST_BUS_INUSE, m_listInUse);
	DDX_Control(pDX, IDC_LIST_BUS_AVAILBLE, m_listAvailable);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgAddRemoveBuses, CDialog)
	//{{AFX_MSG_MAP(CDlgAddRemoveBuses)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
	ON_BN_CLICKED(IDC_BUTTON_RESET, OnButtonReset)
	ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
	ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
	ON_LBN_DBLCLK(IDC_LIST_BUS_AVAILBLE, OnDblclkListBusAvailble)
	ON_LBN_DBLCLK(IDC_LIST_BUS_INUSE, OnDblclkListBusInuse)
	ON_LBN_SELCHANGE(IDC_LIST_BUS_INUSE, OnSelchangeListBusInuse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgAddRemoveBuses message handlers

void CDlgAddRemoveBuses::AddStringToAvailableList( int nStringID, DWORD dwBusID )
{
	CString strBus;
	if( strBus.LoadString( nStringID ) )
	{
		int nIndex = m_listAvailable.AddString( strBus );
		m_listAvailable.SetItemData( nIndex, dwBusID );
	}
}

BOOL CDlgAddRemoveBuses::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	m_listAvailable.ResetContent();

	AddStringToAvailableList( IDS_BUSID512, DSBUSID_DYNAMIC_0 );
	AddStringToAvailableList( IDS_BUSID_STEREO, BUSID_STEREO );

	AddStringToAvailableList( IDS_BUSID64, DSBUSID_REVERB_SEND );
	AddStringToAvailableList( IDS_BUSID65, DSBUSID_CHORUS_SEND );

	AddStringToAvailableList( IDS_BUSID0, DSBUSID_LEFT );
	AddStringToAvailableList( IDS_BUSID1, DSBUSID_RIGHT );

	CString strBus;
	for( int i=0; i<m_adwBusIDs.GetSize(); i++ )
	{
		DWORD dwBusID = m_adwBusIDs.GetAt( i );
		if( strBus.LoadString( dwBusID - DSBUSID_LEFT + IDS_BUSID0 ) )
		{
			int nIndex = m_listInUse.AddString( strBus );
			m_listInUse.SetItemData( nIndex, dwBusID );
		}
	}

	m_btnRemove.EnableWindow( (m_adwBusIDs.GetSize() > 0) ? TRUE : FALSE );
	// Fix 46903: DMP: Order of busses not correct if users does not list them in ascending order
	// Disallow moving the buses, since we're going to resort them anyways
	//m_btnUp.EnableWindow( (m_adwBusIDs.GetSize() > 1) ? TRUE : FALSE );
	//m_btnDown.EnableWindow( (m_adwBusIDs.GetSize() > 1) ? TRUE : FALSE );
	m_btnUp.EnableWindow( FALSE );
	m_btnDown.EnableWindow( FALSE );
	m_btnAdd.EnableWindow( (m_adwBusIDs.GetSize() < MAX_AUDIO_CHANNELS) ? TRUE : FALSE );

	m_listInUse.SetCurSel( 0 );
	m_listAvailable.SetCurSel( 0 );

	OnSelchangeListBusInuse();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgAddRemoveBuses::OnButtonAdd() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nIndex = m_listAvailable.GetCurSel();
	if( nIndex != LB_ERR )
	{
		DWORD dwBusID = m_listAvailable.GetItemData( nIndex );

		if( dwBusID == BUSID_STEREO )
		{
			AddBusIDToUsedList( DSBUSID_LEFT );
			AddBusIDToUsedList( DSBUSID_RIGHT );
		}
		else
		{
			AddBusIDToUsedList( dwBusID );
		}

		SortUsedList();

		m_listAvailable.SetCurSel( nIndex + 1 );
	}
}

void CDlgAddRemoveBuses::AddBusIDToUsedList( DWORD dwBusID )
{
	if( m_listInUse.GetCount() >= MAX_AUDIO_CHANNELS )
	{
		return;
	}

	CString strBus;
	if( strBus.LoadString( dwBusID - DSBUSID_LEFT + IDS_BUSID0 ) )
	{
		int nNewIndex = m_listInUse.GetCurSel();
		if( nNewIndex == LB_ERR )
		{
			nNewIndex = 0;
		}
		else
		{
			nNewIndex++;
		}

		m_listInUse.InsertString( nNewIndex, strBus );
		m_listInUse.SetItemData( nNewIndex, dwBusID );

		m_btnRemove.EnableWindow( TRUE );

		m_listInUse.SetCurSel( nNewIndex );

		if( m_listInUse.GetCount() >= MAX_AUDIO_CHANNELS )
		{
			m_btnAdd.SetButtonStyle( BS_PUSHBUTTON, TRUE );
			m_btnRemove.SetButtonStyle( BS_DEFPUSHBUTTON, TRUE );
			m_btnAdd.EnableWindow( FALSE );
			m_btnRemove.SetFocus();
		}

		OnSelchangeListBusInuse();
	}
}

void CDlgAddRemoveBuses::OnButtonRemove() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nIndex = m_listInUse.GetCurSel();
	if( nIndex != LB_ERR )
	{
		// TODO: Select dwBusID in m_listAvailable ?
		//DWORD dwBusID = m_listInUse.GetItemData( nIndex );

		m_listInUse.DeleteString( nIndex );

		m_btnAdd.EnableWindow( TRUE );

		if( m_listInUse.GetCount() == 0 )
		{
			m_btnAdd.SetFocus();
			m_btnAdd.SetButtonStyle( BS_DEFPUSHBUTTON, TRUE );
			m_btnRemove.SetButtonStyle( BS_PUSHBUTTON, TRUE );
			m_btnRemove.EnableWindow( FALSE );
		}
		else
		{
			m_listInUse.SetCurSel( min(m_listInUse.GetCount() - 1, nIndex) );
		}

		OnSelchangeListBusInuse();
	}
}

void CDlgAddRemoveBuses::OnButtonReset() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Remove all existing buses
	m_listInUse.ResetContent();

	// Add just the dynamic bus
	CString strBus;
	if( strBus.LoadString( IDS_BUSID512 ) )
	{
		int nNewIndex = m_listInUse.AddString( strBus );
		m_listInUse.SetItemData( nNewIndex, DSBUSID_DYNAMIC_0 );

		m_listInUse.SetCurSel( nNewIndex );

		m_btnRemove.EnableWindow( TRUE );
		m_btnAdd.EnableWindow( TRUE );
	}

	OnSelchangeListBusInuse();
}

void CDlgAddRemoveBuses::OnButtonUp() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the index of the selected bus
	int nIndex = m_listInUse.GetCurSel();
	if( nIndex != LB_ERR )
	{
		// This shouldn't be zero
		ASSERT( nIndex != 0 );

		// Get the bus ID of the selected bus
		DWORD dwBusID = m_listInUse.GetItemData( nIndex );

		// Remove the selected bus
		m_listInUse.DeleteString( nIndex );

		// Move the selected bus up one
		nIndex = max( 0, nIndex - 1 );

		// Re-add the selected bus
		CString strBus;
		if( strBus.LoadString( dwBusID - DSBUSID_LEFT + IDS_BUSID0 ) )
		{
			m_listInUse.InsertString( nIndex, strBus );
			m_listInUse.SetItemData( nIndex, dwBusID );

			m_listInUse.SetCurSel( nIndex );
		}

		OnSelchangeListBusInuse();

		SortUsedList();
	}
}

void CDlgAddRemoveBuses::OnButtonDown() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the index of the selected bus
	int nIndex = m_listInUse.GetCurSel();
	if( nIndex != LB_ERR )
	{
		// This shouldn't be the last bus
		ASSERT( nIndex != m_listInUse.GetCount() - 1 );

		// Get the bus ID of the selected bus
		DWORD dwBusID = m_listInUse.GetItemData( nIndex );

		// Remove the selected bus
		m_listInUse.DeleteString( nIndex );

		// Move the selected bus down one
		nIndex = min( nIndex + 1, m_listInUse.GetCount() );

		// Re-add the selected bus
		CString strBus;
		if( strBus.LoadString( dwBusID - DSBUSID_LEFT + IDS_BUSID0 ) )
		{
			m_listInUse.InsertString( nIndex, strBus );
			m_listInUse.SetItemData( nIndex, dwBusID );

			m_listInUse.SetCurSel( nIndex );
		}

		OnSelchangeListBusInuse();

		SortUsedList();
	}
}

void CDlgAddRemoveBuses::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_adwBusIDs.RemoveAll();

	for( int nIndex = 0; nIndex < m_listInUse.GetCount(); nIndex++ )
	{
		m_adwBusIDs.Add( m_listInUse.GetItemData( nIndex ) );
	}

	if( m_adwBusIDs.GetSize() == 0 )
	{
		AfxMessageBox(IDS_ZERO_BUSES);
		return;
	}

	CDialog::OnOK();
}

void CDlgAddRemoveBuses::OnDblclkListBusAvailble() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_listInUse.GetCount() < MAX_AUDIO_CHANNELS )
	{
		OnButtonAdd();
	}
}

void CDlgAddRemoveBuses::OnDblclkListBusInuse() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OnButtonRemove();
}

void CDlgAddRemoveBuses::OnSelchangeListBusInuse() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Fix 46903: DMP: Order of busses not correct if users does not list them in ascending order
	// Disallow moving the buses, since we're going to resort them anyways
	/*
	BOOL fEnableUp = (m_listInUse.GetCount() > 1) ? TRUE : FALSE;
	BOOL fEnableDown = fEnableUp;

	// Get the selected index
	int nIndex = m_listInUse.GetCurSel();
	if( nIndex == LB_ERR )
	{
		fEnableUp = FALSE;
		fEnableDown = FALSE;
	}

	if( fEnableUp )
	{
		fEnableUp = (nIndex != 0) ? TRUE : FALSE;
	}

	if( fEnableDown )
	{
		fEnableDown = (nIndex != m_listInUse.GetCount() - 1) ? TRUE : FALSE;
	}

	m_btnUp.EnableWindow( fEnableUp );
	if( !fEnableUp )
	{
		m_btnUp.SetButtonStyle( BS_PUSHBUTTON, TRUE );
	}
	m_btnDown.EnableWindow( fEnableDown );
	if( !fEnableDown )
	{
		m_btnDown.SetButtonStyle( BS_PUSHBUTTON, TRUE );
	}
	*/
}

// Fix 46903: DMP: Order of busses not correct if users does not list them in ascending order
void CDlgAddRemoveBuses::SortUsedList( void )
{
	// Bubble sort m_listInUse

	bool fContinue = true;
	while( fContinue )
	{
		fContinue = false;

		for( int nIndex = m_listInUse.GetCount() - 1; nIndex > 0; nIndex-- )
		{
			// nIndex is at least 1
			ASSERT( nIndex > 0 );

			// If the items are out of order
			if( m_listInUse.GetItemData( nIndex ) < m_listInUse.GetItemData( nIndex - 1 ) )
			{
				// Set fContinue
				fContinue = true;

				// Reverse the items
				CString strItem1, strItem2;
				m_listInUse.GetText( nIndex, strItem1 );
				m_listInUse.GetText( nIndex - 1, strItem2 );

				DWORD dwData1, dwData2;
				dwData1 = m_listInUse.GetItemData( nIndex );
				dwData2 = m_listInUse.GetItemData( nIndex - 1 );

				int nSel = m_listInUse.GetCurSel();

				m_listInUse.DeleteString( nIndex );
				m_listInUse.DeleteString( nIndex - 1 );

				m_listInUse.InsertString( nIndex - 1, strItem1 );
				m_listInUse.SetItemData( nIndex - 1, dwData1 );

				m_listInUse.InsertString( nIndex, strItem2 );
				m_listInUse.SetItemData( nIndex, dwData2 );

				if( nSel == nIndex )
				{
					m_listInUse.SetCurSel( nIndex - 1 );
				}
				else if( nSel == nIndex - 1 )
				{
					m_listInUse.SetCurSel( nIndex );
				}
			}
		}
	}

	OnSelchangeListBusInuse();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\BufferPPGMgr.cpp ===
// BufferPPGMgr.cpp : implementation file
//

#include "stdafx.h"
#include "BufferPPGMgr.h"
#include "TabBuffer.h"
#include "ItemInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

short CBufferPPGMgr::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CBufferPPGMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBufferPPGMgr::CBufferPPGMgr( ) : CDllBasePropPageManager()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_GUIDManager	= GUID_BufferPPGMgr;

	m_pTabBuffer = NULL;
}

CBufferPPGMgr::~CBufferPPGMgr()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pTabBuffer)
	{
		delete m_pTabBuffer;
		m_pTabBuffer = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CBufferPPGMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((pbstrTitle == NULL)
	|| (pfAddPropertiesText == NULL))
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_BUFFER_TEXT );

	BufferInfoForPPG bufferInfoForPPG;

	// Nothing is constructed in the call to GetData, so we don't need to worry
	// about cleaning up any memory
	if(m_pIPropPageObject
	&& SUCCEEDED(m_pIPropPageObject->GetData((void **)&bufferInfoForPPG)) )
	{
		if( bufferInfoForPPG.m_fValid )
		{
			CString strBuffer;
			if( bufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_DEFINED )
			{
				// Initialize the bus ID text from the GUID of the standard buffer
				if( bufferInfoForPPG.m_guidBufferID == GUID_Buffer_Reverb )
				{
					strBuffer.LoadString( IDS_BUFFER_REVERB );
				}
				else if( bufferInfoForPPG.m_guidBufferID == GUID_Buffer_EnvReverb )
				{
					strBuffer.LoadString( IDS_BUFFER_ENVREVERB );
				}
				/*
				else if( bufferInfoForPPG.m_guidBufferID == GUID_Buffer_3D )
				{
					strBuffer.LoadString( IDS_BUFFER_3D );
				}
				*/
				else if( bufferInfoForPPG.m_guidBufferID == GUID_Buffer_3D_Dry )
				{
					strBuffer.LoadString( IDS_BUFFER_3D_DRY );
				}
				else if( bufferInfoForPPG.m_guidBufferID == GUID_Buffer_Mono )
				{
					strBuffer.LoadString( IDS_BUFFER_MONO );
				}
				else if( bufferInfoForPPG.m_guidBufferID == GUID_Buffer_Stereo )
				{
					strBuffer.LoadString( IDS_BUFFER_STEREO );
				}
				else
				{
					ASSERT(FALSE);
				}
			}
			else
			{
				// Try and load the text 'User Defined'
				strBuffer.LoadString(IDS_BUFFER_USER_DEFINED);
			}

			if( !strBuffer.IsEmpty() )
			{
				strTitle = strBuffer + _T(" ") + strTitle;
			}
		}
		if( !bufferInfoForPPG.m_strAudioPathName.IsEmpty() )
		{
			strTitle = bufferInfoForPPG.m_strAudioPathName + _T(" - ") + strTitle;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CBufferPPGMgr::GetPropertySheetPages(IDMUSProdPropSheet *pIPropSheet, LONG *hPropSheetPage[], short *pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((hPropSheetPage == NULL)
	|| (pnNbrPages == NULL))
	{
		return E_POINTER;
	}

	if(pIPropSheet == NULL)
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Buffer header tab
	if( m_pTabBuffer == NULL )
	{
		m_pTabBuffer = new CTabBuffer();
		m_pTabBuffer->m_pBufferPPGMgr = this;
	}
	if(m_pTabBuffer)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pTabBuffer->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *) hPage;
			nNbrPages++;
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CBufferPPGMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	if(m_pIPropSheet)
	{
		m_pIPropSheet->GetActivePage( &CBufferPPGMgr::sm_nActiveTab );
	}

	HRESULT hr = CBasePropPageManager::OnRemoveFromPropertySheet();

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	RefreshData();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr IDMUSProdPropPageManager::RefreshData

HRESULT CBufferPPGMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pTabBuffer == NULL )
	{
		return S_OK;
	}

	BufferInfoForPPG bufferInfoForPPG;
	if( (m_pIPropPageObject == NULL)
	||	FAILED(m_pIPropPageObject->GetData((void **)&bufferInfoForPPG)) )
	{
		m_pTabBuffer->SetBuffer( NULL, NULL );
		return S_OK;
	}
	
	// Make sure changes to current effect are processed in OnKillFocus
	// messages before setting the new effect
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabBuffer->GetSafeHwnd() ? m_pTabBuffer->GetParent() : NULL;

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	m_pTabBuffer->SetBuffer( &bufferInfoForPPG, m_pIPropPageObject );

	// Restore focus
	if( pWndHadFocus
	&&	pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr IDMUSProdPropPageManager::SetObject

HRESULT CBufferPPGMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr IDMUSProdPropPageManager::RemoveObject

HRESULT CBufferPPGMgr::RemoveObject( IDMUSProdPropPageObject *pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = CDllBasePropPageManager::RemoveObject(pIPropPageObject);
	if(SUCCEEDED(hr))
	{
		if( m_pTabBuffer )
		{
			m_pTabBuffer->SetBuffer( NULL, NULL );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// BufferInfoForPPG::Import

void BufferInfoForPPG::Import( const BufferOptions *pBufferOptions, bool fItemHasPChannels )
{
	ASSERT( pBufferOptions );
	if( !pBufferOptions )
	{
 		m_dwHeaderFlags = 0;
		m_dwBufferFlags = 0;
		m_dwNumChannels = 0;
		m_dwMinNumChannels = 0;
		m_dwDesignFlags = 0;
		m_lPan = 0;
		m_lVolume = 0;
		ZeroMemory( &m_guidBufferID, sizeof(GUID) );
		ZeroMemory( &m_clsid3dAlgorithm, sizeof(CLSID) );
		InitializeDS3DBUFFER( &m_ds3DBuffer );
	}
	else
	{
 		m_dwHeaderFlags = pBufferOptions->dwHeaderFlags;
		m_dwBufferFlags = pBufferOptions->dwBufferFlags;
		m_dwDesignFlags = fItemHasPChannels ? DESIGN_BUFFER_HAS_PCHANNELS : 0;
		m_dwMinNumChannels = fItemHasPChannels ? pBufferOptions->lstBusIDs.GetSize() : 1;
		if( m_dwHeaderFlags & DMUS_BUFFERF_DEFINED )
		{
			m_dwNumChannels = pBufferOptions->lstBusIDs.GetSize();
		}
		else
		{
			m_dwNumChannels = pBufferOptions->wChannels;
		}
		m_guidBufferID = pBufferOptions->guidBuffer;
		m_clsid3dAlgorithm = pBufferOptions->guid3DAlgorithm;
		m_ds3DBuffer = pBufferOptions->ds3DBuffer;
		m_lPan = pBufferOptions->lPan;
		m_lVolume = pBufferOptions->lVolume;
	}
}


/////////////////////////////////////////////////////////////////////////////
// BufferInfoForPPG::Copy

void BufferInfoForPPG::Copy( const BufferInfoForPPG &bufferInfoForPPG )
{
	PPGItemBase::Copy( bufferInfoForPPG );
 	m_dwHeaderFlags = bufferInfoForPPG.m_dwHeaderFlags;
	m_dwBufferFlags = bufferInfoForPPG.m_dwBufferFlags;
	m_dwNumChannels = bufferInfoForPPG.m_dwNumChannels;
	m_guidBufferID = bufferInfoForPPG.m_guidBufferID;
	m_clsid3dAlgorithm = bufferInfoForPPG.m_clsid3dAlgorithm;
	m_ds3DBuffer = bufferInfoForPPG.m_ds3DBuffer;
	m_dwDesignFlags = bufferInfoForPPG.m_dwDesignFlags;
	m_dwMinNumChannels = bufferInfoForPPG.m_dwMinNumChannels;
	m_lPan = bufferInfoForPPG.m_lPan;
	m_lVolume = bufferInfoForPPG.m_lVolume;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\BufferPPGMgr.h ===
#if !defined(AFX_BUFFERPPGMGR_H__F80ABA51_4947_4D98_B9AB_BA0550B4DE9D__INCLUDED_)
#define AFX_BUFFERPPGMGR_H__F80ABA51_4947_4D98_B9AB_BA0550B4DE9D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// BufferPPGMgr.h : header file
//

#include <DMUSProd.h>
#include "DllBasePropPageManager.h"
#include "PPGItemBase.h"
#include "dsound.h"

// {1EE539BC-4328-4c19-8BA0-D146404D5159}
static const GUID GUID_BufferPPGMgr = 
{ 0x1ee539bc, 0x4328, 0x4c19, { 0x8b, 0xa0, 0xd1, 0x46, 0x40, 0x4d, 0x51, 0x59 } };

struct BufferOptions;
class CTabBuffer;

#define CH_BUFFER_STANDARDGUID	0x00000001
#define CH_BUFFER_HEADERFLAGS	0x00000002
#define CH_BUFFER_BUFFERFLAGS	0x00000004
#define CH_BUFFER_BUFFER3DALG	0x00000008
#define CH_BUFFER_BUFFER3DPOS	0x00000010
#define CH_BUFFER_BUFFERCHANNELS	0x00000020
#define CH_BUFFER_USERGUID		0x00000040
#define CH_BUFFER_BUFFERPAN		0x00000080
#define CH_BUFFER_BUFFERVOLUME	0x00000100

#define DESIGN_BUFFER_HAS_PCHANNELS	0x00000001

void InitializeDS3DBUFFER( DS3DBUFFER *pDS3DBUFFER );

struct BufferInfoForPPG : public PPGItemBase
{
	BufferInfoForPPG() : PPGItemBase()
	{
 		m_ppgIndex = PPG_BUFFER;
		m_dwHeaderFlags = 0;
		m_dwBufferFlags = 0;
		m_dwNumChannels = 0;
		m_dwDesignFlags = 0;
		m_dwMinNumChannels = 0;
		InitializeDS3DBUFFER( &m_ds3DBuffer );
		ZeroMemory( &m_guidBufferID, sizeof(GUID) );
		ZeroMemory( &m_clsid3dAlgorithm, sizeof(GUID) );
	}

	void Copy( const BufferInfoForPPG &bufferInfoForPPG );
	void Import( const BufferOptions *pBufferOptions, bool fItemHasPChannels );
 	DWORD		m_dwHeaderFlags;
	DWORD		m_dwBufferFlags;
	DWORD		m_dwNumChannels;
	DWORD		m_dwMinNumChannels; // minimum number of channels
	GUID		m_guidBufferID;
	CLSID		m_clsid3dAlgorithm;
	DS3DBUFFER	m_ds3DBuffer;  // 3D settings
	DWORD		m_dwDesignFlags;
	LONG		m_lVolume;
	LONG		m_lPan;
};

/////////////////////////////////////////////////////////////////////////////
// CBufferPPGMgr

class CBufferPPGMgr : public CDllBasePropPageManager
{
friend CTabBuffer;
public:
	CBufferPPGMgr();
	virtual ~CBufferPPGMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
	HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	CTabBuffer		*m_pTabBuffer;

public:
	static short	sm_nActiveTab;
};

#endif // !defined(AFX_BUFFERPPGMGR_H__F80ABA51_4947_4D98_B9AB_BA0550B4DE9D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\AudioPathRef.h ===
#ifndef __AUDIOPATHREF_H__
#define __AUDIOPATHREF_H__

// AudioPathRef.h : header file
//

#include "AudioPathComponent.h"
#include "AudioPathDocType.h"

class CAudioPathRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CAudioPathRef();
	~CAudioPathRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CDirectMusicAudioPath*	m_pAudioPath;		// AudioPathRef refers to this AudioPath

private:
    DWORD				m_dwRef;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*		m_pIParentNode;
};

#endif // __AUDIOPATHREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgInsertEffect.cpp ===
// DlgInsertEffect.cpp : implementation file
//

#include "stdafx.h"
#include "DlgInsertEffect.h"
#include "EffectInfo.h"
#include "AudioPath.h"
#define _SYS_GUID_OPERATORS_
#include "dmoreg.h"
#include "uuids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgInsertEffect dialog


CDlgInsertEffect::CDlgInsertEffect(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgInsertEffect::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pAudioPath = NULL;
	m_fUserChangedName = false;

	//{{AFX_DATA_INIT(CDlgInsertEffect)
	//}}AFX_DATA_INIT
}


void CDlgInsertEffect::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgInsertEffect)
	DDX_Control(pDX, IDC_COMBO_EFFECT, m_comboEffect);
	DDX_Control(pDX, IDC_EDIT_INSTANCE, m_editInstance);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgInsertEffect, CDialog)
	//{{AFX_MSG_MAP(CDlgInsertEffect)
	ON_EN_KILLFOCUS(IDC_EDIT_INSTANCE, OnKillfocusEditInstance)
	ON_CBN_SELCHANGE(IDC_COMBO_EFFECT, OnSelchangeComboEffect)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgInsertEffect message handlers

BOOL CDlgInsertEffect::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	IEnumDMO *pEnumDMO;

	DMO_PARTIAL_MEDIATYPE dmoPMT;
	dmoPMT.type = MEDIATYPE_Audio;
	dmoPMT.subtype = MEDIASUBTYPE_PCM;

	if( SUCCEEDED( DMOEnum( DMOCATEGORY_AUDIO_EFFECT, 0, 1, &dmoPMT, 1, &dmoPMT, &pEnumDMO ) ) )
	{
		pEnumDMO->Reset();
		CLSID clsidItem;
		WCHAR *pwcName;
		DWORD dwItemsFetched;
		while( S_OK == pEnumDMO->Next( 1, &clsidItem, &pwcName, &dwItemsFetched ) )
		{
			CString strName = pwcName;
			EffectInfo *pEffectInfo = new EffectInfo( strName, strName, clsidItem, GUID_NULL );

			m_lstEffects.AddHead( pEffectInfo );

			// Create the name to display
			AfxFormatString2( strName, IDS_INSERT_EFFECT_LIST, pEffectInfo->m_strName, pEffectInfo->m_strInstanceName );

			// Add the string to the combobox and point it's item at the associated EffectInfo
			int nIndex = m_comboEffect.AddString( strName );
			m_comboEffect.SetItemDataPtr( nIndex, pEffectInfo );

			::CoTaskMemFree( pwcName );
		}
		pEnumDMO->Release();
	}

	// Select the first item
	m_comboEffect.SetCurSel( 0 );

	// Set the instance name, based on the first item
	SetInstanceName();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgInsertEffect::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the index of the current combobox item
	int nIndex = m_comboEffect.GetCurSel();
	if( nIndex != CB_ERR )
	{
		// Get an EffectInfo pointer from the selected item
		m_EffectInfoToCopy.Copy( *static_cast<EffectInfo *>( m_comboEffect.GetItemDataPtr( nIndex ) ) );
	}

	// Get the instance name to use
	m_editInstance.GetWindowText( m_strInstanceName );

	CDialog::OnOK();
}

void CDlgInsertEffect::SetInstanceName( void )
{
	// Check that we have an AudioPath pointer
	if( m_pAudioPath )
	{
		// Get the currently selected index
		int nIndex = m_comboEffect.GetCurSel();
		if( nIndex != CB_ERR )
		{
			// Get a pointer to the effect
			EffectInfo *pEffectInfo = static_cast<EffectInfo *>( m_comboEffect.GetItemDataPtr( nIndex ) );

			// Copy the effect
			EffectInfo newEffectInfo;
			newEffectInfo.Copy( *pEffectInfo );

			// Now, get a unique name for this effect
			m_pAudioPath->GetUniqueEffectInstanceName( &newEffectInfo );

			// Update the display with the effect's instance name
			m_editInstance.SetWindowText( newEffectInfo.m_strInstanceName );

			// Save the instance name for use in OnKillfocusEditInstance
			m_strOldInstanceName = newEffectInfo.m_strInstanceName;
		}
	}
}

void CDlgInsertEffect::OnKillfocusEditInstance() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the new text for the instance name
	CString strNewInstanceText;
	m_editInstance.GetWindowText( strNewInstanceText );
	strNewInstanceText.TrimLeft();
	strNewInstanceText.TrimRight();

	// Check if the string is empty
	if( strNewInstanceText.IsEmpty() )
	{
		// Reset it to the last instance name used
		m_editInstance.SetWindowText( m_strOldInstanceName );
	}
	else
	{
		// Get the index of the current combobox item
		int nIndex = m_comboEffect.GetCurSel();
		if( nIndex != CB_ERR )
		{
			// Get an EffectInfo pointer from the selected item
			EffectInfo *pEffectInfo = static_cast<EffectInfo *>( m_comboEffect.GetItemDataPtr( nIndex ) );

			// Copy the effect
			EffectInfo newEffectInfo;
			newEffectInfo.Copy( *pEffectInfo );

			// Change the effect's instance name to the one entered by the user
			newEffectInfo.m_strInstanceName = strNewInstanceText;

			// Check if the name is unique
			m_pAudioPath->GetUniqueEffectInstanceName( &newEffectInfo );

			// If name wasn't unique, it was changed
			if( newEffectInfo.m_strInstanceName != strNewInstanceText )
			{
				// Set the display with the new name
				m_editInstance.SetWindowText( newEffectInfo.m_strInstanceName );
			}

			// Check if the name changed
			if( m_strOldInstanceName != newEffectInfo.m_strInstanceName )
			{
				// Save the instance name
				m_strOldInstanceName = newEffectInfo.m_strInstanceName;

				// Flag that the user changed the instance name
				m_fUserChangedName = true;
			}
		}
	}
}

void CDlgInsertEffect::OnSelchangeComboEffect() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// If the user hasn't modified the instance name
	if( !m_fUserChangedName )
	{
		// Set the instance name, based on the chosen effect
		SetInstanceName();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgEditSynth.h ===
#if !defined(AFX_DLGEDITSYNTH_H__51ACE707_7179_4F5C_AB26_67BB6DFB6037__INCLUDED_)
#define AFX_DLGEDITSYNTH_H__51ACE707_7179_4F5C_AB26_67BB6DFB6037__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgEditSynth.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgEditSynth dialog

class CDlgEditSynth : public CDialog
{
// Construction
public:
	CDlgEditSynth(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgEditSynth)
	enum { IDD = IDD_DLG_SYNTH };
	CSpinButtonCtrl	m_spinVoices;
	CEdit	m_editVoices;
	CEdit	m_editSynthName;
	CButton	m_checkReverb;
	CButton	m_checkChorus;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgEditSynth)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	DWORD	m_dwEffects;
	DWORD	m_dwSupportedEffects;
	DWORD	m_dwSampleRate;
	DWORD	m_dwVoices;
	DWORD	m_dwMaxVoices;
	CString	m_strName;

protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgEditSynth)
	afx_msg void OnKillfocusEditVoices();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGEDITSYNTH_H__51ACE707_7179_4F5C_AB26_67BB6DFB6037__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgSendProperties.h ===
#if !defined(AFX_DLGSENDPROPERTIES_H__6754EBBC_BC07_4879_BCBF_E9998362F885__INCLUDED_)
#define AFX_DLGSENDPROPERTIES_H__6754EBBC_BC07_4879_BCBF_E9998362F885__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgSendProperties.h : header file
//

#include "resource.h"
#include "Dlg3DParam.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgSendProperties dialog

class CDlgSendProperties : public CDialog
{
// Construction
public:
	CDlgSendProperties(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgSendProperties)
	enum { IDD = IDD_DLG_SEND_PROPERTIES };
	C3DEdit	m_editVolume;
	CTabCtrl	m_tab;
	//}}AFX_DATA

	long	m_lVolume;
	CString m_strTitle;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgSendProperties)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgSendProperties)
	afx_msg void OnKillfocusEditVolume();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGSENDPROPERTIES_H__6754EBBC_BC07_4879_BCBF_E9998362F885__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgNewAudiopath.cpp ===
// DlgNewAudiopath.cpp : implementation file
//

#include "stdafx.h"
#include "DlgNewAudiopath.h"
#include "AudioPathComponent.h"
#include "AudioPath.h"
#include "dmusici.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgNewAudiopath dialog


CDlgNewAudiopath::CDlgNewAudiopath(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgNewAudiopath::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgNewAudiopath)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pAudioPathComponent = NULL;
	m_fBaseOnExistingAudiopath = false;
	m_pExistingAudiopath = NULL;
	m_dwDefaultAudiopathID = 0;
}


void CDlgNewAudiopath::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgNewAudiopath)
	DDX_Control(pDX, IDC_AUDIOPATH_LIST, m_listAudiopath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgNewAudiopath, CDialog)
	//{{AFX_MSG_MAP(CDlgNewAudiopath)
	ON_BN_CLICKED(IDC_NEW_AUDIOPATH, OnNewAudiopath)
	ON_BN_CLICKED(IDC_EXISTING_AUDIOPATH, OnExistingAudiopath)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgNewAudiopath message handlers

void CDlgNewAudiopath::OnOK() 
{
	if( GetCheckedRadioButton( IDC_NEW_AUDIOPATH, IDC_EXISTING_AUDIOPATH ) == IDC_EXISTING_AUDIOPATH )
	{
		int nSel = m_listAudiopath.GetCurSel();
		if( nSel != LB_ERR )
		{
			DWORD dwData = m_listAudiopath.GetItemData( nSel );
			if( (dwData >= DMUS_APATH_SHARED_STEREOPLUSREVERB)
			&&	(dwData <= DMUS_APATH_DYNAMIC_STEREO) )
			{
				m_fBaseOnExistingAudiopath = true;
				m_dwDefaultAudiopathID = dwData;
			}
			else
			{
				m_pExistingAudiopath = (CDirectMusicAudioPath *)m_listAudiopath.GetItemDataPtr( nSel );
				if( m_pExistingAudiopath )
				{
					m_fBaseOnExistingAudiopath = true;
				}
			}
		}
	}

	CDialog::OnOK();
}

void AddStandardStringToList( int nStringID, DWORD dwStandardID, CListBox &listBox )
{
	CString strName;
	if( strName.LoadString( nStringID ) )
	{
		int nPos = listBox.InsertString( 0, strName );
		listBox.SetItemData( nPos, dwStandardID );
	}
}

BOOL CDlgNewAudiopath::OnInitDialog() 
{
	CDialog::OnInitDialog();

	if( m_pAudioPathComponent )
	{
		POSITION pos = m_pAudioPathComponent->m_lstAudioPaths.GetHeadPosition();
		while( pos )
		{
			CDirectMusicAudioPath *pAudioPath = m_pAudioPathComponent->m_lstAudioPaths.GetNext( pos );

			BSTR bstrName = pAudioPath->GetNameForConductor();
			if( bstrName )
			{
				CString strName = bstrName;
				::SysFreeString( bstrName );
				int nPos = m_listAudiopath.AddString( strName );
				m_listAudiopath.SetItemDataPtr( nPos, pAudioPath );
			}
		}
	}

	AddStandardStringToList( IDS_APATH_STEREO, DMUS_APATH_DYNAMIC_STEREO, m_listAudiopath );
	AddStandardStringToList( IDS_APATH_MONO, DMUS_APATH_DYNAMIC_MONO, m_listAudiopath );
	AddStandardStringToList( IDS_APATH_3D_DRY, DMUS_APATH_DYNAMIC_3D, m_listAudiopath );
	//AddStandardStringToList( IDS_APATH_3D, DMUS_APATH_DYNAMIC_ENV3D, m_listAudiopath );
	AddStandardStringToList( IDS_APATH_MUSIC, DMUS_APATH_SHARED_STEREOPLUSREVERB, m_listAudiopath );

	CheckRadioButton( IDC_NEW_AUDIOPATH, IDC_EXISTING_AUDIOPATH, IDC_NEW_AUDIOPATH );

	CWnd *pWnd = GetDlgItem( IDC_EXISTING_AUDIOPATH );
	if( pWnd )
	{
		pWnd->EnableWindow( (m_listAudiopath.GetCount() > 0) ? TRUE : FALSE );
	}

	// Disable the list until the 'use existing' button is checked
	m_listAudiopath.EnableWindow( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgNewAudiopath::OnNewAudiopath() 
{
	// Disable the list since the 'use existing' button is unchecked
	m_listAudiopath.EnableWindow( FALSE );
}

void CDlgNewAudiopath::OnExistingAudiopath() 
{
	// Enable the list since the 'use existing' button is checked
	m_listAudiopath.EnableWindow( TRUE );

	if( m_listAudiopath.GetCurSel() == LB_ERR )
	{
		m_listAudiopath.SetCurSel( 0 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectInfo.cpp ===
// EffectInfo.cpp : implementation file
//

#include "stdafx.h"
#include "EffectInfo.h"
#include "RiffStrm.h"
#include "ItemInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define BUFFER_SIZE 256

bool StreamsAreEqual( IStream *pIStream1, IStream *pIStream2 )
{
	// Check if stream pointers are equal (including both NULL)
	if( pIStream1 == pIStream2 )
	{
		return true;
	}

	// Check if either stream pointer is NULL
	if( (pIStream1 == NULL)
	||	(pIStream2 == NULL) )
	{
		return false;
	}

	// Get the length of each stream
	STATSTG statStg1, statStg2;
	if( FAILED( pIStream1->Stat( &statStg1, STATFLAG_NONAME ) )
	||	FAILED( pIStream2->Stat( &statStg2, STATFLAG_NONAME ) )
	||	(statStg1.cbSize.QuadPart != statStg2.cbSize.QuadPart) )
	{
		// If either call to Stat failed, or the length are different, return false
		return false;
	}

	// Seek back to the start of each stream
	if( FAILED( StreamSeek( pIStream1, 0, STREAM_SEEK_SET ) )
	||	FAILED( StreamSeek( pIStream2, 0, STREAM_SEEK_SET ) ) )
	{
		// If either seek failed, return false
		return false;
	}

	// Try and allocate buffers to read data into
	BYTE *pbData1 = new BYTE[BUFFER_SIZE];
	if( pbData1 == NULL )
	{
		return false;
	}
	BYTE *pbData2 = new BYTE[BUFFER_SIZE];
	if( pbData2 == NULL )
	{
		delete []pbData1;
		return false;
	}

	// Initialize the amount of data to compare
	long lStreamSize = min( statStg1.cbSize.LowPart, LONG_MAX );

	while( lStreamSize > 0 )
	{
		// Try and read in a chunk of data
		ULONG cbRead1, cbRead2;
		const ULONG lReadSize = min( lStreamSize, BUFFER_SIZE );
		if( FAILED( pIStream1->Read( pbData1, lReadSize, &cbRead1 ) )
		||	FAILED( pIStream2->Read( pbData2, lReadSize, &cbRead2 ) )
		||	(lReadSize != cbRead1)
		||	(lReadSize != cbRead2) )
		{
			// If either read failed, or we didn't read in
			// the correct amount of data, return false
			break;
		}

		// Check if the data we read is identical
		if( memcmp( pbData1, pbData2, lReadSize ) != 0 )
		{
			// Nope
			break;
		}

		lStreamSize -= lReadSize;
	}

	delete []pbData1;
	delete []pbData2;

	// If we read all the data, return true.  Otherwise, return false
	return lStreamSize <= 0;
}

/////////////////////////////////////////////////////////////////////////////
// EffectInfo

EffectInfo::EffectInfo()
{
	m_pIStream = NULL;
	Empty();
}

EffectInfo::EffectInfo( CString strNewName, CString strNewInstanceName, REFCLSID rclsidNewObject, REFCLSID rclsidSendBuffer )
{
	m_pIStream = NULL;
	Empty();
	m_strName = strNewName;
	m_strInstanceName = strNewInstanceName;
	m_clsidObject = rclsidNewObject;
	m_clsidSendBuffer = rclsidSendBuffer;
}

void EffectInfo::Empty( void )
{
	ZeroMemory( &m_clsidObject, sizeof(CLSID) );
	ZeroMemory( &m_clsidSendBuffer, sizeof(CLSID) );

	if( m_pIStream )
	{
		m_pIStream->Release();
		m_pIStream= NULL;
	}
	m_dwFlags = 0;
	m_strInstanceName.Empty();
	m_strName.Empty();
	m_pSendDestinationMixGroup = NULL;
}

EffectInfo::~EffectInfo()
{
	if( m_pIStream )
	{
		m_pIStream->Release();
		m_pIStream = NULL;
	}
}

void EffectInfo::Copy( const EffectInfo &effectInfo )
{
	if( m_pIStream )
	{
		m_pIStream->Release();
		m_pIStream = NULL;
	}

	m_strInstanceName = effectInfo.m_strInstanceName;
	m_strName = effectInfo.m_strName;
	m_clsidObject = effectInfo.m_clsidObject;
	m_clsidSendBuffer = effectInfo.m_clsidSendBuffer;
	m_dwFlags = effectInfo.m_dwFlags;
	m_pSendDestinationMixGroup = effectInfo.m_pSendDestinationMixGroup;

	if( effectInfo.m_pIStream )
	{
		effectInfo.m_pIStream->Clone( &m_pIStream );
	}
}

void EffectInfo::Copy( const ioDSoundEffect *pioDSoundEffect )
{
	// Validate pioDSoundEffect
	ASSERT( pioDSoundEffect );
	if( NULL == pioDSoundEffect )
	{
		return;
	}

	// Remove our existing stream pointer
	if( m_pIStream )
	{
		m_pIStream->Release();
		m_pIStream = NULL;
	}

	// Copy the effect's data stream, if available
	if( pioDSoundEffect->pStreamData )
	{
		pioDSoundEffect->pStreamData->Clone( &m_pIStream );
	}

	// Set the effect's flags
	m_dwFlags = pioDSoundEffect->ioFXHeader.dwEffectFlags;

	// Clear our pointer to the dest. mix group
	m_pSendDestinationMixGroup = NULL;

	// Copy the rest of the effect's information
	m_strName = pioDSoundEffect->strEffectName;
	m_strInstanceName = pioDSoundEffect->strInstanceName;
	m_clsidObject = pioDSoundEffect->ioFXHeader.guidDSFXClass;
	m_clsidSendBuffer = pioDSoundEffect->ioFXHeader.guidSendBuffer;
}

bool EffectInfo::IsEqualExceptName( const EffectInfo *pEffectInfo ) const
{
	if( (m_dwFlags != pEffectInfo->m_dwFlags)
	||	(m_clsidObject != pEffectInfo->m_clsidObject)
	||	(m_clsidSendBuffer != pEffectInfo->m_clsidSendBuffer)
	||	!StreamsAreEqual( m_pIStream, pEffectInfo->m_pIStream ) )
	{
		return false;
	}
	return true;
}

HRESULT EffectInfo::Write( IDMUSProdRIFFStream *pIRiffStream ) const
{
	if( !pIRiffStream )
	{
		return E_POINTER;
	}

	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Save the effect in a LIST chunk
	MMCKINFO ckEffect;
	ckEffect.fccType = DMUSPROD_FOURCC_EFFECTINFO_LIST;
	if( 0 == pIRiffStream->CreateChunk( &ckEffect, MMIO_CREATELIST ) )
	{
		// Save the instance name in a UNAM chunk
		MMCKINFO ckSubChunk;
		ckSubChunk.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
		{
			SaveMBStoWCS( pStream, &m_strInstanceName );
			pIRiffStream->Ascend( &ckSubChunk, 0 );
		}

		// Save the normal name in a EFFECTINFO_NAME chunk
		ckSubChunk.ckid = DMUSPROD_FOURCC_EFFECTINFO_NAME;
		if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
		{
			SaveMBStoWCS( pStream, &m_strName );
			pIRiffStream->Ascend( &ckSubChunk, 0 );
		}

		// Save the CLSID in an EFFECTINFO_HEADER chunk
		ckSubChunk.ckid = DMUSPROD_FOURCC_EFFECTINFO_HEADER;
		if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
		{
			pStream->Write( &m_clsidObject, sizeof(CLSID), NULL );
			pStream->Write( &m_clsidSendBuffer, sizeof(CLSID), NULL );
			pStream->Write( &m_dwFlags, sizeof(DWORD), NULL );
			pIRiffStream->Ascend( &ckSubChunk, 0 );
		}

		// If there is any custom data, save it in an EFFECTINFO_DATA chunk
		if( m_pIStream )
		{
			STATSTG statStg;
			if( SUCCEEDED( m_pIStream->Stat( &statStg, STATFLAG_NONAME ) )
			&&	(statStg.cbSize.QuadPart > 0)  )
			{
				// Seek back to the start of the stream
				if( SUCCEEDED( StreamSeek( m_pIStream, 0 , STREAM_SEEK_SET ) ) )
				{
					ckSubChunk.ckid = DMUSPROD_FOURCC_EFFECTINFO_DATA;
					if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
					{
						ULARGE_INTEGER cbRead, cbWritten;
						m_pIStream->CopyTo( pStream, statStg.cbSize, &cbRead, &cbWritten );
						if( (statStg.cbSize.QuadPart != cbRead.QuadPart)
						||	(statStg.cbSize.QuadPart != cbWritten.QuadPart) )
						{
							ASSERT(FALSE);
						}

						pIRiffStream->Ascend( &ckSubChunk, 0 );
					}
				}
			}
		}

		pIRiffStream->Ascend( &ckEffect, 0 );
	}

	pStream->Release();

	return S_OK;
}

HRESULT EffectInfo::Read( IStream *pIStream )
{
	if( !pIStream )
	{
		return E_POINTER;
	}

	// Allocate a RIFF stream to use to parse this stream
	IDMUSProdRIFFStream *pRiffStream = NULL;
	AllocRIFFStream( pIStream, &pRiffStream );
	if( !pRiffStream )
	{
		return E_POINTER;
	}

	// Initialize ourself to a clean state
	Empty();

	// Initialize our result code
	HRESULT hr = E_FAIL;

	// Descend into the main EffectInfo LIST chunk
	MMCKINFO ckMain;
	ckMain.fccType = DMUSPROD_FOURCC_EFFECTINFO_LIST;
    if( pRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
	{
		// Now, descend into each of the subchunks
		MMCKINFO ck;
		while( pRiffStream->Descend( &ck, &ckMain, 0 ) == 0 )
		{
			switch( ck.ckid )
			{
			case DMUS_FOURCC_UNAM_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &m_strInstanceName );
				break;
			case DMUSPROD_FOURCC_EFFECTINFO_NAME:
				ReadMBSfromWCS( pIStream, ck.cksize, &m_strName );
				break;
			case DMUSPROD_FOURCC_EFFECTINFO_HEADER:
				if( ck.cksize >= sizeof(CLSID) )
				{
					pIStream->Read( &m_clsidObject, sizeof(CLSID), NULL );
					if( ck.cksize >= sizeof(CLSID) * 2 )
					{
						pIStream->Read( &m_clsidSendBuffer, sizeof(CLSID), NULL );
						if( ck.cksize >= sizeof(CLSID) * 2 + sizeof(DWORD) )
						{
							pIStream->Read( &m_dwFlags, sizeof(DWORD), NULL );
						}
					}
					hr = S_OK;
				}
				break;
			case DMUSPROD_FOURCC_EFFECTINFO_DATA:
				// Read in the effect's data

				// Delete any existing data
				if( m_pIStream )
				{
					m_pIStream->Release();
					m_pIStream = NULL;
				}

				// Allocate a stream for the new data
				if( SUCCEEDED( ::CreateStreamOnHGlobal( NULL, TRUE, &m_pIStream ) ) )
				{
					// Read in the new data
					ULARGE_INTEGER cbWrite, cbRead, cbWritten;
					cbWrite.QuadPart = ck.cksize;
					pIStream->CopyTo( m_pIStream, cbWrite, &cbRead, &cbWritten );
					ASSERT( cbWrite.QuadPart == cbRead.QuadPart );
					ASSERT( cbWrite.QuadPart == cbWritten.QuadPart );
				}
				break;
			}
			pRiffStream->Ascend( &ck, 0 );
		}
		pRiffStream->Ascend( &ckMain, 0 );
	}

	// Release the RIFF stream
	pRiffStream->Release();

	return hr;
}

HRESULT EffectInfo::Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent )
{
	if( !pIRiffStream || !pckParent )
	{
		return E_POINTER;
	}

	// Get a pointer to the IStream
	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Initialize ourself to a clean state
	Empty();

	// Initialize the result to S_OK
	HRESULT hr = S_OK;

	// Descend into all chunks within pckParent
	MMCKINFO ckChunk;
	DWORD cbRead;
	while( SUCCEEDED(hr)
		&& (0 == pIRiffStream->Descend( &ckChunk, pckParent, 0 )) )
	{
		switch( ckChunk.ckid )
		{
		case DMUS_FOURCC_UNAM_CHUNK:
			// Read in the effect's instance name
			ReadMBSfromWCS( pStream, ckChunk.cksize, &m_strInstanceName );
			break;

		case DMUSPROD_FOURCC_EFFECTINFO_NAME:
			// Read in the effect's standard name
			ReadMBSfromWCS( pStream, ckChunk.cksize, &m_strName );
			break;

		case DMUSPROD_FOURCC_EFFECTINFO_HEADER:
			// Read in the effect's CLSID
			if( ckChunk.cksize >= sizeof(CLSID) )
			{
				hr = pStream->Read( &m_clsidObject, sizeof(CLSID), &cbRead );

				// If we didn't read in the correct amount, set hr to a failure code
				if( SUCCEEDED(hr)
				&&	(cbRead != sizeof(CLSID)) )
				{
					hr = E_FAIL;
				}

				// Read in the effect's send CLSID
				if( ckChunk.cksize >= sizeof(CLSID) * 2 )
				{
					hr = pStream->Read( &m_clsidSendBuffer, sizeof(CLSID), &cbRead );

					// If we didn't read in the correct amount, set hr to a failure code
					if( SUCCEEDED(hr)
					&&	(cbRead != sizeof(CLSID)) )
					{
						hr = E_FAIL;
					}

					// Read in the effect's flags
					if( ckChunk.cksize >= sizeof(CLSID) * 2 + sizeof(DWORD) )
					{
						hr = pStream->Read( &m_dwFlags, sizeof(DWORD), &cbRead );

						// If we didn't read in the correct amount, set hr to a failure code
						if( SUCCEEDED(hr)
						&&	(cbRead != sizeof(DWORD)) )
						{
							hr = E_FAIL;
						}
					}
				}
			}
			else
			{
				hr = E_FAIL;
			}
			break;

		case DMUSPROD_FOURCC_EFFECTINFO_DATA:
			// Read in the effect's data

			// Delete any existing data
			if( m_pIStream )
			{
				m_pIStream->Release();
				m_pIStream = NULL;
			}

			// Allocate a stream for the new data
			if( SUCCEEDED( ::CreateStreamOnHGlobal( NULL, TRUE, &m_pIStream ) ) )
			{
				// Read in the new data
				ULARGE_INTEGER cbWrite, cbRead, cbWritten;
				cbWrite.QuadPart = ckChunk.cksize;
				hr = pStream->CopyTo( m_pIStream, cbWrite, &cbRead, &cbWritten );

				// If we didn't read in the correct amount, set hr to a failure code
				if( SUCCEEDED(hr)
				&&	((cbWrite.QuadPart != cbRead.QuadPart) ||
					 (cbWrite.QuadPart != cbWritten.QuadPart)) )
				{
					hr = E_FAIL;
				}

				// If the read failed
				if( FAILED(hr) )
				{
					// Delete the new data
					m_pIStream->Release();
					m_pIStream = NULL;
				}
			}
			break;
		}

		// Ascend out of the child chunks
		pIRiffStream->Ascend( &ckChunk, 0 );
	}

	// Release the IStream
	pStream->Release();

	// Return the result
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgInsertEffect.h ===
#if !defined(AFX_DLGINSERTEFFECT_H__2D6F83EC_6726_4D73_B54E_06172EAA5BC2__INCLUDED_)
#define AFX_DLGINSERTEFFECT_H__2D6F83EC_6726_4D73_B54E_06172EAA5BC2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"
#include "EffectInfo.h"

// DlgInsertEffect.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgInsertEffect dialog

class CDirectMusicAudioPath;

class CDlgInsertEffect : public CDialog
{
// Construction
public:
	CDlgInsertEffect(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgInsertEffect)
	enum { IDD = IDD_DLG_INSERT_EFFECT };
	CComboBox	m_comboEffect;
	CEdit	m_editInstance;
	//}}AFX_DATA

	EffectInfo m_EffectInfoToCopy;
	CDirectMusicAudioPath *m_pAudioPath;
	CString m_strInstanceName;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgInsertEffect)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetInstanceName( void );
	bool m_fUserChangedName;
	CString m_strOldInstanceName;
	CTypedPtrList< CPtrList, EffectInfo *> m_lstEffects;

	// Generated message map functions
	//{{AFX_MSG(CDlgInsertEffect)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnKillfocusEditInstance();
	afx_msg void OnSelchangeComboEffect();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGINSERTEFFECT_H__2D6F83EC_6726_4D73_B54E_06172EAA5BC2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgNewAudiopath.h ===
#if !defined(AFX_DLGNEWAUDIOPATH_H__7775BF7C_BE75_4F4F_8F75_9634EB1BA20D__INCLUDED_)
#define AFX_DLGNEWAUDIOPATH_H__7775BF7C_BE75_4F4F_8F75_9634EB1BA20D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgNewAudiopath.h : header file
//

#include "resource.h"

class CAudioPathComponent;
class CDirectMusicAudioPath;

/////////////////////////////////////////////////////////////////////////////
// CDlgNewAudiopath dialog

class CDlgNewAudiopath : public CDialog
{
// Construction
public:
	CDlgNewAudiopath(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgNewAudiopath)
	enum { IDD = IDD_NEW_AUDIOPATH };
	CListBox	m_listAudiopath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgNewAudiopath)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	CAudioPathComponent		*m_pAudioPathComponent;
	bool					m_fBaseOnExistingAudiopath;
	CDirectMusicAudioPath	*m_pExistingAudiopath;
	DWORD					m_dwDefaultAudiopathID;

protected:
	// Generated message map functions
	//{{AFX_MSG(CDlgNewAudiopath)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnNewAudiopath();
	afx_msg void OnExistingAudiopath();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGNEWAUDIOPATH_H__7775BF7C_BE75_4F4F_8F75_9634EB1BA20D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\DlgSendProperties.cpp ===
// DlgSendProperties.cpp : implementation file
//

#include "stdafx.h"
#include "DlgSendProperties.h"
#include "DSound.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgSendProperties dialog


CDlgSendProperties::CDlgSendProperties(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgSendProperties::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgSendProperties)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_lVolume = 0;
}


void CDlgSendProperties::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgSendProperties)
	DDX_Control(pDX, IDC_EDIT_VOLUME, m_editVolume);
	DDX_Control(pDX, IDC_TAB1, m_tab);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgSendProperties, CDialog)
	//{{AFX_MSG_MAP(CDlgSendProperties)
	ON_EN_KILLFOCUS(IDC_EDIT_VOLUME, OnKillfocusEditVolume)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgSendProperties message handlers

void CDlgSendProperties::OnKillfocusEditVolume() 
{
	BOOL bTransSuccessful = FALSE;
	long lNewValue = GetDlgItemInt( IDC_EDIT_VOLUME, &bTransSuccessful, TRUE );
	if( !bTransSuccessful )
	{
		SetDlgItemInt( IDC_EDIT_VOLUME, m_lVolume, TRUE );
		return;
	}
	else
	{
		if( lNewValue < DSBVOLUME_MIN )
		{
			lNewValue = DSBVOLUME_MIN;
		}
		else if( lNewValue > DSBVOLUME_MAX )
		{
			lNewValue = DSBVOLUME_MAX;
		}
		m_lVolume = lNewValue;
		SetDlgItemInt( IDC_EDIT_VOLUME, lNewValue, TRUE );
	}
}

void CDlgSendProperties::OnOK() 
{
	OnKillfocusEditVolume();

	CDialog::OnOK();
}

BOOL CDlgSendProperties::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Initialize the title
	SetWindowText( m_strTitle );

	// Initialize tab control
	CString strText;
	strText.LoadString( IDS_SEND_TEXT );
	m_tab.InsertItem( 0, strText );

	// Set volume
	m_editVolume.m_fDotValid = false;
	SetDlgItemInt( IDC_EDIT_VOLUME, m_lVolume, TRUE );
	strText.Format( _T("%d"), DSBVOLUME_MIN );
	m_editVolume.SetLimitText( strText.GetLength() );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectListCtl.h ===
#if !defined(AFX_EFFECTLISTCTL_H__0EEF952B_9F3E_490C_AEA4_3B719B1104C5__INCLUDED_)
#define AFX_EFFECTLISTCTL_H__0EEF952B_9F3E_490C_AEA4_3B719B1104C5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EffectListCtl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEffectListCtl window

class CEffectListCtl : public CListCtrl
{
// Construction
public:
	CEffectListCtl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEffectListCtl)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEffectListCtl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEffectListCtl)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EFFECTLISTCTL_H__0EEF952B_9F3E_490C_AEA4_3B719B1104C5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectPPGMgr.h ===
// EffectPPGMgr.h: interface for the CEffectPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __EFFECTPPGMGR_H__
#define __EFFECTPPGMGR_H__

#include <DMUSProd.h>
#include "DllBasePropPageManager.h"

// {665D665F-5959-4c7f-9D65-5D6732CC0EED}
static const GUID GUID_EffectPPGMgr = 
{ 0x665d665f, 0x5959, 0x4c7f, { 0x9d, 0x65, 0x5d, 0x67, 0x32, 0xcc, 0xe, 0xed } };


class CTabEffectInfo;

//////////////////////////////////////////////////////////////////////
//  CEffectPPGMgr

class CEffectPPGMgr : public CDllBasePropPageManager 
{
public:
	CEffectPPGMgr();
	virtual ~CEffectPPGMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
	HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	CTabEffectInfo	*m_pTabEffectInfo;

public:
	static short	sm_nActiveTab;
};

#endif //__EFFECTPPGMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\ItemInfo.cpp ===
// ItemInfo.cpp : implementation file
//

#include "stdafx.h"
#include "dsoundp.h"
#include "ItemInfo.h"
#include "EffectInfo.h"
#include "RiffStrm.h"
#include "AudioPath.h"
#include "AudioPathDesignerDLL.h"
#include "MultiTree.h"
#include "AudioPathDlg.h"
#include "MixGroupPPGMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif //_DEBUG


static CString PortNameFromGUID( const GUID &rguidPort )
{
	// Ensure we have a pointer to DirectMusic
	ASSERT( theApp.m_pAudioPathComponent->m_pIDMusic );

	// Check if asking for the default port
	if( rguidPort == GUID_Synth_Default )
	{
		// Yes - return 'Default Synth'
		CString strDefault;
		strDefault.LoadString( IDS_DEFAULT_PORT );
		return strDefault;
	}

	// Iterate through all ports
	for(DWORD dwIndex = 0; ; dwIndex++)
	{
		// Initialize dmpc
		DMUS_PORTCAPS dmpc;
		ZeroMemory(&dmpc, sizeof(dmpc));
		dmpc.dwSize = sizeof(DMUS_PORTCAPS);

		// Get the port's capabilities
		HRESULT hr = theApp.m_pAudioPathComponent->m_pIDMusic->EnumPort(dwIndex, &dmpc);

		// If we succeeded and didn't hit the end of the list
		if(SUCCEEDED(hr) && (hr != S_FALSE) )
		{
			if( rguidPort == dmpc.guidPort )
			{
				return CString(dmpc.wszDescription);
			}
		}
		else
		{
			break;
		}
	}

	CString strUnknown;
	strUnknown.LoadString( IDS_UNKNOWN_SYNTH_NAME );
	return strUnknown;
}

/////////////////////////////////////////////////////////////////////////////
// BufferOptions

BufferOptions::BufferOptions()
{
	Empty();
}

BufferOptions::~BufferOptions()
{
	// Delete just the effect wrappers
	while( !lstEffects.IsEmpty() )
	{
		delete lstEffects.RemoveHead();
	}
}

void BufferOptions::Empty( void )
{
	// Delete just the effect wrappers
	while( !lstEffects.IsEmpty() )
	{
		delete lstEffects.RemoveHead();
	}

	lstBusIDs.RemoveAll();
#ifndef DMP_XBOX
	lstBusIDs.Add( DSBUSID_LEFT );
	lstBusIDs.Add( DSBUSID_RIGHT );
	wChannels = 2;
	CoCreateGuid( &guidBuffer );
	dwBufferFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
	dwHeaderFlags = 0;
#else
	wChannels = 1;
	guidBuffer = GUID_Buffer_3D_Dry;
	dwBufferFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
	dwHeaderFlags = DMUS_BUFFERF_DEFINED;
#endif
	guid3DAlgorithm = DS3DALG_DEFAULT;
	InitializeDS3DBUFFER( &ds3DBuffer );
	lVolume = 0;
	lPan = 0;
	fSelected = false;
	CoCreateGuid( &guidDesignEffectGUID );
}

HRESULT BufferOptions::Write( IDMUSProdRIFFStream *pIRiffStream ) const
{
	if( !pIRiffStream )
	{
		return E_POINTER;
	}

	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Save the buffer in a LIST chunk
	MMCKINFO ckBuffer;
	ckBuffer.fccType = DMUSPROD_FOURCC_ITEM_BUFFER_LIST;
	if( 0 == pIRiffStream->CreateChunk( &ckBuffer, MMIO_CREATELIST ) )
	{
		MMCKINFO ckSubChunk;
		// If there are any bus IDs
		if( lstBusIDs.GetSize() > 0 )
		{
			// Save the bus IDs in a BUS_ID chunk
			ckSubChunk.ckid = DMUSPROD_FOURCC_BUS_ID;
			if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
			{
				pStream->Write( lstBusIDs.GetData(), sizeof(DWORD) * lstBusIDs.GetSize(), NULL );
				pIRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		// Save the buffer settings in a BUFFER_CHUNK chunk
		ckSubChunk.ckid = DMUSPROD_FOURCC_BUFFER_CHUNK;
		if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
		{
			ioBufferOptions oBufferOptions;
			memcpy( &oBufferOptions.ds3DBuffer, &ds3DBuffer, sizeof( DS3DBUFFER ) );
			oBufferOptions.dwBufferFlags = dwBufferFlags;
			oBufferOptions.dwHeaderFlags = dwHeaderFlags;
			oBufferOptions.guid3DAlgorithm = guid3DAlgorithm;
			oBufferOptions.guidBuffer = guidBuffer;
			oBufferOptions.wChannels = wChannels;
			oBufferOptions.lPan = lPan;
			oBufferOptions.lVolume = lVolume;

			pStream->Write( &oBufferOptions, sizeof( ioBufferOptions ), NULL );
			pIRiffStream->Ascend( &ckSubChunk, 0 );
		}

		// Only save the effect list when using a non-defined buffer
		if( !(dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
		{
			// If there are any effects, save them
			POSITION pos = lstEffects.GetHeadPosition();
			while( pos )
			{
				lstEffects.GetNext( pos )->m_EffectInfo.Write( pIRiffStream );
			}
		}

		pIRiffStream->Ascend( &ckBuffer, 0 );
	}

	pStream->Release();

	return S_OK;
}

HRESULT BufferOptions::Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent, CDirectMusicAudioPath *pAudioPath )
{
	if( !pIRiffStream || !pckParent )
	{
		return E_POINTER;
	}

	// Get a pointer to the IStream
	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Initialize ourself to a clean state
	Empty();

	// Initialize the result to S_OK
	HRESULT hr = S_OK;

	// Descend into all chunks within pckParent
	MMCKINFO ckChunk;
	DWORD cbRead;
	while( SUCCEEDED(hr)
		&& (0 == pIRiffStream->Descend( &ckChunk, pckParent, 0 )) )
	{
		switch( ckChunk.ckid )
		{
		case DMUSPROD_FOURCC_BUS_ID:
			if( ckChunk.cksize >= sizeof(DWORD) )
			{
				// Remove any existing bus IDs
				lstBusIDs.RemoveAll();

				// Read in the bus IDs
				long lSize = ckChunk.cksize;
				DWORD dwBusIDTmp;
				while( SUCCEEDED(hr)
				&&	(lSize >= sizeof(DWORD)) )
				{
					hr = pStream->Read( &dwBusIDTmp, sizeof(DWORD), &cbRead );
					lSize -= sizeof(DWORD);

					// If we didn't read in enough data, set hr to a failure code
					if( SUCCEEDED(hr)
					&&	(cbRead != sizeof(DWORD)) )
					{
						hr = E_FAIL;
					}
					else
					{
						// Otherwise, add the bus ID on to the end of the array
						lstBusIDs.Add( dwBusIDTmp );
					}
				}
			}
			else
			{
				// Chunk is too small - fail
				hr = E_FAIL;
			}
			break;

		case DMUSPROD_FOURCC_BUFFER_CHUNK:
			{
				// Read in the buffer settings
				ioBufferOptions iBufferOptions;
				DWORD cbToRead = min( ckChunk.cksize, sizeof( ioBufferOptions ) );
				hr = pStream->Read( &iBufferOptions, cbToRead, &cbRead );

				// If we didn't read in enough data, set hr to a failure code
				if( SUCCEEDED(hr)
				&&	(cbRead != cbToRead) )
				{
					hr = E_FAIL;
				}
				else
				{
					// Otherwise, apply the settings
					memcpy( &ds3DBuffer, &iBufferOptions.ds3DBuffer, sizeof( DS3DBUFFER ) );
					ds3DBuffer.dwSize = sizeof( DS3DBUFFER );
					dwBufferFlags = iBufferOptions.dwBufferFlags;
					dwHeaderFlags = iBufferOptions.dwHeaderFlags;
					guid3DAlgorithm = iBufferOptions.guid3DAlgorithm;
					guidBuffer = iBufferOptions.guidBuffer;
					wChannels = iBufferOptions.wChannels;
					lPan = iBufferOptions.lPan;
					lVolume = iBufferOptions.lVolume;
				}
			}
			break;

		case FOURCC_LIST:
			switch( ckChunk.fccType )
			{
			// Read in each effect chunk
			case DMUSPROD_FOURCC_EFFECTINFO_LIST:
				{
					// Try and read in the effect and
					// Get a pointer to the EffectInfo structure
					EffectInfo *pEffectInfo = pAudioPath->LoadEffect( pIRiffStream, &ckChunk );

					if( pEffectInfo )
					{
						// If the read succeeded, create a BusEffectInfo to wrap the EffectInfo
						BusEffectInfo *pBusEffectInfo = new BusEffectInfo(pEffectInfo);

						// Add the effect to our list of effects
						lstEffects.AddTail( pBusEffectInfo );

						delete pEffectInfo;
					}
				}
				break;
			}
			break;
		}

		pIRiffStream->Ascend( &ckChunk, 0 );
	}

	// Release the IStream
	pStream->Release();

	// Return the result
	return hr;
}

void BufferOptions::Copy( const BufferOptions &bufferOptions )
{
	// Delete just the effect wrappers
	while( !lstEffects.IsEmpty() )
	{
		delete lstEffects.RemoveHead();
	}

	lstBusIDs.Copy( bufferOptions.lstBusIDs );
	guidBuffer = bufferOptions.guidBuffer;
	dwBufferFlags = bufferOptions.dwBufferFlags;
	dwHeaderFlags = bufferOptions.dwHeaderFlags;
	guid3DAlgorithm = bufferOptions.guid3DAlgorithm;
	wChannels = bufferOptions.wChannels;
	ds3DBuffer = bufferOptions.ds3DBuffer;
	fSelected = bufferOptions.fSelected;
	CoCreateGuid( &guidDesignEffectGUID );

	lPan = bufferOptions.lPan;
	lVolume = bufferOptions.lVolume;

	POSITION pos = bufferOptions.lstEffects.GetHeadPosition();
	while( pos )
	{
		BusEffectInfo *pBusEffectInfo = new BusEffectInfo( bufferOptions.lstEffects.GetNext( pos ) );
		lstEffects.AddTail( pBusEffectInfo );
	}
}

/////////////////////////////////////////////////////////////////////////////
// ItemInfo

ItemInfo::ItemInfo()
{
	nNumPChannels = 0;
	adwPChannels = NULL;
	pPortOptions = NULL;
	fSubFieldSelected = false;
	dwDisplayIndex = 0;
}

ItemInfo::ItemInfo( DWORD dwPChannel )
{
	nNumPChannels = 1;
	adwPChannels = new DWORD[1];
	adwPChannels[0] = dwPChannel;
	pPortOptions = NULL;
	fSubFieldSelected = false;
	dwDisplayIndex = 0;
}

ItemInfo::ItemInfo( LPCTSTR strText )
{
	strBandName = strText;
	pPortOptions = NULL;
	nNumPChannels = 0;
	adwPChannels = NULL;
	fSubFieldSelected = false;
	dwDisplayIndex = 0;
}

void ItemInfo::Empty()
{
	if( adwPChannels )
	{
		delete []adwPChannels;
		adwPChannels = NULL;
	}
	nNumPChannels = 0;
	fSubFieldSelected = false;
	while( !lstBuffers.IsEmpty() )
	{
		delete lstBuffers.RemoveHead();
	}
	strBandName.Empty();

	// Don't delete pPortOptions - it is managed by CDirectMusicAudioPath
	pPortOptions = NULL;
	dwDisplayIndex = 0;
}

ItemInfo::~ItemInfo()
{
	while( !lstBuffers.IsEmpty() )
	{
		delete lstBuffers.RemoveHead();
	}
	if( adwPChannels )
	{
		delete[] adwPChannels;
		adwPChannels = NULL;
	}
	pPortOptions = NULL;
}

HRESULT ItemInfo::Write( IDMUSProdRIFFStream *pIRiffStream, const ItemInfo *pParentInfo ) const
{
	if( !pIRiffStream )
	{
		return E_POINTER;
	}

	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Save the item in a LIST chunk
	MMCKINFO ckItem;
	ckItem.fccType = DMUSPROD_FOURCC_ITEMINFO_LIST;
	if( 0 == pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) )
	{
		MMCKINFO ckSubChunk;

		// Save the name in a UNAM chunk
		if( !strBandName.IsEmpty()
		||	(pParentInfo && !pParentInfo->strBandName.IsEmpty()) )
		{
			ckSubChunk.ckid = DMUS_FOURCC_UNAM_CHUNK;
			if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
			{
				SaveMBStoWCS( pStream, pParentInfo ? &pParentInfo->strBandName : &strBandName );
				pIRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		// Save the PChannel list in an DMUSPROD_FOURCC_PCHANNEL_CHUNK chunk
		if( nNumPChannels )
		{
			ckSubChunk.ckid = DMUSPROD_FOURCC_PCHANNEL_CHUNK;
			if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
			{
				pStream->Write( adwPChannels, nNumPChannels * sizeof(DWORD), NULL );
				pIRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		// Write out the port settings
		if( pParentInfo
		&&	pParentInfo->pPortOptions )
		{
			pParentInfo->pPortOptions->Write( pIRiffStream );
		}
		else if( pPortOptions )
		{
			pPortOptions->Write( pIRiffStream );
		}

		// If there are any buffers, save them
		if( pParentInfo )
		{
			POSITION posBuffer = pParentInfo->lstBuffers.GetHeadPosition();
			while( posBuffer )
			{
				pParentInfo->lstBuffers.GetNext( posBuffer )->Write( pIRiffStream );
			}
		}
		else
		{
			POSITION posBuffer = lstBuffers.GetHeadPosition();
			while( posBuffer )
			{
				lstBuffers.GetNext( posBuffer )->Write( pIRiffStream );
			}
		}
			/*
			ckSubChunk.fccType = DMUSPROD_FOURCC_ITEM_BUFFER_LIST;
			if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, MMIO_CREATELIST ) )
			{
				if( pParentInfo )
				{
					POSITION posBus = pParentInfo->lstBuffers.GetHeadPosition();
					while( posBus )
					{
						pParentInfo->lstBuffers.GetNext( posBus )->Write( pIRiffStream );
					}
				}
				else
				{
					POSITION posBus = lstBuffers.GetHeadPosition();
					while( posBus )
					{
						lstBuffers.GetNext( posBus )->Write( pIRiffStream );
					}
				}
				pIRiffStream->Ascend( &ckSubChunk, 0 );
			}
			*/

		pIRiffStream->Ascend( &ckItem, 0 );
	}

	pStream->Release();

	return S_OK;
}

HRESULT ItemInfo::Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent, CDirectMusicAudioPath *pAudioPath )
{
	if( !pIRiffStream || !pckParent )
	{
		return E_POINTER;
	}

	// Get a pointer to the IStream
	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Initialize ourself to a clean state
	Empty();

	// Initialize the result to S_OK
	HRESULT hr = S_OK;

	// Descend into all chunks within pckParent
	MMCKINFO ckChunk;
	DWORD cbRead;
	while( SUCCEEDED(hr)
		&& (0 == pIRiffStream->Descend( &ckChunk, pckParent, 0 )) )
	{
		switch( ckChunk.ckid )
		{
		// Read in the mix group name
		case DMUS_FOURCC_UNAM_CHUNK:
			ReadMBSfromWCS( pStream, ckChunk.cksize, &strBandName );
			break;

		// Read in the list of PChannels
		case DMUSPROD_FOURCC_PCHANNEL_CHUNK:
			// Compute how many PChannels there are
			nNumPChannels = ckChunk.cksize / sizeof(DWORD);

			// Allocate memory for the list of PChannels
			adwPChannels = new DWORD[nNumPChannels];

			// Try and read in the list of PChannels
			hr = pStream->Read( adwPChannels, nNumPChannels * sizeof(DWORD), &cbRead );

			// If we were unable to read all of the PChannels, set hr to a failure code
			if( SUCCEEDED(hr)
			&&	(cbRead != nNumPChannels * sizeof(DWORD)) )
			{
				hr = E_FAIL;
			}

			// If we failed, set the number of PChannels to 0 and delete the memory
			// allocated for them
			if( FAILED(hr) )
			{
				nNumPChannels = 0;
				delete []adwPChannels;
				adwPChannels = NULL;
			}
			break;

		case FOURCC_LIST:
			switch( ckChunk.fccType )
			{
			case DMUSPROD_FOURCC_PORTSETTINGS_LIST:
				// Read in the port settings chunk
				{
					// Create a temporary PortOptions structure
					PortOptions *pTmpPortOptions = new PortOptions;

					// Read in the structure
					hr = pTmpPortOptions->Read( pIRiffStream, &ckChunk );

					if( SUCCEEDED( hr ) )
					{
						// Read succeeded - add the port to the AudioPath's list
						// of ports, if necessary
						pPortOptions = pAudioPath->PastePortOptionsHelper( pTmpPortOptions );
					}
					else
					{
						// Read failed - delete the port
						delete pTmpPortOptions;
					}
				}
				break;

			case DMUSPROD_FOURCC_ITEM_BUFFER_LIST:
				// Read in a buffer
				{
					// Create a new BufferOptions structure
					BufferOptions *pBufferOptions = new BufferOptions();

					// Read in the BufferOptions structure
					hr = pBufferOptions->Read( pIRiffStream, &ckChunk, pAudioPath );

					if( SUCCEEDED( hr ) )
					{
						// If the read succeeded, add it to the list of buses
						lstBuffers.AddTail( pBufferOptions );
					}
					else
					{
						// If the read failed, delete the BufferOptions structure
						delete pBufferOptions;
					}
					/*
					// Iterate through all BUS_LIST chunks
					MMCKINFO ckBus;
					while( SUCCEEDED(hr)
						&& (0 == pIRiffStream->Descend( &ckBus, &ckChunk, 0 )) )
					{
						switch( ckBus.ckid )
						{
						case FOURCC_LIST:
							switch( ckBus.fccType )
							{
							case DMUSPROD_FOURCC_BUS_LIST:
								{
									// Create a new BufferOptions structure
									BufferOptions *pBufferOptions = new BufferOptions();

									// Read in the BufferOptions structure
									hr = pBufferOptions->Read( pIRiffStream, &ckBus, pAudioPath );

									if( SUCCEEDED( hr ) )
									{
										// If the read succeeded, add it to the list of buses
										lstBuffers.AddTail( pBufferOptions );
									}
									else
									{
										// If the read failed, delete the BufferOptions structure
										delete pBufferOptions;
									}
								}
								break;
							}
						}

						// Ascend out of the BUS_LIST chunk
						pIRiffStream->Ascend( &ckBus, 0 );
					}
					*/
				}
				break;
			}
			break;
		}

		// Ascend out of the child chunk
		pIRiffStream->Ascend( &ckChunk, 0 );
	}

	// Release the IStream
	pStream->Release();

	// Return the result
	return hr;
}

bool ItemInfo::Select( bool fNewSelectState )
{
	bool fRefresh = false;

	if( !fNewSelectState && fSubFieldSelected )
	{
		fSubFieldSelected = false;
		fRefresh = true;
	}

	BEI_SELECTION beiNewState = fNewSelectState ? BEI_NORMAL : BEI_NONE;

	POSITION posBuffer = lstBuffers.GetHeadPosition();
	while( posBuffer )
	{
		BufferOptions *pBufferOptions = lstBuffers.GetNext( posBuffer );
		if( pBufferOptions->fSelected != fNewSelectState )
		{
			pBufferOptions->fSelected = fNewSelectState;
			fRefresh = true;
		}

		POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
		while( posEffect )
		{
			BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );
			if( pBusEffectInfo->m_beiSelection != beiNewState )
			{
				pBusEffectInfo->m_beiSelection = beiNewState;
				fRefresh = true;
			}
		}
	}

	return fRefresh;
}

void ItemInfo::Copy( const ItemInfo &itemInfo )
{
	strBandName = itemInfo.strBandName;
	fSubFieldSelected = itemInfo.fSubFieldSelected;
	nNumPChannels = itemInfo.nNumPChannels;
	if( adwPChannels )
	{
		delete [] adwPChannels;
		adwPChannels = 0;
	}
	if( nNumPChannels )
	{
		adwPChannels = new DWORD[nNumPChannels];
		memcpy( adwPChannels, itemInfo.adwPChannels, sizeof(DWORD) * nNumPChannels );
	}

	pPortOptions = itemInfo.pPortOptions;

	while( !lstBuffers.IsEmpty() )
	{
		delete lstBuffers.RemoveHead();
	}

	POSITION pos = itemInfo.lstBuffers.GetHeadPosition();
	while( pos )
	{
		BufferOptions *pBufferOptions = new BufferOptions;
		pBufferOptions->Copy( *itemInfo.lstBuffers.GetNext( pos ) );
		lstBuffers.AddTail( pBufferOptions );
	}
}

void CreateBuffers( ioPortConfig *pioPortConfig,
			 const DWORD dwPChStart, const DWORD dwPChannelSpan,
			 CString strMixGroupName,
			 const CTypedPtrList< CPtrList, BufferOptions *> &lstBuffers,
			 CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers )
{
	// Create a new ioPChannelToBuffer for this buffer
	ioPChannelToBuffer *pioPChannelToBuffer = new ioPChannelToBuffer;
	pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelBase = dwPChStart;
	pioPChannelToBuffer->ioPChannelToBufferHeader.dwPChannelCount = dwPChannelSpan;
	pioPChannelToBuffer->ioPChannelToBufferHeader.dwBufferCount = lstBuffers.GetCount();
	//pioPChannelToBuffer->ioPChannelToBufferHeader.dwFlags = 0; // TODO: Fix this
	pioPChannelToBuffer->strMixGroupName = strMixGroupName;

	// Iterate through the list of buffers
	POSITION posBuffer = lstBuffers.GetHeadPosition();
	while( posBuffer )
	{
		// Get a pointer to each BufferOptions structure
		BufferOptions *pBufferOptions = lstBuffers.GetNext( posBuffer );

		// Store the buffer's GUID
		GUID *pGuid = new GUID;
		*pGuid = pBufferOptions->guidBuffer;
		pioPChannelToBuffer->lstGuids.AddTail( pGuid );

		// If a defined buffer, store the design-time GUID
		if( pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED )
		{
			GUID *pGuid = new GUID;
			*pGuid = pBufferOptions->guidBuffer;
			pioPChannelToBuffer->lstDesignGuids.AddTail( pGuid );
			pGuid = new GUID;
			*pGuid = pBufferOptions->guidDesignEffectGUID;
			pioPChannelToBuffer->lstDesignGuids.AddTail( pGuid );
		}

		// Look for an existing ioDSoundBuffer structure for this GUID
		// If we're using a standard GUID, there can only be one
		bool fFoundExistingBuffer = false;
		POSITION posDSBuffer = lstDSoundBuffers.GetHeadPosition();
		while( posDSBuffer )
		{
			ioDSoundBuffer *pioDSoundBuffer = lstDSoundBuffers.GetNext( posDSBuffer );
			if( pioDSoundBuffer->ioBufferHeader.guidBufferID == *pGuid )
			{
				fFoundExistingBuffer = true;
				break;
			}
		}

		// If we didn't find an existing buffer, create a new one
		if( !fFoundExistingBuffer )
		{
			// Create a new ioDSoundBuffer structure
			ioDSoundBuffer *pioDSoundBuffer = new ioDSoundBuffer;

			// Copy the header information
			pioDSoundBuffer->ioBufferHeader.guidBufferID = pBufferOptions->guidBuffer;
			pioDSoundBuffer->ioBufferHeader.dwFlags = pBufferOptions->dwHeaderFlags;

			// If not using a standard buffer
			if( !(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
			{
				// Copy the buffer-specific information
				pioDSoundBuffer->ioDSBufferDesc.dwFlags = pBufferOptions->dwBufferFlags;
				pioDSoundBuffer->ioDSBufferDesc.lVolume = pBufferOptions->lVolume;
				pioDSoundBuffer->ioDSBufferDesc.lPan = pBufferOptions->lPan;
				//pioDSoundBuffer->ioDSBufferDesc.dwReserved = 0;

				// Ensure there are at least as many channels as Bus IDs
				pioDSoundBuffer->ioDSBufferDesc.nChannels = max( WORD(pBufferOptions->lstBusIDs.GetSize()), pBufferOptions->wChannels );

				// Copy the 3D information
				pioDSoundBuffer->ioDS3D.guid3DAlgorithm = pBufferOptions->guid3DAlgorithm;
				pioDSoundBuffer->ioDS3D.ds3d = pBufferOptions->ds3DBuffer;

				// Set the bus ID(s) for this buffer
				pioDSoundBuffer->lstBusIDs.Copy( pBufferOptions->lstBusIDs );

				// Only save the effect list when using a non-defined buffer
				// and when the buffer has the CTRLFX flag set
				if( !(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
				{
					// Now, save the information for the effect chain
					POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
					while( posEffect )
					{
						// Get a pointer to each effect
						BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );

						// Create a new ioDSoundEffect structure
						ioDSoundEffect *pioDSoundEffect = new ioDSoundEffect;

						// Initialize the DMUS_IO_FX_HEADER structure
						pioDSoundEffect->ioFXHeader.dwEffectFlags = pBusEffectInfo->m_EffectInfo.m_dwFlags;
						pioDSoundEffect->ioFXHeader.guidDSFXClass = pBusEffectInfo->m_EffectInfo.m_clsidObject;
						//pioDSoundEffect->ioFXHeader.guidReserved = GUID_AllZeros;
						pioDSoundEffect->ioFXHeader.guidSendBuffer = pBusEffectInfo->m_EffectInfo.m_clsidSendBuffer;
						//pioDSoundEffect->ioFXHeader.dwReserved = 0;

						// Copy the effect's instance name and real name
						pioDSoundEffect->strInstanceName = pBusEffectInfo->m_EffectInfo.m_strInstanceName;
						pioDSoundEffect->strEffectName = pBusEffectInfo->m_EffectInfo.m_strName;

						// Copy the effect's guid
						pioDSoundEffect->guidDesignGUID = pBusEffectInfo->m_guidEffectInfo;

						// Clone the effect's data stream, if necessary
						if( pBusEffectInfo->m_EffectInfo.m_pIStream )
						{
							pBusEffectInfo->m_EffectInfo.m_pIStream->Clone( &pioDSoundEffect->pStreamData );
						}

						// Add the effect to the end of the effect chain
						pioDSoundBuffer->lstDSoundEffects.AddTail( pioDSoundEffect );
					}
				}
			}

			// if not using a defined buffer
			if( !(pioDSoundBuffer->ioBufferHeader.dwFlags & DMUS_BUFFERF_DEFINED) )
			{
				// Ensure either the Ctrl3D or CtrlPan flag is set
				if( pioDSoundBuffer->ioDSBufferDesc.dwFlags & DSBCAPS_CTRL3D )
				{
					pioDSoundBuffer->ioDSBufferDesc.dwFlags &= ~DSBCAPS_CTRLPAN;
				}
				else
				{
					pioDSoundBuffer->ioDSBufferDesc.dwFlags |= DSBCAPS_CTRLPAN;
				}

				// Ensure only the globalfocus flag is set
				pioDSoundBuffer->ioDSBufferDesc.dwFlags |= DSBCAPS_GLOBALFOCUS;
				pioDSoundBuffer->ioDSBufferDesc.dwFlags &= ~DSBCAPS_STICKYFOCUS;

				// Ensure the CtrlVolume flag is set
				pioDSoundBuffer->ioDSBufferDesc.dwFlags |= DSBCAPS_CTRLVOLUME;

				// Ensure the CtrlFx flag is set iff there are effects
				if( pioDSoundBuffer->lstDSoundEffects.GetCount() > 0 )
				{
					pioDSoundBuffer->ioDSBufferDesc.dwFlags |= DSBCAPS_CTRLFX;
				}
				else
				{
					pioDSoundBuffer->ioDSBufferDesc.dwFlags &= ~DSBCAPS_CTRLFX;
				}
			}

			if( dwPChannelSpan == 0 )
			{
				// There are no PChannel pointing to this buffer, so use the MixGroup name
				pioDSoundBuffer->strName = strMixGroupName;

				// Flag the buffer as 'MixIn'
				pioDSoundBuffer->ioBufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
				pioDSoundBuffer->ioDSBufferDesc.dwFlags |= DSBCAPS_MIXIN;

				// Ensure none of the location flags are set
				pioDSoundBuffer->ioDSBufferDesc.dwFlags &= ~(DSBCAPS_LOCDEFER | DSBCAPS_LOCSOFTWARE | DSBCAPS_LOCHARDWARE);

				// Ensure there are no BusIDs
				pioDSoundBuffer->lstBusIDs.RemoveAll();
			}
			else
			{
				// Clear the name of the DSound buffer
				pioDSoundBuffer->strName.Empty();

				// Ensure the buffer is not MixIn
				pioDSoundBuffer->ioBufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;
				pioDSoundBuffer->ioDSBufferDesc.dwFlags &= ~DSBCAPS_MIXIN;

				// Ensure only the LocDefer location flag is set
				pioDSoundBuffer->ioDSBufferDesc.dwFlags |= DSBCAPS_LOCDEFER;
				pioDSoundBuffer->ioDSBufferDesc.dwFlags &= ~(DSBCAPS_LOCSOFTWARE | DSBCAPS_LOCHARDWARE);

				// if not using a defined buffer
				if( !(pioDSoundBuffer->ioBufferHeader.dwFlags & DMUS_BUFFERF_DEFINED) )
				{
					// Verify there is at least one Bus ID
					ASSERT( pioDSoundBuffer->lstBusIDs.GetSize() > 0 );
				}
			}

			// Now, add the ioDSoundBuffer to the end of the list of buffers
			lstDSoundBuffers.AddTail( pioDSoundBuffer );
		}
	}

	if( pioPortConfig
	&&	(dwPChannelSpan > 0) )
	{
		// Add the ioPChannelToBuffer to the end of the list of PChannel->Buffer mappings
		pioPortConfig->lstPChannelToBuffer.AddTail( pioPChannelToBuffer );
	}
	else
	{
		// No PChannels, so delete pioPChannelToBuffer
		delete pioPChannelToBuffer;
	}
}

void CreateSynthAndBuffers( CTypedPtrList< CPtrList, ioPortConfig*> &lstPortConfigs,
			 PortOptions *pPortOptions, 
			 const DWORD dwPChStart, const DWORD dwPChannelSpan,
			 CString strMixGroupName,
			 const CTypedPtrList< CPtrList, BufferOptions *> &lstBuffers,
			 CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers )
{
	ioPortConfig *pioPortConfig = NULL;

	if( dwPChannelSpan > 0 )
	{
		ASSERT( pPortOptions );

		DMUS_PORTPARAMS8 dmPortParams;
		ZeroMemory( &dmPortParams, sizeof(DMUS_PORTPARAMS8) );
		dmPortParams.dwSize = sizeof(DMUS_PORTPARAMS8);
		dmPortParams.dwValidParams = DMUS_PORTPARAMS_EFFECTS | DMUS_PORTPARAMS_SAMPLERATE | DMUS_PORTPARAMS_VOICES| DMUS_PORTPARAMS_FEATURES;
		dmPortParams.dwSampleRate = pPortOptions->m_dwSampleRate;
		dmPortParams.dwVoices = pPortOptions->m_dwVoices;
		dmPortParams.dwEffectFlags = pPortOptions->m_dwEffects;
		dmPortParams.dwFeatures = pPortOptions->m_fAudioPath ? DMUS_PORT_FEATURE_AUDIOPATH | DMUS_PORT_FEATURE_STREAMING : 0;

		const DWORD dwPChannelEndPlusOne = dwPChStart + dwPChannelSpan;
		POSITION posSynth = lstPortConfigs.GetHeadPosition();
		while( posSynth )
		{
			ioPortConfig *pPortConfig = lstPortConfigs.GetNext( posSynth );

			// Check if the PChannel ranges are adjacent
			if( (pPortConfig->ioPortConfigHeader.dwPChannelBase == dwPChannelEndPlusOne)
			||	(pPortConfig->ioPortConfigHeader.dwPChannelBase + pPortConfig->ioPortConfigHeader.dwPChannelCount == dwPChStart) )
			{
				// Check if the port guids and parameters are equal
				if( (pPortOptions->m_guidPort == pPortConfig->ioPortConfigHeader.guidPort)
				&&	(0 == memcmp( &pPortConfig->ioPortParams, &dmPortParams, sizeof( DMUS_PORTPARAMS8 ) )) )
				{
					// Synths are equal and adjacent - just extend the PChannel range
					pPortConfig->ioPortConfigHeader.dwPChannelBase = min( dwPChStart, pPortConfig->ioPortConfigHeader.dwPChannelBase );
					pPortConfig->ioPortConfigHeader.dwPChannelCount += dwPChannelSpan;

					// Create any buffers for this range of PChannels, if the port support audio paths
					if( pPortOptions->m_fAudioPath )
					{
						CreateBuffers( pPortConfig, dwPChStart, dwPChannelSpan, strMixGroupName, lstBuffers, lstDSoundBuffers );
					}
					else
					{
						// Otherwise, create a design-time chunk to store the PChannel range and Mix Group
						ioDesignMixGroup *pioDesignMixGroup = new ioDesignMixGroup;
						pioDesignMixGroup->dwPChannelStart = dwPChStart;
						pioDesignMixGroup->dwPChannelSpan = dwPChannelSpan;
						pioDesignMixGroup->strMixGroupName = strMixGroupName;
						pPortConfig->lstDesignMixGroup.AddTail( pioDesignMixGroup );
					}

					return;
				}
			}
		}

		// Didn't find an equal and adjacent synth - must create a new one
		pioPortConfig = new ioPortConfig;

		// Set up the DMUS_IO_PORTCONFIG_HEADER structure
		pioPortConfig->ioPortConfigHeader.guidPort = pPortOptions->m_guidPort;
		pioPortConfig->ioPortConfigHeader.dwPChannelBase = dwPChStart;
		pioPortConfig->ioPortConfigHeader.dwPChannelCount = dwPChannelSpan;
		pioPortConfig->ioPortConfigHeader.dwFlags = DMUS_PORTCONFIGF_DRUMSON10;

		// Just copy the DMUS_PORTPARAMS8 structure
		memcpy( &(pioPortConfig->ioPortParams ), &dmPortParams, sizeof(DMUS_PORTPARAMS8) );

		// Copy the names for this port
		pioPortConfig->strPortName = pPortOptions->m_strName;

		// Add the new synth to the list
		lstPortConfigs.AddTail( pioPortConfig );
	}

	// Create any buffers for this range of PChannels, if
	// the PChannel span is empty, or if the port supports AudioPaths
	if( dwPChannelSpan == 0
	||	(pPortOptions && pPortOptions->m_fAudioPath ) )
	{
		CreateBuffers( pioPortConfig, dwPChStart, dwPChannelSpan, strMixGroupName, lstBuffers, lstDSoundBuffers );
	}
	else
	{
		// Otherwise, create a design-time chunk to store the PChannel range and Mix Group
		ioDesignMixGroup *pioDesignMixGroup = new ioDesignMixGroup;
		pioDesignMixGroup->dwPChannelStart = dwPChStart;
		pioDesignMixGroup->dwPChannelSpan = dwPChannelSpan;
		pioDesignMixGroup->strMixGroupName = strMixGroupName;
		pioPortConfig->lstDesignMixGroup.AddTail( pioDesignMixGroup );
	}
}

HRESULT ItemInfo::ConvertToDMusic( CTypedPtrList< CPtrList, ioPortConfig*> &lstPortConfigs,
		CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers ) const
{
	UNREFERENCED_PARAMETER(lstDSoundBuffers);

	if( nNumPChannels > 0 )
	{
		long lIndex = 0;
		while( lIndex < nNumPChannels )
		{
			const DWORD dwPChStart = adwPChannels[lIndex];
			DWORD dwPChCur = dwPChStart + 1;
			lIndex++;

			while( (lIndex < nNumPChannels) && (adwPChannels[lIndex] == dwPChCur) )
			{
				lIndex++;
				dwPChCur++;
			}

			CreateSynthAndBuffers( lstPortConfigs, pPortOptions, dwPChStart, dwPChCur - dwPChStart, strBandName, lstBuffers, lstDSoundBuffers );
		}
	}
	else
	{
		CreateSynthAndBuffers( lstPortConfigs, pPortOptions, 0, 0, strBandName, lstBuffers, lstDSoundBuffers );
	}

	return S_OK;
}

bool ItemInfo::IsAnythingSelected( void )
{
	POSITION posBuffer = lstBuffers.GetHeadPosition();
	while( posBuffer )
	{
		BufferOptions *pBufferOptions = lstBuffers.GetNext( posBuffer );
		if( pBufferOptions->fSelected )
		{
			return true;
		}

		POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
		while( posEffect )
		{
			BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );
			if( pBusEffectInfo->m_beiSelection != BEI_NONE )
			{
				return true;
			}
		}
	}

	return false;
}

HRESULT PortOptions::Write( IDMUSProdRIFFStream *pIRiffStream ) const
{
	if( !pIRiffStream )
	{
		return E_POINTER;
	}

	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Save the item in a LIST chunk
	MMCKINFO ckPort;
	ckPort.fccType = DMUSPROD_FOURCC_PORTSETTINGS_LIST;
	if( 0 == pIRiffStream->CreateChunk( &ckPort, MMIO_CREATELIST ) )
	{
		MMCKINFO ckSubChunk;
		// Save the name in a UNAM chunk
		if( m_strName.GetLength() )
		{
			ckSubChunk.ckid = DMUS_FOURCC_UNAM_CHUNK;
			if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
			{
				SaveMBStoWCS( pStream, &m_strName );
				pIRiffStream->Ascend( &ckSubChunk, 0 );
			}
		}

		// Save the port settings in an PORTSETTINGS_CHUNK chunk
		ckSubChunk.ckid = DMUSPROD_FOURCC_PORTSETTINGS_CHUNK;
		if( 0 == pIRiffStream->CreateChunk( &ckSubChunk, 0 ) )
		{
			ioPortOptions oPortOptions;
			oPortOptions.guidPort = m_guidPort;
			oPortOptions.dwSampleRate = m_dwSampleRate;
			oPortOptions.dwVoices = m_dwVoices;
			oPortOptions.dwMaxVoices = m_dwMaxVoices;
			oPortOptions.dwEffects = m_dwEffects;
			oPortOptions.dwSupportedEffects = m_dwSupportedEffects;
			oPortOptions.fAudioPath = m_fAudioPath;
			pStream->Write( &oPortOptions, sizeof(ioPortOptions), NULL );
			pIRiffStream->Ascend( &ckSubChunk, 0 );
		}

		pIRiffStream->Ascend( &ckPort, 0 );
	}

	pStream->Release();

	return S_OK;
}

HRESULT PortOptions::Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent )
{
	if( !pIRiffStream || !pckParent )
	{
		return E_POINTER;
	}

	// Get a pointer to the IStream
	IStream *pStream = pIRiffStream->GetStream();
	if( !pStream )
	{
		return E_POINTER;
	}

	// Initialize ourself to a clean state
	Empty();

	// Initialize the result to S_OK
	HRESULT hr = S_OK;

	// Descend into all chunks within pckParent
	MMCKINFO ckChunk;
	DWORD cbRead;
	while( SUCCEEDED(hr)
		&& (0 == pIRiffStream->Descend( &ckChunk, pckParent, 0 )) )
	{
		switch( ckChunk.ckid )
		{
		case DMUS_FOURCC_UNAM_CHUNK:
			// Read in the custom name
			ReadMBSfromWCS( pStream, ckChunk.cksize, &m_strName );
			break;

		case DMUSPROD_FOURCC_PORTSETTINGS_CHUNK:
			// Read in the port settings
			{
				// Initialize the ioPortOptions structre
				ioPortOptions iPortOptions;

				// Calculate how much of the structure to read
				DWORD cbToRead = min( ckChunk.cksize, sizeof(ioPortOptions) );

				// Read in the structure
				hr = pStream->Read( &iPortOptions, sizeof(ioPortOptions), &cbRead );

				// If we didn't read in enough data, set hr to a failure code
				if( SUCCEEDED(hr)
				&&	(cbRead != cbToRead) )
				{
					hr = E_FAIL;
				}

				// If the read succeeded
				if( SUCCEEDED(hr) )
				{
					// Copy the data to ourself
					m_guidPort = iPortOptions.guidPort;
					m_dwSampleRate = iPortOptions.dwSampleRate;
					m_dwVoices = iPortOptions.dwVoices;
					m_dwMaxVoices = iPortOptions.dwMaxVoices;
					m_dwEffects = iPortOptions.dwEffects;
					m_dwSupportedEffects = iPortOptions.dwSupportedEffects;
					m_fAudioPath = iPortOptions.fAudioPath ? true : false;
				}
			}
			break;
		}

		// If the name wasn't read in, get it from the port's GUID
		if( m_strName.IsEmpty() )
		{
			m_strName = PortNameFromGUID( m_guidPort );
		}

		pIRiffStream->Ascend( &ckChunk, 0 );
	}

	// Release the IStream
	pStream->Release();

	// Return the result
	return hr;
}

void PortOptions::Empty( void )
{
	m_guidPort = GUID_Synth_Default;
	m_dwEffects = 0;
	m_dwSampleRate = 22050;
	m_dwSupportedEffects = 0;
	m_dwVoices = DEFAULT_NUM_VOICES;
	m_dwMaxVoices = DEFAULT_NUM_VOICES;
	m_fAudioPath = true;
	m_strName.Empty();
}

void PortOptions::Copy( const PortOptions *pPortOptions )
{
	if( pPortOptions == NULL )
	{
		Empty();
	}
	else
	{
		m_strName = pPortOptions->m_strName;
		m_guidPort = pPortOptions->m_guidPort;
		m_dwEffects = pPortOptions->m_dwEffects;
		m_dwSupportedEffects = pPortOptions->m_dwSupportedEffects;
		m_dwSampleRate = pPortOptions->m_dwSampleRate;
		m_dwVoices = pPortOptions->m_dwVoices;
		m_dwMaxVoices = pPortOptions->m_dwMaxVoices;
		m_fAudioPath = pPortOptions->m_fAudioPath;
	}
}

bool PortOptions::IsEqual( const PortOptions *pPortOptions ) const
{
	// m_dwSupportedEffects, m_dwMaxVoices, and m_fAudioPath are non-editable parameters,
	// and solely depend on the port's GUID.
	if( (pPortOptions == NULL)
	||	(m_dwEffects != pPortOptions->m_dwEffects)
//	||	(m_dwSupportedEffects != pPortOptions->m_dwSupportedEffects)
	||	(m_dwSampleRate != pPortOptions->m_dwSampleRate)
	||	(m_dwVoices != pPortOptions->m_dwVoices)
//	||	(m_dwMaxVoices != pPortOptions->m_dwMaxVoices)
//	||	(m_fAudioPath != pPortOptions->m_fAudioPath)
	||	(m_guidPort != pPortOptions->m_guidPort)
	||	(m_strName != pPortOptions->m_strName) )
	{
		return false;
	}

	return true;
}

void InitializeDS3DBUFFER( DS3DBUFFER *pDS3DBUFFER )
{
	ASSERT( pDS3DBUFFER );
	ZeroMemory( pDS3DBUFFER, sizeof( DS3DBUFFER ) );
	pDS3DBUFFER->dwSize = sizeof( DS3DBUFFER );
	pDS3DBUFFER->dwInsideConeAngle = DS3D_DEFAULTCONEANGLE;
	pDS3DBUFFER->dwOutsideConeAngle = DS3D_DEFAULTCONEANGLE;
	pDS3DBUFFER->dwMode = DS3DMODE_NORMAL;
	pDS3DBUFFER->flMaxDistance = DS3D_DEFAULTMAXDISTANCE;
	pDS3DBUFFER->flMinDistance = DS3D_DEFAULTMINDISTANCE;
	pDS3DBUFFER->lConeOutsideVolume = DS3D_DEFAULTCONEOUTSIDEVOLUME;
	pDS3DBUFFER->vConeOrientation.z = 1.0;
	//pDS3DBUFFER->vPosition = 0;
	//pDS3DBUFFER->vVelocity = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectInfo.h ===
#if !defined(AFX_EFFECTINFO_H__F2CDDA70_482F_4CEB_9BCB_ED886E21599A__INCLUDED_)
#define AFX_EFFECTINFO_H__F2CDDA70_482F_4CEB_9BCB_ED886E21599A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EffectInfo.h : header file
//

#include "PPGItemBase.h"

#define DMUSPROD_FOURCC_EFFECTINFO_LIST mmioFOURCC('e','f','c','l')
#define DMUS_FOURCC_UNAM_CHUNK			mmioFOURCC('U','N','A','M')
#define DMUSPROD_FOURCC_EFFECTINFO_HEADER mmioFOURCC('e','f','c','h')
#define DMUSPROD_FOURCC_EFFECTINFO_DATA mmioFOURCC('e','f','c','d')
#define DMUSPROD_FOURCC_EFFECTINFO_NAME mmioFOURCC('e','f','c','n')

#define CH_EFFECT_NAME		0x00000001
#define CH_EFFECT_FLAGS		0x00000002
#define CH_EFFECT_DATA		0x00000004
#define CH_EFFECT_SEND		0x00000008

/*
LIST
(
	'efcl-list' 	// List container for one effect
	[<UNAM-ck>] 	// Optional user-defined name
	<efch-ck>		// Effect header information
	[<efcd-ck>] 	// Optional effect data
	[<efcn-ck>] 	// Optional standard effect name
)
 
	// <efch-ck>			// Effect header chunk
	(
		'efch'
		<CLSID> 	// Effect's CLSID
	)
 
	// <efcd-ck>			// Effect data chunk
	(
		'efcd'
		<BYTE>...	// Effect-specific data
	)
 
	// <efcn-ck>			// Effect name chunk
	(
		'efcn'
		<WCHAR>...	// Effect name
	)
*/

interface IDMUSProdRIFFStream;
interface IStream;
interface IDMUSProdPropPageObject;
class ItemInfo;
struct ioDSoundEffect;

bool StreamsAreEqual( IStream *pIStream1, IStream *pIStream2 );

class EffectInfo
{
// Construction
public:
	EffectInfo();
	EffectInfo( CString strNewName, CString strNewInstanceName, REFCLSID rclsidNewObject, REFCLSID rclsidSendBuffer );
	~EffectInfo();

// Attributes
public:
	CString		m_strInstanceName;
	CString		m_strName;
	CLSID		m_clsidObject;
	CLSID		m_clsidSendBuffer;
	IStream		*m_pIStream;
	DWORD		m_dwFlags;

	ItemInfo	*m_pSendDestinationMixGroup;

// Operations
public:
	HRESULT Write( IDMUSProdRIFFStream *pIStream ) const;
	HRESULT Read( IStream *pIStream );
	HRESULT Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent );

	void Empty( void );

	void Copy( const EffectInfo &effectInfo );
	void Copy( const ioDSoundEffect *pioDSoundEffect );
	bool IsEqualExceptName( const EffectInfo *pEffectInfo ) const;
};

class EffectInfoForPPG : public PPGItemBase
{
// Construction
public:
	EffectInfoForPPG() : PPGItemBase()
	{
		ZeroMemory( &m_clsidObject, sizeof(CLSID) );
		ZeroMemory( &m_clsidSendBuffer, sizeof(CLSID) );
		ZeroMemory( &m_guidMyBuffer, sizeof(GUID) );
		m_pIStream = NULL;
		m_dwFlags = 0;
		m_ppgIndex = PPG_EFFECT;
	};
	virtual ~EffectInfoForPPG()
	{
		if( m_pIStream )
		{
			m_pIStream->Release();
			m_pIStream = NULL;
		}
	}

// Attributes
public:
	CString		m_strInstanceName;
	CString		m_strName;
	CLSID		m_clsidObject;
	CLSID		m_clsidSendBuffer;
	IStream		*m_pIStream;
	DWORD		m_dwFlags;
	GUID		m_guidMyBuffer;

// Operations
public:
	void Copy( const EffectInfoForPPG &effectInfoForPPG )
	{
		PPGItemBase::Copy( effectInfoForPPG );
		m_strInstanceName = effectInfoForPPG.m_strInstanceName;
		m_strName = effectInfoForPPG.m_strName;
		m_clsidObject = effectInfoForPPG.m_clsidObject;
		m_clsidSendBuffer = effectInfoForPPG.m_clsidSendBuffer;
		m_guidMyBuffer = effectInfoForPPG.m_guidMyBuffer;
		m_dwFlags = effectInfoForPPG.m_dwFlags;
		if( m_pIStream )
		{
			m_pIStream->Release();
			m_pIStream = NULL;
		}
		if( effectInfoForPPG.m_pIStream )
		{
			effectInfoForPPG.m_pIStream->Clone( &m_pIStream );
		}
	}
	void Import( const EffectInfo &effectInfo )
	{
		m_strInstanceName = effectInfo.m_strInstanceName;
		m_strName = effectInfo.m_strName;
		m_clsidObject = effectInfo.m_clsidObject;
		m_clsidSendBuffer = effectInfo.m_clsidSendBuffer;
		m_dwFlags = effectInfo.m_dwFlags;
		if( m_pIStream )
		{
			m_pIStream->Release();
			m_pIStream = NULL;
		}
		if( effectInfo.m_pIStream )
		{
			effectInfo.m_pIStream->Clone( &m_pIStream );
		}
	}
};

#endif // !defined(AFX_EFFECTINFO_H__F2CDDA70_482F_4CEB_9BCB_ED886E21599A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectListDlg.cpp ===
// EffectListDlg.cpp : implementation file
//

#include "stdafx.h"
#include <windowsx.h>
#include "dsoundp.h"
#include "EffectListDlg.h"
#include "RiffStrm.h"
#include "AudioPath.h"
#include "AudioPathDesignerDLL.h"
#include "EffectPPGMgr.h"
#include "AudioPathCtl.h"
#include "AudioPathDlg.h"
#include "ItemInfo.h"
#define _SYS_GUID_OPERATORS_
#include "dmoreg.h"
#include "uuids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEffectListDlg dialog


CEffectListDlg::CEffectListDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEffectListDlg::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CEffectListDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pAudioPathCtrl = NULL;
	m_pAudioPath = NULL;
}

CEffectListDlg::~CEffectListDlg()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Remove Effect from clipboard
	theApp.FlushClipboard( this );
}

void CEffectListDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEffectListDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEffectListDlg, CDialog)
	//{{AFX_MSG_MAP(CEffectListDlg)
	ON_NOTIFY(LVN_BEGINDRAG, IDC_LIST_EFFECTS, OnBegindragListEffects)
	ON_WM_CONTEXTMENU()
	ON_WM_SIZE()
	ON_COMMAND(ID_EDIT_EFFECT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_EFFECT_SELECT_ALL, OnEditSelectAll)
	ON_NOTIFY(NM_SETFOCUS, IDC_LIST_EFFECTS, OnSetfocusListEffects)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEffectListDlg message handlers

void CEffectListDlg::OnBegindragListEffects(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NMLISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	COleDataSource *poleSourceObj = new COleDataSource;
	if( poleSourceObj )
	{
		IStream *pIStream;
		::CreateStreamOnHGlobal( NULL, TRUE, &pIStream );
		IDMUSProdRIFFStream *pRiffStream = NULL;
		AllocRIFFStream( pIStream, &pRiffStream );

		bool fWrote = false;
		if( !m_listEffects.GetFirstSelectedItemPosition() )
		{
			// Write out the effect that the drag is started on
			EffectInfo *pEffectInfo = (EffectInfo *)m_listEffects.GetItemData( pNMListView->iItem );
			if( pEffectInfo )
			{
				pEffectInfo->Write( pRiffStream );
				fWrote = true;
			}
		}
		else
		{
			// Write out all the selected effects
			POSITION pos = m_listEffects.GetFirstSelectedItemPosition();
			while( pos )
			{
				// Get a pointer to each effect
				int nIndex = m_listEffects.GetNextSelectedItem( pos );
				EffectInfo *pEffectInfo = reinterpret_cast<EffectInfo *>(m_listEffects.GetItemData( nIndex ));
				if( pEffectInfo )
				{
					pEffectInfo->Write( pRiffStream );

					fWrote = true;
				}
			}
		}

		pRiffStream->Release();

		if( fWrote )
		{
			// Seek back to the start
			StreamSeek( pIStream, 0, STREAM_SEEK_SET );

			STGMEDIUM stgMedium;
			stgMedium.tymed = TYMED_ISTREAM;
			stgMedium.pstm = pIStream;
			stgMedium.pstm->AddRef();
			stgMedium.pUnkForRelease = NULL;
			poleSourceObj->CacheData( CDirectMusicAudioPath::m_scfEffect, &stgMedium );

			// Begin Drag operation
			poleSourceObj->DoDragDrop( DROPEFFECT_COPY );
		}

		delete poleSourceObj;
		pIStream->Release();

		*pResult = 1;
		return;
	}

	*pResult = 0;
}

void CEffectListDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pWnd);

	RECT rectWindow;
	m_listEffects.GetWindowRect( &rectWindow );
	if( ::PtInRect( &rectWindow, point ) )
	{
		HMENU hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_EFFECTPALETTE_RMENU));
		if( hMenu )
		{
			HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
			if( hMenuPopup )
			{
				// Enable/disable items as appropriate
				bool fTemp = AnyEffectsSelected();

				// TODO:
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_COPY, fTemp ?
								MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_SELECT_ALL, ( m_listEffects.GetItemCount() > (fTemp ? 1 : 0) ) ?
								MF_ENABLED : MF_GRAYED );

				// Get the position of the popup menu
				DWORD dwPos = ::GetMessagePos();

				// Display the popup menu
				::TrackPopupMenu( hMenuPopup, TPM_LEFTALIGN | TPM_TOPALIGN, GET_X_LPARAM( dwPos ), GET_Y_LPARAM( dwPos ), 0, m_hWnd, NULL );
			}

			DestroyMenu( hMenu ); // This will destroy the submenu as well.
		}
	}
	else
	{
		//TRACE("Context out of list.\n");
	}
}

BOOL CEffectListDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	m_listEffects.SubclassDlgItem(IDC_LIST_EFFECTS, this);

	CDC *pDC = GetDC();

	CString strTitle;
	CSize size;
	size.cx = 80;

	strTitle.LoadString( IDS_EFFECTLIST_EFFECT_TYPE );
	if( pDC )
	{
		size = pDC->GetTextExtent( strTitle );
	}
	m_listEffects.InsertColumn( 0, strTitle, LVCFMT_LEFT, size.cx, -1 );

	ReleaseDC( pDC );

	RefreshControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEffectListDlg::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnSize(nType, cx, cy);
    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow( m_listEffects.GetSafeHwnd() ) )
	{
		return;
	}

	RECT rect;
	GetClientRect(&rect);
	m_listEffects.MoveWindow(&rect);
}

BOOL CEffectListDlg::OnEraseBkgnd( CDC* pDC )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UNREFERENCED_PARAMETER(pDC);
	return TRUE;
}

void CEffectListDlg::OnEditCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(AnyEffectsSelected());

	// Get a copy of the currently selected effects
	IDataObject *pIDataObject;
	if( SUCCEEDED( CreateDataObject( &pIDataObject ) ) )
	{
		// Send the data to the clipboard
		theApp.PutDataInClipboard( pIDataObject, this );

		// Release our reference to the data object
		pIDataObject->Release();
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CEffectListDlg::OnEditCut() 
{
	ASSERT( 0 );
}

void CEffectListDlg::OnEditDelete() 
{
	ASSERT( 0 );
}

void CEffectListDlg::OnEditInsert() 
{
	ASSERT( 0 );
}

void CEffectListDlg::OnEditPaste() 
{
	ASSERT( 0 );
}

void CEffectListDlg::OnEditSelectAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	for( int iIndex = 0; iIndex < m_listEffects.GetItemCount(); iIndex++ )
	{
		m_listEffects.SetItemState( iIndex, LVIS_SELECTED, LVIS_SELECTED );
	}
}

void CEffectListDlg::OnSetfocusListEffects(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pNMHDR);

	if( m_pAudioPathCtrl )
	{
		m_pAudioPathCtrl->SetLastFocus( FOC_EFFECT );
	}
	
	*pResult = 0;
}

int CEffectListDlg::FindEffectInfoIndex( const EffectInfo *pEffectInfo )
{
	const int nNumItems = m_listEffects.GetItemCount();
	for( int i=0; i < nNumItems; i++ )
	{
		// Compare the EffectInfo pointer
		if( pEffectInfo == reinterpret_cast<EffectInfo *>(m_listEffects.GetItemData( i )) )
		{
			return i;
		}
	}

	// Not found - return -1
	return -1;
}

void CEffectListDlg::AddEffectToList( EffectInfo *pEffectInfo )
{
	// Don't add send effects to the effect palette
	if( pEffectInfo->m_clsidObject == GUID_DSFX_SEND )
	{
		return;
	}

	// Don't add non-default effects to the effect palette
	if( pEffectInfo->m_strInstanceName != pEffectInfo->m_strName )
	{
		return;
	}

	// Fill in the first column
	LVITEM lvItem;
	lvItem.mask = LVIF_PARAM | LVIF_TEXT;
	lvItem.iItem = 0;
	lvItem.iSubItem = 0;
	lvItem.pszText = pEffectInfo->m_strName.GetBuffer( 0 );
	lvItem.lParam = DWORD(pEffectInfo);

	m_listEffects.InsertItem( &lvItem );
	pEffectInfo->m_strName.ReleaseBuffer( -1 );
}

void CEffectListDlg::RefreshControls()
{
	EmptyEffectList();

#ifndef DMP_XBOX
	IEnumDMO *pEnumDMO;

	DMO_PARTIAL_MEDIATYPE dmoPMT;
	dmoPMT.type = MEDIATYPE_Audio;
	dmoPMT.subtype = MEDIASUBTYPE_PCM;

	if( SUCCEEDED( DMOEnum( DMOCATEGORY_AUDIO_EFFECT, 0, 1, &dmoPMT, 1, &dmoPMT, &pEnumDMO ) ) )
	{
		pEnumDMO->Reset();
		CLSID clsidItem;
		WCHAR *pwcName;
		DWORD dwItemsFetched;
		while( S_OK == pEnumDMO->Next( 1, &clsidItem, &pwcName, &dwItemsFetched ) )
		{
			const CString strName = pwcName;
			EffectInfo *pEffectInfo = new EffectInfo( strName, strName, clsidItem, GUID_NULL );

			// Ensure the effect's name is unique
			//GetUniqueEffectInstanceName( pEffectInfo );

			AddEffectToList( pEffectInfo );

			::CoTaskMemFree( pwcName );
		}
		pEnumDMO->Release();
	}
#endif
}

void CEffectListDlg::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	pCmdUI->Enable( AnyEffectsSelected() ? TRUE : FALSE );
}

void CEffectListDlg::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	pCmdUI->Enable( FALSE );
}

void CEffectListDlg::OnUpdateEditDelete(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	pCmdUI->Enable( FALSE );
}

void CEffectListDlg::OnUpdateEditInsert(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	pCmdUI->Enable( FALSE );
}

void CEffectListDlg::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	pCmdUI->Enable( FALSE );
}

void CEffectListDlg::OnUpdateEditSelectAll(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pAudioPath != NULL );

	bool fTemp = AnyEffectsSelected();
	pCmdUI->Enable( ( m_listEffects.GetItemCount() > (fTemp ? 1 : 0) ) ? TRUE : FALSE );
}

void CEffectListDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	EmptyEffectList();

	CDialog::OnDestroy();
}

bool CEffectListDlg::AnyEffectsSelected( void ) 
{
	return m_listEffects.GetFirstSelectedItemPosition() ? true : false;
}

void CEffectListDlg::EmptyEffectList( void )
{
	while( m_listEffects.GetItemCount() > 0 )
	{
		EffectInfo *pEffectInfo = reinterpret_cast<EffectInfo *>(m_listEffects.GetItemData( 0 ));
		if( pEffectInfo )
		{
			delete pEffectInfo;
		}
		m_listEffects.DeleteItem( 0 );
	}
}

HRESULT	CEffectListDlg::CreateDataObject( IDataObject** ppIDataObject )
{
	// Validate our pointer to the data object
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the data object
	*ppIDataObject = NULL;

	if( AnyEffectsSelected() )
	{
		// Create the CDllJazzDataObject 
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Create the stream to save the selected PChannels in
		IStream *pIStream;
		if( FAILED( theApp.m_pAudioPathComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIStream ) ) )
		{
			pDataObject->Release();
			return E_OUTOFMEMORY;
		}

		// Create the RIFF stream to save the selected effect in
		IDMUSProdRIFFStream *pRiffStream = NULL;
		AllocRIFFStream( pIStream, &pRiffStream );

		// Write out all the selected effects
		POSITION pos = m_listEffects.GetFirstSelectedItemPosition();
		while( pos )
		{
			// Get a pointer to each effect
			int nIndex = m_listEffects.GetNextSelectedItem( pos );
			EffectInfo *pEffectInfo = reinterpret_cast<EffectInfo *>(m_listEffects.GetItemData( nIndex ));
			if( pEffectInfo )
			{
				pEffectInfo->Write( pRiffStream );
			}
		}

		// Release the RIFF stream
		pRiffStream->Release();

		// Place effects into CDllJazzDataObject
		pDataObject->AddClipFormat( CDirectMusicAudioPath::m_scfEffect, pIStream );

		// Release the stream
		pIStream->Release();

		// Copy the pointer to the IDataObject
		*ppIDataObject = pDataObject; // Already AddRef'd

		// Return a success code
		return S_OK;
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectListCtl.cpp ===
// EffectListCtl.cpp : implementation file
//

#include "stdafx.h"
#include "EffectListCtl.h"
#include "EffectInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEffectListCtl

CEffectListCtl::CEffectListCtl()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

}

CEffectListCtl::~CEffectListCtl()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

}


BEGIN_MESSAGE_MAP(CEffectListCtl, CListCtrl)
	//{{AFX_MSG_MAP(CEffectListCtl)
	ON_WM_DRAWITEM_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEffectListCtl message handlers

void CEffectListCtl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the Effect
	EffectInfo *pEffectInfo = reinterpret_cast<EffectInfo *>(lpDrawItemStruct->itemData);
	if( !pEffectInfo )
	{
		return;
	}

	// if we're drawing a real item and the item is to be completely
	// draw or drawn as if it is selected, then ...

	if (((LONG)(lpDrawItemStruct->itemID) >= 0) &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
	{
		// set up the text color and the background color
		COLORREF oldTextColor, oldBkColor;
		if ( (lpDrawItemStruct->itemState & ODS_SELECTED) != 0 )
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetFocus() == m_hWnd ? ::GetSysColor(COLOR_HIGHLIGHT) : ::GetSysColor(COLOR_INACTIVECAPTION) );
		}
		else
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOWTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOW) );
		}

		// Draw the (un)selected background
		::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &lpDrawItemStruct->rcItem, NULL, 0, NULL);

		LVCOLUMN lvColumn;
		long lXPos = 0;

		long lScrollPos = -GetScrollPos( SB_HORZ );

		// Effect Name
		lvColumn.mask = LVCF_WIDTH;
		if( GetColumn( 0, &lvColumn ) )
		{
			RECT rectText = lpDrawItemStruct->rcItem;
			rectText.left = lScrollPos;
			rectText.right = lvColumn.cx + lScrollPos;
			::DrawText( lpDrawItemStruct->hDC, pEffectInfo->m_strName, -1, &rectText, DT_SINGLELINE | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );

			lXPos += lvColumn.cx;
		}

		// restore the old objects in the DC
		::SetTextColor( lpDrawItemStruct->hDC, oldTextColor );
		::SetBkColor( lpDrawItemStruct->hDC, oldBkColor);
	}

	// if the item is focused, draw the focus rectangle
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
	{
		::DrawFocusRect( lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem) );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectPPGMgr.cpp ===
// EffectPPGMgr.cpp: implementation of the CEffectPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "EffectPPGMgr.h"
#include "TabEffectInfo.h"
#include "EffectInfo.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

short CEffectPPGMgr::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CEffectPPGMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEffectPPGMgr::CEffectPPGMgr( ) : CDllBasePropPageManager()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_GUIDManager	= GUID_EffectPPGMgr;

	m_pTabEffectInfo= NULL;
}

CEffectPPGMgr::~CEffectPPGMgr()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pTabEffectInfo)
	{
		delete m_pTabEffectInfo;
		m_pTabEffectInfo = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CEffectPPGMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CEffectPPGMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CEffectPPGMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((pbstrTitle == NULL)
	|| (pfAddPropertiesText == NULL))
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_EFFECT_TEXT );

	EffectInfoForPPG effectInfoForPPG;

	// Nothing is constructed in the call to GetData, so we don't need to worry
	// about cleaning up any memory
	if(m_pIPropPageObject
	&& SUCCEEDED(m_pIPropPageObject->GetData((void **)&effectInfoForPPG)) )
	{
		if( effectInfoForPPG.m_fValid
		&&	!effectInfoForPPG.m_strInstanceName.IsEmpty() )
		{
			strTitle = effectInfoForPPG.m_strInstanceName + _T(" ") + strTitle;
		}
		if( !effectInfoForPPG.m_strAudioPathName.IsEmpty() )
		{
			strTitle = effectInfoForPPG.m_strAudioPathName + _T(" - ") + strTitle;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CEffectPPGMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CEffectPPGMgr::GetPropertySheetPages(IDMUSProdPropSheet *pIPropSheet, LONG *hPropSheetPage[], short *pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((hPropSheetPage == NULL)
	|| (pnNbrPages == NULL))
	{
		return E_POINTER;
	}

	if(pIPropSheet == NULL)
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Segment tab
	if( m_pTabEffectInfo == NULL )
	{
		m_pTabEffectInfo = new CTabEffectInfo();
	}
	if(m_pTabEffectInfo)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pTabEffectInfo->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *) hPage;
			nNbrPages++;
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CEffectPPGMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CEffectPPGMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	if(m_pIPropSheet)
	{
		m_pIPropSheet->GetActivePage( &CEffectPPGMgr::sm_nActiveTab );
	}

	HRESULT hr = CBasePropPageManager::OnRemoveFromPropertySheet();

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	RefreshData();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CEffectPPGMgr IDMUSProdPropPageManager::RefreshData

HRESULT CEffectPPGMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pTabEffectInfo == NULL)
	{
		return S_OK;
	}

	// Try and get the information for the selected effect
	EffectInfoForPPG effectInfoForPPG;
	if( (m_pIPropPageObject == NULL)
	||	FAILED(m_pIPropPageObject->GetData((void **)&effectInfoForPPG)) )
	{
		m_pTabEffectInfo->SetEffect( NULL, NULL );

		return S_OK;
	}

	// Make sure changes to current effect are processed in OnKillFocus
	// messages before setting the new effect
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabEffectInfo->GetSafeHwnd() ? m_pTabEffectInfo->GetParent() : NULL;

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	m_pTabEffectInfo->SetEffect( &effectInfoForPPG, m_pIPropPageObject );

	// Restore focus
	if( pWndHadFocus
	&&	pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CEffectPPGMgr IDMUSProdPropPageManager::SetObject

HRESULT CEffectPPGMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CEffectPPGMgr IDMUSProdPropPageManager::RemoveObject

HRESULT CEffectPPGMgr::RemoveObject( IDMUSProdPropPageObject *pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = CDllBasePropPageManager::RemoveObject(pIPropPageObject);
	if(SUCCEEDED(hr))
	{
		if(m_pTabEffectInfo)
		{
			m_pTabEffectInfo->SetEffect(NULL,NULL);
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\EffectListDlg.h ===
#if !defined(AFX_EFFECTLISTDLG_H__8F60957D_55B7_4513_81AC_ADB50E6C6910__INCLUDED_)
#define AFX_EFFECTLISTDLG_H__8F60957D_55B7_4513_81AC_ADB50E6C6910__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EffectListDlg.h : header file
//

#include "resource.h"
#include "DMUSProd.h"
#include "EffectInfo.h"
#include "TreeDropTarget.h"
#include "EffectListCtl.h"

class CAudioPathCtrl;
class CDirectMusicAudioPath;

/////////////////////////////////////////////////////////////////////////////
// CEffectListDlg dialog

class CEffectListDlg : public CDialog
{
friend CAudioPathCtrl;
// Construction
public:
	CEffectListDlg(CWnd* pParent = NULL);   // standard constructor
	virtual ~CEffectListDlg();

// Dialog Data
	//{{AFX_DATA(CEffectListDlg)
	enum { IDD = IDD_DLG_EFFECTLIST };
	CEffectListCtl	m_listEffects;
	//}}AFX_DATA

public:
	CAudioPathCtrl*		m_pAudioPathCtrl;
	CDirectMusicAudioPath*	m_pAudioPath;

	void RefreshControls();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEffectListDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	afx_msg BOOL OnEraseBkgnd( CDC* pDC );


// Implementation
protected:
	int FindEffectInfoIndex( const EffectInfo *pEffectInfo );
	bool AnyEffectsSelected( void );
	void AddEffectToList( EffectInfo *pEffectInfo );
	void EmptyEffectList( void );
	HRESULT	CreateDataObject( IDataObject** ppIDataObject );

	// Generated message map functions
	//{{AFX_MSG(CEffectListDlg)
	afx_msg void OnBegindragListEffects(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnEditDelete();
	afx_msg void OnEditInsert();
	afx_msg void OnEditPaste();
	afx_msg void OnEditSelectAll();
	afx_msg void OnSetfocusListEffects(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EFFECTLISTDLG_H__8F60957D_55B7_4513_81AC_ADB50E6C6910__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\MultiTree.cpp ===
// MultiTree.cpp : implementation file

#include "stdafx.h"
#include <windowsx.h>
#include "dsoundp.h"
#undef SubclassWindow
#include "AudioPathDesigner.h"
#include "MultiTree.h"
#include "resource.h"
#include "AudioPathDlg.h"
#include "AudioPath.h"
#include "ItemInfo.h"
#include "EffectInfo.h"
#include "RiffStrm.h"
#include "AudioPathDesignerDLL.h"
#include "MixGroupPPGMgr.h"
#include "BufferPPGMgr.h"
#include "EffectPPGMgr.h"
#include "AudioPathCtl.h"
#include "DllJazzDataObject.h"
#include "DlgAddRemoveBuses.h"
#include "EffectListDlg.h"
#include "DlgInsertEffect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////

#ifndef MST_TIMER_PERIOD
#define MST_TIMER_PERIOD	75		//ms
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditLabel

CEditLabel::CEditLabel( CString strOrigName )
{
	m_strOrigName = strOrigName;
}

CEditLabel::~CEditLabel()
{
}


BEGIN_MESSAGE_MAP(CEditLabel, CEdit)
	//{{AFX_MSG_MAP(CEditLabel)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditLabel message handlers

/////////////////////////////////////////////////////////////////////////////
// CEditLabel::OnKeyDown

void CEditLabel::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	{
		switch( nChar )
		{
			case VK_TAB:
			case VK_RETURN:
				CloseWindow();
				return;

			case 0x43:  // VK_C
				if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
				{
					Copy();
				}
				break;

			case 0x56:	// VK_V
				if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
				{
					Paste();
				}
				break;

			case 0x58:	// VK_X
				if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
				{
					Cut();
				}
				break;

			case 0x5A:	// VK_Z
				if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
				{
					SetSel( 0, -1 );
					ReplaceSel( m_strOrigName );
					SetSel( 0, -1 );
				}
				break;
		}
	}

	CEdit::OnKeyDown( nChar, nRepCnt, nFlags );
}


/////////////////////////////////////////////////////////////////////////////
// CMultiTree


IMPLEMENT_DYNAMIC(CMultiTree, CListCtrl)

CMultiTree::CMultiTree()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pAudioPathDlg = NULL;
	m_pointPopUpMenu.x = -1;
	m_pointPopUpMenu.y = -1;
	m_pEditCtrl = NULL;
}

CMultiTree::~CMultiTree()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Persist MixGroup or Effect to clipboard
	theApp.FlushClipboard( this );
}

BEGIN_MESSAGE_MAP(CMultiTree, CListCtrl)
	//{{AFX_MSG_MAP(CMultiTree)
	ON_WM_LBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_RBUTTONDOWN()
	ON_WM_KEYDOWN()
	ON_WM_CONTEXTMENU()
	ON_COMMAND(ID_EDIT_COPY, OnEditPChannelCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditPChannelCut)
	ON_COMMAND(ID_EDIT_DELETE, OnEditPChannelDelete)
	ON_COMMAND(ID_EDIT_INSERT, OnEditPChannelInsert)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPChannelPaste)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditPChannelSelectAll)
	ON_COMMAND(ID_EDIT_INSERT_MIXGROUP, OnEditInsertMixGroup)
	ON_COMMAND(ID_EDIT_MIXGROUP_PROPERTIES, OnEditMixGroupProperties)
	ON_COMMAND(ID_EDIT_EFFECT_COPY, OnEditEffectCopy)
	ON_COMMAND(ID_EDIT_EFFECT_CUT, OnEditEffectCut)
	ON_COMMAND(ID_EDIT_EFFECT_DELETE, OnEditEffectDelete)
#ifndef DMP_XBOX
	ON_COMMAND(ID_EDIT_EFFECT_INSERT, OnEditEffectInsert)
	ON_COMMAND(ID_EDIT_SEND_EFFECT_INSERT, OnEditEffectInsertSend)
#endif
	ON_COMMAND(ID_EDIT_EFFECT_PASTE, OnEditEffectPaste)
	ON_COMMAND(ID_EDIT_EFFECT_SELECT_ALL, OnEditEffectSelectAll)
	ON_COMMAND(ID_EDIT_EFFECT_PROPERTIES, OnEditEffectProperties)
	ON_COMMAND(ID_EDIT_BUS_PROPERTIES, OnEditBusProperties)
	ON_COMMAND(ID_EDIT_BUFFER_INSERT, OnEditBufferInsert)
	ON_COMMAND(ID_EDIT_BUFFER_DELETE, OnEditBufferDelete)
	ON_COMMAND(ID_EDIT_BUS_ADDREMOVE, OnEditBusAddRemove)
	ON_COMMAND(ID_EDIT_INSERT_ENV_REVERB, OnEditInsertEnvReverb)
	ON_NOTIFY_REFLECT(LVN_BEGINLABELEDIT, OnBeginlabeledit)
	ON_NOTIFY_REFLECT(LVN_ENDLABELEDIT, OnEndlabeledit)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMultiTree message handlers


void CMultiTree::SelectAll( void )
{
	for( int iIndex = 0; iIndex < GetItemCount(); iIndex++ )
	{
		SetItemState( iIndex, LVIS_SELECTED, LVIS_SELECTED );
	}
}

void CMultiTree::SelectItem( ItemInfo *pItemInfo )
{
	ASSERT( pItemInfo );

	if( pItemInfo->lstBuffers.IsEmpty() )
	{
		int iIndex = m_pAudioPathDlg->FindItem( pItemInfo, NULL );
		SetItemState( iIndex, LVIS_SELECTED, LVIS_SELECTED );
	}

	POSITION pos = pItemInfo->lstBuffers.GetHeadPosition();
	while( pos )
	{
		BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( pos );

		int iIndex = m_pAudioPathDlg->FindItem( pItemInfo, pBufferOptions );
		SetItemState( iIndex, LVIS_SELECTED, LVIS_SELECTED );
	}
}


/////////////////////////////////////////////////////////////////////////////
// OnButtonDown

#define _bShift	(nFlags & MK_SHIFT)
#define _bCtrl	(nFlags & MK_CONTROL)


void CMultiTree::OnLButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OnButtonDown(TRUE, nFlags, point);
}

void CMultiTree::OnRButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OnButtonDown(FALSE, nFlags, point);
}

void CMultiTree::OnButtonDown(BOOL bLeft, UINT nFlags, CPoint point)
{
	UINT nHF = 0;
	int nItem = HitTest(point, &nHF);
	if (nItem >= 0 && !(nHF & LVHT_NOWHERE))
	{
		RECT rect;
		if( GetItemRect( nItem, &rect, LVIR_LABEL )
		&&	(point.x > rect.right) )
		{
			OnButtonDownOnItemRight( nItem, nFlags, point );
			SetFocus();
			return;
		}

		// Clean up all sub-field selections
		UnselectAllSubFields();
	}

	// Fall through to the base class implementation
	if( bLeft )
	{
		// If the user clicked on a selected item when we don't have focus
		if( (nItem >=0)
		&&	(nHF & LVHT_ONITEMLABEL)
		&&	IsSelected( nItem )
		&&	(::GetFocus() != m_hWnd) )
		{
			// Just set the focus to our control
			SetFocus();
		}
		else
		{
			// Otherwise, do the default behavior
			CListCtrl::OnLButtonDown( nFlags, point );
		}
	}
	else
	{
		CListCtrl::OnRButtonDown( nFlags, point );
	}

	m_pAudioPathDlg->SwitchToCorrectPropertyPage();
}

void CMultiTree::OnButtonDownOnItemRight(int nItem, UINT nFlags, CPoint point)
{
	RECT rectItemRect;
	GetItemRect( nItem, &rectItemRect, LVIR_BOUNDS );

	void *pObject = NULL;
	TreeColumn tcRes = GetThingUnderPointAndItem( point, nItem, &pObject );

	switch( tcRes )
	{
	case PCHANNEL_COL:
		// Should not happen
		ASSERT(FALSE);
		break;
	case BUS_BUFFER_COL:
		if( pObject )
		{
			BufferOptions *pBufferOptions = reinterpret_cast<BufferOptions *>(pObject);
			if( _bCtrl )
			{
				pBufferOptions->fSelected = !pBufferOptions->fSelected;
			}
			else
			{
				UnselectAll();
				pBufferOptions->fSelected = TRUE;
			}
			InvalidateRect( &rectItemRect, TRUE );
		}
		break;
	case EFFECT_COL:
		if( pObject )
		{
			BusEffectInfo *pBusEffectInfo = reinterpret_cast<BusEffectInfo *>(pObject);
			if( _bCtrl )
			{
				if( pBusEffectInfo->m_beiSelection == BEI_NONE )
				{
					pBusEffectInfo->m_beiSelection = BEI_NORMAL;
				}
				else
				{
					pBusEffectInfo->m_beiSelection = BEI_NONE;
				}
			}
			else
			{
				UnselectAll();
				pBusEffectInfo->m_beiSelection = BEI_NORMAL;
			}
			InvalidateRect( &rectItemRect, TRUE );
		}
		break;
	default:
		break;
	}

	m_pAudioPathDlg->SwitchToCorrectPropertyPage();
}


void CMultiTree::OnSetFocus(CWnd* pOldWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListCtrl::OnSetFocus(pOldWnd);

	// Continue through all mix group items
	for( int i=0; i < GetItemCount(); i++ )
	{
		// Get a pointer to the ItemInfo in this item
		ItemInfo *pItemInfo = GetItemInfo( i );

		// Check if anything in the item is selected
		if( pItemInfo
		&&	(pItemInfo->IsAnythingSelected() || IsSelected(i)) )
		{
			// Redraw the item
			InvalidateItem( pItemInfo );
		}
	}

	if( m_pAudioPathDlg )
	{
		if( m_pAudioPathDlg->m_pAudioPathCtrl )
		{
			m_pAudioPathDlg->m_pAudioPathCtrl->SetLastFocus( FOC_MIXGROUP );
		}
	}
}

TreeColumn CMultiTree::GetFirstSelectedThing( ItemInfo **ppItemInfo, BufferOptions **ppBufferOptions, BusEffectInfo **ppBusEffectInfo ) const
{
	if( ppItemInfo )
	{
		*ppItemInfo = NULL;
	}

	if( ppBufferOptions )
	{
		*ppBufferOptions= NULL;
	}

	if( ppBusEffectInfo )
	{
		*ppBusEffectInfo = NULL;
	}

	// Iterate through the items
	for( int i=0; i < GetItemCount(); i++ )
	{
		// Get a pointer to this item
		ItemInfo *pItemInfo = GetItemInfo( i );

		// If the pointer is NULL, go on to the next item
		if( pItemInfo == NULL )
		{
			continue;
		}

		// If the MixGroup is selected, switch to the MixGroup PPG
		UINT nState = GetItemState( i, LVIS_SELECTED );
		if ( nState & LVIS_SELECTED )
		{
			if( ppItemInfo )
			{
				*ppItemInfo = pItemInfo;
			}
			return PCHANNEL_COL;
		}

		// See if a buffer or effect is selected
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

			// If the buffer is selected, switch to the buffer PPG
			if( pBufferOptions->fSelected )
			{
				if( ppItemInfo )
				{
					*ppItemInfo = pItemInfo;
				}
				if( ppBufferOptions )
				{
					*ppBufferOptions = pBufferOptions;
				}
				return BUS_BUFFER_COL;
			}

			// See if any effect is selected
			POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
			while( posEffect )
			{
				// Get a pointer to each effect
				BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );

				// If the effect is selected, switch to the effect PPG
				if( pBusEffectInfo->m_beiSelection == BEI_NORMAL )
				{
					if( ppItemInfo )
					{
						*ppItemInfo = pItemInfo;
					}
					if( ppBufferOptions )
					{
						*ppBufferOptions = pBufferOptions;
					}
					if( ppBusEffectInfo )
					{
						*ppBusEffectInfo = pBusEffectInfo;
					}
					return EFFECT_COL;
				}
			}
		}
	}

	return NONE_COL;
}

void CMultiTree::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListCtrl::OnKillFocus(pNewWnd);
	//'emulated' selected items may not get
	// refreshed to grey

	// Continue through all mix group items
	for( int i=0; i < GetItemCount(); i++ )
	{
		// Get a pointer to the ItemInfo in this item
		ItemInfo *pItemInfo = GetItemInfo( i );

		// Check if anything in the item is selected
		if( pItemInfo
		&&	(pItemInfo->IsAnythingSelected() || IsSelected(i)) )
		{
			// Redraw the item
			InvalidateItem( pItemInfo );
		}
	}
}

void CMultiTree::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch (nChar) {
		case VK_F2:
			if( m_pEditCtrl == NULL )
			{
				POSITION pos = GetFirstSelectedItemPosition();
				if( pos )
				{
					// Get a pointer to the item being edited
					int nItem = GetNextSelectedItem( pos );
					ItemInfo *pItemInfo = GetItemInfo( nItem );
					if( pItemInfo )
					{
						// Ensure this is not the Env Reverb mix group
						if( pItemInfo->lstBuffers.GetCount() != 1
						||	pItemInfo->lstBuffers.GetHead()->guidBuffer != GUID_Buffer_EnvReverb )
						{
							// Edit the label
							CEdit *pEdit = EditLabel( nItem );
							if( pEdit )
							{
								// Change the text for the item to only contain the Mix Group name
								pEdit->SetWindowText( pItemInfo->strBandName );
								pEdit->SetSel( 0, -1, FALSE );
							}
						}
					}
				}
			}
			break;
	}

	CListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMultiTree::GetSelectedList(CItemList& list) const
{
	list.RemoveAll();

	POSITION pos = GetFirstSelectedItemPosition();
	while( pos )
	{
		list.AddTail( GetItemInfo( GetNextSelectedItem( pos ) ) );
	}
}

void CMultiTree::SetDMAudioPathDlg( CAudioPathDlg *pDMAudioPathDlg )
{
	m_pAudioPathDlg = pDMAudioPathDlg;
}

void CMultiTree::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pWnd);

	ScreenToClient( &point );
	ItemInfo *pItemInfo = NULL;
	BusEffectInfo *pBusEffectInfo;
	BufferOptions *pBufferOptions;
	int iColumn = GetItemBufferEffectUnderPoint( point, &pItemInfo, &pBufferOptions, &pBusEffectInfo );

	// If there is no item under the mouse cursor
	if( pItemInfo == NULL )
	{
		// Always display the PChannel menu
		iColumn = PCHANNEL_COL;
	}

	HMENU hMenu = NULL;
	switch( iColumn )
	{
	case PCHANNEL_COL:
		hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_PCHANNELTREE_RMENU));
		break;
	case BUS_BUFFER_COL:
		hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_AUDIOBUS_RMENU));
		break;
	case EFFECT_COL:
		hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_EFFECTLIST_RMENU));
		break;
	}

	if( hMenu )
	{
		HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
		if( hMenuPopup )
		{
			// Get the position of the popup menu
			const DWORD dwPos = ::GetMessagePos();

			bool fTemp;
			switch( iColumn )
			{
			case BUS_BUFFER_COL:
				if( pItemInfo
				&&	pItemInfo->nNumPChannels > 0
				&&	ItemSupportsBuffers( pItemInfo ) )
				{
					if( pBufferOptions
					&&	!(pBufferOptions->dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
					{
						EnableMenuItem( hMenuPopup, ID_EDIT_BUS_ADDREMOVE, MF_ENABLED );
					}
					else
					{
						EnableMenuItem( hMenuPopup, ID_EDIT_BUS_ADDREMOVE, MF_GRAYED );
					}
					EnableMenuItem( hMenuPopup, ID_EDIT_BUFFER_INSERT, MF_ENABLED );
					EnableMenuItem( hMenuPopup, ID_EDIT_BUFFER_DELETE, pItemInfo->lstBuffers.GetCount() > 0 ? MF_ENABLED : MF_GRAYED );
				}
				else
				{
					EnableMenuItem( hMenuPopup, ID_EDIT_BUS_ADDREMOVE, MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_BUFFER_INSERT, MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_BUFFER_DELETE, MF_GRAYED );
				}
				break;

			case PCHANNEL_COL:
				// Enable/disable items as appropriate
				fTemp = (GetSelectedCount() > 0);

				EnableMenuItem( hMenuPopup, ID_EDIT_CUT, fTemp ?
								MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_COPY, fTemp ?
								MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, fTemp ?
								MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_MIXGROUP_PROPERTIES, fTemp ? MF_ENABLED : MF_GRAYED );
				if( m_pAudioPathDlg->m_pAudioPath )
				{
					fTemp = ::IsClipboardFormatAvailable( m_pAudioPathDlg->m_pAudioPath->m_scfPChannel ) ||
							::IsClipboardFormatAvailable( m_pAudioPathDlg->m_pAudioPath->m_scfEffect );
				}
				else
				{
					fTemp = false;
				}
				EnableMenuItem( hMenuPopup, ID_EDIT_PASTE, fTemp ?
								MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( GetItemCount() > signed(GetSelectedCount()) ) ?
								MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_INSERT_MIXGROUP, MF_ENABLED );
				EnableMenuItem( hMenuPopup, ID_EDIT_INSERT_ENV_REVERB, m_pAudioPathDlg->HasEnvReverb() ? MF_GRAYED : MF_ENABLED );

				// Check if the user clicked on the Env. Reverb mix group
				if( IsItemEnvReverb( pItemInfo ) )
				{
					EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, MF_GRAYED );
				}
				else
				{
					EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, MF_ENABLED );
				}
				break;

			case EFFECT_COL:
				// Enable/disable items as appropriate

				// fTemp is true if we clicked on an effect
				fTemp = ((pBusEffectInfo != NULL) ? true : false);

				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_CUT, fTemp ? MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_COPY, fTemp ? MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_DELETE, fTemp ? MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_PROPERTIES, fTemp ? MF_ENABLED : MF_GRAYED );

				fTemp = ItemAndBufferSupportEffects( pItemInfo, pBufferOptions );
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_SELECT_ALL, (fTemp && (pBufferOptions->lstEffects.GetCount() > 0)) ? MF_ENABLED : MF_GRAYED );
#ifndef DMP_XBOX
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_INSERT, fTemp ? MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_SEND_EFFECT_INSERT, fTemp ? MF_ENABLED : MF_GRAYED );
#else
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_INSERT, MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_SEND_EFFECT_INSERT, MF_GRAYED );
#endif
				fTemp = (::IsClipboardFormatAvailable( m_pAudioPathDlg->m_pAudioPath->m_scfEffect ) != 0);
				EnableMenuItem( hMenuPopup, ID_EDIT_EFFECT_PASTE, fTemp ? MF_ENABLED : MF_GRAYED );
				break;
			}

			// Save the position of the popup menu
			m_pointPopUpMenu.x = GET_X_LPARAM( dwPos );
			m_pointPopUpMenu.y = GET_Y_LPARAM( dwPos );

			// Display the popup menu
			::TrackPopupMenu( hMenuPopup, TPM_LEFTALIGN | TPM_TOPALIGN, m_pointPopUpMenu.x, m_pointPopUpMenu.y, 0, m_hWnd, NULL );
		}

		DestroyMenu( hMenu ); // This will destroy the submenu as well.
	}
}

HRESULT	CMultiTree::CreateDataObject( IDataObject** ppIDataObject )
{
	// Validate our pointer to the data object
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the data object
	*ppIDataObject = NULL;

	if( m_pAudioPathDlg && (GetSelectedCount() > 0) )
	{
		// Create the CDllJazzDataObject 
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Create the stream to save the selected PChannels in
		IStream *pIStream;
		if( FAILED( theApp.m_pAudioPathComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIStream ) ) )
		{
			pDataObject->Release();
			return E_OUTOFMEMORY;
		}

		CItemList lstTreeItems;
		GetSelectedList( lstTreeItems );

		// Create the RIFF stream to save the selected PChannels in
		IDMUSProdRIFFStream *pRiffStream = NULL;
		AllocRIFFStream( pIStream, &pRiffStream );

		// Write out all the selected PChannels
		POSITION pos = lstTreeItems.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to the information for the item
			const ItemInfo *pItemInfo = lstTreeItems.GetNext( pos );

			// Verify we got a pointer to the item
			if( pItemInfo )
			{
				// If this is a sub-item, then it needs to get the synth/effects/buffer information from the parent.
				pItemInfo->Write( pRiffStream, NULL );
			}
		}

		// Release the RIFF stream
		pRiffStream->Release();

		// Place MixGroups into CDllJazzDataObject
		pDataObject->AddClipFormat( CDirectMusicAudioPath::m_scfPChannel, pIStream );

		// Release the stream
		pIStream->Release();

		// Copy the pointer to the IDataObject
		*ppIDataObject = pDataObject; // Already AddRef'd

		// Return a success code
		return S_OK;
	}

	return E_FAIL;
}

void CMultiTree::OnEditPChannelCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(GetSelectedCount() > 0);

	// Get a copy of the currently selected MixGroups
	IDataObject *pIDataObject;
	if( SUCCEEDED( CreateDataObject( &pIDataObject ) ) )
	{
		// Send the data to the clipboard
		theApp.PutDataInClipboard( pIDataObject, this );

		// Release our reference to the data object
		pIDataObject->Release();
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::OnEditPChannelCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(GetSelectedCount() > 0);
	if( m_pAudioPathDlg && (GetSelectedCount() > 0) )
	{
		// Save an undo state
		m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_CUT_PCHANNELS, true );
		OnEditPChannelCopy();
		DoDelete();
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::OnEditPChannelDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(GetSelectedCount() > 0);
	if( m_pAudioPathDlg && (GetSelectedCount() > 0) )
	{
		// Save an undo state
		m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_DELETE_PCHANNELS, true );
		DoDelete();
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::DoDelete( void )
{
	ASSERT(GetSelectedCount() > 0);
	if( m_pAudioPathDlg && (GetSelectedCount() > 0) )
	{
		CItemList lstTreeItems;
		GetSelectedList( lstTreeItems );

		while( !lstTreeItems.IsEmpty() )
		{
			ItemInfo *pItemInfo = lstTreeItems.RemoveHead();

			if( pItemInfo )
			{
				// Removing a first-level item
				const POSITION posToRemove = m_pAudioPathDlg->m_pAudioPath->m_lstItems.Find( pItemInfo );
				ASSERT( posToRemove );
				m_pAudioPathDlg->m_pAudioPath->m_lstItems.RemoveAt( posToRemove );
			}

			// Update any send effects that pointed at this item
			m_pAudioPathDlg->m_pAudioPath->DisconnectSendEffects( pItemInfo );

			// Now, delete the item that was clicked on
			int nItem = m_pAudioPathDlg->FindItem( pItemInfo, NULL );
			while( nItem >= 0 )
			{
				ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nItem ));
				ASSERT( pItemInfoWrapper );
				DeleteItem( nItem );
				delete pItemInfoWrapper;
				nItem = m_pAudioPathDlg->FindItem( pItemInfo, NULL );
			}
			if( pItemInfo )
			{
				delete pItemInfo;
			}
		}

		// Now, sort the band-level PChannels
		m_pAudioPathDlg->m_pAudioPath->UpdateDisplayIndexes();
		SortItems( ComparePChannelsInTree, 0 );

		m_pAudioPathDlg->m_pAudioPath->SyncAudiopathsInUse( AUDIOPATH_UNLOAD_DOWNLOAD_WAVES );

		m_pAudioPathDlg->m_pAudioPathCtrl->SwitchToCorrectPropertyPage();
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::OnEditPChannelInsert() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPathDlg )
	{
		m_pAudioPathDlg->InsertPChannel( m_pointPopUpMenu );
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::OnEditInsertMixGroup()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPathDlg )
	{
		POINT pointNowhere = { LONG_MIN, LONG_MIN };
		m_pAudioPathDlg->InsertPChannel( pointNowhere );
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::OnEditInsertEnvReverb()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPathDlg )
	{
		m_pAudioPathDlg->InsertEnvReverb();
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::OnEditPChannelPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPathDlg && m_pAudioPathDlg->m_pAudioPath )
	{
		if( ::IsClipboardFormatAvailable( m_pAudioPathDlg->m_pAudioPath->m_scfPChannel ) )
		{
			m_pAudioPathDlg->PastePChannelFromClipboard( m_pointPopUpMenu );
		}
		else if( ::IsClipboardFormatAvailable( m_pAudioPathDlg->m_pAudioPath->m_scfEffect ) )
		{
			m_pAudioPathDlg->PasteEffectFromClipboard( m_pointPopUpMenu );
		}
		else
		{
			ASSERT(FALSE);
		}
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMultiTree::GetEffectRect( const POINT &point, int nTreeItem, BusEffectInfo **ppBusEffectInfo, RECT *pRect )
{
	ASSERT( nTreeItem >= 0 );
	ASSERT( ppBusEffectInfo || pRect );

	if( ppBusEffectInfo )
	{
		*ppBusEffectInfo = NULL;
	}

	if( pRect )
	{
		ZeroMemory( pRect, sizeof(RECT) );
	}

	ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nTreeItem ));

	// If the pointer is NULL, return early
	if( pItemInfoWrapper == NULL )
	{
		return;
	}

	ItemInfo *pItemInfo = pItemInfoWrapper->pItemInfo;

	// If the pointer is NULL, return early
	if( pItemInfo == NULL )
	{
		return;
	}

	// If there are no buffers, return early
	if( pItemInfo->lstBuffers.IsEmpty()
	||	!pItemInfoWrapper->pBufferOptions )
	{
		return;
	}

	long lMixGroupWidth, lBusWidth, lBufferWidth;
	if( pItemInfo
	&&	m_pAudioPathDlg->GetColumnWidths( lMixGroupWidth, lBusWidth, lBufferWidth ) )
	{
		RECT rectItem;
		if( 0 != GetItemRect( nTreeItem, &rectItem, LVIR_BOUNDS ) )
		{
			RECT rectWindow;
			{
				rectWindow.left = lMixGroupWidth + lBusWidth + lBufferWidth - GetScrollPos(SB_HORZ);
				rectWindow.top = rectItem.top;
				rectWindow.bottom = rectItem.bottom;

				// Pointer to each buffer
				BufferOptions *pBufferOptions = pItemInfoWrapper->pBufferOptions;

				if( ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
				{
					POSITION pos = pBufferOptions->lstEffects.GetHeadPosition();
					while( pos )
					{
						BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( pos );
						rectWindow.right = rectWindow.left + pBusEffectInfo->m_lPixelWidth;

						if( (rectWindow.left <= point.x)
						&&	(rectWindow.right >= point.x) )
						{
							if( ppBusEffectInfo )
							{
								*ppBusEffectInfo = pBusEffectInfo;
							}
							if( pRect )
							{
								*pRect = rectWindow;
							}
							break;
						}
						rectWindow.left += pBusEffectInfo->m_lPixelWidth;
					}
				}
			}
		}
	}
}

TreeColumn CMultiTree::GetColumn( long lXPos )
{
	lXPos += GetScrollPos(SB_HORZ);

	if( lXPos < 0 )
	{
		return NONE_COL;
	}

	LVCOLUMN lvColumn;
	lvColumn.mask = LVCF_WIDTH;

	// Mix group column
	if( GetColumn( 0, &lvColumn ) )
	{
		lXPos -= lvColumn.cx;

		if( lXPos < 0 )
		{
			return PCHANNEL_COL;
		}

	}

	// Bus column
	if( GetColumn( 1, &lvColumn ) )
	{
		lXPos -= lvColumn.cx;

		if( lXPos < 0 )
		{
			return BUS_BUFFER_COL;
		}
	}

	// Buffer column
	if( GetColumn( 2, &lvColumn ) )
	{
		lXPos -= lvColumn.cx;

		if( lXPos < 0 )
		{
			return BUS_BUFFER_COL;
		}
	}

	return EFFECT_COL;
}

TreeColumn CMultiTree::GetItemBufferEffectUnderPoint( const POINT &point, ItemInfo **ppItem, BufferOptions **ppBufferOptions, BusEffectInfo **ppBusEffectInfo )
{
	TreeColumn tcRes = NONE_COL;

	if( ppItem )
	{
		*ppItem = NULL;
	}
	if( ppBufferOptions )
	{
		*ppBufferOptions = NULL;
	}
	if( ppBusEffectInfo )
	{
		*ppBusEffectInfo = NULL;
	}

	int nItem = HitTest( point, NULL );
	if( nItem >= 0 )
	{
		ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nItem ));
		if( !pItemInfoWrapper )
		{
			return NONE_COL;
		}

		ItemInfo *pItemInfo = pItemInfoWrapper->pItemInfo;;
		if( !pItemInfo )
		{
			return NONE_COL;
		}

		if( ppItem )
		{
			*ppItem = pItemInfo;
		}

		tcRes = GetColumn( point.x );

		RECT rectItem;
		switch( tcRes )
		{
		case BUS_BUFFER_COL:
		case EFFECT_COL:
			// If we found an item, the item has at least one buffer, and we should return
			// a pointer to the buffer and/or effect
			if( !pItemInfo->lstBuffers.IsEmpty()
			&&	(ppBufferOptions || ppBusEffectInfo)
			&&	( 0 != GetItemRect( nItem, &rectItem, LVIR_BOUNDS )) )
			{
				// Our pointer to the clicked on buffer
				BufferOptions *pBufferOptions = pItemInfoWrapper->pBufferOptions;

				if( pBufferOptions )
				{
					if( ppBufferOptions )
					{
						*ppBufferOptions = pBufferOptions;
					}

					long lMixGroupWidth, lBusWidth, lBufferWidth;
					if( ppBusEffectInfo
					&&	ItemAndBufferSupportEffects( pItemInfo, pBufferOptions )
					&&	m_pAudioPathDlg->GetColumnWidths( lMixGroupWidth, lBusWidth, lBufferWidth ) )
					{
						long lLeft = lMixGroupWidth + lBusWidth + lBufferWidth - GetScrollPos(SB_HORZ);

						POSITION pos = pBufferOptions->lstEffects.GetHeadPosition();
						while( pos )
						{
							BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( pos );
							const long lRight = lLeft + pBusEffectInfo->m_lPixelWidth;

							if( (lLeft <= point.x)
							&&	(lRight >= point.x) )
							{
								*ppBusEffectInfo = pBusEffectInfo;
								break;
							}
							lLeft += pBusEffectInfo->m_lPixelWidth;
						}
					}
				}
			}
			break;
		}
	}

	return tcRes;
}

TreeColumn CMultiTree::GetThingUnderPointAndItem( const POINT &point, int nTreeItem, void **ppThing )
{
	UNREFERENCED_PARAMETER(nTreeItem);

	if( ppThing )
	{
		ItemInfo *pItemInfo;
		BufferOptions *pBufferOptions;
		BusEffectInfo *pBusEffectInfo;
		const TreeColumn tcRes = GetItemBufferEffectUnderPoint( point, &pItemInfo, &pBufferOptions, &pBusEffectInfo );

		switch( tcRes )
		{
		case PCHANNEL_COL:
			*ppThing = pItemInfo;
			break;
		case BUS_BUFFER_COL:
			*ppThing = pBufferOptions;
			break;
		case EFFECT_COL:
			*ppThing = pBusEffectInfo;
			break;
		case NONE_COL:
			*ppThing = NULL;
			break;
		}

		return tcRes;
	}
	else
	{
		return GetColumn( point.x );
	}
}

void CMultiTree::UnselectAll(void )
{
	// Continue until we're through all mix group items
	for( int i=0; i < GetItemCount(); i++ )
	{
		// If the parent item is selected
		if (IsSelected(i) != 0)
		{
			// Unselect it
			SetItemState(i, 0, LVIS_SELECTED);
		}

		// Get a pointer to the ItemInfo in this item
		ItemInfo *pItemInfo = GetItemInfo( i );

		// Unselect it.  If anything was previously selected
		if( pItemInfo && pItemInfo->Select( false ) )
		{
			// Redraw the item
			InvalidateItem( pItemInfo );
		}
	}
}

void CMultiTree::OnEditPChannelSelectAll()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	SelectAll();
}

void CMultiTree::OnEditEffectCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get a pointer to the first selected effect
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	BusEffectInfo *pBusEffectInfo;
	if( GetFirstSelectedThing( &pItemInfo, &pBufferOptions, &pBusEffectInfo ) == EFFECT_COL )
	{
		IDataObject *pIDataObject;
		if( SUCCEEDED( CreateDataObjectEffect( &pIDataObject ) ) )
		{
			// Send the data to the clipboard
			theApp.PutDataInClipboard( pIDataObject, this );

			// Release our reference to the data object
			pIDataObject->Release();
		}
	}
}

void CMultiTree::OnEditEffectCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Just do a copy followed by a delete
	OnEditEffectCopy();
	OnEditEffectDelete();
}

void CMultiTree::OnEditEffectDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get a pointer to the first selected effect
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	if( GetFirstSelectedThing( &pItemInfo, &pBufferOptions, NULL ) == EFFECT_COL )
	{
		// Save an UNDO state
		m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_DELETE_EFFECT );

		POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
		while( posEffect )
		{
			const POSITION posToRemove = posEffect;
			BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );
			if( pBusEffectInfo->m_beiSelection == BEI_NORMAL )
			{
				pBufferOptions->lstEffects.RemoveAt( posToRemove );

				// Delete the Bus effect
				delete pBusEffectInfo;
			}
		}

		// Update the internal names, so that column resize works correctly
		m_pAudioPathDlg->UpdateTreeItemName( pItemInfo );

		// Redraw the item
		InvalidateItem( pItemInfo );

		// Resort the display
		m_pAudioPathDlg->m_pAudioPath->UpdateDisplayIndexes();
		SortItems( ComparePChannelsInTree, 0 );

		// Resize the effect column, since an effect was removed
		m_pAudioPathDlg->ResizeEffectColumn();

		m_pAudioPathDlg->m_pAudioPath->SyncAudiopathsInUse( 0 );

		m_pAudioPathDlg->m_pAudioPathCtrl->SwitchToCorrectPropertyPage();
	}
}

#ifndef DMP_XBOX
void CMultiTree::OnEditEffectInsert()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Convert from screen to client coordinates
	POINT pointInsert = m_pointPopUpMenu;
	ScreenToClient( &pointInsert );

	UINT flags;
	int nTargetItem = HitTest(pointInsert, &flags);
	if( nTargetItem >= 0 )
	{
		BusEffectInfo *pInsertedOnBusEffectInfo;
		RECT rectDroppedOnEffect;
		GetEffectRect( pointInsert, nTargetItem, &pInsertedOnBusEffectInfo, &rectDroppedOnEffect );

		ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nTargetItem ));

		// If the pointer is NULL, return early
		if( pItemInfoWrapper == NULL )
		{
			return;
		}

		ItemInfo *pItemInfo = pItemInfoWrapper->pItemInfo;

		if( pItemInfo
		&&	(pInsertedOnBusEffectInfo || !pItemInfo->lstBuffers.IsEmpty()) )
		{
			// Create and initialize the dialog
			CDlgInsertEffect dlgInsertEffect;
			dlgInsertEffect.m_pAudioPath = m_pAudioPathDlg->m_pAudioPath;

			// Display the dialog
			if( (dlgInsertEffect.DoModal() == IDOK)
			&&	(dlgInsertEffect.m_EffectInfoToCopy.m_clsidObject != GUID_NULL) )
			{
				// Save an undo state
				m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_INSERT_EFFECT, true );

				if( pItemInfo && pInsertedOnBusEffectInfo )
				{
					POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
					while( posBuffer )
					{
						BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

						POSITION pos = pBufferOptions->lstEffects.Find( pInsertedOnBusEffectInfo );
						if( pos )
						{
							// Create a BusEffectInfo to wrap the dropped EffectInfo
							BusEffectInfo *pBusEffectInfo = new BusEffectInfo( &dlgInsertEffect.m_EffectInfoToCopy );

							if( pBusEffectInfo )
							{
								// Set the instance name for the effect
								pBusEffectInfo->m_EffectInfo.m_strInstanceName = dlgInsertEffect.m_strInstanceName;

								// Make only this effect selected
								UnselectAll();
								pBusEffectInfo->m_beiSelection = BEI_NORMAL;

								if( pointInsert.x + GetScrollPos(SB_HORZ) <= rectDroppedOnEffect.left + pInsertedOnBusEffectInfo->m_lPixelWidth / 2 )
								{
									pBufferOptions->lstEffects.InsertBefore( pos, pBusEffectInfo );
								}
								else
								{
									pBufferOptions->lstEffects.InsertAfter( pos, pBusEffectInfo );
								}
							}
							break;
						}
					}
				}
				else if( pItemInfo && !pItemInfo->lstBuffers.IsEmpty() )
				{
					// Get the rectangle of the item
					RECT rectItem;
					if( 0 != GetItemRect( nTargetItem, &rectItem, LVIR_BOUNDS ) )
					{
						// Pointer to the buffer
						BufferOptions *pBufferOptions = pItemInfoWrapper->pBufferOptions;

						// Add the effect to the buffer, if it supports effects,
						// and we can get the column widths
						long lMixGroupWidth, lBusWidth, lBufferWidth;
						if( ItemAndBufferSupportEffects( pItemInfo, pBufferOptions )
						&&	m_pAudioPathDlg->GetColumnWidths( lMixGroupWidth, lBusWidth, lBufferWidth ) )
						{
							// Create a BusEffectInfo to wrap the dropped EffectInfo
							BusEffectInfo *pBusEffectInfo = new BusEffectInfo( &dlgInsertEffect.m_EffectInfoToCopy );

							if( pBusEffectInfo )
							{
								// Set the instance name for the effect
								pBusEffectInfo->m_EffectInfo.m_strInstanceName = dlgInsertEffect.m_strInstanceName;

								// Make only this effect selected
								UnselectAll();
								pBusEffectInfo->m_beiSelection = BEI_NORMAL;

								if( pointInsert.x + GetScrollPos(SB_HORZ) <= lMixGroupWidth + lBusWidth + lBufferWidth )
								{
									pBufferOptions->lstEffects.AddHead( pBusEffectInfo );
								}
								else
								{
									pBufferOptions->lstEffects.AddTail( pBusEffectInfo );
								}
							}
						}
					}
				}

				if( pItemInfo )
				{
					// Update the internal names, so that column resize works correctly
					m_pAudioPathDlg->UpdateTreeItemName( pItemInfo );

					// Resize the effect column, since an effect may have been added
					m_pAudioPathDlg->ResizeEffectColumn();
				}

				InvalidateItem( nTargetItem );

				m_pAudioPathDlg->m_pAudioPath->SyncAudiopathsInUse( 0 );

				// Set the focus to the mix group
				m_pAudioPathDlg->m_pAudioPathCtrl->SetLastFocus( FOC_MIXGROUP );

				// Switch to the correct property page
				m_pAudioPathDlg->m_pAudioPathCtrl->SwitchToCorrectPropertyPage();
			}
		}
	}
}

void CMultiTree::OnEditEffectInsertSend()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Convert from screen to client coordinates
	POINT pointInsert = m_pointPopUpMenu;
	ScreenToClient( &pointInsert );

	UINT flags;
	int nTargetItem = HitTest(pointInsert, &flags);
	if( nTargetItem >= 0 )
	{
		// Save an undo state
		m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_INSERT_EFFECT, true );

		BusEffectInfo *pInsertedOnBusEffectInfo;
		RECT rectDroppedOnEffect;
		GetEffectRect( pointInsert, nTargetItem, &pInsertedOnBusEffectInfo, &rectDroppedOnEffect );

		ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nTargetItem ));

		// If the pointer is NULL, return early
		if( pItemInfoWrapper == NULL )
		{
			return;
		}

		ItemInfo *pItemInfo = pItemInfoWrapper->pItemInfo;

		if( pItemInfo && pInsertedOnBusEffectInfo )
		{
			POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
			while( posBuffer )
			{
				BufferOptions *pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );

				POSITION pos = pBufferOptions->lstEffects.Find( pInsertedOnBusEffectInfo );
				if( pos )
				{
					// Initialize to send to the EnvReverb buffer
					GUID guidToSendTo = GUID_Buffer_EnvReverb;

					// Find the first mixgroup that doesn't have any PChannels
					for( int i=0; i < GetItemCount(); i++ )
					{
						// Get a pointer to the ItemInfo in this item
						ItemInfo *pDestItemInfo = GetItemInfo( i );

						// Check if the item has zero PChannels and at least one buffer
						if( pDestItemInfo
						&&	pDestItemInfo != pItemInfo
						&&	pDestItemInfo->nNumPChannels == 0
						&&	!pDestItemInfo->lstBuffers.IsEmpty() )
						{
							guidToSendTo = pDestItemInfo->lstBuffers.GetHead()->guidBuffer;
							break;
						}
					}

					CString strText;
					strText.LoadString( IDS_SEND_TEXT );
					EffectInfo *pNewEffectInfo = new EffectInfo( strText,strText, GUID_DSFX_SEND, guidToSendTo);

					if( pNewEffectInfo )
					{
						// Ensure the effect's name is unique
						m_pAudioPathDlg->m_pAudioPath->GetUniqueEffectInstanceName( pNewEffectInfo );

						// Create a BusEffectInfo to wrap the dropped EffectInfo
						BusEffectInfo *pBusEffectInfo = new BusEffectInfo(pNewEffectInfo);

						if( pBusEffectInfo )
						{
							if( pointInsert.x + GetScrollPos(SB_HORZ) <= rectDroppedOnEffect.left + pInsertedOnBusEffectInfo->m_lPixelWidth / 2 )
							{
								pBufferOptions->lstEffects.InsertBefore( pos, pBusEffectInfo );
							}
							else
							{
								pBufferOptions->lstEffects.InsertAfter( pos, pBusEffectInfo );
							}
						}
						delete pNewEffectInfo;
					}
					break;
				}
			}
		}
		else if( pItemInfo && !pItemInfo->lstBuffers.IsEmpty() )
		{
			// Get the rectangle of the item
			RECT rectItem;
			if( 0 != GetItemRect( nTargetItem, &rectItem, LVIR_BOUNDS ) )
			{
				// Pointer to each buffer
				BufferOptions *pBufferOptions = pItemInfoWrapper->pBufferOptions;

				// Add the effect to the buffer, if it supports effects,
				// and we can get the column widths
				long lMixGroupWidth, lBusWidth, lBufferWidth;
				if( ItemAndBufferSupportEffects( pItemInfo, pBufferOptions )
				&&	m_pAudioPathDlg->GetColumnWidths( lMixGroupWidth, lBusWidth, lBufferWidth ) )
				{
					// Initialize to send to the EnvReverb buffer
					GUID guidToSendTo = GUID_Buffer_EnvReverb;

					// Find the first mixgroup that doesn't have any PChannels
					for( int i=0; i < GetItemCount(); i++ )
					{
						// Get a pointer to the ItemInfo in this item
						ItemInfo *pDestItemInfo = GetItemInfo( i );

						// Check if the item has zero PChannels and at least one buffer
						if( pDestItemInfo
						&&	pDestItemInfo != pItemInfo
						&&	pDestItemInfo->nNumPChannels == 0
						&&	!pDestItemInfo->lstBuffers.IsEmpty() )
						{
							guidToSendTo = pDestItemInfo->lstBuffers.GetHead()->guidBuffer;
							break;
						}
					}

					CString strText;
					strText.LoadString( IDS_SEND_TEXT );
					EffectInfo *pNewEffectInfo = new EffectInfo( strText, strText, GUID_DSFX_SEND, guidToSendTo);

					if( pNewEffectInfo )
					{
						// Ensure the effect's name is unique
						m_pAudioPathDlg->m_pAudioPath->GetUniqueEffectInstanceName( pNewEffectInfo );

						// Create a BusEffectInfo to wrap the dropped EffectInfo
						BusEffectInfo *pBusEffectInfo = new BusEffectInfo(pNewEffectInfo);

						if( pBusEffectInfo )
						{
							// Make only this effect selected
							UnselectAll();
							pBusEffectInfo->m_beiSelection = BEI_NORMAL;

							if( pointInsert.x + GetScrollPos(SB_HORZ)<= lMixGroupWidth + lBusWidth + lBufferWidth )
							{
								pBufferOptions->lstEffects.AddHead( pBusEffectInfo );
							}
							else
							{
								pBufferOptions->lstEffects.AddTail( pBusEffectInfo );
							}
						}
						
						delete pNewEffectInfo;
					}
				}
			}
		}

		if( pItemInfo )
		{
			// Update the internal names, so that column resize works correctly
			m_pAudioPathDlg->UpdateTreeItemName( pItemInfo );

			// Resize the effect column, since an effect may have been added
			m_pAudioPathDlg->ResizeEffectColumn();
		}

		InvalidateItem( nTargetItem );

		// Resort the display
		m_pAudioPathDlg->m_pAudioPath->UpdateDisplayIndexes();
		SortItems( ComparePChannelsInTree, 0 );

		m_pAudioPathDlg->m_pAudioPath->SyncAudiopathsInUse( 0 );

		// Set the focus to the mix group
		m_pAudioPathDlg->m_pAudioPathCtrl->SetLastFocus( FOC_MIXGROUP );

		// Switch to the correct property page
		m_pAudioPathDlg->m_pAudioPathCtrl->SwitchToCorrectPropertyPage();
	}
}
#endif // DMP_XBOX

void CMultiTree::OnEditEffectPaste()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pAudioPathDlg->PasteEffectFromClipboard( m_pointPopUpMenu );
}

void CMultiTree::OnEditEffectSelectAll()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Convert from screen to client coordinates
	POINT pointInsert = m_pointPopUpMenu;
	ScreenToClient( &pointInsert );

	// Find out which buffer was clicked on
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	GetItemBufferEffectUnderPoint( pointInsert, &pItemInfo, &pBufferOptions, NULL );
	if( ItemAndBufferSupportEffects( pItemInfo, pBufferOptions )
	&&	!pBufferOptions->lstEffects.IsEmpty() )
	{
		// Make only these effects selected
		UnselectAll();

		POSITION pos = pBufferOptions->lstEffects.GetHeadPosition();
		while( pos )
		{
			pBufferOptions->lstEffects.GetNext( pos )->m_beiSelection = BEI_NORMAL;
		}

		InvalidateItem( pItemInfo );
	}
}

void CMultiTree::OnEditMixGroupProperties()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	// Get a pointer to the first selected item
	const ItemInfo *pItemInfo = GetFirstSelectedMixGroupItem();
	if( pItemInfo )
	{
		m_pAudioPathDlg->UpdateMixGroupForPPG();

		// Verify that the property sheet is showing
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() != S_OK )
			{
				short nActiveTab = CMixGroupPPGMgr::sm_nActiveTab;

				if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIMixGroupPageManager) ) )
				{
					theApp.m_pAudioPathComponent->m_pIMixGroupPageManager->SetObject( m_pAudioPathDlg );
					pIPropSheet->SetActivePage( nActiveTab ); 
				}

				// Show the property sheet
				pIPropSheet->Show( TRUE );

				// Refresh the property sheet title
				pIPropSheet->RefreshTitleByObject( m_pAudioPathDlg );

				// Refresh the property sheet page
				pIPropSheet->RefreshActivePageByObject( m_pAudioPathDlg );
			}
			pIPropSheet->Release();
		}
	}
}

void CMultiTree::OnEditBusAddRemove()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Convert from screen to client coordinates
	POINT pointInsert = m_pointPopUpMenu;
	ScreenToClient( &pointInsert );

	// Get the item inserted on
	UINT uFlags;
	int nTreeItem = HitTest( pointInsert, &uFlags );
	if( nTreeItem >= 0 )
	{
		// Get a pointer to the mix group item
		//ItemInfo *pItemInfo = GetItemInfo( nTreeItem );

		// Get the buffer to change
		BufferOptions *pBufferOptions;
		if( (GetThingUnderPointAndItem( pointInsert, nTreeItem, (void **)&pBufferOptions ) == BUS_BUFFER_COL)
		&&	pBufferOptions )
		{
			CDlgAddRemoveBuses dlgAddRemoveBuses;

			dlgAddRemoveBuses.m_adwBusIDs.Copy( pBufferOptions->lstBusIDs );

			if( (dlgAddRemoveBuses.DoModal() == IDOK)
			&&	((pBufferOptions->lstBusIDs.GetSize() != dlgAddRemoveBuses.m_adwBusIDs.GetSize()) ||
				 (0 != memcmp( pBufferOptions->lstBusIDs.GetData(), dlgAddRemoveBuses.m_adwBusIDs.GetData(), sizeof(DWORD) * pBufferOptions->lstBusIDs.GetSize() ))) )
			{
				// Save an UNDO state
				m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_ADDREMOVE_BUSES );

				// Save the offset between the # of buses and the # of channels
				const int nChannelOffset = pBufferOptions->wChannels - pBufferOptions->lstBusIDs.GetSize();
				ASSERT( nChannelOffset >= 0 );

				// Copy the new list of buses
				pBufferOptions->lstBusIDs.Copy( dlgAddRemoveBuses.m_adwBusIDs );

				// Update the # of channels
				pBufferOptions->wChannels = WORD( min( MAX_AUDIO_CHANNELS, pBufferOptions->lstBusIDs.GetSize() + nChannelOffset ) );

				// Redraw the item's bus list
				InvalidateItem( nTreeItem );

				// Update the buffer property page
				m_pAudioPathDlg->UpdateBufferForPPG();
				theApp.m_pAudioPathComponent->m_pIBufferPageManager->RefreshData();

				m_pAudioPathDlg->m_pAudioPath->SyncAudiopathsInUse( 0 );
			}
		}
	}
}

ItemInfo *CMultiTree::GetFirstSelectedMixGroupItem() const
{
	POSITION pos = GetFirstSelectedItemPosition();
	if( pos )
	{
		// Return a pointer to the selected item
		return GetItemInfo( GetNextSelectedItem( pos ) );
	}

	return NULL;
}

void CMultiTree::UnselectAllSubFields(void )
{
	// Continue until we're through all mix group items
	for( int iIndex = 0; iIndex < GetItemCount(); iIndex++ )
	{
		// Get a pointer to the ItemInfo in this item
		ItemInfo *pItemInfo = GetItemInfo( iIndex );

		// Unselect it.  If anything was previously selected
		if( pItemInfo && pItemInfo->Select( false ) )
		{
			// Redraw the item
			InvalidateItem( pItemInfo );
		}
	}
}

void CMultiTree::OnEditEffectProperties()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	// Get a pointer to the first selected item
	if( GetFirstSelectedThing( NULL, NULL, NULL ) == EFFECT_COL )
	{
		m_pAudioPathDlg->UpdateEffectForPPG();

		// Verify that the property sheet is showing
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() != S_OK )
			{
				short nActiveTab = CEffectPPGMgr::sm_nActiveTab;

				if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIEffectPageManager) ) )
				{
					theApp.m_pAudioPathComponent->m_pIEffectPageManager->SetObject( m_pAudioPathDlg );
					pIPropSheet->SetActivePage( nActiveTab ); 
				}

				// Show the property sheet
				pIPropSheet->Show( TRUE );

				// Refresh the property sheet title
				pIPropSheet->RefreshTitleByObject( m_pAudioPathDlg );

				// Refresh the property sheet page
				pIPropSheet->RefreshActivePageByObject( m_pAudioPathDlg );
			}
			pIPropSheet->Release();
		}
	}
}

void CMultiTree::OnEditBusProperties()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	// Get a pointer to the first selected item
	if( GetFirstSelectedThing( NULL, NULL, NULL ) == BUS_BUFFER_COL )
	{
		m_pAudioPathDlg->UpdateBufferForPPG();

		// Verify that the property sheet is showing
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() != S_OK )
			{
				short nActiveTab = CBufferPPGMgr::sm_nActiveTab;

				if( SUCCEEDED ( pIPropSheet->SetPageManager(theApp.m_pAudioPathComponent->m_pIBufferPageManager ) ) )
				{
					theApp.m_pAudioPathComponent->m_pIBufferPageManager->SetObject( m_pAudioPathDlg );
					pIPropSheet->SetActivePage( nActiveTab ); 
				}

				// Show the property sheet
				pIPropSheet->Show( TRUE );

				// Refresh the property sheet title
				pIPropSheet->RefreshTitleByObject( m_pAudioPathDlg );

				// Refresh the property sheet page
				pIPropSheet->RefreshActivePageByObject( m_pAudioPathDlg );
			}
			pIPropSheet->Release();
		}
	}
}

void CMultiTree::OnEditBufferInsert()
{
	// Convert from screen to client coordinates
	POINT pointInsert = m_pointPopUpMenu;
	ScreenToClient( &pointInsert );

	// Get the item inserted on
	UINT uFlags;
	int nTreeItem = HitTest( pointInsert, &uFlags );
	if( nTreeItem >= 0 )
	{
		// Get a pointer to the mix group item
		ItemInfo *pItemInfo = GetItemInfo( nTreeItem );

		if( pItemInfo )
		{
			// Save an UNDO state
			m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_INSERT_BUFFER );

			// Create a buffer
			BufferOptions *pBufferOptions = new BufferOptions;

			// Add the buffer to the item
			pItemInfo->lstBuffers.AddTail( pBufferOptions );

			// If there was an existing buffer
			if( pItemInfo->lstBuffers.GetCount() > 1 )
			{
				// Insert the buffer into the list
				LVITEM lvItem;
				lvItem.mask = LVIF_PARAM | LVIF_TEXT;
				lvItem.iItem = 0;
				lvItem.iSubItem = 0;
				lvItem.pszText = pItemInfo->strBandName.GetBuffer( 0 );
				lvItem.lParam = DWORD(new ItemInfoWrapper(pItemInfo, pBufferOptions));
				InsertItem( &lvItem );
				pItemInfo->strBandName.ReleaseBuffer( -1 );
			}
			else
			{
				// No existing buffer - set the click-on item's buffer pointer
				ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nTreeItem ));
				if( pItemInfoWrapper )
				{
					pItemInfoWrapper->pBufferOptions = pBufferOptions;
				}
			}

			m_pAudioPathDlg->UpdateTreeItemName( pItemInfo );
			m_pAudioPathDlg->m_pAudioPath->UpdateDisplayIndexes();
			SortItems( ComparePChannelsInTree, 0 );

			// Redraw the parent item's synth and effect setting, in case
			// it should become unselected
			// TODO: Redraw less
			InvalidateRect( NULL );

			m_pAudioPathDlg->m_pAudioPath->SyncAudiopathsInUse( 0 );
		}
	}
}

void CMultiTree::OnEditBufferDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get a pointer to the first selected buffer
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	if( GetFirstSelectedThing( &pItemInfo, &pBufferOptions, NULL ) == BUS_BUFFER_COL )
	{
		// Save an UNDO state
		m_pAudioPathDlg->m_pAudioPath->SaveUndoState( IDS_UNDO_DELETE_BUFFER );

		// Now, delete all the selected buffers from this item
		POSITION posBuffer = pItemInfo->lstBuffers.GetHeadPosition();
		while( posBuffer )
		{
			// Save the current position
			const POSITION posCurrent = posBuffer;

			// Get a pointer to each buffer
			pBufferOptions = pItemInfo->lstBuffers.GetNext( posBuffer );
			if( pBufferOptions->fSelected )
			{
				// Remove the buffer from the list
				pItemInfo->lstBuffers.RemoveAt( posCurrent );

				// Find the tree item corresponding to this buffer
				int nTreeItem = m_pAudioPathDlg->FindItem( pItemInfo, pBufferOptions );
				if( nTreeItem >= 0 )
				{
					ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nTreeItem ));
					ASSERT( pItemInfoWrapper );
					if( pItemInfo->lstBuffers.IsEmpty() )
					{
						// If we deleted the last buffer
						pItemInfoWrapper->pBufferOptions = NULL;
					}
					else
					{
						// Delete the item
						DeleteItem( nTreeItem );
						delete pItemInfoWrapper;
					}
				}

				// Delete the buffer
				delete pBufferOptions;
			}
		}

		InvalidateItem( pItemInfo );

		m_pAudioPathDlg->m_pAudioPath->SyncAudiopathsInUse( 0 );

		m_pAudioPathDlg->m_pAudioPathCtrl->SwitchToCorrectPropertyPage();
	}
}

void CMultiTree::OnBeginlabeledit(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// For some reason we periodically miss LVN_ENDLABELEDIT notifications
	// when drag is halfway started on double-click.
	if( m_pEditCtrl )
	{
		delete m_pEditCtrl;
		m_pEditCtrl = NULL;
	}

	NMLVDISPINFO* pLVDispInfo = (NMLVDISPINFO*)pNMHDR;

	ItemInfo *pItemInfo = GetItemInfo( pLVDispInfo->item.iItem );

	CEdit* pEdit = GetEditControl();

	if( pEdit && pItemInfo )
	{
		// Subclass the edit control
		m_pEditCtrl = new CEditLabel( pItemInfo->strBandName );
		if( m_pEditCtrl )
		{
			m_pEditCtrl->SubclassWindow( pEdit->GetSafeHwnd() );
			m_pEditCtrl->SetLimitText( DMUS_MAX_NAME );
			m_pEditCtrl->SetWindowText( pItemInfo->strBandName );
		}

		// Limit length of text
		pEdit->SetLimitText( DMUS_MAX_NAME );
		*pResult = 0;
		return;
	}
	
	*pResult = 1;
}

void CMultiTree::OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pNMHDR);

	if( m_pEditCtrl )
	{
		m_pEditCtrl->UnsubclassWindow();
		delete m_pEditCtrl;
		m_pEditCtrl = NULL;
	}

	NMLVDISPINFO* pLVDispInfo = (NMLVDISPINFO*)pNMHDR;
	ItemInfo *pItemInfo = GetItemInfo( pLVDispInfo->item.iItem );

	if( pItemInfo && m_pAudioPathDlg && m_pAudioPathDlg->m_pAudioPath
	&&	(pLVDispInfo->item.mask & LVIF_TEXT) )
	{
		// Check if the name is unique and at least one character long
		if( (_tcslen( pLVDispInfo->item.pszText ) > 0)
		&&	m_pAudioPathDlg->m_pAudioPath->IsMixgroupNameUnique( NULL, pLVDispInfo->item.pszText ) )
		{
			// Set to true once an undo state has been saved
			bool fChanged = false;

			// Name is unique - save undo state
			m_pAudioPathDlg->m_pAudioPath->SaveUndoState( fChanged, IDS_UNDO_MIXGROUP_NAME, true );

			// Update the name
			pItemInfo->strBandName = pLVDispInfo->item.pszText;
			m_pAudioPathDlg->UpdateTreeItemName( pItemInfo );
			m_pAudioPathDlg->UpdateMixGroupForPPG();
			theApp.m_pAudioPathComponent->m_pIMixGroupPageManager->RefreshData();
		}
		// If name is not unique, ignore the edit
	}

	SetFocus();

	*pResult = 0;
}

void CMultiTree::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pEditCtrl )
	{
		delete m_pEditCtrl;
		m_pEditCtrl = NULL;
	}

	CListCtrl::OnDestroy();
}

HRESULT	CMultiTree::CreateDataObjectEffect( IDataObject** ppIDataObject )
{
	// Validate our pointer to the data object
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the data object
	*ppIDataObject = NULL;

	// Get a pointer to the first selected effect
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	if( GetFirstSelectedThing( &pItemInfo, &pBufferOptions, NULL ) == EFFECT_COL )
	{
		// Create the CDllJazzDataObject 
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Create the stream to save the selected PChannels in
		IStream *pIStream;
		if( FAILED( theApp.m_pAudioPathComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIStream ) ) )
		{
			pDataObject->Release();
			return E_OUTOFMEMORY;
		}

		// Create the RIFF stream to save the selected effect in
		IDMUSProdRIFFStream *pRiffStream = NULL;
		AllocRIFFStream( pIStream, &pRiffStream );

		// Write out all the selected effects
		POSITION posEffect = pBufferOptions->lstEffects.GetHeadPosition();
		while( posEffect )
		{
			// Get a pointer to each effect
			BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( posEffect );
			if( pBusEffectInfo->m_beiSelection == BEI_NORMAL )
			{
				pBusEffectInfo->m_EffectInfo.Write( pRiffStream );
			}
		}

		// Release the RIFF stream
		pRiffStream->Release();

		// Place effects into CDllJazzDataObject
		pDataObject->AddClipFormat( CDirectMusicAudioPath::m_scfEffect, pIStream );

		// Release the stream
		pIStream->Release();

		// Copy the pointer to the IDataObject
		*ppIDataObject = pDataObject; // Already AddRef'd

		// Return a success code
		return S_OK;
	}

	return E_FAIL;
}

void CMultiTree::InvalidateItem( ItemInfo *pItemInfo )
{
	// Redraw the item
	if( pItemInfo->lstBuffers.IsEmpty() )
	{
		InvalidateItem( m_pAudioPathDlg->FindItem( pItemInfo, NULL ) );
	}
	else
	{
		POSITION pos = pItemInfo->lstBuffers.GetHeadPosition();
		while( pos )
		{
			InvalidateItem( m_pAudioPathDlg->FindItem( pItemInfo, pItemInfo->lstBuffers.GetNext( pos ) ) );
		}
	}
}

void CMultiTree::InvalidateItem( int nItem )
{
	// Redraw the item
	if( nItem >= 0 )
	{
		RECT rectDraw;
		if( GetItemRect( nItem, &rectDraw, LVIR_BOUNDS ) )
		{
			InvalidateRect( &rectDraw, TRUE );
		}
	}
}

void BufferToString( const ItemInfo *pItem, const BufferOptions *pBufferOptions, CString &strText );

void CMultiTree::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the Effect
	ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(lpDrawItemStruct->itemData);
	if( !pItemInfoWrapper )
	{
		return;
	}

	ItemInfo *pItemInfo = pItemInfoWrapper->pItemInfo;
	if( !pItemInfo )
	{
		return;
	}

	// if we're drawing a real item and the item is to be completely
	// draw or drawn as if it is selected, then ...

	long lMixGroupWidth, lBusWidth, lBufferWidth;
	if (((LONG)(lpDrawItemStruct->itemID) >= 0)
		&&	m_pAudioPathDlg->GetColumnWidths( lMixGroupWidth, lBusWidth, lBufferWidth )
		&&	(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
	{
		bool fItemSelected = IsSelected( m_pAudioPathDlg->FindItem( pItemInfo, NULL ) );
		const bool fHasFocus = (::GetFocus() == GetSafeHwnd());

		const COLORREF crSelectedText = ::GetSysColor( COLOR_HIGHLIGHTTEXT );
		const COLORREF crSelectedBackground = ::GetSysColor( fHasFocus ? COLOR_HIGHLIGHT : COLOR_INACTIVECAPTION );
		const COLORREF crGreySelectedBackground = ::GetNearestColor( lpDrawItemStruct->hDC, RGB( 100, 100, 100 ) );
		const COLORREF crNormalText = ::GetSysColor(COLOR_WINDOWTEXT);
		const COLORREF crNormalBackground = ::GetSysColor(COLOR_WINDOW);

		const COLORREF crNewBackGround = fItemSelected ? crSelectedBackground : crNormalBackground;
		const COLORREF crOldBackGround = ::SetBkColor( lpDrawItemStruct->hDC, crNewBackGround );
		const COLORREF crNewTextColor = fItemSelected ? crSelectedText : crNormalText;
		const COLORREF crOldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, crNewTextColor );

		if( fItemSelected )
		{
			// Draw the (un)selected background
			::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &lpDrawItemStruct->rcItem, NULL, 0, NULL);
		}

		// Get horizontal scroll position
		long lScrollPos = -GetScrollPos( SB_HORZ );

		// Initialize the text rectangle
		RECT rectText = lpDrawItemStruct->rcItem;

		// Only draw the main item name and dashed line for the first buffer
		if( pItemInfo->lstBuffers.IsEmpty()
		||	pItemInfoWrapper->pBufferOptions == pItemInfo->lstBuffers.GetHead() )
		{
			// Draw a line from the Mix Group to the bus column
			HPEN hPenLine = ::CreatePen( PS_DOT, 0, ::GetSysColor( COLOR_GRAYTEXT ) );
			if( hPenLine )
			{
				// Get the extent of the main item text
				SIZE sizeText;
				::GetTextExtentPoint32( lpDrawItemStruct->hDC, GetItemText( lpDrawItemStruct->itemID, 0 ), GetItemText( lpDrawItemStruct->itemID, 0 ).GetLength(), &sizeText );

				const long lYPos = (lpDrawItemStruct->rcItem.top + lpDrawItemStruct->rcItem.bottom) / 2;
				const HPEN hPenOld = static_cast<HPEN>(::SelectObject( lpDrawItemStruct->hDC, hPenLine ));
				::MoveToEx( lpDrawItemStruct->hDC, sizeText.cx + lScrollPos, lYPos, NULL );
				::LineTo( lpDrawItemStruct->hDC, lMixGroupWidth + lScrollPos, lYPos );
				::SelectObject( lpDrawItemStruct->hDC, hPenOld );
				::DeleteObject( hPenLine );
			}

			// Draw the main item text
			rectText.left = lScrollPos;
			rectText.right = lMixGroupWidth + lScrollPos;
			::DrawText( lpDrawItemStruct->hDC, GetItemText( lpDrawItemStruct->itemID, 0 ), -1, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );

			// if the item is focused, draw the focus rectangle
			//if ( lpCustomDraw->uItemState & CDIS_FOCUS )
			//{
			//	::DrawFocusRect( lpDrawItemStruct->hDC, &rectText );
			//}
		}

		if( pItemInfoWrapper->pBufferOptions )
		{
			// Get a pointer to each buffer
			BufferOptions *pBufferOptions = pItemInfoWrapper->pBufferOptions;

			// Set up the top and bottom of the rectangle to draw in
			rectText.top = lpDrawItemStruct->rcItem.top;
			rectText.bottom = lpDrawItemStruct->rcItem.bottom;
			rectText.right = lpDrawItemStruct->rcItem.right;

			// Only draw effect list when the item and buffer support effects
			if( ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
			{
				// Draw the effects list
				SIZE sizeText;
				CString strEffects;
				long lTextXPos = lMixGroupWidth + lBusWidth + lBufferWidth;
				POSITION pos = pBufferOptions->lstEffects.GetHeadPosition();
				while( pos )
				{
					// Get a pointer to each effect
					BusEffectInfo *pBusEffectInfo = pBufferOptions->lstEffects.GetNext( pos );

					// Check if this is a sending effect
					if( (GUID_DSFX_SEND == pBusEffectInfo->m_EffectInfo.m_clsidObject)
					/*||	(GUID_DSFX_STANDARD_I3DL2SOURCE == pBusEffectInfo->m_EffectInfo.m_clsidObject)*/ )
					{
						if( GUID_DSFX_SEND == pBusEffectInfo->m_EffectInfo.m_clsidObject )
						{
							// Load the "Send" text
							strEffects.LoadString( IDS_SEND_TEXT );
						}
						else
						{
							// Use the instance name
							strEffects = pBusEffectInfo->m_EffectInfo.m_strInstanceName;
						}

						if( NULL != pBusEffectInfo->m_EffectInfo.m_pSendDestinationMixGroup )
						{
							strEffects += _T(" (") + pBusEffectInfo->m_EffectInfo.m_pSendDestinationMixGroup->strBandName + _T(")");
						}
						else if( GUID_Buffer_EnvReverb == pBusEffectInfo->m_EffectInfo.m_clsidSendBuffer )
						{
							CString strReverb;
							strReverb.LoadString( IDS_BUFFER_ENVREVERB );
							strEffects += _T(" (") + strReverb + _T(")");
						}
						else
						{
							CString strExt;
							strExt.LoadString( IDS_SEND_EXTENAL );
							strEffects += strExt;
						}
					}
					else
					{
						strEffects = pBusEffectInfo->m_EffectInfo.m_strInstanceName;
					}
					::GetTextExtentPoint32( lpDrawItemStruct->hDC, strEffects, strEffects.GetLength(), &sizeText );
					pBusEffectInfo->m_lPixelWidth = sizeText.cx;

					if( !fItemSelected )
					{
						switch( pBusEffectInfo->m_beiSelection )
						{
						case BEI_NORMAL:
							::SetBkColor( lpDrawItemStruct->hDC, crSelectedBackground );
							::SetTextColor( lpDrawItemStruct->hDC, crSelectedText );
							break;
						case BEI_GREY:
							::SetBkColor( lpDrawItemStruct->hDC, crGreySelectedBackground );
							::SetTextColor( lpDrawItemStruct->hDC, crSelectedText );
							break;
						}
					}
					// Set the left edge of the text
					rectText.left = lTextXPos + lScrollPos;

					if( !fItemSelected )
					{
						const long lOldRight = rectText.right;
						if( lTextXPos + lScrollPos + sizeText.cx < rectText.right )
						{
							rectText.right = lTextXPos + lScrollPos + sizeText.cx;
						}
						// Draw the (un)selected background
						::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &rectText, NULL, 0, NULL);
						rectText.right = lOldRight;
					}

					// Draw the text
					::DrawText( lpDrawItemStruct->hDC, strEffects, -1, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_LEFT );
					//::TextOut( lpDrawItemStruct->hDC, lTextXPos, lpDrawItemStruct->rcItem.top + 4 + lBufferVerticalOffset, strEffects, strEffects.GetLength() );

					if( !fItemSelected )
					{
						switch( pBusEffectInfo->m_beiSelection )
						{
						case BEI_NORMAL:
						case BEI_GREY:
							::SetBkColor( lpDrawItemStruct->hDC, crNewBackGround );
							::SetTextColor( lpDrawItemStruct->hDC, crNewTextColor );
							break;
						}
					}
					lTextXPos += sizeText.cx;

					// If there is another effect after this one
					if( pos )
					{
						// Draw the " | " spacer between them
						strEffects = _T(" | ");

						// Get the extent of the spacer text
						::GetTextExtentPoint32( lpDrawItemStruct->hDC, strEffects, strEffects.GetLength(), &sizeText );

						// Set the left edge to just after the text we just drew
						rectText.left = lTextXPos + lScrollPos;

						// Draw the text
						::DrawText( lpDrawItemStruct->hDC, strEffects, -1, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_LEFT );
						//::TextOut( lpDrawItemStruct->hDC, lTextXPos, lpDrawItemStruct->rcItem.top + 4 + lBufferVerticalOffset, strEffects, strEffects.GetLength() );

						// Update how far along we've drawn
						lTextXPos += sizeText.cx;

						// Update the width of the effect to include the " | " spacer
						pBusEffectInfo->m_lPixelWidth += sizeText.cx;
					}
				}
			}

			// Draw the bus list
			CString strTemp;
			BusListToString( pItemInfo, pBufferOptions, strTemp );

			if( !fItemSelected
			&&	pBufferOptions->fSelected )
			{
				::SetBkColor( lpDrawItemStruct->hDC, crSelectedBackground );
				::SetTextColor( lpDrawItemStruct->hDC, crSelectedText );
			}
			rectText.top = lpDrawItemStruct->rcItem.top;
			rectText.bottom = lpDrawItemStruct->rcItem.bottom;
			rectText.left = lMixGroupWidth + lScrollPos;
			rectText.right = lMixGroupWidth + lBusWidth + lScrollPos;
			if( !fItemSelected )
			{
				// Draw the (un)selected background
				::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &rectText, NULL, 0, NULL);
			}

			// Draw the text
			::DrawText( lpDrawItemStruct->hDC, strTemp, -1, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );

			// Draw the buffer text
			BufferToString( pItemInfo, pBufferOptions, strTemp );
			rectText.left = lMixGroupWidth + lBusWidth + lScrollPos;
			rectText.right = lMixGroupWidth + lBusWidth + lBufferWidth + lScrollPos;
			if( !fItemSelected )
			{
				// Draw the (un)selected background
				::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &rectText, NULL, 0, NULL);
			}

			// Draw the txt
			::DrawText( lpDrawItemStruct->hDC, strTemp, -1, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );

			if( !fItemSelected
			&&	pBufferOptions->fSelected )
			{
				::SetBkColor( lpDrawItemStruct->hDC, crNewBackGround );
				::SetTextColor( lpDrawItemStruct->hDC, crNewTextColor );
			}
		}
		// If the item doesn't have a buffer
		else
		{
			// Draw the bus text
			CString strTemp;
			BusListToString( pItemInfo, NULL, strTemp );

			RECT rectText;
			rectText.top = lpDrawItemStruct->rcItem.top;
			rectText.bottom = lpDrawItemStruct->rcItem.bottom;
			rectText.left = lMixGroupWidth + lScrollPos;
			rectText.right = lMixGroupWidth + lBusWidth + lScrollPos;
			::DrawText( lpDrawItemStruct->hDC, strTemp, -1, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );

			// Draw the buffer text
			BufferToString( pItemInfo, NULL, strTemp );
			rectText.left = lMixGroupWidth + lBusWidth + lScrollPos;
			rectText.right = lMixGroupWidth + lBusWidth + lBufferWidth + lScrollPos;
			::DrawText( lpDrawItemStruct->hDC, strTemp, -1, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );
		}

		::SetBkColor( lpDrawItemStruct->hDC, crOldBackGround );
		::SetTextColor( lpDrawItemStruct->hDC, crOldTextColor );
	}

	// if the item is focused, draw the focus rectangle
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
	{
		::DrawFocusRect( lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem) );
	}
}

ItemInfo *CMultiTree::GetItemInfo( int nItem ) const
{
	ItemInfoWrapper *pItemInfoWrapper = reinterpret_cast<ItemInfoWrapper *>(GetItemData( nItem ));
	if( pItemInfoWrapper )
	{
		return pItemInfoWrapper->pItemInfo;
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\PPGItemBase.h ===
#if !defined(AFX_PPGITEMBASE_H__818EB751_0DC9_4AE7_ABE6_56FCB72464A9__INCLUDED_)
#define AFX_PPGITEMBASE_H__818EB751_0DC9_4AE7_ABE6_56FCB72464A9__INCLUDED_

typedef enum { PPG_NONE = 0, PPG_MIX_GROUP = 1, PPG_BUFFER = 2, PPG_EFFECT = 3 } PPG_INDEX;

class CDirectMusicAudioPath;

struct PPGItemBase
{
// Construction
public:
	PPGItemBase()
	{
		m_ppgIndex = PPG_NONE;
		m_dwChanged = 0;
		m_pAudioPath = NULL;
		m_fValid = false;
	};
	virtual ~PPGItemBase()
	{
	};

// Operations
public:
	// Helper functions
	void Copy( const PPGItemBase &ppgItemBase )
	{
		m_ppgIndex = ppgItemBase.m_ppgIndex;
		m_dwChanged = ppgItemBase.m_dwChanged;
		m_pAudioPath = ppgItemBase.m_pAudioPath;
		m_strAudioPathName = ppgItemBase.m_strAudioPathName;
		m_fValid = ppgItemBase.m_fValid;
	};

	PPG_INDEX	m_ppgIndex;
	DWORD		m_dwChanged;
	bool		m_fValid;
	CDirectMusicAudioPath	*m_pAudioPath;
	CString		m_strAudioPathName;
};

#endif // !defined(AFX_PPGITEMBASE_H__818EB751_0DC9_4AE7_ABE6_56FCB72464A9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\ItemInfo.h ===
#if !defined(AFX_ITEMINFO_H__808FB750_0DC9_4AE7_ABE6_56FCB72464A9__INCLUDED_)
#define AFX_ITEMINFO_H__808FB750_0DC9_4AE7_ABE6_56FCB72464A9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ItemInfo.h : header file
//

#include "resource.h"
#include "DMUSProd.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "EffectInfo.h"

/////////////////////////////////////////////////////////////////////////////
// ItemInfo window

#define DEFAULT_NUM_VOICES 48

#define DMUSPROD_FOURCC_ITEMINFO_LIST	mmioFOURCC('i','t','m','l')
#define DMUSPROD_FOURCC_PCHANNEL_CHUNK	mmioFOURCC('p','c','h','n')

#define DMUSPROD_FOURCC_PORTSETTINGS_LIST mmioFOURCC('p','r','t','l')
#define DMUSPROD_FOURCC_PORTSETTINGS_CHUNK	mmioFOURCC('p','s','h','c')

#define DMUSPROD_FOURCC_ITEM_BUFFER_LIST mmioFOURCC('i','b','f','l') 
#define DMUSPROD_FOURCC_BUFFER_CHUNK	mmioFOURCC('i','b','s','l')
#define DMUSPROD_FOURCC_BUS_ID			mmioFOURCC('b','s','i','d')

/*
LIST
(
	'itml'			// List of item information
	[<UNAM-ck>] 	// Optional Mix Group name
	[<pchn-ck>] 	// Optional PChannel chunk
	<prtl-list> 	// Port settings list
	<ibsl-list> 	// List of buses
)

LIST
(
	'prtl'			// List container for one port configuration
	<pshc-ck>		// Port settings header
)

LIST
(
	'ibsl-list' 	// List containter for a number of buses
	<busl-list>...	// Any number of bus list chunks
)

LIST
(
	'busl-list' 	// List container for one bus
	<bush-ck>		// Bus config header chunk
	[<efcl-list>]...// Any number of effect list chunks
)

	// <pchn-ck>			// PChannel listing chunk
	(
		'pchn'
		<DWORD>...	// Array of PChannels.
	)
 
	// <pshc-ck>			// Port settings header chunk
	(
		'pshc'
		<ioPortOptions>   // Port settings
	)
 
	// <bush-ck>			// bus settings header chunk
	(
		'bush'
		<DWORD> 	// Bus ID
	)
*/

#define FOURCC_DMUS_EFFECT_DATA_CHUNK mmioFOURCC('d','a','t','a')
#define FOURCC_PORT_NAME_CHUNK mmioFOURCC('p','n','c','d')
#define FOURCC_EFFECT_NAME_CHUNK mmioFOURCC('e','n','c','d')

/*

ioPortConfig
* DMUS_IO_PORTCONFIG_HEADER
* DMUS_PORTPARAMS8
* Instance name
* Port name
* list of ioPChannelToBuffer
* list of ioDesignMixGroup (used for ports that don't connect to buffers)

ioPChannelToBuffer
* DMUS_IO_PCHANNELTOBUFFER_HEADER
* list of buffer GUIDs
* Name of mix group these PChannels are from

ioDesignMixGroup
* list of PChannels
* Name of mix group these PChannels are from

ioDSoundBuffer
* GUID
* Name
* DSOUND_IO_DSBUFFERDESC
* DSOUND_IO_DSBUSSID (list of DWORDs)
* 3d Parameters
* list of ioDSoundEffect

ioDSoundEffect
* DSOUND_IO_DXDMO_HEADER
* Instance name
* Effect name
* pointer to stream with effect data
* design-time GUID

*/

struct ioPChannelToBuffer
{
	ioPChannelToBuffer()
	{
		ZeroMemory( &ioPChannelToBufferHeader, sizeof(DMUS_IO_PCHANNELTOBUFFER_HEADER) );
	}
	~ioPChannelToBuffer()
	{
		while( !lstGuids.IsEmpty() )
		{
			delete lstGuids.RemoveHead();
		}
		while( !lstDesignGuids.IsEmpty() )
		{
			delete lstDesignGuids.RemoveHead();
		}
	}

	DMUS_IO_PCHANNELTOBUFFER_HEADER ioPChannelToBufferHeader;
	CTypedPtrList< CPtrList, GUID* > lstGuids;
	// List of Design GUIDS, with the buffer GUID, then the design GUID, then the buffer GUID, etc.
	CTypedPtrList< CPtrList, GUID* > lstDesignGuids;
	CString strMixGroupName;
};

struct ioDesignMixGroup
{
	DWORD dwPChannelStart;
	DWORD dwPChannelSpan;
	CString strMixGroupName;
};

struct ioPortConfig
{
	ioPortConfig()
	{
		ZeroMemory( &ioPortConfigHeader, sizeof(DMUS_IO_PORTCONFIG_HEADER) );
		ZeroMemory( &ioPortParams, sizeof(DMUS_PORTPARAMS8) );
	}
	~ioPortConfig()
	{
		while( !lstPChannelToBuffer.IsEmpty() )
		{
			delete lstPChannelToBuffer.RemoveHead();
		}
		while( !lstDesignMixGroup.IsEmpty() )
		{
			delete lstDesignMixGroup.RemoveHead();
		}
	}

	DMUS_IO_PORTCONFIG_HEADER ioPortConfigHeader;
	DMUS_PORTPARAMS8 ioPortParams;
	CString strPortName;
	CTypedPtrList< CPtrList, ioPChannelToBuffer* > lstPChannelToBuffer;
	CTypedPtrList< CPtrList, ioDesignMixGroup* > lstDesignMixGroup;
};

struct ioDSoundEffect
{
	ioDSoundEffect()
	{
		ZeroMemory( &ioFXHeader, sizeof(DSOUND_IO_DXDMO_HEADER) );
		pStreamData = NULL;
		ZeroMemory( &guidDesignGUID, sizeof(GUID) );
	}
	~ioDSoundEffect()
	{
		if( pStreamData )
		{
			pStreamData->Release();
			pStreamData = NULL;
		}
	}

	DSOUND_IO_DXDMO_HEADER ioFXHeader;
	IStream *pStreamData;
	CString strInstanceName;	// Also - other UNFO information?
	CString strEffectName;
	GUID guidDesignGUID;
};

void InitializeDS3DBUFFER( DS3DBUFFER *pDS3DBUFFER );

struct ioDSoundBuffer
{
	ioDSoundBuffer()
	{
		ZeroMemory( &ioBufferHeader, sizeof( DMUS_IO_BUFFER_ATTRIBUTES_HEADER ) );
		ZeroMemory( &ioDSBufferDesc, sizeof( DSOUND_IO_DSBUFFERDESC ) );
		ZeroMemory( &ioDS3D, sizeof( DSOUND_IO_3D ) );
		InitializeDS3DBUFFER( &ioDS3D.ds3d );
	}
	~ioDSoundBuffer()
	{
		while( !lstDSoundEffects.IsEmpty() )
		{
			delete lstDSoundEffects.RemoveHead();
		}
	}

	DMUS_IO_BUFFER_ATTRIBUTES_HEADER ioBufferHeader;
	CString strName;	// Also - other UNFO information?
	DSOUND_IO_DSBUFFERDESC ioDSBufferDesc;
	DSOUND_IO_3D ioDS3D;
	CDWordArray lstBusIDs;
	CTypedPtrList< CPtrList, ioDSoundEffect*> lstDSoundEffects;
};

/*
typedef struct 
{
	DSBUFFERDESC dsbd;
} DSOUND_IO_DSBUFFERDESC;

typedef struct 
{
	DWORD	busid[1];
} DSOUND_IO_DSBUSID;

typedef struct
{
	// data structure with presets for 3d
} DSOUND_IO_3D;
*/

interface IDMUSProdRIFFStream;
class CDirectMusicAudioPath;

struct ioPortOptions
{
	ioPortOptions()
	{
		ZeroMemory( &guidPort, sizeof(GUID) );
		dwEffects = 0;
		dwSupportedEffects = 0xFFFFFFFF;
		dwSampleRate = 0;
		dwVoices = DEFAULT_NUM_VOICES;
		dwMaxVoices = DEFAULT_NUM_VOICES;
		fAudioPath = TRUE;
	}

	GUID	guidPort; // GUID used to create the port
	DWORD	dwEffects; // Effects flags (DMUS_EFFECT_*)
	DWORD	dwSupportedEffects; // Supported effects flags (DMUS_EFFECT_*)
	DWORD	dwSampleRate; // Sample rate (11025, 22050, 44100, 48000)
	DWORD	dwVoices; // Number of voices (default = DEFAULT_NUM_VOICES)
	DWORD	dwMaxVoices; // Maximum number of voices (default = DEFAULT_NUM_VOICES)
	BOOL    fAudioPath; // Whether or not the port supports audio paths
};

struct PortOptions
{
	CString 			m_strName;
	GUID				m_guidPort; // GUID used to create the port
	DWORD				m_dwEffects; // Effects flags (DMUS_EFFECT_*)
	DWORD				m_dwSampleRate; // Sample rate (11000, 22000, 44000)
	DWORD				m_dwVoices; // Number of voices (default = DEFAULT_NUM_VOICES)
	DWORD				m_dwMaxVoices; // Maximum number of voices (default = DEFAULT_NUM_VOICES)
    bool				m_fAudioPath; // Whether or not the port supports audio paths
	DWORD				m_dwSupportedEffects; // Which effects are supported

	PortOptions()
	{
		Empty();
	};

	HRESULT Write( IDMUSProdRIFFStream *pIStream ) const;
	HRESULT Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent );

	void Empty( void );

	void Copy( const PortOptions *pPortOptions );
	bool IsEqual( const PortOptions *pPortOptions ) const;
};

typedef enum { BEI_NONE = 0, BEI_NORMAL = 1, BEI_GREY = 2 } BEI_SELECTION;

struct BusEffectInfo
{
	BusEffectInfo( EffectInfo *pNewEffectInfo )
	{
		if( pNewEffectInfo )
		{
			m_EffectInfo.Copy( *pNewEffectInfo );
		}
		m_beiSelection = BEI_NONE;
		m_lPixelWidth = 0;
		::CoCreateGuid( &m_guidEffectInfo );
	}

	BusEffectInfo( const BusEffectInfo *pBusEffectInfo )
	{
		m_EffectInfo.Copy( pBusEffectInfo->m_EffectInfo );
		m_beiSelection = pBusEffectInfo->m_beiSelection;
		m_lPixelWidth = pBusEffectInfo->m_lPixelWidth;
		::CoCreateGuid( &m_guidEffectInfo );
	}

	BusEffectInfo( const ioDSoundEffect *pioDSoundEffect )
	{
		ASSERT( pioDSoundEffect );
		if( pioDSoundEffect )
		{
			m_EffectInfo.Copy( pioDSoundEffect );
			m_guidEffectInfo = pioDSoundEffect->guidDesignGUID;
		}
		else
		{
			::CoCreateGuid( &m_guidEffectInfo );
		}
		m_beiSelection = BEI_NONE;
		m_lPixelWidth = 0;
	}

	EffectInfo m_EffectInfo;
	BEI_SELECTION	m_beiSelection;
	long		m_lPixelWidth;
	GUID		m_guidEffectInfo;
};

struct ioBufferOptions
{
	ioBufferOptions()
	{
		ZeroMemory( this, sizeof(ioBufferOptions) );
		InitializeDS3DBUFFER( &ds3DBuffer );
	}

	GUID	guidBuffer;		// Buffer's GUID
	GUID	guid3DAlgorithm;// DSBUFFERDESC::guid3DAlgorithm
	DWORD	dwHeaderFlags;  // DMUS_IO_BUFFER_ATTRIBUTES_HEADER::dwFlags
	DWORD	dwBufferFlags;	// DSBUFFERDESC::dwFlags
	WORD	wChannels;		// WAVEFORMATEX::nChannels (only used if number of Bus IDs is 0)
	WORD	wReserved;		// Padding bytes
	DS3DBUFFER	ds3DBuffer; // 3D settings
	LONG	lVolume;		// Initial pan; only used if CTRLVOLUME is specified
	LONG	lPan;			// Initial pan; only used if CTRLPAN is specified
};

struct BufferOptions
{
	CDWordArray lstBusIDs;
	GUID	guidBuffer;		// Buffer's GUID
	DWORD	dwHeaderFlags;  // DMUS_IO_BUFFER_ATTRIBUTES_HEADER::dwFlags
	DWORD	dwBufferFlags;	// DSBUFFERDESC::dwFlags
	GUID	guid3DAlgorithm;// DSBUFFERDESC::guid3DAlgorithm
	WORD	wChannels;		// WAVEFORMATEX::nChannels (only used if number of Bus IDs is 0)
	DS3DBUFFER	ds3DBuffer; // 3D settings
	LONG	lVolume;		// Initial pan; only used if CTRLVOLUME is specified
	LONG	lPan;			// Initial pan; only used if CTRLPAN is specified
	//CString strName;	// Name of buffer
	CTypedPtrList< CPtrList, BusEffectInfo *> lstEffects;
	bool	fSelected;		// Selection state of buffer and buses
	GUID	guidDesignEffectGUID;// Design-time GUID used when this is a standard buffer with an effect in it

	BufferOptions();
	~BufferOptions();

	void Empty( void );
	void Copy( const BufferOptions &bufferOptions );

	HRESULT Write( IDMUSProdRIFFStream *pIStream ) const;
	HRESULT Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent, CDirectMusicAudioPath *pAudioPath );
};

class ItemInfo
{
// Construction
public:
	ItemInfo();
	ItemInfo( DWORD dwPChannel );
	ItemInfo( LPCTSTR strText );
	~ItemInfo();

// Attributes
public:
	CString strBandName;
	int nNumPChannels;
	DWORD *adwPChannels;
	bool fSubFieldSelected;

	PortOptions *pPortOptions;

	CTypedPtrList< CPtrList, BufferOptions *> lstBuffers;

	DWORD dwDisplayIndex;

// Operations
public:
	HRESULT Write( IDMUSProdRIFFStream *pIStream, const ItemInfo *pParentInfo = NULL ) const;
	HRESULT Read( IDMUSProdRIFFStream *pIRiffStream, MMCKINFO *pckParent, CDirectMusicAudioPath *pAudioPath );
	bool Select( bool fNewSelectState ); // Returns true if something changed
	HRESULT ConvertToDMusic( CTypedPtrList< CPtrList, ioPortConfig*> &lstPortConfigs,
		CTypedPtrList< CPtrList, ioDSoundBuffer*> &lstDSoundBuffers ) const;

	// Helper functions
	void Copy( const ItemInfo &itemInfo );
	bool IsAnythingSelected( void );

protected:
	void Empty( void );
};

#endif // !defined(AFX_ITEMINFO_H__808FB750_0DC9_4AE7_ABE6_56FCB72464A9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\Splitter.cpp ===
// Splitter.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "Splitter.h"
#pragma warning(default:4201)
#include "AudioPathDesignerDLL.h"
#include "AudioPathCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//*****************************************************************************
//***** CSplitter
//*****************************************************************************

BEGIN_MESSAGE_MAP(CSplitter, CWnd)
	//{{AFX_MSG_MAP(CSplitter)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_SETCURSOR()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_WM_CAPTURECHANGED()
END_MESSAGE_MAP()

//*****************************************************************************
CSplitter::CSplitter() :
	m_rcTrack(0, 0, 0, 0),
	m_fTracking(FALSE),
	m_fVisible(FALSE),
	m_pParent(NULL),
	m_nWidth(0),
	m_rcFirstPane(0, 0, 0, 0),
	m_rcSecondPane(0, 0, 0, 0),
	m_pFirstPane(NULL),
	m_pSecondPane(NULL)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
}

//*****************************************************************************
CSplitter::~CSplitter()
{
}

//*****************************************************************************
BOOL CSplitter::Create( CWnd *pParent, RECT *rect )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Save our parent
	m_pParent = pParent;

	if( rect )
	{
		RECT tempRect;
		m_pParent->GetWindowRect( &tempRect );
				
		m_rcTrack = *rect;
		m_rcSecondPane = m_rcFirstPane = m_rcTrack;

		m_rcFirstPane.left = 0;
		m_rcFirstPane.right = m_rcTrack.left-1;
		m_rcSecondPane.left = m_rcTrack.right+1;
		m_rcSecondPane.right = tempRect.right;

		m_nWidth = rect->right-rect->left;
		ASSERT( m_nWidth > 0 );
	}

	// Create our splitter class
	WNDCLASS wc;

	ZeroMemory( &wc, sizeof(wc) );
	wc.lpszClassName = "DittoSplitterClass";
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = ::DefWindowProc;
	wc.hInstance     = AfxGetInstanceHandle();
	wc.hCursor       = theApp.LoadCursor( MAKEINTRESOURCE(IDC_SPLITTER) );
	wc.hbrBackground = (HBRUSH)( COLOR_BTNFACE + 1 );

	// Register our splitter class
	AfxRegisterClass( &wc );

	// Create our splitter
	return CWnd::Create( wc.lpszClassName, "", WS_VISIBLE | WS_CHILD, 
						 m_rcTrack, pParent, IDC_SPLITTER );
}

//*****************************************************************************
void CSplitter::OnPaint()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	RECT rc;

	// Make sure Splitter bar and panes are updated when
	// the parent resizes.
	m_pParent->GetClientRect( &rc );
	m_rcTrack.bottom = rc.bottom;

	MoveWindow( &m_rcTrack, FALSE );

	// Resize First Pane
	m_rcFirstPane.right = m_rcTrack.left;
	m_rcFirstPane.bottom = m_rcTrack.bottom;

	// Resize Second Pane
	m_rcSecondPane.left = m_rcTrack.right;
	m_rcSecondPane.bottom = m_rcTrack.bottom;
	m_rcSecondPane.right = rc.right;

	// Resize First Pane
	m_pFirstPane->MoveWindow( &m_rcFirstPane );

	// Resize Second Pane Window
	m_pSecondPane->MoveWindow( &m_rcSecondPane );

	// Paint Scroll Bar
	CPaintDC dc( this );
	GetClientRect( &rc );
	dc.Draw3dRect( &rc, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW));
}

//*****************************************************************************
void CSplitter::OnLButtonDown( UINT /*nFlags*/, CPoint /*point*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent != NULL );

	// Capture the mouse
	SetCapture();

	// Set our initial splitter position in our main frame's client coordinates
	GetWindowRect( &m_rcTrack );
	m_pParent->ScreenToClient( &m_rcTrack );
	//m_rcTrack.top++; m_rcTrack.bottom--; m_rcTrack.right--;

	// Set our tracking flag
	m_fTracking = TRUE;

	// Draw our initial tracker
	InvertTracker();
}

//*****************************************************************************
void CSplitter::OnLButtonUp(UINT /*nFlags*/, CPoint /*point*/)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent != NULL );
	BOOL fWasTracking = m_fTracking;

	OnEndCapture();
	
	if(fWasTracking)
	{
		RECT rect;
		m_pParent->GetClientRect( &rect );
		static_cast<CAudioPathCtrl*>(m_pParent)->EndTrack( m_rcTrack.left );

		MoveWindow(	&m_rcTrack );
		OnPaint();
	}
}

//*****************************************************************************
void CSplitter::OnMouseMove( UINT /*nFlags*/, CPoint point )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fTracking )
	{
		// Convert out point to client coordinates of our frame
		ClientToScreen( &point );
		m_pParent->ScreenToClient( &point );

		// Get the client are of our frame
		CRect rcClient;
		m_pParent->GetClientRect( &rcClient );

		// Force the point to be in our client area
		if( (point.x + 34) > rcClient.right )
		{
			point.x = rcClient.right - 34;
		}
		if( (point.x - 31) < rcClient.left )
		{
			point.x = rcClient.left + 31;
		}

		// If the point has changed since the last mouse move, then update change
		if( m_rcTrack.left != (point.x - 1) )
		{
			InvertTracker();
//			if(point.x < CPersonalityCtrl::MinSplitterXPos)
//			{
//				point.x = CPersonalityCtrl::MinSplitterXPos;
//			}
			m_rcTrack.left  = point.x - (m_nWidth>>1);
			m_rcTrack.right = point.x + (m_nWidth>>1);
			m_rcTrack.bottom = rcClient.bottom;
			InvertTracker();
		}
	}
}

//*****************************************************************************
void CSplitter::OnCancelMode()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OnEndCapture();
	CWnd::OnCancelMode();
}

//*****************************************************************************
void CSplitter::OnCaptureChanged( CWnd *pWnd )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OnEndCapture();
	CWnd::OnCaptureChanged( pWnd );
}

//*****************************************************************************
void CSplitter::OnEndCapture()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fVisible )
	{
		InvertTracker();
	}

	if( m_fTracking )
	{
		ReleaseCapture();
		m_fTracking = FALSE;
	}
}

//*****************************************************************************
void CSplitter::InvertTracker()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent );

	// Get the DC of our main frame
	CDC *pDC = m_pParent->GetParent()->GetDC();

	ASSERT( pDC );

	CRgn rgnNew, rgnOrig;
	rgnOrig.CreateRectRgn( 0, 0, 1, 1 );
	RECT rect;
	m_pParent->GetClientRect( &rect );
	rgnNew.CreateRectRgn( rect.left, rect.top, rect.right, rect.bottom );
	::GetClipRgn( pDC->GetSafeHdc(), rgnOrig );
	pDC->SelectClipRgn( &rgnNew, RGN_COPY );

	pDC->GetClipBox( &rect );

	// Create our inverted brush pattern (looks just like frame window sizing)
	CBrush *pBrush = CDC::GetHalftoneBrush();

	// Select the brush into our DC  
	HBRUSH hBrushStock = NULL;
	if( pBrush != NULL )
	{
		hBrushStock = (HBRUSH)SelectObject( pDC->m_hDC, pBrush->m_hObject );
	}

	// Draw our tracking line
	pDC->PatBlt( m_rcTrack.left, m_rcTrack.top, m_rcTrack.Width(), m_rcTrack.Height(), PATINVERT );

	// Free our brush and DC
	if (hBrushStock != NULL)
	{
		SelectObject( pDC->m_hDC, hBrushStock );
	}
	pDC->SelectClipRgn( &rgnOrig );
	ReleaseDC( pDC );

	// Toggle visible flag
	m_fVisible = !m_fVisible;

	rgnNew.DeleteObject();
	rgnOrig.DeleteObject();
}

BOOL CSplitter::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (pWnd == this)?CWnd::OnSetCursor(pWnd, nHitTest, message):FALSE;
}

RECT CSplitter::GetFirstPaneRect()
{	
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_rcFirstPane;
}

RECT CSplitter::GetSecondPaneRect()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_rcSecondPane;
}

void CSplitter::SetFirstPane( CWnd *pPane )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pFirstPane = pPane;
}

void CSplitter::SetSecondPane( CWnd *pPane )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pSecondPane = pPane;
}



void CSplitter::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	
	// TODO: Add your message handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AudioPathDesignerDLL.rc
//
#define IDI_ABOUTDLL                    1
#define IDS_AUDIOPATH                   2
#define IDD_ABOUTBOX_AUDIOPATH          2
#define IDB_AUDIOPATH                   2
#define IDS_AUDIOPATH_PPG               3
#define IDD_DLG_AUDIOPATH               101
#define IDD_OLE_PROPPAGE_LARGE          105
#define IDS_AUDIOPATH_PPG_CAPTION       200
#define IDS_AUDIOPATH_COMPONENT_NAME    201
#define IDC_LIST_CHANNEL                201
#define IDS_HELP_FILE_EXT               202
#define IDS_ERR_INVALIDARG              203
#define IDC_EDIT_PCHANNEL               203
#define IDR_AUDIOPATH_DOCTYPE           204
#define IDC_BUTTON_ADD                  204
#define IDI_AUDIOPATH_DOCTYPE_SEL       205
#define IDS_ERR_REGISTER_CF             205
#define IDM_AUDIOPATH_NODE_RMENU        205
#define IDC_BTN_REMOVE                  205
#define IDI_AUDIOPATHREF                206
#define IDS_ERR_ADD_CLIPFORMAT          206
#define IDC_EDIT_MIXGROUP_NAME          206
#define IDC_SPIN_PCHANNEL               206
#define IDI_AUDIOPATHREF_SEL            207
#define IDS_ERR_ADD_IMAGELIST           207
#define IDM_PCHANNELTREE_RMENU          207
#define IDC_EDIT_CUSTOMNAME             207
#define IDC_EDIT_PCHANNEL_NAME          207
#define IDS_ERR_MEMORY                  208
#define IDD_DLG_ADD_PCHANNEL            208
#define IDC_BUTTON_EDIT_PROPERTIES      208
#define IDS_ERR_ADD_DOCTYPE             209
#define IDM_EFFECTLIST_RMENU            209
#define IDC_CHECK_HARDWARE              209
#define IDS_ERR_MISSING_CONDUCTOR       210
#define IDC_CHECK_SOFTWARE              210
#define IDS_AUDIOPATH_TEXT              211
#define IDM_AUDIOBUS_RMENU              211
#define IDC_CHECK_OPTIONAL              211
#define IDS_AUDIOPATH_VERSION_TEXT      212
#define IDS_NO_AUDIOPATH                213
#define IDD_DLG_EFFECTLIST              213
#define IDS_UNDO_AUDIOPATH_NAME         214
#define IDD_DLG_INSERT_EFFECT           214
#define IDS_UNDO_AUDIOPATH_GUID         215
#define IDD_DLG_SYNTH                   215
#define IDD_TAB_BUFFER                  216
#define IDS_ZERO_BUSES                  216
#define IDS_UNDO                        217
#define IDR_AUDIOPATH_ACCELS            217
#define IDS_UNDO_ACCEL                  218
#define IDS_REDO                        219
#define IDC_CHECK_MUTE3DATMAXDISTANCE   219
#define IDS_REDO_ACCEL                  220
#define IDS_ERR_MISSING_DX8             221
#define IDC_FILE_VERSION                222
#define IDS_UNDO_AUDIOPATH_AUTHOR       222
#define IDS_UNDO_AUDIOPATH_COPYRIGHT    223
#define IDS_UNDO_AUDIOPATH_SUBJECT      224
#define IDC_AUTHOR                      225
#define IDS_UNDO_AUDIOPATH_VERSION      225
#define IDC_COMBO_3DAlg                 225
#define IDC_COPYRIGHT                   226
#define IDS_AUDIOPATH_OBJECT_TEXT       226
#define IDC_EDIT_TYPE                   226
#define IDC_VERSION_1                   227
#define IDS_DEFAULT_MIXGROUP_NAME       227
#define IDC_VERSION_2                   228
#define IDS_DEFAULT_PORT_CUSTOMNAME     228
#define IDC_BUTTON_SYNTH                228
#define IDC_VERSION_3                   229
#define IDS_UNDO_DROP_PCHANNELS         229
#define IDC_COMBO_EFFECT                229
#define IDC_VERSION_4                   230
#define IDD_TAB_AUDIOPATH_AUDIOPATH     230
#define IDS_UNDO_DROP_EFFECTS           230
#define IDC_EDIT_INSTANCE               230
#define IDC_NAME                        231
#define IDC_SUBJECT                     231
#define IDS_UNDO_INSERT_PCHANNELS       231
#define IDC_EDIT_SYNTH_NAME             231
#define IDS_UNDO_CUT_PCHANNELS          232
#define IDS_UNDO_DELETE_PCHANNELS       233
#define IDS_UNDO_INSERT_MIXGROUP        234
#define IDC_EDIT_CHANNELS               234
#define IDS_UNDO_EFFECT_NAME            235
#define IDC_SPIN_CHANNELS               235
#define IDS_UNDO_EFFECT_FLAGS           236
#define IDC_CHECK_SHARE                 236
#define IDR_AUDIOPATH_EDITOR            237
#define IDS_UNDO_EFFECT_DATA            237
#define IDC_CHECK_PREDEFINED            237
#define IDS_UNDO_MIXGROUP_NAME          238
#define IDS_UNDO_MIXGROUP_SYNTH         239
#define IDC_COMBO_STANDARD_BUFFER       239
#define IDS_INSERT_EFFECT_LIST          240
#define IDC_BUTTON_GUID                 240
#define IDS_UNDO_INSERT_EFFECT          241
#define IDC_CHECK_REVERB                241
#define IDM_AUDIOPATHREF_NODE_RMENU     242
#define IDS_EFFECTLIST_EFFECT_TYPE      242
#define IDC_CHECK_CHORUS                242
#define IDC_SPLITTER                    243
#define IDS_EFFECTLIST_INSTANCE_NAME    243
#define IDC_BUTTON_ADD16                243
#define IDM_AUDIOPATH_DOCROOT_RMENU     243
#define IDS_EFFECT_TEXT                 243
#define IDD_DLG_GUID                    244
#define IDS_DEFAULT_SYNTH_NAME          244
#define IDM_EFFECTPALETTE_RMENU         244
#define IDD_TAB_AUDIOPATH_INFO          245
#define IDS_UNKNOWN_SYNTH_NAME          245
#define IDD_TAB_EFFECT                  246
#define IDS_UNDO_ADDREMOVE_PCHANNELS    246
#define IDD_TAB_MIXGROUP                247
#define IDS_ERR_EFFECT_INUSE            247
#define IDS_ERR_EFFECT_DEFAULT_DELETE   248
#define IDS_UNDO_DEFAULT_SAMPLERATE     249
#define IDS_UNDO_STANDARD_BUFFER_TYPE   250
#define IDS_UNDO_BUFFER_SETTINGS        251
#define IDC_CHECK_DOWNLOAD_GM           251
#define IDS_BUFFER_REVERB               252
#define IDS_BUFFER_ENVREVERB            253
#define IDS_BUFFER_MONO                 255
#define IDS_BUFFER_STEREO               256
#define IDS_UNDO_DELETE_EFFECT          257
#define IDS_3DALG_DEFAULT               258
#define IDS_3DALG_NO_VIRTUALIZATION     259
#define IDS_3DALG_HRTF_FULL             260
#define IDS_3DALG_HRTF_LIGHT            261
#define IDS_UNDO_BUFFER_3DALGORITHM     262
#define IDS_ERR_MISSING_TOOLGRAPH_DESIGNER 263
#define IDS_UNDO_BUFFER_3DPOSITION      264
#define IDS_UNDO_INSERT_BUFFER          265
#define IDS_UNDO_DELETE_BUFFER          266
#define IDS_UNDO_ADDREMOVE_BUSES        267
#define IDS_BUFFER_3D_DRY               268
#define IDS_PPG_BUFFER_ENV_REVERB       269
#define IDS_PPG_BUFFER_REVERB           270
#define IDS_PPG_BUFFER_3D_DRY           272
#define IDS_PPG_BUFFER_MONO             273
#define IDS_PPG_BUFFER_STEREO           274
#define IDS_UNDO_BUFFER_CHANNELS        275
#define IDS_UNDO_BUFFER_GUID            276
#define IDS_BUFFER_UNSUPPORTED          277
#define IDS_ERR_CANT_EDIT_SYNTH         278
#define IDS_TOOLGRAPH_TEXT              279
#define IDS_MIXGROUP_COLUMN             280
#define IDS_BUFFER_COLUMN               281
#define IDS_BUS_COLUMN                  282
#define IDS_EFFECTS_COLUMN              283
#define IDS_DEFAULT_PORT                284
#define IDS_APATH_MUSIC                 285
#define IDS_APATH_ENV                   287
#define IDS_MIXGROUP_TEXT               287
#define IDS_SEND_EXTENAL                288
#define IDS_APATH_3D_DRY                289
#define IDS_APATH_MONO                  290
#define IDS_APATH_STEREO                291
#define IDS_UNDO_EFFECT_SEND            292
#define IDS_SEND_OTHER                  293
#define IDS_SEND_TEXT                   294
#define IDS_UNDO_BUFFER_PAN             295
#define IDS_UNDO_BUFFER_VOLUME          296
#define IDS_BUFFER_TEXT                 297
#define IDS_PAN_LEFT                    298
#define IDS_PAN_RIGHT                   299
#define IDS_PAN_MID                     300
#define IDS_MINUS_TEXT                  301
#define IDC_EDIT_GUID                   305
#define IDC_NEW_GUID                    306
#define IDM_NEW_TOOLGRAPH               307
#define IDD_DLG_ADD_BUSES               309
#define IDD_DLG_3D_POS                  311
#define IDD_NEW_AUDIOPATH               313
#define IDD_DLG_SEND_PROPERTIES         315
#define IDC_LIST_BUS_AVAILBLE           523
#define IDC_BUTTON_REMOVE               527
#define IDC_BUTTON_RESET                528
#define IDC_LIST_BUS_INUSE              529
#define IDC_BUTTON_UP                   530
#define IDC_BUTTON_DOWN                 531
#define ID_STATIC_SYNTH                 533
#define IDC_BUTTON_3D_POS               535
#define IDC_EDIT_CONE_INSIDE            537
#define IDC_EDIT_CONE_OUTSIDE           538
#define IDC_EDIT_CONE_VOLUME            539
#define IDC_EDIT_MIN_DISTANCE           540
#define IDC_EDIT_MAX_DISTANCE           541
#define IDC_COMBO_MODE                  543
#define IDC_RADIO_LOCALFOCUS            545
#define IDC_RADIO_STICKYFOCUS           546
#define IDC_RADIO_GLOBALFOCUS           547
#define IDC_TREE_HEADER                 548
#define IDC_NEW_AUDIOPATH               549
#define IDC_EXISTING_AUDIOPATH          550
#define IDC_AUDIOPATH_LIST              551
#define IDC_COMBO_SEND                  552
#define IDC_BUTTON_SEND_GUID            553
#define IDC_STATIC_SEND                 554
#define IDC_TAB1                        556
#define IDC_EDIT_VOLUME                 557
#define IDC_EDIT_PAN                    558
#define IDC_RADIO_PAN                   560
#define IDC_RADIO_CTRL3D                561
#define IDC_SPIN_PAN                    562
#define IDC_SPIN_VOLUME                 563
#define IDC_CHECK_DOPPLER               564
#define IDC_TREE_PCHANNELS              1000
#define IDC_SLIDER_XPOS                 1004
#define IDC_SLIDER_YPOS                 1005
#define IDC_SLIDER_ZPOS                 1006
#define IDC_EDIT_XPOS                   1007
#define IDC_EDIT_YPOS                   1008
#define IDC_EDIT_ZPOS                   1009
#define IDC_SLIDER_XVEL                 1010
#define IDC_COMBO_SYNTH                 1011
#define IDC_SLIDER_YVEL                 1011
#define IDC_SLIDER_ZVEL                 1012
#define IDC_EDIT_XVEL                   1013
#define IDC_LIST_EFFECTS                1014
#define IDC_EDIT_YVEL                   1014
#define IDC_EDIT_ZVEL                   1015
#define IDC_SLIDER_XCONE                1016
#define IDC_SLIDER_YCONE                1017
#define IDC_SLIDER_ZCONE                1018
#define IDC_EDIT_XCONE                  1019
#define IDC_EDIT_YCONE                  1020
#define IDC_EDIT_ZCONE                  1021
#define IDC_11                          1133
#define IDC_22                          1134
#define IDC_44                          1135
#define IDC_EDIT_VOICES                 1150
#define IDC_SPIN_VOICES                 1151
#define IDC_48                          1156
#define IDS_BUSID_REV_STEREO            1993
#define IDS_BUFFER_NONE                 1994
#define IDS_BUSID_STANDARD              1995
#define IDS_BUSID_USER_BUFFER           1996
#define IDS_BUFFER_USER_DEFINED         1996
#define IDS_BUSID_MULTIPLE              1997
#define IDS_BUSID_STEREO                1998
#define IDS_BUSID_NONE                  1999
#define IDS_BUSID0                      2000
#define IDS_BUSID1                      2001
#define IDS_BUSID2                      2002
#define IDS_BUSID3                      2003
#define IDS_BUSID4                      2004
#define IDS_BUSID5                      2005
#define IDS_BUSID6                      2006
#define IDS_BUSID7                      2007
#define IDS_BUSID8                      2008
#define IDS_BUSID9                      2009
#define IDS_BUSID10                     2010
#define IDS_BUSID11                     2011
#define IDS_BUSID12                     2012
#define IDS_BUSID13                     2013
#define IDS_BUSID14                     2014
#define IDS_BUSID15                     2015
#define IDS_BUSID16                     2016
#define IDS_BUSID17                     2017
#define IDS_BUSID64                     2064
#define IDS_BUSID65                     2065
#define IDS_BUSID512                    2512
#define IDS_BUSID513                    2513
#define IDM_PROPERTIES                  32768
#define IDM_RENAME                      32769
#define ID_EDIT_INSERT_MIX              32770
#define ID_EDIT_INSERT_MIXGROUP         32771
#define ID_AUDIOBUS_SPLIT               32772
#define ID_SYNTH_CREATE                 32773
#define ID_EDIT_EFFECT_CUT              32774
#define ID_EDIT_EFFECT_COPY             32775
#define ID_EDIT_EFFECT_PASTE            32776
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_EFFECT_INSERT           32778
#define ID_EDIT_EFFECT_DELETE           32779
#define ID_EDIT_EFFECT_SELECT_ALL       32780
#define ID_EDIT_EFFECT_PROPERTIES       32781
#define ID_EDIT_MIXGROUP_PROPERTIES     32782
#define ID_AUDIOBUS_STEREO              32783
#define ID_AUDIOBUS_LEFT                32784
#define ID_AUDIOBUS_RIGHT               32785
#define ID_AUDIOBUS_FX                  32786
#define ID_AUDIOBUS_FRONT_CENTER        32787
#define ID_AUDIOBUS_LOW_FREQ            32788
#define ID_AUDIOBUS_BACK_LEFT           32789
#define ID_AUDIOBUS_BACK_RIGHT          32790
#define ID_AUDIOBUS_REVERB              32791
#define ID_AUDIOBUS_CHORUS              32792
#define ID_AUDIOBUS_LEFT_CENTER         32793
#define ID_AUDIOBUS_RIGHT_CENTER        32794
#define ID_AUDIOBUS_BACK_CENTER         32795
#define ID_AUDIOBUS_SIDE_LEFT           32796
#define ID_AUDIOBUS_SIDE_RIGHT          32797
#define ID_AUDIOBUS_TOP_CENTER          32798
#define ID_AUDIOBUS_TOP_FRONT_LEFT      32799
#define ID_AUDIOBUS_TOP_FRONT_CENTER    32800
#define ID_AUDIOBUS_TOP_FRONT_RIGHT     32801
#define ID_AUDIOBUS_TOP_BACK_LEFT       32802
#define ID_AUDIOBUS_TOP_BACK_RIGHT      32803
#define ID_AUDIOBUS_TOP_BACK_CENTER     32804
#define ID_EDIT_BUS_ADDREMOVE           32805
#define ID_EDIT_INSERT_ENV_REVERB       32806
#define ID_EDIT_SEND_EFFECT_INSERT      32807
#define ID_EDIT_BUS_PROPERTIES          32890
#define ID_EDIT_BUFFER_INSERT           32891
#define ID_EDIT_BUFFER_DELETE           32892
#define ID_EDIT_INSERT                  32893
#define IDM_HELP_FINDER                 32900
#define IDM_CUT                         32901
#define IDM_COPY                        32902
#define IDM_PASTE                       32903
#define IDM_DELETE                      32904

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        317
#define _APS_NEXT_COMMAND_VALUE         32808
#define _APS_NEXT_CONTROL_VALUE         565
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\MixGroupPPGMgr.cpp ===
// MixGroupPPGMgr.cpp : implementation file
//

#include "stdafx.h"
#include "MixGroupPPGMgr.h"
#include "TabMixGroup.h"
#include "ItemInfo.h"
#include "AudioPath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

short CMixGroupPPGMgr::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMixGroupPPGMgr::CMixGroupPPGMgr( ) : CDllBasePropPageManager()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_GUIDManager	= GUID_MixGroupPPGMgr;

	m_pTabMixGroup= NULL;
}

CMixGroupPPGMgr::~CMixGroupPPGMgr()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pTabMixGroup)
	{
		delete m_pTabMixGroup;
		m_pTabMixGroup = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CMixGroupPPGMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((pbstrTitle == NULL)
	|| (pfAddPropertiesText == NULL))
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_MIXGROUP_TEXT );

	MixGroupInfoForPPG mixGroupInfoForPPG;

	// Nothing is constructed in the call to GetData, so we don't need to worry
	// about cleaning up any memory
	if(m_pIPropPageObject
	&& SUCCEEDED(m_pIPropPageObject->GetData((void **)&mixGroupInfoForPPG)) )
	{
		if( mixGroupInfoForPPG.m_fValid
		&&	!mixGroupInfoForPPG.m_strMixGroupName.IsEmpty() )
		{
			strTitle = mixGroupInfoForPPG.m_strMixGroupName + _T(" ") + strTitle;
		}
		if( !mixGroupInfoForPPG.m_strAudioPathName.IsEmpty() )
		{
			strTitle = mixGroupInfoForPPG.m_strAudioPathName + _T(" - ") + strTitle;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CMixGroupPPGMgr::GetPropertySheetPages(IDMUSProdPropSheet *pIPropSheet, LONG *hPropSheetPage[], short *pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((hPropSheetPage == NULL)
	|| (pnNbrPages == NULL))
	{
		return E_POINTER;
	}

	if(pIPropSheet == NULL)
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Segment tab
	if( m_pTabMixGroup == NULL )
	{
		m_pTabMixGroup = new CTabMixGroup();
	}
	if(m_pTabMixGroup)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pTabMixGroup->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *) hPage;
			nNbrPages++;
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CMixGroupPPGMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	if(m_pIPropSheet)
	{
		m_pIPropSheet->GetActivePage( &CMixGroupPPGMgr::sm_nActiveTab );
	}

	HRESULT hr = CBasePropPageManager::OnRemoveFromPropertySheet();

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	RefreshData();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr IDMUSProdPropPageManager::RefreshData

HRESULT CMixGroupPPGMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pTabMixGroup == NULL)
	{
		return S_OK;
	}

	// Try and get the information for the selected Mix Group
	MixGroupInfoForPPG mixGroupInfoForPPG;
	if( (m_pIPropPageObject == NULL)
	||	FAILED(m_pIPropPageObject->GetData((void **)&mixGroupInfoForPPG)) )
	{
		m_pTabMixGroup->SetItem( NULL, NULL );

		return S_OK;
	}

	// Make sure changes to current effect are processed in OnKillFocus
	// messages before setting the new effect
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabMixGroup->GetSafeHwnd() ? m_pTabMixGroup->GetParent() : NULL;

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	m_pTabMixGroup->SetItem( &mixGroupInfoForPPG, m_pIPropPageObject );

	// Restore focus
	if( pWndHadFocus
	&&	pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr IDMUSProdPropPageManager::SetObject

HRESULT CMixGroupPPGMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr IDMUSProdPropPageManager::RemoveObject

HRESULT CMixGroupPPGMgr::RemoveObject( IDMUSProdPropPageObject *pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = CDllBasePropPageManager::RemoveObject(pIPropPageObject);
	if(SUCCEEDED(hr))
	{
		if(m_pTabMixGroup)
		{
			m_pTabMixGroup->SetItem( NULL, NULL );
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\MixGroupPPGMgr.h ===
#if !defined(AFX_MIXGROUPPPGMGR_H__3AAC415E_7096_49B6_AAE4_7FA2DAFD39D6__INCLUDED_)
#define AFX_MIXGROUPPPGMGR_H__3AAC415E_7096_49B6_AAE4_7FA2DAFD39D6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MixGroupPPGMgr.h : header file
//

#include <DMUSProd.h>
#include "DllBasePropPageManager.h"
#include "PPGItemBase.h"
#include "ItemInfo.h"

// {1D3748D4-80CC-45e8-AACB-BC6BC9142869}
static const GUID GUID_MixGroupPPGMgr = 
{ 0x1d3748d4, 0x80cc, 0x45e8, { 0xaa, 0xcb, 0xbc, 0x6b, 0xc9, 0x14, 0x28, 0x69 } };

#define CH_MIXGROUP_NAME			0x00000001
#define CH_MIXGROUP_SYNTH			0x00000002
#define CH_MIXGROUP_SYNTH_SETTINGS	0x00000004

#define MGI_HAS_SYNTH				0x00000001
#define MGI_CAN_EDIT_SYNTH			0x00000002
#define MGI_DONT_EDIT_NAME			0x00000004

struct MixGroupInfoForPPG : public PPGItemBase
{
	MixGroupInfoForPPG() : PPGItemBase()
	{
		m_ppgIndex = PPG_MIX_GROUP;
		m_dwFlags = 0;
	}
	void Copy( const MixGroupInfoForPPG &mixGroupInfoForPPG )
	{
		PPGItemBase::Copy( mixGroupInfoForPPG );
		m_strMixGroupName = mixGroupInfoForPPG.m_strMixGroupName;
		m_PortOptions.Copy( &mixGroupInfoForPPG.m_PortOptions );
		m_dwFlags = mixGroupInfoForPPG.m_dwFlags;
	}
	CString		m_strMixGroupName;
	PortOptions	m_PortOptions;
	DWORD		m_dwFlags;

};

/////////////////////////////////////////////////////////////////////////////
// CMixGroupPPGMgr

class CMixGroupPPGMgr : public CDllBasePropPageManager
{
friend class CTabMixGroup;

public:
	CMixGroupPPGMgr();
	virtual ~CMixGroupPPGMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
	HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	CTabMixGroup	*m_pTabMixGroup;

public:
	static short	sm_nActiveTab;
};

#endif // !defined(AFX_MIXGROUPPPGMGR_H__3AAC415E_7096_49B6_AAE4_7FA2DAFD39D6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\MultiTree.h ===
#if !defined(AFX_MLTITREE_H__9F4750E5_C512_11D2_880A_02608C7CB3EE__INCLUDED_)
#define AFX_MLTITREE_H__9F4750E5_C512_11D2_880A_02608C7CB3EE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MltiTree.h : header file
// Original code Copyright (c) 1999 Richard Hazlewood
// This code is provided as-is.  Use at your own peril.
// Modifications Copyright 1999-2001 Microsoft Corp.

#include "ItemInfo.h"

#ifndef RELEASE
#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0
#endif
/////////////////////////////////////////////////////////////////////////////

typedef CTypedPtrList<CPtrList, ItemInfo *> CItemList;
class CAudioPathDlg;
class CEditLabel;
struct BusEffectInfo;

typedef enum { NONE_COL = 0, PCHANNEL_COL = 1, BUS_BUFFER_COL = 2, EFFECT_COL = 3 } TreeColumn;

struct ItemInfoWrapper
{
	ItemInfoWrapper( ItemInfo *pNewItemInfo, BufferOptions *pNewBufferOptions )
	{
		pItemInfo = pNewItemInfo;
		pBufferOptions = pNewBufferOptions;
	}
	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiTree window

#ifndef MST_AFX_EXT_CLASS
#define MST_AFX_EXT_CLASS
//define this if building class for DLL export/import
// typically: #define MST_AFX_EXT_CLASS AFX_EXT_CLASS
#endif

class MST_AFX_EXT_CLASS CMultiTree :
	public CListCtrl /*,
	public IDropSource,
	public IDropTarget*/
{
friend class CAudioPathDlg;
	DECLARE_DYNAMIC(CMultiTree)
// Construction
public:
	CMultiTree();
	virtual ~CMultiTree();


// Attributes
public:
	POINT		m_pointPopUpMenu;
	CAudioPathDlg *m_pAudioPathDlg;

// Operations
public:
	void SelectAll( void );	//doesn't affect focus
	void UnselectAll( void );
	void InvalidateItem( ItemInfo *pItemInfo );
	void InvalidateItem( int nItem );

	ItemInfo *GetFirstSelectedMixGroupItem() const;
	TreeColumn GetFirstSelectedThing( ItemInfo **ppItemInfo, BufferOptions **ppBufferOptions, BusEffectInfo **ppBusEffectInfo ) const;
	void SetDMAudioPathDlg( CAudioPathDlg *pDMAudioPathDlg );

	HRESULT	CreateDataObject( IDataObject** ppIDataObject );
	bool IsSelected(int nItem) const {return !!(LVIS_SELECTED & CListCtrl::GetItemState(nItem, LVIS_SELECTED));};
	void SelectItem( ItemInfo *pItemInfo );

	void GetSelectedList(CItemList& list) const;

	void GetEffectRect( const POINT &point, int nItem, BusEffectInfo **ppBusEffectInfo, RECT *pRect );
	TreeColumn GetItemBufferEffectUnderPoint( const POINT &point, ItemInfo **ppItem, BufferOptions **ppBufferOptions, BusEffectInfo **ppBusEffectInfo );
	TreeColumn GetThingUnderPointAndItem( const POINT &point, int nTreeItem, void **ppThing );
	TreeColumn GetColumn( long lXPos );
	BOOL GetColumn( int nCol, LVCOLUMN* pColumn ) const {return CListCtrl::GetColumn( nCol, pColumn );};

	/*
	void GetItemAndEffectRect( const POINT &point, ItemInfo **ppItem, BusEffectInfo **ppBusEffectInfo, RECT *pRect );
	TreeColumn GetItemAndThingUnderPoint( const POINT &point, ItemInfo **ppItem, void **ppThing );
	*/

	ItemInfo *GetItemInfo( int nItem ) const;

	void DisplayPPGForFirstSelectedThing( void );

protected:
	CEditLabel	*m_pEditCtrl;

protected:
	void OnButtonDown(BOOL bLeft, UINT nFlags, CPoint point);
	/*
	//void DoPreSelection(int nItem, BOOL bLeft, UINT nFlags);
	//void DoAction(int nItem, BOOL bLeft, UINT nFlags, CPoint point, bool fEditInPlace);
	//void DoBanding(BOOL bLeft, UINT nFlags, CPoint point);
	void DoNothingForMousePress(BOOL bLeft);
	void UpdateSelectionForRect(LPCRECT pRect, UINT nFlags, CTreeItemList& list);
	void SelectAllIgnore(BOOL bSelect, HTREEITEM hIgnore);
	void SelectItemIfUnselected( int nItem, DWORD dwState );
	*/
	void OnButtonDownOnItemRight(int nItem, UINT nFlags, CPoint point);
	void UnselectAllSubFields( void );
	void DoDelete( void );

// Edit helper functions
	HRESULT	CreateDataObjectEffect( IDataObject** ppIDataObject );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMultiTree)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CMultiTree)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnEditPChannelCopy();
	afx_msg void OnEditPChannelCut();
	afx_msg void OnEditPChannelDelete();
	afx_msg void OnEditPChannelInsert();
	afx_msg void OnEditPChannelPaste();
	afx_msg void OnEditPChannelSelectAll();
	afx_msg void OnEditInsertMixGroup();
	afx_msg void OnEditMixGroupProperties();
	afx_msg void OnEditEffectCopy();
	afx_msg void OnEditEffectCut();
	afx_msg void OnEditEffectDelete();
	afx_msg void OnEditEffectInsert();
	afx_msg void OnEditEffectInsertSend();
	afx_msg void OnEditEffectPaste();
	afx_msg void OnEditEffectSelectAll();
	afx_msg void OnEditEffectProperties();
	afx_msg void OnEditBusProperties();
	afx_msg void OnEditBufferInsert();
	afx_msg void OnEditBufferDelete();
	afx_msg void OnEditBusAddRemove();
	afx_msg void OnEditInsertEnvReverb();
	afx_msg void OnBeginlabeledit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CEditLabel window

class CEditLabel : public CEdit
{
// Construction
public:
	CEditLabel( CString strOrigName );

// Attributes
protected:
	CString		m_strOrigName;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditLabel)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditLabel();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditLabel)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MLTITREE_H__9F4750E5_C512_11D2_880A_02608C7CB3EE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabAudioPathInfo.cpp ===
// TabAudioPathInfo.cpp : implementation file
//

#include "stdafx.h"
#include "TabAudioPathInfo.h"
#include "AudioPathDesignerDll.h"
#include "AudioPath.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo property page

CTabAudioPathInfo::CTabAudioPathInfo( CAudioPathPropPageManager* pAudioPathPropPageManager ) : CPropertyPage(CTabAudioPathInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabAudioPathInfo)
	//}}AFX_DATA_INIT
	
	ASSERT( pAudioPathPropPageManager != NULL );

	m_pAudioPath = NULL;
	m_pPageManager = pAudioPathPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabAudioPathInfo::~CTabAudioPathInfo()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::SetAudioPath

void CTabAudioPathInfo::SetAudioPath( CDirectMusicAudioPath* pAudioPath )
{
	m_pAudioPath = pAudioPath;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::SetModifiedFlag

void CTabAudioPathInfo::SetModifiedFlag( void ) 
{
	ASSERT( m_pAudioPath != NULL );

	m_pAudioPath->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::EnableControls

void CTabAudioPathInfo::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::UpdateControls

void CTabAudioPathInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pAudioPath )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pAudioPath->m_strAuthor );
		m_editCopyright.SetWindowText( m_pAudioPath->m_strCopyright );
		m_editSubject.SetWindowText( m_pAudioPath->m_strSubject );
		
		strText.Format( "%u", ((m_pAudioPath->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pAudioPath->m_vVersion.dwVersionMS & 0x0000FFFF) );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pAudioPath->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pAudioPath->m_vVersion.dwVersionLS & 0x0000FFFF) );
		m_editVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editSubject.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabAudioPathInfo::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabAudioPathInfo)
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabAudioPathInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabAudioPathInfo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnSetActive

BOOL CTabAudioPathInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CAudioPathPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnCreate

int CTabAudioPathInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnDestroy

void CTabAudioPathInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnKillFocusAuthor

void CTabAudioPathInfo::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pAudioPath->m_strAuthor ) != 0 )
		{
			m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_AUTHOR );
			m_pAudioPath->m_strAuthor = strAuthor;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnKillFocusCopyright

void CTabAudioPathInfo::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pAudioPath->m_strCopyright ) != 0 )
		{
			m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_COPYRIGHT );
			m_pAudioPath->m_strCopyright = strCopyright;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnKillFocusSubject

void CTabAudioPathInfo::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pAudioPath->m_strSubject ) != 0 )
		{
			m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_SUBJECT );
			m_pAudioPath->m_strSubject = strSubject;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnKillFocusVersion_1

void CTabAudioPathInfo::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CString strVersion_1;
		CString strAudioPathVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pAudioPath->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strAudioPathVersion_1.Format( "%u", ((m_pAudioPath->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			
			if( strVersion_1.Compare( strAudioPathVersion_1 ) != 0 )
			{
				DWORD dwVersion_1 = _ttoi( strVersion_1 );
				dwVersion_1 = (dwVersion_1 & 0x0000FFFF) << 16;

				m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_VERSION );
				m_pAudioPath->m_vVersion.dwVersionMS &= 0x0000FFFF;
				m_pAudioPath->m_vVersion.dwVersionMS |= dwVersion_1;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnKillFocusVersion_2

void CTabAudioPathInfo::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CString strVersion_2;
		CString strAudioPathVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pAudioPath->m_vVersion.dwVersionMS & 0x0000FFFF) );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strAudioPathVersion_2.Format( "%u", (m_pAudioPath->m_vVersion.dwVersionMS & 0x0000FFFF) );
			
			if( strVersion_2.Compare( strAudioPathVersion_2 ) != 0 )
			{
				DWORD dwVersion_2 = _ttoi( strVersion_2 );
				dwVersion_2 &= 0x0000FFFF;

				m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_VERSION );
				m_pAudioPath->m_vVersion.dwVersionMS &= 0xFFFF0000;
				m_pAudioPath->m_vVersion.dwVersionMS |= dwVersion_2;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnKillFocusVersion_3

void CTabAudioPathInfo::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CString strVersion_3;
		CString strAudioPathVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pAudioPath->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strAudioPathVersion_3.Format( "%u", ((m_pAudioPath->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			
			if( strVersion_3.Compare( strAudioPathVersion_3 ) != 0 )
			{
				DWORD dwVersion_3 = _ttoi( strVersion_3 );
				dwVersion_3 = (dwVersion_3 & 0x0000FFFF) << 16;

				m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_VERSION );
				m_pAudioPath->m_vVersion.dwVersionLS &= 0x0000FFFF;
				m_pAudioPath->m_vVersion.dwVersionLS |= dwVersion_3;

			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnKillFocusVersion_4

void CTabAudioPathInfo::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CString strVersion_4;
		CString strAudioPathVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pAudioPath->m_vVersion.dwVersionLS & 0x0000FFFF) );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strAudioPathVersion_4.Format( "%u", (m_pAudioPath->m_vVersion.dwVersionLS & 0x0000FFFF) );
			
			if( strVersion_4.Compare( strAudioPathVersion_4 ) != 0 )
			{
				DWORD dwVersion_4 = _ttoi( strVersion_4 );
				dwVersion_4 &= 0x0000FFFF;

				m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_VERSION );
				m_pAudioPath->m_vVersion.dwVersionLS &= 0xFFFF0000;
				m_pAudioPath->m_vVersion.dwVersionLS |= dwVersion_4;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo::OnEditGUID

void CTabAudioPathInfo::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		CGuidDlg dlg;

		memcpy( &dlg.m_guid, &m_pAudioPath->m_guidAudioPath, sizeof(GUID) );

		if( dlg.DoModal() == IDOK )
		{
			m_pAudioPath->SaveUndoState( IDS_UNDO_AUDIOPATH_GUID );
			memcpy( &m_pAudioPath->m_guidAudioPath, &dlg.m_guid, sizeof(GUID) );

			// Notify connected nodes that AudioPath GUID has changed
			theApp.m_pAudioPathComponent->m_pIFramework->NotifyNodes( m_pAudioPath, DOCROOT_GuidChange, NULL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabAudioPathAudioPath.cpp ===
// TabAudioPathAudioPath.cpp : implementation file
//

#include "stdafx.h"
#include "TabAudioPathAudioPath.h"
#include "AudioPathDesignerDll.h"
#include "AudioPath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath property page

CTabAudioPathAudioPath::CTabAudioPathAudioPath( CAudioPathPropPageManager* pAudioPathPropPageManager ) : CPropertyPage(CTabAudioPathAudioPath::IDD)
{
	//{{AFX_DATA_INIT(CTabAudioPathAudioPath)
	//}}AFX_DATA_INIT
	
	ASSERT( pAudioPathPropPageManager != NULL );

	m_pAudioPath = NULL;
	m_pPageManager = pAudioPathPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabAudioPathAudioPath::~CTabAudioPathAudioPath()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::SetAudioPath

void CTabAudioPathAudioPath::SetAudioPath( CDirectMusicAudioPath* pAudioPath )
{
	m_pAudioPath = pAudioPath;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::SetModifiedFlag

void CTabAudioPathAudioPath::SetModifiedFlag( void ) 
{
	ASSERT( m_pAudioPath != NULL );

	m_pAudioPath->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::EnableControls

void CTabAudioPathAudioPath::EnableControls( BOOL fEnable ) 
{
	if( fEnable
	&&	m_pAudioPath
	&&	!m_pAudioPath->IsInSegment() )
	{
		m_editName.EnableWindow( TRUE );
	}
	else
	{
		m_editName.EnableWindow( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::UpdateControls

void CTabAudioPathAudioPath::UpdateControls() 
{
	// Make sure controls have been created
	if( (m_pAudioPath == NULL)
	||	(::IsWindow(m_editName.m_hWnd) == FALSE) )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pAudioPath )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pAudioPath->m_strName );
	}
	else
	{
		m_editName.SetWindowText( _T("") );

		EnableControls( FALSE );
	}

	// Set the default sample rate
	/*
	int nID = IDC_22;
	switch( m_pAudioPath->m_dwSampleRate )
	{
	case 11025:
		nID = IDC_11;
		break;
	case 22050:
		// Default
		//nID = IDC_22;
		break;
	case 44100:
		nID = IDC_44;
		break;
	case 48000:
		nID = IDC_48;
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	CheckRadioButton( IDC_11, IDC_48, nID );
	*/
}


void CTabAudioPathAudioPath::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabAudioPathAudioPath)
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabAudioPathAudioPath, CPropertyPage)
	//{{AFX_MSG_MAP(CTabAudioPathAudioPath)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	//ON_BN_CLICKED(IDC_11, On11)
	//ON_BN_CLICKED(IDC_22, On22)
	//ON_BN_CLICKED(IDC_44, On44)
	//ON_BN_CLICKED(IDC_48, On48)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath message handlers


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::OnInitDialog

BOOL CTabAudioPathAudioPath::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::OnSetActive

BOOL CTabAudioPathAudioPath::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CAudioPathPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::OnCreate

int CTabAudioPathAudioPath::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::OnDestroy

void CTabAudioPathAudioPath::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::OnKillFocusName

void CTabAudioPathAudioPath::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pAudioPathComponent != NULL );
	ASSERT( theApp.m_pAudioPathComponent->m_pIFramework != NULL );

	if( m_pAudioPath )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pAudioPath->m_strName );
		}
		else
		{
			if( strName.Compare( m_pAudioPath->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pAudioPath->SetNodeName( bstrName );
				theApp.m_pAudioPathComponent->m_pIFramework->RefreshNode( m_pAudioPath );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath::On11

/*
void CTabAudioPathAudioPath::On11() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		m_pAudioPath->SetSampleRate( 11025 );
	}
}

void CTabAudioPathAudioPath::On22() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		m_pAudioPath->SetSampleRate( 22050 );
	}
}

void CTabAudioPathAudioPath::On44() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		m_pAudioPath->SetSampleRate( 44100 );
	}
}

void CTabAudioPathAudioPath::On48() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pAudioPath )
	{
		m_pAudioPath->SetSampleRate( 48000 );
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabAudioPathAudioPath.h ===
#if !defined(AFX_TABAUDIOPATHAUDIOPATH_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABAUDIOPATHAUDIOPATH_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabAudioPathAudioPath.h : header file
//

#include "resource.h"

class CAudioPathPropPageManager;
class CDirectMusicAudioPath;

/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathAudioPath dialog

class CTabAudioPathAudioPath : public CPropertyPage
{
// Construction
public:
	CTabAudioPathAudioPath( CAudioPathPropPageManager* pAudioPathPropPageManager );
	virtual ~CTabAudioPathAudioPath();
	void SetAudioPath( CDirectMusicAudioPath* pAudioPath );

// Dialog Data
	//{{AFX_DATA(CTabAudioPathAudioPath)
	enum { IDD = IDD_TAB_AUDIOPATH_AUDIOPATH };
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabAudioPathAudioPath)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicAudioPath*		m_pAudioPath;
	CAudioPathPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabAudioPathAudioPath)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	virtual BOOL OnInitDialog();
	//afx_msg void On11();
	//afx_msg void On22();
	//afx_msg void On44();
	//afx_msg void On48();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABAUDIOPATHAUDIOPATH_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabAudioPathInfo.h ===
#if !defined(AFX_TABAUDIOPATHINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABAUDIOPATHINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabAudioPathInfo.h : header file
//

#include "resource.h"

class CAudioPathPropPageManager;
class CDirectMusicAudioPath;

/////////////////////////////////////////////////////////////////////////////
// CTabAudioPathInfo dialog

class CTabAudioPathInfo : public CPropertyPage
{
// Construction
public:
	CTabAudioPathInfo( CAudioPathPropPageManager* pAudioPathPropPageManager );
	virtual ~CTabAudioPathInfo();
	void SetAudioPath( CDirectMusicAudioPath* pAudioPath );

// Dialog Data
	//{{AFX_DATA(CTabAudioPathInfo)
	enum { IDD = IDD_TAB_AUDIOPATH_INFO };
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabAudioPathInfo)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicAudioPath*		m_pAudioPath;
	CAudioPathPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabAudioPathInfo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusAuthor();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABAUDIOPATHINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabBuffer.cpp ===
// TabBuffer.cpp : implementation file
//

#include "stdafx.h"
#include "TabBuffer.h"
#include "BufferPPGMgr.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "AudioPathDesignerDLL.h"
#include "AudioPathComponent.h"
#include "guiddlg.h"
#include "LockoutNotification.h"
#include "Dlg3DParam.h"
#include "DlgAddRemoveBuses.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static int BufferGUIDToIndex( GUID &rguidBuffer )
{
	if( rguidBuffer == GUID_Buffer_Reverb )
	{
		return 0;
	}
	/*
	if( rguidBuffer == GUID_Buffer_3D )
	{
		return 1;
	}
	*/
	if( rguidBuffer == GUID_Buffer_3D_Dry )
	{
		return 1;
	}
	if( rguidBuffer == GUID_Buffer_Mono )
	{
		return 2;
	}
	if( rguidBuffer == GUID_Buffer_Stereo )
	{
		return 3;
	}
	return -1;
}

static GUID BufferIndexToGUID( int nIndex )
{
	switch( nIndex )
	{
	case 0:
		return GUID_Buffer_Reverb;
		/*
	case 1:
		return GUID_Buffer_3D;
		*/
	case 1:
		return GUID_Buffer_3D_Dry;
	case 2:
		return GUID_Buffer_Mono;
	case 3:
		return GUID_Buffer_Stereo;
	default:
		return GUID_AllZeros;
	}
}

static void PanValueToString( int nValue, CString& strValue ) 
{
	CString strTemp;

	if( nValue < DSBPAN_CENTER )
	{
		strTemp.LoadString( IDS_PAN_LEFT );
		strValue.Format( "%s%d", strTemp, abs(nValue) );
	}
	else if( nValue > DSBPAN_CENTER )
	{
		strTemp.LoadString( IDS_PAN_RIGHT );
		strValue.Format( "%s%d", strTemp, nValue );
	}
	else
	{
		strValue.LoadString( IDS_PAN_MID );
	} 
}

static int StringToPanValue( LPCTSTR pszNewValue )
{
	CString strNewValue = pszNewValue;
	int nLength = strNewValue.GetLength();

	int nNewValue = INT_MIN; // Bad Value

	CString strTemp;
	strTemp.LoadString( IDS_PAN_MID );

	if( strTemp.CompareNoCase( strNewValue) == 0 )
	{
		nNewValue = DSBPAN_CENTER;
	}
	else
	{
		CString strMinus;
		strMinus.LoadString( IDS_MINUS_TEXT );

		CString strBalance = strNewValue.Left( 1 );
		CString strValue = strNewValue.Right( nLength - 1 );

		// 1st char of 'L' or negative number means LEFT
		strTemp.LoadString( IDS_PAN_LEFT);
		if( (strTemp.CompareNoCase( strBalance ) == 0)
		||  (strMinus.CompareNoCase( strBalance ) == 0) )
		{
			nNewValue = _ttoi( strValue );
			nNewValue = -nNewValue;
		}
		else
		{
			// 1st char of 'R' or positive number means RIGHT
			strTemp.LoadString( IDS_PAN_RIGHT);
			if( strTemp.CompareNoCase( strBalance ) == 0 )
			{
				nNewValue = _ttoi( strValue );
			}
			else
			{
				nNewValue = _ttoi( strNewValue );
			}
		}
	}

	return nNewValue;
}

/////////////////////////////////////////////////////////////////////////////
// CTabBuffer property page

IMPLEMENT_DYNCREATE(CTabBuffer, CPropertyPage)

CTabBuffer::CTabBuffer() : CPropertyPage(CTabBuffer::IDD)
{
	//{{AFX_DATA_INIT(CTabBuffer)
	//}}AFX_DATA_INIT
	m_fNeedToDetach = false;
	m_pIPropPageObject = NULL;
	m_pBufferPPGMgr = NULL;
	m_fWasShared = false;
}

CTabBuffer::~CTabBuffer()
{
	// Weak reference - don't release it!
	//RELEASE(m_pIPropPageObject)
	// Weak reference - don't release it!
	//RELEASE(m_pBufferPPGMgr)
}

void CTabBuffer::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabBuffer)
	DDX_Control(pDX, IDC_SPIN_VOLUME, m_spinVolume);
	DDX_Control(pDX, IDC_SPIN_PAN, m_spinPan);
	DDX_Control(pDX, IDC_EDIT_VOLUME, m_editVolume);
	DDX_Control(pDX, IDC_EDIT_PAN, m_editPan);
	DDX_Control(pDX, IDC_COMBO_STANDARD_BUFFER, m_comboStandardBuffer);
	DDX_Control(pDX, IDC_CHECK_SHARE, m_checkShared);
	DDX_Control(pDX, IDC_CHECK_PREDEFINED, m_checkPredefined);
	DDX_Control(pDX, IDC_BUTTON_GUID, m_btnEditGuid);
	DDX_Control(pDX, IDC_EDIT_CHANNELS, m_editChannels);
	DDX_Control(pDX, IDC_SPIN_CHANNELS, m_spinChannels);
	DDX_Control(pDX, IDC_COMBO_3DAlg, m_combo3DAlg);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabBuffer, CPropertyPage)
	//{{AFX_MSG_MAP(CTabBuffer)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHECK_PREDEFINED, OnCheckPredefined)
	ON_CBN_SELCHANGE(IDC_COMBO_STANDARD_BUFFER, OnSelchangeComboStandardBuffer)
	ON_BN_CLICKED(IDC_CHECK_SHARE, OnCheckShare)
	ON_BN_CLICKED(IDC_BUTTON_GUID, OnButtonGuid)
	ON_CBN_SELCHANGE(IDC_COMBO_3DAlg, OnSelchangeCOMBO3DAlg)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_CHANNELS, OnDeltaposSpinChannels)
	ON_EN_KILLFOCUS(IDC_EDIT_CHANNELS, OnKillfocusEditChannels)
	ON_BN_CLICKED(IDC_BUTTON_3D_POS, OnButton3dPos)
	ON_EN_KILLFOCUS(IDC_EDIT_PAN, OnKillfocusEditPan)
	ON_EN_KILLFOCUS(IDC_EDIT_VOLUME, OnKillfocusEditVolume)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PAN, OnDeltaposSpinPan)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabBuffer message handlers

BOOL CTabBuffer::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->GetActivePage( &CBufferPPGMgr::sm_nActiveTab );
		RELEASE( pIPropSheet );
	}

	return CPropertyPage::OnSetActive();
}

int CTabBuffer::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = true;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CTabBuffer::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;

		m_fNeedToDetach = false;
	}

	CPropertyPage::OnDestroy();
}

BOOL CTabBuffer::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();

	m_combo3DAlg.ResetContent();

	// DS3DALG_DEFAULT -- Default
	// DS3DALG_NO_VIRTUALIZATION -- No virtualization
	// DS3DALG_HRTF_FULL -- High quality HRTF
	// DS3DALG_HRTF_LIGHT -- Fast HRTF
	CString strText;
	int nIndex;

	strText.LoadString( IDS_3DALG_DEFAULT );
	nIndex = m_combo3DAlg.AddString( strText );
	m_combo3DAlg.SetItemDataPtr( nIndex, (void *)&DS3DALG_DEFAULT );

	strText.LoadString( IDS_3DALG_NO_VIRTUALIZATION );
	nIndex = m_combo3DAlg.AddString( strText );
	m_combo3DAlg.SetItemDataPtr( nIndex, (void *)&DS3DALG_NO_VIRTUALIZATION );

	strText.LoadString( IDS_3DALG_HRTF_FULL );
	nIndex = m_combo3DAlg.AddString( strText );
	m_combo3DAlg.SetItemDataPtr( nIndex, (void *)&DS3DALG_HRTF_FULL );

	strText.LoadString( IDS_3DALG_HRTF_LIGHT );
	nIndex = m_combo3DAlg.AddString( strText );
	m_combo3DAlg.SetItemDataPtr( nIndex, (void *)&DS3DALG_HRTF_LIGHT );

	m_spinChannels.SetRange( 1, MAX_AUDIO_CHANNELS );
	strText.Format( "%d", MAX_AUDIO_CHANNELS );
	m_editChannels.SetLimitText( strText.GetLength() );

	m_spinVolume.SetRange( DSBVOLUME_MIN, 0 );
	strText.Format( "%d", DSBVOLUME_MIN );
	m_editVolume.SetLimitText( strText.GetLength() );
	m_editVolume.m_fMinusValid = true;
	m_editVolume.m_fDotValid = false;

	m_spinPan.SetRange( DSBPAN_LEFT, DSBPAN_RIGHT );
	PanValueToString( DSBPAN_LEFT, strText );
	m_editPan.SetLimitText( strText.GetLength() );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabBuffer::SetBuffer

void CTabBuffer::SetBuffer( BufferInfoForPPG* pBufferInfoForPPG, IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pBufferInfoForPPG )
	{
		m_BufferInfoForPPG.Copy( *pBufferInfoForPPG );
	}
	else
	{
		m_BufferInfoForPPG.m_fValid = false;
	}

	m_pIPropPageObject = pINewPropPageObject;

	m_fWasShared = false;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBuffer::EnableUserControls

void CTabBuffer::EnableUserControls( bool fEnable ) 
{
	if( fEnable
	&&	(m_BufferInfoForPPG.m_dwMinNumChannels < MAX_AUDIO_CHANNELS) )
	{
		m_editChannels.EnableWindow( TRUE );
		m_spinChannels.EnableWindow( TRUE );
	}
	else
	{
		m_editChannels.EnableWindow( FALSE );
		m_spinChannels.EnableWindow( FALSE );
	}

	EnableDlgItem( IDC_RADIO_CTRL3D, fEnable );
	EnableDlgItem( IDC_RADIO_PAN, fEnable );
	EnableDlgItem( IDC_CHECK_DOPPLER, fEnable );

	m_editVolume.EnableWindow( fEnable );

	/*
	EnableDlgItem( IDC_RADIO_GLOBALFOCUS, fEnable );
	EnableDlgItem( IDC_RADIO_STICKYFOCUS, fEnable );
	EnableDlgItem( IDC_RADIO_LOCALFOCUS, fEnable );
	*/

	if( fEnable )
	{
		if( m_BufferInfoForPPG.m_dwBufferFlags & DSBCAPS_CTRL3D )
		{
			EnableDlgItem( IDC_CHECK_MUTE3DATMAXDISTANCE, TRUE );
			EnableDlgItem( IDC_BUTTON_3D_POS, TRUE );
			m_combo3DAlg.EnableWindow( TRUE );
			m_editPan.EnableWindow( FALSE );
		}
		else
		{
			EnableDlgItem( IDC_CHECK_MUTE3DATMAXDISTANCE, FALSE );
			EnableDlgItem( IDC_BUTTON_3D_POS, FALSE );
			m_combo3DAlg.EnableWindow( FALSE );
			m_editPan.EnableWindow( TRUE );
		}

	}
	else
	{
		EnableDlgItem( IDC_CHECK_MUTE3DATMAXDISTANCE, FALSE );
		EnableDlgItem( IDC_BUTTON_3D_POS, FALSE );
		m_combo3DAlg.EnableWindow( FALSE );
		m_editPan.EnableWindow( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBuffer::EnableDlgItem

void CTabBuffer::EnableDlgItem( int nItem, BOOL fEnable )
{
	CWnd* pWnd = GetDlgItem( nItem );
	if( pWnd )
	{
		pWnd->EnableWindow( fEnable );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBuffer::EnableControls

void CTabBuffer::EnableControls( bool fEnable ) 
{
	EnableUserControls( fEnable
		&& !(m_BufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_DEFINED) );

	m_checkShared.EnableWindow( fEnable );

	// Check if fEnable is set and we're not using the EnvReverb buffer type
	// and the mix group has PChannels
#ifndef DMP_XBOX
	if( fEnable
	&&	(m_BufferInfoForPPG.m_guidBufferID != GUID_Buffer_EnvReverb)
	&&	(m_BufferInfoForPPG.m_dwDesignFlags & DESIGN_BUFFER_HAS_PCHANNELS) )
	{
		// Allow the user to modify the "Use standard buffer" checkbox
		m_checkPredefined.EnableWindow( TRUE );
	}
	else
#endif
	{
		m_checkPredefined.EnableWindow( FALSE );
	}

	// Check if fEnable is set and we're using a defined buffer type,
	// but not using the EnvReverb buffer type
	if( fEnable
	&&	(m_BufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_DEFINED)
	&&	(m_BufferInfoForPPG.m_guidBufferID != GUID_Buffer_EnvReverb) )
	{
		// Allow the user to modify the "Predefined buffer" combobox
		m_comboStandardBuffer.EnableWindow( TRUE );
	}
	else
	{
		m_comboStandardBuffer.EnableWindow( FALSE );
	}

	// Check if fEnable is set and we're using a shared, non-standard buffer
	if( fEnable
	&&	!(m_BufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_DEFINED) )
	{
		// Allow the user to modify the buffer's GUID
		m_btnEditGuid.EnableWindow( TRUE );
	}
	else
	{
		m_btnEditGuid.EnableWindow( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBuffer::UpdateControls

void CTabBuffer::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_comboStandardBuffer.m_hWnd) == FALSE )
	{
		return;
	}

	// Don't send notifications when updating the dialog
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Update controls
	if( m_BufferInfoForPPG.m_fValid && m_pIPropPageObject )
	{
		EnableControls( true );

		// Set the states of the checkboxes
		m_checkPredefined.SetCheck( ((m_BufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_DEFINED) != 0) ? 1 : 0 );
		m_checkShared.SetCheck( ((m_BufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_SHARED) != 0) ? 1 : 0 );

		if( m_BufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_DEFINED )
		{
			CString strText;
			m_comboStandardBuffer.ResetContent();

			// If using the environmental reverb type
			if( m_BufferInfoForPPG.m_guidBufferID == GUID_Buffer_EnvReverb )
			{
				// Set the combobox to say 'Environmental Reverb'
				strText.LoadString(IDS_PPG_BUFFER_ENV_REVERB);
				m_comboStandardBuffer.AddString( strText );
				m_comboStandardBuffer.SetCurSel( 0 );

				CheckDlgButton( IDC_RADIO_CTRL3D, 0 );
				CheckDlgButton( IDC_CHECK_MUTE3DATMAXDISTANCE, 0 );
				CheckDlgButton( IDC_RADIO_PAN, 1 );
				CheckDlgButton( IDC_CHECK_DOPPLER, 0 );
				SetDlgItemInt( IDC_EDIT_CHANNELS, 2, FALSE );
			}
			else
			{
				// Otherwise, set the defined buffer type
				strText.LoadString(IDS_PPG_BUFFER_REVERB);
				m_comboStandardBuffer.AddString( strText );
				/*
				strText.LoadString(IDS_PPG_BUFFER_3D);
				m_comboStandardBuffer.AddString( strText );
				*/
				strText.LoadString(IDS_PPG_BUFFER_3D_DRY);
				m_comboStandardBuffer.AddString( strText );
				strText.LoadString(IDS_PPG_BUFFER_MONO);
				m_comboStandardBuffer.AddString( strText );
				strText.LoadString(IDS_PPG_BUFFER_STEREO);
				m_comboStandardBuffer.AddString( strText );

				m_comboStandardBuffer.SetCurSel( BufferGUIDToIndex( m_BufferInfoForPPG.m_guidBufferID ) );

				// Set the checkboxes
				int nIndex = BufferGUIDToIndex( m_BufferInfoForPPG.m_guidBufferID );
				switch( nIndex )
				{
				case 0: // Reverb
				case 3: // Stereo
					CheckDlgButton( IDC_RADIO_CTRL3D, 0 );
					CheckDlgButton( IDC_CHECK_MUTE3DATMAXDISTANCE, 0 );
					CheckDlgButton( IDC_RADIO_PAN, 1 );
					SetDlgItemInt( IDC_EDIT_CHANNELS, 2, FALSE );
					break;
				//case 1: // 3D Wet
				case 1: // 3D Dry
					CheckDlgButton( IDC_RADIO_CTRL3D, 1 );
					CheckDlgButton( IDC_CHECK_MUTE3DATMAXDISTANCE, 1 );
					CheckDlgButton( IDC_RADIO_PAN, 0 );
					SetDlgItemInt( IDC_EDIT_CHANNELS, 1, FALSE );
					break;
				default: // Everything else (Mono)
					CheckDlgButton( IDC_RADIO_CTRL3D, 0 );
					CheckDlgButton( IDC_CHECK_MUTE3DATMAXDISTANCE, 0 );
					CheckDlgButton( IDC_RADIO_PAN, 1 );
					SetDlgItemInt( IDC_EDIT_CHANNELS, 1, FALSE );
					break;
				}

				// Set the doppler checkbox if anything except a Reverb buffer
				CheckDlgButton( IDC_CHECK_DOPPLER, (nIndex == 0) ? 0 : 1 );
			}

			// Set the 3d type to 'default'
			for( int nIndex = 0; nIndex < m_combo3DAlg.GetCount(); nIndex++ )
			{
				CLSID *pclsidItem = static_cast<CLSID *>(m_combo3DAlg.GetItemDataPtr( nIndex ));
				if( pclsidItem
				&&	(*pclsidItem == DS3DALG_DEFAULT) )
				{
					m_combo3DAlg.SetCurSel( nIndex );
					break;
				}
			}

			// Set the focus radio buttons
			//CheckRadioButton( IDC_RADIO_LOCALFOCUS, IDC_RADIO_GLOBALFOCUS, IDC_RADIO_GLOBALFOCUS );

			// Set the Pan and Volume
			SetDlgItemInt( IDC_EDIT_PAN, 0, TRUE );
			SetDlgItemInt( IDC_EDIT_VOLUME, 0, TRUE );
		}
		else
		{
			m_comboStandardBuffer.SetCurSel( -1 );

			// Get the 3d type
			for( int nIndex = 0; nIndex < m_combo3DAlg.GetCount(); nIndex++ )
			{
				CLSID *pclsidItem = static_cast<CLSID *>(m_combo3DAlg.GetItemDataPtr( nIndex ));
				if( pclsidItem
				&&	(*pclsidItem == m_BufferInfoForPPG.m_clsid3dAlgorithm) )
				{
					m_combo3DAlg.SetCurSel( nIndex );
					break;
				}
			}

			// Set the number of channels
			SetDlgItemInt( IDC_EDIT_CHANNELS, m_BufferInfoForPPG.m_dwNumChannels, FALSE );
			m_spinChannels.SetPos( m_BufferInfoForPPG.m_dwNumChannels );
			m_spinChannels.SetRange( m_BufferInfoForPPG.m_dwMinNumChannels, MAX_AUDIO_CHANNELS );

			// Set the focus radio buttons
			/*
			if( m_BufferInfoForPPG.m_dwBufferFlags & DSBCAPS_STICKYFOCUS )
			{
				CheckRadioButton( IDC_RADIO_LOCALFOCUS, IDC_RADIO_GLOBALFOCUS, IDC_RADIO_STICKYFOCUS );
			}
			else if( m_BufferInfoForPPG.m_dwBufferFlags & DSBCAPS_GLOBALFOCUS )
			{
				CheckRadioButton( IDC_RADIO_LOCALFOCUS, IDC_RADIO_GLOBALFOCUS, IDC_RADIO_GLOBALFOCUS );
			}
			else // None
			{
				CheckRadioButton( IDC_RADIO_LOCALFOCUS, IDC_RADIO_GLOBALFOCUS, IDC_RADIO_LOCALFOCUS );
			}
			*/

			// Set the checkboxes
			CheckDlgButton( IDC_RADIO_CTRL3D, (m_BufferInfoForPPG.m_dwBufferFlags & DSBCAPS_CTRL3D) ? 1 : 0 );
			CheckDlgButton( IDC_CHECK_MUTE3DATMAXDISTANCE, (m_BufferInfoForPPG.m_dwBufferFlags & DSBCAPS_MUTE3DATMAXDISTANCE) ? 1 : 0 );
			CheckDlgButton( IDC_RADIO_PAN, (m_BufferInfoForPPG.m_dwBufferFlags & DSBCAPS_CTRLPAN) ? 1 : 0 );
			CheckDlgButton( IDC_CHECK_DOPPLER, (m_BufferInfoForPPG.m_dwBufferFlags & DSBCAPS_CTRLFREQUENCY) ? 1 : 0 );

			// Set the Volume value
			SetDlgItemInt( IDC_EDIT_VOLUME, m_BufferInfoForPPG.m_lVolume, TRUE );

			// Set the Pan value
			CString strPan;
			PanValueToString( m_BufferInfoForPPG.m_lPan, strPan );
			SetDlgItemText( IDC_EDIT_PAN, strPan );
		}
	}
	else
	{
		EnableControls( false );

		m_checkPredefined.SetCheck( 0 );
		m_checkShared.SetCheck( 0 );
		m_comboStandardBuffer.SetCurSel( -1 );

		m_combo3DAlg.SetCurSel( -1 );
		SetDlgItemText( IDC_EDIT_CHANNELS, NULL );

		// Set the focus radio buttons
		//CheckRadioButton( IDC_RADIO_LOCALFOCUS, IDC_RADIO_GLOBALFOCUS, IDC_RADIO_LOCALFOCUS );

		// Set the checkboxes
		CheckDlgButton( IDC_RADIO_CTRL3D, 0 );
		CheckDlgButton( IDC_CHECK_MUTE3DATMAXDISTANCE, 0 );
		CheckDlgButton( IDC_RADIO_PAN, 0 );

		// Set the Pan and Volume
		SetDlgItemText( IDC_EDIT_PAN, NULL );
		SetDlgItemText( IDC_EDIT_VOLUME, NULL );
	}
}

void CTabBuffer::OnCheckPredefined() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !m_BufferInfoForPPG.m_fValid || !m_pIPropPageObject )
	{
		return;
	}

	if( m_checkPredefined.GetCheck() )
	{
		m_fWasShared = (m_BufferInfoForPPG.m_dwHeaderFlags & DMUS_BUFFERF_SHARED) ? true : false;

		m_BufferInfoForPPG.m_dwHeaderFlags |= DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_SHARED;

		// The Buffer GUID should not be one of the predefined ones
		ASSERT( BufferGUIDToIndex( m_BufferInfoForPPG.m_guidBufferID ) == -1);

		// Flag that we also changed the standard GUID
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_HEADERFLAGS | CH_BUFFER_STANDARDGUID;
		m_BufferInfoForPPG.m_guidBufferID = GUID_Buffer_Reverb;
	}
	else
	{
		m_BufferInfoForPPG.m_dwHeaderFlags &= ~DMUS_BUFFERF_DEFINED;
		if( m_fWasShared )
		{
			m_BufferInfoForPPG.m_dwHeaderFlags |= DMUS_BUFFERF_SHARED;
		}
		else
		{
			m_BufferInfoForPPG.m_dwHeaderFlags &= ~DMUS_BUFFERF_SHARED;
		}

		// Flag that we also changed the standard GUID
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_HEADERFLAGS | CH_BUFFER_STANDARDGUID;
		CoCreateGuid( &m_BufferInfoForPPG.m_guidBufferID );
	}

	// Update the editor with the new information
	m_pIPropPageObject->SetData( &m_BufferInfoForPPG );

	// Enable/disable the edit guid button and standard buffer droplist
	// Update the droplist to point to the correct buffer
	UpdateControls();
}

void CTabBuffer::OnSelchangeComboStandardBuffer() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !m_BufferInfoForPPG.m_fValid || !m_pIPropPageObject )
	{
		return;
	}

	// Get the new index
	int nIndex = m_comboStandardBuffer.GetCurSel();
	if( nIndex != CB_ERR )
	{
		// Get a copy of the new GUID
		m_BufferInfoForPPG.m_guidBufferID = BufferIndexToGUID( nIndex );

		if( /*(GUID_Buffer_3D == m_BufferInfoForPPG.m_guidBufferID)
		||	*/(GUID_Buffer_3D_Dry == m_BufferInfoForPPG.m_guidBufferID) )
		{
			m_BufferInfoForPPG.m_dwHeaderFlags &= ~DMUS_BUFFERF_SHARED;
		}
		else // GUID_Buffer_Reverb, GUID_Buffer_Stereo, GUID_Buffer_Mono
		{
			m_BufferInfoForPPG.m_dwHeaderFlags |= DMUS_BUFFERF_SHARED;
		}

		// Nofiy the PPO that the data changed
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_STANDARDGUID;
		m_pIPropPageObject->SetData( &m_BufferInfoForPPG );

		// Refresh the controls
		UpdateControls();
	}
}

void CTabBuffer::OnCheckShare() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !m_BufferInfoForPPG.m_fValid || !m_pIPropPageObject )
	{
		return;
	}

	if( m_checkShared.GetCheck() )
	{
		m_BufferInfoForPPG.m_dwHeaderFlags |= DMUS_BUFFERF_SHARED;
	}
	else
	{
		m_BufferInfoForPPG.m_dwHeaderFlags &= ~DMUS_BUFFERF_SHARED;
	}

	// Update the editor with the new information
	m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_HEADERFLAGS;
	m_pIPropPageObject->SetData( &m_BufferInfoForPPG );

	// Enable/disable the edit guid button
	EnableControls( true );
}

void CTabBuffer::OnButtonGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CGuidDlg dlgGuid;
	dlgGuid.m_guid = m_BufferInfoForPPG.m_guidBufferID;
	if( dlgGuid.DoModal() == IDOK )
	{
		// Get the new GUID
		m_BufferInfoForPPG.m_guidBufferID = dlgGuid.m_guid;

		// Update the editor with the new information
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_USERGUID;
		m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
	}
}

void CTabBuffer::OnSelchangeCOMBO3DAlg() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_BufferInfoForPPG.m_fValid || !m_pIPropPageObject )
	{
		return;
	}

	// Get the new index
	int nIndex = m_combo3DAlg.GetCurSel();
	if( nIndex != CB_ERR )
	{
		// Get a copy of the new GUID
		GUID *pGuid = (GUID *)m_combo3DAlg.GetItemDataPtr( nIndex );
		if( pGuid )
		{
			m_BufferInfoForPPG.m_clsid3dAlgorithm = *pGuid;

			// Nofiy the PPO that the data changed
			m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFER3DALG;
			m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
		}
	}
}

BOOL CTabBuffer::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_BufferInfoForPPG.m_fValid || !m_pIPropPageObject )
	{
		return CPropertyPage::OnCommand( wParam, lParam );
	}

	int nControlID = LOWORD( wParam );
	int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		// Get a pointer to the button that was pressed
		CWnd* pWnd = GetDlgItem( nControlID );
		if( pWnd )
		{
			bool fButtonChecked = (IsDlgButtonChecked( nControlID ) != 0);

			// Handle buttons with side effects:
			switch( nControlID )
			{
				/*
			case IDC_RADIO_LOCALFOCUS:
				// Clear sticky and global bits
				m_BufferInfoForPPG.m_dwBufferFlags &= ~(DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS);

				// Nofiy the PPO that the data changed
				m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERFLAGS;
				m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
				break;
			case IDC_RADIO_STICKYFOCUS:
				// Set sticky bit
				m_BufferInfoForPPG.m_dwBufferFlags |= DSBCAPS_STICKYFOCUS;

				// Clear global bit
				m_BufferInfoForPPG.m_dwBufferFlags &= ~DSBCAPS_GLOBALFOCUS;

				// Nofiy the PPO that the data changed
				m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERFLAGS;
				m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
				break;
			case IDC_RADIO_GLOBALFOCUS:
				// Set global bit
				m_BufferInfoForPPG.m_dwBufferFlags |= DSBCAPS_GLOBALFOCUS;

				// Clear sticky bit
				m_BufferInfoForPPG.m_dwBufferFlags &= ~DSBCAPS_STICKYFOCUS;

				// Nofiy the PPO that the data changed
				m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERFLAGS;
				m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
				break;
				*/
			case IDC_RADIO_PAN:
				// Disable and uncheck Mute Sound button
				EnableDlgItem( IDC_CHECK_MUTE3DATMAXDISTANCE, FALSE );
				CheckDlgButton( IDC_CHECK_MUTE3DATMAXDISTANCE, 0 );
				m_BufferInfoForPPG.m_dwBufferFlags &= ~DSBCAPS_MUTE3DATMAXDISTANCE;

				// Disable the 3D position controls
				EnableDlgItem( IDC_BUTTON_3D_POS, FALSE );

				// Disable the 3D algorithm combobox
				m_combo3DAlg.EnableWindow( FALSE );

				// Clear bit
				m_BufferInfoForPPG.m_dwBufferFlags &= ~DSBCAPS_CTRL3D;

				// Enable the Pan edit box
				m_editPan.EnableWindow( TRUE );

				// Set the CtrlPan bit
				m_BufferInfoForPPG.m_dwBufferFlags |= DSBCAPS_CTRLPAN;

				// Nofiy the PPO that the data changed
				m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERFLAGS;
				m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
				break;
			case IDC_RADIO_CTRL3D:
				// Enable the Mute sound button
				EnableDlgItem( IDC_CHECK_MUTE3DATMAXDISTANCE, TRUE );

				// Enable the 3D position controls
				EnableDlgItem( IDC_BUTTON_3D_POS, TRUE );

				// Enable the 3D algorithm combobox
				m_combo3DAlg.EnableWindow( TRUE );

				// Set Ctrl3D bit
				m_BufferInfoForPPG.m_dwBufferFlags |= DSBCAPS_CTRL3D;

				// Disable the Pan edit box
				m_editPan.EnableWindow( FALSE );

				// Clear the CtrlPan bit
				m_BufferInfoForPPG.m_dwBufferFlags &= ~DSBCAPS_CTRLPAN;

				// Nofiy the PPO that the data changed
				m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERFLAGS;
				m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
				break;
			default:
			{	// Handle other buttons
				DWORD dwBufferFlag = 0;
				switch( nControlID )
				{
				case IDC_CHECK_MUTE3DATMAXDISTANCE:
					dwBufferFlag = DSBCAPS_MUTE3DATMAXDISTANCE;
					break;
				case IDC_CHECK_DOPPLER:
					dwBufferFlag = DSBCAPS_CTRLFREQUENCY;
				}

				if( dwBufferFlag )
				{
					if( fButtonChecked )
					{
						// Button was checked
						m_BufferInfoForPPG.m_dwBufferFlags |= dwBufferFlag;
					}
					else
					{
						// Button was unchecked
						m_BufferInfoForPPG.m_dwBufferFlags &= ~dwBufferFlag;
					}

					// Nofiy the PPO that the data changed
					m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERFLAGS;
					m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
				}
				break;
			}
			}
		}
	}

	return CPropertyPage::OnCommand( wParam, lParam );
}

void CTabBuffer::OnButton3dPos() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDlg3DParam dlg3DParam;
	dlg3DParam.m_ds3DBuffer = m_BufferInfoForPPG.m_ds3DBuffer;
	if( dlg3DParam.DoModal() == IDOK )
	{
		if( memcmp( &m_BufferInfoForPPG.m_ds3DBuffer, &dlg3DParam.m_ds3DBuffer, sizeof(DS3DBUFFER) ) != 0 )
		{
			m_BufferInfoForPPG.m_ds3DBuffer = dlg3DParam.m_ds3DBuffer;

			// Nofiy the PPO that the data changed
			m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFER3DPOS;
			m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
		}
	}
}

void CTabBuffer::OnDeltaposSpinChannels(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewValue = m_spinChannels.GetPos() + pNMUpDown->iDelta;
	if( unsigned(nNewValue) < m_BufferInfoForPPG.m_dwMinNumChannels )
	{
		nNewValue = m_BufferInfoForPPG.m_dwMinNumChannels;
	}
	else if( nNewValue > MAX_AUDIO_CHANNELS )
	{
		nNewValue = MAX_AUDIO_CHANNELS;
	}
	
	if( (unsigned) nNewValue != m_BufferInfoForPPG.m_dwNumChannels )
	{
		m_BufferInfoForPPG.m_dwNumChannels = nNewValue;

		// Nofiy the PPO that the data changed
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERCHANNELS;
		m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
	}

	*pResult = 0;
}

void CTabBuffer::OnKillfocusEditChannels() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fSucceeded;
	int nNumChannels = GetDlgItemInt( IDC_EDIT_CHANNELS, &fSucceeded, FALSE );
	if( !fSucceeded
	||	unsigned(nNumChannels) < m_BufferInfoForPPG.m_dwMinNumChannels )
	{
		// Set a minimum of m_BufferInfoForPPG.m_dwMinNumChannels
		nNumChannels = m_BufferInfoForPPG.m_dwMinNumChannels;

		// Reset the number of channels
		SetDlgItemInt( IDC_EDIT_CHANNELS, nNumChannels, FALSE );
		m_spinChannels.SetPos( nNumChannels );
	}
	else if( nNumChannels > MAX_AUDIO_CHANNELS )
	{
		// Set a maximum of MAX_AUDIO_CHANNELS
		nNumChannels = MAX_AUDIO_CHANNELS;

		// Reset the number of channels
		SetDlgItemInt( IDC_EDIT_CHANNELS, nNumChannels, FALSE );
		m_spinChannels.SetPos( nNumChannels );
	}

	if( (unsigned) nNumChannels != m_BufferInfoForPPG.m_dwNumChannels )
	{
		m_BufferInfoForPPG.m_dwNumChannels = nNumChannels;

		// Nofiy the PPO that the data changed
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERCHANNELS;
		m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
	}
}

void CTabBuffer::OnKillfocusEditVolume() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fSucceeded;
	int nVolume = GetDlgItemInt( IDC_EDIT_VOLUME, &fSucceeded, TRUE );
	if( !fSucceeded
	||	nVolume > DSBVOLUME_MAX )
	{
		// Set volume to default (0)
		nVolume = DSBVOLUME_MAX;

		// Reset the volume value
		SetDlgItemInt( IDC_EDIT_VOLUME, nVolume, TRUE );
	}
	else if( nVolume < DSBVOLUME_MIN )
	{
		// Set volume to minimum
		nVolume = DSBVOLUME_MIN;

		// Reset the volume value
		SetDlgItemInt( IDC_EDIT_VOLUME, nVolume, TRUE );
	}

	if( nVolume != m_BufferInfoForPPG.m_lVolume )
	{
		m_BufferInfoForPPG.m_lVolume = nVolume;

		// Nofiy the PPO that the data changed
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERVOLUME;
		m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
	}
}

void CTabBuffer::OnKillfocusEditPan() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get text from edit control
	CString strNewPan;
	m_editPan.GetWindowText( strNewPan );
	strNewPan.TrimRight();
	strNewPan.TrimLeft();

	int nNewPan;

	if( strNewPan.IsEmpty() )
	{
		// Set pan to default
		nNewPan = DSBPAN_CENTER;

		// Reset the pan value
		SetDlgItemInt( IDC_EDIT_PAN, nNewPan, TRUE );
	}
	else
	{
		nNewPan = StringToPanValue( strNewPan );
		if( nNewPan == INT_MIN )
		{
			// Bad value - no change
			nNewPan = m_BufferInfoForPPG.m_lPan;
		}
		else
		{
			// Make sure value is within range
			if( nNewPan < DSBPAN_LEFT )
			{
				nNewPan = DSBPAN_LEFT;
			}
			if( nNewPan > DSBPAN_RIGHT )
			{
				nNewPan = DSBPAN_RIGHT;
			}
		}
	}

	if( nNewPan != m_BufferInfoForPPG.m_lPan )
	{
		m_BufferInfoForPPG.m_lPan = nNewPan;

		// Nofiy the PPO that the data changed
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERPAN;
		m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
	}

	// Check if edit control's text needs to be updated
	CString strValue;
	CString strCurValue;
	PanValueToString( nNewPan, strValue );
	m_editPan.GetWindowText( strCurValue );
	if( strCurValue != strValue )
	{
		m_editPan.SetWindowText( strValue );
		// SetSel's needed to get caret to end of string
		m_editPan.SetSel( 0, -1 );
		m_editPan.SetSel( -1, -1 );
	}
}

void CTabBuffer::OnDeltaposSpinPan(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Just in case user clicked on spin control immediately after typing text
	OnKillfocusEditPan();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewPan = m_BufferInfoForPPG.m_lPan + pNMUpDown->iDelta;

	// Make sure value is within range
	if( nNewPan < DSBPAN_LEFT )
	{
		nNewPan = DSBPAN_LEFT;
	}
	if( nNewPan > DSBPAN_RIGHT )
	{
		nNewPan = DSBPAN_RIGHT;
	}

	if( nNewPan != m_BufferInfoForPPG.m_lPan )
	{
		m_BufferInfoForPPG.m_lPan = nNewPan;

		// Nofiy the PPO that the data changed
		m_BufferInfoForPPG.m_dwChanged = CH_BUFFER_BUFFERPAN;
		m_pIPropPageObject->SetData( &m_BufferInfoForPPG );
	}

	CString strValue;

	PanValueToString( nNewPan, strValue );
	m_editPan.SetWindowText( strValue );
	
	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\Splitter.h ===
#ifndef __SPLITTER_H__
#define __SPLITTER_H__

// Splitter.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSplitter class

class CSplitter : public CWnd
{
protected:
   CRect	m_rcFirstPane;
   CRect	m_rcSecondPane;

   CWnd		*m_pFirstPane;
   CWnd		*m_pSecondPane;

   CRect	m_rcTrack;
   BOOL		m_fTracking;
   BOOL		m_fVisible;
   CWnd		*m_pParent;
   int		m_nWidth;

public:
   CSplitter();
   BOOL Create(CWnd *pParent, RECT *rect = NULL);
   RECT	GetFirstPaneRect();
   RECT	GetSecondPaneRect();
   void SetFirstPane( CWnd *pPane );
   void SetSecondPane( CWnd *pPane );
   void SetTracker(RECT& rect)
   {
	   m_rcTrack = rect;
   }

protected:
   void OnEndCapture();
   void InvertTracker();

   //{{AFX_VIRTUAL(CSplitter)
   //}}AFX_VIRTUAL

public:
   virtual ~CSplitter();

protected:
   //{{AFX_MSG(CSplitter)
   afx_msg void OnPaint();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnCancelMode();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
   afx_msg void OnCaptureChanged(CWnd *pWnd);
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __SPLITTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
// Compatible with Microsoft Internet Explorer 4.0 and above.
#define _WIN32_IE 0x0400

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <Afxdisp.h>
#include <htmlhelp.h>
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabBuffer.h ===
#if !defined(AFX_TABBUFFER_H__527B1967_EB6A_435C_9C70_7559BF058E07__INCLUDED_)
#define AFX_TABBUFFER_H__527B1967_EB6A_435C_9C70_7559BF058E07__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TabBuffer.h : header file
//

#include "resource.h"
#include "BufferPPGMgr.h"
#include "Dlg3DParam.h"

interface IDMUSProdPropPageObject;

/////////////////////////////////////////////////////////////////////////////
// CTabBuffer dialog

class CTabBuffer : public CPropertyPage
{
friend CBufferPPGMgr;

	DECLARE_DYNCREATE(CTabBuffer)

// Construction
public:
	CTabBuffer();
	~CTabBuffer();

// Dialog Data
	//{{AFX_DATA(CTabBuffer)
	enum { IDD = IDD_TAB_BUFFER };
	CSpinButtonCtrl	m_spinVolume;
	CSpinButtonCtrl	m_spinPan;
	C3DEdit	m_editVolume;
	CEdit	m_editPan;
	CComboBox	m_comboStandardBuffer;
	CButton	m_checkShared;
	CButton	m_checkPredefined;
	CButton	m_btnEditGuid;
	CEdit	m_editChannels;
	CSpinButtonCtrl	m_spinChannels;
	CComboBox	m_combo3DAlg;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabBuffer)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Access functions
public:
	void SetBuffer( BufferInfoForPPG* pBufferInfoForPPG, IDMUSProdPropPageObject* pINewPropPageObject );

// Attributes
protected:
	BufferInfoForPPG	m_BufferInfoForPPG;
	IDMUSProdPropPageObject* m_pIPropPageObject;
	CBufferPPGMgr	*m_pBufferPPGMgr;
	bool			m_fNeedToDetach;
	bool			m_fWasShared;

// Implementation
protected:
	void UpdateControls();
	void EnableControls( bool fEnable );
	void EnableUserControls( bool fEnable );
	void EnableDlgItem( int nItem, BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabBuffer)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckPredefined();
	afx_msg void OnSelchangeComboStandardBuffer();
	afx_msg void OnCheckShare();
	afx_msg void OnButtonGuid();
	afx_msg void OnSelchangeCOMBO3DAlg();
	afx_msg void OnDeltaposSpinChannels(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditChannels();
	afx_msg void OnButton3dPos();
	afx_msg void OnKillfocusEditPan();
	afx_msg void OnKillfocusEditVolume();
	afx_msg void OnDeltaposSpinPan(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABBUFFER_H__527B1967_EB6A_435C_9C70_7559BF058E07__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabEffectInfo.h ===
#if !defined(AFX_TABEFFECTINFO_H__3E290DA9_992B_4E96_9FA6_109C750AEA33__INCLUDED_)
#define AFX_TABEFFECTINFO_H__3E290DA9_992B_4E96_9FA6_109C750AEA33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TabEffectInfo.h : header file
//

#include "resource.h"
#include "EffectInfo.h"


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo dialog

class CTabEffectInfo : public CPropertyPage
{
	DECLARE_DYNCREATE(CTabEffectInfo)

// Construction
public:
	CTabEffectInfo();
	~CTabEffectInfo();

// Dialog Data
	//{{AFX_DATA(CTabEffectInfo)
	enum { IDD = IDD_TAB_EFFECT };
	CComboBox	m_comboSend;
	CEdit	m_editType;
	CEdit	m_editCustomName;
	CButton	m_checkSoftware;
	CButton	m_btnEditProperties;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabEffectInfo)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Access functions
public:
	void SetEffect( EffectInfoForPPG* pEffectInfo, IDMUSProdPropPageObject* pIPropPageObject );

// Attributes
protected:
	EffectInfoForPPG	m_EffectInfoForPPG;
	IDMUSProdPropPageObject* m_pIPropPageObject;
	bool				m_fNeedToDetach;
	bool				m_fHaveValidData;

// Implementation
protected:
	void UpdateControls();
	void EnableControls( bool fEnable );
	void EnableDlgItem( int nItem, BOOL fEnable );
	void ShowDlgItem( int nItem, int nCmdShow );

	// Generated message map functions
	//{{AFX_MSG(CTabEffectInfo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckSoftware();
	afx_msg void OnButtonEditProperties();
	afx_msg void OnKillfocusEditCustomname();
	afx_msg void OnSelchangeComboSend();
	afx_msg void OnButtonSendGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABEFFECTINFO_H__3E290DA9_992B_4E96_9FA6_109C750AEA33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabMixGroup.cpp ===
// TabMixGroup.cpp : implementation file
//

#include "stdafx.h"
#include "audiopathdesignerdll.h"
#include "TabMixGroup.h"
#include "AudioPath.h"
#include "AudioPathCtl.h"
#include "ItemInfo.h"
#include "DlgEditSynth.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabMixGroup property page

IMPLEMENT_DYNCREATE(CTabMixGroup, CPropertyPage)

CTabMixGroup::CTabMixGroup() : CPropertyPage(CTabMixGroup::IDD)
{
	//{{AFX_DATA_INIT(CTabMixGroup)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_fNeedToDetach = false;
	m_pIPropPageObject = NULL;
}

CTabMixGroup::~CTabMixGroup()
{
	// Weak reference - don't release it!
	//RELEASE(m_pIPropPageObject)
}

void CTabMixGroup::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabMixGroup)
	DDX_Control(pDX, ID_STATIC_SYNTH, m_groupSynth);
	DDX_Control(pDX, IDC_BUTTON_SYNTH, m_buttonSynth);
	DDX_Control(pDX, IDC_EDIT_MIXGROUP_NAME, m_editMixGroupName);
	DDX_Control(pDX, IDC_COMBO_SYNTH, m_comboSynth);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabMixGroup, CPropertyPage)
	//{{AFX_MSG_MAP(CTabMixGroup)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_SYNTH, OnButtonSynth)
	ON_EN_KILLFOCUS(IDC_EDIT_MIXGROUP_NAME, OnKillfocusEditMixgroupName)
	ON_CBN_SELCHANGE(IDC_COMBO_SYNTH, OnSelchangeComboSynth)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabMixGroup message handlers

BOOL CTabMixGroup::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->GetActivePage( &CMixGroupPPGMgr::sm_nActiveTab );
		RELEASE( pIPropSheet );
	}
	
	return CPropertyPage::OnSetActive();
}

int CTabMixGroup::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = true;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CTabMixGroup::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;

		m_fNeedToDetach = false;
	}

	CPropertyPage::OnDestroy();
}

BOOL CTabMixGroup::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();

	m_editMixGroupName.LimitText( DMUS_MAX_NAME );

	// Remove all ports from the combobox
	m_comboSynth.ResetContent();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabMixGroup::SetItem

void CTabMixGroup::SetItem( MixGroupInfoForPPG* pMixGroupInfoForPPG, IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pMixGroupInfoForPPG )
	{
		m_MixGroupInfoForPPG.Copy( *pMixGroupInfoForPPG );
	}
	else
	{
		m_MixGroupInfoForPPG.m_fValid = false;
	}

	m_pIPropPageObject = pINewPropPageObject;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMixGroup::EnableControls

void CTabMixGroup::EnableControls( bool fEnable ) 
{
	m_editMixGroupName.EnableWindow( (m_MixGroupInfoForPPG.m_dwFlags & MGI_DONT_EDIT_NAME) ? FALSE : TRUE );

	m_groupSynth.EnableWindow( (m_MixGroupInfoForPPG.m_dwFlags & MGI_HAS_SYNTH) ? TRUE : FALSE );

	if( fEnable
	&&	(m_MixGroupInfoForPPG.m_dwFlags & MGI_HAS_SYNTH) )
	{
		m_comboSynth.EnableWindow( TRUE );
		m_buttonSynth.EnableWindow( TRUE );
	}
	else
	{
		m_comboSynth.EnableWindow( FALSE );
		m_buttonSynth.EnableWindow( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMixGroup::UpdateControls

void CTabMixGroup::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editMixGroupName.m_hWnd) == FALSE )
	{
		return;
	}

	// Remove all ports from the combobox
	m_comboSynth.ResetContent();

	// Update controls
	if( m_MixGroupInfoForPPG.m_fValid && m_pIPropPageObject )
	{
		EnableControls( true );

		// Set name
		m_editMixGroupName.SetWindowText( m_MixGroupInfoForPPG.m_strMixGroupName );

		if( m_MixGroupInfoForPPG.m_pAudioPath
		&&	(m_MixGroupInfoForPPG.m_dwFlags & MGI_HAS_SYNTH) )
		{
			// Iterate through all ports
			POSITION posPort = m_MixGroupInfoForPPG.m_pAudioPath->m_lstPortOptions.GetHeadPosition();
			while( posPort )
			{
				PortOptions *pPortOptions = m_MixGroupInfoForPPG.m_pAudioPath->m_lstPortOptions.GetNext( posPort );
				int nIndex = m_comboSynth.AddString( pPortOptions->m_strName );

				m_comboSynth.SetItemDataPtr( nIndex, pPortOptions );

				if( m_MixGroupInfoForPPG.m_PortOptions.IsEqual( pPortOptions ) )
				{
					m_comboSynth.SetCurSel( nIndex );
				}
			}
		}
	}
	else
	{
		m_editMixGroupName.SetWindowText( _T("") );
		m_comboSynth.SetCurSel( -1 );

		EnableControls( false );
	}
}

void CTabMixGroup::OnButtonSynth() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !(m_MixGroupInfoForPPG.m_dwFlags & MGI_CAN_EDIT_SYNTH) )
	{
		AfxMessageBox( IDS_ERR_CANT_EDIT_SYNTH );
		return;
	}

	// Get Producer hwnd
	HWND hwndProducer = m_MixGroupInfoForPPG.m_pAudioPath->m_pAudioPathCtrl->m_hWndContainer;
	if( hwndProducer == NULL )
	{
		ASSERT( 0 );
		return;
	}


	CDlgEditSynth dlgEditSynth( CWnd::FromHandle( hwndProducer ) );
	dlgEditSynth.m_dwEffects = m_MixGroupInfoForPPG.m_PortOptions.m_dwEffects;
	dlgEditSynth.m_dwSupportedEffects = m_MixGroupInfoForPPG.m_PortOptions.m_dwSupportedEffects;
	dlgEditSynth.m_dwSampleRate = m_MixGroupInfoForPPG.m_PortOptions.m_dwSampleRate;
	dlgEditSynth.m_dwVoices = m_MixGroupInfoForPPG.m_PortOptions.m_dwVoices;
	dlgEditSynth.m_dwMaxVoices = m_MixGroupInfoForPPG.m_PortOptions.m_dwMaxVoices;
	dlgEditSynth.m_strName = m_MixGroupInfoForPPG.m_PortOptions.m_strName;

	if( dlgEditSynth.DoModal() == IDOK )
	{
		if( m_MixGroupInfoForPPG.m_PortOptions.m_dwEffects != dlgEditSynth.m_dwEffects
		||	m_MixGroupInfoForPPG.m_PortOptions.m_dwSampleRate != dlgEditSynth.m_dwSampleRate
		||	m_MixGroupInfoForPPG.m_PortOptions.m_dwVoices != dlgEditSynth.m_dwVoices )
		{
			m_MixGroupInfoForPPG.m_PortOptions.m_dwEffects = dlgEditSynth.m_dwEffects;
			m_MixGroupInfoForPPG.m_PortOptions.m_dwSampleRate = dlgEditSynth.m_dwSampleRate;
			m_MixGroupInfoForPPG.m_PortOptions.m_dwVoices = dlgEditSynth.m_dwVoices;

			// Nofiy the PPO that the data changed
			m_MixGroupInfoForPPG.m_dwChanged = CH_MIXGROUP_SYNTH;
			m_pIPropPageObject->SetData( &m_MixGroupInfoForPPG );
		}
	}
}

void CTabMixGroup::OnKillfocusEditMixgroupName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !m_MixGroupInfoForPPG.m_fValid || !m_pIPropPageObject )
	{
		return;
	}

	CString strNewText;
	m_editMixGroupName.GetWindowText( strNewText );

	// Strip leading and trailing spaces
	strNewText.TrimLeft();
	strNewText.TrimRight();

	if( strNewText.IsEmpty() )
	{
		m_editMixGroupName.SetWindowText( m_MixGroupInfoForPPG.m_strMixGroupName );
	}
	else if( strNewText != m_MixGroupInfoForPPG.m_strMixGroupName )
	{
		m_MixGroupInfoForPPG.m_strMixGroupName = strNewText;
		m_MixGroupInfoForPPG.m_dwChanged = CH_MIXGROUP_NAME;
		m_pIPropPageObject->SetData( &m_MixGroupInfoForPPG );
	}
}

void CTabMixGroup::OnSelchangeComboSynth() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !m_MixGroupInfoForPPG.m_fValid || !m_pIPropPageObject )
	{
		return;
	}

	// Get the new index
	int nIndex = m_comboSynth.GetCurSel();
	if( nIndex != CB_ERR )
	{
		// Get a pointer to the new synth GUID
		PortOptions *pPortOptions = static_cast<PortOptions *>( m_comboSynth.GetItemDataPtr( nIndex ) );

		// Copy the information for the new synth
		m_MixGroupInfoForPPG.m_PortOptions.Copy( pPortOptions );

		// Nofiy the PPO that the data changed
		m_MixGroupInfoForPPG.m_dwChanged = CH_MIXGROUP_SYNTH;
		m_pIPropPageObject->SetData( &m_MixGroupInfoForPPG );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\AddRemoveDlg.cpp ===
// AddRemoveDlg.cpp : implementation file
//

#include "stdafx.h"
#include "bandeditordll.h"
#include "Band.h"
#include "BandDlg.h"
#include "AddRemoveDlg.h"
#include "PChannelName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern DWORD dwaPriorities[];

/////////////////////////////////////////////////////////////////////////////
// CAddRemoveDlg dialog


CAddRemoveDlg::CAddRemoveDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAddRemoveDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddRemoveDlg)
	//}}AFX_DATA_INIT
}


void CAddRemoveDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddRemoveDlg)
	DDX_Control(pDX, IDC_PCHANNEL_SPIN, m_ChannelSpin);
	DDX_Control(pDX, IDC_CHANNEL_LIST, m_ChanListBox);
	DDX_Control(pDX, IDC_PCHANNEL_EDIT, m_ChannelEdit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddRemoveDlg, CDialog)
	//{{AFX_MSG_MAP(CAddRemoveDlg)
	ON_BN_CLICKED(IDC_ADD_BTN, OnAddBtn)
	ON_BN_CLICKED(IDC_REMOVE_BTN, OnRemoveBtn)
	ON_BN_CLICKED(IDCANCEL, OnCancel)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PCHANNEL_SPIN, OnDeltaposPchannelSpin)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddRemoveDlg::UpdateData
//
void CAddRemoveDlg::OnAddBtn() 
{
	// Do a sorted add to the list
	DWORD dwChannel = m_ChannelSpin.GetPos()-1;
	
	if(AddToChannels((int)dwChannel) == TRUE)
		PopulateChannelList();

	m_ChanListBox.SetSel(-1, FALSE);
	CString sChannelString;
	sChannelString.Format("%d", dwChannel + 1);
	int nChannelIndex = m_ChanListBox.FindStringExact(0, sChannelString);
	m_ChanListBox.SetSel(nChannelIndex);

	int nNextChannel = GetNextAvailablePChannel(dwChannel + 1);
	m_ChannelSpin.SetPos(nNextChannel);
}

void CAddRemoveDlg::OnRemoveBtn() 
{
	ASSERT(m_pBandDlg != NULL);

	if (m_ChanListBox.GetSelCount() <= 0)
		return;

	// Bring up a message box warning the user.
	if (m_ChanListBox.GetSelCount() > 0)
	{
		CString strWarning;
		strWarning.LoadString(IDS_REMOVEWARNING);
		CString strConfirm;
		strConfirm.LoadString(IDS_CONFIRM);
		if (MessageBox(strWarning, strConfirm, MB_YESNO | MB_ICONINFORMATION) == IDNO)
			return;
	}

	// Remove channels selected in the list
	for (int nCount = m_ChanListBox.GetCount() - 1; nCount >= 0; nCount--) 
	{
		if (m_ChanListBox.GetSel(nCount)) 
		{
			int nChannel = m_ChanListBox.GetItemData(nCount);			
			
			POSITION position = m_Channels.Find(nChannel);
			m_Channels.RemoveAt(position);

			m_ChanListBox.DeleteString(nCount);
		}
	}

}

BOOL CAddRemoveDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_ChannelEdit.SetLimitText(3);
	
	CloneChannels();
	// Fill dialog with data
	PopulateChannelList();

	CBand* pBand = m_pBandDlg->GetBand();
	ASSERT(pBand);
	DWORD dwfirstAvailableChannel = pBand->GetNextAvailablePChannel();

	m_ChannelSpin.SetRange(1, 999);
	m_ChannelSpin.SetPos(dwfirstAvailableChannel + 1);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddRemoveDlg::PopulateChannelList()
{
	m_ChanListBox.ResetContent();

	POSITION position = m_Channels.GetHeadPosition();
	while(position)
	{
		int nChannel = m_Channels.GetNext(position);

		CString sChannel;
		sChannel.Format("%d", nChannel + 1);
		
		int nIndex = m_ChanListBox.AddString(sChannel);
		if(nIndex != LB_ERR)
			m_ChanListBox.SetItemData(nIndex, nChannel);
	}
}


void CAddRemoveDlg::OnOK() 
{
	if (m_Channels.IsEmpty()) 
	{
		CString str;
		str.LoadString(IDS_ZERO_CHANNELS);
		MessageBox(str);
	}
	else 
	{
		m_pBandDlg->SaveStateForUndo("Add/Remove PChannel");

		POSITION position = m_Channels.GetHeadPosition();
		while(position)
		{
			int nChannel = m_Channels.GetNext(position);
			if(m_pBandDlg->GetBand()->GetInstrumentItemFromList(nChannel) == NULL)
			{
				AddPChannel(nChannel);
			}
		}
		
		position = m_pInstrumentList->GetHeadPosition();
		while(position)
		{
			CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*) m_pInstrumentList->GetNext(position);
			ASSERT(pInstrumentItem);
			
			CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
			ASSERT(pInstrument);

			if(pInstrument)
			{
				if(m_Channels.Find(pInstrument->dwPChannel) == NULL)
				{
					RemovePChannel(pInstrument->dwPChannel);
				}
			}

		}

		CBand* pBand = m_pBandDlg->GetBand();
		ASSERT(pBand);

		if(pBand)
		{
			m_pBandDlg->RefreshDisplay();
			pBand->SetModifiedFlag(TRUE);
			
			pBand->SendBand();
		}

		CDialog::OnOK();
	}
}


void CAddRemoveDlg::SetBandDialog(CBandDlg* pBandDlg)
{
	ASSERT(pBandDlg);

	m_pBandDlg = pBandDlg;
}

void CAddRemoveDlg::SetInstrumentList(CPtrList* pList)
{
	ASSERT(pList);

	m_pInstrumentList = pList;
	CloneChannels();
}

void CAddRemoveDlg::AddPChannel(int nChannel)
{
	CDMInstrument* pInstrument = new CDMInstrument();
	
	pInstrument->dwPChannel = nChannel;
	pInstrument->dwPatch = MAKE_PATCH(pInstrument->IsDrums(), 0, 0, 0);
	memset(pInstrument->dwNoteRanges,0,4 * sizeof(DWORD));
	pInstrument->dwFlags = (DMUS_IO_INST_GS | DMUS_IO_INST_GM);
	int nPriorityIndex = pInstrument->dwPChannel%16;
	pInstrument->dwChannelPriority = dwaPriorities[nPriorityIndex];
	pInstrument->nPitchBendRange = 2;
	pInstrument->SetComponent(m_pBandDlg->GetBand()->m_pComponent);
	pInstrument->SetBand(m_pBandDlg->GetBand());
	
	CInstrumentListItem* pNewInstrumentItem = new CInstrumentListItem(pInstrument);
	m_pBandDlg->GetBand()->InsertIntoInstrumentList(pNewInstrumentItem);

	// Every tenth channel in the group of 16 instruments is the drumkit
	if(pInstrument->dwPChannel != 9 && (pInstrument->dwPChannel)%16 != 9)
	{
		m_pBandDlg->m_MixGrid.AddButton((LPUNKNOWN)pNewInstrumentItem);
		m_pBandDlg->m_MixGrid.SetEnabled(pInstrument->dwPChannel, (pInstrument->dwFlags & DMUS_IO_INST_PATCH));
	}
	else
	{
			// Drums
		HBITMAP hBitmap = LoadBitmap( AfxGetResourceHandle(), MAKEINTRESOURCE( IDB_UDRUMS ) );
		m_pBandDlg->m_MixGrid.AddButton((LPUNKNOWN)pNewInstrumentItem);
		m_pBandDlg->m_MixGrid.SetEnabled(pInstrument->dwPChannel, (pInstrument->dwFlags & DMUS_IO_INST_PATCH));
		DeleteObject( hBitmap );
	}
	CBand* pBand = m_pBandDlg->GetBand();
	ASSERT(pBand);
	if(pBand)
	{
		pInstrument->Send(pBand, DM_PATCH_CHANGE);
		pInstrument->SendBandUpdate(pBand);
	}
}

void CAddRemoveDlg::OnCancel()
{
	m_Channels.RemoveAll();
	CDialog::OnCancel();
}


void CAddRemoveDlg::RemovePChannel(int nChannel)
{
	m_pBandDlg->m_MixGrid.RemoveButton(nChannel);

	CInstrumentListItem* pInstrumentItem = m_pBandDlg->GetBand()->GetInstrumentItemFromList(nChannel);
	ASSERT(pInstrumentItem);

	if(pInstrumentItem)
	{
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		CBand* pBand = m_pBandDlg->GetBand();
		ASSERT(pBand);
		if(pBand)
		{
			pInstrument->Send(pBand, DM_PATCH_CHANGE);
			pBand->DeleteFromInstrumentList(pInstrumentItem);
			pInstrument->SendBandUpdate(pBand);
		}
	}
}

void CAddRemoveDlg::CloneChannels()
{
	POSITION position = m_pInstrumentList->GetHeadPosition();

	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)m_pInstrumentList->GetNext(position);
		ASSERT(pInstrumentItem);
		
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		AddToChannels(pInstrument->dwPChannel);
	}
}

// Always sorted!
BOOL CAddRemoveDlg::AddToChannels(int nChannel)
{
	if(m_Channels.Find(nChannel) != NULL)
		return FALSE;

	POSITION position = m_Channels.GetHeadPosition();
	while(position)
	{
		int nListChannel = m_Channels.GetNext(position);

		if(nListChannel >= nChannel + 1)
		{
			POSITION matchPosition = m_Channels.Find(nListChannel);
			m_Channels.InsertBefore(matchPosition, nChannel);
			return TRUE;
		}
	}

	m_Channels.AddTail(nChannel);
	return TRUE;
}

void CAddRemoveDlg::OnDeltaposPchannelSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	int iCurrentPosition = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	CBand* pBand = m_pBandDlg->GetBand();
	ASSERT(pBand);

	int nNextChannel = -1;

	if(iDelta > 0)
	{
		nNextChannel = GetNextAvailablePChannel(iCurrentPosition);
	}
	else if(iDelta < 0)
	{
		nNextChannel = GetLastAvailablePChannel(iCurrentPosition);
	}
	
	if(nNextChannel >= 1)
		m_ChannelSpin.SetPos(nNextChannel);
	
	*pResult = 1;
}


int CAddRemoveDlg::GetNextAvailablePChannel(int nStartIndex)
{
	int  nHighestPChannelInList = 0;

	POSITION position = m_Channels.GetHeadPosition();
	int nLastPChannel = nStartIndex;
	
	while(position)
	{
		int nPChannelInList = m_Channels.GetNext(position) + 1;
		
		if(nLastPChannel < nPChannelInList - 1)		// If a vacant position
			return nLastPChannel + 1;						// Return the last position + 1

		if(nLastPChannel < nPChannelInList)
			nLastPChannel = nPChannelInList;

		if(nStartIndex <= nPChannelInList)
			nLastPChannel = nPChannelInList;

		if(nHighestPChannelInList < nLastPChannel)
			nHighestPChannelInList = nLastPChannel;
	}
	
	if(nLastPChannel == nStartIndex)
			nHighestPChannelInList = nLastPChannel;
	
	return (nHighestPChannelInList + 1);	
}

int	CAddRemoveDlg::GetLastAvailablePChannel(int nStartIndex)
{
	int  nHighestPChannelInList = 0;

	if((int)nStartIndex == 0)
		return 0;

	POSITION position = m_Channels.GetTailPosition();
	
	int nLastPChannel = (int)nStartIndex;

	// If there are no channels in use then we can go the whole range
	if(m_Channels.IsEmpty())
	{
		nLastPChannel--;
		nLastPChannel = nLastPChannel < 0 ? 0 : nLastPChannel;
		nLastPChannel = nLastPChannel > 998 ? 998 : nLastPChannel;
		return nLastPChannel;
	}

	while(position)
	{
		int nPChannelInList = m_Channels.GetPrev(position) + 1;

		if(nLastPChannel > nPChannelInList + 1) // If a vacant position
		{
			// The difference could be more than one pchannel
			// in which case return the closest to the highest on the list
			if(abs(nLastPChannel - nPChannelInList + 1) > 1)
				return nLastPChannel - 1;
			else
				return nPChannelInList + 1;
		}
		
		else if(nLastPChannel > nPChannelInList)
			nLastPChannel = nPChannelInList;
	}

	// None before were found so return the start index
	return -1;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabEffectInfo.cpp ===
// TabEffectInfo.cpp : implementation file
//

#include "stdafx.h"
#include "dsoundp.h"
#include "audiopathdesignerdll.h"
#include "TabEffectInfo.h"
#include "EffectPPGMgr.h"
#include "EffectInfo.h"
#include "RiffStrm.h"
#include "OlePropSheet.h"
#include "OlePropPage.h"
#include "AudioPathComponent.h"
#include "AudioPath.h"
#include "guiddlg.h"
#include "DlgSendProperties.h"
#include "mediaobj.h"
#define _SYS_GUID_OPERATORS_
#include "dmoreg.h"
#include "uuids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const IID IID_IMediaObject = _uuidof(IMediaObject);

/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo property page

IMPLEMENT_DYNCREATE(CTabEffectInfo, CPropertyPage)

void EmptyComboBox( CComboBox &comboBox )
{
	while( comboBox.GetCount() > 0 )
	{
		GUID *pGuid = static_cast<GUID *>(comboBox.GetItemDataPtr(0));
		if( pGuid )
		{
			delete pGuid;
		}
		comboBox.DeleteString( 0 );
	}
}

CTabEffectInfo::CTabEffectInfo() : CPropertyPage(CTabEffectInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabEffectInfo)
	//}}AFX_DATA_INIT
	m_fHaveValidData = false;
	m_fNeedToDetach = false;
	m_pIPropPageObject = NULL;
}

CTabEffectInfo::~CTabEffectInfo()
{
	// Weak reference:
	//RELEASE(m_pIPropPageObject);
}

void CTabEffectInfo::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabEffectInfo)
	DDX_Control(pDX, IDC_COMBO_SEND, m_comboSend);
	DDX_Control(pDX, IDC_EDIT_TYPE, m_editType);
	DDX_Control(pDX, IDC_EDIT_CUSTOMNAME, m_editCustomName);
	DDX_Control(pDX, IDC_CHECK_SOFTWARE, m_checkSoftware);
	DDX_Control(pDX, IDC_BUTTON_EDIT_PROPERTIES, m_btnEditProperties);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabEffectInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabEffectInfo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHECK_SOFTWARE, OnCheckSoftware)
	ON_BN_CLICKED(IDC_BUTTON_EDIT_PROPERTIES, OnButtonEditProperties)
	ON_EN_KILLFOCUS(IDC_EDIT_CUSTOMNAME, OnKillfocusEditCustomname)
	ON_CBN_SELCHANGE(IDC_COMBO_SEND, OnSelchangeComboSend)
	ON_BN_CLICKED(IDC_BUTTON_SEND_GUID, OnButtonSendGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo message handlers

BOOL CTabEffectInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pAudioPathComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->GetActivePage( &CEffectPPGMgr::sm_nActiveTab );
		RELEASE( pIPropSheet );
	}
	
	return CPropertyPage::OnSetActive();
}

int CTabEffectInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = true;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}

void CTabEffectInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	EmptyComboBox( m_comboSend );

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;

		m_fNeedToDetach = false;
	}

	CPropertyPage::OnDestroy();
}

BOOL CTabEffectInfo::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTabEffectInfo::OnCheckSoftware() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_fHaveValidData && m_pIPropPageObject );
	if( !m_fHaveValidData
	||	(m_pIPropPageObject == NULL) )
	{
		return;
	}

	if( m_checkSoftware.GetCheck() )
	{
		m_EffectInfoForPPG.m_dwFlags |= DSFX_LOCSOFTWARE;
	}
	else
	{
		m_EffectInfoForPPG.m_dwFlags &= ~DSFX_LOCSOFTWARE;
	}

	// Update the editor with the new information
	m_EffectInfoForPPG.m_dwChanged = CH_EFFECT_FLAGS;
	m_pIPropPageObject->SetData( &m_EffectInfoForPPG );
}

long GetLongFromStream( IStream *pStream )
{
	DWORD cbRead = 0;
	LONG lResult;
	if( pStream
	&&	SUCCEEDED( StreamSeek( pStream, 0, STREAM_SEEK_SET ) )
	&&	SUCCEEDED( pStream->Read( &lResult, sizeof(LONG), &cbRead ) )
	&&	(cbRead == sizeof(LONG)) )
	{
		return lResult;
	}
	return 0;
}

IStream *GetStreamFromLong( LONG lValue )
{
	// Try and create a stream
	IStream *pIStream;
	if( SUCCEEDED( ::CreateStreamOnHGlobal( NULL, TRUE, &pIStream ) ) )
	{
		// Try and write the long to the stream
		DWORD cbWritten;
		if( SUCCEEDED( pIStream->Write( &lValue, sizeof(LONG), &cbWritten ) )
		&&	(cbWritten == sizeof(LONG)) )
		{
			// Seek back to the start of the stream
			StreamSeek( pIStream, 0, STREAM_SEEK_SET );

			// Return the stream
			return pIStream;
		}
		pIStream->Release();
	}

	// Failed - return NULL
	return NULL;
}

void CTabEffectInfo::OnButtonEditProperties() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_fHaveValidData && m_pIPropPageObject );
	if( !m_fHaveValidData
	||	(m_pIPropPageObject == NULL) )
	{
		return;
	}

	// Check if this is a send effect
	if( m_EffectInfoForPPG.m_clsidObject == GUID_DSFX_SEND )
	{
		// Save initial value
		long lInitialValue = GetLongFromStream( m_EffectInfoForPPG.m_pIStream );

		// Initialize the dialog
		CDlgSendProperties dlgSendProperties;
		dlgSendProperties.m_lVolume = lInitialValue;

		// Calculate the dialog's title
		CString strSendDest, strSend;
		m_comboSend.GetWindowText( strSendDest );
		strSend.LoadString( IDS_SEND_TEXT );
		strSend += _T(": ") + strSendDest;
		dlgSendProperties.m_strTitle = strSend;

		// Display the dialog
		if( (dlgSendProperties.DoModal() == IDOK)
		&&	(dlgSendProperties.m_lVolume != lInitialValue) )
		{
			// Release the existing stream, if there is one
			if( m_EffectInfoForPPG.m_pIStream )
			{
				m_EffectInfoForPPG.m_pIStream->Release();
			}

			// Create a new steram to store the volume value in
			m_EffectInfoForPPG.m_pIStream = GetStreamFromLong( dlgSendProperties.m_lVolume );

			// Update the editor with the new information
			m_EffectInfoForPPG.m_dwChanged = CH_EFFECT_DATA;
			m_pIPropPageObject->SetData( &m_EffectInfoForPPG );
		}
		return;
	}

	// Try and create the effect, asking for an IMediaObject interface
	IMediaObject *pIMediaObject;
	if( FAILED( ::CoCreateInstance( m_EffectInfoForPPG.m_clsidObject, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void **)&pIMediaObject ) ) )
	{
		return;
	}

	// Set the default sample rate to 22050
	DWORD dwSampleRate = 22050;

	// Initialize the DMUS_AUDIOPARAMS structure
	DMUS_AUDIOPARAMS dmAudioParams;
	ZeroMemory( &dmAudioParams, sizeof( DMUS_AUDIOPARAMS ) );
	dmAudioParams.dwSize = sizeof( DMUS_AUDIOPARAMS );

	// Try and get the current performance audio params, and check if we got
	// the sample rate
	if( SUCCEEDED( theApp.m_pAudioPathComponent->m_pIConductor->GetAudioParams( &dmAudioParams ) )
	&&	(dmAudioParams.dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE) )
	{
		// Copy the sample rate, since it should be valid
		dwSampleRate = dmAudioParams.dwSampleRate;
	}

	// TODO: Set number of channels based on the buffer this effect is in
	const DWORD dwNumChannels = 1;
	WAVEFORMATEX waveFormat = {WAVE_FORMAT_PCM, dwNumChannels, dwSampleRate, dwSampleRate * 2 * dwNumChannels, 2 * dwNumChannels, 16, 0};

	DMO_MEDIA_TYPE dmt;
    ZeroMemory(&dmt, sizeof dmt);
    dmt.majortype               = MEDIATYPE_Audio;
    dmt.subtype                 = MEDIASUBTYPE_PCM;
    dmt.bFixedSizeSamples       = TRUE;
    dmt.bTemporalCompression    = FALSE;
    dmt.lSampleSize             = 2; // 16-bit samples
    dmt.formattype              = FORMAT_WaveFormatEx;
    dmt.cbFormat                = sizeof(WAVEFORMATEX);
    dmt.pbFormat                = PBYTE(&waveFormat);

	pIMediaObject->SetInputType(0, &dmt, 0);
	pIMediaObject->SetOutputType(0, &dmt, 0);

	// Ask for an IPersistStream interface
	IPersistStream *pIPersistStream;
	if( FAILED( pIMediaObject->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
	{
		pIMediaObject->Release();
		return;
	}

	pIMediaObject->Release();
	pIMediaObject = NULL;

	// Check if the effect has any data
	if( m_EffectInfoForPPG.m_pIStream )
	{
		// Seek back to the start of the stream
		if( SUCCEEDED( StreamSeek( m_EffectInfoForPPG.m_pIStream, 0 , STREAM_SEEK_SET ) ) )
		{
			// Try and load the effect
			pIPersistStream->Load( m_EffectInfoForPPG.m_pIStream );
		}
	}

	// Save the original state of the effect
	IStream *pIOriginalStream = NULL;
	if( SUCCEEDED( ::CreateStreamOnHGlobal( NULL, TRUE, &pIOriginalStream ) ) )
	{
		// Try and save the effect to a stream
		if( FAILED( pIPersistStream->Save( pIOriginalStream, TRUE ) ) )
		{
			pIOriginalStream->Release();
			pIOriginalStream = NULL;
		}
	}

	CString strTitle;
	strTitle= m_EffectInfoForPPG.m_strName + _T(" : ") + m_EffectInfoForPPG.m_strInstanceName;

	IDMUSProdUpdateObjectNow *pIDMUSProdUpdateObjectNow = NULL;
	m_pIPropPageObject->QueryInterface( IID_IDMUSProdUpdateObjectNow, (void**)&pIDMUSProdUpdateObjectNow );

	COlePropSheet *pPropSheet = new COlePropSheet( pIPersistStream, strTitle, pIDMUSProdUpdateObjectNow );
	if( pPropSheet )
	{
		int nResult = pPropSheet->DoModal();
		if( IDOK == nResult )
		{
			// Create a stream to store the effect's data in
			IStream *pIStream;
			if( SUCCEEDED( ::CreateStreamOnHGlobal( NULL, TRUE, &pIStream ) ) )
			{
				// Try and save the effect to a stream
				if( SUCCEEDED( pIPersistStream->Save( pIStream, TRUE ) ) )
				{
					// Seek back to the start of the stream
					if( SUCCEEDED( StreamSeek( pIStream, 0 , STREAM_SEEK_SET ) ) )
					{
						// Check if the data changed at all
						if( !StreamsAreEqual( pIStream, m_EffectInfoForPPG.m_pIStream ) )
						{
							// Data changed

							// Release the existing stream
							if( m_EffectInfoForPPG.m_pIStream )
							{
								m_EffectInfoForPPG.m_pIStream->Release();
								m_EffectInfoForPPG.m_pIStream = NULL;
							}

							// Clone the stream for the EffectInfo
							VERIFY( SUCCEEDED( pIStream->Clone( &m_EffectInfoForPPG.m_pIStream ) ) );

							// Update the editor with the new information
							m_EffectInfoForPPG.m_dwChanged = CH_EFFECT_DATA;
							m_pIPropPageObject->SetData( &m_EffectInfoForPPG );
						}
					}
				}

				// Release the stream
				pIStream->Release();
			}
		}
		else
		{
			// Ensure the object is reset to its old state
			if( pIDMUSProdUpdateObjectNow )
			{
				// Check if there is an original state stream
				if( pIOriginalStream )
				{
					// Seek back to the start of the stream
					if( SUCCEEDED( StreamSeek( pIOriginalStream, 0 , STREAM_SEEK_SET ) ) )
					{
						// Try and load the object with the stream
						if( SUCCEEDED( pIPersistStream->Load( pIOriginalStream ) ) )
						{
							pIDMUSProdUpdateObjectNow->UpdateObjectNow( pIPersistStream );
						}
					}
				}
			}
		}
	}

	// Release the object's original state stream
	if( pIOriginalStream )
	{
		pIOriginalStream->Release();
	}

	// Release the object's IDMUSProdUpdateObjectNow interface
	if( pIDMUSProdUpdateObjectNow )
	{
		pIDMUSProdUpdateObjectNow->Release();
	}

	// Release the effect's IPersistStream interface
	pIPersistStream->Release();
}

void CTabEffectInfo::OnKillfocusEditCustomname() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_fHaveValidData && m_pIPropPageObject );
	if( !m_fHaveValidData
	||	(m_pIPropPageObject == NULL) )
	{
		return;
	}

	CString strNewText;
	m_editCustomName.GetWindowText( strNewText );

	// Strip leading and trailing spaces
	strNewText.TrimLeft();
	strNewText.TrimRight();

	if( strNewText.IsEmpty() )
	{
		m_editCustomName.SetWindowText( m_EffectInfoForPPG.m_strInstanceName );
		return;
	}

	m_EffectInfoForPPG.m_strInstanceName = strNewText;

	// Update the editor with the new information
	m_EffectInfoForPPG.m_dwChanged = CH_EFFECT_NAME;
	m_pIPropPageObject->SetData( &m_EffectInfoForPPG );
}


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo::SetEffect

void CTabEffectInfo::SetEffect( EffectInfoForPPG* pEffectInfo, IDMUSProdPropPageObject* pIPropPageObject )
{
	m_pIPropPageObject = pIPropPageObject;
	if( (pEffectInfo == NULL)
	||	(pIPropPageObject == NULL) )
	{
		m_fHaveValidData = false;
	}
	else
	{
		m_fHaveValidData = true;
		m_EffectInfoForPPG.Copy( *pEffectInfo );
	}

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo::EnableControls

void CTabEffectInfo::EnableControls( bool fEnable ) 
{
	// Check if this is a send effect
	if( m_EffectInfoForPPG.m_clsidObject == GUID_DSFX_SEND )
	{
		m_editCustomName.EnableWindow( FALSE );
	}
	else
	{
		m_editCustomName.EnableWindow( fEnable );
	}
	m_editType.EnableWindow( fEnable );

	// If this is a send effect (or an I3DL2 source effect)
	if( fEnable
	&&	((m_EffectInfoForPPG.m_clsidObject == GUID_DSFX_SEND)
		 /*|| (m_EffectInfoForPPG.m_clsidObject == GUID_DSFX_STANDARD_I3DL2SOURCE)*/) )
	{
		// Show the send options
		EnableDlgItem( IDC_STATIC_SEND, TRUE );
		ShowDlgItem( IDC_STATIC_SEND, SW_SHOWNA );
		ShowDlgItem( IDC_BUTTON_SEND_GUID, SW_SHOWNA );
		m_comboSend.ShowWindow( SW_SHOWNA );

		// Disable the 'Always Process in Software' checkbox
		m_checkSoftware.EnableWindow( FALSE );
	}
	else
	{
		// Hide the send options
		EnableDlgItem( IDC_STATIC_SEND, FALSE );
		EnableDlgItem( IDC_BUTTON_SEND_GUID, FALSE );
		m_comboSend.EnableWindow( FALSE );
		ShowDlgItem( IDC_STATIC_SEND, SW_HIDE );
		ShowDlgItem( IDC_BUTTON_SEND_GUID, SW_HIDE );
		m_comboSend.ShowWindow( SW_HIDE );

		// Possibly enable the 'Always Process in Software' checkbox
		m_checkSoftware.EnableWindow( fEnable );
	}

	// Check if the effect has any property pages
	if( fEnable
	&&	(m_EffectInfoForPPG.m_clsidObject != GUID_DSFX_SEND) ) // Always enable the send effect
	{
		// Initialize to false
		fEnable = false;

		// Try and create the effect, asking for an ISpecifyPropertyPages interface
		ISpecifyPropertyPages *pISpecifyPropertyPages;
		if( SUCCEEDED( ::CoCreateInstance( m_EffectInfoForPPG.m_clsidObject, NULL, CLSCTX_INPROC_SERVER, IID_ISpecifyPropertyPages, (void **)&pISpecifyPropertyPages ) ) )
		{
			CAUUID cauuid;
			if( SUCCEEDED( pISpecifyPropertyPages->GetPages( &cauuid ) ) )
			{
				// At least one property page exists, enable the button
				if( cauuid.cElems > 0 )
				{
					for( ULONG i=0; !fEnable && (i < cauuid.cElems); i++ )
					{
						IPropertyPage *pIPropertyPage;
						if( SUCCEEDED( ::CoCreateInstance( cauuid.pElems[i], NULL, CLSCTX_INPROC_SERVER, IID_IPropertyPage, (void **)&pIPropertyPage ) ) )
						{
							fEnable = true;
							pIPropertyPage->Release();
						}
					}
				}
				::CoTaskMemFree( cauuid.pElems );
			}
			pISpecifyPropertyPages->Release();
		}
	}
	m_btnEditProperties.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo::UpdateControls

void CTabEffectInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editCustomName.m_hWnd) == FALSE )
	{
		return;
	}

	// Update controls
	m_editCustomName.LimitText( DMUS_MAX_NAME );

	// Empty the combo box
	EmptyComboBox( m_comboSend );

	if( m_fHaveValidData && m_pIPropPageObject )
	{
		EnableControls( true );

		// Check if this is a send effect
		if( m_EffectInfoForPPG.m_clsidObject == GUID_DSFX_SEND )
		{
			// Set name
			m_editCustomName.SetWindowText( NULL );
		}
		else
		{
			// Set name
			m_editCustomName.SetWindowText( m_EffectInfoForPPG.m_strInstanceName );
		}

		// Get the effect type
		m_editType.SetWindowText( m_EffectInfoForPPG.m_strName );

		// Set the flags
		m_checkSoftware.SetCheck( (m_EffectInfoForPPG.m_dwFlags & DSFX_LOCSOFTWARE) ? 1 : 0 );

		// If a send effect, update the send combobox and 'edit guid' button
		// If an I3DL2 source, update the send combobox and 'edit guid' button
		if( (m_EffectInfoForPPG.m_clsidObject == GUID_DSFX_SEND)
		/*||	(m_EffectInfoForPPG.m_clsidObject == GUID_DSFX_STANDARD_I3DL2SOURCE)*/ )
		{
			// Create the variables to use when iterating through the buffers
			CString strName;
			WCHAR wcstrBufferName[DMUS_MAX_NAME + 1];

			// Flag when we find the buffer
			bool fFoundBuffer = false;

			// Flag when we find our audiopath
			bool fFoundOurAudiopath = false;

			// Iterate through all audiopaths
			POSITION pos = theApp.m_pAudioPathComponent->m_lstAudioPaths.GetHeadPosition();
			while( pos )
			{
				// Get a pointer to each audiopath
				CDirectMusicAudioPath *pAudioPath = theApp.m_pAudioPathComponent->m_lstAudioPaths.GetNext( pos );

				// Copy the name
				strName = pAudioPath->m_strName;

				// Iterate through all mixin buffers
				DWORD dwIndex = 0;
				while( true )
				{
					// Create a new guid to store the buffer's GUID
					GUID *pguidBuffer = new GUID;

					// Ensure we could allocate memory
					if( pguidBuffer == NULL )
					{
						break;
					}

					// Try and enumerate a buffer
					if( FAILED( pAudioPath->EnumBufferInfo( dwIndex, wcstrBufferName, pguidBuffer ) ) )
					{
						delete pguidBuffer;
						break;
					}

					// Skip Environmental reverb buffers and our buffer
					if( (GUID_Buffer_EnvReverb == *pguidBuffer)
					||	(m_EffectInfoForPPG.m_guidMyBuffer == *pguidBuffer) )
					{
						delete pguidBuffer;
						dwIndex++;
						continue;
					}

					// Create the name to display
					CString strDisplayName;
					if( pAudioPath != m_EffectInfoForPPG.m_pAudioPath )
					{
						strDisplayName = strName + _T(": ") + CString( wcstrBufferName );
					}
					else
					{
						fFoundOurAudiopath = true;
						strDisplayName = CString( wcstrBufferName );
					}

					// Add the name to the combobox
					int nPos = m_comboSend.AddString( strDisplayName );

					// Point the name at the GUID
					m_comboSend.SetItemDataPtr( nPos, pguidBuffer );

					// Check if this is the buffer we're looking for
					if( *pguidBuffer == m_EffectInfoForPPG.m_clsidSendBuffer )
					{
						m_comboSend.SetCurSel( nPos );
						EnableDlgItem( IDC_BUTTON_SEND_GUID, FALSE );
						fFoundBuffer = true;
					}

					// Increment the buffer index
					dwIndex++;
				}
			}

			// If we didn't find our audiopath, we must be embedded in a segment
			if( !fFoundOurAudiopath )
			{
				// Add the buffers from this audiopath to the dropdown

				// Copy the name
				strName = m_EffectInfoForPPG.m_pAudioPath->m_strName;

				// Iterate through all mixin buffers
				DWORD dwIndex = 0;
				while( true )
				{
					// Create a new guid to store the buffer's GUID
					GUID *pguidBuffer = new GUID;

					// Ensure we could allocate memory
					if( pguidBuffer == NULL )
					{
						break;
					}

					// Try and enumerate a buffer
					if( FAILED( m_EffectInfoForPPG.m_pAudioPath->EnumBufferInfo( dwIndex, wcstrBufferName, pguidBuffer ) ) )
					{
						delete pguidBuffer;
						break;
					}

					// Skip Environmental reverb buffers and our buffer
					if( (GUID_Buffer_EnvReverb == *pguidBuffer)
					||	(m_EffectInfoForPPG.m_guidMyBuffer == *pguidBuffer) )
					{
						delete pguidBuffer;
						dwIndex++;
						continue;
					}

					// Create the name to display
					CString strDisplayName;
					strDisplayName = CString( wcstrBufferName );

					// Add the name to the combobox
					int nPos = m_comboSend.AddString( strDisplayName );

					// Point the name at the GUID
					m_comboSend.SetItemDataPtr( nPos, pguidBuffer );

					// Check if this is the buffer we're looking for
					if( *pguidBuffer == m_EffectInfoForPPG.m_clsidSendBuffer )
					{
						m_comboSend.SetCurSel( nPos );
						EnableDlgItem( IDC_BUTTON_SEND_GUID, FALSE );
						fFoundBuffer = true;
					}

					// Increment the buffer index
					dwIndex++;
				}
			}

			// Add the 'Environmental Reverb' text
			if( strName.LoadString( IDS_BUFFER_ENVREVERB ) )
			{
				// Create a new guid to store the buffer's GUID
				GUID *pguidBuffer = new GUID;

				// Ensure we could allocate memory
				if( pguidBuffer != NULL )
				{
					// Copy the GUID
					memcpy( pguidBuffer, &GUID_Buffer_EnvReverb, sizeof(GUID) );

					// Add the buffer text
					int nPos = m_comboSend.AddString( strName );

					// Point it at the EnvReverb GUID
					m_comboSend.SetItemDataPtr( nPos, pguidBuffer );

					// Check if this is the buffer we're looking for
					if( GUID_Buffer_EnvReverb == m_EffectInfoForPPG.m_clsidSendBuffer )
					{
						m_comboSend.SetCurSel( nPos );
						EnableDlgItem( IDC_BUTTON_SEND_GUID, FALSE );
						fFoundBuffer = true;
					}
				}
			}

			// Add the 'Other...' text
			if( strName.LoadString( IDS_SEND_OTHER ) )
			{
				int nPos = m_comboSend.AddString( strName );

				// Point it at a NULL GUID
				m_comboSend.SetItemDataPtr( nPos, NULL );

				// If we didn't find the buffer
				if( !fFoundBuffer )
				{
					m_comboSend.SetCurSel( nPos );
					EnableDlgItem( IDC_BUTTON_SEND_GUID, TRUE );
				}
			}

			// Disable the 'Edit GUID' button if we found the buffer
			EnableDlgItem( IDC_BUTTON_SEND_GUID, fFoundBuffer ? FALSE : TRUE );

			// Enable the combobox
			m_comboSend.EnableWindow( TRUE );
		}
	}
	else
	{
		m_editCustomName.SetWindowText( _T("") );
		m_editType.SetWindowText( _T("") );
		m_checkSoftware.SetCheck( 0 );

		EnableControls( false );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo::OnSelchangeComboSend

void CTabEffectInfo::OnSelchangeComboSend() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nSel = m_comboSend.GetCurSel();
	if( nSel != CB_ERR )
	{
		GUID *pGuid = static_cast<GUID *>(m_comboSend.GetItemDataPtr(nSel));
		if( pGuid )
		{
			memcpy( &m_EffectInfoForPPG.m_clsidSendBuffer, pGuid, sizeof(GUID) );

			// Update the editor with the new information
			m_EffectInfoForPPG.m_dwChanged = CH_EFFECT_SEND;
			m_pIPropPageObject->SetData( &m_EffectInfoForPPG );

			// Disable the 'Edit GUID' button
			EnableDlgItem( IDC_BUTTON_SEND_GUID, FALSE );
		}
		else
		{
			// Save a copy of the old GUID
			const GUID oldGuid = m_EffectInfoForPPG.m_clsidSendBuffer;

			// Display the 'Edit GUID' dialog
			OnButtonSendGuid();

			// Check if the GUID changed
			if( oldGuid == m_EffectInfoForPPG.m_clsidSendBuffer )
			{
				// No change - reset the combobox
				UpdateControls();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo::OnButtonSendGuid

void CTabEffectInfo::OnButtonSendGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CGuidDlg dlg;

	memcpy( &dlg.m_guid, &m_EffectInfoForPPG.m_clsidSendBuffer, sizeof(GUID) );

	if( dlg.DoModal() == IDOK )
	{
		memcpy( &m_EffectInfoForPPG.m_clsidSendBuffer, &dlg.m_guid, sizeof(GUID) );

		// Update the editor with the new information
		m_EffectInfoForPPG.m_dwChanged = CH_EFFECT_SEND;
		m_pIPropPageObject->SetData( &m_EffectInfoForPPG );

		// Update the combobox selection
		UpdateControls();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo::EnableDlgItem

void CTabEffectInfo::EnableDlgItem( int nItem, BOOL fEnable )
{
	CWnd* pWnd = GetDlgItem( nItem );
	if( pWnd )
	{
		pWnd->EnableWindow( fEnable );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabEffectInfo::ShowDlgItem

void CTabEffectInfo::ShowDlgItem( int nItem, int nCmdShow )
{
	CWnd* pWnd = GetDlgItem( nItem );
	if( pWnd )
	{
		pWnd->ShowWindow( nCmdShow );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TabMixGroup.h ===
#if !defined(AFX_TABMIXGROUP_H__A37594BC_7317_4208_9B0E_A53431BE06A8__INCLUDED_)
#define AFX_TABMIXGROUP_H__A37594BC_7317_4208_9B0E_A53431BE06A8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TabMixGroup.h : header file
//

#include "resource.h"
#include "MixGroupPPGMgr.h"

/////////////////////////////////////////////////////////////////////////////
// CTabMixGroup dialog

class CTabMixGroup : public CPropertyPage
{
	DECLARE_DYNCREATE(CTabMixGroup)

// Construction
public:
	CTabMixGroup();
	~CTabMixGroup();

// Dialog Data
	//{{AFX_DATA(CTabMixGroup)
	enum { IDD = IDD_TAB_MIXGROUP };
	CButton	m_groupSynth;
	CButton	m_buttonSynth;
	CEdit	m_editMixGroupName;
	CComboBox	m_comboSynth;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabMixGroup)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Access functions
public:
	void SetItem( MixGroupInfoForPPG* pMixGroupInfoForPPG, IDMUSProdPropPageObject* pINewPropPageObject );

// Attributes
protected:
	MixGroupInfoForPPG	m_MixGroupInfoForPPG;
	IDMUSProdPropPageObject* m_pIPropPageObject;
	bool			m_fNeedToDetach;

// Implementation
protected:
	void UpdateControls();
	void EnableControls( bool fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabMixGroup)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonSynth();
	afx_msg void OnKillfocusEditMixgroupName();
	afx_msg void OnSelchangeComboSynth();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABMIXGROUP_H__A37594BC_7317_4208_9B0E_A53431BE06A8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TreeDroptarget.cpp ===
// TreeDropTarget.cpp : implementation file
// For OLE Drag and Drop between tree controls
// Designed and developed by Vinayak Tadas
// vinayakt@aditi.com
// Modified for use in DirectMusic Producer by James Dooley
// jdooley@microsoft.com
// 

#include "stdafx.h"
#include "TreeDroptarget.h"
#include "MultiTree.h"
#include "AudioPathDlg.h"
#include "AudioPath.h"
#include "EffectListDlg.h"
#include "DllJazzDataObject.h"

#define RECT_BORDER	10

/////////////////////////////////////////////////////////////////////////////
// CTreeDropTarget

CTreeDropTarget::CTreeDropTarget()
{
	m_pITargetDataObject = NULL;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_cRef = 0;
	AddRef();
}

HRESULT CTreeDropTarget::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualIID(riid, IID_IDropTarget)
	||	::IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IDropTarget *)this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CTreeDropTarget::AddRef( void )
{
	return InterlockedIncrement( &m_cRef );
}

ULONG CTreeDropTarget::Release( void )
{
	const long lRes = InterlockedDecrement( &m_cRef );
	if( lRes == 0 )
	{
		delete this;
	}

	return lRes;
}

/********************************************************************
OnDragEnter()
	Called when the user drags the object in Tree control.
********************************************************************/
HRESULT CTreeDropTarget::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Release the target data object, if we haven't already done so (we should have)
	RELEASE( m_pITargetDataObject );

	// Validate the pointer to the IDataObject
	if( pIDataObject )
	{
		// Store IDataObject associated with current drag-drop operation
		m_pITargetDataObject = pIDataObject;
		m_pITargetDataObject->AddRef();

		// Determine effect of drop
		return DragOver( grfKeyState, point, pdwEffect );
	}
	else
	{
		return E_POINTER;
	}
}

/********************************************************************
OnDragOver()
	Called when the user drags the object over Tree control.
********************************************************************/
		
HRESULT CTreeDropTarget::DragOver( DWORD grfKeyState, POINTL pointl, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate our pointers
	if( (m_pAudioPathDlg == NULL)
	||	(m_pITargetDataObject == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Highlight the item under the mouse and 
	CMultiTree *pDestTreeCtrl = &(m_pAudioPathDlg->m_tcTree);
	POINT point = {pointl.x, pointl.y};
	pDestTreeCtrl->ScreenToClient( &point );

	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	pDestTreeCtrl->GetItemBufferEffectUnderPoint( point, &pItemInfo, &pBufferOptions, NULL );
	
	// Scroll Tree control depending on mouse position
	CRect rectClient;
	pDestTreeCtrl->GetClientRect(&rectClient);
	pDestTreeCtrl->ClientToScreen(rectClient);
	pDestTreeCtrl->ClientToScreen(&point);
	int nScrollDir = -1;
	if ( point.y >= rectClient.bottom - RECT_BORDER)
		nScrollDir = SB_LINEDOWN;
	else
	if ( (point.y <= rectClient.top + RECT_BORDER) )
		nScrollDir = SB_LINEUP;

	
	if ( nScrollDir != -1 ) 
	{
		int nScrollPos = pDestTreeCtrl->GetScrollPos(SB_VERT);
		WPARAM wParam = MAKELONG(nScrollDir, nScrollPos);
		pDestTreeCtrl->SendMessage(WM_VSCROLL, wParam);
	}
	
	nScrollDir = -1;
	if ( point.x <= rectClient.left + RECT_BORDER )
		nScrollDir = SB_LINELEFT;
	else
	if ( point.x >= rectClient.right - RECT_BORDER)
		nScrollDir = SB_LINERIGHT;
	
	if ( nScrollDir != -1 ) 
	{
		int nScrollPos = pDestTreeCtrl->GetScrollPos(SB_VERT);
		WPARAM wParam = MAKELONG(nScrollDir, nScrollPos);
		pDestTreeCtrl->SendMessage(WM_HSCROLL, wParam);
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject )
	{
		if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( m_pITargetDataObject, CDirectMusicAudioPath::m_scfEffect ) ) )
		{
			if( ItemAndBufferSupportEffects( pItemInfo, pBufferOptions ) )
			{
				dwEffect = DROPEFFECT_COPY;
			}
		}
		else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, CDirectMusicAudioPath::m_scfPChannel ) ) )
		{
			if ( grfKeyState & MK_SHIFT )
			{
				dwEffect = DROPEFFECT_MOVE;
			}
			else
			{
				dwEffect = DROPEFFECT_COPY;
			}
		}

		delete pDataObject;
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/********************************************************************
OnDragLeave()
	Called when the user drags the object out of Tree control.
********************************************************************/
HRESULT CTreeDropTarget::DragLeave( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate our pointer
	if( m_pAudioPathDlg == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Release our pointer to the object being dragged
	RELEASE( m_pITargetDataObject );

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	// Remove Highlighting 
	//m_pAudioPathDlg->m_tcTree.SendMessage(TVM_SELECTITEM, TVGN_DROPHILITE,0);

	return S_OK;
}


/********************************************************************
OnDrop()
	Called when the user drops the object in the  Tree control.
********************************************************************/
HRESULT CTreeDropTarget::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(grfKeyState);

	if( (pdwEffect == NULL)
	||	(pIDataObject == NULL) )
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	// Validate our pointer
	if( m_pAudioPathDlg == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//Remove highlighting
	//m_pAudioPathDlg->m_tcTree.SendMessage(TVM_SELECTITEM, TVGN_DROPHILITE,0);

	POINT ptShort = {point.x, point.y};
	m_pAudioPathDlg->m_tcTree.ScreenToClient( &ptShort );

	HRESULT hr = m_pAudioPathDlg->DropOnTree( pIDataObject, m_dwOverDragEffect, ptShort );

	*pdwEffect = m_dwOverDragEffect;

	// Release the target data object, if we haven't already done so (we should have)
	RELEASE( m_pITargetDataObject );

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\AddRemoveDlg.h ===
#if !defined(AFX_ADDREMOVEDLG_H__B603A605_2231_11D2_850F_00A0C99F7E74__INCLUDED_)
#define AFX_ADDREMOVEDLG_H__B603A605_2231_11D2_850F_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddRemoveDlg.h : header file
//

#include <afxtempl.h>


/////////////////////////////////////////////////////////////////////////////
// CAddRemoveDlg dialog

class CAddRemoveDlg : public CDialog
{
// Construction
public:
	CAddRemoveDlg(CWnd* pParent = NULL);   // standard constructor

	void SetBandDialog(CBandDlg* pBandDlg);
	void SetInstrumentList(CPtrList* pList);

	CPtrList* m_pInstrumentList;

	
// Dialog Data
	//{{AFX_DATA(CAddRemoveDlg)
	enum { IDD = IDD_ADDREMOVE };
	CSpinButtonCtrl	m_ChannelSpin;
	CListBox	m_ChanListBox;
	CEdit		m_ChannelEdit;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddRemoveDlg)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddRemoveDlg)
	afx_msg void OnAddBtn();
	afx_msg void OnRemoveBtn();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnDeltaposPchannelSpin(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Operations
private:
	BOOL	AddToChannels(int nChannel);
	void	AddPChannel(int nChannel);
	void	RemovePChannel(int nChannel);
	void	CloneChannels();
	CString GetPChannelName(CDMInstrument* pInstrument);
	void	PopulateChannelList();
	int		GetNextAvailablePChannel(int nStartIndex);
	int		GetLastAvailablePChannel(int nStartIndex);


// Attributes
private:
	CBandDlg* m_pBandDlg;
	CList<int, int> m_Channels;		
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDREMOVEDLG_H__B603A605_2231_11D2_850F_00A0C99F7E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\AudioPathDesigner\TreeDroptarget.h ===
// TreeDropTarget.h
// For OLE Drag and Drop between tree controls
// Designed and developed by Vinayak Tadas
// vinayakt@aditi.com
// 

#if !defined(AFX_TREEDROPTARGET_H__246241C3_897C_11D3_A59E_00A02411D21E__INCLUDED_)
#define AFX_TREEDROPTARGET_H__246241C3_897C_11D3_A59E_00A02411D21E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TreeDropTarget.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTreeDropTarget

class CAudioPathDlg;

class CTreeDropTarget :public IDropTarget	
{
public:
	CTreeDropTarget();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL point, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect);

// Members
public:
	CAudioPathDlg	*m_pAudioPathDlg;

private:
	IDataObject		*m_pITargetDataObject;
	DWORD			m_dwOverDragButton;
	DWORD			m_dwOverDragEffect;
	long			m_cRef;

};
/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_TREEDROPTARGET_H__246241C3_897C_11D3_A59E_00A02411D21E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandAboutBox.h ===
#if !defined(AFX_BANDABOUTBOX_H__1B9DF6D3_020A_11D1_BAF1_00805F493F43__INCLUDED_)
#define AFX_BANDABOUTBOX_H__1B9DF6D3_020A_11D1_BAF1_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// BandAboutBox.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBandAboutBox dialog

class CBandAboutBox : public CDialog
{
// Construction
public:
	CBandAboutBox(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CBandAboutBox)
	enum { IDD = IDD_ABOUTBOX_BAND };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBandAboutBox)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBandAboutBox)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BANDABOUTBOX_H__1B9DF6D3_020A_11D1_BAF1_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandAboutBox.cpp ===
// BandAboutBox.cpp : implementation file
//

#include "stdafx.h"
#include "BandEditorDLL.h"
#include "BandAboutBox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBandAboutBox dialog


CBandAboutBox::CBandAboutBox(CWnd* pParent /*=NULL*/)
	: CDialog(CBandAboutBox::IDD, pParent)
{
	//{{AFX_DATA_INIT(CBandAboutBox)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CBandAboutBox::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBandAboutBox)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBandAboutBox, CDialog)
	//{{AFX_MSG_MAP(CBandAboutBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBandAboutBox message handlers

BOOL CBandAboutBox::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achJazzExeName[MAX_PATH + 1];
	TCHAR achFileVersion[MAX_PATH];

	if( GetModuleFileName ( theApp.m_hInstance, achJazzExeName, MAX_PATH ) )
	{
		if( theApp.GetFileVersion( achJazzExeName, achFileVersion, MAX_PATH ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_BAND_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\Band.h ===
#ifndef __BAND_H__
#define __BAND_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Band.h : header file
//

#include "BandComponent.h"
#include "BandDocType.h"
#include "TabBand.h"
#include "RiffStrm.h"
#include "dmusici.h"
#include "dmusicf.h"

#define DMUS_PATCH (DMUS_IO_INST_BANKSELECT | DMUS_IO_INST_PATCH)

#define DM_PATCH_CHANGE		DMUS_PMSGT_PATCH
#define DM_TRANSPOSE		DMUS_PMSGT_TRANSPOSE
#define DM_PITCHBEND_RANGE	DMUS_PMSGT_CURVE
#define DM_VOLUME			(DM_TRANSPOSE + 1)
#define DM_PAN				(DM_VOLUME + 1)

#define MIDI_PROGRAM_CHANGE 0xc0
#define MIDI_CONTROL_CHANGE 0xb0
#define MIDI_CC_BS_MSB		0x00
#define MIDI_CC_BS_LSB		0x20
#define MIDI_CC_VOLUME		0x07
#define MIDI_CC_PAN 		0x0a

#define DRUM_TRACK			10
#define DRUM_PCHANNEL		9


static DWORD dwaPriorities[NBR_IMA_INSTRUMENTS] = { DAUD_CHAN1_DEF_VOICE_PRIORITY, DAUD_CHAN2_DEF_VOICE_PRIORITY,
													DAUD_CHAN3_DEF_VOICE_PRIORITY, DAUD_CHAN4_DEF_VOICE_PRIORITY, 
													DAUD_CHAN5_DEF_VOICE_PRIORITY, DAUD_CHAN6_DEF_VOICE_PRIORITY,
													DAUD_CHAN7_DEF_VOICE_PRIORITY, DAUD_CHAN8_DEF_VOICE_PRIORITY,
													DAUD_CHAN9_DEF_VOICE_PRIORITY, DAUD_CHAN10_DEF_VOICE_PRIORITY,
													DAUD_CHAN11_DEF_VOICE_PRIORITY, DAUD_CHAN12_DEF_VOICE_PRIORITY,
													DAUD_CHAN13_DEF_VOICE_PRIORITY, DAUD_CHAN14_DEF_VOICE_PRIORITY,
													DAUD_CHAN15_DEF_VOICE_PRIORITY, DAUD_CHAN16_DEF_VOICE_PRIORITY};

static DWORD dwaPriorityLevels[5] = { DAUD_CRITICAL_VOICE_PRIORITY, DAUD_HIGH_VOICE_PRIORITY,     
									  DAUD_STANDARD_VOICE_PRIORITY, DAUD_LOW_VOICE_PRIORITY };  


/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler window

class CContextMenuHandler : public CWnd
{
// Construction
public:
	CContextMenuHandler();

// Attributes
public:
	class CBand *m_pBand;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContextMenuHandler)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CContextMenuHandler();

	// Generated message map functions
protected:
	//{{AFX_MSG(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CLinkedDLSCollection

class CLinkedDLSCollection
{
// Constructor
public:
	CLinkedDLSCollection( IDMUSProdNode* pIDocRootNode );
	virtual ~CLinkedDLSCollection();

// Attributes
public:
	IDMUSProdNode*	m_pIDocRootNode;
	DWORD			m_dwUseCount;
};


//////////////////////////////////////////////////////////////////////
//	CBandPropPageManager

class CBandPropPageManager : public CDllBasePropPageManager 
{
friend class CTabBand;

public:
	CBandPropPageManager();
	virtual ~CBandPropPageManager();

	// IDMUSProdPropPageManager functions
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
	HRESULT STDMETHODCALLTYPE RefreshData();

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CTabBand*			m_pTabBand;
};


class CDMInstrument : public DMUS_IO_INSTRUMENT
{
friend class CBand;
friend class CBandDlg;
friend class CInstrumentListItem;
friend class CCommonInstrumentPropertyObject;

protected:
	CString 					m_csCollection;
private:
	CBand*						m_pBand;
	CBandComponent* 			m_pComponent;
	IDMUSProdReferenceNode* 	m_pDMReference;
	bool						m_fSelected;		// This flag is used to save the selection info in DesignTime save

	static BOOL					m_bSendBandUpdate;

public:
	CDMInstrument();
	~CDMInstrument();
	CDMInstrument&	operator = (const CDMInstrument& dmInstrument);

	void						ResetInstruemnt();
	bool						IsDrums();
	HRESULT 					Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT 					Save(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT 					SaveFileRef(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT 					SaveDMRef(IDMUSProdRIFFStream* pIRiffStream, WhichLoader whichLoader );
	void						SetComponent(CBandComponent* pComponent) {m_pComponent = pComponent;}
	CBandComponent* 			GetComponent() {return m_pComponent;}
	void						SetBand(CBand* pBand) {m_pBand = pBand;}
	CBand*						GetBand() {return m_pBand;}
	BOOL						SendBandUpdate(IDMUSProdNode* pIBandnode);
	HRESULT 					Send(IDMUSProdNode* pIBandNode, UINT uMsgType);

	void						SetDLSCollection( IDMUSProdReferenceNode* pDMReferenceNode );
};


class CInstrumentListItem : public IDMUSProdBandPChannel
{
public:
	CInstrumentListItem();
	CInstrumentListItem(CDMInstrument* pInstrument);
	
	~CInstrumentListItem();

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDMUSProdBandPChannel methods
	HRESULT STDMETHODCALLTYPE GetPChannelNumber(int* pnNumber);
	HRESULT STDMETHODCALLTYPE GetVolume(int* pnVolume);
	HRESULT STDMETHODCALLTYPE GetPan(int* pnPan);

	HRESULT STDMETHODCALLTYPE SetVolume(int nVolume);
	HRESULT STDMETHODCALLTYPE SetPan(int nPan);
	
	HRESULT STDMETHODCALLTYPE IsSelected(BOOL* pfSelected);
	HRESULT STDMETHODCALLTYPE SetSelected(BOOL fSelection);

	HRESULT STDMETHODCALLTYPE IsEnabled(BOOL* pbEnabled);

	HRESULT STDMETHODCALLTYPE SyncChanges(BOOL bSendBandUpdate);


	// Other methoda
	void SetInstrument(CDMInstrument* pInstrument);
	CDMInstrument* GetInstrument();

	void SetSelected(bool bSelectionFlag);
	void SetSelected();
	bool IsSelected();

	static CCommonInstrumentPropertyObject m_CommonPropertyObject;

private:
	DWORD			m_dwRef;
	bool			m_fSelected;
	CDMInstrument*	m_pInstrument;
};



 

class CCommonInstrumentPropertyObject : public IDMUSProdPropPageObject
{
	friend class CInstrumentListItem;
	friend class CPChannelPropPage;
public:

	CCommonInstrumentPropertyObject();
	~CCommonInstrumentPropertyObject();
	
	// IUnknown functions
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void** ppData );
	HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();


	void		SetReset(bool bReset);
	void		SetProperties(CBandDlg* pBandDlg, CDMInstrument* pInstrument);
	void		SetSelectedChannels(int nSelectedChannels);
	void		SetBandDialog(CBandDlg* pBandDlg);
	CBandDlg*	GetBandDialog();

	// Applies and Syncs the changes for all the selected PChannels and refreshes the dialog
	void ApplyChangesToSelectedChannelsAndRefreshUI();
	void ApplyChanges(CDMInstrument* pInstrument);

	void SyncPChannelChanges(int nChannels, CInstrumentListItem** ppInstrumentArray);
	void SyncChanges(CDMInstrument* pInstrument, CBand *pBand = NULL);

	void ApplyOctaveChange(CDMInstrument* pInstrument);
	void ApplyPanChange(CDMInstrument* pInstrument);
	void ApplyVolumeChange(CDMInstrument* pInstrument);
	void ApplyInstrumentChange(CDMInstrument* pInstrument, const CString *pcsCurrentCollection = NULL);
	void ApplyPChannelChange(CDMInstrument* pInstrument);
	void ApplyNoteRangeChange(CDMInstrument* pInstrument);
	void ApplyPriorityChange(CDMInstrument* pInstrument);
	void ApplySoundCanvasChange(CDMInstrument* pInstrument);
	void ApplyPitchBendRangeChange(CDMInstrument* pInstrument);

	void SyncOctaveChange(CDMInstrument* pInstrument);
	void SyncPanChange(CDMInstrument* pInstrument);
	void SyncVolumeChange(CDMInstrument* pInstrument);
	void SyncInstrumentChange(CDMInstrument* pInstrument);
	void SyncPChannelChange(CDMInstrument* pInstrument);
	void SyncNoteRangeChange(CDMInstrument* pInstrument);
	void SyncPriorityChange(CDMInstrument* pInstrument);
	void SyncSoundCanvasChange(CDMInstrument* pInstrument);
	void SyncPitchBendRangeChange(CDMInstrument* pInstrument);

	// Set all the ignores
	void SetIgnoreInstrument(int nIgnore);
	void SetIgnoreOctaveTranspose(int nIgnore);
	void SetIgnoreVolume(int nIgnore);
	void SetIgnorePan(int nIgnore);
	void SetIgnorePriority(int nIgnore);
	void SetIgnoreNoteRange(int nIgnore);
	void SetIgnorePitchBendRange(int nIgnore);

	// Applies all the ignores
	void ApplyIgnores(CDMInstrument* pInstrument);
	void SyncIgnores(CDMInstrument* pInstrument);

	void ApplyInstrumentIgnore(CDMInstrument* pInstrument);
	void ApplyOctaveTransposeIgnore(CDMInstrument* pInstrument);
	void ApplyVolumeIgnore(CDMInstrument* pInstrument);
	void ApplyPanIgnore(CDMInstrument* pInstrument);
	void ApplyPriorityIgnore(CDMInstrument* pInstrument);
	void ApplyNoteRangeIgnore(CDMInstrument* pInstrument);
	void ApplyPitchBendRangeIgnore(CDMInstrument* pInstrument);

	void SyncInstrumentIgnore(CDMInstrument* pInstrument);
	void SyncOctaveTransposeIgnore(CDMInstrument* pInstrument);
	void SyncVolumeIgnore(CDMInstrument* pInstrument);
	void SyncPanIgnore(CDMInstrument* pInstrument);
	void SyncPriorityIgnore(CDMInstrument* pInstrument);
	void SyncPitchBendRangeIgnore(CDMInstrument* pInstrument);

	// Gets the number of selected channels
	int GetNumberOfChannels();

	void SetPChannelNumber(int nNumber);
	void SetPChannelName(CString sName);
	void SetInstrument(CDMInstrument* pInstrument);
	void SetPatch(DWORD dwPatch);
	void SetInstrument(CString sInstrumentName);
	void SetOctave(short nOctave);
	void SetTranspose(short nTranspose);
	void SetOctaveTranspose(short nOctaveTranspose);
	void SetVolume(int nVolume);
	void SetPan(int nPan);
	void SetPriority(DWORD lPriority, bool bPreserveOffset = false);
	void SetLowNote(short nLowNote);
	void SetHighNote(short nHighNote);
	void SetSoundCanvas(int nState);
	void SetSoundCanvas(CDMInstrument* pInstrument);
	void SetPitchBendOctave(short nPitchBendRange);
	void SetPitchBendTranspose(short nPitchBendRange);
	void SetPitchBendRange(short nPitchBendRange);
	void SetNoteRange(int nHighNote, int LowNote);

	int 	GetPChannelNumber();
	CString GetPChannelName();
	CString GetInstrument();
	short	GetOctave();
	short	GetTranspose();
	short	GetOctaveTranspose();
	int 	GetVolume();
	int 	GetPan();
	void	GetPriority(DWORD& dwPriorityLevel, DWORD& dwPriorityOffset);
	short	GetLowNote();
	short	GetHighNote();
	int		GetSoundCanvas();
	short	GetPitchBendOctave();
	short	GetPitchBendTranspose();
	short	GetPitchBendRange();

// Attributes
public:
		// The flag to check if something has changed
	DWORD m_dwChanged;
	DWORD m_dwIgnoresChanged;
	DWORD  m_dwInstrumentChangeID;
	int m_nABIIndex;


//Attributes
private:

	DWORD		m_dwRef; 

	bool		m_bReset;					// The reset will make the set methods ignore 
											// the unknown val if previouosly set

	CBandDlg*	m_pBandDlg; 				// The Band Dialog for the selected PChannels
	int 		m_nChannels;				// Number of selected PChannels

	int			m_nLastSelectedCollection; 	// We need to remember which dLS collection we used the last time
	CString		m_csCurrentCollection;		// so we can set it in the "Other DLS.." dialog 

	CString		m_sInstrumentInfo;			// This keeps the Collection, MSB, LSB, Patch info to show on the prop page
	CString		m_sInstrumentCollectionInfo;// Keeps the collection name for the instruments
	DWORD		m_dwInstrumentPatchInfo;	// Keeps the MSB LSB, Patch info 


	bool		m_bPreservePriorityOffset;  // Used to change only the priority level maintaining the offset

	// The common fields to be displayed in the property sheet

	int 		m_nPChannelNumber;		// PChannels number
	CString 	m_sPChannelName;		// PChannel Name
	DWORD		m_dwPatch;				// Patch Number
	CString 	m_sPatch;				// The instrument name
	short		m_nOctave;				// Octave
	short		m_nTranspose;			// Transpose
	short		m_nOctaveTranspose;		// Octave and Transpose added
	int 		m_nVolume;				// Volume
	int 		m_nPan; 				// Pan
	DWORD		m_dwPriority;			// Priority
	DWORD		m_dwPriorityLevel;		// Priority Level that maps to standard offsets (Low, Standard, High, critical)
	DWORD		m_dwPriorityOffset;		// Offset difference from the level
	short		m_nLowNote; 			// Low note of range
	short		m_nHighNote;			// High note of range
	int			m_nSoundCanvas;			// Use Roland SoundCanvas (TM) : 0 - Don't, 1 - Use it, 2 - Don't Know! Different Instrument, different settings!
	short		m_nPitchBendOctave;		// Octave for the Pitch Bend Range
	short		m_nPitchBendTranspose;	// Transpose for the Pitch Bend Range
	short		m_nPitchBendRange;		// The pitch bend range for the instrument

	// All the ignores....

	int 	m_nIgnoreVolume;
	int 	m_nIgnoreOctaveTranspose;
	int 	m_nIgnoreInstrument;
	int 	m_nIgnorePan;
	int 	m_nIgnorePriority;
	int 	m_nIgnoreNoteRange;
	int		m_nIgnorePitchBendRange;

//Operations
private:
	void CheckAllIgnores(CDMInstrument* pInstrument);
	void CheckInstrumentIgnore(CDMInstrument* pInstrument);
	void CheckOctaveTransposeIgnore(CDMInstrument* pInstrument);
	void CheckVolumeIgnore(CDMInstrument* pInstrument);
	void CheckPanIgnore(CDMInstrument* pInstrument);
	void CheckPriorityIgnore(CDMInstrument* pInstrument);
	void CheckNoteRangeIgnore(CDMInstrument* pInstrument);
	void CheckPitchBendIgnore(CDMInstrument* pInstrument);
};

#define PCHANNEL_CHANGED	(1 << 0)
#define INSTRUMENT_CHANGED	(1 << 1)
#define OCTAVE_CHANGED		(1 << 2)
#define TRANSPOSE_CHANGED	(1 << 3)
#define VOLUME_CHANGED		(1 << 4)
#define PAN_CHANGED 		(1 << 5)
#define NOTERANGE_CHANGED	(1 << 6)
#define PRIORITY_CHANGED	(1 << 7)
#define SOUNDCANVAS_CHANGED (1 << 8)
#define PITCHBEND_CHANGED	(1 << 9)

#define IGNORE_INSTRUMENT_CHANGED		(1 << 10)
#define IGNORE_VOLUME_CHANGED			(1 << 11)
#define IGNORE_PAN_CHANGED				(1 << 12)
#define IGNORE_OCTAVETRANSPOSE_CHANGED	(1 << 13)
#define IGNORE_PRIORITY_CHANGED 		(1 << 14)
#define IGNORE_NOTERANGE_CHANGED		(1 << 15)
#define IGNORE_PITCHBEND_CHANGED		(1 << 16)

#define IGNORES_CHANGED ( IGNORE_INSTRUMENT_CHANGED | IGNORE_VOLUME_CHANGED | IGNORE_PAN_CHANGED \
						| IGNORE_OCTAVETRANSPOSE_CHANGED | IGNORE_PRIORITY_CHANGED | IGNORE_NOTERANGE_CHANGED \
						| IGNORE_PITCHBEND_CHANGED )

#define DLS_REQUEST 		1
#define DRUMS_REQUEST		2

#define IGNORE_OFF			1			
#define IGNORE_ON			0
#define IGNORE_UNDT 		2


class CBand : public IDMUSProdNode, public IDMUSProdBandEdit8a, public IPersistStream,
			  public IDMUSProdNotifySink, public IDMUSProdPropPageObject, public IDMUSProdBandMgrEdit,
			  public IDMUSProdGetReferencedNodes
{
friend class CBandCtrl;
friend class CBandDlg;
friend class CBandDocType;
friend class CBandPropPageManager;
friend class CCommonInstrumentPropertyObject;
friend class CTabBand;

public:
	CBand( CBandComponent* pComponent );
	~CBand();

	// IUnknown functions
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnFirstImage );
	HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
	HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

	HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
	HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
	HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
	HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
	HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
	HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
	HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

	HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
	HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
	HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
	HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

	HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
	HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
	HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

	HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
	HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

	// IDMUSProdBandEdit functions
	HRESULT STDMETHODCALLTYPE GetDefaultFlag( BOOL* pfDefaultFlag);
	HRESULT STDMETHODCALLTYPE SetDefaultFlag( BOOL fDefaultFlag );
    HRESULT STDMETHODCALLTYPE GetDLSRegionName( DWORD dwPChannel, BYTE bMIDINote, BSTR* pbstrName );

	// IDMUSProdBandEdit8 functions
	HRESULT STDMETHODCALLTYPE GetPatchForPChannel( DWORD dwPChannel, DWORD *pdwPatch );

 	// IDMUSProdBandEdit8a functions
    HRESULT STDMETHODCALLTYPE GetInstNameForPChannel( DWORD dwPChannel, BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE DisplayInstrumentButton( DWORD dwPChannel, LONG lXPos, LONG lYPos );
	HRESULT STDMETHODCALLTYPE InsertPChannel( DWORD dwPChannel, BOOL fClearBandFirst );
	HRESULT STDMETHODCALLTYPE SetAudiopath( IUnknown* punkAudiopath );

	// IDMUSProdBandMgrEdit functions
    HRESULT STDMETHODCALLTYPE DisplayEditBandButton( DWORD dwPChannel, LONG lXPos, LONG lYPos );

	// IPersist functions
	STDMETHOD(GetClassID)( CLSID* pClsId );

	// IPersistStream functions
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IDMUSProdNotifySink method
	STDMETHOD(OnUpdate)(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData);

	// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void** ppData );
	HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// Additional functions
	HRESULT OnViewProperties();

    // IDMUSProdGetReferencedNodes
    HRESULT STDMETHODCALLTYPE GetReferencedNodes( DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode, DWORD dwErrorLength, WCHAR *wcstrErrorText );

public:
	HRESULT Load_IMA_Band( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT LoadDMBand( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo );
	
	void	SetModifiedFlag( BOOL fNeedsSaved );
	void	Activate();
	void	EnablePatch( int nIndex );
	void	RemoveFromNotifyList( IDMUSProdReferenceNode* pDMReferenceNode );
	void	AddToNotifyList( IDMUSProdReferenceNode* pDMReferenceNode );
	HRESULT NotifyEveryone( GUID guidNotification);

	void	GetGUID( GUID* pguidBand );
	void	SetGUID( GUID guidBand );

	HRESULT OnContextCommand( WPARAM wParam, LPARAM lParam );

	// Operations on the Instrument List

	CDMInstrument*			GetInstrumentFromList(long PChannel);
	CDMInstrument*			GetInstrumentByIndex(int nIndex);
	
	CInstrumentListItem*	GetInstrumentItemFromList(long lPChannel);
	CInstrumentListItem*	GetInstrumentItemByIndex(int nCount);

	int						GetInstrumentCount();
	int						GetNumberOfSelectedInstruments();

	int						GetSelectedInstruments(CInstrumentListItem** ppInstrumentArray);
	void					UnselectAllInstruments();
	void					SelectAllInstruments();
	
	void*					GetInstrumentList();
	void					DeleteInstrumentList();
	
	void					InsertIntoInstrumentList(CInstrumentListItem* pInstrumentItem);
	CInstrumentListItem*	InsertIntoInstrumentList();
	
	int						DeleteFromInstrumentList(DWORD nPChannel);
	int						DeleteFromInstrumentList(CInstrumentListItem* pInstrumentItem);
	
	DWORD					GetNextAvailablePChannel();
	DWORD					GetNextAvailablePChannel(DWORD dwStartChannel);
	DWORD					GetLastAvailablePChannel(DWORD nStartIndex);

	bool					IsPChannelFree(DWORD dwPChannel);
	CInstrumentListItem*	ChangePChannelNumber(DWORD oldPChannel, DWORD newPChannel);
	void					SendBand();
	bool					m_bInUndoRedo;

protected:
	HRESULT SaveBandChunk( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveBandUnfoList( IDMUSProdRIFFStream* pIRiffStream );

private:
	void InitInstrumentList();
	HRESULT LoadDMInstruments( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT SyncAllInstruments(DMUS_PMSGT_TYPES pmsgType);


public:
	CBandComponent* 	m_pComponent;
	CBandCtrl*			m_pBandCtrl;
	IDirectMusicAudioPath *m_pAudiopath;

private:
	DWORD				m_dwRef;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*		m_pIParentNode;

	HWND				m_hWndEditor;
	CContextMenuHandler	m_ContextMenuHandler;
	DWORD				m_dwPChannelForContextMenu;
	CDMInstrument*		m_pDMInstrumentForContextMenu;

	// Band data for Music Engine
	BOOL				m_fDefault;

	//patch/program change and DLS info
	CTypedPtrList<CPtrList, CLinkedDLSCollection*>	 m_lstDLSCollections;
	CTypedPtrList<CPtrList, CInstrumentListItem*>	 m_lstInstruments;

	GUID				m_guidBand;
	CString 			m_csName;
	CString 			m_strDefaultCollection;
	DMUS_IO_VERSION 	m_Version;
	BOOL				m_fDirty;

	// resource reference count
	static long			m_slResourceRefCount;
};

#define FOURCC_COLLECTION_REF	mmioFOURCC('c','o','l','r')
#define FOURCC_INST_DESIGNTIME	mmioFOURCC('i','n','s','p')

// 5/11/98 JHD: Added next 3 lines to reflect the IMA -> DMusic mapping
// This expects a voiceid from 1-16
#define IMA25_VOICEID_TO_PCHANNEL( id )  ( ( id + 4 ) & 0xf )
#define PCHANNEL_TO_IMA25_VOICEID( id )  ( ( id + 12 ) & 0xf )

#endif // __BAND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandComponent.cpp ===
// BandComponent.cpp : implementation file
//

#include "stdafx.h"

#include "BandEditorDLL.h"
#include "Band.h"
#include "BandRef.h"
#include "DLSDesigner.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBandComponent constructor/destructor

CBandComponent::CBandComponent()
{
    m_dwRef = 0;
	m_pIFramework = NULL;
	m_pIDocType8 = NULL;
	m_pIConductor = NULL;
	m_pIDMPerformance = NULL;
	m_nFirstBandImage = 0;
	m_nFirstBandRefImage = 0;
	m_nFirstFolderImage = 0;
	m_nNextBand = 0;		
	m_cfBand = 0;
	m_cfBandList = 0;
	m_pvLastFailedCollectionRefStream = NULL;
}

CBandComponent::~CBandComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::ReleaseAll

void CBandComponent::ReleaseAll( void )
{
	CBand *pBand;

	while( !m_lstBands.IsEmpty() )
	{
		pBand = static_cast<CBand*>( m_lstBands.RemoveHead() );
		pBand->Release();
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;

		theApp.m_pIFramework->Release();
		theApp.m_pIFramework = NULL;
	}

	if( m_pIDocType8 )
	{
		m_pIDocType8->Release();
		m_pIDocType8 = NULL;
	}
	
	if (m_pIDMPerformance)
	{
		m_pIDMPerformance->Release();
		m_pIDMPerformance = NULL;
	}

	if( m_pIConductor )
	{
		m_pIConductor->Release();
		m_pIConductor = NULL;
	}

	while(m_lstLastCollection.IsEmpty() == FALSE)
	{
		m_lstLastCollection.RemoveHead();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent IUnknown implementation

HRESULT CBandComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdRIFFExt *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CBandComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CBandComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CBandComponent IDMUSProdComponent::Initialize

HRESULT CBandComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	// Validate arguments
	ASSERT(pIFramework);
	ASSERT(pbstrErrMsg);

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	theApp.m_pIFramework = pIFramework;
	theApp.m_pIFramework->AddRef();

	// Get IDMUSProdConductor and DMusic Performance interface pointers 
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) )
	||  FAILED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			pIComponent->Release();
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	pIComponent->Release();

	// Add applicable images to the Project Tree control's image list 
	if( !SUCCEEDED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clip format for a .bnp file 
	CString strExt = _T(".bnp");
	BSTR bstrExt = strExt.AllocSysString();
	if( !SUCCEEDED ( pIFramework->RegisterClipFormatForFile(m_cfBand, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pIDocType8 = new CBandDocType( this );
    if( m_pIDocType8 == NULL )
    {
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pIDocType8->AddRef();

	if( !SUCCEEDED ( pIFramework->AddDocType(m_pIDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent IDMUSProdComponent::CleanUp

HRESULT CBandComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CBand *pBand;

	while( !m_lstBands.IsEmpty() )
	{
		pBand = static_cast<CBand*>( m_lstBands.RemoveHead() );
		pBand->Release();
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent IDMUSProdComponent::GetName

HRESULT CBandComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_BAND_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent IDMUSProdComponent::AllocReferenceNode

HRESULT CBandComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_BandRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create BandRefNode
	CBandRef* pBandRef = new CBandRef( this );
	if( pBandRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pBandRef;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent IDMUSProdComponent::OnActivateApp

HRESULT CBandComponent::OnActivateApp( BOOL fActivate )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CBandComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CBand* pBand;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Band 
	pBand = new CBand( this );
	if( pBand == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	// Load the Band file
	//m_pIFramework->StartWaitCursor();
	hr = pBand->Load( pIStream );
	//m_pIFramework->EndWaitCursor();
	if( !SUCCEEDED ( hr ) )
	{
		pBand->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pBand;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CBandComponent::AddNodeImageLists

HRESULT CBandComponent::AddNodeImageLists( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_BAND_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_BAND_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstBandImage ) ) )
	{
		return E_FAIL;
	}
	
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstFolderImage ) ) )
	{
		return E_FAIL;
	}
	
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_BANDREF_NODE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_BANDREF_NODE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstBandRefImage ) ) )
	{
		return E_FAIL;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::RegisterClipboardFormats

BOOL CBandComponent::RegisterClipboardFormats( void )
{
	m_cfBand = ::RegisterClipboardFormat( CF_BAND );
	m_cfBandList = ::RegisterClipboardFormat( CF_BANDLIST );
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );

	if( m_cfBand == 0
	||  m_cfBandList == 0
	||  m_cfProducerFile == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::GetBandImageIndex

HRESULT CBandComponent::GetBandImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pnFirstImage = m_nFirstBandImage;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::GetFolderImageIndex

HRESULT CBandComponent::GetFolderImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pnFirstImage = m_nFirstFolderImage;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::GetBandRefImageIndex

HRESULT CBandComponent::GetBandRefImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pnFirstImage = m_nFirstBandRefImage;
	
	return S_OK;
}


bool CBandComponent::IsGM(DWORD dwBank, DWORD dwInstrument)
{
	BYTE	bMSB, bLSB, bPatch;

	bMSB = (BYTE) ((dwBank & 0x00007F00) >> 8);
	bLSB = (BYTE) (dwBank & 0x0000007F);
	bPatch = (BYTE) (dwInstrument & 0x0000007F);
	
	if (bLSB != 0) return false;

	if ( (bMSB == 0) ) // && (bLSB == 0) 
	{
		if ((dwBank & 0x80000000)) //Drum Kit
		{
			if ((bPatch == 0x0)  ||
				(bPatch == 0x08) ||
				(bPatch == 0x10) ||
				(bPatch == 0x18) ||
				(bPatch == 0x19) ||
				(bPatch == 0x20) ||
				(bPatch == 0x28) ||
				(bPatch == 0x30) || 
				(bPatch == 0x38) )
			{
				return  true;
			}
			else
				return false;
		}
		else return true;//is GM
	}
	// check for GS
	switch (bMSB)
	{
		case 6:
		case 7:
			if (bPatch == 0x7D) return true;
			break;
		case 24:
			if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
			break;
		case 9:
			if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
			break;
		case 2:
			if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
			break;
		case 3:
			if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
			break;
		case 4:
		case 5:
			if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
			break;
		case 32:
			if ((bPatch == 0x10) ||
				(bPatch == 0x11) ||
				(bPatch == 0x18) ||
				(bPatch == 0x34) ) return true;
			break;
		case 1:
			if ((bPatch == 0x26) ||
				(bPatch == 0x39) ||
				(bPatch == 0x3C) ||
				(bPatch == 0x50) ||
				(bPatch == 0x51) ||
				(bPatch == 0x62) ||
				(bPatch == 0x66) ||
				(bPatch == 0x68) ||
				((bPatch > 0x77) && (bPatch < 0x80))) return true;
				break;
		case 16:
			switch (bPatch)
			{
				case 0x00:
					return true;
					break;
				case 0x04:
					return true;
					break;
				case 0x05:
					return true;
					break;
				case 0x06:
					return true;
					break;
				case 0x10:
					return true;
					break;
				case 0x13:
					return true;
					break;
				case 0x18:
					return true;
					break;
				case 0x19:
					return true;
					break;
				case 0x1C:
					return true;
					break;
				case 0x27:
					return true;
					break;
				case 0x3E:
					return true;
					break;
				case 0x3F:
					return true;
					break;
				default:
					return false;
			}
			break;
		case 8:
			if ((bPatch < 0x07) || ((bPatch == 0x7D)))
			{
				return true;
			}
			else if ((bPatch > 0x3F) && (bPatch < 0x50))
			{
				return false;
			}
			else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
			{
				if ((bPatch == 0x50) || 
					(bPatch == 0x51) ||
					(bPatch == 0x6B))
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x1F) && (bPatch < 0x40))
			{
				if ((bPatch > 0x25) && (bPatch < 0x29) ||
					(bPatch > 0x3C)  ||
					(bPatch == 0x30) || 
					(bPatch == 0x32) )
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
				     (bPatch != 0x0D) && (bPatch != 0x0F))
			{
				return true;
			}
			else if ((bPatch > 0x0F) && (bPatch < 0x20))
			{
				if (bPatch > 0x17)
				{
					return true;
				}
				else if ( (bPatch == 0x13) || (bPatch == 0x15) )
					return true;
				else
					return false;
			}
			else if(bPatch >= 0x73 && bPatch <= 0x77)
				return true;
			break;
		default:
			return false;
	}
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::FindDLSCollection

IDMUSProdReferenceNode* CBandComponent::FindDLSCollection( CString  csCollection, IStream* pIStream )
{
	IDMUSProdReferenceNode*	pIReferenceNode = NULL;
	IDMUSProdNode*			pIDocRootNode = NULL;
	IDMUSProdDocType*		pIDocType = NULL;
	IDMUSProdPersistInfo*	pIPersistInfo = NULL;
	DMUSProdStreamInfo		StreamInfo;
	HRESULT					hr;

	ASSERT( m_pIFramework != NULL );

	// Get DocType for DLS Collections
	hr = m_pIFramework->FindDocTypeByNodeId( GUID_CollectionNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get IDMUSProdPersistInfo interface for pIStream 
	hr = pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get target directory
	pIPersistInfo->GetStreamInfo( &StreamInfo );

	if( !csCollection.IsEmpty() )
	{
		BSTR bstrCollection = csCollection.AllocSysString();

		if( FAILED ( m_pIFramework->GetBestGuessDocRootNode( pIDocType,
															 bstrCollection,
															 StreamInfo.pITargetDirectoryNode,
															 &pIDocRootNode ) ) )
		{
			pIDocRootNode = NULL;
		}
	}

	if( pIDocRootNode == NULL)
	{
		// Cannot find Collection
		// If user cancelled previous search for this Collection, no need to ask again
		if( IsInFailedCollectionList(csCollection) && m_pvLastFailedCollectionRefStream == pIStream)
		{
			hr = E_FAIL;
			goto ON_ERROR; 
		}
	
		if(m_pvLastFailedCollectionRefStream != (void*)pIStream)
		{
			while(m_lstLastCollection.IsEmpty() == FALSE)
			{
				m_lstLastCollection.RemoveHead();
			}

			m_pvLastFailedCollectionRefStream = (void*)pIStream;
		}

		// Determine File Open dialog prompt
		CString	csOpenDlgTitle;
		if( csCollection.IsEmpty() )
		{
			csOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_DLS );
		}
		else
		{
			AfxFormatString1( csOpenDlgTitle, IDS_FILE_OPEN_DLS, csCollection );
		}
		BSTR bstrOpenDlgTitle = csOpenDlgTitle.AllocSysString();

		// Display File open dialog
		if( m_pIFramework->OpenFile(pIDocType, bstrOpenDlgTitle, StreamInfo.pITargetDirectoryNode, &pIDocRootNode) != S_OK )
		{
			// Did not open a file, or opened file other than DLS file
			// so we do not want this DocRoot
			RELEASE( pIDocRootNode );
		}
	}

	if( pIDocRootNode )
	{
		pIReferenceNode = CreateCollectionRefNode( pIDocRootNode );
	}
	else
	{
		m_lstLastCollection.AddTail(csCollection);
	}

ON_ERROR:
	RELEASE( pIPersistInfo );
	RELEASE( pIDocType );
	RELEASE( pIDocRootNode );

	return pIReferenceNode;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::CreateCollectionRefNode

IDMUSProdReferenceNode* CBandComponent::CreateCollectionRefNode( IDMUSProdNode* pDLSCollectionNode )
{
	HRESULT						hr;
	IDMUSProdNode*				pINode;
	IDMUSProdComponent*			pIComponent;
	IDMUSProdReferenceNode*		pIRefNode;
	bool						bCollectionFound=false;

	// Allocate a new reference node
	hr = m_pIFramework->FindComponent( CLSID_DLSComponent,  &pIComponent );
	if(FAILED(hr))
	{
		return NULL;
	}

	hr = pIComponent->AllocReferenceNode(GUID_CollectionRefNode, &pINode);
	pIComponent->Release();
	if(FAILED(hr))
	{
		return NULL;
	}
	hr = pINode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIRefNode);
	pINode->Release();
	if (FAILED(hr))
	{
		TRACE("Failed query for Reference interface\n");
		return NULL;
	}
	
	hr = pIRefNode->SetReferencedFile(pDLSCollectionNode);
	if (FAILED(hr))
	{
		TRACE("Failed to SetReferencedFile\n");
		pIRefNode->Release();
		return NULL;
	}
	return pIRefNode;
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::AddToBandFileList

void CBandComponent::AddToBandFileList( CBand* pBand )
{
	if( pBand )
	{
		GUID guidBand;
		pBand->GetGUID( &guidBand );

		// Prevent duplicate object GUIDs
		GUID guidBandList;
		POSITION pos = m_lstBands.GetHeadPosition();
		while( pos )
		{
			CBand* pBandList = m_lstBands.GetNext( pos );

			pBandList->GetGUID( &guidBandList );
			if( ::IsEqualGUID( guidBandList, guidBand ) )
			{
				::CoCreateGuid( &guidBand );
				pBand->SetGUID( guidBand );
				break;
			}
		}

		// Add to list
		pBand->AddRef();
		m_lstBands.AddTail( pBand );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandComponent::RemoveFromBandFileList

void CBandComponent::RemoveFromBandFileList( CBand* pBand )
{
	if( pBand )
	{
		// Remove from list
		POSITION pos = m_lstBands.Find( pBand );
		if( pos )
		{
			m_lstBands.RemoveAt( pos );
			pBand->Release();
		}
	}
}



HRESULT CBandComponent::SendPMsg( DMUS_PMSG *pPMsg, IDirectMusicAudioPath* pDMAudioPath )
{
	if(!m_pIDMPerformance )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	IDirectMusicPerformance8 *pDMPerf8;
	if( SUCCEEDED( m_pIDMPerformance->QueryInterface( IID_IDirectMusicPerformance8, (void **)&pDMPerf8 ) ) )
	{
		bool fRelease = false;
		if( pDMAudioPath == NULL )
		{
			pDMPerf8->GetDefaultAudioPath( &pDMAudioPath );
			fRelease = true;
		}

		if( pDMAudioPath )
		{
			if( SUCCEEDED( pDMAudioPath->ConvertPChannel( pPMsg->dwPChannel, &pPMsg->dwPChannel ) ) )
			{
				hr = pDMPerf8->SendPMsg( pPMsg );
			}
			if( fRelease )
			{
				pDMAudioPath->Release();
			}
		}
		pDMPerf8->Release();
	}

	return hr;
}

BOOL CBandComponent::IsInFailedCollectionList(CString csCollection)
{
	POSITION position = m_lstLastCollection.GetHeadPosition();
	while(position)
	{
		CString csCollectionName = m_lstLastCollection.GetNext(position);
		if(csCollectionName.CompareNoCase(csCollection) == 0)
		{
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\Band.cpp ===
// Band.cpp : implementation file
//

#include "stdafx.h"

#include "BandEditorDLL.h"
#include "StyleDesigner.h"
#include "Band.h"
#include "BandCtl.h"
#include "DLSDesigner.h"
#include "IMABand.h"
#include <mmreg.h>
#include "Info.h"
#include "PChannelPropPage.h"
#include "PChannelPropPageMgr.h"
#include "PChannelName.h"
#include "resourcemaps.h"
#include "DlgDLS.h"
#include "BandDlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern BInstr abiGS[];
extern BInstr abiDrums[];


static BYTE sabPan[NBR_IMA_INSTRUMENTS]    = {  5, 20, 35, 50, 65, 80, 95, 110,  5, 20, 35, 50, 65, 80, 95, 110 };
static BYTE sabVolume[NBR_IMA_INSTRUMENTS] = { 85, 85, 85, 85, 85, 85, 85,  85, 70, 70, 70, 70, 70, 70, 70,  70 };


// {5574FDE0-0C3B-11d2-89B3-00C04FD912C8}
static const GUID GUID_BandPropPageManager = 
{ 0x5574fde0, 0xc3b, 0x11d2, { 0x89, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8 } };


CCommonInstrumentPropertyObject CInstrumentListItem::m_CommonPropertyObject;
static const TCHAR achUnknown[16] = "---------------";
long CBand::m_slResourceRefCount = 0;

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler

CContextMenuHandler::CContextMenuHandler()
{
	m_pBand = NULL;
}

CContextMenuHandler::~CContextMenuHandler()
{
}


BEGIN_MESSAGE_MAP(CContextMenuHandler, CWnd)
	//{{AFX_MSG_MAP(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler message handlers

BOOL CContextMenuHandler::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = S_FALSE;

	if( m_pBand != NULL )
	{
		hr = m_pBand->OnContextCommand( wParam, lParam );
	}
	
	if( hr == S_OK )
	{
		return TRUE;
	}

	return CWnd::OnCommand( wParam, lParam );
}

//////////////////////////////////////////////////////////////////////
// CLinkedDLSCollection Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLinkedDLSCollection::CLinkedDLSCollection( IDMUSProdNode* pIDocRootNode )
{
    ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
	m_pIDocRootNode->AddRef();

	m_dwUseCount = 1;
}


CLinkedDLSCollection::~CLinkedDLSCollection()
{
	RELEASE( m_pIDocRootNode );
}


//////////////////////////////////////////////////////////////////////
// CBandPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBandPropPageManager::CBandPropPageManager()
{
	m_pTabBand = NULL;
	m_GUIDManager = GUID_BandPropPageManager;
}

CBandPropPageManager::~CBandPropPageManager()
{
	if( m_pTabBand )
	{
		delete m_pTabBand;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageManager::RemoveCurrentObject

void CBandPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CBandPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	CString strDocRootName;
	CString strMotifName;

	// Load "BAND" text
	strTitle.LoadString( IDS_BAND_TEXT );

	CBand* pBand;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pBand))) )
	{
		// Get DocRoot's Name
		if( pBand->m_pIDocRootNode
		&&  pBand->m_pIDocRootNode != (IDMUSProdNode *)pBand )
		{
			BSTR bstrDocRootName;

			if( SUCCEEDED ( pBand->m_pIDocRootNode->GetNodeName( &bstrDocRootName ) ) )
			{
				strDocRootName = bstrDocRootName;
				::SysFreeString( bstrDocRootName );
			}
		}

		// If DocRoot is GUID_StyleNode.....
		if( pBand->m_pIDocRootNode
		&&  pBand->m_pIDocRootNode != (IDMUSProdNode *)pBand )
		{
			GUID guidNodeId;

			if( strDocRootName.IsEmpty() == FALSE )
			{
				strMotifName = _T(" - ");
			}

			if( SUCCEEDED ( pBand->m_pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
			{
				if( ::IsEqualGUID ( guidNodeId, GUID_StyleNode )  )
				{
					// and ParentNode is GUID_MotifNode.....
					if( pBand->m_pIParentNode )
					{
						if( SUCCEEDED ( pBand->m_pIParentNode->GetNodeId ( &guidNodeId ) ) )
						{
							if( ::IsEqualGUID ( guidNodeId, GUID_MotifNode )  )
							{
								// Get Motif's Name
								BSTR bstrMotifName;

								if( SUCCEEDED ( pBand->m_pIParentNode->GetNodeName( &bstrMotifName ) ) )
								{
									CString strName;
									AfxFormatString1( strName, IDS_MOTIF_TEXT, CString(bstrMotifName) );
									::SysFreeString( bstrMotifName );

									strMotifName = _T(" (");
									strMotifName += strName;
									strMotifName += _T(") - ");
								}
							}
						}
					}
				}
			}
		}

		// Format title
		strTitle += (_T(": ") + strDocRootName + strMotifName + pBand->m_csName);
	}

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CBandPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Band tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	m_pTabBand = new CTabBand( this );
	if( m_pTabBand )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabBand->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CBandPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CBandPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CBand* pBand;
	
	if( m_pIPropPageObject == NULL )
	{
		pBand = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pBand ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Band are processed in OnKillFocus
	// messages before setting the new Band
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabBand->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Band
	m_pTabBand->SetBand( pBand );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	if(m_pIPropSheet)
		m_pIPropSheet->RefreshTitle();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CBand constructor/destructor

CBand::CBand( CBandComponent* pComponent )
{
	ASSERT( pComponent != NULL );

	m_bInUndoRedo = false;
    m_dwRef = 0;
	AddRef();

	m_pComponent = pComponent;
	m_pComponent->AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_hWndEditor = NULL;
	m_pAudiopath = NULL;

	InterlockedIncrement( &m_slResourceRefCount );
	if( m_slResourceRefCount == 1 )  
	{
		BInstr   *pbi;

		// allocate and load patch names
		pbi = &abiGS[0];
		while( pbi->nStringId != IDS_PGMEND )
		{
			if( pbi->pstrName == NULL )
			{
				pbi->pstrName = new CString;
				ASSERT( pbi->pstrName != NULL );
				pbi->pstrName->LoadString( pbi->nStringId );
			}
			pbi++;
		}

		// allocate and load drum names
		pbi = &abiDrums[0];
		while( pbi->nStringId != IDS_PGMEND )
		{
			if( pbi->pstrName == NULL )
			{
				pbi->pstrName = new CString;
				ASSERT( pbi->pstrName != NULL );
				pbi->pstrName->LoadString( pbi->nStringId );
			}
			pbi++;
		}

		CPChannelPropPage::CreatePatchPopupMenu();
	}

// Band data for Music Engine
	TCHAR achName[SMALL_BUFFER];
	short nOne = 1;

	::LoadString( theApp.m_hInstance, IDS_BAND_TEXT, achName, SMALL_BUFFER );
    m_csName.Format( "%s%d", achName, nOne );

	InitInstrumentList();

	m_pBandCtrl = NULL;
	m_fDefault = FALSE;
	::CoCreateGuid( &m_guidBand );
	m_fDirty = FALSE;

	m_pDMInstrumentForContextMenu = NULL;
	m_dwPChannelForContextMenu = 0;
	RECT rect = {0,0,0,0};
	m_ContextMenuHandler.CreateEx(0L, NULL, "Hidden band editor menu handler",
								  WS_POPUP | WS_CHILD, rect, NULL, 0, NULL);
	m_ContextMenuHandler.m_pBand = this;
}

CBand::~CBand()
{
	ASSERT( theApp.m_pIFramework != NULL );


	RELEASE( m_pAudiopath );

	DeleteInstrumentList();
	
	// DLSCollection list should be empty!
	ASSERT( m_lstDLSCollections.IsEmpty() );

	// Remove CBand from clipboard
	theApp.FlushClipboard( this );

	// Remove CBand from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		pIPropSheet->Release();
	}

	if( InterlockedDecrement( &m_slResourceRefCount ) == 0 )  // last instance
	{
		BInstr   *pbi;

		// destroy the patch names
		pbi = &abiGS[0];
		while( pbi->nStringId != IDS_PGMEND )
		{
			if( pbi->pstrName )  
			{
				delete pbi->pstrName;
				pbi->pstrName = NULL;
			}
			pbi++;
		}

		// destroy the drums names
		pbi = &abiDrums[0];
		while( pbi->nStringId != IDS_PGMEND )
		{
			if( pbi->pstrName )  
			{
				delete pbi->pstrName;
				pbi->pstrName = NULL;
			}
			pbi++;
		}	

		::DestroyMenu(CPChannelPropPage::m_hmenuPatch);
		::DestroyMenu(CPChannelPropPage::m_hmenuDrums);
	
	}

	if(IsWindow(m_ContextMenuHandler.m_hWnd))
	{
		m_ContextMenuHandler.m_pBand = NULL;
		//m_ContextMenuHandler.DestroyWindow();
		::DestroyWindow( m_ContextMenuHandler.m_hWnd );
	}

	if( m_pComponent )
	{
		m_pComponent->Release();
	}
}

void CBand::InitInstrumentList()
{
	for( int nCount = 0 ; nCount < NBR_IMA_INSTRUMENTS ; ++nCount )
    {
		CDMInstrument* pInstrument = new CDMInstrument();	
        
		pInstrument->dwPatch = 0;
		pInstrument->dwAssignPatch = 0;
		pInstrument->dwPChannel = nCount;
		pInstrument->dwPatch = MAKE_PATCH(pInstrument->IsDrums(), 0, 0, 0);
		pInstrument->dwFlags = (DMUS_IO_INST_GS | DMUS_IO_INST_GM);
		memset(pInstrument->dwNoteRanges,0,4 * sizeof(DWORD));
		pInstrument->bPan = sabPan[nCount];
		pInstrument->bVolume = sabVolume[nCount];
		pInstrument->nTranspose = 0;
		pInstrument->nPitchBendRange = 2;
		pInstrument->dwChannelPriority = dwaPriorities[nCount];
		
		pInstrument->SetComponent(m_pComponent);
		pInstrument->SetBand(this);


		CInstrumentListItem* pInstrumentListItem = new CInstrumentListItem(pInstrument);
		m_lstInstruments.AddTail(pInstrumentListItem);
    }
}


void CBand::DeleteInstrumentList()
{
	CInstrumentListItem* pInstrumentItem;

	while( !m_lstInstruments.IsEmpty() )
	{
		pInstrumentItem = m_lstInstruments.RemoveHead();
		//delete pInstrumentItem;
		if(pInstrumentItem->Release() == 0)
			pInstrumentItem = NULL;
	}
}

void* CBand::GetInstrumentList()
{
	return &m_lstInstruments;
}


/////////////////////////////////////////////////////////////////////////////
// CBand::SetModifiedFlag

void CBand::SetModifiedFlag( BOOL fNeedsSaved )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Framework responsible for clearing its own modified flag.
	// Otherwise Project file containing multiple dirty files
	// may be flagged as not dirty because one file is no 
	// longer dirty.
	if( fNeedsSaved )
	{
		m_fDirty = TRUE;
	}
    else
    {
        m_fDirty = FALSE;
    }
}


/////////////////////////////////////////////////////////////////////////////
// CBand IUnknown implementation

HRESULT CBand::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdNode *)this;
    }

    else if( ::IsEqualIID(riid, IID_IDMUSProdBandEdit) )
    {
        *ppvObj = (IDMUSProdBandEdit *)this;
    }

	else if( ::IsEqualIID(riid, IID_IDMUSProdBandEdit8) )
	{
		*ppvObj = (IDMUSProdBandEdit8 *)this;
	}

	else if( ::IsEqualIID(riid, IID_IDMUSProdBandEdit8a) )
	{
		*ppvObj = (IDMUSProdBandEdit8a *)this;
	}

	else if( ::IsEqualIID(riid, IID_IDMUSProdBandMgrEdit) )
	{
		*ppvObj = (IDMUSProdBandMgrEdit *)this;
	}

    else if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink) )
    {
        *ppvObj = (IDMUSProdNotifySink *)this;
    }

	else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
	{
		*ppvObj = (IDMUSProdPropPageObject *)this;
	}

    else if( ::IsEqualIID(riid, IID_IPersist) )
    {
        *ppvObj = (IPersist *)this;
    }

    else if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        *ppvObj = (IPersistStream *)this;
    }

    else if( ::IsEqualIID(riid, IID_IDMUSProdGetReferencedNodes) )
    {
        *ppvObj = (IDMUSProdGetReferencedNodes *)this;
    }
	else
	{
	    *ppvObj = NULL;
		return E_NOINTERFACE;
	}
	
	AddRef();
	return S_OK;
}

ULONG CBand::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CBand::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetNodeImageIndex

HRESULT CBand::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return( m_pComponent->GetBandImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetFirstChild

HRESULT CBand::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;	// No children for Band nodes
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetNextChild

HRESULT CBand::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;	// No children for Band nodes
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetNodeListInfo

HRESULT CBand::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Only applies to band 'files'
	if( m_pIDocRootNode == this )
	{
		CString strDescriptor;

		pListInfo->bstrName = m_csName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &m_guidBand, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetComponent

HRESULT CBand::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetDocRootNode

HRESULT CBand::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::SetDocRootNode

HRESULT CBand::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetParentNode

HRESULT CBand::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::SetParentNode

HRESULT CBand::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetNodeId

HRESULT CBand::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_BandNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetNodeName

HRESULT CBand::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_csName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetNodeNameMaxLength

HRESULT CBand::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::ValidateNodeName

HRESULT CBand::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = S_OK;

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_pIDocRootNode
	&&  m_pIDocRootNode != this )
	{
		// Store original Band name
		CString strOrigName = m_csName;

		m_csName = strName;

		// Give DocRoot node a chance to validate the new Band name
		IDMUSProdNotifySink* pINotifySink;

		if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
		{
			hr = pINotifySink->OnUpdate( this, BAND_ValidateNameChange, NULL  );
			pINotifySink->Release();
		}

		// Put back original Band name
		m_csName = strOrigName;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::SetNodeName

HRESULT CBand::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName = bstrName;
	::SysFreeString( bstrName );

	m_csName = strName;
	SetModifiedFlag( TRUE );

	if( m_pIDocRootNode
	&&  m_pIDocRootNode != this )
	{
		// Notify Style DocRoot node that Band name has changed
		IDMUSProdNotifySink* pINotifySink;

		if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
		{
			pINotifySink->OnUpdate( this, BAND_NameChange, NULL  );
			pINotifySink->Release();
		}
	}
	else
	{
		// Notify connected nodes that Band name has changed
		m_pComponent->m_pIFramework->NotifyNodes( this, BAND_NameChange, NULL );
	}

	CBandPropPageManager* pPageManager = NULL;
	// Get the Band page manager
	if( theApp.m_pIPageManager && theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_BandPropPageManager ) == S_OK )
	{
		pPageManager = (CBandPropPageManager*) theApp.m_pIPageManager;
		pPageManager->RefreshData();
	}


	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetEditorClsId

HRESULT CBand::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pClsId = CLSID_BandEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetEditorTitle

HRESULT CBand::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrTitle == NULL )
	{
		return E_POINTER;
	}

	// Load "BAND" text
	CString strBand;
	strBand.LoadString( IDS_BAND_TEXT );

	// Get DocRoot's Name
	CString strDocRootName;
	if( m_pIDocRootNode
	&&  m_pIDocRootNode != (IDMUSProdNode *)this )
	{
		BSTR bstrDocRootName;

		if( SUCCEEDED ( m_pIDocRootNode->GetNodeName( &bstrDocRootName ) ) )
		{
			strDocRootName = bstrDocRootName;
			::SysFreeString( bstrDocRootName );
		}
	}

	// If DocRoot is GUID_StyleNode.....
	CString strMotifName;
	if( m_pIDocRootNode
	&&  m_pIDocRootNode != (IDMUSProdNode *)this )
	{
		GUID guidNodeId;

		if( strDocRootName.IsEmpty() == FALSE )
		{
			strMotifName = _T(" - ");
		}

		if( SUCCEEDED ( m_pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID ( guidNodeId, GUID_StyleNode )  )
			{
				// and ParentNode is GUID_MotifNode.....
				if( m_pIParentNode )
				{
					if( SUCCEEDED ( m_pIParentNode->GetNodeId ( &guidNodeId ) ) )
					{
						if( ::IsEqualGUID ( guidNodeId, GUID_MotifNode )  )
						{
							// Get Motif's Name
							BSTR bstrMotifName;

							if( SUCCEEDED ( m_pIParentNode->GetNodeName( &bstrMotifName ) ) )
							{
								CString strName;
								AfxFormatString1( strName, IDS_MOTIF_TEXT, CString(bstrMotifName) );
								::SysFreeString( bstrMotifName );

								strMotifName = _T(" (");
								strMotifName += strName;
								strMotifName += _T(") - ");
							}
						}
					}
				}
			}
		}
	}

	// Format title
	CString strTitle;
	strTitle = strBand + _T(": ") + strDocRootName + strMotifName + m_csName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetEditorWindow

HRESULT CBand::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::SetEditorWindow

HRESULT CBand::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::UseOpenCloseImages

HRESULT CBand::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetRightClickMenuId

HRESULT CBand::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;

	if(	m_pIDocRootNode == this )
	{
		*pnMenuId = IDM_BAND_DOCROOT_RMENU;
	}
	else
	{
		*pnMenuId = IDM_BAND_NODE_RMENU;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::OnRightClickMenuInit

HRESULT CBand::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;
	CString strMenuText;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	IDMUSProdNode* pIThisNode = (IDMUSProdNode *)this;
	IDMUSProdNode* pIDocRootNode;

	if( !SUCCEEDED ( GetDocRootNode(&pIDocRootNode) ) )
	{
		return E_FAIL;
	}

	if( menu.Attach(hMenu) )
	{
		TCHAR achMenuText[MID_BUFFER];

		menu.EnableMenuItem( IDM_RENAME, (MF_ENABLED | MF_BYCOMMAND) );

		if( pIThisNode != pIDocRootNode )
		{
			// IDM_CUT
			if( CanCut() == S_OK )
			{
				menu.EnableMenuItem( IDM_CUT, (MF_ENABLED | MF_BYCOMMAND) );
			}
			else
			{
				menu.EnableMenuItem( IDM_CUT, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// IDM_COPY
			if( CanCopy() == S_OK )
			{
				menu.EnableMenuItem( IDM_COPY, (MF_ENABLED | MF_BYCOMMAND) );
			}
			else
			{
				menu.EnableMenuItem( IDM_COPY, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// IDM_PASTE
			{
				IDataObject* pIDataObject;
				BOOL fWillSetReference;

				menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

				if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
				{
					if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
					{
						menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
					}
					
					pIDataObject->Release();
				}
			}

			// IDM_DELETE
			if( CanDelete() == S_OK )
			{
				menu.EnableMenuItem( IDM_DELETE, (MF_ENABLED | MF_BYCOMMAND) );
			}
			else
			{
				menu.EnableMenuItem( IDM_DELETE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// IDM_RENAME
			if( m_pIParentNode == NULL )
			{
				menu.EnableMenuItem( IDM_RENAME, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// IDM_CREATE_FILE
			menu.InsertMenu( 0, MF_BYPOSITION | MF_SEPARATOR );
			::LoadString( theApp.m_hInstance, IDS_SAVE_AS_TEXT, achMenuText, MID_BUFFER );
			menu.InsertMenu( 0, MF_BYPOSITION | MF_STRING, IDM_CREATE_FILE, achMenuText );
		}

		menu.Detach();
	}

	pIDocRootNode->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::OnRightClickMenuSelect

HRESULT CBand::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	IDataObject* pIDataObject;

	switch( lCommandId )
	{
		case IDM_CREATE_FILE:
			if( SUCCEEDED ( m_pComponent->m_pIFramework->SaveNodeAsNewFile(this) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_CUT:
			if( CanCut() == S_OK )
			{
				if( SUCCEEDED ( CreateDataObject( &pIDataObject ) ) )
				{
					if( theApp.PutDataInClipboard( pIDataObject, this ) )
					{
						DeleteNode( FALSE );
					}
					
					pIDataObject->Release();
					pIDataObject = NULL;
				}
			}
			break;

		case IDM_COPY:
			if( CanCopy() == S_OK )
			{
				if( SUCCEEDED ( CreateDataObject( &pIDataObject ) ) )
				{
					theApp.PutDataInClipboard( pIDataObject, this );
					
					pIDataObject->Release();
					pIDataObject = NULL;
				}
			}
			break;

		case IDM_PASTE:
		{
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				pIDataObject->Release();
				pIDataObject = NULL;
			}
			break;
		}

		case IDM_RENAME:
			if( SUCCEEDED ( m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_DELETE:
			DeleteNode( TRUE );
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::DeleteChildNode

HRESULT CBand::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Band nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::InsertChildNode

HRESULT CBand::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Band nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::DeleteNode

HRESULT CBand::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIParentNode;

	// Let our parent delete us
    if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			// Make sure the band is removed from the notification list
			// A band is added to the notification list when an instrument references a DLS collection
			POSITION position = m_lstInstruments.GetHeadPosition();
			while(position)
			{
				CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*) m_lstInstruments.GetNext(position);
				ASSERT(pInstrumentItem);
				CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
				if(pInstrument)
					pInstrument->SetDLSCollection(NULL);
			}
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
			return hr;
		}
	}

	// No parent so we will delete ourself
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Remove from Project Tree
	if( m_pComponent->m_pIFramework->RemoveNode( this, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Make sure the band is removed from the notification list
	// A band is added t the notification list when an instrument references a DLS collection
	POSITION position = m_lstInstruments.GetHeadPosition();
	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*) m_lstInstruments.GetNext(position);
		ASSERT(pInstrumentItem);
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		if(pInstrument)
			pInstrument->SetDLSCollection(NULL);
	}


	// Remove from Component Band list
	m_pComponent->RemoveFromBandFileList( this );

//	m_pComponent->m_pIFramework->SetModifiedFlag( this, TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::OnNodeSelChanged

HRESULT CBand::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::CreateDataObject

HRESULT CBand::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Band into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_BAND into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfBand, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pIFramework->SaveClipFormat( m_pComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// There is the potential for a Band node to become a file
			// so we must also place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			pIStream->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::CanCut

HRESULT CBand::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::CanCopy

HRESULT CBand::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::CanDelete

HRESULT CBand::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			return m_pIParentNode->CanDeleteChildNode( this );
		}
		else
		{
			return S_FALSE;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::CanDeleteChildNode

HRESULT CBand::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( 0 );

	return E_NOTIMPL;	// Band nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::CanPasteFromData

HRESULT CBand::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			// Let Style, for example, decide what can be dropped
			return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
		}
	}

	// Can't drop anything on a Band file in the Project Tree
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::PasteFromData

HRESULT CBand::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			// Let Style, for example, handle paste
			return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
		}
	}

	// Can't drop anything on a Band file in the Project Tree
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::CanChildPasteFromData

HRESULT CBand::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
									  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;			// Band nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::ChildPasteFromData

HRESULT CBand::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;			// Band nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdNode::GetObject

HRESULT CBand::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit::GetDefaultFlag

HRESULT CBand::GetDefaultFlag( BOOL* pfDefaultFlag )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfDefaultFlag == NULL )
	{
		return E_POINTER;
	}

	*pfDefaultFlag = m_fDefault;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit::SetDefaultFlag

HRESULT CBand::SetDefaultFlag( BOOL fDefaultFlag )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fDefault = fDefaultFlag;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit::GetDLSRegionName

HRESULT CBand::GetDLSRegionName( DWORD dwPChannel, BYTE bMIDINote, BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

	CInstrumentListItem* pInstrumentItem;
	CDMInstrument* pInstrument;
 
	// Search instrument list for a matching PChannel
	POSITION pos = m_lstInstruments.GetHeadPosition();
	while( pos )
	{
		pInstrumentItem = m_lstInstruments.GetNext( pos );
		pInstrument = pInstrumentItem->GetInstrument();

		if( pInstrument
		&&  pInstrument->dwPChannel == dwPChannel )
		{
			// We found a matching PChannel
			// So check for a DLS collection
			if( pInstrument->m_pDMReference )
			{
				IDLSQueryInstruments* pIDLSQueryInstruments;

				// This PChannel is assigned to a DLS instrument
				// So get a pointer to the DLS Collection's IDLSQueryInstruments interface
				if( SUCCEEDED ( pInstrument->m_pDMReference->QueryInterface( IID_IDLSQueryInstruments, (void **)&pIDLSQueryInstruments ) ) )
				{
					CString strName;
					BSTR bstrName;

					// Now get the Region name
					HRESULT hr = pIDLSQueryInstruments->GetRegionWaveName( (BYTE)MSB( pInstrument->dwPatch ),
																		   (BYTE)LSB( pInstrument->dwPatch ),	
																		   (BYTE)( pInstrument->dwPatch & 0x7F ),
																			pInstrument->IsDrums(),	
																			bMIDINote,
																			&bstrName );
					pIDLSQueryInstruments->Release();
					pIDLSQueryInstruments = NULL;

					if( hr == S_OK )
					{
						strName = bstrName;
						::SysFreeString( bstrName );

						*pbstrName = strName.AllocSysString();
						return S_OK;

					}
				}
			}

			// There aren't DLS region names for this PChannel
			break;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit8 implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit8::GetPatchForPChannel

HRESULT CBand::GetPatchForPChannel( DWORD dwPChannel, DWORD *pdwPatch )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pdwPatch == NULL )
	{
		return E_POINTER;
	}

	// Search instrument list for a matching PChannel
	POSITION pos = m_lstInstruments.GetHeadPosition();
	while( pos )
	{
		CInstrumentListItem* pInstrumentItem = m_lstInstruments.GetNext( pos );
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();

		if( pInstrument
		&&  pInstrument->dwPChannel == dwPChannel )
		{
			if( pInstrument->dwFlags & DMUS_IO_INST_PATCH )
			{
				// We found a matching PChannel - copy the patch number
				*pdwPatch = pInstrument->dwPatch;
				return S_OK;
			}
			else
			{
				// Instrument doesn't have a patch set
				return DMUS_E_TYPE_DISABLED;
			}
		}
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit8a implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit8a::GetInstNameForPChannel

HRESULT CBand::GetInstNameForPChannel( DWORD dwPChannel, BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

	// Search instrument list for a matching PChannel
	POSITION pos = m_lstInstruments.GetHeadPosition();
	while( pos )
	{
		CInstrumentListItem* pInstrumentItem = m_lstInstruments.GetNext( pos );
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();

		if( pInstrument
		&&  pInstrument->dwPChannel == dwPChannel )
		{
			if( pInstrument->dwFlags & DMUS_IO_INST_PATCH )
			{
				// We found a matching PChannel - determine the instrument name
				CString strName = CBandDlg::GetPatchName( m_pComponent, pInstrument);
				if( !strName.IsEmpty() )
				{
					*pbstrName = strName.AllocSysString();
					return S_OK;
				}
				else
				{
					// Instrument doesn't have a name set
					return E_FAIL;
				}
			}
			else
			{
				// Instrument doesn't have a patch set
				return DMUS_E_TYPE_DISABLED;
			}
		}
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit8a::DisplayInstrumentButton

HRESULT CBand::DisplayInstrumentButton( DWORD dwPChannel, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Search instrument list for a matching PChannel
	POSITION pos = m_lstInstruments.GetHeadPosition();
	while( pos )
	{
		CInstrumentListItem* pInstrumentItem = m_lstInstruments.GetNext( pos );
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();

		if( pInstrument
		&&  pInstrument->dwPChannel == dwPChannel )
		{
			if( pInstrument->dwFlags & DMUS_IO_INST_PATCH )
			{
				// We found a matching PChannel - display the popup menu
				HMENU hmenu = CPChannelPropPage::m_hmenuDrums;

				if(dwPChannel != 9 && dwPChannel%16 != 9)
					hmenu = CPChannelPropPage::m_hmenuPatch;

				m_pDMInstrumentForContextMenu = pInstrument;
				m_dwPChannelForContextMenu = dwPChannel;

				TrackPopupMenu( GetSubMenu( hmenu, 0 ), TPM_LEFTALIGN | TPM_VCENTERALIGN | TPM_LEFTBUTTON,
											lXPos, lYPos, 0, m_ContextMenuHandler.GetSafeHwnd(), NULL );
				return S_OK;
			}
			else
			{
				// Instrument doesn't have a patch set
				return DMUS_E_TYPE_DISABLED;
			}
		}
	}

	return E_INVALIDARG;
}

HRESULT CBand::OnContextCommand( WPARAM wParam, LPARAM lParam )
{
	// not a menu message
	if( lParam )  
	{
		return E_NOTIMPL;
	}

	if( wParam == ID_INSERT_NEWINSTRUMENT )
	{
		return InsertPChannel( m_dwPChannelForContextMenu, FALSE );
	}
	else if( wParam == ID_OPEN_BANDEDITOR )
	{
		return m_pComponent->m_pIFramework->OpenEditor( this );
	}

	//
	// This is very similar to CPChannelPropPage::OnCommand - please try to keep them in sync!
	//

	// check for program changes
	BInstr  *pbi;

	pbi = &abiGS[0];
	int nCount = 0;
	while( pbi->nStringId != IDS_PGMEND )
	{
		if( pbi->nStringId == wParam )
		{
			// Save the state for undo
			// Not necessary - this is only called if we're embedded in a segment,
			// so the segment handles the Undo queue
			//pBandDlg->SaveStateForUndo("Program Change");

			CString sName = *pbi->pstrName;

			const DWORD dwOrigPatch = m_pDMInstrumentForContextMenu->dwPatch;
			const IDMUSProdReferenceNode *pOrigRefNode = m_pDMInstrumentForContextMenu->m_pDMReference;

			CInstrumentListItem::m_CommonPropertyObject.SetPatch(pbi->bPatch);
			CInstrumentListItem::m_CommonPropertyObject.SetInstrument(sName);
			CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = INSTRUMENT_CHANGED;
			CInstrumentListItem::m_CommonPropertyObject.m_dwInstrumentChangeID = 0;
			CInstrumentListItem::m_CommonPropertyObject.m_nABIIndex = nCount;

			CInstrumentListItem::m_CommonPropertyObject.ApplyInstrumentChange( m_pDMInstrumentForContextMenu );

			// Check if anything actually changed
			if( dwOrigPatch == m_pDMInstrumentForContextMenu->dwPatch
			&&	pOrigRefNode == m_pDMInstrumentForContextMenu->m_pDMReference )
			{
				return S_FALSE;
			}

			// We need to update if somebody else does a Send
			CDMInstrument::m_bSendBandUpdate = TRUE;
			if(m_pDMInstrumentForContextMenu->SendBandUpdate(this))
			{
				CDMInstrument::m_bSendBandUpdate = FALSE;
				CInstrumentListItem::m_CommonPropertyObject.SyncChanges(m_pDMInstrumentForContextMenu, this);
			}
			CDMInstrument::m_bSendBandUpdate = TRUE;
			SetModifiedFlag( TRUE );

			// Refresh the display
			if( m_pBandCtrl
			&&	m_pBandCtrl->m_pBandDlg )
			{
				m_pBandCtrl->m_pBandDlg->UpdatePChannelChanges(true, false);
			}

			return S_OK;
		}
		pbi++;
		nCount++;
	}

	// check for drum program changes
	pbi = &abiDrums[0];
	nCount = 0;
	while( pbi->nStringId != IDS_PGMEND )
	{
		if( pbi->nStringId == wParam )
		{
			// Save the state for undo
			// Not necessary - this is only called if we're embedded in a segment,
			// so the segment handles the Undo queue
			//pBandDlg->SaveStateForUndo("Program Change");

			CString sName = *pbi->pstrName;

			const DWORD dwOrigPatch = m_pDMInstrumentForContextMenu->dwPatch;
			const IDMUSProdReferenceNode *pOrigRefNode = m_pDMInstrumentForContextMenu->m_pDMReference;

			CInstrumentListItem::m_CommonPropertyObject.SetPatch(pbi->bPatch);
			CInstrumentListItem::m_CommonPropertyObject.SetInstrument(sName);
			CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = INSTRUMENT_CHANGED;
			CInstrumentListItem::m_CommonPropertyObject.m_dwInstrumentChangeID = DRUMS_REQUEST;
			CInstrumentListItem::m_CommonPropertyObject.m_nABIIndex = nCount;

			CInstrumentListItem::m_CommonPropertyObject.ApplyInstrumentChange( m_pDMInstrumentForContextMenu );

			// Check if anything actually changed
			if( dwOrigPatch == m_pDMInstrumentForContextMenu->dwPatch
			&&	pOrigRefNode == m_pDMInstrumentForContextMenu->m_pDMReference )
			{
				return S_FALSE;
			}

			// We need to update if somebody else does a Send
			CDMInstrument::m_bSendBandUpdate = TRUE;
			if(m_pDMInstrumentForContextMenu->SendBandUpdate(this))
			{
				CDMInstrument::m_bSendBandUpdate = FALSE;
				CInstrumentListItem::m_CommonPropertyObject.SyncChanges(m_pDMInstrumentForContextMenu, this);
			}
			CDMInstrument::m_bSendBandUpdate = TRUE;
			SetModifiedFlag( TRUE );

			// Refresh the display
			if( m_pBandCtrl
			&&	m_pBandCtrl->m_pBandDlg )
			{
				m_pBandCtrl->m_pBandDlg->UpdatePChannelChanges(true, false);
			}

			return S_OK;
		}
		pbi++;
		nCount++;
	}

	// Check if it's other DLS request
	if( wParam == IDS_DLS )
	{
		// Save the state for undo
		// Not necessary - this is only called if we're embedded in a segment,
		// so the segment handles the Undo queue
		//pBandDlg->SaveStateForUndo("Program Change");

		const DWORD dwOrigPatch = m_pDMInstrumentForContextMenu->dwPatch;
		const IDMUSProdReferenceNode *pOrigRefNode = m_pDMInstrumentForContextMenu->m_pDMReference;

		CInstrumentListItem::m_CommonPropertyObject.m_dwInstrumentChangeID = DLS_REQUEST;
		CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = INSTRUMENT_CHANGED;

		CInstrumentListItem::m_CommonPropertyObject.ApplyInstrumentChange( m_pDMInstrumentForContextMenu, &m_strDefaultCollection );

		// Check if anything actually changed
		if( dwOrigPatch == m_pDMInstrumentForContextMenu->dwPatch
		&&	pOrigRefNode == m_pDMInstrumentForContextMenu->m_pDMReference )
		{
			return S_FALSE;
		}

		// We need to update if somebody else does a Send
		CDMInstrument::m_bSendBandUpdate = TRUE;
		if(m_pDMInstrumentForContextMenu->SendBandUpdate(this))
		{
			CDMInstrument::m_bSendBandUpdate = FALSE;
			CInstrumentListItem::m_CommonPropertyObject.SyncChanges(m_pDMInstrumentForContextMenu, this);
		}
		CDMInstrument::m_bSendBandUpdate = TRUE;
		SetModifiedFlag( TRUE );

		// Refresh the display
		if( m_pBandCtrl
		&&	m_pBandCtrl->m_pBandDlg )
		{
			m_pBandCtrl->m_pBandDlg->UpdatePChannelChanges(true, false);
		}

		return S_OK;
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit8a::InsertPChannel

HRESULT CBand::InsertPChannel( DWORD dwPChannel, BOOL fClearBandFirst )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( dwPChannel > 999 )
	{
		return E_INVALIDARG;
	}

	if( fClearBandFirst )
	{
		DeleteInstrumentList();
	}

	// Search instrument list for a matching PChannel
	CInstrumentListItem* pMatchingInstrumentItem = NULL;
	POSITION pos = m_lstInstruments.GetHeadPosition();
	while( pos )
	{
		CInstrumentListItem* pInstrumentItem = m_lstInstruments.GetNext( pos );
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();

		if( pInstrument
		&&  pInstrument->dwPChannel == dwPChannel )
		{
			if( pInstrument->dwFlags & DMUS_IO_INST_PATCH )
			{
				// We found a matching PChannel - fail
				return E_INVALIDARG;
			}
			else
			{
				pMatchingInstrumentItem = pInstrumentItem;
				break;
			}
		}
	}

	if( pMatchingInstrumentItem )
	{
		// If there already is an instrument for this channel
		CDMInstrument* pInstrument = pMatchingInstrumentItem->GetInstrument();
		pInstrument->ResetInstruemnt();
		pInstrument->dwPatch = MAKE_PATCH(pInstrument->IsDrums(), 0, 0, 0);
		int nPriorityIndex = pInstrument->dwPChannel%16;
		pInstrument->dwChannelPriority = dwaPriorities[nPriorityIndex];
		pInstrument->dwFlags = DMUS_IO_INST_GM | DMUS_IO_INST_PITCHBENDRANGE | DMUS_IO_INST_TRANSPOSE | DMUS_IO_INST_VOLUME | DMUS_IO_INST_PAN | DMUS_IO_INST_BANKSELECT | DMUS_IO_INST_PATCH;
		pInstrument->SendBandUpdate(this);
	}
	else
	{
		// No matching instrument - need to create a new one
		POSITION position = m_lstInstruments.FindIndex(dwPChannel - 1);
		CDMInstrument* pInstrument = new CDMInstrument();
		pInstrument->SetComponent(m_pComponent);
		pInstrument->SetBand(this);
		pInstrument->dwPChannel = dwPChannel;
		pInstrument->dwPatch = MAKE_PATCH(pInstrument->IsDrums(), 0, 0, 0);
		int nPriorityIndex = pInstrument->dwPChannel%16;
		pInstrument->dwChannelPriority = dwaPriorities[nPriorityIndex];
		pInstrument->dwFlags = DMUS_IO_INST_GM | DMUS_IO_INST_PITCHBENDRANGE | DMUS_IO_INST_TRANSPOSE | DMUS_IO_INST_VOLUME | DMUS_IO_INST_PAN | DMUS_IO_INST_BANKSELECT | DMUS_IO_INST_PATCH;
		pMatchingInstrumentItem = new CInstrumentListItem(pInstrument);
		m_lstInstruments.InsertAfter(position, pMatchingInstrumentItem);
		pInstrument->SendBandUpdate(this);
	}

	CDMInstrument* pInstrument = pMatchingInstrumentItem->GetInstrument();
	ASSERT(pInstrument);
	pInstrument->Send(this, DM_PATCH_CHANGE);
	SetModifiedFlag( TRUE );

	// Refresh the display
	if( m_pBandCtrl
	&&	m_pBandCtrl->m_pBandDlg )
	{
		m_pBandCtrl->m_pBandDlg->UpdatePChannelChanges(true, false);
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandEdit8a::SetAudiopath

HRESULT CBand::SetAudiopath( IUnknown* punkAudiopath )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	RELEASE( m_pAudiopath );

	if( punkAudiopath )
	{
		return punkAudiopath->QueryInterface( IID_IDirectMusicAudioPath, (void **)&m_pAudiopath );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandMgrEdit implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdBandMgrEdit::DisplayEditBandButton

HRESULT CBand::DisplayEditBandButton( DWORD dwPChannel, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Enable the "New Instrument" item if this is true
	bool fEnableNewInstrument = true;

	// Search instrument list for a matching PChannel
	POSITION pos = m_lstInstruments.GetHeadPosition();
	while( pos )
	{
		CInstrumentListItem* pInstrumentItem = m_lstInstruments.GetNext( pos );
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();

		if( pInstrument
		&&  pInstrument->dwPChannel == dwPChannel )
		{
			if( pInstrument->dwFlags & DMUS_IO_INST_PATCH )
			{
				// We found a matching PChannel - set fEnableNewInstrument to false
				fEnableNewInstrument = false;
				break;
			}
			else
			{
				// We found a matching PChannel, but it doesn't have a patch
				// Keep fEnableNewInstrument at true
				break;
			}
		}
	}

	// Load the menu
	HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_BANDMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	// Enable the items appropriately
	::EnableMenuItem( hMenuPopup, ID_OPEN_BANDEDITOR, MF_ENABLED );
	::EnableMenuItem( hMenuPopup, ID_INSERT_NEWINSTRUMENT, fEnableNewInstrument ? MF_ENABLED : MF_GRAYED );

	// Save the PChannel # and instrument
	m_dwPChannelForContextMenu = dwPChannel;
	m_pDMInstrumentForContextMenu = NULL; // Not used

	// Display the menu
	TrackPopupMenu( hMenuPopup, TPM_LEFTALIGN | TPM_RIGHTBUTTON, lXPos, lYPos, 0, m_ContextMenuHandler.GetSafeHwnd(), NULL );

	// Cleanup
	::DestroyMenu( hMenu );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IPersist::GetClassID

HRESULT CBand::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IPersistStream::IsDirty

HRESULT CBand::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ( m_fDirty ) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IPersistStream::Load

HRESULT CBand::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBandCtrl	&&  m_pBandCtrl->m_pBandDlg )
	{
		m_pBandCtrl->m_pBandDlg->m_MixGrid.RemoveAllButtons();
	}

	IDMUSProdRIFFStream* pIRiffStream;
	MMCKINFO ckMain;

	ASSERT( pIStream != NULL );
	ASSERT( m_pComponent != NULL );


	HRESULT hr = E_FAIL;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
        if( pIRiffStream->Descend( &ckMain, NULL, 0 ) == 0 )
        {
			if (ckMain.ckid == FOURCC_RIFF)
			{
				if (ckMain.fccType == FOURCC_BAND_FORM)
				{
					hr = Load_IMA_Band( pIRiffStream, &ckMain );
				}
				else if (ckMain.fccType == DMUS_FOURCC_BAND_FORM)
				{
					hr = LoadDMBand( pIRiffStream, &ckMain );
				}
			}
        }

		pIRiffStream->Release();
    }

	// Update the mixer grid...
	// Load could be called through the Undo call thread...
	if( m_pBandCtrl	&&  m_pBandCtrl->m_pBandDlg )
	{
		m_pBandCtrl->m_pBandDlg->RemoveAndAddAllButtonsToGrid();
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CBand IPersistStream::Save

HRESULT CBand::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    HRESULT hr = E_FAIL;
    MMCKINFO ckMain;

	// Save the Band
	if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return E_FAIL;
	}
		
	ckMain.fccType = DMUS_FOURCC_BAND_FORM;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
		&&  SUCCEEDED( SaveBandChunk( pIRiffStream ) )
		&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
	{
		if( fClearDirty )
		{
			SetModifiedFlag( FALSE );
		}
		
		hr = S_OK;
	}
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IPersistStream::GetSizeMax

HRESULT CBand::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CBand INotifySink Implementation

/////////////////////////////////////////////////////////////////////////////
// CBand::OnUpdate

HRESULT CBand::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID( guidUpdateType, GUID_BAND_UpdatePerformanceMsg ))
	{
		if( pIDocRootNode == m_pIDocRootNode )
		{
			SendBand();
			return S_OK;
		}
		return E_INVALIDARG;
	}

	if(::IsEqualGUID( guidUpdateType, GUID_DMCollectionResync ))
	{
		IDMUSProdNode* pIDocRootNodeDLS = NULL;
		CDMInstrument* pInstrument = NULL;
		CInstrumentListItem *pInstrumentItem = NULL;

		// A DLS Collection used by this Band is resyncing it's IDirectMusicCollection object
		POSITION position = m_lstInstruments.GetHeadPosition();
		while( position )
		{
			pInstrumentItem = m_lstInstruments.GetNext( position );
			pInstrument = pInstrumentItem->GetInstrument();

			if( pInstrument != NULL && pInstrument->m_pDMReference )
			{
				if( SUCCEEDED (	pInstrument->m_pDMReference->GetReferencedFile( &pIDocRootNodeDLS ) ) )
				{
					if( pIDocRootNodeDLS == pIDocRootNode )
					{
						SendBand();
						pIDocRootNodeDLS->Release();
						break;
					}

					pIDocRootNodeDLS->Release();
				}
			}
		}

		return S_OK;
	}

	else if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileNameChange )
		 ||  ::IsEqualGUID(guidUpdateType, DOCROOT_GuidChange ) 
		 ||  ::IsEqualGUID(guidUpdateType, COLLECTION_NameChange))
	{
		IDMUSProdNode* pIDocRootNodeDLS;

		CDMInstrument* pInstrument;
		CInstrumentListItem *pInstrumentItem;

		// A DLS Collection used by this Band was renamed or had its GUID changed
		POSITION position = m_lstInstruments.GetHeadPosition();
		while( position )
		{
			pInstrumentItem = m_lstInstruments.GetNext( position );
			pInstrument = pInstrumentItem->GetInstrument();

			if( pInstrument != NULL && pInstrument->m_pDMReference )
			{
				if( SUCCEEDED (	pInstrument->m_pDMReference->GetReferencedFile( &pIDocRootNodeDLS ) ) )
				{
					if( pIDocRootNodeDLS == pIDocRootNode )
					{
						SetModifiedFlag( TRUE );
						// No need to change text on patch button, it didn't change
						// but change the collection name on the static
						BSTR bstrDLSName;
						pIDocRootNodeDLS->GetNodeName(&bstrDLSName);
						pInstrument->m_csCollection = bstrDLSName;
					}

					pIDocRootNodeDLS->Release();
				}
			}
		}

		return S_OK;
	}

	else if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileDeleted )
		 ||  ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileClosed ) )
	{
		IDMUSProdNode* pIDocRootNodeDLS;

		CDMInstrument* pInstrument;
		CInstrumentListItem *pInstrumentItem;

		// A DLS Collection used by this Band was deleted or closed
		POSITION position = m_lstInstruments.GetHeadPosition();
		while( position )
		{
			pInstrumentItem = m_lstInstruments.GetNext( position );
			pInstrument = pInstrumentItem->GetInstrument();

			if( pInstrument != NULL && pInstrument->m_pDMReference )
			{
				if( SUCCEEDED (	pInstrument->m_pDMReference->GetReferencedFile( &pIDocRootNodeDLS ) ) )
				{
					if( pIDocRootNodeDLS == pIDocRootNode )
					{
						pInstrument->SetDLSCollection( NULL );

						if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileDeleted ) )
						{
							SetModifiedFlag( TRUE );
						}

						// Change text on patch button
						if( m_pBandCtrl	&& m_pBandCtrl->m_pBandDlg )
						{
							long lOrigTrackEdit = m_pBandCtrl->m_pBandDlg->m_nTrackEdit;

							m_pBandCtrl->m_pBandDlg->m_nTrackEdit = pInstrument->dwPChannel + 1;
							m_pBandCtrl->m_pBandDlg->UpdatePChannelList();
							m_pBandCtrl->m_pBandDlg->RefreshPChannelPropertyPage();
							
							m_pBandCtrl->m_pBandDlg->m_nTrackEdit = lOrigTrackEdit; 
						}
					}

					pIDocRootNodeDLS->Release();
				}
			}
		}

		// Refresh Band Editor
		if( m_pBandCtrl
		&&  m_pBandCtrl->m_pBandDlg )
		{
			m_pBandCtrl->m_pBandDlg->InvalidateRect( NULL );
			m_pBandCtrl->m_pBandDlg->UpdateWindow();
		}

		return S_OK;
	}

	else if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileReplaced ) )
	{
		IDMUSProdNode* pIDocRootNodeDLS;

		CDMInstrument* pInstrument;
		CInstrumentListItem *pInstrumentItem;

		// A DLS Collection used by this Band was replaced in the Project Tree
		POSITION position = m_lstInstruments.GetHeadPosition();
		while( position )
		{
			pInstrumentItem = m_lstInstruments.GetNext( position );
			pInstrument = pInstrumentItem->GetInstrument();

			if( pInstrument != NULL && pInstrument->m_pDMReference )
			{
				if( SUCCEEDED (	pInstrument->m_pDMReference->GetReferencedFile( &pIDocRootNodeDLS ) ) )
				{
					if( pIDocRootNodeDLS == pIDocRootNode )
					{
						IDMUSProdReferenceNode* pCollectionRef = m_pComponent->CreateCollectionRefNode( (IDMUSProdNode *)pData );
						if( pCollectionRef )
						{
							pInstrument->SetDLSCollection( pCollectionRef );
							SetModifiedFlag( TRUE );

							// Change text on patch button
							if( m_pBandCtrl
							&&  m_pBandCtrl->m_pBandDlg )
							{
								long lOrigTrackEdit = m_pBandCtrl->m_pBandDlg->m_nTrackEdit;

								m_pBandCtrl->m_pBandDlg->m_nTrackEdit = pInstrument->dwPChannel + 1;
								m_pBandCtrl->m_pBandDlg->UpdatePChannelList();
								
								m_pBandCtrl->m_pBandDlg->m_nTrackEdit = lOrigTrackEdit; 
							}

							pCollectionRef->Release();
						}
					}

					pIDocRootNodeDLS->Release();
				}
			}
		}

		// Refresh Band Editor
		if( m_pBandCtrl	&&  m_pBandCtrl->m_pBandDlg )
		{
			m_pBandCtrl->m_pBandDlg->InvalidateRect( NULL );
			m_pBandCtrl->m_pBandDlg->UpdateWindow();
		}

		return S_OK;
	}
	else if(::IsEqualGUID(guidUpdateType, INSTRUMENT_NameChange) ||
			::IsEqualGUID(guidUpdateType, INSTRUMENT_Deleted))
	{
		// Just refresh the dialog
		if( m_pBandCtrl	&&  m_pBandCtrl->m_pBandDlg )
		{
			m_pBandCtrl->m_pBandDlg->m_PChannelList.Invalidate();
			if(::IsEqualGUID(guidUpdateType, INSTRUMENT_Deleted))
				m_pBandCtrl->m_pBandDlg->RefreshDisplay();
		}
		
		return S_OK;
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand additional functions

/////////////////////////////////////////////////////////////////////////////
// CBand::SendBand

void CBand::SendBand( )
{
	IDirectMusicBand* pIDMBand;

	CWaitCursor wait;

	// Persist the Band into a DirectMusicBand object
	if( SUCCEEDED ( ::CoCreateInstance( CLSID_DirectMusicBand, NULL, CLSCTX_INPROC, IID_IDirectMusicBand, (void**)&pIDMBand ) ) )
	{
		IStream* pIMemStream;
		IPersistStream* pIPersistStreamEngine;

		if( SUCCEEDED ( m_pComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream ) ) )
		{
			if( SUCCEEDED ( Save( pIMemStream, FALSE ) ) )
			{
				if( SUCCEEDED ( pIDMBand->QueryInterface( IID_IPersistStream, (void **)&pIPersistStreamEngine ) ) )
				{
					StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
					pIPersistStreamEngine->Load( pIMemStream );

					// Send the Band
					IDirectMusicSegment* pIDMSegmentBand;

					if( SUCCEEDED ( pIDMBand->CreateSegment( &pIDMSegmentBand ) ) )
					{
						HRESULT hr = m_pComponent->m_pIDMPerformance->PlaySegment( pIDMSegmentBand,
								 DMUS_SEGF_SECONDARY, 0, NULL );
						pIDMSegmentBand->Release();
					}

					pIPersistStreamEngine->Release();
				}
			}

			pIMemStream->Release();
		}

		pIDMBand->Release();
	}
}

HRESULT CBand::NotifyEveryone( GUID guidNotification)
{
	ASSERT(m_pIDocRootNode);
	if(m_pIDocRootNode == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	if( m_pIDocRootNode != this )
	{
		IDMUSProdNotifySink* pINotifySink = NULL;
		if( SUCCEEDED ( m_pIDocRootNode->QueryInterface(IID_IDMUSProdNotifySink, (void**)&pINotifySink) ) )
		{
			// Ask DocRoot if change should be sent
			if( pINotifySink->OnUpdate( this, guidNotification, NULL ) == S_OK )
			{
				SendBand();
			}

			pINotifySink->Release();
		}
	}

	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_UNEXPECTED;
	}

	pIFramework->NotifyNodes(this, guidNotification, NULL);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand::Activate

void CBand::Activate( void )
{
	// Notify DocRoot that this Band Editor is the active window
	if( m_pIDocRootNode != (IDMUSProdNode *)this )
	{
		IDMUSProdNotifySink* pINotifySink;

		if( SUCCEEDED ( m_pIDocRootNode->QueryInterface(IID_IDMUSProdNotifySink, (void**)&pINotifySink) ) )
		{
			// Ask DocRoot if change should be sent
			if( pINotifySink->OnUpdate( this, GUID_BAND_ActivateNotifyMsg, NULL ) == S_OK )
			{
				SendBand();
			}

			pINotifySink->Release();
		}
	}
	m_pBandCtrl->m_pBandDlg->m_PChannelList.SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CBand::EnablePatch

void CBand::EnablePatch( int nIndex )
{
	CDMInstrument* pInstrument = GetInstrumentFromList(nIndex);
	
	ASSERT(pInstrument);
	if(pInstrument == NULL)
		return;

	pInstrument->dwFlags |= 
				(DMUS_IO_INST_TRANSPOSE | DMUS_IO_INST_PAN | DMUS_IO_INST_VOLUME | DMUS_IO_INST_PATCH);
}


/////////////////////////////////////////////////////////////////////////////
// CBand::RemoveFromNotifyList

void CBand::RemoveFromNotifyList( IDMUSProdReferenceNode* pDMReferenceNode )
{
	CLinkedDLSCollection* pTheLinkedDLSCollection = NULL;
	IDMUSProdNode* pIDocRootNode;

	if( SUCCEEDED (	pDMReferenceNode->GetReferencedFile( &pIDocRootNode ) ) )
	{
		CLinkedDLSCollection* pLinkedDLSCollection;

		POSITION pos = m_lstDLSCollections.GetHeadPosition();
		while( pos )
		{
			pLinkedDLSCollection = m_lstDLSCollections.GetNext( pos );

			if( pLinkedDLSCollection->m_pIDocRootNode == pIDocRootNode )
			{
				pTheLinkedDLSCollection = pLinkedDLSCollection;
				break;
			}
		}

		if( pTheLinkedDLSCollection )
		{
			ASSERT( pTheLinkedDLSCollection->m_dwUseCount > 0 );

			pTheLinkedDLSCollection->m_dwUseCount--;

			if( pTheLinkedDLSCollection->m_dwUseCount == 0 )
			{
				// Remove from DLS Collection's notify list
				theApp.m_pIFramework->RemoveFromNotifyList( pIDocRootNode, this );

				// Remove from Band's DLS Collection list
				pos = m_lstDLSCollections.Find( pTheLinkedDLSCollection );
				if( pos )
				{
					m_lstDLSCollections.RemoveAt( pos );
					delete pTheLinkedDLSCollection;
				}
			}
		}

		pIDocRootNode->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBand::AddToNotifyList

void CBand::AddToNotifyList( IDMUSProdReferenceNode* pDMReferenceNode )
{
	CLinkedDLSCollection* pTheLinkedDLSCollection = NULL;
	IDMUSProdNode* pIDocRootNode;

	if( SUCCEEDED (	pDMReferenceNode->GetReferencedFile( &pIDocRootNode ) ) )
	{
		CLinkedDLSCollection* pLinkedDLSCollection;

		POSITION pos = m_lstDLSCollections.GetHeadPosition();
		while( pos )
		{
			pLinkedDLSCollection = m_lstDLSCollections.GetNext( pos );

			if( pLinkedDLSCollection->m_pIDocRootNode == pIDocRootNode )
			{
				pTheLinkedDLSCollection = pLinkedDLSCollection;
				break;
			}
		}

		if( pTheLinkedDLSCollection )
		{
			pTheLinkedDLSCollection->m_dwUseCount++;
		}
		else
		{
			pTheLinkedDLSCollection = new CLinkedDLSCollection( pIDocRootNode );
			if( pTheLinkedDLSCollection )
			{
				// Add to DLS Collection file's notify list
				if( SUCCEEDED ( theApp.m_pIFramework->AddToNotifyList( pIDocRootNode, this ) ) )
				{
					m_lstDLSCollections.AddTail( pTheLinkedDLSCollection );
				}
				else
				{
					delete pTheLinkedDLSCollection;
				}
			}
		}

		pIDocRootNode->Release();
	}
}


CDMInstrument* CBand::GetInstrumentFromList(long lPChannel)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if(m_lstInstruments.IsEmpty())
		return NULL;

	CInstrumentListItem* pInstrumentItem = GetInstrumentItemFromList(lPChannel);
	if(pInstrumentItem)
	{
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);
		return pInstrument;
	}
	return NULL;
}

CInstrumentListItem* CBand::GetInstrumentItemFromList(long lPChannel)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if(lPChannel < 0 || m_lstInstruments.IsEmpty())
		return NULL;
	
	POSITION position = m_lstInstruments.GetHeadPosition();
	while(position)
	{
		CInstrumentListItem* pInstrumentListItem = (CInstrumentListItem*)m_lstInstruments.GetNext(position);
		if(pInstrumentListItem == NULL)
			break;

		CDMInstrument* pInstrument = pInstrumentListItem->GetInstrument();
		if(pInstrument->dwPChannel == (DWORD)lPChannel)
			return pInstrumentListItem;
	}
	return NULL;
}

int CBand::GetInstrumentCount()
{
	return m_lstInstruments.GetCount();
}


//////////////////////////////////////////////////////
// CBand::GetInstrumentByIndex(int nIndex)
//
// This just gets instruments based on the passed index and NOT on the PChannel
// This method assumes that the passed index would exist and returns NULL if
// an instrument at that index was not found.
CDMInstrument* CBand::GetInstrumentByIndex(int nIndex)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if(m_lstInstruments.IsEmpty())
		return NULL;
	
	POSITION position = m_lstInstruments.FindIndex(nIndex);
	CInstrumentListItem* pInstrumentListItem = m_lstInstruments.GetAt(position);
	CDMInstrument* pInstrument = pInstrumentListItem->GetInstrument();
	return pInstrument;
}

CInstrumentListItem* CBand::GetInstrumentItemByIndex(int nCount)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CInstrumentListItem* pInstrumentListItem = NULL;
	
	POSITION position = m_lstInstruments.FindIndex(nCount);
	pInstrumentListItem = m_lstInstruments.GetAt(position);
	ASSERT(pInstrumentListItem);
	
	return pInstrumentListItem;
	
}
	
int CBand::GetNumberOfSelectedInstruments()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nCount = 0;
	CInstrumentListItem* pInstrumentItem = NULL;
	POSITION position = m_lstInstruments.GetHeadPosition();

	while(position)
	{
		pInstrumentItem = m_lstInstruments.GetNext(position);
		if(pInstrumentItem->IsSelected())
		{
			nCount++;
		}
	}
	return nCount;
}


int CBand::GetSelectedInstruments(CInstrumentListItem** ppInstrumentArray)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(ppInstrumentArray);

	int nCount = 0;
	CInstrumentListItem* pInstrumentItem;
	POSITION position = m_lstInstruments.GetHeadPosition();

	while(position)
	{
		pInstrumentItem = m_lstInstruments.GetNext(position);
		if(pInstrumentItem->IsSelected())
		{
			ppInstrumentArray[nCount] = pInstrumentItem;
			nCount++;
		}
	}
	return nCount;
}

void CBand::SelectAllInstruments()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	POSITION position = m_lstInstruments.GetHeadPosition();
	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)m_lstInstruments.GetNext(position);
		ASSERT(pInstrumentItem);
		pInstrumentItem->SetSelected(true);
	}
}

void CBand::UnselectAllInstruments()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CInstrumentListItem* pInstrumentItem;
	POSITION position = m_lstInstruments.GetHeadPosition();

	while(position)
	{
		pInstrumentItem = m_lstInstruments.GetNext(position);
		if(pInstrumentItem->IsSelected())
		{
			pInstrumentItem->SetSelected(false);
		}
	}

}


DWORD CBand::GetNextAvailablePChannel(DWORD dwStartChannel)
{
	DWORD dwHighestPChannelInList = 0;

	POSITION position = m_lstInstruments.GetHeadPosition();
	DWORD dwLastPChannel = dwStartChannel;
	
	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)m_lstInstruments.GetNext(position);
		ASSERT(pInstrumentItem);
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		DWORD dwPChannelInList = pInstrument->dwPChannel + 1;
		
		// If a vacant position return the last position + 1
		if(dwLastPChannel < dwPChannelInList - 1)		
		{
			return dwLastPChannel;						
		}

		if(dwLastPChannel < dwPChannelInList)
		{
			dwLastPChannel = dwPChannelInList;
		}

		if(dwStartChannel <= dwPChannelInList)
		{
			dwLastPChannel = dwPChannelInList;
		}

		if(dwHighestPChannelInList < dwLastPChannel)
		{
			dwHighestPChannelInList = dwLastPChannel;
		}
	}
	
	if(dwLastPChannel == dwStartChannel)
	{
		dwHighestPChannelInList = dwLastPChannel;
	}
	
	return (dwHighestPChannelInList);	

}


DWORD CBand::GetNextAvailablePChannel()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DWORD dwHighestPch = 0;

	CInstrumentListItem* pInstrumentItem;

	POSITION position = m_lstInstruments.GetHeadPosition();
	int nLastPChannel = -1;
	
	while(position)
	{
		pInstrumentItem = m_lstInstruments.GetNext(position);
		ASSERT(pInstrumentItem);
		
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		if(nLastPChannel < (int)pInstrument->dwPChannel - 1) // If a vacant position
		{
			return nLastPChannel + 1;						 // Return the last position + 1
		}
		else if(nLastPChannel < (int)pInstrument->dwPChannel)
		{
			nLastPChannel = (int)pInstrument->dwPChannel;
		}
		
		if((int)dwHighestPch < nLastPChannel)
		{
			dwHighestPch = nLastPChannel;
		}
	}
	
	if(nLastPChannel == -1)
	{
		dwHighestPch = nLastPChannel;
	}
	
	return (dwHighestPch + 1);	
}


DWORD CBand::GetLastAvailablePChannel(DWORD nStartIndex)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((int)nStartIndex == 0)
	{
		return 0;
	}

	CInstrumentListItem* pInstrumentItem;
	POSITION position = m_lstInstruments.GetTailPosition();
	
	int nLastPChannel = (int)nStartIndex - 1;

	while(position)
	{
		pInstrumentItem = m_lstInstruments.GetPrev(position);
		ASSERT(pInstrumentItem);
		
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		if(nLastPChannel > (int)pInstrument->dwPChannel + 1) // If a vacant position
		{
			return nLastPChannel - 1;
		}
		else if(nLastPChannel > (int)pInstrument->dwPChannel)
		{
			nLastPChannel = (int)pInstrument->dwPChannel;
		}
	}

	nLastPChannel--;
	nLastPChannel = nLastPChannel < 0 ? nStartIndex : nLastPChannel;
	nLastPChannel = nLastPChannel > 998 ? nStartIndex : nLastPChannel;


	// None before were found so return the start index
	return (nLastPChannel);	
}




void CBand::InsertIntoInstrumentList(CInstrumentListItem* pInstrumentItem)
{

	ASSERT(pInstrumentItem);
	CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
	ASSERT(pInstrument);
	
	POSITION position = m_lstInstruments.GetHeadPosition();

	while(position)
	{
		CInstrumentListItem* pListInstrumentItem = (CInstrumentListItem*)m_lstInstruments.GetNext(position);
		ASSERT(pListInstrumentItem);
		CDMInstrument* pListInstrument = pListInstrumentItem->GetInstrument();
		ASSERT(pListInstrument);

		if(pListInstrument->dwPChannel >= pInstrument->dwPChannel + 1)
		{
			POSITION matchPosition = m_lstInstruments.Find(pListInstrumentItem);
			m_lstInstruments.InsertBefore(matchPosition, pInstrumentItem);
			pInstrument->SendBandUpdate(this);
			return;
		}

	}
	
	m_lstInstruments.AddTail(pInstrumentItem);
	pInstrument->SendBandUpdate(this);
}

CInstrumentListItem* CBand::ChangePChannelNumber(DWORD oldPChannel, DWORD newPChannel)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Do nothing if no change in the PChannel number
	if(oldPChannel == newPChannel)
	{
		return NULL;
	}
	
	CInstrumentListItem* pInstrumentListItem = NULL;
	CDMInstrument* pInstrument = NULL;
		
	POSITION position = m_lstInstruments.GetHeadPosition();
	while(position)
	{
		POSITION oldPosition = position;
		pInstrumentListItem = (CInstrumentListItem*)m_lstInstruments.GetNext(position);
		ASSERT(pInstrumentListItem);
		pInstrument = pInstrumentListItem->GetInstrument();
		ASSERT(pInstrument);

		if(pInstrument->dwPChannel == oldPChannel) 
		{
			m_lstInstruments.RemoveAt(oldPosition);
			break;
		}
	}
	
	if(pInstrumentListItem)
	{
		pInstrument->dwPChannel = newPChannel;
		InsertIntoInstrumentList(pInstrumentListItem);
	}

	return pInstrumentListItem;
}

	
	
CInstrumentListItem* CBand::InsertIntoInstrumentList()
{
	CInstrumentListItem* pInstrumentItem = NULL;
	DWORD dwNextAvailableChannel;

	dwNextAvailableChannel = GetNextAvailablePChannel(); //Start with the last PChannel

	if((int)dwNextAvailableChannel >= m_lstInstruments.GetCount())
	{
		CDMInstrument* pInstrument = new CDMInstrument();
		pInstrument->SetComponent(m_pComponent);
		pInstrument->SetBand(this);
		pInstrument->dwPChannel = dwNextAvailableChannel;
		pInstrument->dwPatch = MAKE_PATCH(pInstrument->IsDrums(), 0, 0, 0);
		memset(pInstrument->dwNoteRanges,0,4 * sizeof(DWORD));
		int nPriorityIndex = pInstrument->dwPChannel%16;
		pInstrument->dwChannelPriority = dwaPriorities[nPriorityIndex];
		pInstrument->nPitchBendRange = 2;
		pInstrumentItem = new CInstrumentListItem(pInstrument);
		m_lstInstruments.AddTail(pInstrumentItem);
		pInstrument->SendBandUpdate(this);
	}
	else if((int)dwNextAvailableChannel > 0)
	{
		POSITION position = m_lstInstruments.FindIndex(dwNextAvailableChannel - 1);
		CDMInstrument* pInstrument = new CDMInstrument();
		pInstrument->SetComponent(m_pComponent);
		pInstrument->SetBand(this);
		pInstrument->dwPChannel = dwNextAvailableChannel;
		pInstrument->dwPatch = MAKE_PATCH(pInstrument->IsDrums(), 0, 0, 0);
		memset(pInstrument->dwNoteRanges,0,4 * sizeof(DWORD));
		int nPriorityIndex = pInstrument->dwPChannel%16;
		pInstrument->dwChannelPriority = dwaPriorities[nPriorityIndex];
		pInstrument->nPitchBendRange = 2;
		pInstrumentItem = new CInstrumentListItem(pInstrument);
		m_lstInstruments.InsertAfter(position, pInstrumentItem);
		pInstrument->SendBandUpdate(this);
	}
	else if((int)dwNextAvailableChannel == 0)
	{
		CDMInstrument* pInstrument = new CDMInstrument();
		pInstrument->SetComponent(m_pComponent);
		pInstrument->SetBand(this);
		pInstrument->dwPChannel = dwNextAvailableChannel;
		pInstrument->dwPatch = MAKE_PATCH(pInstrument->IsDrums(), 0, 0, 0);
		memset(pInstrument->dwNoteRanges,0,4 * sizeof(DWORD));
		int nPriorityIndex = pInstrument->dwPChannel%16;
		pInstrument->dwChannelPriority = dwaPriorities[nPriorityIndex];
		pInstrument->nPitchBendRange = 2;
		pInstrumentItem = new CInstrumentListItem(pInstrument);
		m_lstInstruments.AddHead(pInstrumentItem);
		pInstrument->SendBandUpdate(this);
	}

	return pInstrumentItem;
}

	

int CBand::DeleteFromInstrumentList(DWORD nPChannel)
{
	POSITION position = m_lstInstruments.FindIndex(nPChannel);
	
	if(position)
	{
		CInstrumentListItem* pInstrumentItem = m_lstInstruments.GetAt(position);
		ASSERT(pInstrumentItem);
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		m_lstInstruments.RemoveAt(position);
		pInstrument->SendBandUpdate(this);

		if(pInstrumentItem->Release() == 0)
			pInstrumentItem = NULL;
	}

	return m_lstInstruments.GetCount(); // Return the number of instruments in the list
}

	

int CBand::DeleteFromInstrumentList(CInstrumentListItem* pInstrumentItem)
{
	ASSERT(pInstrumentItem);

	POSITION position = m_lstInstruments.Find(pInstrumentItem);

	if(position)
	{
		m_lstInstruments.RemoveAt(position);
		
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);
		pInstrument->SendBandUpdate(this);

		if(pInstrumentItem->Release() == 0)
			pInstrumentItem = NULL;
	}

	return m_lstInstruments.GetCount(); // Return the number of instruments in the list
}

bool CBand::IsPChannelFree(DWORD dwPChannel)
{
	// Go throught he instrument list and find out if this PChannel is used...
	POSITION position = m_lstInstruments.GetHeadPosition();
	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*) m_lstInstruments.GetNext(position);
		ASSERT(pInstrumentItem);
		if(pInstrumentItem)
		{
			CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
			ASSERT(pInstrument);
			if(pInstrument && pInstrument->dwPChannel == dwPChannel)
			{
				return false;
			}
		}
	}

	return true;

}


/////////////////////////////////////////////////////////////////////////////
// CBand::Load_IMA_Band

HRESULT CBand::Load_IMA_Band( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ioBand      iBand;
    IStream*    pIStream;
    HRESULT     hr = E_FAIL;
    MMCKINFO    ck;
	DWORD		cb;
	DWORD		cSize;
    char        sz[32];
	int         i;
	int			iTrack;
	CString		cs_Collection;
	IDMUSProdReferenceNode*		pCollectionRef=NULL;

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
		{
	        case FOURCC_BAND:
				cSize = min( ck.cksize, sizeof( iBand ) );
				hr = pIStream->Read( &iBand, cSize, &cb );
				if( FAILED( hr ) || cb != cSize )
				{
					hr = E_FAIL;
					goto ON_ERR;
				}

				SetModifiedFlag( FALSE );
				WideCharToMultiByte( CP_ACP, 0, iBand.wstrName, -1, sz, sizeof( sz ), NULL, NULL );
				m_csName = sz;
				m_strDefaultCollection = iBand.szCollection;
				m_fDefault = iBand.fDefault;
				
				if ( !m_strDefaultCollection.IsEmpty() )
				{
					pCollectionRef = m_pComponent->FindDLSCollection(m_strDefaultCollection, pIStream);
				}

				for( i = 0 ; i < 16 ; ++i )
				{
					iTrack = IMA25_VOICEID_TO_PCHANNEL(i);
					CDMInstrument* pInstrument = GetInstrumentFromList(iTrack);
					ASSERT(pInstrument);
					//memset( &m_aInstr[iTrack], 0, sizeof( DMUS_IO_INSTRUMENT ) );
					memset( pInstrument, 0, sizeof( DMUS_IO_INSTRUMENT ) );
					// 5/21/98 JHD: Rewrote to accurately reflect how DirectMusic imports IMA instruments
					if(iBand.awDLSBank[i] & 0x8000) 
					{
						// We have a plain old GM collection where MSB & LSB are both zero
						pInstrument->dwPatch = 0;
						pInstrument->dwPatch |= (iBand.abPatch[i] & 0x7F);
						pInstrument->dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
					}
					else
					{
						if(iBand.awDLSBank[i] & 0x4000)
						{
							// We has a GS collection with valid MSB and LSB numbers
							pInstrument->dwPatch = 0;
							pInstrument->dwPatch |= (iBand.abDLSPatch[i] & 0x7F);
							pInstrument->dwPatch |= (iBand.awDLSBank[i] & 0x7F) << 8; // Set LSB
							pInstrument->dwPatch |= ((iBand.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
							pInstrument->dwFlags |= (DMUS_IO_INST_BANKSELECT | DMUS_IO_INST_GS | DMUS_IO_INST_GM);
						}
						else
						{
							if( !pCollectionRef )
							{
								// We have no unique DLS file so we will assume GM
								pInstrument->dwPatch = 0;
								pInstrument->dwPatch |= (iBand.abPatch[i] & 0x7F);
								pInstrument->dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
							}
							else
							{
								// We have a unique DLS file
								pInstrument->dwPatch = 0;
								pInstrument->dwPatch |= (iBand.abDLSPatch[i] & 0x7F);
								pInstrument->dwPatch |= (iBand.awDLSBank[i] & 0x7F) << 8; // Set LSB
								pInstrument->dwPatch |= ((iBand.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
								pInstrument->dwFlags |= (DMUS_IO_INST_BANKSELECT);
								pInstrument->SetDLSCollection( pCollectionRef );
							}
						}
					}
					
					pInstrument->bPan = iBand.abPan[i];
					pInstrument->bVolume = iBand.abVolume[i];
					pInstrument->dwPChannel = iTrack;
					EnablePatch( iTrack );
					
					if(iBand.achOctave[i] != 0)
					{
						pInstrument->nTranspose = iBand.achOctave[i];
					}

					// Set drum-kit bit if a drum-kit
					if(pInstrument->dwPChannel % 16 == DRUM_PCHANNEL)
					{
						pInstrument->dwPatch |= 0x80000000;
					}
				}
				hr = S_OK;
				if (pCollectionRef)
				{
					pCollectionRef->Release();
					pCollectionRef = NULL;
				}
				break;
		}
        pIRiffStream->Ascend( &ck, 0 );
    }
ON_ERR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CBand::LoadDMBand

HRESULT CBand::LoadDMBand( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    IStream*    pIStream;
    HRESULT     hr = E_FAIL;
    MMCKINFO    ck;
    MMCKINFO    ckList;
	DWORD		cb;

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch ( ck.fccType )
				{
					case DMUS_FOURCC_INSTRUMENTS_LIST:
						if(FAILED(LoadDMInstruments(pIRiffStream, &ck)))
						{
							pIStream->Release();
							return E_FAIL;
						}
						break;
					case DMUS_FOURCC_INFO_LIST:
						{
							CInfo infoList;
							infoList.Load(pIRiffStream, &ck);
							m_csName = infoList.m_csName;
						}
						break;
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_INAM:
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_csName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
			case DMUS_FOURCC_GUID_CHUNK: //  <guid-ck>
				if( ck.cksize >= sizeof(GUID) )
				{
					hr = pIStream->Read(&m_guidBand, sizeof(GUID), &cb);
					if ( FAILED(hr) || cb != sizeof(GUID) )
					{
						pIStream->Release();
						return hr;
					}
				}
				break;				
			case DMUS_FOURCC_VERSION_CHUNK:
				if( ck.cksize >= sizeof(DMUS_IO_VERSION) )
				{
					hr = pIStream->Read(&m_Version, sizeof(DMUS_IO_VERSION), &cb);
					if ( FAILED(hr) || cb != sizeof(GUID) )
					{
						pIStream->Release();
						return hr;
					}
				}
				break;
		}
		if (pIRiffStream->Ascend( &ck,0 ) != 0)
		{
			pIStream->Release();
			return E_FAIL;
		}
	}

	pIStream->Release();
	return S_OK;
}

HRESULT CBand::LoadDMInstruments(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Clear the default instrument list before loading the band data
	// We don't do this for IMA bands 'cause they will always have 16 channels
	DeleteInstrumentList();

    IStream*    pIStream;
    HRESULT     hr = E_FAIL;
	MMCKINFO    ckInst;

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

	ckInst.fccType = DMUS_FOURCC_INSTRUMENT_LIST;

	while ( pIRiffStream->Descend(&ckInst, pckMain, MMIO_FINDLIST) == 0 )
	{
		CDMInstrument *pInstr = new CDMInstrument();

		pInstr->SetComponent( m_pComponent );
		pInstr->SetBand( this );
		if(FAILED(pInstr->Load(pIRiffStream, &ckInst)))
		{
			pIStream->Release();
			return E_FAIL;
		}

		// Always true
		//if( pInstr->dwPChannel >= 0 )
		{
			// If the priority is 0 then correct it to standard....(old content did not have priorities saved out)
			if(pInstr->dwChannelPriority == 0)
			{
				int nPriorityIndex = pInstr->dwPChannel%16;
				pInstr->dwChannelPriority = dwaPriorities[nPriorityIndex];
			}

			CInstrumentListItem* pInstrumentItem = new CInstrumentListItem(pInstr);
			InsertIntoInstrumentList(pInstrumentItem);
		}

		pIRiffStream->Ascend( &ckInst, 0 );
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand::SaveBandUnfoList

HRESULT CBand::SaveBandUnfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Band name
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_csName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    if( pIStream )
	{
		pIStream->Release();
	}
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CBand::SaveBandChunk

HRESULT CBand::SaveBandChunk( IDMUSProdRIFFStream* pIRiffStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD cb;
	DMUSProdStreamInfo	StreamInfo;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat= StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

    hr = E_FAIL;

	// save <guid-ck>
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	if (pIRiffStream->CreateChunk(&ck, 0) == 0 )
	{
		hr = pIStream->Write(&m_guidBand, sizeof(GUID), &cb);
		if ( FAILED(hr) || cb  != sizeof(GUID) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	if ( pIRiffStream->Ascend(&ck,0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	// Save Band UNFO LIST header
	hr = SaveBandUnfoList( pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	// Save instrument list
    ckMain.fccType = DMUS_FOURCC_INSTRUMENTS_LIST;
    if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) == 0 )
    {
		int nNumberOfInstruments = m_lstInstruments.GetCount();
		for( int i = 0 ; i < nNumberOfInstruments ; ++i )
		{	//for each instrument
			CDMInstrument* pInstrument = GetInstrumentByIndex(i);
			ASSERT(pInstrument);

			hr = pInstrument->Save(pIRiffStream);
			if (FAILED(hr))
			{
				goto ON_ERROR;
			}
		}//for each instrument
		if ( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
    }

ON_ERROR:
    if( pIStream )
	{
		pIStream->Release();
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBand::ReadListInfoFromStream

HRESULT CBand::ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidBand;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidBand, 0, sizeof(GUID) );

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_BAND_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			// Get Band GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidBand, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidBand, 0, sizeof(GUID) );
				}
			}

			// Get Band name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				DWORD dwPosName = StreamTell( pIStream );
			
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
				else
				{
				    StreamSeek( pIStream, dwPosName, STREAM_SEEK_SET );

					ck.ckid = RIFFINFO_INAM;
					if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
					{
						ReadMBSfromWCS( pIStream, ck.cksize, &strName );
					}
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( !strName.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidBand, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBand::GetGUID

void CBand::GetGUID( GUID* pguidBand )
{
	if( pguidBand )
	{
		*pguidBand = m_guidBand;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBand::SetGUID

void CBand::SetGUID( GUID guidBand )
{
	m_guidBand = guidBand;
	SetModifiedFlag( TRUE );

	// Notify connected nodes that Band GUID has changed
	theApp.m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject::GetData

HRESULT CBand::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject::SetData

HRESULT CBand::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


HRESULT CBand::OnViewProperties()
{
	ASSERT( m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pIPropSheet->IsShowing() == S_OK )
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( this->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				if( SUCCEEDED ( pIPageObject->OnShowProperties() ) )
				{
					hr = S_OK;
				}

				pIPageObject->Release();
			}
		}
		else
		{
			hr = S_OK;
		}

		pIPropSheet->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject::OnShowProperties

HRESULT CBand::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pIFramework != NULL );

	CDllBasePropPageManager* pPageManager;

	// Get the Band page manager
	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_BandPropPageManager ) == S_OK )
	{
		pPageManager = (CDllBasePropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CBandPropPageManager();
	}
	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Band properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CBand::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdGetReferencedNodes implementation

/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdGetReferencedNodes::GetReferencedNodes

HRESULT CBand::GetReferencedNodes( DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode, DWORD dwErrorLength, WCHAR *wcstrErrorText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pdwArraySize == NULL )
	{
		return E_POINTER;
	}

    bool fAddedErrorHeader = false;

	// Iterate through the list of instruments
	DWORD dwIndex = 0;
	POSITION position = m_lstInstruments.GetHeadPosition();
	while(position)
	{
		// Get the instrument from east list item
		CDMInstrument* pInstrument = m_lstInstruments.GetNext(position)->GetInstrument();
		ASSERT(pInstrument);

		// If the instrument has a patch change
		if( pInstrument && (pInstrument->dwFlags & DMUS_IO_INST_PATCH) )
		{
			const DWORD dwOldIndex = dwIndex;

			// If the instrument has a DLS reference
			if( pInstrument->m_pDMReference)
			{
				// Get the node underlying the reference
				IDMUSProdNode *pNode;
				if( SUCCEEDED( pInstrument->m_pDMReference->GetReferencedFile( &pNode ) ) )
				{
					// If we have an array, and we haven't run out of room
					if( ppIDMUSProdNode
					&&	(*pdwArraySize) > dwIndex )
					{
						// Add the node to the array
						ppIDMUSProdNode[dwIndex] = pNode;
						ppIDMUSProdNode[dwIndex]->AddRef();
					}

					// Increment the index
					dwIndex++;

					// Release the node
					pNode->Release();
				}
			}

			// If we didn't find the referenced DLS collection, and there is space in the error string
			if( (dwOldIndex == dwIndex)
			&&	dwErrorLength
			&&	wcstrErrorText
			&&	(wcslen(wcstrErrorText) < dwErrorLength) )
			{
				// Warn the user that this instrument will fail to load on the Xbox

				// Allocate a temporary array to store the current error string
				const int nTempLen = dwErrorLength - wcslen(wcstrErrorText);
				WCHAR *wcstrTmp = new WCHAR[nTempLen + 1];
				if( wcstrTmp )
				{
					// Zero out our temp. string
					ZeroMemory( wcstrTmp, sizeof(WCHAR) * (nTempLen + 1) );

                    // The number of wide characters written
                    int nWritten = 0;

                    if( !fAddedErrorHeader )
                    {
                        fAddedErrorHeader = true;

                        // Add the error header
					    CString strErrorText;
                        AfxFormatString1( strErrorText, IDS_XBOX_ERROR_NO_COLLECTION, m_csName );

					    // Convert to wide characters
					    nWritten = MultiByteToWideChar( CP_ACP, 0, strErrorText, -1, wcstrTmp, nTempLen );

					    // Append the error text
					    wcscat( wcstrErrorText, wcstrTmp );

					    // Zero out our temp. string again
					    ZeroMemory( wcstrTmp, sizeof(WCHAR) * (nTempLen + 1) );
                    }

                    // If there is space left in the string
                    if( nTempLen - nWritten > 0 )
                    {
					    // Write out the error string
					    CString strErrorText;
					    strErrorText.Format( IDS_XBOX_ERROR_PATCH, pInstrument->dwPChannel, MSB(pInstrument->dwPatch), LSB(pInstrument->dwPatch), pInstrument->dwPatch & 0x7F );

					    // Convert to wide characters
					    MultiByteToWideChar( CP_ACP, 0, strErrorText, -1, wcstrTmp, nTempLen - nWritten );

					    // Append the error text
					    wcscat( wcstrErrorText, wcstrTmp );
                    }

					delete []wcstrTmp;
				}
			}
		}
	}

	HRESULT hr = ppIDMUSProdNode && ((*pdwArraySize) < dwIndex) ? S_FALSE : S_OK;

	// Store the number of nodes we returned (or that we require)
	*pdwArraySize = dwIndex;

	return hr;
}


HRESULT CBand::SyncAllInstruments(DMUS_PMSGT_TYPES pmsgType)
{
	POSITION position = m_lstInstruments.GetHeadPosition();
	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)m_lstInstruments.GetNext(position);
		ASSERT(pInstrumentItem);
		if(pInstrumentItem)
		{
			CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
			ASSERT(pInstrument);
			if(pInstrument)
			{
				if(FAILED(pInstrument->Send(this, pmsgType)))
				{
					return E_FAIL;
				}
			}
		}
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
// CDMInstrument implementation
//

// Init the static m_bSendBandUpdate flag
BOOL CDMInstrument::m_bSendBandUpdate = TRUE;

CDMInstrument::CDMInstrument() 
{
	m_fSelected = false;
	m_pDMReference = NULL;
	m_pComponent = NULL;

	ResetInstruemnt();
}

CDMInstrument::~CDMInstrument()
{
	SetDLSCollection( NULL );
}

void CDMInstrument::ResetInstruemnt()
{
	m_fSelected = false;
	SetDLSCollection( NULL );

	dwPatch = 0;
	dwAssignPatch = 0;
	ZeroMemory( dwNoteRanges, sizeof(DWORD) * 4 );
	dwPChannel = 0;
	dwFlags = DMUS_IO_INST_GM;
	bPan = 64;
	bVolume = 64;
	nTranspose = 0; // Balanced
	dwChannelPriority = DAUD_STANDARD_VOICE_PRIORITY; 
	nPitchBendRange = 2;
}

CDMInstrument& CDMInstrument::operator = (const CDMInstrument& dmInstrument)
{
	if(&dmInstrument == this)
	{
		return *this;
	}

	*dynamic_cast<DMUS_IO_INSTRUMENT*>(const_cast<CDMInstrument*>(this)) = dmInstrument;

	m_csCollection = dmInstrument.m_csCollection;
	if( m_pComponent != dmInstrument.m_pComponent )
	{
		if( m_pComponent )
		{
			m_pComponent->Release();
		}
		m_pComponent = dmInstrument.m_pComponent;
		if( m_pComponent )
		{
			m_pComponent->AddRef();
		}
	}

	SetDLSCollection( dmInstrument.m_pDMReference );

	return *this;
}

bool CDMInstrument::IsDrums()
{
	return (dwPChannel == 9 || dwPChannel%16 == 9);
}

HRESULT CDMInstrument::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
    IStream*    pIStream;
	MMCKINFO    ck;
    HRESULT     hr = E_FAIL;
	DWORD		dwByteCount;
	DWORD		dwCurrentFilePos;
	DWORD		dwSize;
	IDMUSProdFileRefChunk*	pIFileRef = NULL;
	IDMUSProdNode*			pIDocRoot = NULL;

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

	dwCurrentFilePos = StreamTell( pIStream );

	while ( pIRiffStream->Descend(&ck, pckMain, 0) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_INSTRUMENT_CHUNK:
			{
				dwSize = min( ck.cksize, sizeof(DMUS_IO_INSTRUMENT) );
				hr = pIStream->Read( dynamic_cast<DMUS_IO_INSTRUMENT*>(this), dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;
			}

			case FOURCC_INST_DESIGNTIME:
			{
				// Read the selection flag
				hr = pIStream->Read(&m_fSelected, sizeof(bool), &dwByteCount);
				if(FAILED(hr) || dwByteCount != sizeof(bool))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				hr = m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				if( SUCCEEDED ( pIFileRef->LoadRefChunk( pIStream, &pIDocRoot ) ) )
				{
					IDMUSProdReferenceNode* pCollectionRef;

					// Create and store reference node for DLS Collection
					pCollectionRef = m_pComponent->CreateCollectionRefNode( pIDocRoot );
					if( pCollectionRef )
					{
						SetDLSCollection( pCollectionRef );
						pCollectionRef->Release();

						dwFlags |= (DMUS_IO_INST_BANKSELECT);
						dwFlags &= ~(DMUS_IO_INST_GS | DMUS_IO_INST_GM);
					}
					pIDocRoot->Release();
				}
				break;
			}

			case FOURCC_LIST:
			{
				if( ck.fccType == DMUS_FOURCC_REF_LIST )
				{
					MMCKINFO ckName;

					ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
					if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
					{
						// Store DLS Collection name
						ReadMBSfromWCS( pIStream, ckName.cksize, &m_csCollection );
					}
				}
				break;
			}
		}

		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	if( m_pDMReference == NULL )
	{
		// Do we have a DLS Collection name?
		if( !m_csCollection.IsEmpty() )
		{
			IDMUSProdReferenceNode* pCollectionRef;

			// Framework could not resolve DLS Collection file reference
			// so we will ask user to help
			pCollectionRef = m_pComponent->FindDLSCollection( m_csCollection, pIStream );
			if( pCollectionRef )
			{
				SetDLSCollection( pCollectionRef );
				pCollectionRef->Release();
			}
			else
			{
				hr = S_FALSE;
				//goto ON_ERROR;
			}
		}
	}

	if( m_pDMReference )
	{
		// Reset Instrument's Collection name
		IDMUSProdNode* pIDocRootNode;

		if( SUCCEEDED (	m_pDMReference->GetReferencedFile( &pIDocRootNode ) ) )
		{
			BSTR bstrCollectionName;

			pIDocRootNode->GetNodeName( &bstrCollectionName );
			m_csCollection = bstrCollectionName;
			::SysFreeString( bstrCollectionName );

			pIDocRootNode->Release();
		}
	}

ON_ERROR:
	RELEASE( pIStream );
	RELEASE( pIFileRef );
	return hr;
}

HRESULT CDMInstrument::Save(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(m_pBand);
	if(m_pBand == NULL)
		return E_FAIL;

    IStream*    pIStream;
    HRESULT     hr = E_FAIL;
	MMCKINFO ckInst;
	MMCKINFO ck;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;
	IDMUSProdPersistInfo* pPersistInfo;
	DMUSProdStreamInfo	StreamInfo;

	DWORD		cb;

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat= StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	
	ckInst.fccType = DMUS_FOURCC_INSTRUMENT_LIST;
	if( pIRiffStream->CreateChunk( &ckInst, MMIO_CREATELIST ) == 0 )
	{
		ck.ckid = DMUS_FOURCC_INSTRUMENT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) == 0 )
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_INSTRUMENT*>(this), sizeof(DMUS_IO_INSTRUMENT), &cb);
			if ( cb != sizeof(DMUS_IO_INSTRUMENT) )
			{
				hr = E_FAIL;
			}
			if ( pIRiffStream->Ascend( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
			}
		}
		if(m_fSelected && m_pBand->m_bInUndoRedo == true && ftFileType == FT_DESIGN)
		{
			ck.ckid = FOURCC_INST_DESIGNTIME;
			if(pIRiffStream->CreateChunk(&ck, 0) == 0)
			{
				hr = pIStream->Write((LPSTR)&(m_fSelected), sizeof(bool), &cb);
				if(cb != sizeof(bool))
				{
					hr = E_FAIL;
				}
				if(pIRiffStream->Ascend(&ck, 0) != 0)
				{
					hr = E_FAIL;
				}
			}
		}
		

		if (m_pDMReference)
		{
			if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ))
			{
				hr = SaveDMRef( pIRiffStream, WL_PRODUCER );
			}
			else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ))
			{
				hr = SaveDMRef( pIRiffStream, WL_DIRECTMUSIC );
				if (FAILED(hr))
				{
					pIStream->Release();
					return hr;
				}
				if (ftFileType == FT_DESIGN)
				{
					hr = SaveFileRef(pIRiffStream);
					if (FAILED(hr))
					{
						pIStream->Release();
						return hr;
					}
				}
			}
		}
		if ( pIRiffStream->Ascend( &ckInst, 0 ) != 0 )
		{
			hr = E_FAIL;
		}
	}
	pIStream->Release();
	return hr;
}

HRESULT CDMInstrument::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk*	pRefChunkLoader=NULL;
	IDMUSProdNode*				pIDocRootNode;
	IStream*					pIStream;

	// Get the DocRoot node
	if( FAILED ( m_pDMReference->GetReferencedFile( &pIDocRootNode ) ) )
	{
		return E_FAIL;
	}
	if( pIDocRootNode == NULL )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdLoaderRefChunk, (void**)&pRefChunkLoader)) )
	{
		if( pRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_PRODUCER:
					pRefChunkLoader->SaveRefChunkForLoader( pIStream,
															pIDocRootNode,
															CLSID_DirectMusicCollection,
															NULL,
															whichLoader );
					break;

				case WL_DIRECTMUSIC:
				{
					// Prepare the DMUS_OBJECTDESC structure
					DMUS_OBJECTDESC dmusObjectDesc;

					IDLSQueryInstruments *pDLSQuery;
					if( SUCCEEDED( m_pDMReference->QueryInterface( IID_IDLSQueryInstruments, (void **)&pDLSQuery ) ) )
					{
						pDLSQuery->GetObjectDescriptor( sizeof(DMUS_OBJECTDESC), &dmusObjectDesc );
						pDLSQuery->Release();
					}
					else
					{
						memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
						dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

						dmusObjectDesc.dwValidData = (DMUS_OBJ_CLASS | DMUS_OBJ_NAME);
						
						dmusObjectDesc.guidClass = CLSID_DirectMusicCollection;
						MultiByteToWideChar( CP_ACP, 0, m_csCollection, -1, 
							dmusObjectDesc.wszName, sizeof( dmusObjectDesc.wszName ) / sizeof( wchar_t ) );
					}

					pRefChunkLoader->SaveRefChunkForLoader( pIStream,
															pIDocRootNode,
															CLSID_DirectMusicCollection,
															&dmusObjectDesc,
															whichLoader );
					break;
				}
			}
			pRefChunkLoader->Release();
		}
	}

	pIDocRootNode->Release();
	pIStream->Release();
	return S_OK;
}

HRESULT CDMInstrument::SaveFileRef(IDMUSProdRIFFStream* pIRiffStream)
{
	IDMUSProdFileRefChunk* pIFileRefChunk;
	IStream*			   pIStream;
	IDMUSProdNode*		   pIDocRootNode;

	// Get the DocRoot node
	if( FAILED ( m_pDMReference->GetReferencedFile( &pIDocRootNode ) ) )
	{
		return E_FAIL;
	}
	if( pIDocRootNode == NULL )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk)) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIDocRootNode->Release();
	pIStream->Release();
	return S_OK;
}

BOOL CDMInstrument::SendBandUpdate(IDMUSProdNode* pIBandNode)
{
	ASSERT(pIBandNode);

	BOOL fSendChange = TRUE;
	IDMUSProdNode* pIDocRootNode = NULL;

	MUSIC_TIME mtTime;

	if( SUCCEEDED ( pIBandNode->GetDocRootNode(&pIDocRootNode) ) )
	{
		if( pIDocRootNode != pIBandNode )
		{
			IDMUSProdNotifySink* pINotifySink;

			if( SUCCEEDED ( pIDocRootNode->QueryInterface(IID_IDMUSProdNotifySink, (void**)&pINotifySink) ) )
			{
				if( pINotifySink->OnUpdate( pIBandNode, GUID_BAND_ChangeNotifyMsg, NULL ) != S_OK ) // Ask DocRoot if change should be sent
				{
					fSendChange = FALSE;

					if( SUCCEEDED( m_pComponent->m_pIDMPerformance->GetTime( NULL, &mtTime) ) )
					{
					   IDirectMusicSegmentState* pSegmentState = NULL;
					   HRESULT hr = m_pComponent->m_pIDMPerformance->GetSegmentState( &pSegmentState, mtTime );
					   if( hr == DMUS_E_NOT_FOUND )
					   {
						  fSendChange = TRUE;
					   }
					   if(pSegmentState)
						   pSegmentState->Release();
					}
				}

				pINotifySink->Release();
			}
	
		}

		pIDocRootNode->Release();
	}

	return fSendChange;
}

HRESULT CDMInstrument::Send(IDMUSProdNode* pIBandNode, UINT uMsgType)
{
	ASSERT( pIBandNode != NULL );
	ASSERT(m_pComponent);

	static BOOL fSendChange = TRUE;
	
	if(m_bSendBandUpdate)
	{
		// We need to send band changes only once
		m_bSendBandUpdate = FALSE;

		fSendChange = SendBandUpdate(pIBandNode);
		if( fSendChange == FALSE)
		{
			// No need to send the change
			return S_OK;
		}
	}

	if(fSendChange == FALSE || uMsgType == NULL)
	{
		// No need to send the change
		return S_OK;
	}

	ASSERT( m_pComponent->m_pIDMPerformance != NULL );
	if ( m_pComponent->m_pIDMPerformance == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr;
	IDirectMusicGraph *pDMGraph = NULL;
	
	hr = m_pComponent->m_pIDMPerformance->QueryInterface( IID_IDirectMusicGraph, (void**) &pDMGraph );
	if ( FAILED( hr ) )
	{
		return E_FAIL;
	}
	switch (uMsgType)
	{
		case DM_PATCH_CHANGE:
		{
			DMUS_PATCH_PMSG* pMsg = NULL;

			hr = m_pComponent->m_pIDMPerformance->AllocPMsg(sizeof(DMUS_PATCH_PMSG), (DMUS_PMSG**)&pMsg);
			if (FAILED(hr))
			{
				pDMGraph->Release();
				return S_OK;
			}
			
			ZeroMemory(pMsg, sizeof(DMUS_PATCH_PMSG));
			pMsg->dwSize = sizeof(DMUS_PATCH_PMSG);
			pMsg->byInstrument = (BYTE) (dwPatch & 0x7F);
			pMsg->byMSB = (BYTE)MSB(dwPatch);
			pMsg->byLSB = (BYTE)LSB(dwPatch);

			// DMUS_PMSG members that need to be initialized
			pMsg->dwFlags |= DMUS_PMSGF_REFTIME;
			pMsg->dwPChannel = dwPChannel;
			pMsg->dwType = DMUS_PMSGT_PATCH;

			hr = m_pComponent->SendPMsg((DMUS_PMSG*)pMsg, m_pBand ? m_pBand->m_pAudiopath : NULL);

		}
		break;
		case DM_TRANSPOSE:
		{
			DMUS_TRANSPOSE_PMSG *pMsg = NULL;
			hr = m_pComponent->m_pIDMPerformance->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG), (DMUS_PMSG**)&pMsg);
			if(SUCCEEDED(hr))
			{
				ZeroMemory(pMsg, sizeof(DMUS_TRANSPOSE_PMSG));
				pMsg->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);

				// DMUS_TRANSPOSE_PMSG members that need to be initialized 
				pMsg->nTranspose = nTranspose;
				// DMUS_PMSG members that need to be initialized
				
				pMsg->dwFlags |= DMUS_PMSGF_REFTIME;
				pMsg->dwPChannel = dwPChannel;
				//pMsg->dwVirtualTrackID = smsg.m_dwVirtualTrackID;
				pMsg->dwType = DMUS_PMSGT_TRANSPOSE;

				// Initializes a few other DMUS_PMSG members
				hr = pDMGraph->StampPMsg((DMUS_PMSG*)pMsg);
				
				hr = m_pComponent->SendPMsg((DMUS_PMSG*)pMsg, m_pBand ? m_pBand->m_pAudiopath : NULL);
			}
		}
		break;
		case DM_VOLUME:
		{
			DMUS_MIDI_PMSG* pMsg = NULL;
			hr = m_pComponent->m_pIDMPerformance->AllocPMsg(sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMsg);

			if(SUCCEEDED(hr))
			{
				ZeroMemory(pMsg, sizeof(DMUS_MIDI_PMSG));
				pMsg->dwSize = sizeof(DMUS_MIDI_PMSG);
				// DMUS_MIDI_PMSG members that need to be initialized 
				pMsg->bStatus = MIDI_CONTROL_CHANGE;
				pMsg->bByte1 = MIDI_CC_VOLUME;
				pMsg->bByte2 = bVolume;
				// DMUS_PMSG members that need to be initialized
				pMsg->dwFlags |= DMUS_PMSGF_REFTIME;
				pMsg->dwPChannel = dwPChannel;
				//pMsg->dwVirtualTrackID = smsg.m_dwVirtualTrackID;
				pMsg->dwType = DMUS_PMSGT_MIDI;

				// Initializes a few other DMUS_PMSG members
				hr = pDMGraph->StampPMsg((DMUS_PMSG*)pMsg);
								
				hr = m_pComponent->SendPMsg((DMUS_PMSG*)pMsg, m_pBand ? m_pBand->m_pAudiopath : NULL);
			}
		}
		break;
		case DM_PAN:
		{
			DMUS_MIDI_PMSG* pMsg = NULL;
			hr = m_pComponent->m_pIDMPerformance->AllocPMsg(sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMsg);

			if(SUCCEEDED(hr))
			{
				ZeroMemory(pMsg, sizeof(DMUS_MIDI_PMSG));
				pMsg->dwSize = sizeof(DMUS_MIDI_PMSG);

				// DMUS_MIDI_PMSG members that need to be initialized 
				pMsg->bStatus = MIDI_CONTROL_CHANGE;
				pMsg->bByte1 = MIDI_CC_PAN;
				pMsg->bByte2 = bPan;
				// DMUS_PMSG members that need to be initialized
				pMsg->dwFlags |= DMUS_PMSGF_REFTIME;
				pMsg->dwPChannel = dwPChannel;
				//pMsg->dwVirtualTrackID = smsg.m_dwVirtualTrackID;
				pMsg->dwType = DMUS_PMSGT_MIDI;

				// Initializes a few other DMUS_PMSG members
				hr = pDMGraph->StampPMsg((DMUS_PMSG*)pMsg);
								
				hr = m_pComponent->SendPMsg((DMUS_PMSG*)pMsg, m_pBand ? m_pBand->m_pAudiopath : NULL);
			}
		}
		break;
		case DM_PITCHBEND_RANGE:
		{
			DMUS_CURVE_PMSG* pMsg = NULL;
			hr = m_pComponent->m_pIDMPerformance->AllocPMsg(sizeof(DMUS_PMSGT_CURVE), (DMUS_PMSG**)&pMsg);

			if(SUCCEEDED(hr))
			{
				ZeroMemory(pMsg, sizeof(DMUS_PMSGT_CURVE));
				pMsg->dwSize = sizeof(DMUS_PMSGT_CURVE);
				
				pMsg->dwFlags |= DMUS_PMSGF_DX8; // Pitch Bend is DX8 only flag
				pMsg->nEndValue = nPitchBendRange << 8;
				pMsg->bType = DMUS_CURVET_RPNCURVE;
				pMsg->bCurveShape = DMUS_CURVES_INSTANT;
				pMsg->wParamType = 0;

				// Initializes a few other DMUS_PMSG members
				hr = pDMGraph->StampPMsg((DMUS_PMSG*)pMsg);
								
				hr = m_pComponent->SendPMsg((DMUS_PMSG*)pMsg, m_pBand ? m_pBand->m_pAudiopath : NULL);
			}
		}
		break;

		default: //not supported
		{
			MessageBox(NULL, "Not supported mesasage", "Band Editor", MB_OK);
		}
	}
	pDMGraph->Release();
	return S_OK;
}


void CDMInstrument::SetDLSCollection( IDMUSProdReferenceNode* pDMReferenceNode )
{
	ASSERT( m_pBand != NULL );

	if( m_pDMReference != pDMReferenceNode )
	{
		if( m_pDMReference )
		{
			m_pBand->RemoveFromNotifyList( m_pDMReference ); 
			m_pDMReference->Release();
		}

		m_pDMReference = pDMReferenceNode;

		if( m_pDMReference != NULL )
		{
			m_pDMReference->AddRef();
			m_pBand->AddToNotifyList( m_pDMReference ); 
		}
	}
}


/////////////////////////////////////////////////////////////
// CInstrumentListItem Construction/Destruction

CInstrumentListItem::CInstrumentListItem(CDMInstrument* pInstrument) : m_dwRef(0)
{
	ASSERT(pInstrument);
	AddRef();

	m_pInstrument = pInstrument;
	m_fSelected = m_pInstrument->m_fSelected;
}

CInstrumentListItem::CInstrumentListItem() : m_fSelected(false)
{
	AddRef();
	m_pInstrument = NULL;
}


CInstrumentListItem::~CInstrumentListItem()
{
	if( m_pInstrument )
	{
		delete m_pInstrument;
		m_pInstrument = NULL;
	}
}

// IUnknown Implementation
HRESULT CInstrumentListItem::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(ppvObj);

	if(ppvObj == NULL)
	{
		return E_POINTER;
	}

	*ppvObj = NULL;

	if( IsEqualIID( riid, IID_IUnknown ) || IsEqualIID(riid, IID_IDMUSProdBandPChannel) )
	{
		AddRef();
		*ppvObj = (IDMUSProdBandPChannel*)this;
		return S_OK;
	}
	*ppvObj = NULL;
    return E_NOINTERFACE;
}


ULONG CInstrumentListItem::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CInstrumentListItem::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

// IDMUSProdBandPChannel Implementation
HRESULT CInstrumentListItem::GetPChannelNumber(int* pnNumber)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 
	ASSERT(m_pInstrument);

	*pnNumber = m_pInstrument->dwPChannel;
	return S_OK; 
}

HRESULT CInstrumentListItem::GetVolume(int* pnVolume)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 
	ASSERT(m_pInstrument);

	*pnVolume = (int)m_pInstrument->bVolume;
	return S_OK;
}

HRESULT CInstrumentListItem::GetPan(int* pnPan)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 
	ASSERT(m_pInstrument);

	*pnPan = (int)m_pInstrument->bPan;
	return S_OK;
}

HRESULT CInstrumentListItem::SetVolume(int nVolume)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 
	ASSERT(m_pInstrument);

	m_pInstrument->bVolume = (BYTE)nVolume;
	m_pInstrument->dwFlags |= DMUS_IO_INST_PATCH | DMUS_IO_INST_VOLUME | DMUS_IO_INST_PITCHBENDRANGE | DMUS_IO_INST_TRANSPOSE;
	return S_OK;
}

HRESULT CInstrumentListItem::SetPan(int nPan)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 
	ASSERT(m_pInstrument);

	m_pInstrument->bPan = (BYTE) nPan;
	m_pInstrument->dwFlags |= DMUS_IO_INST_PATCH | DMUS_IO_INST_PAN | DMUS_IO_INST_PITCHBENDRANGE | DMUS_IO_INST_TRANSPOSE;
	return S_OK;
}

HRESULT CInstrumentListItem::IsSelected(BOOL* pfSelected)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 

	*pfSelected = m_fSelected;
	return S_OK;
}

HRESULT CInstrumentListItem::SetSelected(BOOL fSelection)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 

	m_fSelected = fSelection ? true : false;
	m_pInstrument->m_fSelected = m_fSelected;
	return S_OK;
}


HRESULT CInstrumentListItem::IsEnabled(BOOL* pbEnabled)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 
	ASSERT(m_pInstrument);

	*pbEnabled = (m_pInstrument->dwFlags & DMUS_IO_INST_PATCH);
	return S_OK; 
}

HRESULT CInstrumentListItem::SyncChanges(BOOL bSendBandUpdate)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	 
	ASSERT(m_pInstrument);
	TRACE("In CInstrumentListItem::SyncChanges\n");

	CBand* pBand =  NULL;
	if(m_CommonPropertyObject.m_pBandDlg)
		pBand = m_CommonPropertyObject.m_pBandDlg->GetBand();
	
	// Send only the band update if this is true
	// This will be used to decide whether to send 
	// the other changes on mouse move on the grid
	if(bSendBandUpdate && pBand)
	{
		// Return failure if the update failed
		if(!m_pInstrument->SendBandUpdate(pBand))
			return E_FAIL;
		
		return S_OK;
	}

	m_pInstrument->m_bSendBandUpdate = false;
	if(pBand)
	{
		m_pInstrument->Send(pBand, DM_PAN);
		m_pInstrument->Send(pBand, DM_VOLUME);
	}

	return S_OK;
}


// Other methods
void CInstrumentListItem::SetSelected(bool bSelectionFlag)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	m_fSelected = bSelectionFlag;
	m_pInstrument->m_fSelected = m_fSelected;
}

void CInstrumentListItem::SetSelected()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_fSelected = !m_fSelected;
	m_pInstrument->m_fSelected = m_fSelected;
}

bool CInstrumentListItem::IsSelected()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_fSelected;
}

void CInstrumentListItem::SetInstrument(CDMInstrument* pInstrument)
{
	ASSERT(pInstrument);

	m_pInstrument = pInstrument;
}

CDMInstrument* CInstrumentListItem::GetInstrument()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_pInstrument;
}



////////////////////////////////////
// Common Properties Object

CCommonInstrumentPropertyObject::CCommonInstrumentPropertyObject():
m_dwChanged(0),
m_dwIgnoresChanged(0),
m_dwInstrumentChangeID(0),
m_nABIIndex(0),
m_dwRef(1), 
m_bReset(0),
m_pBandDlg(NULL),
m_nChannels(0),
m_nPChannelNumber(0),
m_sPChannelName(""),
m_dwPatch(0),
m_sPatch(""),
m_nOctave(0),
m_nTranspose(0),
m_nOctaveTranspose(0),
m_nVolume(0),
m_nPan(0),
m_dwPriority(0),
m_dwPriorityLevel(0),
m_dwPriorityOffset(0),
m_nLowNote(0),
m_nHighNote(0),
m_nSoundCanvas(0),
m_nPitchBendOctave(0),
m_nPitchBendTranspose(0),
m_nPitchBendRange(0),
m_nIgnoreVolume(0),
m_nIgnoreOctaveTranspose(0),
m_nIgnoreInstrument(0),
m_nIgnorePan(0),
m_nIgnorePriority(0),
m_nIgnoreNoteRange(0),
m_nIgnorePitchBendRange(0),
m_csCurrentCollection (""), 
m_nLastSelectedCollection(-1),
m_sInstrumentInfo(""),
m_sInstrumentCollectionInfo(""),
m_dwInstrumentPatchInfo(0),
m_bPreservePriorityOffset(false)
{

}

CCommonInstrumentPropertyObject::~CCommonInstrumentPropertyObject()
{
	// Remove PChannel from the property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( theApp.m_pIFramework && SUCCEEDED ( theApp.m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		pIPropSheet->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCommonInstrumentPropertyObject IUnknown implementation

HRESULT CCommonInstrumentPropertyObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(ppvObj);
	if(ppvObj == NULL)
	{
		return E_POINTER;
	}

	*ppvObj = NULL;

	if( IsEqualIID( riid, IID_IUnknown ) || IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
	{
		AddRef();
		*ppvObj = (IDMUSProdPropPageObject *)this;
		return S_OK;
	}
	*ppvObj = NULL;
    return E_NOINTERFACE;
}


ULONG CCommonInstrumentPropertyObject::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CCommonInstrumentPropertyObject::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}
/////////////////////////////////////////////////////////////////////////////
// CInstrumentListItem IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrumentListItem IDMUSProdPropPageObject::GetData

HRESULT CCommonInstrumentPropertyObject::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject::SetData

HRESULT CCommonInstrumentPropertyObject::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pData);
	if(pData == NULL)
		return E_POINTER;

	CCommonInstrumentPropertyObject* pCommonObject = (CCommonInstrumentPropertyObject*)pData;
	ASSERT(pCommonObject);

	pCommonObject->ApplyChangesToSelectedChannelsAndRefreshUI();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject::OnShowProperties

HRESULT CCommonInstrumentPropertyObject::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pIFramework != NULL );

	CDllBasePropPageManager* pPageManager;

	// Get the PChannel page manager
	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PChannelPropPageManager ) == S_OK )
	{
		pPageManager = (CDllBasePropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CPChannelPropPageManager();
	}
	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Save the focus so we can restore after changing the property page
	HWND hwndHadFocus;
	hwndHadFocus = ::GetFocus();

	// Show the PChannel properties
	IDMUSProdPropSheet* pIPropSheet = NULL;

	if( SUCCEEDED ( theApp.m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	// Restore the focus if it has changed
	if( hwndHadFocus != ::GetFocus() )
	{
		::SetFocus( hwndHadFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBand IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CCommonInstrumentPropertyObject::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}

void CCommonInstrumentPropertyObject::SetBandDialog(CBandDlg* pBandDlg)
{
	m_pBandDlg = pBandDlg;
}

CBandDlg* CCommonInstrumentPropertyObject::GetBandDialog()
{
	return m_pBandDlg;
}

void CCommonInstrumentPropertyObject::SetSelectedChannels(int nSelectedChannels)
{
	m_nChannels = nSelectedChannels;
}

int CCommonInstrumentPropertyObject::GetNumberOfChannels()
{
	return m_nChannels;
}

void CCommonInstrumentPropertyObject::SetReset(bool bReset)
{
	m_bReset = bReset;
}

void CCommonInstrumentPropertyObject::SetProperties(CBandDlg* pBandDlg, CDMInstrument* pInstrument)
{
	ASSERT(pBandDlg);
	ASSERT(pInstrument);

	m_pBandDlg = pBandDlg;
	
	SetPChannelNumber(pInstrument->dwPChannel);

	//Have to QI the Project for the PChannel Name : SetPChannelName();

	// Get the project that this band belongs to...
	CBand* pBand  = m_pBandDlg->GetBand();
	IDMUSProdProject* pIProject = NULL;
	IDMUSProdNode* pIDocRootNode = NULL;

	pBand->GetDocRootNode(&pIDocRootNode);

	pBand->m_pComponent->m_pIFramework->FindProject(pIDocRootNode, &pIProject);

	ASSERT(pIProject);
	
	IDMUSProdPChannelName* pIPChannelName;

	WCHAR pszPChannelName[DMUS_MAX_NAME];

	if(pIProject->QueryInterface(IID_IDMUSProdPChannelName, (void**)&pIPChannelName) == S_OK)
		pIPChannelName->GetPChannelName(pInstrument->dwPChannel, pszPChannelName);
	else
		wcscpy(pszPChannelName, (wchar_t*)"");
	

	if(pIPChannelName)
		pIPChannelName->Release();
	if(pIProject)
		pIProject->Release();
	if(pIDocRootNode)
		pIDocRootNode->Release();

	SetPChannelName(pszPChannelName);
	
	SetInstrument(pInstrument);

	 // Initialize m_nOctaveTranspose
	SetOctaveTranspose(pInstrument->nTranspose);
	SetOctave(pInstrument->nTranspose);
	SetTranspose(pInstrument->nTranspose);

	// Set the initial pitch bend range
	SetPitchBendRange(pInstrument->nPitchBendRange);
	SetPitchBendOctave(pInstrument->nPitchBendRange);
	SetPitchBendTranspose(pInstrument->nPitchBendRange);

	// Set inital volume & pan
	SetVolume(pInstrument->bVolume);
	SetPan(pInstrument->bPan);

	// Set initla note range
	SetLowNote(0);
	SetHighNote(127);
	
	WORD wNoteMaskIdx = 0, wNoteIdx = 0;
	DWORD dwNoteMask = pInstrument->dwNoteRanges[wNoteMaskIdx];

	while (wNoteIdx < 128 && wNoteMaskIdx < 4)
	{
		if (dwNoteMask & 1)
		{
			SetLowNote(wNoteIdx);
			break;
		}

		if (!(++wNoteIdx % 32))
		{
			dwNoteMask = pInstrument->dwNoteRanges[++wNoteMaskIdx];
		}
		else
		{
			dwNoteMask >>= 1;
		}
	}
	while (wNoteIdx < 128 && wNoteMaskIdx < 4)
	{
		if (!(dwNoteMask & 1))
		{
			ASSERT(GetLowNote() <= wNoteIdx - 1);
			SetHighNote(wNoteIdx - 1);
			break;
		}

		if (!(++wNoteIdx % 32))
		{
			dwNoteMask = pInstrument->dwNoteRanges[++wNoteMaskIdx];
		}
		else
		{
			dwNoteMask >>= 1;
		}
	}

	SetPriority(pInstrument->dwChannelPriority);			

	SetSoundCanvas(pInstrument);

	CheckAllIgnores(pInstrument);
}

void CCommonInstrumentPropertyObject::CheckAllIgnores(CDMInstrument* pInstrument)
{

	CheckInstrumentIgnore(pInstrument);

	CheckOctaveTransposeIgnore(pInstrument);

	CheckPitchBendIgnore(pInstrument);

	CheckVolumeIgnore(pInstrument);

	CheckPanIgnore(pInstrument);

	CheckPriorityIgnore(pInstrument);

	CheckNoteRangeIgnore(pInstrument);
}

void CCommonInstrumentPropertyObject::CheckInstrumentIgnore(CDMInstrument* pInstrument)
{	
	int nIgnoreFlag = IGNORE_OFF;

	if(!(pInstrument->dwFlags & DMUS_IO_INST_PATCH))
		nIgnoreFlag = IGNORE_ON;
	
	if(m_nChannels > 1 && m_nIgnoreInstrument != nIgnoreFlag && !m_bReset)
		nIgnoreFlag = IGNORE_UNDT;

	m_nIgnoreInstrument = nIgnoreFlag;
}

void CCommonInstrumentPropertyObject::CheckOctaveTransposeIgnore(CDMInstrument* pInstrument)
{
	int nIgnoreFlag = IGNORE_OFF;

	if(!(pInstrument->dwFlags & DMUS_IO_INST_TRANSPOSE))
		nIgnoreFlag = IGNORE_ON;
	
	if(m_nChannels > 1 && m_nIgnoreOctaveTranspose != nIgnoreFlag && !m_bReset)
		nIgnoreFlag = IGNORE_UNDT;

	m_nIgnoreOctaveTranspose = nIgnoreFlag;
}

void CCommonInstrumentPropertyObject::CheckPitchBendIgnore(CDMInstrument* pInstrument)
{
	int nIgnoreFlag = IGNORE_OFF;

	if(!(pInstrument->dwFlags & DMUS_IO_INST_PITCHBENDRANGE))
		nIgnoreFlag = IGNORE_ON;
	
	if(m_nChannels > 1 && m_nIgnorePitchBendRange != nIgnoreFlag && !m_bReset)
		nIgnoreFlag = IGNORE_UNDT;

	m_nIgnorePitchBendRange = nIgnoreFlag;
}


void CCommonInstrumentPropertyObject::CheckVolumeIgnore(CDMInstrument* pInstrument)
{
	int nIgnoreFlag = IGNORE_OFF;

	if(!(pInstrument->dwFlags & DMUS_IO_INST_VOLUME))
		nIgnoreFlag = IGNORE_ON;
	
	if(m_nChannels > 1 && m_nIgnoreVolume != nIgnoreFlag && !m_bReset)
		nIgnoreFlag = IGNORE_UNDT;

	m_nIgnoreVolume = nIgnoreFlag;
}

void CCommonInstrumentPropertyObject::CheckPanIgnore(CDMInstrument* pInstrument)
{
	int nIgnoreFlag = IGNORE_OFF;

	if(!(pInstrument->dwFlags & DMUS_IO_INST_PAN))
		nIgnoreFlag = IGNORE_ON;
	
	if(m_nChannels > 1 && m_nIgnorePan != nIgnoreFlag && !m_bReset)
		nIgnoreFlag = IGNORE_UNDT;

	m_nIgnorePan = nIgnoreFlag;
}

void CCommonInstrumentPropertyObject::CheckPriorityIgnore(CDMInstrument* pInstrument)
{
	int nIgnoreFlag = IGNORE_OFF;

	if(!(pInstrument->dwFlags & DMUS_IO_INST_CHANNEL_PRIORITY))
		nIgnoreFlag = IGNORE_ON;
	
	if(m_nChannels > 1 && m_nIgnorePriority != nIgnoreFlag && !m_bReset)
		m_nIgnorePriority = IGNORE_UNDT;
	
	m_nIgnorePriority = nIgnoreFlag;
}

void CCommonInstrumentPropertyObject::CheckNoteRangeIgnore(CDMInstrument* pInstrument)
{
	int nIgnoreFlag = IGNORE_OFF;

	if(!(pInstrument->dwFlags & DMUS_IO_INST_NOTERANGES))
		nIgnoreFlag = IGNORE_ON;
	
	if(m_nChannels > 1 && m_nIgnoreNoteRange != nIgnoreFlag && !m_bReset)
		nIgnoreFlag = IGNORE_UNDT;

	m_nIgnoreNoteRange = nIgnoreFlag;
}


void CCommonInstrumentPropertyObject::SetPChannelNumber(int nNumber)
{
	if(m_nChannels > 1)
		m_nPChannelNumber = -1;
	else
		m_nPChannelNumber = nNumber;
}

void CCommonInstrumentPropertyObject::SetPChannelName(CString sName)
{
	if(m_nChannels > 1)
		m_sPChannelName = achUnknown;
	else
		m_sPChannelName = sName;
}

void CCommonInstrumentPropertyObject::SetInstrument(CDMInstrument* pInstrument)
{
	ASSERT(pInstrument);
	if(pInstrument == NULL)
		return;

	int nPC = pInstrument->dwPatch & 0x7F;
	int nMSB = MSB(pInstrument->dwPatch);
	int nLSB = LSB(pInstrument->dwPatch);

	CBand* pBand = m_pBandDlg->GetBand();
	ASSERT(pBand);

	bool bIsGM = (0 != (pInstrument->dwFlags & DMUS_IO_INST_GM));
	bool bIsGS = (0 != (pInstrument->dwFlags & DMUS_IO_INST_GS));

	CString sCollection = pInstrument->m_csCollection;
	if(pInstrument->m_pDMReference == NULL && false == bIsGM && false == bIsGS)
		sCollection.LoadString(IDS_UNKNOWN);

	if(sCollection.IsEmpty() && bIsGM)
		sCollection.LoadString(IDS_GM);
	if(sCollection.IsEmpty() && bIsGS)
		sCollection.LoadString(IDS_GS);

	if(m_nChannels <= 1 || m_bReset)
	{
		m_sPatch = CBandDlg::GetPatchName(pBand->m_pComponent, pInstrument);
		m_dwInstrumentPatchInfo = pInstrument->dwPatch;
		m_sInstrumentCollectionInfo = sCollection;
		m_sInstrumentInfo.Format("%s (%d, %d, %d)", m_sInstrumentCollectionInfo, nMSB, nLSB, nPC);
	}
	else if(m_nChannels > 1)
	{
		CString sInstrumentInfo;
		sCollection = pInstrument->m_csCollection;
		if(sCollection.IsEmpty() && bIsGM)
			sCollection.LoadString(IDS_GM);
		else if(sCollection.IsEmpty() && bIsGS)
			sCollection.LoadString(IDS_GS);
		else
			sCollection.LoadString(IDS_UNKNOWN);

		if(m_sInstrumentCollectionInfo != sCollection)
			m_sInstrumentCollectionInfo = achUnknown;
		
		if(m_dwInstrumentPatchInfo != pInstrument->dwPatch)
		{
			m_dwInstrumentPatchInfo = 0xFFFFFFFF;
			sInstrumentInfo.Format("%s (%s)", m_sInstrumentCollectionInfo, achUnknown);
		}
		else
			sInstrumentInfo.Format("%s (%d, %d, %d)", m_sInstrumentCollectionInfo, nMSB, nLSB, nPC);

		m_sInstrumentInfo = sInstrumentInfo;

		if(m_sPatch != CBandDlg::GetPatchName(pBand->m_pComponent, pInstrument))
			m_sPatch = achUnknown;
	}
}

// Forced set on the instrument name while updating from the property page 
void CCommonInstrumentPropertyObject::SetInstrument(CString sInstrumentName)
{
	m_sPatch = sInstrumentName;
}

void CCommonInstrumentPropertyObject::SetPatch(DWORD dwPatch)
{
	m_dwPatch = dwPatch;
}

void CCommonInstrumentPropertyObject::SetOctave(short nTranspose)
{
	short nOctave = nTranspose/12;
	if(m_nChannels <= 1 || m_bReset)
	{
		m_nOctave = nOctave;
	}
	else if(m_nChannels > 1 && m_nOctaveTranspose != nTranspose)
		m_nOctave = -12;
}

void CCommonInstrumentPropertyObject::SetTranspose(short nTranspose)
{
	short nOctave = nTranspose / 12;
	
	short nFractionalTranspose = nTranspose - nOctave * 12;

	if(m_nChannels <= 1 || m_bReset)
	{
		m_nTranspose = nFractionalTranspose;
	}
	else if(m_nChannels > 1 && m_nOctaveTranspose != nTranspose)
		m_nTranspose = -12;
}


void CCommonInstrumentPropertyObject::SetOctaveTranspose(short nOctaveTranspose)
{
	if(m_nChannels <= 1 || m_bReset)
	{
		m_nOctave = (int)(nOctaveTranspose/12);
		m_nTranspose = nOctaveTranspose - m_nOctave * 12;
		m_nOctaveTranspose = nOctaveTranspose;
	}
	else if(m_nChannels > 1 && m_nOctaveTranspose != nOctaveTranspose)
		m_nTranspose = -12;
}


void CCommonInstrumentPropertyObject::SetPitchBendOctave(short nPitchBendRange)
{
	nPitchBendRange = nPitchBendRange > 127 ? 127 :  nPitchBendRange;
	nPitchBendRange = nPitchBendRange < 0 ? 0 :  nPitchBendRange;

	short nOctave = nPitchBendRange / 12;
	if(m_nChannels <= 1 || m_bReset)
	{
		m_nPitchBendOctave = nOctave;
	}
	else if(m_nChannels > 1 && m_nPitchBendRange != nPitchBendRange)
	{
		m_nPitchBendOctave = -12;
	}
}

void CCommonInstrumentPropertyObject::SetPitchBendTranspose(short nPitchBendRange)
{
	nPitchBendRange = nPitchBendRange > 127 ? 127 :  nPitchBendRange;
	nPitchBendRange = nPitchBendRange < 0 ? 0 :  nPitchBendRange;

	short nOctave = nPitchBendRange/12;
	
	short nFractionalTranspose = nPitchBendRange - nOctave * 12;

	if(m_nChannels <= 1 || m_bReset)
	{
		m_nPitchBendTranspose = nFractionalTranspose;
	}
	else if(m_nChannels > 1 && m_nPitchBendRange != nPitchBendRange)
		m_nPitchBendRange = -12;
}


void CCommonInstrumentPropertyObject::SetPitchBendRange(short nPitchBendRange)
{
	if(m_nChannels <= 1 || m_bReset)
	{
		nPitchBendRange = nPitchBendRange > 127 ? 127 :  nPitchBendRange;
		nPitchBendRange = nPitchBendRange < 0 ? 0 :  nPitchBendRange;

		m_nPitchBendOctave = (int)(nPitchBendRange / 12);
		m_nPitchBendTranspose = nPitchBendRange - m_nPitchBendOctave * 12;
		m_nPitchBendRange = nPitchBendRange;
	}
	else if(m_nChannels > 1 && m_nPitchBendRange!= nPitchBendRange)
	{
		m_nPitchBendRange = -12;
	}
}


void CCommonInstrumentPropertyObject::SetNoteRange(int nHighNote, int nLowNote)
{
	if(m_nChannels <= 1 || m_bReset)
	{
		nHighNote = nHighNote > 127 ? 127 :  nHighNote;
		nLowNote = nLowNote < 0 ? 0 :  nLowNote;

		m_nHighNote = short(nHighNote);
		m_nLowNote = short(nLowNote);
	}
	else if(m_nChannels > 1)
	{
		if(m_nLowNote != nLowNote)
		{
			m_nLowNote = -1;
		}
		if(m_nHighNote != nHighNote)
		{
			m_nHighNote = -1;
		}
	}
}

void CCommonInstrumentPropertyObject::SetVolume(int nVolume)
{
	if(m_nChannels <= 1 || m_bReset)
	{
		m_nVolume = nVolume;
	}
	else if(m_nChannels > 1 && m_nVolume != nVolume)
		m_nVolume = -1;
}
	

void CCommonInstrumentPropertyObject::SetPan(int nPan)
{
	if(m_nChannels <= 1 || m_bReset)
	{
		m_nPan = nPan;
	}
	else if(m_nChannels > 1 && m_nPan != nPan)
		m_nPan = -1;
}

// bool bPreserveOffset flag is used when the offset is not changed BUT 
// the priority level is changed on the property page 
void CCommonInstrumentPropertyObject::SetPriority(DWORD dwPriority, bool bPreserveOffset)
{
	m_bPreservePriorityOffset = bPreserveOffset;

	// Find out where this priority range falls
	int nCount = 0;
	while(dwPriority < dwaPriorityLevels[nCount] && nCount < PRIORITY_LEVELS)
		nCount++;
	
	DWORD dwPriorityLevel = dwaPriorityLevels[nCount];
	DWORD dwPriorityOffset = dwPriority - dwaPriorityLevels[nCount];

	if(m_nChannels <= 1 || m_bReset)
	{
		m_dwPriority = dwPriority;
		m_dwPriorityLevel = dwPriorityLevel;
		m_dwPriorityOffset = dwPriorityOffset;
	}
	else if(m_nChannels > 1 && (m_dwPriorityLevel != dwPriorityLevel) || (m_dwPriorityOffset != dwPriorityOffset))
	{
		if(m_dwPriorityLevel != dwPriorityLevel )
			m_dwPriorityLevel = 0xFFFFFFFF;

		if(m_dwPriorityOffset != dwPriorityOffset)
			m_dwPriorityOffset = 0xFFFFFFFF;
	}
	else
		m_dwPriority = m_dwPriority|dwPriority;
}

void CCommonInstrumentPropertyObject::SetLowNote(short nLowNote)
{
	ASSERT(nLowNote >= 0 && nLowNote <= 127);
	m_nLowNote = nLowNote;
}

void CCommonInstrumentPropertyObject::SetHighNote(short nHighNote)
{
	ASSERT(nHighNote >= 0 && nHighNote <= 127);
	m_nHighNote = nHighNote;
}


void CCommonInstrumentPropertyObject::SetSoundCanvas(CDMInstrument* pInstrument)
{
	int nState = 0;
	if(pInstrument->dwFlags & DMUS_IO_INST_USE_DEFAULT_GM_SET)
		nState = 1;
	
	if(m_nChannels <= 1 || m_bReset)
	{
		m_nSoundCanvas = nState;
	}
	else if(m_nChannels > 1 && m_nSoundCanvas != nState)
		m_nSoundCanvas = 2;
}

void CCommonInstrumentPropertyObject::SetSoundCanvas(int nState)
{
	m_nSoundCanvas = nState;
}


int  CCommonInstrumentPropertyObject::GetPChannelNumber()
{
	return m_nPChannelNumber;
}

CString CCommonInstrumentPropertyObject::GetPChannelName()
{
	return m_sPChannelName;
}

CString CCommonInstrumentPropertyObject::GetInstrument()
{
	return m_sPatch;
}

short CCommonInstrumentPropertyObject::GetOctave()
{
	return m_nOctave;
}

short CCommonInstrumentPropertyObject::GetTranspose()
{
	return m_nTranspose;
}

short CCommonInstrumentPropertyObject::GetOctaveTranspose()
{
	return m_nOctaveTranspose;
}


short CCommonInstrumentPropertyObject::GetPitchBendOctave()
{
	return m_nPitchBendOctave;
}

short CCommonInstrumentPropertyObject::GetPitchBendTranspose()
{
	return m_nPitchBendTranspose;
}

short CCommonInstrumentPropertyObject::GetPitchBendRange()
{
	return m_nPitchBendRange;
}

int CCommonInstrumentPropertyObject::GetVolume()
{
	return m_nVolume;
}

int CCommonInstrumentPropertyObject::GetPan()
{
	return m_nPan;
}

void CCommonInstrumentPropertyObject::GetPriority(DWORD& dwPriority, DWORD& dwOffset)
{
	// Don't do anything if it's indeterminate
	/*if(m_dwPriority == 0xFFFFFFFF)
		return;

		// Find out where this priority range falls
	int nCount = 0;
	while(m_dwPriority < dwaPriorityLevels[nCount] && nCount < PRIORITY_LEVELS)
		nCount++;
	
	dwPriority = dwaPriorityLevels[nCount];
	dwOffset = m_dwPriority - dwaPriorityLevels[nCount];*/

	dwPriority = m_dwPriorityLevel;
	dwOffset = m_dwPriorityOffset;
}

short CCommonInstrumentPropertyObject::GetLowNote()
{
	return m_nLowNote;
}

short CCommonInstrumentPropertyObject::GetHighNote()
{
	return m_nHighNote;
}

int CCommonInstrumentPropertyObject::GetSoundCanvas()
{
	return m_nSoundCanvas;
}


// All the SetIgnore methods....

void CCommonInstrumentPropertyObject::SetIgnoreInstrument(int nIgnore)
{
	m_nIgnoreInstrument = nIgnore;
}


void CCommonInstrumentPropertyObject::SetIgnoreOctaveTranspose(int nIgnore)
{
	m_nIgnoreOctaveTranspose = nIgnore;
}

void CCommonInstrumentPropertyObject::SetIgnorePitchBendRange(int nIgnore)
{
	m_nIgnorePitchBendRange = nIgnore;
}

void CCommonInstrumentPropertyObject::SetIgnoreVolume(int nIgnore)
{
	m_nIgnoreVolume = nIgnore;
}

void CCommonInstrumentPropertyObject::SetIgnorePan(int nIgnore)
{
	m_nIgnorePan = nIgnore;
}

void CCommonInstrumentPropertyObject::SetIgnorePriority(int nIgnore)
{
	m_nIgnorePriority = nIgnore;
}

void CCommonInstrumentPropertyObject::SetIgnoreNoteRange(int nIgnore)
{
	m_nIgnoreNoteRange = nIgnore;
}

void CCommonInstrumentPropertyObject::ApplyChangesToSelectedChannelsAndRefreshUI()
{
	ASSERT(m_pBandDlg);
	CBand* pBand = m_pBandDlg->GetBand();
	ASSERT(pBand);
	
	int nSelectedChannels = pBand->GetNumberOfSelectedInstruments();

	if(nSelectedChannels == 0)
		return;
	
	CInstrumentListItem** ppInstrumentsArray = new CInstrumentListItem* [nSelectedChannels];
	ASSERT(ppInstrumentsArray);

	pBand->GetSelectedInstruments(ppInstrumentsArray);

	for(int nCount=0; nCount < nSelectedChannels; nCount++)
	{
		CInstrumentListItem* pInstrumentItem = ppInstrumentsArray[nCount];
		ASSERT(pInstrumentItem);

		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		ApplyChanges(pInstrument);
	}

	// We need to update if somebody else does a Send
	CDMInstrument::m_bSendBandUpdate = TRUE;
	SyncPChannelChanges(nSelectedChannels, ppInstrumentsArray);
	CDMInstrument::m_bSendBandUpdate = TRUE;

	delete[] ppInstrumentsArray;	

	bool bResetChannelList = false;
	if(m_dwChanged & PCHANNEL_CHANGED)
	{
		bResetChannelList = true;
	}

	m_pBandDlg->UpdatePChannelChanges(bResetChannelList);
	
	// Reset all the temporary values;
	m_dwChanged = 0;
	m_dwInstrumentChangeID = 0;
	m_nABIIndex = 0;
}

void CCommonInstrumentPropertyObject::ApplyChanges(CDMInstrument* pInstrument)
{
	// Mark the band as modified so we get the "save" messagebox at exit time...
	m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );

	if(m_dwChanged & OCTAVE_CHANGED)
		ApplyOctaveChange(pInstrument);
	
	if(m_dwChanged & PAN_CHANGED)
		ApplyPanChange(pInstrument);

	if(m_dwChanged & VOLUME_CHANGED)
		ApplyVolumeChange(pInstrument);

	if(m_dwChanged & INSTRUMENT_CHANGED)
		ApplyInstrumentChange(pInstrument);

	if(m_dwChanged & PCHANNEL_CHANGED)
		ApplyPChannelChange(pInstrument);

	if(m_dwChanged & NOTERANGE_CHANGED)
		ApplyNoteRangeChange(pInstrument);

	if(m_dwChanged & PITCHBEND_CHANGED)
		ApplyPitchBendRangeChange(pInstrument);

	if(m_dwChanged & PRIORITY_CHANGED)
		ApplyPriorityChange(pInstrument);

	if(m_dwChanged & SOUNDCANVAS_CHANGED)
		ApplySoundCanvasChange(pInstrument);

	if(m_dwChanged & IGNORES_CHANGED)
		ApplyIgnores(pInstrument);
}

void CCommonInstrumentPropertyObject::SyncPChannelChanges(int nChannels, CInstrumentListItem** ppInstrumentsArray)
{
	bool bDeleteInstrumentArray = false;
	if(ppInstrumentsArray == NULL)
	{
		ASSERT(m_pBandDlg);
		CBand* pBand = m_pBandDlg->GetBand();
		ASSERT(pBand);
		nChannels = pBand->GetNumberOfSelectedInstruments();

		if(nChannels == 0)
			return;
		
		ppInstrumentsArray = new CInstrumentListItem* [nChannels];
		ASSERT(ppInstrumentsArray);

		pBand->GetSelectedInstruments(ppInstrumentsArray);

		bDeleteInstrumentArray = true;
	}
	
	CDMInstrument::m_bSendBandUpdate = TRUE;
	BOOL bSendForBandUpdate = TRUE; 

	// Send the changes for each instrument
	for(int nCount = 0; nCount < nChannels; nCount++)
	{
		CInstrumentListItem* pInstrumentItem = ppInstrumentsArray[nCount];
		ASSERT(pInstrumentItem);

		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		// Do we need to send the band changes?
		if(bSendForBandUpdate)
		{
			bSendForBandUpdate = FALSE;
			if(!pInstrument->SendBandUpdate(m_pBandDlg->GetBand()))
				return;
		}

		CDMInstrument::m_bSendBandUpdate = FALSE;
		SyncChanges(pInstrument);
	}

	if(bDeleteInstrumentArray)
		delete[] ppInstrumentsArray;
}

void CCommonInstrumentPropertyObject::SyncChanges(CDMInstrument* pInstrument, CBand *pBand)
{
	ASSERT( pBand || (m_pBandDlg && m_pBandDlg->GetBand()) );

	if(m_dwChanged & OCTAVE_CHANGED)
		pInstrument->Send(pBand ? pBand : m_pBandDlg->GetBand(), DM_TRANSPOSE);
	
	if(m_dwChanged & PAN_CHANGED)
		pInstrument->Send(pBand ? pBand : m_pBandDlg->GetBand(), DM_PAN);

	if(m_dwChanged & VOLUME_CHANGED)
		pInstrument->Send(pBand ? pBand : m_pBandDlg->GetBand(), DM_VOLUME);

	if(m_dwChanged & INSTRUMENT_CHANGED)
		pInstrument->Send(pBand ? pBand : m_pBandDlg->GetBand(), DM_PATCH_CHANGE);

	if(m_dwChanged & PRIORITY_CHANGED)
		pInstrument->Send(pBand ? pBand : m_pBandDlg->GetBand(), DM_PATCH_CHANGE);

	if(m_dwChanged & SOUNDCANVAS_CHANGED)
		pInstrument->Send(pBand ? pBand : m_pBandDlg->GetBand(), DM_PATCH_CHANGE);

	if(m_dwChanged & IGNORES_CHANGED)
		SyncIgnores(pInstrument);
}



void CCommonInstrumentPropertyObject::SyncIgnores(CDMInstrument* pInstrument)
{
	if(m_dwChanged & IGNORE_INSTRUMENT_CHANGED)
		SyncInstrumentIgnore(pInstrument);

	if(m_dwChanged & IGNORE_OCTAVETRANSPOSE_CHANGED)
		SyncOctaveTransposeIgnore(pInstrument);

	if(m_dwChanged & IGNORE_VOLUME_CHANGED)
		SyncVolumeIgnore(pInstrument);

	if(m_dwChanged & IGNORE_PAN_CHANGED)
		SyncPanIgnore(pInstrument);

	if(m_dwChanged & IGNORE_PRIORITY_CHANGED)
		SyncPriorityIgnore(pInstrument);

	if(m_dwChanged & IGNORE_PITCHBEND_CHANGED)
		SyncPitchBendRangeIgnore(pInstrument);
}



void CCommonInstrumentPropertyObject::ApplyOctaveChange(CDMInstrument* pInstrument)
{
	pInstrument->nTranspose = GetOctaveTranspose();
}


void CCommonInstrumentPropertyObject::ApplyPitchBendRangeChange(CDMInstrument* pInstrument)
{
	pInstrument->nPitchBendRange = GetPitchBendRange();
}


void CCommonInstrumentPropertyObject::ApplyPanChange(CDMInstrument* pInstrument)
{
	pInstrument->bPan = BYTE(GetPan());
}


void CCommonInstrumentPropertyObject::ApplyVolumeChange(CDMInstrument* pInstrument)
{
	pInstrument->bVolume = BYTE(GetVolume());
}

void CCommonInstrumentPropertyObject::ApplyInstrumentChange(CDMInstrument* pInstrument, const CString *pcsCurrentCollection)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pInstrument);
	BInstr bi;

	if(m_dwInstrumentChangeID == DLS_REQUEST)
	{
		ASSERT( pcsCurrentCollection || (m_pBandDlg && m_pBandDlg->GetBand()) );

		CDlgDLS dlg;
		int nPChannel = pInstrument->dwPChannel;

		// initialize the data
		dlg.m_nLastSelectedCollection = m_nLastSelectedCollection;
		dlg.m_csCurrentCollection = m_csCurrentCollection;

		dlg.m_nTrack = nPChannel;
		dlg.m_nPC = pInstrument->dwPatch & 0x7F;
		dlg.m_nMSB = MSB(pInstrument->dwPatch);
		dlg.m_nLSB = LSB(pInstrument->dwPatch);
		
		if( pInstrument->m_csCollection.IsEmpty() == FALSE )
			dlg.m_csCurrentCollection = pInstrument->m_csCollection;
		else if(m_csCurrentCollection.IsEmpty())
		{
			if( pcsCurrentCollection )
			{
				dlg.m_csCurrentCollection = *pcsCurrentCollection;
			}
			else if( m_pBandDlg )
			{
				dlg.m_csCurrentCollection = m_pBandDlg->GetBand()->m_strDefaultCollection;
			}
		}
		
		// display the dialog
		if( IDOK == dlg.DoModal())
		{
			// set the new values
			m_csCurrentCollection = dlg.m_csCurrentCollection;
			m_nLastSelectedCollection = dlg.m_nLastSelectedCollection;
			pInstrument->m_csCollection = dlg.m_csCurrentCollection;
	
			pInstrument->dwPatch = MAKE_PATCH( (pInstrument->IsDrums()), dlg.m_nMSB, dlg.m_nLSB, dlg.m_nPC & 0x7F );

			pInstrument->dwFlags |= (DMUS_IO_INST_BANKSELECT);
			pInstrument->dwFlags &= ~(DMUS_IO_INST_GS | DMUS_IO_INST_GM);
			pInstrument->dwFlags |= 
				(DMUS_IO_INST_TRANSPOSE | DMUS_IO_INST_PATCH);

			// Store reference to DLS Collection
			pInstrument->SetDLSCollection( dlg.m_pICurrentRefNode );

			if( m_pBandDlg )
			{
				m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
			}
		}

		return;
	}

	// No Custom DLS
	pInstrument->m_csCollection = "";

	if(m_dwInstrumentChangeID == DRUMS_REQUEST) // If a drum request
		bi = abiDrums[m_nABIIndex];
	else										// A GM/GS request
		bi = abiGS[m_nABIIndex];


	int nPChannel = pInstrument->dwPChannel;
	
	pInstrument->dwPatch = MAKE_PATCH( (pInstrument->IsDrums()), bi.bMSB, bi.bLSB, bi.bPatch & 0x7F );

	// Clear GM/GS flags;
	pInstrument->dwFlags &= ~(DMUS_IO_INST_GS | DMUS_IO_INST_GM);
	if( bi.bMSB != 0	&&  pInstrument->IsDrums() == false)
	{
		pInstrument->dwFlags |= DMUS_IO_INST_BANKSELECT; 			// GS
		pInstrument->dwFlags |= DMUS_IO_INST_GS;
	}
	else
	{
		pInstrument->dwFlags &= ~DMUS_IO_INST_BANKSELECT;			// GM
		pInstrument->dwFlags |= DMUS_IO_INST_GM;
	}

	// Get rid of reference to DLS Collection
	pInstrument->SetDLSCollection( NULL );

	if( m_pBandDlg )
	{
		m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
	}
}

void CCommonInstrumentPropertyObject::ApplyPChannelChange(CDMInstrument* pInstrument)
{
	m_pBandDlg->ChangePChannelNumber(pInstrument, m_nPChannelNumber);
	m_nChannels = 0;
}

void CCommonInstrumentPropertyObject::ApplyNoteRangeChange(CDMInstrument* pInstrument)
{
	ASSERT(sizeof(pInstrument->dwNoteRanges) == 16);
	ZeroMemory(pInstrument->dwNoteRanges, 16);

	WORD wNoteIdx = (WORD)GetLowNote(), wNoteMax = (WORD)GetHighNote();
	WORD wNoteMaskIdx = wNoteIdx / 32;
	PDWORD pdwNoteMask = &pInstrument->dwNoteRanges[wNoteMaskIdx];

	while (wNoteIdx <= wNoteMax && wNoteMaskIdx < 4)
	{
		*pdwNoteMask |= 1 << (wNoteIdx % 32);
		if (!(++wNoteIdx % 32))
		{
			pdwNoteMask = &pInstrument->dwNoteRanges[++wNoteMaskIdx];
		}
	}
}

void CCommonInstrumentPropertyObject::ApplyPriorityChange(CDMInstrument* pInstrument)
{
	 // If we're changing only the level
	if(m_bPreservePriorityOffset)
	{
		// Find out where this priority range falls
		int nCount = 0;
		while(pInstrument->dwChannelPriority < dwaPriorityLevels[nCount] && nCount < PRIORITY_LEVELS)
			nCount++;
		
		DWORD dwOffset = pInstrument->dwChannelPriority - dwaPriorityLevels[nCount];
		pInstrument->dwChannelPriority = m_dwPriorityLevel|dwOffset;
	}
	else
		pInstrument->dwChannelPriority = m_dwPriority;
}

void CCommonInstrumentPropertyObject::ApplySoundCanvasChange(CDMInstrument* pInstrument)
{
	// We can't set the indeterminate state
	if(m_nSoundCanvas == 2)
		return;

	if(m_nSoundCanvas == 1)
		pInstrument->dwFlags |= DMUS_IO_INST_USE_DEFAULT_GM_SET;
	else
		pInstrument->dwFlags &= ~DMUS_IO_INST_USE_DEFAULT_GM_SET;
}


	
void CCommonInstrumentPropertyObject::ApplyIgnores(CDMInstrument* pInstrument)
{
	if(m_dwChanged & IGNORE_INSTRUMENT_CHANGED)
		ApplyInstrumentIgnore(pInstrument);

	if(m_dwChanged & IGNORE_OCTAVETRANSPOSE_CHANGED)
		ApplyOctaveTransposeIgnore(pInstrument);

	if(m_dwChanged & IGNORE_VOLUME_CHANGED)
		ApplyVolumeIgnore(pInstrument);

	if(m_dwChanged & IGNORE_PAN_CHANGED)
		ApplyPanIgnore(pInstrument);

	if(m_dwChanged & IGNORE_PRIORITY_CHANGED)
		ApplyPriorityIgnore(pInstrument);

	if(m_dwChanged & IGNORE_NOTERANGE_CHANGED)
		ApplyNoteRangeIgnore(pInstrument);

	if(m_dwChanged & IGNORE_PITCHBEND_CHANGED)
		ApplyPitchBendRangeIgnore(pInstrument);
}

void CCommonInstrumentPropertyObject::ApplyInstrumentIgnore(CDMInstrument* pInstrument)
{

	if(m_nIgnoreInstrument == IGNORE_ON)
	{
		pInstrument->dwFlags &= ~DMUS_IO_INST_PATCH;
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnoreInstrument == IGNORE_OFF)
	{
		pInstrument->dwFlags |= DMUS_IO_INST_PATCH;
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PATCH_CHANGE);
	}

	m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
}

void CCommonInstrumentPropertyObject::ApplyOctaveTransposeIgnore(CDMInstrument* pInstrument)
{
	DWORD temp = DMUS_IO_INST_TRANSPOSE;

	if(m_nIgnoreOctaveTranspose == IGNORE_ON)
	{
		pInstrument->dwFlags &= ~DMUS_IO_INST_TRANSPOSE; // Ignore the transpose
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnoreOctaveTranspose == IGNORE_OFF)
	{
		pInstrument->dwFlags |= DMUS_IO_INST_TRANSPOSE;
		pInstrument->Send(m_pBandDlg->GetBand(), DM_TRANSPOSE);
	}

	m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
}


void CCommonInstrumentPropertyObject::ApplyPitchBendRangeIgnore(CDMInstrument* pInstrument)
{
	DWORD temp = DMUS_IO_INST_PITCHBENDRANGE;

	if(m_nIgnorePitchBendRange == IGNORE_ON)
	{
		pInstrument->dwFlags &= ~DMUS_IO_INST_PITCHBENDRANGE; // Ignore the transpose
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnorePitchBendRange == IGNORE_OFF)
	{
		pInstrument->dwFlags |= DMUS_IO_INST_PITCHBENDRANGE;
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PITCHBEND_RANGE);
	}

	m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
}


void CCommonInstrumentPropertyObject::ApplyVolumeIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnoreVolume == IGNORE_ON)
	{
		pInstrument->dwFlags &= ~DMUS_IO_INST_VOLUME; // Ignore the volume
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnoreVolume == IGNORE_OFF)
	{
		pInstrument->dwFlags |= DMUS_IO_INST_VOLUME;
		pInstrument->Send(m_pBandDlg->GetBand(), DM_VOLUME);
	}

	m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
}

void CCommonInstrumentPropertyObject::ApplyPanIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnorePan == IGNORE_ON)
	{
		pInstrument->dwFlags &= ~DMUS_IO_INST_PAN; // Ignore the pan
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnorePan == IGNORE_OFF)
	{
		pInstrument->dwFlags |= DMUS_IO_INST_PAN;
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PAN);
	}
	m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
}

void CCommonInstrumentPropertyObject::ApplyPriorityIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnorePriority == IGNORE_ON)
	{
		pInstrument->dwFlags &= ~DMUS_IO_INST_CHANNEL_PRIORITY; // Ignore the pan
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnorePriority == IGNORE_OFF)
	{
		pInstrument->dwFlags |= DMUS_IO_INST_CHANNEL_PRIORITY;
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PATCH_CHANGE);
	}

	m_pBandDlg->GetBand()->SetModifiedFlag( TRUE );
}


void CCommonInstrumentPropertyObject::ApplyNoteRangeIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnoreNoteRange == IGNORE_ON)
		pInstrument->dwFlags &= ~DMUS_IO_INST_NOTERANGES; // Ignore the note range
	else if(m_nIgnoreNoteRange == IGNORE_OFF)
		pInstrument->dwFlags |= DMUS_IO_INST_NOTERANGES;
}


void CCommonInstrumentPropertyObject::SyncInstrumentIgnore(CDMInstrument* pInstrument)
{

	if(m_nIgnoreInstrument == IGNORE_ON)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnoreInstrument == IGNORE_OFF)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PATCH_CHANGE);
	}
}


void CCommonInstrumentPropertyObject::SyncOctaveTransposeIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnoreOctaveTranspose == IGNORE_ON)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnoreOctaveTranspose == IGNORE_OFF)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), DM_TRANSPOSE);
	}
}


void CCommonInstrumentPropertyObject::SyncPitchBendRangeIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnorePitchBendRange == IGNORE_ON)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnorePitchBendRange == IGNORE_OFF)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PITCHBEND_RANGE);
	}
}


void CCommonInstrumentPropertyObject::SyncVolumeIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnoreVolume == IGNORE_ON)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnoreVolume == IGNORE_OFF)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), DM_VOLUME);
	}
}

void CCommonInstrumentPropertyObject::SyncPanIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnorePan == IGNORE_ON)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnorePan == IGNORE_OFF)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PAN);
	}
}

void CCommonInstrumentPropertyObject::SyncPriorityIgnore(CDMInstrument* pInstrument)
{
	if(m_nIgnorePriority == IGNORE_ON)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), NULL);
	}
	else if(m_nIgnorePriority == IGNORE_OFF)
	{
		pInstrument->Send(m_pBandDlg->GetBand(), DM_PATCH_CHANGE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandComponent.h ===
#ifndef __BANDCOMPONENT_H__
#define __BANDCOMPONENT_H__

// BandComponent.h : header file
//

#define MSB_MASK (0x007F0000)
#define LSB_MASK (0x00007F00)

#define MAKE_PATCH(DRUM, MSB, LSB, Patch) ( ((DWORD) ((DRUM) == 0 ? 0 : 0x80000000))  | ((DWORD)(BYTE)(MSB) << 16) | ((DWORD)(LSB) << 8) | (DWORD)(Patch))
#define MSB(dwPatch) (((dwPatch) & MSB_MASK) >> 16)
#define LSB(dwPatch) (((dwPatch) & LSB_MASK) >> 8)

#include <afxtempl.h>
#include "dmusici.h"

class CBand;

class CBandComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt
{
public:
    CBandComponent();
	~CBandComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
    HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivateApp );

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists( void );
	BOOL RegisterClipboardFormats();
	void ReleaseAll();

public:
    HRESULT STDMETHODCALLTYPE	GetBandImageIndex( short* pnFirstImage );
    HRESULT STDMETHODCALLTYPE	GetFolderImageIndex( short* pnFirstImage );
    HRESULT STDMETHODCALLTYPE	GetBandRefImageIndex( short* pnFirstImage );

	void						AddToBandFileList( CBand* pBand );
	void						RemoveFromBandFileList( CBand* pBand );

	IDMUSProdReferenceNode*		FindDLSCollection( CString csCollection, IStream* pIStream );
	IDMUSProdReferenceNode*		CreateCollectionRefNode( IDMUSProdNode* pDLSCollectionNode );
	bool						IsGM( DWORD dwBank, DWORD dwInstrument );

	HRESULT						SendPMsg( DMUS_PMSG *pPMsg, IDirectMusicAudioPath* pDMAudioPath = NULL );
	
	BOOL						IsInFailedCollectionList(CString csCollection);

public:
	interface IDirectMusicPerformance*	m_pIDMPerformance;
	IDMUSProdFramework*					m_pIFramework;
	IDMUSProdConductor*					m_pIConductor;
	CList<CString, CString&>			m_lstLastCollection;

	void*				m_pvLastFailedCollectionRefStream;
	short				m_nNextBand;		// Appended to name of new Band
	UINT				m_cfBand;			// CF_BAND clipboard format
	UINT				m_cfBandList;		// CF_BANDLIST clipboard format
	UINT				m_cfProducerFile;	// CF_DMUSPROD_FILE clipboard format

private:
	IDMUSProdDocType8*  m_pIDocType8;
    DWORD				m_dwRef;
	short				m_nFirstBandImage;
	short				m_nFirstBandRefImage;
	short				m_nFirstFolderImage;

	CTypedPtrList<CPtrList, CBand*> m_lstBands;


};

#endif // __BANDCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandCtl.h ===
#if !defined(BANDCTL_H__3BD2BA32_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
#define BANDCTL_H__3BD2BA32_46E7_11D0_89AC_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// BandCtl.h : Declaration of the CBandCtrl ActiveX Control class.

class CBandDlg;

/////////////////////////////////////////////////////////////////////////////
// CBandCtrl : See BandCtl.cpp for implementation.

class CBandCtrl : public COleControl
{
friend class CBandDlg;

	DECLARE_DYNCREATE(CBandCtrl)

// Constructor
public:
	CBandCtrl();

// Attributes
public:
	CBandDlg*	m_pBandDlg;
	bool		m_fFrameActive;
	bool		m_fDocWindowActive;

private:
	HWND				m_hWndContainer;
	HMENU				m_hMenuInPlace;
	HANDLE				m_hKeyStatusBar;
	CToolBar*			m_pToolBar;
	CBand*				m_pBand;
	CBandComponent*		m_pComponent;
	HWND				m_hLastFocusWnd;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBandCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CBandCtrl();

	DECLARE_OLECREATE_EX(CBandCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CBandCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CBandCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CBandCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CBandCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnEditProperties();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnEditUndo();
	afx_msg void OnEditRedo();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnHelpFinder();
	afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
	afx_msg void OnEditSelectAll();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CBandCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CBandCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

	// IOleInPlaceObject
	BEGIN_INTERFACE_PART(MyOleInPlaceObject, IOleInPlaceObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(InPlaceDeactivate)();
		STDMETHOD(UIDeactivate)();
		STDMETHOD(SetObjectRects)(LPCRECT, LPCRECT);
		STDMETHOD(ReactivateAndUndo)();
	END_INTERFACE_PART(MyOleInPlaceObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CBandCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(BANDCTL_H__3BD2BA32_46E7_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandCtl.cpp ===
// BandCtl.cpp : Implementation of the CBandCtrl ActiveX Control class.

#include "stdafx.h"
#include "BandEditorDLL.h"
#include "Band.h"
#include "BandRef.h"
#include "BandCtl.h"
#include "BandDlg.h"
#include "BandPpg.h"
#include "BandAboutBox.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBandCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CBandCtrl, COleControl)
	//{{AFX_MSG_MAP(CBandCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_COMMAND(ID_EDIT_PROPERTIES, OnEditProperties)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_WM_SETFOCUS()
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECTALL, OnUpdateEditSelectAll)
	ON_COMMAND(ID_EDIT_SELECTALL, OnEditSelectAll)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CBandCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CBandCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CBandCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CBandCtrl, COleControl)
	//{{AFX_EVENT_MAP(CBandCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl Interface map

BEGIN_INTERFACE_MAP(CBandCtrl, COleControl)
    INTERFACE_PART(CBandCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CBandCtrl, IID_IOleInPlaceObject, MyOleInPlaceObject)
    INTERFACE_PART(CBandCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CBandCtrl, 1)
	PROPPAGEID(CBandPropPage::guid)
END_PROPPAGEIDS(CBandCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CBandCtrl, "STYLEDESIGNER.BandCtrl.1",
	0x3bd2ba11, 0x46e7, 0x11d0, 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CBandCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DBand =
		{ 0x3bd2ba0f, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DBandEvents =
		{ 0x3bd2ba10, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwBandOleMisc =
	OLEMISC_SIMPLEFRAME |
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CBandCtrl, IDS_BAND, _dwBandOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::CBandCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CBandCtrl

BOOL CBandCtrl::CBandCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_BAND,
			IDB_BAND,
			afxRegApartmentThreading,
			_dwBandOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::CBandCtrl - Constructor

CBandCtrl::CBandCtrl()
{
	m_pComponent = NULL;

/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DBand, &IID_DBandEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DBand;
	m_piidEvents = &IID_DBandEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	EnableSimpleFrame();

	m_pBandDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_hKeyStatusBar = NULL;
	m_pToolBar = NULL;
	m_pBand = NULL;
	m_hLastFocusWnd = NULL;
	m_fFrameActive = false;
	m_fDocWindowActive = false;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::~CBandCtrl - Destructor

CBandCtrl::~CBandCtrl()
{

	// If we are in a Property Page Manager we need to remove ourselves before we go away
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pBand->m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**) &pIPropSheet)))
	{
		pIPropSheet->RemovePageManagerByObject(&(CInstrumentListItem::m_CommonPropertyObject));
		pIPropSheet->Release();
	}


	if( m_pBand )
	{
		m_pBand->Release();
	}
	if (m_pComponent)
	{
		m_pComponent->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CBandCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CBandCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CBandCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CBandCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::QueryInterface

STDMETHODIMP CBandCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CBandCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::AttachObjects

HRESULT CBandCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CBandCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	GUID guidNode;

	pINode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_BandRefNode ) )
	{
		CBandRef* pBandRef = (CBandRef *)pINode;
		ASSERT( pBandRef->m_pBand != NULL );
		pThis->m_pBand = pBandRef->m_pBand;
	}
	else
	{
		pThis->m_pBand = (CBand *)pINode;
	}
	
	pThis->m_pBand->AddRef();
	pThis->m_pComponent = (CBandComponent*)pThis->m_pBand->m_pComponent;
	pThis->m_pComponent->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::OnInitMenuFilePrint

HRESULT CBandCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CBandCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::OnFilePrint

HRESULT CBandCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CBandCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CBandCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CBandCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::OnFilePrintPreview

HRESULT CBandCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CBandCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::OnViewProperties

HRESULT CBandCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CBandCtrl, Editor )
	ASSERT( theApp.m_pIFramework != NULL );
	HRESULT hr = E_FAIL;

	if(pThis->m_pBand)
	{
		// Show the pchannel property page if a pchannel is selected
		// Otherwise show the band's property page
		if(pThis->m_pBandDlg != NULL && pThis->m_pBand->GetNumberOfSelectedInstruments() > 0)
		{
			hr = S_OK;
			pThis->m_pBandDlg->RefreshPChannelPropertyPage();
		}
		else
		{
			hr = S_OK;
			pThis->m_pBand->OnViewProperties();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XEditor::OnF1Help

HRESULT CBandCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CBandCtrl, Editor )

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/BandEditorWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CBandCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CBandCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( fActivate
	&&	pThis->m_fDocWindowActive )
	{
		pThis->m_pBand->Activate();
	}
	
	if(pThis->m_pBandDlg)
	{
		if(fActivate)
		{
			pThis->m_pBandDlg->m_PChannelList.SetFocus();
			if(pThis->m_pBandDlg->IsMidiRegistered() == false)
			{
				pThis->m_pBandDlg->RegisterMidi();
			}
		}
		else
		{
			pThis->m_pBandDlg->UnRegisterMidi();
		}
	}

	pThis->m_fFrameActive = fActivate ? true : false;

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( fActivate
	&&	pThis->m_fFrameActive )
	{
		pThis->m_pBand->Activate();
	}

	if(pThis->m_pBandDlg)
	{
		if( fActivate )
		{
			CInstrumentListItem::m_CommonPropertyObject.SetBandDialog(pThis->m_pBandDlg);
			pThis->m_pBandDlg->m_PChannelList.SetFocus();
			pThis->m_pBandDlg->RegisterMidi();
		}
		else
		{
			CInstrumentListItem::m_CommonPropertyObject.SetBandDialog(NULL);
			pThis->m_pBandDlg->UnRegisterMidi();
		}
	}

	if( fActivate )
	{
		pThis->m_pBand->OnViewProperties();
	}

	pThis->m_fDocWindowActive = fActivate ? true : false;

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::XMyOleInPlaceObject implementation

STDMETHODIMP_(ULONG) CBandCtrl::XMyOleInPlaceObject::AddRef()
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.AddRef();
}

STDMETHODIMP_(ULONG) CBandCtrl::XMyOleInPlaceObject::Release()
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.Release();
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.GetWindow( lphwnd );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceObject::InPlaceDeactivate()
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	// Need to do this here instead of in OnDestroy, because OnDocWindowActivate() is called for
	// the newly active window (which may be another Band control) before our OnDestroy
	// method is called.
	if(pThis->m_pBandDlg)
	{
		CInstrumentListItem::m_CommonPropertyObject.SetBandDialog(NULL);
	}

	return pThis->m_xOleInPlaceObject.InPlaceDeactivate();
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceObject::UIDeactivate()
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.UIDeactivate();
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceObject::SetObjectRects( LPCRECT lprcPosRect, LPCRECT lprcClipRect )
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.SetObjectRects( lprcPosRect, lprcClipRect );
}

STDMETHODIMP CBandCtrl::XMyOleInPlaceObject::ReactivateAndUndo()
{
	METHOD_MANAGE_STATE( CBandCtrl, MyOleInPlaceObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceObject.ReactivateAndUndo();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnDraw - Drawing function

void CBandCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// TODO: Replace the following code with your own drawing code.
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::DoPropExchange - Persistence support

void CBandCtrl::DoPropExchange(CPropExchange* pPX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnResetState - Reset control to default state

void CBandCtrl::OnResetState()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::AboutBox - Display an "About" box to the user

void CBandCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CBandAboutBox dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnCreate

int CBandCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pBand != NULL );

	if( COleControl::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Cut down on flicker when redrawing Band editor
	ModifyStyle( 0, WS_CLIPCHILDREN, 0 );
	CWnd* pWndParent = GetParent();
	if( pWndParent )
	{
		pWndParent->ModifyStyle( 0, WS_CLIPCHILDREN, 0 );
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_BAND_EDITOR) );

	// Create control's toolbar
//	CWnd* pWndParent = CWnd::FromHandle( m_hWndContainer );
//	if( pWndParent )
//	{
//		m_pToolBar = new CToolBar;
//		m_pToolBar->Create( pWndParent );
//		m_pToolBar->LoadToolBar( IDR_BAND_EDITOR );
//		m_pToolBar->SetBarStyle( m_pToolBar->GetBarStyle() | CBRS_SIZE_DYNAMIC );
//		m_pToolBar->SetOwner( this );
//	}
	
	// Create control's dialog
	m_pBandDlg = new CBandDlg();
	if( m_pBandDlg == NULL )
	{
		return -1;
	}

	m_pBandDlg->m_pBandCtrl = this;

	if( 0 == m_pBandDlg->Create( NULL, "WindowName", WS_CHILD | WS_VISIBLE, CRect( 0, 0, 800, 400 ), this, 888, NULL ) )
	{
		return -1;
	}

	m_pBand->m_pBandCtrl = this;
	m_pBandDlg->OnInitialUpdate();

	m_fFrameActive = true;
	m_fDocWindowActive = true;
	m_pBand->Activate();
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnDestroy

void CBandCtrl::OnDestroy() 
{
	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}
	
	if( m_pToolBar )
	{
		delete m_pToolBar;	
		m_pToolBar = NULL;
	}

	ASSERT( m_pBand != NULL );

	m_pBand->m_pBandCtrl = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnGetInPlaceMenu

HMENU CBandCtrl::OnGetInPlaceMenu() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnEditProperties

void CBandCtrl::OnEditProperties() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CRect rectControl;
	GetRectInContainer( rectControl );

	MSG msg;
	ZeroMemory( &msg, sizeof(MSG) );

	msg.hwnd = this->GetSafeHwnd();
	msg.message = WM_MYPROPVERB;

	m_xOleObject.DoVerb( OLEIVERB_PROPERTIES,
						 &msg, m_pClientSite, 0L, m_hWndContainer, rectControl );
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnHideToolBars

void CBandCtrl::OnHideToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pBand != NULL );
	ASSERT( m_pBand->m_pComponent != NULL );

	m_pBand->m_pComponent->m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );
	m_hKeyStatusBar = NULL;

	if( m_pToolBar )
	{
		BORDERWIDTHS border;

		border.top = 0;
		border.left = 0;
		border.right = 0;
		border.bottom = 0;

		if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
		{
			m_pInPlaceFrame->SetBorderSpace( &border );
			m_pToolBar->ShowWindow( SW_HIDE );
			return;
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnShowToolBars

void CBandCtrl::OnShowToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BORDERWIDTHS border;
	CRect rectBorder;

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	ASSERT( m_pBand != NULL );
	ASSERT( m_pBand->m_pComponent != NULL );

	// Create status bar panes if they don't already exist
	if( m_hKeyStatusBar == NULL )
	{
		m_pBand->m_pComponent->m_pIFramework->SetNbrStatusBarPanes( 1, SBLS_EDITOR, &m_hKeyStatusBar );
		m_pBand->m_pComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 15 );
	}

	// Show the ToolBar
	if( m_pToolBar )
	{
		if( SUCCEEDED ( m_pInPlaceFrame->GetBorder(&rectBorder) ) )
		{
			border.top = TOOLBAR_HEIGHT;
			border.left = 0;
			border.right = 0;
			border.bottom = 0;

			if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
			{
				m_pInPlaceFrame->SetBorderSpace( &border );

				m_pToolBar->MoveWindow( rectBorder.left,
										rectBorder.top,
										rectBorder.Width(),
										TOOLBAR_HEIGHT );
				m_pToolBar->ShowWindow( SW_SHOWNORMAL );
				return;
			}
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CBandCtrl::OnSize

void CBandCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnSize(nType, cx, cy);
	
	m_pBandDlg->MoveWindow( 0, 0, cx, cy );
}

void CBandCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IPersistStream *pIPStream;

	m_pBand->QueryInterface( IID_IPersistStream, (void **) &pIPStream );
	if( pIPStream )
	{
		m_pBand->m_bInUndoRedo = true;
		m_pBandDlg->m_pBandDo->Undo( pIPStream );
		m_pBand->m_bInUndoRedo = false;
		pIPStream->Release();
	}

	// Update display
	m_pBandDlg->RefreshDisplay();

	// Notify DocRoot that Band has changed
	IDMUSProdNode* pIDocRootNode;

	if( SUCCEEDED ( m_pBand->GetDocRootNode(&pIDocRootNode) ) )
	{
		if( pIDocRootNode != (IDMUSProdNode *)m_pBand )
		{
			IDMUSProdNotifySink* pINotifySink;

			if( SUCCEEDED ( pIDocRootNode->QueryInterface(IID_IDMUSProdNotifySink, (void**)&pINotifySink) ) )
			{
				// Ask DocRoot if change should be sent
				if( pINotifySink->OnUpdate( m_pBand, GUID_BAND_ChangeNotifyMsg, NULL ) == S_OK )
				{
					m_pBand->SendBand();
				}

				pINotifySink->Release();
			}
		}

		pIDocRootNode->Release();
	}

    // Saving clears this, but we are still dirty
    m_pBand->SetModifiedFlag( TRUE );

	if(m_pBandDlg)
		m_pBandDlg->SetFocus();
}

void CBandCtrl::OnUpdateEditUndo(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;
	
	TCHAR achText[256];

	ASSERT( m_pBandDlg->m_pBandDo != NULL );

	if( m_pBandDlg->m_pBandDo )
	{
		if( m_pBandDlg->m_pBandDo->GetUndo(achText, 256) )
		{
			if( *achText )
			{
				strUndo += " ";
				strUndo += achText;
			}

			fEnable = TRUE;
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}

void CBandCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IPersistStream *pIPStream;

	m_pBand->QueryInterface( IID_IPersistStream, (void **) &pIPStream );
	if( pIPStream )
	{
		m_pBand->m_bInUndoRedo = true;
		m_pBandDlg->m_pBandDo->Redo( pIPStream );
		m_pBand->m_bInUndoRedo = false;
		pIPStream->Release();
	}

	// Update display
	m_pBandDlg->RefreshDisplay();

	// Notify DocRoot that Band has changed
	IDMUSProdNode* pIDocRootNode;

	if( SUCCEEDED ( m_pBand->GetDocRootNode(&pIDocRootNode) ) )
	{
		if( pIDocRootNode != (IDMUSProdNode *)m_pBand )
		{
			IDMUSProdNotifySink* pINotifySink;

			if( SUCCEEDED ( pIDocRootNode->QueryInterface(IID_IDMUSProdNotifySink, (void**)&pINotifySink) ) )
			{
				// Ask DocRoot if change should be sent
				if( pINotifySink->OnUpdate( m_pBand, GUID_BAND_ChangeNotifyMsg, NULL ) == S_OK )
				{
					m_pBand->SendBand();
				}

				pINotifySink->Release();
			}
		}

		pIDocRootNode->Release();
	}

    // Saving clears this, but we are still dirty
    m_pBand->SetModifiedFlag( TRUE );

	if(m_pBandDlg)
		m_pBandDlg->SetFocus();
}

void CBandCtrl::OnUpdateEditRedo(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;
	
	TCHAR achText[256];

	ASSERT( m_pBandDlg->m_pBandDo != NULL );

	if( m_pBandDlg->m_pBandDo )
	{
		if( m_pBandDlg->m_pBandDo->GetRedo(achText, 256) )
		{
			if( *achText )
			{
				strRedo += " ";
				strRedo += achText;
			}

			fEnable = TRUE;
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}

void CBandCtrl::OnSetFocus(CWnd* pOldWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnSetFocus(pOldWnd);

	IDMUSProdTransport* pITransport;

	if( SUCCEEDED ( m_pBand->m_pIDocRootNode->QueryInterface( IID_IDMUSProdTransport, (void **)&pITransport ) ) )
	{
		m_pBand->m_pComponent->m_pIConductor->SetActiveTransport( pITransport, 0 );
		//m_pBand->Send();To Do: use args

		pITransport->Release();
	}
}

BOOL CBandCtrl::PreTranslateMessage( MSG* pMsg ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case 0x59:	// VK_Y		(Redo)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditRedo();
						return TRUE;
					}
					break;

				case 0x5A:	// VK_Z		(Undo)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditUndo();
						return TRUE;
					}
					break;
			}
			break;
	}

	return COleControl::PreTranslateMessage( pMsg );
}

void CBandCtrl::OnHelpFinder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}

void CBandCtrl::OnUpdateEditSelectAll(CCmdUI* pCmdUI) 
{
	if(m_pBandDlg == NULL)
	{
		pCmdUI->Enable( false );
	}
	else
	{
		pCmdUI->Enable( true );
	}
}

void CBandCtrl::OnEditSelectAll() 
{
	if(m_pBandDlg)
	{
		m_pBandDlg->SelectAllPChannels();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandDocType.cpp ===
// BandDocType.cpp : implementation file
//

#include "stdafx.h"

#include "BandEditorDLL.h"
#include "Band.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBandDocType constructor/destructor

CBandDocType::CBandDocType()
{
    ASSERT( 1 );
}

CBandDocType::CBandDocType( CBandComponent* pComponent )
{
	ASSERT( pComponent != NULL );

    m_dwRef = 0;

	m_pComponent = pComponent;
//  m_pComponent->AddRef() intentionally missing
}

CBandDocType::~CBandDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType IUnknown implementation

HRESULT CBandDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CBandDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CBandDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CBandDocType::GetResourceId

HRESULT CBandDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_BAND_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::DoesExtensionMatch

HRESULT CBandDocType::DoesExtensionMatch( BSTR bstrExt )
{
#ifndef DMP_XBOX
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_BAND_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}
#endif

	return S_FALSE;
}
/*HRESULT CBandDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt;
	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	strExt = bstrExt;
	::SysFreeString( bstrExt );

	if( ::LoadString(theApp.m_hInstance, IDR_BAND_DOCTYPE, achBuffer, MID_BUFFER) )
	{
		if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
		{
			strExt.MakeUpper();
			strDocTypeExt.MakeUpper();

			if( _tcscmp( strDocTypeExt, strExt ) == 0 )
			{
				return S_OK;
			}
			else
			{
				return S_FALSE;
			}
		}
	}

	return E_FAIL;
}*/


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::DoesIdMatch

HRESULT CBandDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_BandNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::AllocNode

HRESULT STDMETHODCALLTYPE CBandDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_BandNode) == FALSE )
	{
		return E_INVALIDARG ;
	}

	// Create a new Band
	CBand* pBand = new CBand( m_pComponent );
	if( pBand == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppINode = (IDMUSProdNode *)pBand;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::OnFileNew

HRESULT CBandDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
								 IDMUSProdNode** ppIDocRootNode )
{
#ifndef DMP_XBOX
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIBandNode;

	HRESULT hr = E_FAIL;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Band 
	hr = AllocNode( GUID_BandNode, &pIBandNode );
	if( SUCCEEDED ( hr ) )
	{
		CBand* pBand = (CBand *)pIBandNode;

		// Set the Band's name
		TCHAR achName[SMALL_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_BAND_TEXT, achName, SMALL_BUFFER );
		pBand->m_csName.Format( "%s%d", achName, ++m_pComponent->m_nNextBand );

		// Set root and parent node of ALL children
		theApp.SetNodePointers( pIBandNode, pIBandNode, NULL );

		// Add node to Project Tree
		hr = m_pComponent->m_pIFramework->AddNode(pIBandNode, NULL);
		if( SUCCEEDED( hr ) )
		{
			m_pComponent->AddToBandFileList( (CBand *)pIBandNode );
			*ppIDocRootNode = pIBandNode;
			((CBand *)pIBandNode)->m_fDirty = TRUE;
			hr = S_OK;
		}
		else
		{
			pIBandNode->Release();
		}
	}

	return hr;
#else
	return E_NOTIMPL;
#endif
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::OnFileOpen

HRESULT CBandDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
								  IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
#ifndef DMP_XBOX
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pINode;
	HRESULT hr = E_FAIL;

	ASSERT( pIStream != NULL );
	ASSERT( m_pComponent != NULL );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( SUCCEEDED ( m_pComponent->LoadRIFFChunk( pIStream, &pINode ) ) )
	{
		// Insert a node into the Project Tree
		theApp.SetNodePointers( pINode, pINode, NULL );

		// Add node to Project Tree
		hr = m_pComponent->m_pIFramework->AddNode(pINode, NULL);
		if( SUCCEEDED( hr ) )
		{
			m_pComponent->AddToBandFileList( (CBand *)pINode );
			*ppIDocRootNode = pINode;
		}
		else {
			pINode->Release();
		}
	}
	return hr;
#else
	return E_NOTIMPL;
#endif
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::IsFileTypeExtension

HRESULT CBandDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
#ifndef DMP_XBOX
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".bnp") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".bnd") )
			{
				return S_OK;
			}
			break;
	}
#endif

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType IDMUSProdDocType::OnFileSave

HRESULT CBandDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType IDMUSProdDocType::GetListInfo

HRESULT CBandDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Create temporary container object to retrieve list info
	CBand* pBand = new CBand( m_pComponent );
	if( pBand )
	{
		hr = pBand->ReadListInfoFromStream( pIStream, pListInfo );

		RELEASE( pBand );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::GetObjectDescriptorFromNode

HRESULT CBandDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Band Node
	CBand* pBand;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_BandNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pBand = (CBand *)pIDocRootNode;

	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | D