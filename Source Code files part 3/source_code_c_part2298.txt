8",     X_D3DFMT_A8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8R8G8B8",     X_D3DFMT_X8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_A8B8G8R8",     X_D3DFMT_A8B8G8R8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_B8G8R8A8",     X_D3DFMT_B8G8R8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_R8G8B8A8",     X_D3DFMT_R8G8B8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8L8V8U8",     X_D3DFMT_X8L8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_Q8W8V8U8",     X_D3DFMT_Q8W8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_V16U16",       X_D3DFMT_V16U16,        FMT_SWIZZLED,   0    },
    { "D3DFMT_A4R4G4B4",     X_D3DFMT_A4R4G4B4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_R4G4B4A4",     X_D3DFMT_R4G4B4A4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_X1R5G5B5",     X_D3DFMT_X1R5G5B5,      FMT_SWIZZLED,   0    },
    { "D3DFMT_A1R5G5B5",     X_D3DFMT_A1R5G5B5,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G5B5A1",     X_D3DFMT_R5G5B5A1,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G6B5",       X_D3DFMT_R5G6B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R6G5B5",       X_D3DFMT_R6G5B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_L6V5U5",       X_D3DFMT_L6V5U5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R8B8",         X_D3DFMT_R8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_G8B8",         X_D3DFMT_G8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_V8U8",         X_D3DFMT_V8U8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_A8L8",         X_D3DFMT_A8L8,          FMT_SWIZZLED,   8    },
    { "D3DFMT_AL8",          X_D3DFMT_AL8,           FMT_SWIZZLED,   8    },
    { "D3DFMT_A8",           X_D3DFMT_A8,            FMT_SWIZZLED,   8    },
    { "D3DFMT_L8",           X_D3DFMT_L8,            FMT_SWIZZLED,   0    },
//  { "D3DFMT_P8",           X_D3DFMT_P8,            FMT_SWIZZLED,   8    }, // Bundler doesn't support (yet)
    { "D3DFMT_L16",          X_D3DFMT_L16,           FMT_SWIZZLED,   0    },
    { "D3DFMT_DXT1",         X_D3DFMT_DXT1,          FMT_COMPRESSED, 1    },
    { "D3DFMT_DXT2",         X_D3DFMT_DXT2,          FMT_COMPRESSED, 8    },
    { "D3DFMT_DXT3",         X_D3DFMT_DXT3,          FMT_COMPRESSED, 8    },
    { "D3DFMT_DXT4",         X_D3DFMT_DXT4,          FMT_COMPRESSED, 8    },
    { "D3DFMT_DXT5",         X_D3DFMT_DXT5,          FMT_COMPRESSED, 8    },
    { "D3DFMT_LIN_A8B8G8R8", X_D3DFMT_LIN_A8B8G8R8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_A8R8G8B8", X_D3DFMT_LIN_A8R8G8B8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_B8G8R8A8", X_D3DFMT_LIN_B8G8R8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_R8G8B8A8", X_D3DFMT_LIN_R8G8B8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_X8R8G8B8", X_D3DFMT_LIN_X8R8G8B8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_X8L8V8U8", X_D3DFMT_LIN_X8L8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_Q8W8V8U8", X_D3DFMT_LIN_Q8W8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_V16U16",   X_D3DFMT_LIN_V16U16,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A4R4G4B4", X_D3DFMT_LIN_A4R4G4B4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_R4G4B4A4", X_D3DFMT_LIN_R4G4B4A4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_A1R5G5B5", X_D3DFMT_LIN_A1R5G5B5,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_R5G5B5A1", X_D3DFMT_LIN_R5G5B5A1,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_X1R5G5B5", X_D3DFMT_LIN_X1R5G5B5,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R5G6B5",   X_D3DFMT_LIN_R5G6B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R6G5B5",   X_D3DFMT_LIN_R6G5B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L6V5U5",   X_D3DFMT_LIN_L6V5U5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_G8B8",     X_D3DFMT_LIN_G8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R8B8",     X_D3DFMT_LIN_R8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8L8",     X_D3DFMT_LIN_A8L8,      FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_V8U8",     X_D3DFMT_LIN_V8U8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_AL8",      X_D3DFMT_LIN_AL8,       FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_L16",      X_D3DFMT_LIN_L16,       FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L8",       X_D3DFMT_LIN_L8,        FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8",       X_D3DFMT_LIN_A8,        FMT_LINEAR    , 8    },
};



//-----------------------------------------------------------------------------
// Name: ConvertTextureFormat()
// Desc: 
// TODO: Make this handle the pitch requirements of small textures
//-----------------------------------------------------------------------------
HRESULT ConvertTextureFormat( VOID* pSrcData, 
                              DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, 
                              VOID* pDstData, DWORD dwDstFormat )
{
    // Create convenient access ptrs
    DWORD* pSrcData32 = (DWORD*)pSrcData;
    BYTE*  pDstData8  =  (BYTE*)pDstData;
    WORD*  pDstData16 =  (WORD*)pDstData;
    DWORD* pDstData32 = (DWORD*)pDstData;

    // Look through all pixels
    for( DWORD z=0; z<dwDepth; z++ )
    {
        for( DWORD y=0; y<dwHeight; y++ )
        {
            for( DWORD x=0; x<dwWidth; x++ )
            {
                // Read src pixel
                FLOAT a = (((*pSrcData32)&0xff000000)>>24L)/255.0f;
                FLOAT r = (((*pSrcData32)&0x00ff0000)>>16L)/255.0f;
                FLOAT g = (((*pSrcData32)&0x0000ff00)>> 8L)/255.0f;
                FLOAT b = (((*pSrcData32)&0x000000ff)>> 0L)/255.0f;
                pSrcData32++;

                // Assign values to non-ARGB channels
                FLOAT q = a;
                FLOAT w = r;
                FLOAT v = g;
                FLOAT u = b;
                FLOAT l = (r+g+b)/3;

                // Write dst pixel
                switch( dwDstFormat )
                {
                    case X_D3DFMT_A8R8G8B8:     // case X_D3DFMT_Q8W8V8U8:
                    case X_D3DFMT_LIN_A8R8G8B8: // case X_D3DFMT_LIN_Q8W8V8U8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_X8R8G8B8:     // case X_D3DFMT_X8L8V8U8:
                    case X_D3DFMT_LIN_X8R8G8B8: // case X_D3DFMT_LIN_X8L8V8U8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8B8G8R8:
                    case X_D3DFMT_LIN_A8B8G8R8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(b*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(r*0xff))<< 0L);
                        break;
                    case X_D3DFMT_B8G8R8A8:
                    case X_D3DFMT_LIN_B8G8R8A8:
                        (*pDstData32++) = (((DWORD)(b*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(r*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_R8G8B8A8:
                    case X_D3DFMT_LIN_R8G8B8A8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(b*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A1R5G5B5:
                    case X_D3DFMT_LIN_A1R5G5B5:
                        (*pDstData16++) = (((WORD)(a*0x01))<<15L) | 
                                          (((WORD)(r*0x1f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_X1R5G5B5:
                    case X_D3DFMT_LIN_X1R5G5B5:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_R5G5B5A1:
                    case X_D3DFMT_LIN_R5G5B5A1:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<11L) | 
                                          (((WORD)(g*0x1f))<< 6L) | 
                                          (((WORD)(b*0x1f))<< 1L) | 
                                          (((WORD)(a*0x01))<< 0L);
                        break;
                    case X_D3DFMT_R5G6B5:
                    case X_D3DFMT_LIN_R5G6B5:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<11L) | 
                                          (((WORD)(g*0x3f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_R6G5B5:     // case X_D3DFMT_L6V5U5:
                    case X_D3DFMT_LIN_R6G5B5: // case X_D3DFMT_LIN_L6V5U5:
                        (*pDstData16++) = (((WORD)(r*0x3f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_A4R4G4B4:
                    case X_D3DFMT_LIN_A4R4G4B4:
                        (*pDstData16++) = (((WORD)(a*0x0f))<<12L) | 
                                          (((WORD)(r*0x0f))<< 8L) | 
                                          (((WORD)(g*0x0f))<< 4L) | 
                                          (((WORD)(b*0x0f))<< 0L);
                        break;
                    case X_D3DFMT_R4G4B4A4:
                    case X_D3DFMT_LIN_R4G4B4A4:
                        (*pDstData16++) = (((WORD)(r*0x0f))<<12L) | 
                                          (((WORD)(g*0x0f))<< 8L) | 
                                          (((WORD)(b*0x0f))<< 4L) | 
                                          (((WORD)(a*0x0f))<< 0L);
                        break;
                    case X_D3DFMT_R8B8:
                    case X_D3DFMT_LIN_R8B8:
                        (*pDstData16++) = (((WORD)(r*0xff))<< 8L) | 
                                          (((WORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_G8B8:     // case X_D3DFMT_V8U8:
                    case X_D3DFMT_LIN_G8B8: // case X_D3DFMT_LIN_V8U8:
                        (*pDstData16++) = (((WORD)(g*0xff))<< 8L) | 
                                          (((WORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8L8:
                    case X_D3DFMT_LIN_A8L8:
                        (*pDstData16++) = (((WORD)(a*0xff))<< 8L) | 
                                          (((WORD)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_L16:
                    case X_D3DFMT_LIN_L16:
                        (*pDstData16++) = (((WORD)(l*0xffff))<< 0L);
                        break;
                    case X_D3DFMT_L8:
                    case X_D3DFMT_LIN_L8:
                        (*pDstData8++)  = (((BYTE)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8:
                    case X_D3DFMT_LIN_A8:
                        (*pDstData8++)  = (((BYTE)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_AL8:
                    case X_D3DFMT_LIN_AL8:
                        (*pDstData8++)  = (((BYTE)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_V16U16:
                    case X_D3DFMT_LIN_V16U16:
                        (*pDstData32++) = (((DWORD)(v*0xffff))<<16L) | 
                                          (((DWORD)(u*0xffff))<< 0L);
                        break;
                }
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CBaseTexture()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CBaseTexture::CBaseTexture( CBundler * pBundler )
{
    m_nFormat      = -1;
    m_strFormat[0] = 0;
    m_dwFilter     = D3DX_FILTER_TRIANGLE;
    m_dwLevels     = 1;
    m_pBundler     = pBundler;
}




//-----------------------------------------------------------------------------
// Name: ~CBaseTexture()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CBaseTexture::~CBaseTexture()
{
}




//-----------------------------------------------------------------------------
// Name: FormatFromString()
// Desc: Returns an index into the format spec array corresponding to the
//       given string
//-----------------------------------------------------------------------------
int CBaseTexture::FormatFromString( char* strFormat )
{
    if( strFormat[0] == 0 )
        return 0;

    DWORD dwNumFormats = sizeof(g_TextureFormats) / sizeof(g_TextureFormats[0]);

    for( DWORD i = 0; i < dwNumFormats; i++ )
    {
        if( !lstrcmpi( strFormat, g_TextureFormats[i].strFormat ) )
            return i;
    }

    return -2;
}




//-----------------------------------------------------------------------------
// Name: FormatFromString()
// Desc: Returns an index into the format spec array corresponding to the
//       given string
//-----------------------------------------------------------------------------
int CBaseTexture::FormatFromPCFormat( D3DFORMAT d3dFormat )
{
    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8: return FormatFromString( "D3DFMT_A8R8G8B8" );
        case D3DFMT_X8R8G8B8: return FormatFromString( "D3DFMT_X8R8G8B8" );
//      case D3DFMT_A8B8G8R8: return FormatFromString( "D3DFMT_A8B8G8R8" );
//      case D3DFMT_B8G8R8A8: return FormatFromString( "D3DFMT_B8G8R8A8" );
//      case D3DFMT_R8G8B8A8: return FormatFromString( "D3DFMT_R8G8B8A8" );
        case D3DFMT_X8L8V8U8: return FormatFromString( "D3DFMT_X8L8V8U8" );
        case D3DFMT_Q8W8V8U8: return FormatFromString( "D3DFMT_Q8W8V8U8" );
        case D3DFMT_V16U16:   return FormatFromString( "D3DFMT_V16U16" );
        case D3DFMT_A4R4G4B4: return FormatFromString( "D3DFMT_A4R4G4B4" );
//      case D3DFMT_R4G4B4A4: return FormatFromString( "D3DFMT_R4G4B4A4" );
        case D3DFMT_X1R5G5B5: return FormatFromString( "D3DFMT_X1R5G5B5" );
        case D3DFMT_A1R5G5B5: return FormatFromString( "D3DFMT_A1R5G5B5" );
//      case D3DFMT_R5G5B5A1: return FormatFromString( "D3DFMT_R5G5B5A1" );
        case D3DFMT_R5G6B5:   return FormatFromString( "D3DFMT_R5G6B5" );
//      case D3DFMT_R6G5B5:   return FormatFromString( "D3DFMT_R6G5B5" );
        case D3DFMT_L6V5U5:   return FormatFromString( "D3DFMT_L6V5U5" );
//      case D3DFMT_R8B8:     return FormatFromString( "D3DFMT_R8B8" );
//      case D3DFMT_G8B8:     return FormatFromString( "D3DFMT_G8B8" );
        case D3DFMT_V8U8:     return FormatFromString( "D3DFMT_V8U8" );
        case D3DFMT_A8L8:     return FormatFromString( "D3DFMT_A8L8" );
//      case D3DFMT_AL8:      return FormatFromString( "D3DFMT_AL8" );
        case D3DFMT_A8:       return FormatFromString( "D3DFMT_A8" );
        case D3DFMT_L8:       return FormatFromString( "D3DFMT_L8" );
//      case D3DFMT_A8R8G8B8: return FormatFromString( "D3DFMT_P8" );
//      case D3DFMT_L16:      return FormatFromString( "D3DFMT_L16" );
        case D3DFMT_DXT1:     return FormatFromString( "D3DFMT_DXT1" );
        case D3DFMT_DXT2:     return FormatFromString( "D3DFMT_DXT2" );
//      case D3DFMT_DXT3:     return FormatFromString( "D3DFMT_DXT3" );
        case D3DFMT_DXT4:     return FormatFromString( "D3DFMT_DXT4" );
//      case D3DFMT_DXT5:     return FormatFromString( "D3DFMT_DXT5" );
    }

    return -2;
}




//-----------------------------------------------------------------------------
// Name: LoadImage()
// Desc: Loads source and alphasource surfaces
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::LoadImage( CHAR* strSource, CHAR* strAlphaSource, CImage** ppImage )
{
    CImage             ColorImage;
    CImage             AlphaImage;
    CImage*            pResizedColorImage = NULL;
    CImage*            pResizedAlphaImage = NULL;
    HRESULT hr; 

    // Add the path (if necessary) to the source filename
    CHAR strImageFilePath[MAX_PATH];
    if( strchr( strSource, ':' ) )
        strcpy( strImageFilePath, strSource );
    else
    {
        strcpy( strImageFilePath, m_pBundler->m_strPath );
        strcat( strImageFilePath, strSource );
    }

    // Load the texture from the source file
    hr = ColorImage.Load( strImageFilePath );
    if( FAILED( hr ) )
        return hr;

    // Depalettize any palettized images
    if( D3DFMT_P8 == ColorImage.m_Format )
        ColorImage.Depalettize();

    if( strAlphaSource[0] )
    {
        // Add the path (if necessary) to the source filename
        CHAR strImageFilePath[MAX_PATH];
        if( strchr( strSource, ':' ) )
            strcpy( strImageFilePath, strAlphaSource );
        else
        {
            strcpy( strImageFilePath, m_pBundler->m_strPath );
            strcat( strImageFilePath, strAlphaSource );
        }

        // Load the texture from the alpha source file
        hr = AlphaImage.Load( strImageFilePath );
        if( FAILED( hr ) )
            return hr;

        // Can't currently deal with palettized images
        if( D3DFMT_P8 == AlphaImage.m_Format )
            return E_FAIL;
    }

    // Determine final texture size
    DWORD dwWidth  = ColorImage.m_Width;
    DWORD dwHeight = ColorImage.m_Height;
    
    if( strAlphaSource[0] )
    {
        if( dwWidth  < AlphaImage.m_Width  )   dwWidth  = AlphaImage.m_Width;
        if( dwHeight < AlphaImage.m_Height )   dwHeight = AlphaImage.m_Height;
    }

    // Do the size conversion for the source image
    pResizedColorImage = new CImage( ColorImage.m_Width, ColorImage.m_Height, D3DFMT_A8R8G8B8 );
    hr = LoadImageFromImage( pResizedColorImage, &ColorImage, m_dwFilter );

    if( strAlphaSource[0] )
    {
        // Do the size conversion for the alpha source image
        pResizedAlphaImage = new CImage( AlphaImage.m_Width, AlphaImage.m_Height, AlphaImage.m_Format );
        hr = LoadImageFromImage( pResizedAlphaImage, &AlphaImage, m_dwFilter );
    }

    // Merge in the alpha channel
    if( strAlphaSource[0] )
    {
        DWORD* pColorBits = (DWORD*)pResizedColorImage->m_pData;
        DWORD* pAlphaBits = (DWORD*)pResizedAlphaImage->m_pData;

        for( DWORD yp = 0; yp < dwHeight; yp++ )
        {
            for( DWORD xp = 0; xp < dwWidth; xp++ )
            {
                DWORD dwAlpha = (*pAlphaBits) << 24;
                (*pColorBits) &= 0x00ffffff;
                (*pColorBits) |= dwAlpha;

                pColorBits++;
                pAlphaBits++;
            }
        }
    }
        
    // Return the surface in the output parameter
    (*ppImage) = pResizedColorImage;

    delete pResizedAlphaImage;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadImageUsingD3DX()
// Desc: Loads source and alphasource surfaces. This should be used after other
//       load attempts failed, since D3DX forces surfaces to have dimensions
//       that are a power of two.
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::LoadImageUsingD3DX( CHAR* strSource, CHAR* strAlphaSource, 
                                            CImage** ppImage )
{
    D3DSURFACE_DESC    ColorImageDesc;
    D3DSURFACE_DESC    AlphaImageDesc;
    LPDIRECT3DSURFACE8 pOrigColorSurface;
    LPDIRECT3DSURFACE8 pOrigAlphaSurface;
    LPDIRECT3DSURFACE8 pResizedColorSurface;
    LPDIRECT3DSURFACE8 pResizedAlphaSurface;
    HRESULT hr; 

    if( strAlphaSource[0] )
        printf( "WARNING: Couldn't load %s and/or %s natively - attempting to use D3D runtime.\n", strSource, strAlphaSource );
    else
        printf( "WARNING: Couldn't load %s natively - attempting to use D3D runtime.\n", strSource );

    hr = m_pBundler->InitD3D();
    if( FAILED( hr ) )
    {
        m_pBundler->ErrorMsg( "The bundler requires the D3D reference rasterizer in order\n" );
        m_pBundler->ErrorMsg( "to load certain types of files, but was unable to create it.\n" );
        m_pBundler->ErrorMsg( "Try using BMP or TGA files instead of DDS or JPG files.\n" );
        return hr;
    }

    // Add the path (if necessary) to the source filename
    CHAR strImageFilePath[MAX_PATH];
    if( strchr( strSource, ':' ) )
        strcpy( strImageFilePath, strSource );
    else
    {
        strcpy( strImageFilePath, m_pBundler->m_strPath );
        strcat( strImageFilePath, strSource );
    }


    // Load the texture from the source file
    LPDIRECT3DTEXTURE8 pImageTexture;
    hr = D3DXCreateTextureFromFileEx( m_pBundler->m_pd3ddev, strImageFilePath, 
                                      D3DX_DEFAULT, D3DX_DEFAULT, 1,
                                      0, D3DFMT_UNKNOWN, D3DPOOL_SYSTEMMEM,
                                      D3DX_DEFAULT, D3DX_DEFAULT, 0,
                                      NULL, NULL, &pImageTexture );
    if( FAILED( hr ) )
    {
        m_pBundler->ErrorMsg( "Couldn't load image <%s>\n", strSource );
        return hr;
    }

    // Get a surface for the image
    pImageTexture->GetSurfaceLevel( 0, &pOrigColorSurface );
    pImageTexture->Release();
    pOrigColorSurface->GetDesc( &ColorImageDesc );

    if( m_nFormat < 0 )
    {
        m_nFormat   = FormatFromPCFormat( ColorImageDesc.Format );
        if( m_nFormat < 0 )
        {
            m_pBundler->ErrorMsg( "Unssupported format for image <%s>\n", strSource );
            return E_FAIL;
        }
        lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );
    }

    if( strAlphaSource[0] )
    {
        // Add the path (if necessary) to the source filename
        CHAR strImageFilePath[MAX_PATH];
        if( strchr( strSource, ':' ) )
            strcpy( strImageFilePath, strAlphaSource );
        else
        {
            strcpy( strImageFilePath, m_pBundler->m_strPath );
            strcat( strImageFilePath, strAlphaSource );
        }

        // Load the texture from the alpha source file
        LPDIRECT3DTEXTURE8 pAlphaTexture;
        hr = D3DXCreateTextureFromFileEx( m_pBundler->m_pd3ddev, strImageFilePath, 
                                          D3DX_DEFAULT, D3DX_DEFAULT, 1,
                                          0, D3DFMT_UNKNOWN, D3DPOOL_DEFAULT,
                                          D3DX_DEFAULT, D3DX_DEFAULT, 0,
                                          NULL, NULL, &pAlphaTexture );
        if( FAILED( hr ) )
        {
            m_pBundler->ErrorMsg( "Couldn't load image <%s>\n", strAlphaSource );
            return hr;
        }

        pAlphaTexture->GetSurfaceLevel( 0, &pOrigAlphaSurface );
        pAlphaTexture->Release();
        pOrigAlphaSurface->GetDesc( &AlphaImageDesc );
    }

    // Determine final texture size
    DWORD dwWidth  = ColorImageDesc.Width;
    DWORD dwHeight = ColorImageDesc.Height;
    
    if( strAlphaSource[0] )
    {
        if( dwWidth  < AlphaImageDesc.Width  )   dwWidth  = AlphaImageDesc.Width;
        if( dwHeight < AlphaImageDesc.Height )   dwHeight = AlphaImageDesc.Height;
    }

    // Do the size conversion for the source image
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                    &pResizedColorSurface );

    hr = D3DXLoadSurfaceFromSurface( pResizedColorSurface, NULL, NULL, 
                                     pOrigColorSurface, NULL, NULL,
                                     m_dwFilter, 0 );

    if( strAlphaSource[0] )
    {
        // Do the size conversion for the alpha source image
        hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                        &pResizedAlphaSurface );

        hr = D3DXLoadSurfaceFromSurface( pResizedAlphaSurface, NULL, NULL, 
                                         pOrigAlphaSurface, NULL, NULL,
                                         m_dwFilter, 0 );
    }


    // Merge in the alpha channel
    if( strAlphaSource[0] )
    {
        D3DLOCKED_RECT lockColor;
        D3DLOCKED_RECT lockAlpha;
        hr = pResizedColorSurface->LockRect( &lockColor, NULL, 0 );
        hr = pResizedAlphaSurface->LockRect( &lockAlpha, NULL, 0 );

        DWORD* pColorBits = (DWORD*)lockColor.pBits;
        DWORD* pAlphaBits = (DWORD*)lockAlpha.pBits;

        for( DWORD yp = 0; yp < dwHeight; yp++ )
        {
            for( DWORD xp = 0; xp < dwWidth; xp++ )
            {
                DWORD dwAlpha = (*pAlphaBits) << 24;
                (*pColorBits) &= 0x00ffffff;
                (*pColorBits) |= dwAlpha;

                pColorBits++;
                pAlphaBits++;
            }
        }

        pResizedColorSurface->UnlockRect();
        pResizedAlphaSurface->UnlockRect();
    }

    
    // Copy everything over to the output CImage
    (*ppImage) = new CImage( dwWidth, dwHeight, D3DFMT_A8R8G8B8 );
    D3DLOCKED_RECT lr;
    pResizedColorSurface->LockRect( &lr, NULL, D3DLOCK_READONLY );
    memcpy( (*ppImage)->m_pData, lr.pBits, lr.Pitch * dwHeight );
    pResizedColorSurface->UnlockRect();

    // Release the color surfaces
    pOrigColorSurface->Release();
    pResizedColorSurface->Release();

    // Release the alpha surfaces
    if( strAlphaSource[0] )
    {
        pOrigAlphaSurface->Release();
        pResizedAlphaSurface->Release();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ResizeImage()
// Desc: Convert the surface to the new width, height, and format
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::ResizeImage( DWORD dwWidth, DWORD dwHeight, 
                                     CImage** ppImage )
{
    CImage* pOldImage = *ppImage;
    HRESULT hr; 

    *ppImage = new CImage( dwWidth, dwHeight, D3DFMT_A8R8G8B8 );

    hr = LoadImageFromImage( *ppImage, pOldImage, m_dwFilter );

    // Release the old surface
    delete pOldImage;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteSwizzledTextureData()
// Desc: Swizzles the texture data to NVidia's swizzled format.  
//       XGSwizzleRect requires that the memory being swizzled to is 16-byte
//       aligned.
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
                                              DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a sizzled texture
    // is Width * BytesPerTexel
    DWORD  dwBytesPerTexel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD  dwPitch         = dwWidth*dwBytesPerTexel;
    DWORD  dwTextureSize   = dwPitch * dwHeight * dwDepth;
    BYTE*  pBitsUnaligned  = new BYTE[ dwTextureSize + 16 ];
    int    temp      = (int)pBitsUnaligned;
    BYTE*  pBitsTemp = (BYTE*)(( temp + 15 ) & ~15);   // 16-byte aligned ptr.

    // Swizzle the data into a temporary buffer, and then copy it back
    XGSwizzleBox( pBits, 0, 0, NULL, pBitsTemp, dwWidth, dwHeight, dwDepth,
                  NULL, dwBytesPerTexel );

    if( FAILED( m_pBundler->WriteData( pBitsTemp, dwTextureSize ) ) )
        return 0;

    delete[] pBitsUnaligned;

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: WriteCompressedTextureData()
// Desc: Compresses the texture data
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteCompressedTextureData( VOID* pSrcBits, DWORD dwWidth, 
                                                DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a compressed texture
    // is Width*2 or Width*4, depending on the compression 
    DWORD dwBlockSize;
    DWORD dwCompressedSize;
//    DWORD dwSrcPitch   = (dwWidth*4+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD dwSrcPitch   = dwWidth*sizeof(DWORD);
    BOOL  bPreMultiply = g_TextureFormats[m_nFormat].strFormat[10] == '2' ||
                         g_TextureFormats[m_nFormat].strFormat[10] == '4';

    switch( g_TextureFormats[m_nFormat].dwXboxFormat )
    {
        case X_D3DFMT_DXT1: 
            dwBlockSize      = 8;
            dwCompressedSize = dwWidth*dwHeight/2; 
            break;
        case X_D3DFMT_DXT2:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        case X_D3DFMT_DXT4:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        default:
            return E_FAIL;
    }

    // Allocate space for the compressed data
    BYTE* pCompressedData = new BYTE[dwDepth*dwCompressedSize];
    BYTE* pDstBits        = pCompressedData;

    for( DWORD i=0; i<dwDepth; i++ )
    {
        // Compress the data
        if( FAILED( XGCompressRect( pDstBits,
                                    D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat),
                                    0, dwWidth, dwHeight, pSrcBits, 
                                    D3DFORMAT(X_D3DFMT_LIN_A8R8G8B8), 
                                    dwSrcPitch, 0.5,
                                    bPreMultiply ? XGCOMPRESS_PREMULTIPLY : 0 ) ) )
            return 0;

        pSrcBits = (BYTE*)pSrcBits + dwSrcPitch*dwHeight;
        pDstBits = (BYTE*)pDstBits + dwCompressedSize;
    }

    if( dwDepth == 1 )
    {
        // Write the compressed data
        if( FAILED( m_pBundler->WriteData( pCompressedData, dwCompressedSize ) ) )
            return 0;
    }
    else
    {
        // For volume textures, compressed blocks are stored in block linear
        // format, so we need to write them in the correct order.
        DWORD dwNumXBlocks = dwWidth/4;
        DWORD dwNumYBlocks = dwHeight/4;
        DWORD dwNumWBlocks = (dwDepth<4) ? 1 : dwDepth/4;

        for( DWORD w=0; w<dwDepth; w+=4 )
        {
            for( DWORD by=0; by<dwNumYBlocks; by++ )
            {
                for( DWORD bx=0; bx<dwNumXBlocks; bx++ )
                {
                    BYTE* pBits0 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+0)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits1 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+1)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits2 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+2)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits3 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+3)*dwNumXBlocks*dwNumYBlocks ) ];
    
                    // Write the compressed data
                    if( dwDepth >= 1 ) 
                        m_pBundler->WriteData( pBits0, dwBlockSize );
                    if( dwDepth >= 2 ) 
                        m_pBundler->WriteData( pBits1, dwBlockSize );
                    if( dwDepth >= 3 ) 
                        m_pBundler->WriteData( pBits2, dwBlockSize );
                    if( dwDepth >= 4 ) 
                        m_pBundler->WriteData( pBits3, dwBlockSize );
                }
            }
        }
    }

    // Cleanup
    delete[] pCompressedData;

    // Return the number of bytes written
    return dwDepth*dwCompressedSize;
}




//-----------------------------------------------------------------------------
// Name: WriteLinearTextureData()
// Desc: 
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
                                            DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a linear texture
    // needs to be a multiple of 64 bytes.
    DWORD dwBytesPerTexel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD dwPitch         = (dwWidth*dwBytesPerTexel+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD dwTextureSize   = dwPitch * dwHeight * dwDepth;

    // Write the texture
    if( dwPitch == dwWidth*dwBytesPerTexel )
    {
        if( FAILED( m_pBundler->WriteData( pBits, dwTextureSize ) ) )
            return 0;
    }
    else
    {
        // For textures with non-conforming pitches, write the data aligned
        // according to the pitch
        BYTE* pTempBits = (BYTE*)pBits;
        BYTE  pZeroes[64];
        ZeroMemory( pZeroes, 64 );
        
        for( DWORD z=0; z<dwDepth; z++ )
        {
            for( DWORD y=0; y<dwHeight; y++ )
            {
                // Write data
                if( FAILED( m_pBundler->WriteData( pTempBits, dwWidth*dwBytesPerTexel ) ) )
                    return 0;
                pTempBits += dwWidth*dwBytesPerTexel;

                // Pad to 64-bytes
                if( FAILED( m_pBundler->WriteData( pZeroes, dwPitch - dwWidth*dwBytesPerTexel ) ) )
                    return 0;
            }
        }
    }

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: SaveImage()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveImage( DWORD* pcbData, DWORD dwLevels, CImage* pImage )
{
    HRESULT hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    DWORD dwWidth = pImage->m_Width;
    DWORD dwHeight = pImage->m_Height;

    // Allocate memory for converting the surface format
    VOID* pSurfaceData = (VOID*)new BYTE[dwWidth*dwHeight*4];

    // Loop over each mipmap level of the texture
    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        CImage* pMipmap = new CImage( dwWidth, dwHeight, pImage->m_Format );
        hr = LoadImageFromImage( pMipmap, pImage, m_dwFilter );

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( pMipmap->m_pData, dwWidth, dwHeight, 1 );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( pMipmap->m_pData, dwWidth, dwHeight, 1,
                                  pSurfaceData, g_TextureFormats[m_nFormat].dwXboxFormat );

            if( g_TextureFormats[m_nFormat].Type == FMT_SWIZZLED )
            {
                // If we're writing a swizzled format, swizzle the texture data
                (*pcbData) += WriteSwizzledTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
            else
            {
                // Write out linear surface data
                (*pcbData) += WriteLinearTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
        }

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            dwWidth  = max( dwWidth, 4 );
            dwHeight = max( dwHeight, 4 );
        }
            
        // Release the mipmap level
    }

    // Cleanup
    delete[] pSurfaceData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveVolumeTexture()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, CVolume* pVolume )
{
    HRESULT        hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Get the surface desc, used to create mipmap levels
    DWORD dwWidth  = pVolume->m_Width;
    DWORD dwHeight = pVolume->m_Height;
    DWORD dwDepth  = pVolume->m_Depth;

    // Allocate memory for converting the surface format
    VOID* pVolumeData = (VOID*)new BYTE[dwWidth*dwHeight*dwDepth*4];

    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        CVolume* pTempVolume = new CVolume( dwWidth, dwHeight, dwDepth, pVolume->m_Format );

        LoadVolumeFromVolume( pTempVolume, pVolume, m_dwFilter );

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( pTempVolume->m_pData, dwWidth, 
                                                      dwHeight, dwDepth );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( pTempVolume->m_pData, dwWidth, dwHeight, dwDepth,
                                  pVolumeData, g_TextureFormats[m_nFormat].dwXboxFormat );

            // If we're writing a swizzled format, swizzle the texture data
            (*pcbData) += WriteSwizzledTextureData( pVolumeData, dwWidth, dwHeight, dwDepth );
        }

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;
        if( dwDepth >= 2 )
            dwDepth >>= 1;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            dwWidth  = max( dwWidth, 4 );
            dwHeight = max( dwHeight, 4 );
        }
            
        // Release the mipmap level
        delete pTempVolume;
    }

    // Cleanup
    delete[] pVolumeData;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\video\WMVPlayBack\WMVPlayBack.cpp ===
//-----------------------------------------------------------------------------
// File: WMVPlayBack.cpp
//
// Desc: Demonstrates how to use the WMVDecoder XMO to play streaming video
//
// Hist: 7.6.01 - New for September XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <wmvxmo.h>
#include <assert.h>

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\ndebug output" },
};

#define NUM_HELP_CALLOUTS 2

// Vertex definition for the screen-space quad
typedef struct {
    D3DXVECTOR4 p;
    D3DXVECTOR2 t;
} CUSTOMVERTEX;
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)

// Define audio packet params
#define NUM_PACKETS 48
#define PACKET_SIZE 4096

// Define a video frame structure:
typedef struct _VIDEOFRAME {
    struct _VIDEOFRAME *pNext;          // Next pending video frame
    LPDIRECT3DTEXTURE8  pTexture;       // Texture data
    REFERENCE_TIME      rtTimeStamp;    // Time stamp of video frame
    DWORD               dwSetAtVBlank;  // VBlank count at which frame was started
    BYTE *              pBits;          // Pointer to texture data
    DWORD               dwFrameNumber;  // Frame sequence number (debug)
} VIDEOFRAME;

// Number of video frames to buffer
#define NUM_FRAMES 8

// Maximum # of video frames to decode per frame
#define MAXDECODE_PER_FRAME 3

static DWORD g_dwVidFrame = 0;

// Set this to TRUE to render using the overlay
static const BOOL g_bOverlay = FALSE;

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    BOOL FindFreePacket( DWORD * pdwIndex );    // Find a free audio packet
    BOOL FindFreeFrame( VIDEOFRAME ** ppFrame );// Find a free video frame
    
    HRESULT ProcessVideoQueues();               // Processes our video queues

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;
    BOOL        m_bDrawHelp;

    BOOL        m_bDebugInfo;                   // Show video debug info?

    HRESULT         m_hrOpenFile;               // Result from creating decoder
    BOOL            m_bDecode;                  // Set to FALSE at end of video
    LPWMVDECODER    m_pWMVDecoder;              // WMV Decoder
    WMVVIDEOINFO    m_wmvVideoInfo;             // Video info
    REFERENCE_TIME  m_rtDuration;               // Duration of video
    WAVEFORMATEX    m_wfx;                      // Audio format

    DWORD                   m_adwStatus[NUM_PACKETS];   // Audio packet status
    BYTE *                  m_pbSampleData;             // Audio sample data
    LPDIRECTSOUNDSTREAM     m_pStream;                  // DirectSound Stream

    VIDEOFRAME              m_aVideoFrames[NUM_FRAMES]; // Video frames
    VIDEOFRAME *            m_pCurrentFrame;            // Frame to render
    LPDIRECT3DVERTEXBUFFER8 m_pvbQuad;                  // Quad for rendering video

    BOOL            m_bGotData;             // TRUE after we've gotten a packet
    LPDIRECTSOUND8  m_pDSound;              // DirectSound object
    REFERENCE_TIME  m_rtStartTime;          // Reference time at start
    REFERENCE_TIME  m_rtCurrentTime;        // Reference time of current frame
    REFERENCE_TIME  m_rtPreroll;            // Preroll time

    //-------------------------------------------------------------------------
    // Name: class CFrameQueue
    // Desc: Maintains a queue of video frames
    //-------------------------------------------------------------------------
    class CFrameQueue
    {
    public:
        VIDEOFRAME * m_pHead;
        VIDEOFRAME * m_pTail;

        CFrameQueue() { m_pHead = m_pTail = NULL; }
        BOOL IsEmpty() { return m_pHead == NULL; }
        void Enqueue( VIDEOFRAME * pFrame );
        VIDEOFRAME * Dequeue(); 
    };

    CFrameQueue m_fqFree;       // Free frames - these can be filled
    CFrameQueue m_fqBusy;       // Busy frames - possibly being rendered
    CFrameQueue m_fqReady;      // Ready frames - filled, and can be displayed
};


//-----------------------------------------------------------------------------
// Name: VBlankCallback
// Desc: Called every vblank, so we can mantain a count of vblanks
//-----------------------------------------------------------------------------
DWORD g_dwVBlankCount = 0;
void __cdecl VBlankCallback( D3DVBLANKDATA *pData )
{
    g_dwVBlankCount++;
}



//-----------------------------------------------------------------------------
// Name: FrameQueue::Enqueue
// Desc: Adds a frame to tail of queue
//-----------------------------------------------------------------------------
void
CXBoxSample::CFrameQueue::Enqueue( VIDEOFRAME * pFrame )
{ 
    pFrame->pNext = NULL;

    if( m_pTail ) 
    {
        m_pTail->pNext = pFrame;
        m_pTail = pFrame;
    }
    else
        m_pHead = m_pTail = pFrame;
}



//-----------------------------------------------------------------------------
// Name: FrameQueue::Dequeue
// Desc: Returns the head of the queue
//-----------------------------------------------------------------------------
VIDEOFRAME *
CXBoxSample::CFrameQueue::Dequeue()
{
    assert( m_pHead );
    VIDEOFRAME * pPacket = m_pHead;

    m_pHead = m_pHead->pNext;
    if( !m_pHead )
        m_pTail = NULL;

    pPacket->pNext = NULL;
    return pPacket;
}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_bDebugInfo = TRUE;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    m_bGotData = FALSE;
    m_bDecode = TRUE;

    // If we're using the overlay, enable it
    if( g_bOverlay )
        m_pd3dDevice->EnableOverlay( TRUE );

    // Initialize our timing values
    m_rtStartTime = 0;
    m_pCurrentFrame = NULL;
    m_pd3dDevice->SetVerticalBlankCallback( VBlankCallback );

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    DirectSoundCreate( NULL, &m_pDSound, NULL );

    // Create the video decoder.  We only load
    // the section containing the decoder on demand
    XLoadSection("WMVDEC");
    m_hrOpenFile = WmvCreateDecoder( "D:\\Media\\Videos\\bike.wmv",
                                     NULL,
                                     WMVVIDEOFORMAT_YUY2,
                                     NULL,
                                     &m_pWMVDecoder );

    // If that succeeded, set up for decoding:
    if( SUCCEEDED( m_hrOpenFile ) )
    {
        // Get info about audio and video
        m_pWMVDecoder->GetVideoInfo( &m_wmvVideoInfo );
        m_pWMVDecoder->GetAudioInfo( &m_wfx );
        m_pWMVDecoder->GetPlayDuration( &m_rtDuration, &m_rtPreroll );
        m_rtDuration -= m_rtPreroll;

        // Set up video frame buffers
        for( int i = 0; i < NUM_FRAMES; i++ )
        {
            // Create the texture
            m_pd3dDevice->CreateTexture(
                m_wmvVideoInfo.dwWidth,
                m_wmvVideoInfo.dwHeight,
                0,
                0,
                D3DFMT_YUY2,
                NULL,
                &m_aVideoFrames[i].pTexture );

            // Get a pointer to the texture data
            D3DLOCKED_RECT lr;
            m_aVideoFrames[i].pTexture->LockRect( 0, &lr, NULL, 0 );
            m_aVideoFrames[i].pBits = (BYTE *)lr.pBits;
            m_aVideoFrames[i].pTexture->UnlockRect( 0 );

            m_aVideoFrames[i].dwSetAtVBlank = 0;
            m_fqFree.Enqueue( &m_aVideoFrames[i] );
        }

        // Set up a stream for audio playback
        DSSTREAMDESC dssd = {0};
        dssd.dwFlags =  0;
        dssd.dwMaxAttachedPackets = NUM_PACKETS;
        dssd.lpwfxFormat = &m_wfx;

        DirectSoundCreateStream( &dssd, &m_pStream );

        // Allocate sample data
        m_pbSampleData = new BYTE[ NUM_PACKETS * PACKET_SIZE ];

        // Initialize audio packet status
        for( int i = 0; i < NUM_PACKETS; i++ )
            m_adwStatus[ i ] = XMEDIAPACKET_STATUS_SUCCESS;
    }

    if( !g_bOverlay )
    {
        // Create a vertex buffer for the quad
        FLOAT fLeft   = 320.0f - m_wmvVideoInfo.dwWidth / 2;
        FLOAT fRight  = fLeft + m_wmvVideoInfo.dwWidth;
        FLOAT fTop    = 240.0f - m_wmvVideoInfo.dwHeight / 2;
        FLOAT fBottom = fTop + m_wmvVideoInfo.dwHeight;

        m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ), 0, 0, 0, &m_pvbQuad );
        CUSTOMVERTEX * pVertices;
        m_pvbQuad->Lock( 0, 0, (BYTE **)&pVertices, 0 );
        pVertices[ 0 ].p = D3DXVECTOR4(  fLeft-0.5f,    fTop-0.5f, 1.0f, 1.0f ); pVertices[0].t = D3DXVECTOR2( 0.0f, 0.0f );
        pVertices[ 1 ].p = D3DXVECTOR4( fRight-0.5f,    fTop-0.5f, 1.0f, 1.0f ); pVertices[1].t = D3DXVECTOR2( (FLOAT)m_wmvVideoInfo.dwWidth, 0.0f );
        pVertices[ 2 ].p = D3DXVECTOR4( fRight-0.5f, fBottom-0.5f, 1.0f, 1.0f ); pVertices[2].t = D3DXVECTOR2( (FLOAT)m_wmvVideoInfo.dwWidth, (FLOAT)m_wmvVideoInfo.dwHeight );
        pVertices[ 3 ].p = D3DXVECTOR4(  fLeft-0.5f, fBottom-0.5f, 1.0f, 1.0f ); pVertices[3].t = D3DXVECTOR2( 0.0f, (FLOAT)m_wmvVideoInfo.dwHeight );
        m_pvbQuad->Unlock();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessVideoQueues()
// Desc: Processes our video queues:
//       1) Free up any busy frames that we know are no longer in use.
//          For overlay, we know a frame is no longer in use if we're at
//          least one VBlank after updating with the next frame.
//          For textures, we could have up to 3 frames in the pushbuffer,
//          so we know a frame is no longer in use if we're at least 3 VBlanks
//          after rendering the next frame
//       2) Discard any frames from the ready queue that are obsolete.  A
//          frame is obsolete if the frame after it is displayable.
//       3) Figure out if we need to render a new frame - that is, is there
//          a frame in the ready queue with a timestamp less than current time
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::ProcessVideoQueues()
{
    // Step 1: Move packets from busy->free if they're not being used.
    // The only time the busy queue should be empty is starting up
    while( !m_fqBusy.IsEmpty() )
    {
        // If frame Y was submitted after frame X, and we're sure
        // frame Y is the one being displayed, free frame X
        if( m_fqBusy.m_pHead->pNext &&
            m_fqBusy.m_pHead->pNext->dwSetAtVBlank + ( g_bOverlay ? 0 : 2 )  < g_dwVBlankCount )
        {
            m_fqFree.Enqueue( m_fqBusy.Dequeue() );
        }
        else
            break;
    }

    // Step 2: Discard dropped frames.  We drop frame X if there's 
    // frame Y after it, and frame Y is displayable
    while( !m_fqReady.IsEmpty() && 
            m_fqReady.m_pHead->pNext &&
            m_fqReady.m_pHead->pNext->rtTimeStamp <= m_rtCurrentTime )
    {
        CHAR sz[100];
        sprintf( sz, "Dropped frame %d\n", m_fqReady.m_pHead->dwFrameNumber );
        OUTPUT_DEBUG_STRING( sz );
        m_fqFree.Enqueue( m_fqReady.Dequeue() );
    }

    // Step 3: Now we have at most 1 frame starting before current time
    // See if he should be submitted to render
    if( !m_fqReady.IsEmpty() &&
        m_fqReady.m_pHead->rtTimeStamp <= m_rtCurrentTime )
    {
        // Render the packet
        m_pCurrentFrame = m_fqReady.Dequeue();
        m_fqBusy.Enqueue( m_pCurrentFrame );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Attempts to find a free audio packet (one that isn't currently 
//       submitted to the stream).  Returns TRUE if it found one
//-----------------------------------------------------------------------------
BOOL
CXBoxSample::FindFreePacket( DWORD * pdwIndex )
{
    // Check the status of each packet
    for( int i = 0; i < NUM_PACKETS; i++ )
    {
        // If we find a non-pending packet, return it
        if( m_adwStatus[ i ] != XMEDIAPACKET_STATUS_PENDING )
        {
            *pdwIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
// Name: FindFreeFrame
// Desc: Attempts to find an available video frame (one that is not in the
//          pending video frame queue).  Returns TRUE if one was available
//-----------------------------------------------------------------------------
BOOL
CXBoxSample::FindFreeFrame( VIDEOFRAME ** ppFrame )
{
    // Do we have any frames in the free queue?
    if( !m_fqFree.IsEmpty() )
    {
        *ppFrame = m_fqFree.m_pHead;
        return TRUE;
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    DWORD dwIndex;
    VIDEOFRAME *pFrame;

    // Toggle debug info on/off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
        m_bDebugInfo = !m_bDebugInfo;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Set our time for this frame:
    // Video Time = Current Time - Start Time
    m_pDSound->GetTime( &m_rtCurrentTime );
    m_rtCurrentTime = m_rtCurrentTime - m_rtStartTime;
    
    // Process our 3 video queues
    ProcessVideoQueues();

    // If we are actively decoding...
    if( SUCCEEDED( m_hrOpenFile ) && m_bDecode )
    {
        DWORD dwVideoFrames = 0;

        // Find an audio packet and a video frame
        while( dwVideoFrames < MAXDECODE_PER_FRAME && FindFreePacket( &dwIndex ) && FindFreeFrame( &pFrame ) )
        {
            //
            // Set up an audio packet:
            //
            DWORD audStat, audSize;
            XMEDIAPACKET xmpAudio = {0};
            REFERENCE_TIME rtAudio;

            xmpAudio.dwMaxSize = PACKET_SIZE;
            xmpAudio.pvBuffer  = m_pbSampleData + dwIndex * PACKET_SIZE;
            xmpAudio.pdwStatus = &audStat;
            xmpAudio.pdwCompletedSize = &audSize;
            xmpAudio.prtTimestamp = &rtAudio;

            //
            // Set up a video packet
            //
            DWORD vidStat, vidSize;
            XMEDIAPACKET xmpVideo = {0};
            REFERENCE_TIME rtVideo;

            xmpVideo.dwMaxSize = m_wmvVideoInfo.dwWidth * 
                                 m_wmvVideoInfo.dwHeight * 
                                 m_wmvVideoInfo.dwOutputBitsPerPixel / 8;
            xmpVideo.pdwStatus = &vidStat;
            xmpVideo.pdwCompletedSize = &vidSize;
            xmpVideo.prtTimestamp = &rtVideo;

            // We shouldn't have put the frame in the free queue
            // until we were sure the next one was being used
            assert( !pFrame->pTexture->IsBusy() );

            xmpVideo.pvBuffer  = pFrame->pBits;
        
            // Process the decoder
            HRESULT hr = m_pWMVDecoder->ProcessMultiple( &xmpVideo, &xmpAudio );

            // S_FALSE means that we hit the end of the video
            if( S_FALSE == hr )
            {
                m_bDecode = FALSE;
                m_pStream->Discontinuity();
                OUTPUT_DEBUG_STRING( "Done playing video\n" );

                // Now that we're done with the video, we can
                // unload the decoder
                XFreeSection("WMVDEC");
                break;
            }

            // Get the system start time as of first packet, so 
            // that we can calculate the reference time 
            if( !m_bGotData && ( audSize > 0 || vidSize > 0 ) )
            {
                m_bGotData = TRUE;
                m_pDSound->GetTime( &m_rtStartTime );
                m_rtCurrentTime = 0;
            }
            
            // If we got a video frame, append it to the queue
            if( vidSize > 0 )
            {
                ++dwVideoFrames;

                if( rtVideo < m_rtDuration )
                {
                    // Update the pending video frame queue
                    pFrame->rtTimeStamp = rtVideo;
                    pFrame->dwFrameNumber = g_dwVidFrame++;
                    m_fqReady.Enqueue( m_fqFree.Dequeue() );
                }
            }

            // If we got an audio packet, send it to the stream
            if( audSize > 0 )
            {
                // Process the audio packet
                xmpAudio.dwMaxSize = audSize;
                xmpAudio.pdwCompletedSize = NULL;
                xmpAudio.pdwStatus = &( m_adwStatus[ dwIndex ] );
                xmpAudio.prtTimestamp = NULL;
                m_pStream->Process( &xmpAudio, NULL );
            }
        }
    }
    
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    DirectSoundDoWork();

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    if( m_pCurrentFrame )
    {
        if( g_bOverlay )
        {
            RECT rcSrc = { 0, 0, m_wmvVideoInfo.dwWidth, m_wmvVideoInfo.dwHeight };
            RECT rcDest = { 320 - m_wmvVideoInfo.dwWidth / 2, 240 - m_wmvVideoInfo.dwHeight / 2, 320 + m_wmvVideoInfo.dwWidth / 2, 240 + m_wmvVideoInfo.dwHeight / 2 };
            LPDIRECT3DSURFACE8 pSurface;

            // Update the overlay with the current frame
            m_pCurrentFrame->pTexture->GetSurfaceLevel( 0, &pSurface );
            m_pd3dDevice->UpdateOverlay( pSurface, &rcSrc, &rcDest, FALSE, 0 );
            pSurface->Release();
        }
        else
        {
            // Set up for rendering
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
            m_pd3dDevice->SetTexture( 0, m_pCurrentFrame->pTexture );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
            m_pd3dDevice->SetStreamSource( 0, m_pvbQuad, sizeof( CUSTOMVERTEX ) );
            m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
            m_pd3dDevice->SetRenderState( D3DRS_YUVENABLE, TRUE );

            // Render the quad
            m_pd3dDevice->DrawVertices( D3DPT_QUADLIST, 0, 4 );

            m_pd3dDevice->SetRenderState( D3DRS_YUVENABLE, FALSE );
        }

        // Remember when we attempted to render this frame.
        // The time it actually gets rendered depends on the method
        // For overlay: We can be sure it's been rendered after next vblank
        // For texture: We can be sure it's been rendered 3 vblanks later
        m_pCurrentFrame->dwSetAtVBlank = g_dwVBlankCount;
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"WMVPlayBack" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( FAILED( m_hrOpenFile ) )
        {
            m_Font.DrawText( 64, 80, 0xFFFF0000, L"Couldn't open WMV file" );
        }
        else
        {
            // Display some useful info on video playback
            if( m_bDebugInfo )
            {
                WCHAR sz[100];

                swprintf( sz, L"Video is %d x %d", m_wmvVideoInfo.dwWidth, m_wmvVideoInfo.dwHeight );
                m_Font.DrawText( 64, 80, 0xffffff00, sz );
                swprintf( sz, L"%d bits per second", m_wmvVideoInfo.dwBitsPerSecond );
                m_Font.DrawText( 64, 110, 0xffffff00, sz );

                // If we're still decoding, show some statistics
                if( m_bDecode )
                {
                    swprintf( sz, L"Position: %0.1fs / %0.1fs", m_rtCurrentTime / 10000000.0f, m_rtDuration / 10000000.0f );
                    m_Font.DrawText( 64, 140, 0xffffff00, sz );

                    // See how we're doing on audio packets
                    DWORD dwPending = 0;
                    DWORD dwSucceeded = 0;
                    for( int i = 0; i < NUM_PACKETS; i++ )
                    {
                        switch( m_adwStatus[ i ] )
                        {
                        case XMEDIAPACKET_STATUS_PENDING:
                            dwPending++;
                            break;
                        case XMEDIAPACKET_STATUS_SUCCESS:
                            dwSucceeded++;
                            break;
                        }
                    }
                    swprintf( sz, L"Audio - P: %d S: %d", dwPending, dwSucceeded );
                    m_Font.DrawText( 64, 170, 0xffffff00, sz );

                    // Now check video frames
                    DWORD dwBusy = 0;
                    dwPending = dwSucceeded = 0;
                    for( VIDEOFRAME * pFrame = m_fqFree.m_pHead; pFrame; pFrame = pFrame->pNext )
                        dwSucceeded++;
                    for( VIDEOFRAME * pFrame = m_fqReady.m_pHead; pFrame; pFrame = pFrame->pNext )
                        dwPending++;
                    for( VIDEOFRAME * pFrame = m_fqBusy.m_pHead; pFrame; pFrame = pFrame->pNext )
                        dwBusy++;

                    swprintf( sz, L"Video - F: %d R: %d B: %d", dwSucceeded, dwPending, dwBusy );
                    m_Font.DrawText( 64, 200, 0xffffff00, sz );
                }
            }
        }

        m_Font.End();
    }

    if( !g_bOverlay )
        m_pd3dDevice->BlockUntilVerticalBlank();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\basetexture.h ===
//-----------------------------------------------------------------------------
// File: BaseTexture.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the basic texture-related functionality of the bundler tool
//
// Hist: 04.13.01 - New for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BASETEXTURE_H
#define BASETEXTURE_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;
class CImage;
class CVolume;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h
#define X_D3DFMT_A8R8G8B8              0x00000006
#define X_D3DFMT_X8R8G8B8              0x00000007
#define X_D3DFMT_R5G6B5                0x00000005
#define X_D3DFMT_R6G5B5                0x00000027
#define X_D3DFMT_X1R5G5B5              0x00000003
#define X_D3DFMT_A1R5G5B5              0x00000002
#define X_D3DFMT_A4R4G4B4              0x00000004
#define X_D3DFMT_A8                    0x00000019
#define X_D3DFMT_A8B8G8R8              0x0000003A   
#define X_D3DFMT_B8G8R8A8              0x0000003B   
#define X_D3DFMT_R4G4B4A4              0x00000039   
#define X_D3DFMT_R5G5B5A1              0x00000038   
#define X_D3DFMT_R8G8B8A8              0x0000003C   
#define X_D3DFMT_R8B8                  0x00000029   
#define X_D3DFMT_G8B8                  0x00000028   
#define X_D3DFMT_P8                    0x0000000B
#define X_D3DFMT_L8                    0x00000000
#define X_D3DFMT_A8L8                  0x0000001A
#define X_D3DFMT_AL8                   0x00000001   
#define X_D3DFMT_L16                   0x00000032   
#define X_D3DFMT_V8U8                  0x00000028
#define X_D3DFMT_L6V5U5                0x00000027
#define X_D3DFMT_X8L8V8U8              0x00000007
#define X_D3DFMT_Q8W8V8U8              0x0000003A
#define X_D3DFMT_V16U16                0x00000033
#define X_D3DFMT_DXT1                  0x0000000C
#define X_D3DFMT_DXT2                  0x0000000E
#define X_D3DFMT_DXT3                  0x0000000E // Same constant as DXT2
#define X_D3DFMT_DXT4                  0x0000000F
#define X_D3DFMT_DXT5                  0x0000000F // Same constant as DXT4
#define X_D3DFMT_LIN_A1R5G5B5          0x00000010   
#define X_D3DFMT_LIN_A4R4G4B4          0x0000001D   
#define X_D3DFMT_LIN_A8                0x0000001F   
#define X_D3DFMT_LIN_A8B8G8R8          0x0000003F   
#define X_D3DFMT_LIN_A8R8G8B8          0x00000012   
#define X_D3DFMT_LIN_B8G8R8A8          0x00000040   
#define X_D3DFMT_LIN_G8B8              0x00000017   
#define X_D3DFMT_LIN_R4G4B4A4          0x0000003E   
#define X_D3DFMT_LIN_R5G5B5A1          0x0000003D   
#define X_D3DFMT_LIN_R5G6B5            0x00000011   
#define X_D3DFMT_LIN_R6G5B5            0x00000037   
#define X_D3DFMT_LIN_R8B8              0x00000016   
#define X_D3DFMT_LIN_R8G8B8A8          0x00000041   
#define X_D3DFMT_LIN_X1R5G5B5          0x0000001C   
#define X_D3DFMT_LIN_X8R8G8B8          0x0000001E   
#define X_D3DFMT_LIN_A8L8              0x00000020   
#define X_D3DFMT_LIN_AL8               0x0000001B   
#define X_D3DFMT_LIN_L16               0x00000035   
#define X_D3DFMT_LIN_L8                0x00000013   
#define X_D3DFMT_LIN_V16U16            0x00000036
#define X_D3DFMT_LIN_V8U8              0x00000017
#define X_D3DFMT_LIN_L6V5U5            0x00000037
#define X_D3DFMT_LIN_X8L8V8U8          0x0000001E
#define X_D3DFMT_LIN_Q8W8V8U8          0x00000012

#define D3DTEXTURE_ALIGNMENT            128

#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001
#define D3DFORMAT_DMACHANNEL_B          0x00000002

#define D3DFORMAT_CUBEMAP               0x00000004
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000
#define D3DFORMAT_PSIZE_SHIFT           28

#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_VIDEOMEMORY        0x00800000

#define D3DTEXTURE_PITCH_ALIGNMENT   64


// Texture Resource Format
struct D3DTexture
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;
};


// Enum for format definitions
typedef enum { FMT_LINEAR, FMT_SWIZZLED, FMT_COMPRESSED } FMT_TYPE;


// Format definition
struct FORMATSPEC
{
    CHAR*    strFormat;
    DWORD    dwXboxFormat;
    FMT_TYPE Type;
    DWORD    dwNumAlphaBits;
};
extern const FORMATSPEC g_TextureFormats[];




//-----------------------------------------------------------------------------
// Name: class CBaseTexture
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CBaseTexture
{
public:
    CBaseTexture( CBundler* pBundler );
    ~CBaseTexture();

    CHAR  m_strFormat[MAX_PATH];
    int   m_nFormat;
    DWORD m_dwFilter;
    DWORD m_dwLevels;

protected:
    int     FormatFromString( CHAR* strFormat );            // Format processing
    int     FormatFromPCFormat( D3DFORMAT d3dFormat );
    HRESULT LoadImage( CHAR* strSource, CHAR* strAlphaSource, CImage** ppImage );
    HRESULT LoadImageUsingD3DX( CHAR* strSource, CHAR* strAlphaSource,
                                CImage** ppImage );
    HRESULT ResizeImage( DWORD dwWidth, DWORD dwHeight, CImage** ppImage );
    HRESULT SaveImage( DWORD* pcbData, DWORD dwLevels, CImage* pImage );

    HRESULT SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, CVolume* pVolume );

    DWORD   WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
                                    DWORD dwHeight, DWORD dwDepth );
    DWORD   WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
                                      DWORD dwHeight, DWORD dwDepth );
    DWORD   WriteCompressedTextureData( VOID* pBits, DWORD dwWidth, 
                                        DWORD dwHeight, DWORD dwDepth );

    CBundler* m_pBundler;
};


#endif // BASETEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\bundler.h ===
//-----------------------------------------------------------------------------
// File: Bundler.h
//
// Desc: Header file for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BUNDLER_H
#define BUNDLER_H

#include <assert.h>
#include <windows.h>
#include <d3dx8.h>


// Default extensions for output files
#define XPREXT ".xpr"
#define HDREXT ".h"
#define ERREXT ".err"

#define MAX_RESOURCES 1024

#define TOKEOF ((CHAR)0xff)


class CBundler;
typedef HRESULT (CBundler::* TOKENHANDLERFN)();


// Enums for all of our known tokens
typedef enum 
{ 
    TOKEN_RESOURCE_OPENBRACE             = 0x00000001,
    TOKEN_RESOURCE_CLOSEBRACE            = 0x00000002,
    TOKEN_RESOURCE_EOF                   = 0x00000003,
    TOKEN_RESOURCE_OUT_PACKEDRESOURCE    = 0x00000004,
    TOKEN_RESOURCE_OUT_HEADER            = 0x00000005, 
    TOKEN_RESOURCE_OUT_PREFIX            = 0x00000006, 
    TOKEN_RESOURCE_OUT_ERROR             = 0x00000007,
    TOKEN_RESOURCE_TEXTURE               = 0x00000010,
    TOKEN_RESOURCE_CUBEMAP               = 0x00000030,
    TOKEN_RESOURCE_VOLUMETEXTURE         = 0x00000050,
    TOKEN_RESOURCE_VERTEXBUFFER          = 0x00000100,
    TOKEN_RESOURCE_USERDATA              = 0x00000200,
    TOKEN_RESOURCE_INDEXBUFFER           = 0x00000300,

    // Properties for a resource have the resource
    // value shifted over by 16 bits
    TOKEN_PROPERTY_TEXTURE                = 0x00100000,
    TOKEN_PROPERTY_TEXTURE_SOURCE         = 0x00100001,
    TOKEN_PROPERTY_TEXTURE_ALPHASOURCE    = 0x00100002,
    TOKEN_PROPERTY_TEXTURE_FILTER         = 0x00100003,
    TOKEN_PROPERTY_TEXTURE_FORMAT         = 0x00100004,
    TOKEN_PROPERTY_TEXTURE_WIDTH          = 0x00100005,
    TOKEN_PROPERTY_TEXTURE_HEIGHT         = 0x00100006,
    TOKEN_PROPERTY_TEXTURE_LEVELS         = 0x00100007,

    TOKEN_PROPERTY_CUBEMAP                = 0x00300000,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_XP      = 0x00300001,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_XN      = 0x00300002,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_YP      = 0x00300003,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_YN      = 0x00300004,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP      = 0x00300005,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN      = 0x00300006,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP = 0x00300011,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN = 0x00300012,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP = 0x00300013,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN = 0x00300014,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP = 0x00300015,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN = 0x00300016,
    TOKEN_PROPERTY_CUBEMAP_SIZE           = 0x00300022,

    TOKEN_PROPERTY_VOLUMETEXTURE             = 0x00500000,
//    TOKEN_PROPERTY_VOLUMETEXTURE_SOURCE      = 0x00500001,
//    TOKEN_PROPERTY_VOLUMETEXTURE_ALPHASOURCE = 0x00500002,
    TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH       = 0x00500003,

    TOKEN_PROPERTY_VB                     = 0x01000000,
    TOKEN_PROPERTY_VB_VERTEXDATA          = 0x01000001,
    TOKEN_PROPERTY_VB_VERTEXFORMAT        = 0x01000002,
    TOKEN_PROPERTY_VB_VERTEXFILE          = 0x01000003,

    TOKEN_PROPERTY_USERDATA               = 0x02000000,
    TOKEN_PROPERTY_USERDATA_DATAFILE      = 0x02000001,

    TOKEN_PROPERTY_INDEXBUFFER            = 0x03000000,
    TOKEN_PROPERTY_INDEXBUFFER_INDEXDATA  = 0x03000001,
    TOKEN_PROPERTY_INDEXBUFFER_INDEXFILE  = 0x03000002,

} TOKEN_ID;


// Types of tokens for validation
typedef enum
{
    TT_ANY = 0,
    TT_IDENTIFIER,
    TT_HEXNUMBER,
    TT_INTEGER,
    TT_FLOAT,
    TT_FILENAME,
} TOKENTYPE;


// Token struct that is passed around
typedef struct _BUNDLERTOKEN
{
    char *          strKeyword;
    TOKEN_ID        eType;
    TOKENTYPE       propType;
    TOKENHANDLERFN  pfnHandler;
} BUNDLERTOKEN;


// Resource struct for tracking
typedef struct 
{
    char    strIdentifier[128];
    DWORD   dwOffset;
} RESOURCE_STRUCT;




//-----------------------------------------------------------------------------
// Name: class CBundler
// Desc: Main application class for driving the bundler.  Handles data 
//       management, resource tracking, file management, and tokenizing
//-----------------------------------------------------------------------------
class CBundler
{
public:
    CBundler();
    ~CBundler();

    HRESULT InitD3D();
    HRESULT Initialize( int argc, char * argv[] );
    HRESULT Process();
    void    PrintUsage();

    HRESULT WriteHeader( void * pbBuff, DWORD cb );
    HRESULT WriteData( void * pbBuff, DWORD cb );
    HRESULT PadToAlignment( DWORD dwAlign );

    // Token handling routines
    HRESULT HandleOutPackedResourceToken();
    HRESULT HandleOutHeaderToken();
    HRESULT HandleOutPrefixToken();
    HRESULT HandleOutErrorToken();
    HRESULT HandleTextureToken();
    HRESULT HandleCubemapToken();
	HRESULT HandleVolumeTextureToken();
    HRESULT HandleVertexBufferToken();
    HRESULT HandleUserDataToken();
    HRESULT HandleIndexBufferToken();
    HRESULT HandleEOFToken();

    DWORD   FilterFromString( char* strFilter );

    // D3D stuff for manipulating textures
    LPDIRECT3D8 m_pd3d;
    LPDIRECT3DDEVICE8 m_pd3ddev;

    // Routine to call w/ error messages - prints to stdout and file
    void ErrorMsg( char * strFmt, ... );

    BOOL IsExistingIdentifier( char * strIdentifier );

    DWORD m_cbHeader;
    DWORD m_cbData;

public:

    HRESULT OpenFiles();            // Open output files
    HRESULT CloseFiles();           // Close all files
    HRESULT FlushDataFile();        // Flush from buffer to output file
    HRESULT WriteHeaderFile();      // Create .h header file

    BOOL    Match( INT TokenType, BUNDLERTOKEN* pToken );
    HRESULT GetNextToken( BUNDLERTOKEN* pToken );
    HRESULT GetNextTokenString( CHAR* strTokenString, TOKENTYPE tt );
    HRESULT ValidateType( CHAR* strToken, TOKENTYPE tt );
    HRESULT GetTokenFromString( CHAR* strTokenString, BUNDLERTOKEN* pToken );
    CHAR    GetChar();
    CHAR    PeekChar();

    // Filenames
	CHAR   m_strPath[MAX_PATH];
    CHAR   m_strRDF[MAX_PATH];
    CHAR   m_strXPR[MAX_PATH];
    CHAR   m_strHDR[MAX_PATH];
    CHAR   m_strERR[MAX_PATH];

	// Prefix for header file constants
    CHAR   m_strPrefix[MAX_PATH];

    // File handles
    HANDLE m_hfRDF;
    HANDLE m_hfXPR;
    HANDLE m_hfHDR;
    HANDLE m_hfERR;

    // Data buffer management
    BYTE*  m_pbHeaderBuff;
    DWORD  m_cbHeaderAlloc;
    BYTE*  m_pbDataBuff;
    DWORD  m_cbDataAlloc;

    // Resource tracking
    RESOURCE_STRUCT  m_aResources[MAX_RESOURCES];
    DWORD  m_nResourceCount;

    // For specifying output files and prefix on cmd line vs. in RDF
    BOOL   m_bExplicitXPR;
    BOOL   m_bExplicitHDR;
    BOOL   m_bExplicitERR;
	BOOL   m_bExplicitPrefix;

    // Single character read buffers
    CHAR   m_cNext0;
    CHAR   m_cNext1;
    CHAR   m_cNext2;
    CHAR   m_cNext3;

    // Indicates a single-texture conversion
    BOOL   m_bSingleTexture;

    BOOL   m_bD3DCreated;
};

#endif // BUNDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\CD3DXCodec.cpp ===
//-----------------------------------------------------------------------------
// File: CD3DXCodec.cpp
//
// Desc: Contains general purpose blitting routines
//
// Hist: 01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "CD3DXCodec.h"
#include "basetexture.h"

extern BOOL D3DX__Premult;

static FLOAT g_fDitherOff[] =
{
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f
};

static FLOAT g_fDitherOn[] =
{
    0.96875f, 0.46875f, 0.84375f, 0.34375f, 0.96875f, 0.46875f, 0.84375f, 0.34375f,
    0.21875f, 0.71875f, 0.09375f, 0.59375f, 0.21875f, 0.71875f, 0.09375f, 0.59375f,
    0.78125f, 0.28125f, 0.90625f, 0.40625f, 0.78125f, 0.28125f, 0.90625f, 0.40625f,
    0.03125f, 0.53125f, 0.15625f, 0.65625f, 0.03125f, 0.53125f, 0.15625f, 0.65625f
};



///////////////////////////////////////////////////////////////////////////
// CXD3DXCodec /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CXD3DXCodec* CXD3DXCodec::Create(D3DX_BLT *pBlt)
{

#define CASE_FORMAT(format) \
    case D3DFMT_##format : \
        return new CXD3DXCodec_##format(pBlt)


    switch(pBlt->Format)
    {
//    CASE_FORMAT(R8G8B8);
#if 0
    CASE_FORMAT(R3G3B2);
    CASE_FORMAT(A8R3G3B2);
    CASE_FORMAT(X4R4G4B4);
    CASE_FORMAT(A8P8);
    CASE_FORMAT(A4L4);
    CASE_FORMAT(X8L8V8U8);
    CASE_FORMAT(W11V11U10);
    CASE_FORMAT(DXT3);
    CASE_FORMAT(DXT5);
#endif
    CASE_FORMAT(A8R8G8B8);
    CASE_FORMAT(X8R8G8B8);
    CASE_FORMAT(R5G6B5);
    CASE_FORMAT(X1R5G5B5);
    CASE_FORMAT(A1R5G5B5);
    CASE_FORMAT(A4R4G4B4);
    CASE_FORMAT(A8);
    CASE_FORMAT(P8);
    CASE_FORMAT(L8);
    CASE_FORMAT(A8L8);

    CASE_FORMAT(V8U8);
    CASE_FORMAT(L6V5U5);
    CASE_FORMAT(Q8W8V8U8);
    CASE_FORMAT(V16U16);

//    CASE_FORMAT(UYVY);
//    CASE_FORMAT(YUY2);
//    CASE_FORMAT(DXT1);
//    CASE_FORMAT(DXT2);
//    CASE_FORMAT(DXT4);
    }

    return NULL;
}

CXD3DXCodec::CXD3DXCodec(D3DX_BLT *pBlt, UINT uBPP, DWORD dwType)
{
    m_pbData = (BYTE *) pBlt->pData;
    m_Format = pBlt->Format;
    m_uPitch = pBlt->RowPitch;
    m_uSlice = pBlt->SlicePitch;
    m_Box = pBlt->SubRegion;
    m_ColorKey = pBlt->ColorKey;
    m_bColorKey = pBlt->ColorKey != 0;
    m_pfDither = pBlt->bDither ? g_fDitherOn : g_fDitherOff;
    m_uBytesPerPixel = uBPP >> 3;
    m_bLinear = uBPP != 0;
    m_dwType = dwType;

    if(CODEC_P == m_dwType)
    {
        m_dwType = CODEC_RGB;
        m_bPalettized = TRUE;

        if(pBlt->pPalette)
        {
            for(UINT i = 0; i < 256; i++)
            {
                m_pPalette[i].r = (FLOAT) pBlt->pPalette[i].peRed   * (1.0f / 255.0f);
                m_pPalette[i].g = (FLOAT) pBlt->pPalette[i].peGreen * (1.0f / 255.0f);
                m_pPalette[i].b = (FLOAT) pBlt->pPalette[i].peBlue  * (1.0f / 255.0f);
                m_pPalette[i].a = (FLOAT) pBlt->pPalette[i].peFlags * (1.0f / 255.0f);
            }
        }
        else
        {
            for(UINT i = 0; i < 256; i++)
            {
                m_pPalette[i].r = m_pPalette[i].g = m_pPalette[i].b = m_pPalette[i].a = 1.0f;
            }
        }
    }
    else
    {
        m_bPalettized = FALSE;
    }


    m_uWidth  = (UINT) (m_Box.Right - m_Box.Left);
    m_uHeight = (UINT) (m_Box.Bottom - m_Box.Top);
    m_uDepth  = (UINT) (m_Box.Back - m_Box.Front);
    m_uWidthBytes = m_uWidth * m_uBytesPerPixel;

    if(m_bLinear)
    {
        m_pbData += m_Box.Front * m_uSlice + m_Box.Top * m_uPitch + m_Box.Left * m_uBytesPerPixel;

        m_Box.Left   = 0;
        m_Box.Top    = 0;
        m_Box.Front  = 0;
        m_Box.Right  = m_uWidth;
        m_Box.Bottom = m_uHeight;
        m_Box.Back   = m_uDepth;
    }
}

CXD3DXCodec::~CXD3DXCodec()
{
    // Do nothing
}

void CXD3DXCodec::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    // Do nothing
}

void CXD3DXCodec::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    // Do nothing
}

void CXD3DXCodec::ColorKey(D3DXCOLOR *pColors)
{
    D3DXCOLOR *pColor;
    D3DXCOLOR *pColorLim = pColors + m_uWidth;

    for(pColor = pColors; pColor < pColorLim; pColor++)
    {
        if(*pColor == m_ColorKey)
            pColor->r = pColor->g = pColor->b = pColor->a = 0.0f;
    }
}


///////////////////////////////////////////////////////////////////////////
// Specific codecs ////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define ENCODE(format) \
    void CXD3DXCodec_##format::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)


ENCODE(R8G8B8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        pub[0] = (UINT8) F2I(pColors[i].b * 255.0f + fDither);
        pub[1] = (UINT8) F2I(pColors[i].g * 255.0f + fDither);
        pub[2] = (UINT8) F2I(pColors[i].r * 255.0f + fDither);

        pub += 3;
    }

    F2IEnd();
}


ENCODE(A8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 255.0f + fDither) << 16) |
                         (F2I(pColors[i].g * 255.0f + fDither) <<  8) |
                         (F2I(pColors[i].b * 255.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 255.0f + fDither) << 24));

        pul++;
    }

    F2IEnd();
}


ENCODE(X8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 255.0f + fDither) << 16) |
                         (F2I(pColors[i].g * 255.0f + fDither) <<  8) |
                         (F2I(pColors[i].b * 255.0f + fDither) <<  0));

        pul++;
    }

    F2IEnd();
}


ENCODE(R5G6B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 11) |
                         (F2I(pColors[i].g * 63.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(X1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 10) |
                         (F2I(pColors[i].g * 31.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(A1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 10) |
                         (F2I(pColors[i].g * 31.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0) |
                         (F2I(pColors[i].a *  1.0f + fDither) << 15));

        pus++;
    }

    F2IEnd();
}


ENCODE(A4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 15.0f + fDither) <<  8) |
                         (F2I(pColors[i].g * 15.0f + fDither) <<  4) |
                         (F2I(pColors[i].b * 15.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 15.0f + fDither) << 12));

        pus++;
    }

    F2IEnd();
}


ENCODE(R3G3B2)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) ((F2I(pColors[i].r * 7.0f + fDither) <<  5) |
                        (F2I(pColors[i].g * 7.0f + fDither) <<  2) |
                        (F2I(pColors[i].b * 3.0f + fDither) <<  0));

        pub++;
    }

    F2IEnd();
}


ENCODE(A8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) F2I(pColors[i].a * 255.0f + fDither);

        pub++;
    }

    F2IEnd();
}


ENCODE(A8R3G3B2)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r *   7.0f + fDither) <<  5) |
                         (F2I(pColors[i].g *   7.0f + fDither) <<  2) |
                         (F2I(pColors[i].b *   3.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 255.0f + fDither) <<  8));

        pus++;
    }

    F2IEnd();
}


ENCODE(X4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 15.0f + fDither) <<  8) |
                         (F2I(pColors[i].g * 15.0f + fDither) <<  4) |
                         (F2I(pColors[i].b * 15.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(A8P8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        UINT uMin = 0;
        FLOAT fDistMin = FLT_MAX;

        for(UINT u = 0; u < 256; u++)
        {
            D3DXCOLOR color = *pColors - m_pPalette[u];
            FLOAT fDist = color.r * color.r + color.g * color.g + color.b * color.b;

            if(fDist < fDistMin)
                uMin = u;
        }

        *pus = (UINT16) (uMin | (F2I(pColors[i].a * 255.0f + fDither) << 8));

        pus++;
    }

    F2IEnd();
}


ENCODE(P8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);


    for(UINT i = 0; i < m_uWidth; i++)
    {
        UINT uMin = 0;
        FLOAT fDistMin = FLT_MAX;

        for(UINT u = 0; u < 256; u++)
        {
            D3DXCOLOR color = pColors[i] - m_pPalette[u];
            FLOAT fDist = color.r * color.r + color.g * color.g + color.b * color.b + color.a * color.a;

            if(fDist < fDistMin)
            {
                uMin = u;
                fDistMin = fDist;
            }
        }

        *pub = (UINT8) uMin;

        pub++;
    }
}


ENCODE(L8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) F2I((pColors[i].r * 0.2125f +
                            pColors[i].g * 0.7154f +
                            pColors[i].b * 0.0721f) * 255.0f + fDither);

        pub++;
    }

    F2IEnd();
}


ENCODE(A8L8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I((pColors[i].r * 0.2125f +
                               pColors[i].g * 0.7154f +
                               pColors[i].b * 0.0721f) * 255.0f + fDither) << 0) |

                         (F2I(pColors[i].a * 255.0f + fDither) << 8));

        pus++;
    }

    F2IEnd();
}


ENCODE(A4L4)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) ((F2I((pColors[i].r * 0.2125f +
                              pColors[i].g * 0.7154f +
                              pColors[i].b * 0.0721f) * 15.0f + fDither) << 0) |

                        (F2I(pColors[i].a * 15.0f + fDither) << 4));

        pub++;
    }

    F2IEnd();
}


ENCODE(V8U8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 128.0f + fDither) & 255) << 0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) << 8);
                      
        pus++;
    }

    F2IEnd();
}


ENCODE(L6V5U5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT32) ((F2I(pColors[i].r * 16.0f + fDither) & 31) <<  0) |
                        ((F2I(pColors[i].g * 16.0f + fDither) & 31) <<  5) |
                        ((F2I(pColors[i].a * 63.0f + fDither) & 63) << 10);

        pus++;
    }

    F2IEnd();
}


ENCODE(X8L8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 128.0f + fDither) & 255) <<  0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) <<  8) |
                        ((F2I(pColors[i].a * 255.0f + fDither) & 255) << 16);

        pul++;
    }

    F2IEnd();
}


ENCODE(Q8W8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 128.0f + fDither) & 255) <<  0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) <<  8) |
                        ((F2I(pColors[i].b * 128.0f + fDither) & 255) << 16) |
                        ((F2I(pColors[i].a * 128.0f + fDither) & 255) << 24);

        pul++;
    }

    F2IEnd();
}


ENCODE(V16U16)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 32768.0f + fDither) & 65535) <<  0) |
                        ((F2I(pColors[i].g * 32768.0f + fDither) & 65535) << 16);

        pul++;
    }

    F2IEnd();
}


ENCODE(W11V11U10)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r *  512.0f + fDither) & 1023) <<  0) |
                        ((F2I(pColors[i].g * 1024.0f + fDither) & 2047) << 10) |
                        ((F2I(pColors[i].b * 1024.0f + fDither) & 2046) << 21);

        pul++;
    }

    F2IEnd();
}




#define DECODE(format) \
    void CXD3DXCodec_##format::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)


DECODE(R8G8B8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidthBytes;

    while(pub < pubLim)
    {
        pColors->r = (FLOAT) pub[2] * (1.0f / 255.0f);
        pColors->g = (FLOAT) pub[1] * (1.0f / 255.0f);
        pColors->b = (FLOAT) pub[0] * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pub += 3;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
        pColors->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
        pColors->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = (FLOAT) ((*pul >> 24) & 255) * (1.0f / 255.0f);

        pul++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
        pColors->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
        pColors->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(R5G6B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 11) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 63) * (1.0f / 63.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 10) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 31) * (1.0f / 31.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 10) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 31) * (1.0f / 31.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = (FLOAT) ((*pus >> 15) &  1) * (1.0f /  1.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  8) & 15) * (1.0f / 15.0f);
        pColors->g = (FLOAT) ((*pus >>  4) & 15) * (1.0f / 15.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = (FLOAT) ((*pus >> 12) & 15) * (1.0f / 15.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(R3G3B2)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = (FLOAT) ((*pub >>  5) & 7) * (1.0f / 7.0f);
        pColors->g = (FLOAT) ((*pub >>  2) & 7) * (1.0f / 7.0f);
        pColors->b = (FLOAT) ((*pub >>  0) & 3) * (1.0f / 3.0f);
        pColors->a = 1.0f;

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = 1.0f;
        pColors->g = 1.0f;
        pColors->b = 1.0f;
        pColors->a = (FLOAT) *pub * (1.0f / 255.0f);

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8R3G3B2)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  5) &   7) * (1.0f /   7.0f);
        pColors->g = (FLOAT) ((*pus >>  2) &   7) * (1.0f /   7.0f);
        pColors->b = (FLOAT) ((*pus >>  0) &   3) * (1.0f /   3.0f);
        pColors->a = (FLOAT) ((*pus >>  8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  8) & 15) * (1.0f / 15.0f);
        pColors->g = (FLOAT) ((*pus >>  4) & 15) * (1.0f / 15.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8P8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        *pColors = m_pPalette[*pus & 255];
        pColors->a = (FLOAT) ((*pus >>  8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(P8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        *pColors = m_pPalette[*pub];

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(L8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) *pub * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8L8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) ((*pus >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = (FLOAT) ((*pus >> 8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A4L4)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) ((*pub >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = (FLOAT) ((*pub >> 4) & 15) * (1.0f / 15.0f);

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}

DECODE(V8U8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pus >> 0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pus >> 8) & 255) * (1.0f / 128.0f);
        pColors->b = 0.0f;
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }
}


DECODE(L6V5U5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        INT8 iU = (INT8) ((*pus >>  0) & 31);
        INT8 iV = (INT8) ((*pus >>  5) & 31);

        // Sign extension
        iU <<= 3; iU >>= 3;
        iV <<= 3; iV >>= 3; 

        pColors->r = (FLOAT) iU * (1.0f / 16.0f);
        pColors->g = (FLOAT) iV * (1.0f / 16.0f);
        pColors->b = 0.0f;
        pColors->a = (FLOAT) ((*pus >> 10) & 63) * (1.0f / 63.0f);

        pus++;
        pColors++;
    }
}


DECODE(X8L8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pul >>  0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pul >>  8) & 255) * (1.0f / 128.0f);
        pColors->b = 0.0f;
        pColors->a = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);

        pul++;
        pColors++;
    }
}


DECODE(Q8W8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pul >>  0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pul >>  8) & 255) * (1.0f / 128.0f);
        pColors->b = (FLOAT) (INT8) ((*pul >> 16) & 255) * (1.0f / 128.0f);
        pColors->a = (FLOAT) (INT8) ((*pul >> 24) & 255) * (1.0f / 128.0f);

        pul++;
        pColors++;
    }
}


DECODE(V16U16)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT16) ((*pul >>  0) & 65535) * (1.0f / 32768.0f);
        pColors->g = (FLOAT) (INT16) ((*pul >> 16) & 65535) * (1.0f / 32768.0f);
        pColors->b = 0.0f;
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }
}


DECODE(W11V11U10)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        INT16 iU = (INT16) ((*pul >>  0) & 1023);
        INT16 iV = (INT16) ((*pul >> 10) & 2047);
        INT16 iW = (INT16) ((*pul >> 21) & 2047);

        // Sign extension
        iU <<= 6; iU >>= 6;
        iV <<= 5; iV >>= 5;
        iW <<= 5; iW >>= 5;

        pColors->r = (FLOAT) iU * (1.0f /  512.0f);
        pColors->g = (FLOAT) iV * (1.0f / 1024.0f);
        pColors->b = (FLOAT) iW * (1.0f / 1024.0f);
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }
}





///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecYUV //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CXD3DXCodecYUV::CXD3DXCodecYUV(D3DX_BLT *pBlt)
    : CXD3DXCodec(pBlt, 0, CODEC_RGB)
{
    m_CacheBox.Left   = m_Box.Left & ~1;
    m_CacheBox.Top    = 0;
    m_CacheBox.Front  = 0;
    m_CacheBox.Right  = (m_Box.Right + 1) & ~1;
    m_CacheBox.Bottom = 0;
    m_CacheBox.Back   = 0;

    m_uCacheWidth = m_CacheBox.Right - m_CacheBox.Left;

    m_bCacheDirty     = FALSE;
    m_bCacheAllocated = TRUE;

    if(!(m_pCache = new D3DXCOLOR[m_uCacheWidth]))
        m_bCacheAllocated = FALSE;

    if(D3DFMT_UYVY == pBlt->Format)
    {
        m_uYShift  = 8;
        m_uUVShift = 0;
    }
    else
    {
        m_uYShift  = 0;
        m_uUVShift = 8;
    }
}


CXD3DXCodecYUV::~CXD3DXCodecYUV()
{
    Commit();

    if(m_pCache)
        delete [] m_pCache;
}


HRESULT CXD3DXCodecYUV::Commit()
{
    if(!m_bCacheDirty || !m_bCacheAllocated)
        return S_OK;


    // Write data
    UINT16 *pus = (UINT16 *) (m_pbData + m_CacheBox.Left * 2 + m_CacheBox.Top * m_uPitch + m_CacheBox.Front * m_uSlice);
    D3DXCOLOR *pCache = m_pCache;

    for(UINT uLeft = m_CacheBox.Left; uLeft < m_CacheBox.Right; uLeft += 2)
    {
        FLOAT fY0 =  65.481f * pCache[0].r + 128.553f * pCache[0].g +  24.966f * pCache[0].b;
        FLOAT fY1 =  65.481f * pCache[1].r + 128.553f * pCache[1].g +  24.966f * pCache[1].b;

        FLOAT fU  = -37.797f * pCache[0].r + -74.203f * pCache[0].g + 112.000f * pCache[0].b;
        FLOAT fV  = 112.000f * pCache[0].r + -93.786f * pCache[0].g + -18.214f * pCache[0].b;

        int nY0 = F2I(fY0 + 0.5f) + 16;
        int nY1 = F2I(fY1 + 0.5f) + 16;
        int nU  = F2I(fU + 0.5f) + 128;
        int nV  = F2I(fV + 0.5f) + 128;

        nY0 = (nY0 < 0) ? 0 : ((nY0 > 0xff) ? 0xff : nY0);
        nY1 = (nY1 < 0) ? 0 : ((nY1 > 0xff) ? 0xff : nY1);
        nU  = (nU  < 0) ? 0 : ((nU  > 0xff) ? 0xff : nU );
        nV  = (nV  < 0) ? 0 : ((nV  > 0xff) ? 0xff : nV );

        pus[0] = (UINT16) ((nY0 << m_uYShift) | (nU << m_uUVShift));
        pus[1] = (UINT16) ((nY1 << m_uYShift) | (nV << m_uUVShift));

        pCache += 2;
        pus += 2;
    }

    m_bCacheDirty = FALSE;
    return S_OK;
}


HRESULT CXD3DXCodecYUV::Fetch(UINT uRow, UINT uSlice, BOOL bRead)
{
    HRESULT hr;

    if(!m_bCacheAllocated)
        return E_OUTOFMEMORY;

    if(uRow   >= m_CacheBox.Top   && uRow   < m_CacheBox.Bottom &&
       uSlice >= m_CacheBox.Front && uSlice < m_CacheBox.Back)
    {
        return S_OK;
    }

    // Flush dirty data in cache, if any
    if(FAILED(hr = Commit()))
        return hr;

    // Update cache rect
    m_CacheBox.Top    = uRow;
    m_CacheBox.Bottom = uRow + 1;
    m_CacheBox.Front  = uSlice;
    m_CacheBox.Back   = uSlice + 1;

    if(!bRead)
        return S_OK;


    // Read data
    UINT16 *pus = (UINT16 *) (m_pbData + m_CacheBox.Left * 2 + m_CacheBox.Top * m_uPitch + m_CacheBox.Front * m_uSlice);
    D3DXCOLOR *pCache = m_pCache;

    for(UINT uLeft = m_CacheBox.Left; uLeft < m_CacheBox.Right; uLeft += 2)
    {
        FLOAT fY0 = (FLOAT) ((pus[0] >> m_uYShift)  & 0xff) -  16.0f;
        FLOAT fU  = (FLOAT) ((pus[0] >> m_uUVShift) & 0xff) - 128.0f;

        FLOAT fY1 = (FLOAT) ((pus[1] >> m_uYShift)  & 0xff) -  16.0f;
        FLOAT fV  = (FLOAT) ((pus[1] >> m_uUVShift) & 0xff) - 128.0f;

        pCache[0].r = 0.00456621f * fY0                    + 0.00625893f * fV;
        pCache[0].g = 0.00456621f * fY0 - 0.00153632f * fU - 0.00318811f * fV;
        pCache[0].b = 0.00456621f * fY0 + 0.00791071f * fU;
        pCache[0].a = 1.0f;

        pCache[0].r = (pCache[0].r < 0.0f) ? 0.0f : ((pCache[0].r > 1.0f) ? 1.0f : pCache[0].r);
        pCache[0].g = (pCache[0].g < 0.0f) ? 0.0f : ((pCache[0].g > 1.0f) ? 1.0f : pCache[0].g);
        pCache[0].b = (pCache[0].b < 0.0f) ? 0.0f : ((pCache[0].b > 1.0f) ? 1.0f : pCache[0].b);

        pCache[1].r = 0.00456621f * fY1                    + 0.00625893f * fV;
        pCache[1].g = 0.00456621f * fY1 - 0.00153632f * fU - 0.00318811f * fV;
        pCache[1].b = 0.00456621f * fY1 + 0.00791071f * fU;
        pCache[1].a = 1.0f;

        pCache[1].r = (pCache[1].r < 0.0f) ? 0.0f : ((pCache[1].r > 1.0f) ? 1.0f : pCache[1].r);
        pCache[1].g = (pCache[1].g < 0.0f) ? 0.0f : ((pCache[1].g > 1.0f) ? 1.0f : pCache[1].g);
        pCache[1].b = (pCache[1].b < 0.0f) ? 0.0f : ((pCache[1].b > 1.0f) ? 1.0f : pCache[1].b);

        pCache += 2;
        pus += 2;
    }

    return S_OK;
}


void CXD3DXCodecYUV::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, m_uCacheWidth != m_uWidth)))
        return;

    memcpy(m_pCache + m_Box.Left - m_CacheBox.Left, pColors, m_uWidth * sizeof(D3DXCOLOR));
    m_bCacheDirty = TRUE;
}


void CXD3DXCodecYUV::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, TRUE)))
        return;

    memcpy(pColors, m_pCache + m_Box.Left - m_CacheBox.Left, m_uWidth * sizeof(D3DXCOLOR));

    if(m_bColorKey)
        ColorKey(pColors);
}



#ifdef SUPPORT_DXT
///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecDXT //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CXD3DXCodecDXT::CXD3DXCodecDXT(D3DX_BLT *pBlt)
    : CXD3DXCodec(pBlt, 0, CODEC_RGB)
{
    m_bRepeat = FALSE;

    switch(pBlt->Region.Right)
    {
    case 1:
        m_uXRepeat = 0;
        m_bRepeat = TRUE;
        break;

    case 2:
        m_uXRepeat = 1;
        m_bRepeat = TRUE;
        break;

    default:
        m_uXRepeat = 3;
        break;
    }


    switch(pBlt->Region.Bottom)
    {
    case 1:
        m_uYRepeat = 0;
        m_bRepeat = TRUE;
        break;

    case 2:
        m_uYRepeat = 1;
        m_bRepeat = TRUE;
        break;

    default:
        m_uYRepeat = 3;
        break;
    }


    m_CacheBox.Left   = m_Box.Left & ~3;
    m_CacheBox.Top    = 0;
    m_CacheBox.Front  = 0;
    m_CacheBox.Right  = (m_Box.Right + 3) & ~3;
    m_CacheBox.Bottom = 0;
    m_CacheBox.Back   = 0;

    m_uTopMax     = 0;
    m_uCacheWidth = m_CacheBox.Right - m_CacheBox.Left;

    m_bCacheDirty     = FALSE;
    m_bCacheAllocated = TRUE;

    for(UINT i = 0; i < 4; i++)
    {
        if(!(m_ppCache[i] = new D3DXCOLOR[m_uCacheWidth]))
            m_bCacheAllocated = FALSE;
    }
}


CXD3DXCodecDXT::~CXD3DXCodecDXT()
{
    Commit();

    for(UINT i = 0; i < 4; i++)
    {
        if(m_ppCache[i])
            delete [] m_ppCache[i];
    }
}


HRESULT CXD3DXCodecDXT::Commit()
{
    if(!m_bCacheDirty || !m_bCacheAllocated)
        return S_OK;

    BOOL bPremult = D3DX__Premult;

    for(UINT uLeft = m_CacheBox.Left; uLeft < (UINT) m_CacheBox.Right; uLeft += 4)
    {
        UINT32 ulBlock[16];
        LPBYTE pCell;

        // Copy cache data into block
        F2IBegin();
        UINT32 *pul = &ulBlock[0];

        if(bPremult)
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

                for(UINT uX = 0; uX < 4; uX++)
                {
                    *pul = (UINT32) ((F2I(pColor->r * pColor->a * 255.0f + 0.5f) << 16) |
                                     (F2I(pColor->g * pColor->a * 255.0f + 0.5f) <<  8) |
                                     (F2I(pColor->b * pColor->a * 255.0f + 0.5f) <<  0) |
                                     (F2I(pColor->a             * 255.0f + 0.5f) << 24));

                    pColor++;
                    pul++;
                }
            }
        }
        else
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

                for(UINT uX = 0; uX < 4; uX++)
                {
                    *pul = (UINT32) ((F2I(pColor->r * 255.0f + 0.5f) << 16) |
                                     (F2I(pColor->g * 255.0f + 0.5f) <<  8) |
                                     (F2I(pColor->b * 255.0f + 0.5f) <<  0) |
                                     (F2I(pColor->a * 255.0f + 0.5f) << 24));


                    pColor++;
                    pul++;
                }
            }
        }

        F2IEnd();


        // Repeat data for degenerate case
        if(m_bRepeat)
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                for(UINT uX = 0; uX < 4; uX++)
                {
                    ulBlock[(uY << 2) + uX] = ulBlock[((uY & m_uYRepeat) << 2) + (uX & m_uXRepeat)];
                }
            }
        }


        // Encode DXT block
        switch (m_Format)
        {
        case D3DFMT_DXT1:
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockRGB);
            XXEncodeBlockRGB((S3TC_COLOR *) &ulBlock[0], (S3TCBlockRGB *) pCell);
            break;

        case D3DFMT_DXT2:
#if 0
        case D3DFMT_DXT3:
#endif
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha4);
            EncodeBlockAlpha4((S3TC_COLOR *) &ulBlock[0], (S3TCBlockAlpha4 *) pCell);
            break;

        case D3DFMT_DXT4:
#if 0
        case D3DFMT_DXT5:
#endif
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha3);
            EncodeBlockAlpha3((S3TC_COLOR *) &ulBlock[0], (S3TCBlockAlpha3 *) pCell);
            pCell = pCell;
            break;
        }
    }

    m_bCacheDirty = FALSE;
    return S_OK;
}


HRESULT CXD3DXCodecDXT::Fetch(UINT uRow, UINT uSlice, BOOL bRead)
{
    HRESULT hr;

    if(!m_bCacheAllocated)
        return E_OUTOFMEMORY;

    if(uRow   >= m_CacheBox.Top   && uRow   < m_CacheBox.Bottom &&
       uSlice >= m_CacheBox.Front && uSlice < m_CacheBox.Back)
    {
        return S_OK;
    }

    // Flush dirty data in cache, if any
    if(FAILED(hr = Commit()))
        return hr;



    // Update cache rect
    m_CacheBox.Top    = uRow & ~3;
    m_CacheBox.Bottom = m_CacheBox.Top + 4;
    m_CacheBox.Front  = uSlice;
    m_CacheBox.Back   = uSlice + 1;

    if(m_uTopMax <= m_CacheBox.Top)
    {
        m_uTopMax = m_CacheBox.Top;

        if(!bRead)
            return S_OK;
    }



    // Read data
    BOOL bPremult = D3DX__Premult;

    for(UINT uLeft = m_CacheBox.Left; uLeft < (UINT) m_CacheBox.Right; uLeft += 4)
    {
        UINT32 ulBlock[16];
        LPBYTE pCell;

        // Decode DXT block
        switch (m_Format)
        {
        case D3DFMT_DXT1:
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockRGB);
            XXDecodeBlockRGB((S3TCBlockRGB *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;

        case D3DFMT_DXT2:
#if 0
        case D3DFMT_DXT3:
#endif
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha4);
            DecodeBlockAlpha4((S3TCBlockAlpha4 *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;

        case D3DFMT_DXT4:
#if 0
        case D3DFMT_DXT5:
#endif
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha3);
            DecodeBlockAlpha3((S3TCBlockAlpha3 *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;
        }


        // Copy block data into cache
        UINT32 *pul = &ulBlock[0];

        for(UINT uY = 0; uY < 4; uY++)
        {
            D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

            for(UINT uX = 0; uX < 4; uX++)
            {
                pColor->a = (FLOAT) ((*pul >> 24) & 255) * (1.0f / 255.0f);
                pColor->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
                pColor->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
                pColor->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);

                if(bPremult)
                {
                    if(0.0f == pColor->a)
                    {
                        pColor->r = 0.0f;
                        pColor->g = 0.0f;
                        pColor->b = 0.0f;
                    }
                    else if(1.0f > pColor->a)
                    {
                        pColor->r = (pColor->r < pColor->a) ? (pColor->r / pColor->a) : 1.0f;
                        pColor->g = (pColor->g < pColor->a) ? (pColor->g / pColor->a) : 1.0f;
                        pColor->b = (pColor->b < pColor->a) ? (pColor->b / pColor->a) : 1.0f;
                    }
                }

                pColor++;
                pul++;
            }
        }
    }

    return S_OK;
}


void CXD3DXCodecDXT::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, m_uCacheWidth != m_uWidth)))
        return;

    memcpy(m_ppCache[uRow - m_CacheBox.Top] + m_Box.Left - m_CacheBox.Left, pColors, m_uWidth * sizeof(D3DXCOLOR));
    m_bCacheDirty = TRUE;
}


void CXD3DXCodecDXT::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, TRUE)))
        return;

    memcpy(pColors, m_ppCache[uRow - m_CacheBox.Top] + m_Box.Left - m_CacheBox.Left, m_uWidth * sizeof(D3DXCOLOR));

    if(m_bColorKey)
        ColorKey(pColors);
}
#endif // SUPPORT_DXT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\CD3DXBlt.cpp ===
//-----------------------------------------------------------------------------
// File: CD3DXBlt.cpp
//
// Desc: Contains general purpose blitting routines
//
// Hist: 01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "CD3DXBlt.h"

#define DPF(x,y)
#define D3DXASSERT(x)

///////////////////////////////////////////////////////////////////////////
// CXD3DXBlt ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CXD3DXBlt::CXD3DXBlt()
{
    m_pDest = NULL;
    m_pSrc  = NULL;
}


CXD3DXBlt::~CXD3DXBlt()
{
    if(m_pDest)
        delete m_pDest;

    if(m_pSrc)
        delete m_pSrc;
}

HRESULT CXD3DXBlt::Blt(D3DX_BLT* pDestBlt, D3DX_BLT* pSrcBlt, DWORD dwFilter)
{
    HRESULT hr;

    m_pDest = NULL;
    m_pSrc  = NULL;
    m_dwFilter = dwFilter;


    // Validate filter
    switch(dwFilter & 0xffff)
    {
    case D3DX_FILTER_NONE:
    case D3DX_FILTER_POINT:
    case D3DX_FILTER_LINEAR:
    case D3DX_FILTER_TRIANGLE:
    case D3DX_FILTER_BOX:
        break;

    default:
        DPF(0, "Invalid image filter");
        return D3DERR_INVALIDCALL;
    }

    if(dwFilter & (0xffff0000 & ~(D3DX_FILTER_MIRROR | D3DX_FILTER_DITHER)))
    {
        DPF(0, "Invalid image filter");
        return D3DERR_INVALIDCALL;
    }

    pDestBlt->bDither = (dwFilter & D3DX_FILTER_DITHER);


    // Find codecs
    if(!(m_pDest = CXD3DXCodec::Create(pDestBlt)) ||
       !(m_pSrc  = CXD3DXCodec::Create(pSrcBlt)))
    {
        DPF(0, "Unsupported image format");
        hr = E_FAIL;
        goto LDone;
    }


    // Make sure compatible image types
    if(m_pDest->m_dwType != m_pSrc->m_dwType)
    {
        DPF(0, "No conversion exists between source and destination image formats");
        hr = E_FAIL;
        goto LDone;
    }


    // Find blitter
    if(FAILED(BltSame()) &&
       FAILED(BltCopy()) &&
       FAILED(BltNone()) &&
       FAILED(BltPoint()) &&
       FAILED(BltBox2D()) &&
       FAILED(BltBox3D()) &&
       FAILED(BltLinear2D()) &&
       FAILED(BltLinear3D()) &&
       FAILED(BltTriangle2D()) &&
       FAILED(BltTriangle3D()))
    {
        DPF(0, "No suitable image filter found");
        hr = E_FAIL;
        goto LDone;
    }

    hr = S_OK;
    goto LDone;

LDone:
    if(m_pDest)
    {
        delete m_pDest;
        m_pDest = NULL;
    }

    if(m_pSrc)
    {
        delete m_pSrc;
        m_pSrc = NULL;
    }

    return hr;
}



HRESULT CXD3DXBlt::BltSame()
{
    if(m_pDest->m_Format != m_pSrc->m_Format)
        return E_FAIL;

    if(m_pSrc->m_bColorKey)
        return E_FAIL;

    if(m_pDest->m_uWidth  != m_pSrc->m_uWidth || 
       m_pDest->m_uHeight != m_pSrc->m_uHeight ||
       m_pDest->m_uDepth  != m_pSrc->m_uDepth)
    {
        return E_FAIL;
    }

#ifdef SUPPORT_DXT
    if(!m_pDest->m_bLinear)
        return BltSame_DXTn();
#endif // SUPPORT_DXT

    if(m_pDest->m_bPalettized && m_pDest->m_pPalette != m_pSrc->m_pPalette && 
        memcmp(m_pDest->m_pPalette, m_pSrc->m_pPalette, 256 * sizeof(PALETTEENTRY)))
    {
        return E_FAIL;
    }



    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        BYTE *pbDest = m_pDest->m_pbData + uZ * m_pDest->m_uSlice;
        BYTE *pbSrc  = m_pSrc ->m_pbData + uZ * m_pSrc ->m_uSlice;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            memcpy(pbDest, pbSrc, m_pDest->m_uWidthBytes);

            pbDest += m_pDest->m_uPitch;
            pbSrc  += m_pSrc ->m_uPitch;
        }
    }

    return S_OK;
}


HRESULT CXD3DXBlt::BltCopy()
{
    D3DXCOLOR *pColor;

    if(m_pDest->m_uWidth  != m_pSrc->m_uWidth || 
       m_pDest->m_uHeight != m_pSrc->m_uHeight ||
       m_pDest->m_uDepth  != m_pSrc->m_uDepth)
    {
        return E_FAIL;
    }

    if(!(pColor = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_FAIL;

//  DPF(0, "blt copy %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            m_pSrc ->Decode(uY, uZ, pColor);
            m_pDest->Encode(uY, uZ, pColor);
        }
    }

    delete [] pColor;
    return S_OK;
}


HRESULT CXD3DXBlt::BltNone()
{
    UINT uWidthMax, uWidthMin, uHeightMin, uDepthMin, uY, uZ;

    D3DXCOLOR *pColor;
    D3DXCOLOR *pBlack;

    if((m_dwFilter & 0xff) != D3DX_FILTER_NONE)
        return E_FAIL;

//  DPF(0, "blt none %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    uWidthMax  = (m_pDest->m_uWidth  > m_pSrc->m_uWidth)  ? m_pDest->m_uWidth  : m_pSrc->m_uWidth;
    uWidthMin  = (m_pDest->m_uWidth  < m_pSrc->m_uWidth)  ? m_pDest->m_uWidth  : m_pSrc->m_uWidth;
    uHeightMin = (m_pDest->m_uHeight < m_pSrc->m_uHeight) ? m_pDest->m_uHeight : m_pSrc->m_uHeight;
    uDepthMin  = (m_pDest->m_uDepth  < m_pSrc->m_uDepth)  ? m_pDest->m_uDepth  : m_pSrc->m_uDepth;

    if(!(pColor = new D3DXCOLOR[uWidthMax]))
        return E_FAIL;

    if(!(pBlack = new D3DXCOLOR[m_pDest->m_uWidth]))
    {
        delete [] pColor;
        return E_FAIL;
    }

    memset(pColor, 0x00, uWidthMax * sizeof(D3DXCOLOR));
    memset(pBlack, 0x00, m_pDest->m_uWidth * sizeof(D3DXCOLOR));


    for(uZ = 0; uZ < uDepthMin; uZ++)
    {
        for(uY = 0; uY < uHeightMin; uY++)
        {
            m_pSrc ->Decode(uY, uZ, pColor);
            m_pDest->Encode(uY, uZ, pColor);
        }

        for(uY = uHeightMin; uY < m_pDest->m_uHeight; uY++)
            m_pDest->Encode(uY, uZ, pBlack);
    }

    for(uZ = uDepthMin; uZ < m_pDest->m_uDepth; uZ++)
    {
        for(uY = 0; uY < m_pDest->m_uHeight; uY++)
            m_pDest->Encode(uY, uZ, pBlack);
    }

    delete [] pColor;
    delete [] pBlack;
    return S_OK;
}


HRESULT CXD3DXBlt::BltPoint()
{
    D3DXCOLOR *pSrc;
    D3DXCOLOR *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_POINT)
        return E_FAIL;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        return E_OUTOFMEMORY;

    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
    {
        delete []pSrc;
        return E_OUTOFMEMORY;
    }


//  DPF(0, "blt point %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    UINT uSrcXInc = (m_pSrc->m_uWidth  << 16) / m_pDest->m_uWidth;
    UINT uSrcYInc = (m_pSrc->m_uHeight << 16) / m_pDest->m_uHeight;
    UINT uSrcZInc = (m_pSrc->m_uDepth  << 16) / m_pDest->m_uDepth;

    UINT uSrcZ  = 0;
    UINT uDestZ = 0;

    while(uDestZ < m_pDest->m_uDepth)
    {
        UINT uSrcY  = 0;
        UINT uDestY = 0;
        UINT uSrcYLast = (UINT) -1;

        while(uDestY < m_pDest->m_uHeight)
        {
            UINT uSrcX  = 0;
            UINT uDestX = 0;

            if((uSrcYLast ^ uSrcY) >> 16)
            {
                m_pSrc->Decode(uSrcY >> 16, uSrcZ >> 16, pSrc);
                uSrcYLast = uSrcY;
            }

            while(uDestX < m_pDest->m_uWidth)
            {
                pDest[uDestX] = pSrc[uSrcX >> 16];

                uSrcX += uSrcXInc;
                uDestX++;
            }

            m_pDest->Encode(uDestY, uDestZ, pDest);

            uSrcY += uSrcYInc;
            uDestY++;
        }

        uSrcZ += uSrcZInc;
        uDestZ++;
    }

    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}


HRESULT CXD3DXBlt::BltBox2D()
{
    HRESULT hr;

    D3DXCOLOR *pxyz, *pxYz, *pXyz, *pXYz;
    D3DXCOLOR *pSrc, *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_BOX)
        return E_FAIL;

    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(!(m_pDest->m_uWidth == (m_pSrc->m_uWidth >> 1)) && 
       !(1 == m_pDest->m_uWidth && 1 == m_pSrc->m_uWidth))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uHeight == (m_pSrc->m_uHeight >> 1)) && 
       !(1 == m_pDest->m_uHeight && 1 == m_pSrc->m_uHeight))
    {
        return E_FAIL;
    }

    if(!(1 == m_pDest->m_uDepth && 1 == m_pSrc->m_uDepth))
        return E_FAIL;

//  DPF(0, "blt box %d->%d", m_pSrc->m_Format, m_pDest->m_Format);



    // Optimized filters
    if(!(m_dwFilter & D3DX_FILTER_DITHER) && (m_pSrc->m_Format == m_pDest->m_Format) && 
        (m_pSrc->m_uWidth >= 2) && (m_pSrc->m_uHeight >= 2))
    {
        hr = E_NOTIMPL;

        switch(m_pSrc->m_Format)
        {
#if 0
        case D3DFMT_R8G8B8:   hr = BltBox2D_R8G8B8();   break;
        case D3DFMT_R3G3B2:   hr = BltBox2D_R3G3B2();   break;
        case D3DFMT_A8R3G3B2: hr = BltBox2D_A8R3G3B2(); break;
        case D3DFMT_X4R4G4B4: hr = BltBox2D_X4R4G4B4(); break;
        case D3DFMT_A8P8:     hr = BltBox2D_A8P8();     break;
        case D3DFMT_A4L4:     hr = BltBox2D_A4L4();     break;
#endif
        case D3DFMT_A8R8G8B8: hr = BltBox2D_A8R8G8B8(); break;
        case D3DFMT_X8R8G8B8: hr = BltBox2D_X8R8G8B8(); break;
        case D3DFMT_R5G6B5:   hr = BltBox2D_R5G6B5();   break;
        case D3DFMT_X1R5G5B5: hr = BltBox2D_X1R5G5B5(); break;
        case D3DFMT_A1R5G5B5: hr = BltBox2D_A1R5G5B5(); break;
        case D3DFMT_A4R4G4B4: hr = BltBox2D_A4R4G4B4(); break;
        case D3DFMT_A8:       hr = BltBox2D_A8();       break;
        case D3DFMT_P8:       hr = BltBox2D_P8();       break;
        case D3DFMT_L8:       hr = BltBox2D_A8();       break;
        case D3DFMT_A8L8:     hr = BltBox2D_A8L8();     break;
        }

        if(SUCCEEDED(hr))
            return S_OK;
    }


    // Generic filter
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_OUTOFMEMORY;

    if(1 == m_pSrc->m_uHeight)
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth];

        pxyz = pSrc;
        pxYz = pxyz;
    }
    else
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxYz = pSrc + m_pSrc->m_uWidth * 1;
    }

    if(!pSrc)
    {
        delete [] pDest;
        return E_OUTOFMEMORY;
    }

    if(1 == m_pSrc->m_uWidth)
    {
        pXyz = pxyz;
        pXYz = pxYz;
    }
    else
    {
        pXyz = pxyz + 1;
        pXYz = pxYz + 1;
    }


    for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
    {
        UINT uY2 = uY << 1;

        m_pSrc->Decode(uY2 + 0, 0, pxyz);

        if(pxYz != pxyz)
            m_pSrc->Decode(uY2 + 1, 0, pxYz);


        for(UINT uX = 0; uX < m_pDest->m_uWidth; uX++)
        {
            UINT uX2 = uX << 1;
            pDest[uX] = (pxyz[uX2] + pXyz[uX2] + pxYz[uX2] + pXYz[uX2]) * 0.25f;
        }

        m_pDest->Encode(uY, 0, pDest);
    }


    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}



HRESULT CXD3DXBlt::BltBox3D()
{
    D3DXCOLOR *pxyz, *pxyZ, *pxYz, *pxYZ, *pXyz, *pXyZ, *pXYz, *pXYZ;
    D3DXCOLOR *pSrc, *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_BOX)
        return E_FAIL;

    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(!(m_pDest->m_uWidth == (m_pSrc->m_uWidth >> 1)) && 
       !(1 == m_pDest->m_uWidth && 1 == m_pSrc->m_uWidth))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uHeight == (m_pSrc->m_uHeight >> 1)) && 
       !(1 == m_pDest->m_uHeight && 1 == m_pSrc->m_uHeight))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uDepth == (m_pSrc->m_uDepth >> 1)))
        return E_FAIL;

//  DPF(0, "blt box %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_OUTOFMEMORY;

    if(1 == m_pSrc->m_uHeight)
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxyZ = pSrc + m_pSrc->m_uWidth * 1;
        pxYz = pxyz;
        pxYZ = pxyZ;
    }
    else
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 4];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxyZ = pSrc + m_pSrc->m_uWidth * 1;
        pxYz = pSrc + m_pSrc->m_uWidth * 2;
        pxYZ = pSrc + m_pSrc->m_uWidth * 3;
    }

    if(!pSrc)
    {
        delete [] pDest;
        return E_OUTOFMEMORY;
    }

    if(1 == m_pSrc->m_uWidth)
    {
        pXyz = pxyz;
        pXyZ = pxyZ;
        pXYz = pxYz;
        pXYZ = pxYZ;
    }
    else
    {
        pXyz = pxyz + 1;
        pXyZ = pxyZ + 1;
        pXYz = pxYz + 1;
        pXYZ = pxYZ + 1;
    }



    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        UINT uZ2 = uZ << 1;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            UINT uY2 = uY << 1;

            m_pSrc->Decode(uY2 + 0, uZ2 + 0, pxyz);

            if(pxyZ != pxyz)
                m_pSrc->Decode(uY2 + 0, uZ2 + 1, pxyZ);

            if(pxYz != pxyz)
                m_pSrc->Decode(uY2 + 1, uZ2 + 0, pxYz);

            if(pxYZ != pxyZ && pxYZ != pxYz)
                m_pSrc->Decode(uY2 + 1, uZ2 + 1, pxYZ);


            for(UINT uX = 0; uX < m_pDest->m_uWidth; uX++)
            {
                UINT uX2 = uX << 1;

                pDest[uX] = (pxyz[uX2] + pXyz[uX2] + pxyZ[uX2] + pXyZ[uX2] +
                             pxYz[uX2] + pXYz[uX2] + pxYZ[uX2] + pXYZ[uX2]) * 0.125f;
            }

            m_pDest->Encode(uY, uZ, pDest);
        }
    }

    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}



// ---------------------------------------------------------------------------
//
// LF - Linear filter
//
// This section of the code defines a bunch of structures, macros, and
// functions which are used for the linear filter.
//
// ---------------------------------------------------------------------------

struct LF_From
{
    UINT uFrom;
    float fWeight;
};

struct LF_To
{
    LF_From pFrom[2];
};


static UINT8 *
LF_SetupLinear(UINT uSrcLim, UINT uDstLim, BOOL bRepeat)
{
    LF_To *pTo;
    UINT8 *pbFilter;
    
    if(!(pTo = new LF_To[uDstLim]))
        return NULL;

    pbFilter = (UINT8 *) pTo;
    float fScale = (float) uSrcLim / (float) uDstLim;

    F2IBegin();

    for(UINT u = 0; u < uDstLim; u++)
    {
        float fSrc = (float) u * fScale - 0.5f;
        float fSrcFloor = floorf(fSrc);

        int iSrcA = F2I(fSrcFloor);
        int iSrcB = iSrcA + 1;

        if(iSrcA < 0)
            iSrcA = bRepeat ? uSrcLim - 1 : 0;

        if((UINT) iSrcB >= uSrcLim)
            iSrcB = bRepeat ? 0 : uSrcLim - 1;

        pTo->pFrom[0].uFrom   = (UINT) iSrcA;
        pTo->pFrom[0].fWeight = 1.0f - (fSrc - fSrcFloor);

        pTo->pFrom[1].uFrom   = (UINT) iSrcB;
        pTo->pFrom[1].fWeight = 1.0f - pTo->pFrom[0].fWeight;

        pTo++;
    }

    F2IEnd();

    return pbFilter;
}


HRESULT CXD3DXBlt::BltLinear2D()
{
    HRESULT hr;

    BOOL bRepeatX;
    BOOL bRepeatY;

    BYTE *pbXFilter = NULL;
    BYTE *pbYFilter = NULL;

    LF_To *pToX;
    LF_To *pToY;

    D3DXCOLOR *pDest = NULL;
    D3DXCOLOR *pSrc  = NULL;
    D3DXCOLOR *pSrcT;
    D3DXCOLOR *pxyz, *pxYz;

    UINT uX;
    UINT uY;
    UINT uFrom0;
    UINT uFrom1;


    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if((m_dwFilter & 0xff) != D3DX_FILTER_LINEAR)
        return E_FAIL;

//  DPF(0, "blt linear %d->%d", m_pSrc->m_Format, m_pDest->m_Format);


    // Create linear filters
    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);

    pbXFilter = LF_SetupLinear(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX);
    pbYFilter = LF_SetupLinear(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY);

    if(!pbXFilter || !pbYFilter)
        goto LOutOfMemory;


    // Create temp color space
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        goto LOutOfMemory;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2]))
        goto LOutOfMemory;

    pxyz = pSrc + m_pSrc->m_uWidth * 0;
    pxYz = pSrc + m_pSrc->m_uWidth * 1;



    uY = 0;
    pToY = (LF_To *) pbYFilter;

    uFrom0 = (UINT) -1;
    uFrom1 = (UINT) -1;

    while(uY < m_pDest->m_uHeight)
    {
        uX = 0;
        pToX = (LF_To *) pbXFilter;

        if(pToY->pFrom[0].uFrom != uFrom0)
        {
            if(pToY->pFrom[0].uFrom != uFrom1)
            {
                uFrom0 = pToY->pFrom[0].uFrom;
                m_pSrc->Decode(uFrom0, 0, pxyz);
            }
            else
            {
                uFrom0 = uFrom1;
                uFrom1 = (UINT) -1;

                pSrcT = pxyz; pxyz = pxYz; pxYz = pSrcT;
            }
        }

        if(pToY->pFrom[1].uFrom != uFrom1)
        {
            uFrom1 = pToY->pFrom[1].uFrom;
            m_pSrc->Decode(uFrom1, 0, pxYz);
        }

        while(uX < m_pDest->m_uWidth)
        {
            pDest[uX] = ((pxyz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                          pxyz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                         (pxYz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                          pxYz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight);

            pToX++;
            uX++;
        }

        m_pDest->Encode(uY, 0, pDest);

        pToY++;
        uY++;
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    delete [] pbXFilter;
    delete [] pbYFilter;

    delete [] pDest;
    delete [] pSrc;

    return hr;
}




HRESULT CXD3DXBlt::BltLinear3D()
{
    HRESULT hr;

    BOOL bRepeatX;
    BOOL bRepeatY;
    BOOL bRepeatZ;

    BYTE *pbXFilter = NULL;
    BYTE *pbYFilter = NULL;
    BYTE *pbZFilter = NULL;

    LF_To *pToX;
    LF_To *pToY;
    LF_To *pToZ;

    D3DXCOLOR *pDest = NULL;
    D3DXCOLOR *pSrc  = NULL;
    D3DXCOLOR *pSrcT;
    D3DXCOLOR *pxyz, *pxYz, *pxyZ, *pxYZ;

    UINT uX;
    UINT uY;
    UINT uZ;
    UINT uFrom0;
    UINT uFrom1;


    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if((m_dwFilter & 0xff) != D3DX_FILTER_LINEAR)
        return E_FAIL;

//  DPF(0, "blt linear %d->%d", m_pSrc->m_Format, m_pDest->m_Format);


    // Create linear filters
    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);
    bRepeatZ = !(m_dwFilter & D3DX_FILTER_MIRROR_W);

    pbXFilter = LF_SetupLinear(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX);
    pbYFilter = LF_SetupLinear(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY);
    pbZFilter = LF_SetupLinear(m_pSrc->m_uDepth,  m_pDest->m_uDepth,  bRepeatZ);

    if(!pbXFilter || !pbYFilter || !pbZFilter)
        goto LOutOfMemory;


    // Create temp color space
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        goto LOutOfMemory;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 4]))
        goto LOutOfMemory;

    pxyz = pSrc + m_pSrc->m_uWidth * 0;
    pxYz = pSrc + m_pSrc->m_uWidth * 1;
    pxyZ = pSrc + m_pSrc->m_uWidth * 2;
    pxYZ = pSrc + m_pSrc->m_uWidth * 3;



    uZ = 0;
    pToZ = (LF_To *) pbZFilter;

    while(uZ < m_pDest->m_uDepth)
    {
        uY = 0;
        pToY = (LF_To *) pbYFilter;
        uFrom0 = (UINT) -1;
        uFrom1 = (UINT) -1;


        while(uY < m_pDest->m_uHeight)
        {
            uX = 0;
            pToX = (LF_To *) pbXFilter;

            if(pToY->pFrom[0].uFrom != uFrom0)
            {
                if(pToY->pFrom[0].uFrom != uFrom1)
                {
                    uFrom0 = pToY->pFrom[0].uFrom;

                    m_pSrc->Decode(uFrom0, pToZ->pFrom[0].uFrom, pxyz);
                    m_pSrc->Decode(uFrom0, pToZ->pFrom[1].uFrom, pxyZ);
                }
                else
                {
                    uFrom0 = uFrom1;
                    uFrom1 = (UINT) -1;

                    pSrcT = pxyz; pxyz = pxYz; pxYz = pSrcT;
                    pSrcT = pxyZ; pxyZ = pxYZ; pxYZ = pSrcT;
                }
            }

            if(pToY->pFrom[1].uFrom != uFrom1)
            {
                uFrom1 = pToY->pFrom[1].uFrom;

                m_pSrc->Decode(uFrom1, pToZ->pFrom[0].uFrom, pxYz);
                m_pSrc->Decode(uFrom1, pToZ->pFrom[1].uFrom, pxYZ);
            }


            while(uX < m_pDest->m_uWidth)
            {
                pDest[uX] = ((pxyz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxyz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                             (pxYz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxYz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight) * pToZ->pFrom[0].fWeight +

                            ((pxyZ[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxyZ[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                             (pxYZ[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxYZ[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight) * pToZ->pFrom[1].fWeight;

                pToX++;
                uX++;
            }

            m_pDest->Encode(uY, uZ, pDest);

            pToY++;
            uY++;
        }

        pToZ++;
        uZ++;
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    delete [] pbXFilter;
    delete [] pbYFilter;
    delete [] pbZFilter;

    delete [] pDest;
    delete [] pSrc;

    return hr;
}




// ---------------------------------------------------------------------------
//
// TF - Triangle filter
//
// This section of the code defines a bunch of structures, macros, and
// functions which are used for the triangle filter.
//
// ---------------------------------------------------------------------------

#define TF_EPSILON 0.00001f

struct TF_To
{
    UINT uTo;           // mapping
    FLOAT fWeight;      // mapping weight
};

struct TF_From
{
    UINT uSize;         // size, in bytes
    TF_To pTo[1];       // may continue past 1
};

struct TF_Filter
{
    UINT uSize;         // size, in bytes
    TF_From pFrom[1];   // may continue past 1
};

struct TF_Row
{
    D3DXCOLOR *pclr;    // row data
    FLOAT fWeight;
    TF_Row *pNext;

    ~TF_Row() {
        delete [] pclr;
        delete pNext;
    }
};


static const UINT TF_uFilterSize = sizeof(TF_Filter) - sizeof(TF_From);
static const UINT TF_uFromSize   = sizeof(TF_From) - sizeof(TF_To);
static const UINT TF_uToSize     = sizeof(TF_To);


//
// Setup a triangle filter.  Each source pixel contriubtes equally to the
// destination image.
//

static UINT8 *
TF_SetupTriangle(UINT uSrcLim, UINT uDstLim, BOOL bRepeat)
{
    if(!uSrcLim || !uDstLim)
        return NULL;


    // Compute scale
    FLOAT fScale = (FLOAT) uDstLim / (FLOAT) uSrcLim;
    FLOAT f2ScaleInv = 0.5f / fScale;



    // Allocate memory needed to describe the filter.
    UINT uSizeMax = TF_uFilterSize + TF_uFromSize + TF_uToSize;
    UINT uRepeat = bRepeat ? 1 : 0;

    for(UINT uSrc = 0; uSrc < uSrcLim; uSrc++)
    {
        FLOAT fSrc = (FLOAT) uSrc - 0.5f;
        FLOAT fDstMin = fSrc * fScale;
        FLOAT fDstLim = fDstMin + fScale;

        uSizeMax += TF_uFromSize + TF_uToSize +
            (UINT) (fDstLim - fDstMin + uRepeat + 1) * TF_uToSize * 2;
    }

    UINT8 *pbFilter = new UINT8[uSizeMax];

    if(!pbFilter)
        return NULL;


    // Initialize filter
    UINT uSize = TF_uFilterSize;

    // Initialize accumulators
    UINT uAccumDst = 0;
    FLOAT fAccumWeight = 0.0f;



    for(uSrc = 0; uSrc < uSrcLim; uSrc++)
    {
        // Initialize TF_From block
        UINT uSizeFrom = uSize;
        TF_From *pFrom = (TF_From *) (pbFilter + uSize);
        uSize += TF_uFromSize;
        D3DXASSERT(uSize <= uSizeMax);


        // For each source pixel, we perform two passes.  During the first
        // pass, we record the influences due to this source pixel as we
        // approach it.  During the second pass, we record the influences
        // as we move away from it.

        for(UINT uPass = 0; uPass < 2; uPass++)
        {
            FLOAT fSrc = ((FLOAT) uSrc + uPass) - 0.5f;

            // Start and end of source pixel, in destination coordinates
            FLOAT fDstMin = fSrc * fScale;
            FLOAT fDstLim = fDstMin + fScale;


            // Clamp source pixel to destination image.
            if(!bRepeat)
            {
                if(fDstMin < 0.0f)
                    fDstMin = 0.0f;
                if(fDstLim > (FLOAT) uDstLim)
                    fDstLim = (FLOAT) uDstLim;
            }

            // Start of first destination pixel
            INT nDst = (INT) floorf(fDstMin);



            while((FLOAT) nDst < fDstLim)
            {
                FLOAT fDst0 = (FLOAT) nDst;
                FLOAT fDst1 = fDst0 + 1.0f;

                UINT uDst;
                if(nDst < 0)
                    uDst = (UINT) nDst + uDstLim;
                else if(nDst >= (INT) uDstLim)
                    uDst = (UINT) nDst - uDstLim;
                else
                    uDst = (UINT) nDst;


                // Save the accumulated weight from uAccumDst if we have moved
                // on to accumulating for the next pixel.

                if(uDst != uAccumDst)
                {
                    if(fAccumWeight > TF_EPSILON)
                    {
                        TF_To *pTo  = (TF_To *) (pbFilter + uSize);
                        uSize += TF_uToSize;

                        D3DXASSERT(uSize <= uSizeMax);

                        pTo->uTo = uAccumDst;
                        pTo->fWeight = fAccumWeight;

                    }

                    fAccumWeight = 0.0f;
                    uAccumDst = uDst;
                }


                // Clip destination pixel to source pixel.
                if(fDst0 < fDstMin)
                    fDst0 = fDstMin;
                if(fDst1 > fDstLim)
                    fDst1 = fDstLim;


                // Calculate average weight over destination pixel.  Since the
                // weight varies linearly, when the average weight is
                // multiplied by the size of the destination pixel, the result
                // is equal to the integral of the weight over this portion of
                // the pixel.

                FLOAT fWeight;
                if(!bRepeat && fSrc < 0.0f)
                    fWeight = 1.0f;
                else if(!bRepeat && fSrc + 1.0f >= (FLOAT) uSrcLim)
                    fWeight = 0.0f;
                else
                    fWeight = (fDst0 + fDst1) * f2ScaleInv - fSrc;

                fAccumWeight += (fDst1 - fDst0) * (uPass ? 1.0f - fWeight : fWeight);
                nDst++;
            }
        }


        // If there is a valid value still in the accumulator, it needs to be
        // written out.

        if(fAccumWeight > TF_EPSILON)
        {
            TF_To *pTo = (TF_To *) (pbFilter + uSize);
            uSize += TF_uToSize;

            D3DXASSERT(uSize <= uSizeMax);

            pTo->uTo = uAccumDst;
            pTo->fWeight = fAccumWeight;
        }

        fAccumWeight = 0.0f;


        // Record TF_From's size
        pFrom->uSize = uSize - uSizeFrom;
    }


    // Record TF_Filter's size
    ((TF_Filter *) pbFilter)->uSize = uSize;

    return pbFilter;
}




HRESULT
CXD3DXBlt::BltTriangle2D()
{
    HRESULT hr;
    UINT8 *pbXFilter, *pbYFilter;
    TF_Filter *pXFilter, *pYFilter;
    TF_From *pXFrom, *pYFrom, *pXFromLim, *pYFromLim;
    TF_To *pXTo, *pYTo, *pXToLim, *pYToLim;
    TF_Row *pRow, **ppRowActive, *pRowFree;
    BOOL bRepeatX, bRepeatY;
    UINT uRowsActive;
    UINT uSrcRow;
    D3DXCOLOR *pclrSrc;
    D3DXCOLOR *pclrPal;


    pbXFilter   = NULL;
    pbYFilter   = NULL;
    ppRowActive = NULL;
    pRowFree    = NULL;
    pclrSrc     = NULL;
    pclrPal     = NULL;


//  DPF(0, "blt triangle %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    // Create filters for each axis
    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(m_pDest->m_uDepth != 1 || m_pSrc->m_uDepth != 1)
        return E_FAIL;

    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);

    if(!(pbXFilter = TF_SetupTriangle(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX)) ||
       !(pbYFilter = TF_SetupTriangle(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY)))
    {
        hr = E_FAIL;
        goto LDone;
    }



    pXFilter = (TF_Filter *) pbXFilter;
    pYFilter = (TF_Filter *) pbYFilter;

    pXFromLim = (TF_From *) ((UINT8 *) pXFilter + pXFilter->uSize);
    pYFromLim = (TF_From *) ((UINT8 *) pYFilter + pYFilter->uSize);


    // Initialize accumulation rows
    if(!(ppRowActive = new TF_Row* [m_pDest->m_uHeight]))
        goto LOutOfMemory;

    memset(ppRowActive, 0, m_pDest->m_uHeight * sizeof(TF_Row *));
    uRowsActive = 0;

    if(!(pclrSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        goto LOutOfMemory;



    // Filter image
    uSrcRow = 0;

    for(pYFrom = pYFilter->pFrom; pYFrom < pYFromLim; pYFrom = (TF_From *) pYToLim)
    {
        D3DXCOLOR *pclrSrcX;

        pYToLim = (TF_To *) ((UINT8 *) pYFrom + pYFrom->uSize);

        if(pYFrom->pTo < pYToLim)
        {

            // Create necessary accumulation rows
            for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
            {
                if(!(pRow = ppRowActive[pYTo->uTo]))
                {
                    if(pRowFree)
                    {
                        // Reuse a row
                        pRow = pRowFree;
                        pRowFree = pRow->pNext;
                    }
                    else
                    {
                        // Allocate a new row
                        if(!(pRow = new TF_Row))
                            goto LOutOfMemory;

                        if(!(pRow->pclr = new D3DXCOLOR[m_pDest->m_uWidth]))
                        {
                            delete pRow;
                            goto LOutOfMemory;
                        }
                    }

                    memset(pRow->pclr, 0, m_pDest->m_uWidth * sizeof(D3DXCOLOR));
                    pRow->fWeight = 0.0f;
                    pRow->pNext = NULL;

                    ppRowActive[pYTo->uTo] = pRow;
                    uRowsActive++;
                }
            }


            // Read source pixels
            m_pSrc->Decode(uSrcRow, 0, pclrSrc);


            // Process a row from the source image
            pclrSrcX = pclrSrc;
            for(pXFrom = pXFilter->pFrom; pXFrom < pXFromLim; pXFrom = (TF_From *) pXToLim)
            {
                pXToLim = (TF_To *) ((UINT8 *) pXFrom + pXFrom->uSize);

                for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
                {
                    pRow = ppRowActive[pYTo->uTo];

                    for(pXTo = pXFrom->pTo; pXTo < pXToLim; pXTo++)
                    {
                        FLOAT fWeight =  pYTo->fWeight * pXTo->fWeight;

                        pRow->pclr[pXTo->uTo].r += pclrSrcX->r * fWeight;
                        pRow->pclr[pXTo->uTo].g += pclrSrcX->g * fWeight;
                        pRow->pclr[pXTo->uTo].b += pclrSrcX->b * fWeight;
                        pRow->pclr[pXTo->uTo].a += pclrSrcX->a * fWeight;
                    }
                }

                pclrSrcX++;
            }


            // Write completed accumulation rows
            for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
            {
                pRow = ppRowActive[pYTo->uTo];
                pRow->fWeight += pYTo->fWeight;

                if(pRow->fWeight + TF_EPSILON >= 1.0f)
                {
                    // Write and free row
                    m_pDest->Encode(pYTo->uTo, 0, pRow->pclr);

                    ppRowActive[pYTo->uTo] = NULL;
                    pRow->pNext = pRowFree;
                    pRowFree = pRow;

                    uRowsActive--;
                }
            }
        }

        uSrcRow++;
    }


    // Make sure that all accumulation rows have been written out.  This should
    // only happen if the filter was not constructed correctly.
    if(uRowsActive)
    {
        for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
        {
            if(ppRowActive[uRow])
            {
                // Write and delete row
                m_pDest->Encode(uRow, 0, ppRowActive[uRow]->pclr);
                delete ppRowActive[uRow];

                if(--uRowsActive == 0)
                    break;
            }
        }
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    // Clean up
    delete[] ppRowActive;
    delete pRowFree;

    delete [] pbYFilter;
    delete [] pbXFilter;
    delete [] pclrSrc;
    delete [] pclrPal;

    return hr;
}



HRESULT
CXD3DXBlt::BltTriangle3D()
{
    HRESULT hr;
    UINT8 *pbXFilter, *pbYFilter, *pbZFilter;
    TF_Filter *pXFilter, *pYFilter, *pZFilter;
    TF_From *pXFrom, *pYFrom, *pZFrom, *pXFromLim, *pYFromLim, *pZFromLim;
    TF_To *pXTo, *pYTo, *pZTo, *pXToLim, *pYToLim, *pZToLim;
    TF_Row *pSlice, **ppSliceActive, *pSliceFree;
    BOOL bRepeatX, bRepeatY, bRepeatZ;
    UINT uSlicesActive;
    UINT uSrcRow, uSrcSlice;
    D3DXCOLOR *pclrSrc;
    D3DXCOLOR *pclrPal;


    pbXFilter     = NULL;
    pbYFilter     = NULL;
    pbZFilter     = NULL;
    ppSliceActive = NULL;
    pSliceFree    = NULL;
    pclrSrc       = NULL;
    pclrPal       = NULL;


//  DPF(0, "blt triangle %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    // Create filters for each axis
    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);
    bRepeatZ = !(m_dwFilter & D3DX_FILTER_MIRROR_W);

    if(!(pbXFilter = TF_SetupTriangle(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX)) ||
       !(pbYFilter = TF_SetupTriangle(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY)) ||
       !(pbZFilter = TF_SetupTriangle(m_pSrc->m_uDepth,  m_pDest->m_uDepth,  bRepeatZ)))
    {
        hr = E_FAIL;
        goto LDone;
    }



    pXFilter = (TF_Filter *) pbXFilter;
    pYFilter = (TF_Filter *) pbYFilter;
    pZFilter = (TF_Filter *) pbZFilter;

    pXFromLim = (TF_From *) ((UINT8 *) pXFilter + pXFilter->uSize);
    pYFromLim = (TF_From *) ((UINT8 *) pYFilter + pYFilter->uSize);
    pZFromLim = (TF_From *) ((UINT8 *) pZFilter + pZFilter->uSize);


    // Initialize accumulation slices
    if(!(ppSliceActive = new TF_Row* [m_pDest->m_uDepth]))
        goto LOutOfMemory;

    memset(ppSliceActive, 0, m_pDest->m_uDepth * sizeof(TF_Row *));
    uSlicesActive = 0;

    if(!(pclrSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        goto LOutOfMemory;



    // Filter image
    uSrcSlice = 0;
    for(pZFrom = pZFilter->pFrom; pZFrom < pZFromLim; pZFrom = (TF_From *) pZToLim)
    {
        pZToLim = (TF_To *) ((UINT8 *) pZFrom + pZFrom->uSize);

        // Create necessary accumulation slices
        for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
        {
            if(!(pSlice = ppSliceActive[pZTo->uTo]))
            {
                if(pSliceFree)
                {
                    // Reuse a row
                    pSlice = pSliceFree;
                    pSliceFree = pSlice->pNext;
                }
                else
                {
                    // Allocate a new row
                    if(!(pSlice = new TF_Row))
                        goto LOutOfMemory;

                    if(!(pSlice->pclr = new D3DXCOLOR[m_pDest->m_uWidth * m_pDest->m_uHeight]))
                    {
                        delete pSlice;
                        goto LOutOfMemory;
                    }
                }

                memset(pSlice->pclr, 0, m_pDest->m_uWidth * m_pDest->m_uHeight * sizeof(D3DXCOLOR));
                pSlice->fWeight = 0.0f;
                pSlice->pNext = NULL;

                ppSliceActive[pZTo->uTo] = pSlice;
                uSlicesActive++;
            }
        }

        uSrcRow = 0;
        for(pYFrom = pYFilter->pFrom; pYFrom < pYFromLim; pYFrom = (TF_From *) pYToLim)
        {

            pYToLim = (TF_To *) ((UINT8 *) pYFrom + pYFrom->uSize);

            // Read source pixels
            m_pSrc->Decode(uSrcRow, uSrcSlice, pclrSrc);


            // Process a row from the source image
            D3DXCOLOR *pclrSrcX, *pclrDest;
            pclrSrcX = pclrSrc;

            for(pXFrom = pXFilter->pFrom; pXFrom < pXFromLim; pXFrom = (TF_From *) pXToLim)
            {
                pXToLim = (TF_To *) ((UINT8 *) pXFrom + pXFrom->uSize);

                for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
                {
                    for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
                    {
                        pclrDest = ppSliceActive[pZTo->uTo]->pclr + pYTo->uTo * m_pDest->m_uWidth;

                        for(pXTo = pXFrom->pTo; pXTo < pXToLim; pXTo++)
                        {
                            FLOAT fWeight = pZTo->fWeight * pYTo->fWeight * pXTo->fWeight;

                            pclrDest[pXTo->uTo].r += pclrSrcX->r * fWeight;
                            pclrDest[pXTo->uTo].g += pclrSrcX->g * fWeight;
                            pclrDest[pXTo->uTo].b += pclrSrcX->b * fWeight;
                            pclrDest[pXTo->uTo].a += pclrSrcX->a * fWeight;
                        }
                    }
                }

                pclrSrcX++;
            }

            uSrcRow++;
        }


        // Write completed accumulation slices
        for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
        {
            pSlice = ppSliceActive[pZTo->uTo];
            pSlice->fWeight += pZTo->fWeight;

            if(pSlice->fWeight + TF_EPSILON >= 1.0f)
            {
                // Write and free slice                
                for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
                    m_pDest->Encode(uRow, pZTo->uTo, pSlice->pclr + uRow * m_pDest->m_uWidth);

                ppSliceActive[pZTo->uTo] = NULL;
                pSlice->pNext = pSliceFree;
                pSliceFree = pSlice;

                uSlicesActive--;
            }
        }

        uSrcSlice++;
    }


    // Make sure that all accumulation slices have been written out.  This should
    // only happen if the filter was not constructed correctly.
    if(uSlicesActive)
    {
        for(UINT uSlice = 0; uSlice < m_pDest->m_uDepth; uSlice++)
        {
            if(ppSliceActive[uSlice])
            {
                // Write and delete slice
                for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
                    m_pDest->Encode(uRow, uSlice, pSlice->pclr + uRow * m_pDest->m_uWidth);

                delete ppSliceActive[uSlice];

                if(--uSlicesActive == 0)
                    break;
            }
        }
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    // Clean up
    delete[] ppSliceActive;
    delete pSliceFree;

    delete [] pbZFilter;
    delete [] pbYFilter;
    delete [] pbXFilter;
    delete [] pclrSrc;
    delete [] pclrPal;

    return hr;
}




// ---------------------------------------------------------------------------
//
// Optimized filters
//
// ---------------------------------------------------------------------------

#ifdef SUPPORT_DXT
HRESULT CXD3DXBlt::BltSame_DXTn()
{
    if((m_pSrc->m_Box.Left  | m_pSrc->m_Box.Top  | m_pSrc->m_Box.Right  | m_pSrc->m_Box.Bottom)  & 3)
        return E_FAIL;

    if((m_pDest->m_Box.Left | m_pDest->m_Box.Top | m_pDest->m_Box.Right | m_pDest->m_Box.Bottom) & 3)
        return E_FAIL;


    // Calculate block size and width
    UINT cbBlock, cbWidth;

    switch(m_pDest->m_Format)
    {
    case D3DFMT_DXT1:
        cbBlock = sizeof(S3TCBlockRGB);
        break;

    case D3DFMT_DXT2:
#if 0
    case D3DFMT_DXT3:
#endif
        cbBlock = sizeof(S3TCBlockAlpha4);
        break;

    case D3DFMT_DXT4:
#if 0
    case D3DFMT_DXT5:
#endif
        cbBlock = sizeof(S3TCBlockAlpha3);
        break;

    default:
        return E_FAIL;
    }


    cbWidth = (m_pDest->m_uWidth >> 2) * cbBlock;


    // Copy DXTn blocks
    BYTE *pbSliceDest = m_pDest->m_pbData + (m_pDest->m_Box.Left >> 2) * cbBlock + 
        (m_pDest->m_Box.Top >> 2) * m_pDest->m_uPitch + m_pDest->m_Box.Front * m_pDest->m_uSlice;

    BYTE *pbSliceSrc = m_pSrc->m_pbData + (m_pSrc->m_Box.Left >> 2) * cbBlock + 
        (m_pSrc->m_Box.Top >> 2) * m_pSrc->m_uPitch + m_pSrc->m_Box.Front * m_pSrc->m_uSlice;


    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        BYTE *pbDest = pbSliceDest;
        BYTE *pbSrc  = pbSliceSrc;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY += 4)
        {
            memcpy(pbDest, pbSrc, cbWidth);

            pbDest += m_pDest->m_uPitch;
            pbSrc  += m_pSrc ->m_uPitch;
        }

        pbSliceDest += m_pDest->m_uSlice;
        pbSliceDest += m_pSrc ->m_uSlice;
    }

    return S_OK;
}
#endif // SUPPORT_DXT


HRESULT 
CXD3DXBlt::BltBox2D_R8G8B8()
{
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8R8G8B8()
{
    UINT32 *pulDest   = (UINT32 *) m_pDest->m_pbData;
    UINT32 *pulSrc    = (UINT32 *) m_pSrc->m_pbData;
    UINT32 *pulSrcLim = (UINT32 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pulSrc < pulSrcLim)
    {
        UINT32 *pul     = pulDest;
        UINT32 *pulA    = pulSrc;
        UINT32 *pulB    = (UINT32 *) ((BYTE *) pulA + m_pSrc->m_uPitch);
        UINT32 *pulALim = pulA + m_pSrc->m_uWidth;

        while(pulA < pulALim)
        {
            *pul++ = (((((pulA[0] & 0x00ff00ff) + (pulA[1] & 0x00ff00ff) + 
                         (pulB[0] & 0x00ff00ff) + (pulB[1] & 0x00ff00ff)) + 0x00020002) >> 2) & 0x00ff00ff) |

                     (((((pulA[0] & 0xff00ff00) >> 2) + ((pulA[1] & 0xff00ff00) >> 2) +
                        ((pulB[0] & 0xff00ff00) >> 2) + ((pulB[1] & 0xff00ff00) >> 2)) + (0x02000200 >> 2)) & 0xff00ff00);

            pulA += 2;
            pulB += 2;
        }

        pulDest = (UINT32 *) ((BYTE *) pulDest + m_pDest->m_uPitch);
        pulSrc  = (UINT32 *) ((BYTE *) pulSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_X8R8G8B8()
{
    UINT32 *pulDest   = (UINT32 *) m_pDest->m_pbData;
    UINT32 *pulSrc    = (UINT32 *) m_pSrc->m_pbData;
    UINT32 *pulSrcLim = (UINT32 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pulSrc < pulSrcLim)
    {
        UINT32 *pul     = pulDest;
        UINT32 *pulA    = pulSrc;
        UINT32 *pulB    = (UINT32 *) ((BYTE *) pulA + m_pSrc->m_uPitch);
        UINT32 *pulALim = pulA + m_pSrc->m_uWidth;

        while(pulA < pulALim)
        {
            *pul++ = ((((pulA[0] & 0x00ff00ff) + (pulA[1] & 0x00ff00ff) + 
                        (pulB[0] & 0x00ff00ff) + (pulB[1] & 0x00ff00ff) + 0x00020002) & (0x00ff00ff << 2)) |

                      (((pulA[0] & 0x0000ff00) + (pulA[1] & 0x0000ff00) +
                        (pulB[0] & 0x0000ff00) + (pulB[1] & 0x0000ff00) + 0x00000200) & (0x0000ff00 << 2))) >> 2;

            pulA += 2;
            pulB += 2;
        }

        pulDest = (UINT32 *) ((BYTE *) pulDest + m_pDest->m_uPitch);
        pulSrc  = (UINT32 *) ((BYTE *) pulSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_R5G6B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0xf81f) + ((UINT32) pusA[1] & 0xf81f) + 
                                  ((UINT32) pusB[0] & 0xf81f) + ((UINT32) pusB[1] & 0xf81f) + 0x1002) & (0xf81f << 2)) |

                                ((((UINT32) pusA[0] & 0x07e0) + ((UINT32) pusA[1] & 0x07e0) + 
                                  ((UINT32) pusB[0] & 0x07e0) + ((UINT32) pusB[1] & 0x07e0) + 0x0040) & (0x07e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_X1R5G5B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x7c1f) + ((UINT32) pusA[1] & 0x7c1f) + 
                                  ((UINT32) pusB[0] & 0x7c1f) + ((UINT32) pusB[1] & 0x7c1f) + 0x0802) & (0x7c1f << 2)) |

                                ((((UINT32) pusA[0] & 0x03e0) + ((UINT32) pusA[1] & 0x03e0) + 
                                  ((UINT32) pusB[0] & 0x03e0) + ((UINT32) pusB[1] & 0x03e0) + 0x0040) & (0x03e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A1R5G5B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x7c1f) + ((UINT32) pusA[1] & 0x7c1f) + 
                                  ((UINT32) pusB[0] & 0x7c1f) + ((UINT32) pusB[1] & 0x7c1f) + 0x0802) & (0x7c1f << 2)) |

                                ((((UINT32) pusA[0] & 0x83e0) + ((UINT32) pusA[1] & 0x83e0) + 
                                  ((UINT32) pusB[0] & 0x83e0) + ((UINT32) pusB[1] & 0x83e0) + 0x10040) & (0x83e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A4R4G4B4()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x0f0f) + ((UINT32) pusA[1] & 0x0f0f) + 
                                  ((UINT32) pusB[0] & 0x0f0f) + ((UINT32) pusB[1] & 0x0f0f) + 0x0202) & (0x0f0f << 2)) |

                                ((((UINT32) pusA[0] & 0xf0f0) + ((UINT32) pusA[1] & 0xf0f0) + 
                                  ((UINT32) pusB[0] & 0xf0f0) + ((UINT32) pusB[1] & 0xf0f0) + 0x2020) & (0xf0f0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_R3G3B2() 
{
#if 0
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) ((((((UINT32) pubA[0] & 0xe3) + ((UINT32) pubA[1] & 0xe3) + 
                                 ((UINT32) pubB[0] & 0xe3) + ((UINT32) pubB[1] & 0xe3) + 0x42) & (0xe3 << 2)) |

                               ((((UINT32) pubA[0] & 0x1c) + ((UINT32) pubA[1] & 0x1c) + 
                                 ((UINT32) pubB[0] & 0x1c) + ((UINT32) pubB[1] & 0x1c) + 0x08) & (0x1c << 2))) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8()
{
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) (((UINT32) pubA[0] + (UINT32) pubA[1] + 
                               (UINT32) pubB[0] + (UINT32) pubB[1] + 0x02) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8R3G3B2()
{
#if 0
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x00e3) + ((UINT32) pusA[1] & 0x00e3) + 
                                  ((UINT32) pusB[0] & 0x00e3) + ((UINT32) pusB[1] & 0x00e3) + 0x0042) & (0x00e3 << 2)) |

                                ((((UINT32) pusA[0] & 0xff1c) + ((UINT32) pusA[1] & 0xff1c) + 
                                  ((UINT32) pusB[0] & 0xff1c) + ((UINT32) pusB[1] & 0xff1c) + 0x0208) & (0xff1c << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_X4R4G4B4()
{
#if 0
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x0f0f) + ((UINT32) pusA[1] & 0x0f0f) + 
                                  ((UINT32) pusB[0] & 0x0f0f) + ((UINT32) pusB[1] & 0x0f0f) + 0x0202) & (0x0f0f << 2)) |

                                ((((UINT32) pusA[0] & 0x00f0) + ((UINT32) pusA[1] & 0x00f0) + 
                                  ((UINT32) pusB[0] & 0x00f0) + ((UINT32) pusB[1] & 0x00f0) + 0x0020) & (0x00f0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8P8()
{
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_P8()
{
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8L8()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x00ff) + ((UINT32) pusA[1] & 0x00ff) + 
                                  ((UINT32) pusB[0] & 0x00ff) + ((UINT32) pusB[1] & 0x00ff) + 0x0002) & (0x00ff << 2)) |

                                ((((UINT32) pusA[0] & 0xff00) + ((UINT32) pusA[1] & 0xff00) + 
                                  ((UINT32) pusB[0] & 0xff00) + ((UINT32) pusB[1] & 0xff00) + 0x0200) & (0xff00 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A4L4()
{
#if 0
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) ((((((UINT32) pubA[0] & 0x0f) + ((UINT32) pubA[1] & 0x0f) + 
                                 ((UINT32) pubB[0] & 0x0f) + ((UINT32) pubB[1] & 0x0f) + 0x02) & (0x0f << 2)) |

                               ((((UINT32) pubA[0] & 0xf0) + ((UINT32) pubA[1] & 0xf0) + 
                                 ((UINT32) pubB[0] & 0xf0) + ((UINT32) pubB[1] & 0xf0) + 0x20) & (0xf0 << 2))) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\CD3DXCodec.h ===
//-----------------------------------------------------------------------------
// File: CD3DXCodec.cpp
//
// Desc: Contains general purpose blitting routines
//
// Hist: 01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef __CXD3DXCodec_H__
#define __CXD3DXCodec_H__

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>

#define CODEC_RGB 0x01
#define CODEC_P   0x02
#define CODEC_UV  0x03
#define CODEC_ZS  0x04

typedef signed char  INT8;
typedef short INT16;

typedef unsigned char  UINT8;
typedef unsigned short UINT16;

//----------------------------------------------------------------------------
//
// F2IBegin, F2I, F2IEnd
//
// Fast FLOAT->INT conversion.  F2IBegin sets and F2IEnd restores the FPU
// rounding mode.  F2I converts a float to an int.  You need to be careful of
// what other floating point code resides between F2IBegin and F2IEnd:  If
// something messes with the rounding mode, you could get unpredicted results.
//
//----------------------------------------------------------------------------


static UINT32 g_ulFPU;

static VOID
F2IBegin() {
    UINT32 ulFPU, ul;

    __asm {
        fnstcw WORD PTR [ulFPU]        // Get FPU control word
        mov    eax, DWORD PTR [ulFPU]
        or     eax, 0x0C00             // Rounding mode = CLAMP
        mov    DWORD PTR [ul], eax
        fldcw  WORD PTR [ul]           // Set FPU control word
    }

    // Save old FPU control word in thread-local storage
    g_ulFPU = ulFPU;
}


static inline INT
F2I(FLOAT f)
{
    volatile INT n;

    __asm {
        fld   f   // Load fload
        fistp n   // Store integer (and pop)
    }

    return n;
}

static VOID
F2IEnd() {
    // Get old FPU control word from thread-local storage
    UINT32 ulFPU = g_ulFPU;

    __asm {
        fldcw WORD PTR [ulFPU]    // Set FPU control word
    }
}


struct D3DX_BLT
{
    VOID*               pData;
    D3DFORMAT           Format;

    UINT                RowPitch;
    UINT                SlicePitch;

    D3DBOX              Region;
    D3DBOX              SubRegion;

    BOOL                bDither;

    D3DCOLOR            ColorKey;
    CONST PALETTEENTRY* pPalette;
};


///////////////////////////////////////////////////////////////////////////
// CXD3DXCodec /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXCodec
{
public:
    D3DFORMAT  m_Format;
    DWORD      m_dwType;
    BOOL       m_bLinear;
    BOOL       m_bColorKey;
    BOOL       m_bPalettized;

    BYTE*      m_pbData;
    D3DXCOLOR  m_ColorKey;
    FLOAT*     m_pfDither;
    D3DXCOLOR  m_pPalette[256];
    D3DBOX     m_Box;

    UINT       m_uPitch;
    UINT       m_uSlice;
    UINT       m_uWidth;
    UINT       m_uHeight;
    UINT       m_uDepth;
    UINT       m_uWidthBytes;
    UINT       m_uBytesPerPixel;

public:
    static CXD3DXCodec* Create(D3DX_BLT *pBlt);

    virtual ~CXD3DXCodec();

    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    static D3DCOLOR s_pPalette[256];

    void ColorKey(D3DXCOLOR *pColors);

    CXD3DXCodec(D3DX_BLT *pBlt, UINT uBPP, DWORD dwType);
};


///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecYUV //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXCodecYUV : public CXD3DXCodec
{
public: 
    CXD3DXCodecYUV(D3DX_BLT *pBlt);
    virtual ~CXD3DXCodecYUV();

    HRESULT Commit();
    HRESULT Fetch(UINT uRow, UINT uSlice, BOOL bRead);

    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    D3DXCOLOR *m_pCache;
    D3DBOX     m_CacheBox;
    UINT       m_uCacheWidth;
    BOOL       m_bCacheDirty;
    BOOL       m_bCacheAllocated;
    UINT       m_uYShift;
    UINT       m_uUVShift;
};



///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecDXT //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXCodecDXT : public CXD3DXCodec
{
public: 
    CXD3DXCodecDXT(D3DX_BLT *pBlt);
    virtual ~CXD3DXCodecDXT();

    HRESULT Commit();
    HRESULT Fetch(UINT uRow, UINT uSlice, BOOL bRead);

    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    D3DXCOLOR *m_ppCache[4];
    D3DBOX     m_CacheBox;
    UINT       m_uCacheWidth;
    BOOL       m_bCacheDirty;
    BOOL       m_bCacheAllocated;

    BOOL       m_bRepeat;
    UINT       m_uXRepeat;
    UINT       m_uYRepeat;
    UINT       m_uTopMax;
};



///////////////////////////////////////////////////////////////////////////
// Specific CXD3DXCodecs ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define DECLARE_CODEC(name, bits, type) \
    class CXD3DXCodec_##name : public CXD3DXCodec \
    { \
    public: \
        CXD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CXD3DXCodec(pBlt, (bits), (type)) {} \
    \
        virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors); \
        virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors); \
    }


#define DECLARE_CODEC_YUV(name) \
    class CXD3DXCodec_##name : public CXD3DXCodecYUV \
    { \
    public: \
        CXD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CXD3DXCodecYUV(pBlt) {} \
    }


#define DECLARE_CODEC_DXT(name) \
    class CXD3DXCodec_##name : public CXD3DXCodecDXT \
    { \
    public: \
        CXD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CXD3DXCodecDXT(pBlt) {} \
    }


DECLARE_CODEC(R8G8B8,    24, CODEC_RGB);
DECLARE_CODEC(A8R8G8B8,  32, CODEC_RGB);
DECLARE_CODEC(X8R8G8B8,  32, CODEC_RGB);
DECLARE_CODEC(R5G6B5,    16, CODEC_RGB);
DECLARE_CODEC(X1R5G5B5,  16, CODEC_RGB);
DECLARE_CODEC(A1R5G5B5,  16, CODEC_RGB);
DECLARE_CODEC(A4R4G4B4,  16, CODEC_RGB);
DECLARE_CODEC(R3G3B2,     8, CODEC_RGB);
DECLARE_CODEC(A8,         8, CODEC_RGB);
DECLARE_CODEC(A8R3G3B2,  16, CODEC_RGB);
DECLARE_CODEC(X4R4G4B4,  16, CODEC_RGB);
DECLARE_CODEC(A8P8,      16, CODEC_P);
DECLARE_CODEC(P8,         8, CODEC_P);
DECLARE_CODEC(L8,         8, CODEC_RGB);
DECLARE_CODEC(A8L8,      16, CODEC_RGB);
DECLARE_CODEC(A4L4,       8, CODEC_RGB);

DECLARE_CODEC(V8U8,      16, CODEC_UV);
DECLARE_CODEC(L6V5U5,    16, CODEC_UV);
DECLARE_CODEC(X8L8V8U8,  32, CODEC_UV);
DECLARE_CODEC(Q8W8V8U8,  32, CODEC_UV);
DECLARE_CODEC(V16U16,    32, CODEC_UV);
DECLARE_CODEC(W11V11U10, 32, CODEC_UV);

DECLARE_CODEC_YUV(UYVY);
DECLARE_CODEC_YUV(YUY2);
DECLARE_CODEC_DXT(DXT1);
DECLARE_CODEC_DXT(DXT2);
DECLARE_CODEC_DXT(DXT3);
DECLARE_CODEC_DXT(DXT4);
DECLARE_CODEC_DXT(DXT5);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\CD3DXBlt.h ===
//-----------------------------------------------------------------------------
// File: CD3DXBlt.h
//
// Desc: Contains general purpose blitting routines
//
// Hist: 01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef __CXD3DXBlt_H__
#define __CXD3DXBlt_H__

#include "CD3DXCodec.h"

///////////////////////////////////////////////////////////////////////////
// CXD3DXBlt ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXBlt
{
public:
    CXD3DXBlt();
   ~CXD3DXBlt();

    HRESULT Blt(D3DX_BLT* pDestBlt, D3DX_BLT* pSrcBlt, DWORD dwFilter);

protected:
    // Generic filters
    HRESULT BltSame();
    HRESULT BltCopy();
    HRESULT BltNone();
    HRESULT BltPoint();
    HRESULT BltBox2D();
    HRESULT BltBox3D();
    HRESULT BltLinear2D();
    HRESULT BltLinear3D();
    HRESULT BltTriangle2D();
    HRESULT BltTriangle3D();

    // Optimized filters
    HRESULT BltSame_DXTn();
    HRESULT BltBox2D_R8G8B8();  
    HRESULT BltBox2D_A8R8G8B8();
    HRESULT BltBox2D_X8R8G8B8();
    HRESULT BltBox2D_R5G6B5();  
    HRESULT BltBox2D_X1R5G5B5();
    HRESULT BltBox2D_A1R5G5B5();
    HRESULT BltBox2D_A4R4G4B4();
    HRESULT BltBox2D_R3G3B2();  
    HRESULT BltBox2D_A8();      
    HRESULT BltBox2D_A8R3G3B2();
    HRESULT BltBox2D_X4R4G4B4();
    HRESULT BltBox2D_A8P8();    
    HRESULT BltBox2D_P8();      
    HRESULT BltBox2D_A8L8();    
    HRESULT BltBox2D_A4L4();    

    // Codecs and Filter Type
    CXD3DXCodec *m_pSrc;
    CXD3DXCodec *m_pDest;

    DWORD m_dwFilter;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\bundler.cpp ===
//-----------------------------------------------------------------------------
// File: Bundler.cpp
//
// Desc: Bundles up a list of resources into an Xbox Packed Resource (xpr)
//       file.
//
// Hist: 02.06.01 - New for March XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Bundler.h"
#include "Texture.h"
#include "Cubemap.h"
#include "VolumeTexture.h"
#include "VB.h"
#include "UserData.h"
#include "IndexBuffer.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <delayimp.h>


#define INITIAL_HEADER_ALLOC 1024
#define INITIAL_DATA_ALLOC 65536


//-----------------------------------------------------------------------------
// Name: CBundler()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CBundler::CBundler()
{
    m_strRDF[0] = m_strXPR[0] = m_strHDR[0] = m_strERR[0] = 0;
    m_strPrefix[0] =  0;
    m_hfRDF    = m_hfXPR    = m_hfHDR    = m_hfERR    = INVALID_HANDLE_VALUE;
    m_cbHeader = m_cbData   = 0;
    m_bExplicitHDR = m_bExplicitXPR = m_bExplicitERR = FALSE;
    m_bExplicitPrefix = FALSE;
    m_pbHeaderBuff = m_pbDataBuff   = NULL;
    m_nResourceCount = 0;
    m_cNext0 = m_cNext1 = m_cNext2 = m_cNext3 = ' ';
    m_bSingleTexture = FALSE;
    m_bD3DCreated = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CBundler()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CBundler::~CBundler()
{
    CloseFiles();
    if( m_pbHeaderBuff )
        free( m_pbHeaderBuff );
    if( m_pbDataBuff )
        free( m_pbDataBuff );
}




//-----------------------------------------------------------------------------
// Name: PrintUsage()
// Desc: Prints out the usage string for help
//-----------------------------------------------------------------------------
void CBundler::PrintUsage()
{
    ErrorMsg( "USAGE: Bundler <resource description file> [-o <packed resource filename>]\n" );
    ErrorMsg( "                                           [-h <header filename>]\n");
    ErrorMsg( "                                           [-p <prefix for header file constants>]\n");
    ErrorMsg( "                                           [-e <error filename>]\n");
    ErrorMsg( "                                           [-?]\n");
}




//-----------------------------------------------------------------------------
// Name: ErrorMsg()
// Desc: Prints an error message to stdout, and writes to the error file
//-----------------------------------------------------------------------------
void CBundler::ErrorMsg( CHAR* strFmt, ... )
{
    DWORD cb;
    va_list arglist;
    char strTemp[MAX_PATH];

    if( INVALID_HANDLE_VALUE == m_hfERR )
    {   
        m_hfERR = CreateFile( m_strERR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    }

    va_start( arglist, strFmt );

    vprintf( strFmt, arglist );
    vsprintf( strTemp, strFmt, arglist );
    WriteFile( m_hfERR, strTemp, strlen( strTemp ), &cb, NULL );

    va_end( arglist );
}




//-----------------------------------------------------------------------------
// Name: DelayLoadFailureHook
// Desc: This routine will be called by windows in the event of a failed
//       delay load of a DLL (in our case, D3D), so that we can print a useful
//       error message and abort
//-----------------------------------------------------------------------------
FARPROC WINAPI DelayLoadFailureHook( unsigned dliNotify, PDelayLoadInfo pdli )
{
    printf( "Fatal Error: You tried to load an image that requires the\n" );
    printf( "\tDirectX 8 runtime to load, but either DirectX 8 is not \n" );
    printf( "\tinstalled or couldn't be loaded.  Either convert the image to\n" );
    printf( "\ta Windows Bitmap (BMP), or install the DirectX 8 runtime.\n" );

    exit( EXIT_FAILURE );

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes D3D for texture gunk
//-----------------------------------------------------------------------------
HRESULT CBundler::InitD3D()
{
    HRESULT hr;
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;

    // If we've already init'ed D3D, then we're good to go
    if( m_bD3DCreated )
        return S_FALSE;

    // Set up our delay load failure hook in case DirectX 8 isn't present
    __pfnDliFailureHook = DelayLoadFailureHook;

    m_pd3d = Direct3DCreate8(D3D_SDK_VERSION);
    if (m_pd3d == NULL)
    {
        ErrorMsg("Couldn't create Direct3d - is it installed?\n");
        return E_FAIL;
    }

    m_pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = 8;
    presentParams.BackBufferHeight = 8;
    presentParams.BackBufferFormat = ( ( dispMode.Format == D3DFMT_R8G8B8 ) ? D3DFMT_R5G6B5 : dispMode.Format );

    hr = m_pd3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, GetDesktopWindow(),
        D3DCREATE_SOFTWARE_VERTEXPROCESSING, &presentParams, &m_pd3ddev);
    if (FAILED(hr))
    {
        ErrorMsg("Couldn't create reference device.  Error: %x\n", hr);
        return E_FAIL;
    }

    m_bD3DCreated = TRUE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Parses and validates the command line arguments
//-----------------------------------------------------------------------------
HRESULT CBundler::Initialize( int argc, char * argv[] )
{
    int n;
    int nBaseFileLen;
    char * pch;
    BOOL bHaveRDF = FALSE;

    for(n=1; n<argc; n++)
    {
        // step through each command line parameter
        if((argv[n][0] == '/') || (argv[n][0] == '-'))
        {
            if((n+1) == argc)
                return E_INVALIDARG;

            // found an option
            if(lstrcmpi("o", &(argv[n][1])) == 0)
            {
                // Output file
                lstrcpyA( m_strXPR, argv[n+1] );
                m_bExplicitXPR = TRUE;
            }
            else if(lstrcmpi("h", &(argv[n][1])) == 0)
            {
                // Header file
                lstrcpyA( m_strHDR, argv[n+1] );
                m_bExplicitHDR = TRUE;
            }
            else if(lstrcmpi("p", &(argv[n][1])) == 0)
            {
                // Prefix for header file constants
                lstrcpyA( m_strPrefix, argv[n+1] );
                m_bExplicitPrefix = TRUE;
            }
            else if(lstrcmpi("e", &(argv[n][1])) == 0)
            {
                // Error file
                lstrcpyA( m_strERR, argv[n+1] );
                m_bExplicitERR = TRUE;
            }
            else if(lstrcmpi("?", &(argv[n][1])) == 0)
                return E_INVALIDARG;    // causes usage to be displayed
            else
                return E_INVALIDARG;
            
            n++;    // skip two args
        }
        else
        {
            // Grab the RDF filename
            lstrcpyA( m_strRDF, argv[1] );
        
            // Find where the filename ends and the extension begins
            pch = m_strRDF;
            while( pch && strchr( pch, '.' ) )
            {
                pch = strchr( pch, '.' ) + 1;
            }
        
            // If we never found a '.', use the whole filename
            if( pch == m_strRDF )
                pch = m_strRDF + lstrlen( m_strRDF ) + 1;
        
            // Must have something for a base filename
            nBaseFileLen = pch - m_strRDF - 1;
            if( nBaseFileLen <= 0 )
                return E_INVALIDARG;
        
            // Check to see if we are doing a quick single-texture conversion
            if((_stricmp(pch, "bmp") == 0) ||
               (_stricmp(pch, "jpg") == 0) ||
               (_stricmp(pch, "tga") == 0) ||
               (_stricmp(pch, "dds") == 0) ||
               (_stricmp(pch, "png") == 0))
            {
                m_bSingleTexture = TRUE;
            }
            
            // Copy the base filename + appropriate extension to each string
            strncpy( m_strXPR, m_strRDF, nBaseFileLen );
            m_strXPR[nBaseFileLen] = 0;
            strcat( m_strXPR, XPREXT );
            strncpy( m_strHDR, m_strRDF, nBaseFileLen );
            m_strHDR[nBaseFileLen] = 0;
            strcat( m_strHDR, HDREXT );
            strncpy( m_strERR, m_strRDF, nBaseFileLen );
            m_strERR[nBaseFileLen] = 0;
            strcat( m_strERR, ERREXT );

            strcpy( m_strPath, m_strXPR );
            if( strrchr( m_strPath, '\\' ) )
                strrchr( m_strPath, '\\' )[1] = 0;
            else
                m_strPath[0] = 0;

            bHaveRDF = TRUE;
        }
    }

    if(!bHaveRDF)
        return E_INVALIDARG;
 
    // Creating a D3D device sets the floating point control
    // word to single precision.  Now that we only create the
    // D3D device on demand, we _could_ use double precision,
    // but set to single precision to maintain bit-for-bit
    // output compatibility.
    _controlfp( _PC_24, _MCW_PC );

    // Allocate buffers for storing data
    m_pbHeaderBuff = (BYTE *)malloc( INITIAL_HEADER_ALLOC );
    if( !m_pbHeaderBuff )
        return E_OUTOFMEMORY;
    m_cbHeaderAlloc = INITIAL_HEADER_ALLOC;

    m_pbDataBuff = (BYTE *)malloc( INITIAL_DATA_ALLOC );
    if( !m_pbDataBuff )
        return E_OUTOFMEMORY;
    m_cbDataAlloc = INITIAL_DATA_ALLOC;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OpenFiles()
// Desc: Opens file handles for all our output files
//-----------------------------------------------------------------------------
HRESULT CBundler::OpenFiles()
{
    m_hfXPR = CreateFile( m_strXPR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfXPR )
    {
        ErrorMsg( "Couldn't open XPR file <%s>", m_strXPR );
        return E_FAIL;
    }

    m_hfHDR = CreateFile( m_strHDR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfHDR )
    {
        ErrorMsg( "Coudln't open header file <%s>", m_strHDR );
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CloseFiles()
// Desc: Closes file handles for all our input/output files
//-----------------------------------------------------------------------------
HRESULT CBundler::CloseFiles()
{
    if( INVALID_HANDLE_VALUE != m_hfRDF )
        CloseHandle( m_hfRDF );
    if( INVALID_HANDLE_VALUE != m_hfXPR )
        CloseHandle( m_hfXPR );
    if( INVALID_HANDLE_VALUE != m_hfHDR )
        CloseHandle( m_hfHDR );
    if( INVALID_HANDLE_VALUE != m_hfERR )
        CloseHandle( m_hfERR );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FilterFromString()
// Desc: Returns a D3DXFILTER from the given string
//-----------------------------------------------------------------------------
DWORD CBundler::FilterFromString( char* strFilter )
{
    DWORD filter  = D3DX_FILTER_TRIANGLE; // The default
    DWORD address = 0;
    DWORD dither  = 0;

    if( strFilter[0] )
    {
        // Scan string
        CHAR* strToken = strtok( strFilter, "|" );
        while( strToken != NULL )
        {
            if( !lstrcmpi( strToken, "NONE" ) )      filter  = D3DX_FILTER_NONE;
            if( !lstrcmpi( strToken, "POINT" ) )     filter  = D3DX_FILTER_POINT;
            if( !lstrcmpi( strToken, "LINEAR" ) )    filter  = D3DX_FILTER_LINEAR;
            if( !lstrcmpi( strToken, "TRIANGLE" ) )  filter  = D3DX_FILTER_TRIANGLE;
            if( !lstrcmpi( strToken, "BOX" ) )       filter  = D3DX_FILTER_BOX;
            if( !lstrcmpi( strToken, "WRAP" ) )      address = 0;
            if( !lstrcmpi( strToken, "CLAMP" ) )     address = D3DX_FILTER_MIRROR;
            if( !lstrcmpi( strToken, "DITHER" ) )    dither  = D3DX_FILTER_DITHER;

            strToken = strtok( NULL, "|" );
        }
    }

    return (filter|address|dither);
}




//-----------------------------------------------------------------------------
// Name: HandleTextureToken()
// Desc: Takes over to handle a texture token. Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleTextureToken()
{
    HRESULT hr;
    BUNDLERTOKEN tok;
    char strBuff[MAX_PATH];
    CTexture2D tex(this);
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &tok );
    if( FAILED( hr ) )
        return hr;

    if( tok.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Texture name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( tok.eType & TOKEN_PROPERTY_TEXTURE )
        {
            hr = GetNextTokenString( strBuff, tok.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( tok.eType )
        {
            case TOKEN_PROPERTY_TEXTURE_SOURCE:
                strcpy( tex.m_strSource, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_ALPHASOURCE:
                strcpy( tex.m_strAlphaSource, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_WIDTH:
                tex.m_dwWidth = atoi( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_HEIGHT:
                tex.m_dwHeight = atoi( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuff );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a texture property.\n", tok.strKeyword );
        }
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Texture: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleCubemapToken()
// Desc: Takes over to handle a cubemap token. Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleCubemapToken()
{
    HRESULT      hr;
    BUNDLERTOKEN token;
    char         strBuffer[MAX_PATH];
    CCubemap     tex(this);
    BOOL         bDone = FALSE;
    DWORD        cbHeader;
    DWORD        cbData;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Cubemap name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & (TOKEN_PROPERTY_CUBEMAP|TOKEN_PROPERTY_TEXTURE) )
        {
            hr = GetNextTokenString( strBuffer, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_XP:
                strcpy( tex.m_strSourceXP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_XN:
                strcpy( tex.m_strSourceXN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_YP:
                strcat( tex.m_strSourceYP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_YN:
                strcpy( tex.m_strSourceYN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP:
                strcpy( tex.m_strSourceZP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN:
                strcpy( tex.m_strSourceZN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP:
                strcpy( tex.m_strAlphaSourceXP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN:
                strcpy( tex.m_strAlphaSourceXN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP:
                strcpy( tex.m_strAlphaSourceYP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN:
                strcpy( tex.m_strAlphaSourceYN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP:
                strcpy( tex.m_strAlphaSourceZP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN:
                strcpy( tex.m_strAlphaSourceZN, strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SIZE:
                tex.m_dwSize = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuffer );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a cubemap property.\n", token.strKeyword );
        }
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Cubemap: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     6 x %d x %d, %d levels\n\n", tex.m_dwSize, tex.m_dwSize, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleVolumeTextureToken()
// Desc: Takes over to handle a volume texture token. Reads all tokens up to
//       and including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleVolumeTextureToken()
{
    HRESULT        hr;
    BUNDLERTOKEN   token;
    char           strBuffer[MAX_PATH];
    CVolumeTexture tex(this);
    BOOL           bDone = FALSE;
    DWORD          cbHeader;
    DWORD          cbData;
    DWORD          srcnum = 0;
    DWORD          alphasrcnum = 0;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Cubemap name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & (TOKEN_PROPERTY_CUBEMAP|TOKEN_PROPERTY_TEXTURE) )
        {
            hr = GetNextTokenString( strBuffer, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_TEXTURE_SOURCE:
                if( tex.m_dwDepth )
                {
                    if( srcnum <tex.m_dwDepth )
                        strcpy( tex.m_astrSource[srcnum++], strBuffer );
                    else
                        srcnum++;
                }
                else
                    ErrorMsg("Must specify volume texture DEPTH before SOURCE.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_ALPHASOURCE:
                if( tex.m_dwDepth )
                {
                    if( alphasrcnum <tex.m_dwDepth )
                        strcpy( tex.m_astrAlphaSource[alphasrcnum++], strBuffer );
                    else
                        alphasrcnum++;
                }
                else
                    ErrorMsg("Must specify volume texture DEPTH before ALPHASOURCE.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_WIDTH:
                tex.m_dwWidth = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_HEIGHT:
                tex.m_dwHeight = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH:
                if( 0 == tex.m_dwDepth )
                {   
                    tex.m_dwDepth         = atoi( strBuffer );
                    tex.m_astrSource      = new FILENAME[tex.m_dwDepth];
                    tex.m_astrAlphaSource = new FILENAME[tex.m_dwDepth];
                    ZeroMemory( tex.m_astrSource,      sizeof(FILENAME) * tex.m_dwDepth );
                    ZeroMemory( tex.m_astrAlphaSource, sizeof(FILENAME) * tex.m_dwDepth );
                }
                else
                    ErrorMsg("VolumeTexture DEPTH already specified.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuffer );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a volume texture property.\n", token.strKeyword );
        }
    }

    // Check that we have a good number of sources
    if( ( srcnum != tex.m_dwDepth ) || ( alphasrcnum > 0  && alphasrcnum != tex.m_dwDepth ) )
    {   
        ErrorMsg("Volume texture must have same number of sources as the depth.\n" );
        return E_FAIL;
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Volume texture: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     %d x %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwDepth, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Match()
// Desc: Returns TRUE if it successfuly reads a token of the specified type.
//-----------------------------------------------------------------------------
BOOL CBundler::Match(INT TokType, BUNDLERTOKEN *pTok)
{
    HRESULT hr;
    hr = GetNextToken( pTok );
    if( FAILED( hr ) )
        return FALSE;

    if( pTok->eType != TokType )
        return FALSE;
    
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: HandleVertexBuffer()
// Desc: Takes over to handle a VertexBuffer token.  Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleVertexBufferToken()
{
    HRESULT hr;
    BUNDLERTOKEN tok;
    char strBuff[MAX_PATH], *pEnd;
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

    // This is the vertex buffer name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
    {
        ErrorMsg( "Vertexbuffer name should be followed by an open brace\n" );
        return E_FAIL;
    }

    BOOL bGotVertexData = FALSE;
    CVertexBuffer *vb = new CVertexBuffer(this);
    
    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        switch( tok.eType )
        {
            case TOKEN_PROPERTY_VB_VERTEXFILE:
                // Only allow 1 instance of VertexData/VertexFile
                if( bGotVertexData )
                {
                    ErrorMsg( "Too many VertexData or DataFile statements\n" );
                    return E_FAIL;
                }
                bGotVertexData = TRUE;

                // Get the data file name
                hr = GetNextTokenString( strBuff, TT_FILENAME );
                if( FAILED( hr ) )
                    return hr;

                // Load the data into our vb
                hr = vb->LoadVertexDataFromFile( strBuff );
                if( FAILED( hr ) )
                    return hr;
            break;

            case TOKEN_PROPERTY_VB_VERTEXDATA:
                // Only allow 1 instance of VertexData/VertexFile
                if( bGotVertexData )
                {
                    ErrorMsg( "Too many VertexData or VertexFile statements\n" );
                    return E_FAIL;
                }
                bGotVertexData = TRUE;
                
                if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
                {
                    ErrorMsg( "VertexData property must begin with an open brace.\n" );
                    return E_FAIL;
                }
                while(TRUE)
                {
                    if(FAILED(hr = GetNextTokenString( strBuff, TT_ANY ))) return hr;
                
                    if((strBuff[0] == '}') || (strBuff[0] == TOKEOF))
                        break;
                    else if(ValidateType(strBuff, TT_HEXNUMBER) == S_OK)
                        vb->AddVertexData((DOUBLE)strtoul(strBuff, &pEnd, 16));
                    else if(ValidateType(strBuff, TT_INTEGER) == S_OK)
                        vb->AddVertexData(atof(strBuff));
                    else if(ValidateType(strBuff, TT_FLOAT) == S_OK)
                        vb->AddVertexData(atof(strBuff));
                }
                break;

            case TOKEN_PROPERTY_VB_VERTEXFORMAT:
                if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
                {
                    ErrorMsg( "VertexFormat property must begin with an open brace.\n" );
                    return E_FAIL;
                }
                while(TRUE)
                {
                    if(FAILED(hr = GetNextTokenString( strBuff, TT_ANY ))) return hr;
                
                    if((strBuff[0] == '}') || (strBuff[0] == TOKEOF))
                        break;
                    else
                    {
                        if((strcmp(strBuff, "D3DVSDT_FLOAT1") == 0) ||
                           (strcmp(strBuff, "FLOAT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT1);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT2") == 0) ||
                                (strcmp(strBuff, "FLOAT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT2);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT3") == 0) ||
                                (strcmp(strBuff, "FLOAT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT3);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT4") == 0) ||
                                (strcmp(strBuff, "FLOAT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT4);
                        else if((strcmp(strBuff, "D3DVSDT_D3DCOLOR") == 0) ||
                                (strcmp(strBuff, "D3DCOLOR") == 0))
                            vb->AddVertexFormat(XD3DVSDT_D3DCOLOR);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT2") == 0) ||
                                (strcmp(strBuff, "SHORT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT2);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT4") == 0) ||
                                (strcmp(strBuff, "SHORT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT4);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT1") == 0) ||
                                (strcmp(strBuff, "NORMSHORT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT1);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT2") == 0) ||
                                (strcmp(strBuff, "NORMSHORT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT2);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT3") == 0) ||
                                (strcmp(strBuff, "NORMSHORT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT3);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT4") == 0) ||
                                (strcmp(strBuff, "NORMSHORT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT4);
                        else if((strcmp(strBuff, "D3DVSDT_NORMPACKED3") == 0) ||
                                (strcmp(strBuff, "NORMPACKED3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMPACKED3);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT1") == 0) ||
                                (strcmp(strBuff, "SHORT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT1);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT3") == 0) ||
                                (strcmp(strBuff, "SHORT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT3);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE1") == 0) ||
                                (strcmp(strBuff, "PBYTE1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE1);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE2") == 0) ||
                                (strcmp(strBuff, "PBYTE2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE2);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE3") == 0) ||
                                (strcmp(strBuff, "PBYTE3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE3);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE4") == 0) ||
                                (strcmp(strBuff, "PBYTE4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE4);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT2H") == 0) ||
                                (strcmp(strBuff, "FLOAT2H") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT2H);
                        else
                        {
                            ErrorMsg( "Unrecognized attribute format: %s\n", strBuff );
                            return E_FAIL;
                        }
                    }
                }
                break;

            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a vertexbuffer property.\n", tok.strKeyword );
        }
    }

    // Save the vertexbuffer to the bundle
    hr = vb->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("VB:  Wrote %s: %d bytes per vertex, %d vertices (%d bytes)\n\n", 
           m_aResources[m_nResourceCount].strIdentifier, vb->m_cBytesPerVertex,
           vb->m_cVertices, cbData );

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    delete vb;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleUserDataToken()
// Desc: Takes over to handle a UserData token.  Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleUserDataToken()
{
    BUNDLERTOKEN token;
    CUserData    ud(this);
    CHAR         strBuff[MAX_PATH];
    BOOL         bDone = FALSE;
    DWORD        cbHeader, cbData;
    HRESULT      hr;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Texture name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & TOKEN_PROPERTY_USERDATA )
        {
            hr = GetNextTokenString( strBuff, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_USERDATA_DATAFILE:
                strcpy( ud.m_strSource, strBuff );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a userdata property.\n", token.strKeyword );
        }
    }

    // Save the UserData to the bundle
    hr = ud.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf( "UserData: Wrote %ld bytes.\n", cbHeader );

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleIndexBufferToken()
// Desc: Takes over to handle a IndexBuffer token.  Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleIndexBufferToken()
{
    HRESULT hr;
    BUNDLERTOKEN tok;
    char strBuff[MAX_PATH];
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

    // This is the vertex buffer name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
    {
        ErrorMsg( "IndexBuffer name should be followed by an open brace\n" );
        return E_FAIL;
    }

    CIndexBuffer *ib = new CIndexBuffer(this);
    BOOL bGotIndexData = FALSE;
    
    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        switch( tok.eType )
        {
            case TOKEN_PROPERTY_INDEXBUFFER_INDEXFILE:
                // Only allow 1 instance of IndexData/IndexFile
                if( bGotIndexData )
                {
                    ErrorMsg( "Too many IndexData or IndexFile statements\n" );
                    return E_FAIL;
                }
                bGotIndexData = TRUE;

                // Get the data file name
                hr = GetNextTokenString( strBuff, TT_FILENAME );
                if( FAILED( hr ) )
                    return hr;

                // Load the data into our vb
                hr = ib->LoadIndicesFromFile( strBuff );
                if( FAILED( hr ) )
                    return hr;
            break;

            case TOKEN_PROPERTY_INDEXBUFFER_INDEXDATA:
                // Only allow 1 instance of IndexData/IndexFile
                if( bGotIndexData )
                {
                    ErrorMsg( "Too many IndexData or IndexFile statements\n" );
                    return E_FAIL;
                }
                bGotIndexData = TRUE;
                
                if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
                {
                    ErrorMsg( "Index property must begin with an open brace.\n" );
                    return E_FAIL;
                }
                while(TRUE)
                {
                    if(FAILED(hr = GetNextTokenString( strBuff, TT_ANY ))) return hr;
                
                    if((strBuff[0] == '}') || (strBuff[0] == TOKEOF))
                        break;
                    else if( ValidateType( strBuff, TT_INTEGER ) == S_OK )
                        ib->AddIndex( (WORD)atol( strBuff ) );
                }
                break;

            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a indexbuffer property.\n", tok.strKeyword );
        }
    }

    // Save the vertexbuffer to the bundle
    hr = ib->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("IndexBuffer:  Wrote %d vertices (%d bytes)\n\n", ib->m_dwIndices,
                                                             cbData );
            
    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    delete ib;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FlushDataFile()
// Desc: Writes out all the buffered data to the data file, including
//       appropriate padding
//-----------------------------------------------------------------------------
HRESULT CBundler::FlushDataFile()
{
    BOOL bWriteOK;
    DWORD cb;
    XPR_HEADER xprh;
    BYTE * pbTemp;
    DWORD cbFill = 0;

    // Pad the data buffer out to be a multiple of the DVD sector size (2k).
    // This is needed in order to DMA the file off the DVD drive on the
    // Xbox.
    PadToAlignment( 2048 );

    xprh.dwMagic = XPR_MAGIC_VALUE;
    xprh.dwHeaderSize = m_cbHeader + sizeof( XPR_HEADER );

    // We may need to pad the file to a sector multiple for the 
    // start of the data block
    if( xprh.dwHeaderSize % 2048 )
    {
        cbFill = 2048 - ( xprh.dwHeaderSize % 2048 );
        xprh.dwHeaderSize += cbFill;
    }
    xprh.dwTotalSize = xprh.dwHeaderSize + m_cbData;

    // Write out header stuff
    if( !WriteFile( m_hfXPR, &xprh, sizeof( XPR_HEADER ), &cb, NULL ) )
        return E_FAIL;
    if( !WriteFile( m_hfXPR, m_pbHeaderBuff, m_cbHeader, &cb, NULL ) )
        return E_FAIL;

    if( cbFill )
    {
        // Allocate a buffer for fill data
        pbTemp = (BYTE *)malloc( cbFill );
        memset( pbTemp, 0xDEAD, cbFill );

        // Write it out
        bWriteOK = WriteFile( m_hfXPR, pbTemp, cbFill, &cb, NULL );
        free( pbTemp );
        if( !bWriteOK )
            return E_FAIL;
    }

    if( !WriteFile( m_hfXPR, m_pbDataBuff, m_cbData, &cb, NULL ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteHeaderFile()
// Desc: Writes out a .h file with useful defitions:
//       * NUM_RESOURCES
//       * XXX_OFFSET for each resource
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteHeaderFile()
{
    DWORD i;
    DWORD cb;
    char strBuff[256];

    sprintf( strBuff, "// Automatically generated by the bundler tool from %s\n\n", m_strRDF );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;

    // strip root filename out of m_strRDF;
    CHAR strPrefix[MAX_PATH];

    if( m_strPrefix[0] )
    {
        strcpy( strPrefix, m_strPrefix );
    }
    else
    {
        // Use the resource name as a prefix, after removing prepending path
        // and file extension.
        CHAR* pStr = strrchr( m_strRDF, '\\' );
        if( pStr )
            strcpy( strPrefix, pStr+1 );
        else
            strcpy( strPrefix, m_strRDF );

        pStr = strchr( strPrefix, '.' );
        if( pStr )
            *pStr = '\0';
    }

    // Write out the number of resources
    sprintf( strBuff, "#define %s_NUM_RESOURCES %dUL\n\n", strPrefix, m_nResourceCount );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;

    // Write out the offset of each resource
    if( m_bSingleTexture )
    {
        sprintf( strBuff, "#define %s_OFFSET %dUL\n", strPrefix, 
                          m_aResources[0].dwOffset );
        if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
            return E_FAIL;
    }
    else
    {
        for( i = 0; i < m_nResourceCount; i++ )
        {
            sprintf( strBuff, "#define %s_%s_OFFSET %dUL\n", strPrefix, 
                    m_aResources[i].strIdentifier, m_aResources[i].dwOffset );
            if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
                return E_FAIL;
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleEOFToken()
// Desc: Handles any necessary end-of-input processing, such as patching up
//       header information
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleEOFToken()
{
    if( FAILED( OpenFiles() ) )
        return E_FAIL;

    // write one last header entry to terminate the list
    DWORD tmp = 0xffffffff;
    WriteHeader( &tmp, sizeof( tmp ) );
    m_cbHeader += sizeof( tmp );

    if( FAILED( FlushDataFile() ) )
        return E_FAIL;

    if( FAILED( WriteHeaderFile() ) )
        return E_FAIL;

    return S_FALSE;
}




//-----------------------------------------------------------------------------
// Name: HandleOutPackedResourceToken()
// Desc: Takes over to handle the out_packedresource token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutPackedResourceToken()
{
    CHAR strFilename[MAX_PATH];
    GetNextTokenString( strFilename, TT_FILENAME );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitXPR )
    {
        if( strchr( strFilename, ':' ) )
            strcpy( m_strXPR, strFilename );
        else
        {
            strcpy( m_strXPR, m_strPath );
            strcat( m_strXPR, strFilename );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_packedresource overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleOutHeaderToken()
// Desc: Takes over to handle the out_header token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutHeaderToken()
{
    CHAR strFilename[MAX_PATH];
    GetNextTokenString( strFilename, TT_FILENAME );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitHDR )
    {
        if( strchr( strFilename, ':' ) )
            strcpy( m_strHDR, strFilename );
        else
        {
            strcpy( m_strHDR, m_strPath );
            strcat( m_strHDR, strFilename );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_header overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleOutPrefixToken()
// Desc: Takes over to handle the out_header token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutPrefixToken()
{
    CHAR strPrefix[MAX_PATH];
    GetNextTokenString( strPrefix, TT_ANY );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output prefix must be specified before resources\n" );
    }
    else if( !m_bExplicitPrefix )
    {
        strcpy( m_strPrefix, strPrefix );
    }
    else
    {
        ErrorMsg( "Warning: out_prefix overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleOutErrorToken()
// Desc: Takes over to handle the out_error token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutErrorToken()
{
    CHAR strFilename[MAX_PATH];
    GetNextTokenString( strFilename, TT_FILENAME );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitERR )
    {
        if( strchr( strFilename, ':' ) )
            strcpy( m_strERR, strFilename );
        else
        {
            strcpy( m_strERR, m_strPath );
            strcat( m_strERR, strFilename );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_error overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteHeader()
// Desc: Copies resource header info to the header buffer.  Grows the header
//       buffer by multiples of 2.
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteHeader( void * pbBuff, DWORD cb )
{
    DWORD cbNew = m_cbHeaderAlloc;

    // Find the next power-of-2 size that is big enough to hold the data
    while( m_cbHeader + cb > cbNew )
        cbNew <<= 1;

    // Realloc if necessary
    if( cbNew > m_cbHeaderAlloc )
    {
        BYTE * pbTemp = (BYTE *)realloc( m_pbHeaderBuff, cbNew );
        if( !pbTemp )
            return E_OUTOFMEMORY;
        m_pbHeaderBuff = pbTemp;
        m_cbHeaderAlloc = cbNew;
    }

    // Copy over the data
    memcpy( m_pbHeaderBuff + m_cbHeader, pbBuff, cb );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteData()
// Desc: Copies data to the data buffer.  Grows our data buffer by multiples
//       of 2
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteData( void * pbBuff, DWORD cb )
{
    DWORD cbNew = m_cbDataAlloc;

    //
    // Find the next power-of-2 size that is 
    // big enough to hold the data
    //
    while( m_cbData + cb > cbNew )
        cbNew <<= 1;
    
    // Realloc if necessary
    if( cbNew > m_cbDataAlloc )
    {
        BYTE * pbTemp = (BYTE *)realloc( m_pbDataBuff, cbNew );
        if( !pbTemp )
            return E_OUTOFMEMORY;
        m_pbDataBuff = pbTemp;
        m_cbDataAlloc = cbNew;
    }

    // Copy over the data
    memcpy( m_pbDataBuff + m_cbData, pbBuff, cb );
    m_cbData += cb;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PadToAlignment()
// Desc: Pads the data buffer to the specified alignment
//-----------------------------------------------------------------------------
HRESULT CBundler::PadToAlignment( DWORD dwAlign )
{
    HRESULT hr = S_OK;
    BYTE * pbTemp = NULL;
    DWORD cbFill = 0;

    if( m_cbData % dwAlign )
        cbFill = dwAlign - ( m_cbData % dwAlign );

    if( cbFill )
    {
        pbTemp = (BYTE *)malloc( cbFill );
        memset( pbTemp, 0xDEAD, cbFill );

        hr = WriteData( pbTemp, cbFill );
        
        free( pbTemp );
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: IsExistingIdentifier()
// Desc: Returns TRUE if we've already processed a resource with the given
//       identifier
//-----------------------------------------------------------------------------
BOOL CBundler::IsExistingIdentifier( char * strIdentifier )
{
    DWORD dwIndex;
    DWORD dwStrLen = strlen( strIdentifier );

    for( dwIndex = 0; dwIndex < m_nResourceCount; dwIndex++ )
    {
        if( strlen( m_aResources[ dwIndex ].strIdentifier ) == dwStrLen &&
            !strncmp( strIdentifier, m_aResources[ dwIndex ].strIdentifier, dwStrLen ) )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Processes the resource definition file and processes it to create our
//       Xbox Packed Resource (xpr) file and header file
//-----------------------------------------------------------------------------
HRESULT CBundler::Process()
{
    HRESULT hr;
    BUNDLERTOKEN tok;

    // Special case: single-texture conversion
    if( m_bSingleTexture )
    {
        CTexture2D tex(this);
        DWORD cbHeader, cbData;
        
        if( strrchr( m_strRDF, '\\' ) )
            strcpy( tex.m_strSource, strrchr( m_strRDF, '\\' )+1 );
        else
            strcpy( tex.m_strSource, m_strRDF );
        
        // Save the texture to the bundle
        hr = tex.SaveToBundle( &cbHeader, &cbData );
        if( FAILED( hr ) )
            return hr;
    
        printf( "Texture: Wrote %s out in format %s (%d bytes)\n", 
                 tex.m_strSource, tex.m_strFormat, cbData );
        printf( "     %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwLevels );
    
        m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
        m_cbHeader += cbHeader;

        HandleEOFToken();

        return S_OK;
    }
    
    // Open the file
    m_hfRDF = CreateFile( m_strRDF, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfRDF )
    {
        ErrorMsg( "Error: Can't open <%s>\n", m_strRDF );
        return E_FAIL;
    }

    // Iterate over top-level tokens (Texture, out_xxxx, EOF, etc)
    for( ; ; )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        hr = (this->*tok.pfnHandler)();
        if( FAILED( hr ) )
            return hr;
        else if( hr == S_FALSE  )
            break;

    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program
//-----------------------------------------------------------------------------
int _cdecl main( int argc, char * argv[] )
{
    HRESULT hr;
    CBundler bundler;

    hr = bundler.Initialize( argc, argv );
    if(hr == E_INVALIDARG)
    {
        bundler.PrintUsage();
        return 0;
    }
    else if(FAILED(hr))
    {
        bundler.ErrorMsg( "ERROR: D3D Initialization failed.\n" );
        return 0;
    }

    hr = bundler.Process();
    if( FAILED( hr ) )
        return 0;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\cubemap.cpp ===
//-----------------------------------------------------------------------------
// File: Cubemap.cpp
//
// Desc: Contains the cubemap-specific logic for the bundler tool
//
// Hist: 04.11.01 - New for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Cubemap.h"
#include "Bundler.h"
#include "LoadImage.h"



//-----------------------------------------------------------------------------
// Name: CCubemap()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CCubemap::CCubemap( CBundler* pBundler )
         :CBaseTexture( pBundler )
{
    m_pImageXP              = NULL;
    m_pImageXN              = NULL;
    m_pImageYP              = NULL;
    m_pImageYN              = NULL;
    m_pImageZP              = NULL;
    m_pImageZN              = NULL;

    m_strSourceXP[0]         = '\0';
    m_strSourceXN[0]         = '\0';
    m_strSourceYP[0]         = '\0';
    m_strSourceYN[0]         = '\0';
    m_strSourceZP[0]         = '\0';
    m_strSourceZN[0]         = '\0';
    m_strAlphaSourceXP[0]    = '\0';
    m_strAlphaSourceXN[0]    = '\0';
    m_strAlphaSourceYP[0]    = '\0';
    m_strAlphaSourceYN[0]    = '\0';
    m_strAlphaSourceZP[0]    = '\0';
    m_strAlphaSourceZN[0]    = '\0';
}




//-----------------------------------------------------------------------------
// Name: ~CCubemap()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CCubemap::~CCubemap()
{
    delete m_pImageXP;
    delete m_pImageXN;
    delete m_pImageYP;
    delete m_pImageYN;
    delete m_pImageZP;
    delete m_pImageZN;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CCubemap::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    hr = LoadCubemap();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save cubemap data
    (*pcbData) = 0;

    SaveImage( pcbData, m_dwLevels, m_pImageXP );
    SaveImage( pcbData, m_dwLevels, m_pImageXN );
    SaveImage( pcbData, m_dwLevels, m_pImageYP );
    SaveImage( pcbData, m_dwLevels, m_pImageYN );
    SaveImage( pcbData, m_dwLevels, m_pImageZP );
    SaveImage( pcbData, m_dwLevels, m_pImageZN );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadCubemap()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CCubemap::LoadCubemap()
{
    HRESULT hr;

    // Try to look up our format string
    m_nFormat = FormatFromString( m_strFormat );
    if( m_nFormat < -1 )
    {
        m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
        return E_FAIL;
    }
    lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );

    // Check for linear textures
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_pBundler->ErrorMsg( "Error: Cubemaps cannot have linear formats", m_strFormat );
        return E_FAIL;
    }

    // If an alpha source was specified, make sure the format supports alpha
    if( m_strAlphaSourceXP[0] || m_strAlphaSourceXN[0] || 
        m_strAlphaSourceYP[0] || m_strAlphaSourceYN[0] || 
        m_strAlphaSourceZP[0] || m_strAlphaSourceZN[0] ) 
    {
        if( g_TextureFormats[m_nFormat].dwNumAlphaBits == 0 )
        {
            m_pBundler->ErrorMsg( "Warning: an ALPHASOURCE was specified, yet the " \
                                  "requested texture format, %s,  does not have " \
                                  "any alpha.\n", m_strFormat );
        }
    }

    // Load the image surfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    if( FAILED( hr = LoadImage( m_strSourceXP, m_strAlphaSourceXP, &m_pImageXP ) ) )
    {
		if( m_strAlphaSourceXP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceXP, m_strAlphaSourceXP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceXP );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceXN, m_strAlphaSourceXN, &m_pImageXN ) ) )
    {
		if( m_strAlphaSourceXN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceXN, m_strAlphaSourceXN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceXN );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceYP, m_strAlphaSourceYP, &m_pImageYP ) ) )
    {
		if( m_strAlphaSourceYP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceYP, m_strAlphaSourceYP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceYP );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceYN, m_strAlphaSourceYN, &m_pImageYN ) ) )
    {
		if( m_strAlphaSourceYN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceYN, m_strAlphaSourceYN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceYN );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceZP, m_strAlphaSourceZP, &m_pImageZP ) ) )
    {
		if( m_strAlphaSourceZP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceZP, m_strAlphaSourceZP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceZP );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceZN, m_strAlphaSourceZN, &m_pImageZN ) ) )
    {
		if( m_strAlphaSourceZN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceZN, m_strAlphaSourceZN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceZN );
        return hr;
    }

    // Determine final width and height
    if( m_dwSize==0 )
    {
        // Enforce power-of-two dimensions for cubemap faces
        for( m_dwSize=1;  m_dwSize  < m_pImageXP->m_Width;  m_dwSize<<=1 );
    }

    // Determine final number of miplevels
    DWORD dwLevels = 1; 
    while( (1UL<<(dwLevels-1)) < m_dwSize )
        dwLevels++;
        
    if( m_dwLevels < 1 || m_dwLevels > dwLevels )
        m_dwLevels = dwLevels;

    // Change the size of the surfaces
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageXP );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageXN );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageYP );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageYN );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageZP );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageZN );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CCubemap::SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader )
{
    D3DTexture d3dtex;

    XGSetCubeTextureHeader( m_dwSize, m_dwLevels, 0,
                            (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                            D3DPOOL_DEFAULT, (IDirect3DCubeTexture8*)&d3dtex,
                            dwStart, 0 );

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    (*pcbHeader) = sizeof(d3dtex);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\cubemap.h ===
//-----------------------------------------------------------------------------
// File: Cubemap.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the cubemap-related functionality of the bundler tool
//
// Hist: 04.11.01 - New for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CUBEMAP_H
#define CUBEMAP_H

#include "Texture.h"




//-----------------------------------------------------------------------------
// Name: class CCubemap
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CCubemap : public CBaseTexture
{
    CImage* m_pImageXP;
    CImage* m_pImageXN;
    CImage* m_pImageYP;
    CImage* m_pImageYN;
    CImage* m_pImageZP;
    CImage* m_pImageZN;

    HRESULT LoadCubemap();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

public:
    char  m_strSourceXP[MAX_PATH];
    char  m_strSourceXN[MAX_PATH];
    char  m_strSourceYP[MAX_PATH];
    char  m_strSourceYN[MAX_PATH];
    char  m_strSourceZP[MAX_PATH];
    char  m_strSourceZN[MAX_PATH];
    char  m_strAlphaSourceXP[MAX_PATH];
    char  m_strAlphaSourceXN[MAX_PATH];
    char  m_strAlphaSourceYP[MAX_PATH];
    char  m_strAlphaSourceYN[MAX_PATH];
    char  m_strAlphaSourceZP[MAX_PATH];
    char  m_strAlphaSourceZN[MAX_PATH];
    DWORD m_dwSize;

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CCubemap( CBundler* pBundler );
    ~CCubemap();
};


#endif // CUBEMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\LoadImage.cpp ===
//-----------------------------------------------------------------------------
// File: LoadImage.cpp
//
// Desc: Loads image files.
//
// Hist: 04.13.01 - New for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <d3d8.h>
#include "bundler.h"
#include "LoadImage.h"
#include "cd3dxblt.h"



//-----------------------------------------------------------------------------
// Name: CImage()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CImage::CImage()
{
    m_Format         = D3DFMT_UNKNOWN;
    m_pData          = NULL;
    m_pPalette       = NULL;
    m_bDeleteData    = FALSE;
    m_bDeletePalette = FALSE;
}




//-----------------------------------------------------------------------------
// Name: CImage()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CImage::CImage( DWORD dwWidth, DWORD dwHeight, D3DFORMAT format )
{
    m_Format            = format;
    m_Width             = dwWidth;
    m_Height            = dwHeight;

    m_Rect.left         = 0;
    m_Rect.top          = 0;
    m_Rect.right        = dwWidth;
    m_Rect.bottom       = dwHeight;

    // TODO: This needs to get straightened out
    m_Pitch             = m_Width * sizeof( DWORD );
    m_pData             = new BYTE[ m_Pitch * m_Height ];
    m_pPalette          = NULL;
    m_bDeleteData       = TRUE;
    m_bDeletePalette    = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CImage()
// Desc: Frees resources held by the object
//-----------------------------------------------------------------------------
CImage::~CImage()
{
    if( m_pData && m_bDeleteData )
        delete[] m_pData;

    if( m_pPalette && m_bDeletePalette )
        delete[] m_pPalette;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Attempts to load the given data as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( const VOID* pData, DWORD cbData )
{
    HRESULT hr;

    // Try all known image loading subroutines
    for( int i = 0; i < 4; i++ )
    {
        switch(i)
        {
            case 0: hr = LoadBMP( pData, cbData ); break;
            case 1: hr = LoadPPM( pData, cbData ); break;
            case 2: hr = LoadTGA( pData, cbData ); break;
            case 3: hr = LoadDIB( pData, cbData ); break;
        }

        if( SUCCEEDED(hr) )
            break;

        if( m_pData && m_bDeleteData )
            delete[] m_pData;

        if( m_pPalette && m_bDeletePalette )
            delete[] m_pPalette;

        m_pData          = NULL;
        m_pPalette       = NULL;
        m_bDeleteData    = FALSE;
        m_bDeletePalette = FALSE;
    }

    if( 4 == i )
    {
        DPF(0, "Unsupported file format");
        return D3DXERR_INVALIDDATA;
    }

    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = m_Width;
    m_Rect.bottom = m_Height;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Depalettize()
// Desc: Depalettize palettized images
//-----------------------------------------------------------------------------
HRESULT CImage::Depalettize()
{
    if( NULL == m_pPalette )
        return S_OK;

    BYTE*  pSrcData = (BYTE*)m_pData;
    DWORD* pDstData = new DWORD[m_Width*m_Height];

    BYTE*  pOldData = (BYTE*)pSrcData;
    BYTE*  pNewData = (BYTE*)pDstData;

    // Loop through all texels and get 32-bit color from the 8-bit palette index
    for( DWORD y=0; y<m_Height; y++ )
    {
        for( DWORD x=0; x<m_Width; x++ )
        {
            BYTE  index = *pSrcData++;

            DWORD red   = m_pPalette[index].peRed;
            DWORD green = m_pPalette[index].peGreen;
            DWORD blue  = m_pPalette[index].peBlue;
            DWORD alpha = m_pPalette[index].peFlags;

            *pDstData++ = (alpha<<24) | (red<<16) | (green<<8) | (blue<<0);
        }
    }

    // Delete the old palette
    if( m_bDeletePalette )
        delete[] m_pPalette;
    m_pPalette       = NULL;
    m_bDeletePalette = FALSE;

    // Delete the old data, and assign the new data
    if( m_bDeleteData )
        delete[] m_pData;
    m_pData          = pNewData;
    m_bDeleteData    = TRUE;

    // The format is now A8R8G8B8
    m_Format = D3DFMT_A8R8G8B8;
    m_Pitch  = m_Width * sizeof(DWORD);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Reads the data from the file and tries to load it as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( CHAR* strFilename )
{
    HANDLE hFile = CreateFileA( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_HANDLE;

    // Allocate memory
    DWORD dwFileSize = GetFileSize( hFile, NULL );
    VOID* pFileData  = malloc( dwFileSize );

    // Read it the file
    DWORD dwRead;
    ReadFile( hFile, (VOID*)pFileData, dwFileSize, &dwRead, NULL );

    HRESULT hr = Load( pFileData, dwFileSize );

    // Free stuff
    CloseHandle( hFile );
    free( pFileData );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: LoadBMP()
// Desc: Attempts to load the given data as a BMP
//-----------------------------------------------------------------------------
HRESULT CImage::LoadBMP( const VOID* pvData, DWORD cbData )
{
    // Examine header
    if(cbData < sizeof(BITMAPFILEHEADER))
        return E_FAIL;

    BITMAPFILEHEADER *pFH = (BITMAPFILEHEADER *) pvData;

    if(pFH->bfType != (('B') | ('M' << 8)) || pFH->bfSize > cbData)
        return E_FAIL;

    return LoadDIB((BYTE *) pvData + sizeof(BITMAPFILEHEADER), cbData - sizeof(BITMAPFILEHEADER));
}




//-----------------------------------------------------------------------------
// Name: LoadDIB()
// Desc: Attempts to load the given data as a DIB
//-----------------------------------------------------------------------------
HRESULT CImage::LoadDIB( const VOID* pvData, DWORD cbData )
{
    UNALIGNED BITMAPINFOHEADER *pIH;
    DWORD     dwWidth, dwHeight, dwOffset, dwClrUsed;

    if(cbData < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    pIH = (BITMAPINFOHEADER *) pvData;

    if(pIH->biSize < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    dwWidth   = (DWORD) (pIH->biWidth);
    dwHeight  = (DWORD) (pIH->biHeight > 0 ? pIH->biHeight : -pIH->biHeight);
    dwClrUsed = (DWORD) (pIH->biClrUsed);

    if((pIH->biBitCount <= 8) && (0 == dwClrUsed))
        dwClrUsed = (DWORD) (1 << pIH->biBitCount);

    dwOffset  = (DWORD) pIH->biSize + dwClrUsed * sizeof(DWORD);

    if(dwOffset > (DWORD) cbData)
        return E_FAIL;

    if(pIH->biPlanes != 1)
        return E_FAIL;


    // Only RGB and BITFIELD bitmaps can be inverted
    if(pIH->biHeight < 0 && pIH->biCompression != BI_RGB && pIH->biCompression != BI_BITFIELDS)
        return E_FAIL;


    // Compute format
    DWORD dwB, dwG, dwR, dwA;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pIH->biCompression)
    {
        case BI_RGB:
        case BI_RLE4:
        case BI_RLE8:

            switch(pIH->biBitCount)
            {
                case 1:
                case 4:
                case 8:
                    Format = D3DFMT_P8;
                    break;

                case 16:
                    Format = D3DFMT_X1R5G5B5;
                    break;

                case 24:
#if 0
                    Format = D3DFMT_R8G8B8;
                    break;
#endif
                case 32:
                    Format = D3DFMT_X8R8G8B8;
                    break;

                default:
                    return E_FAIL;
            }
            break;

        case BI_BITFIELDS:
            if(pIH->biSize < sizeof(BITMAPV4HEADER))
                return E_FAIL;

            dwB = ((BITMAPV4HEADER *) pIH)->bV4BlueMask;
            dwG = ((BITMAPV4HEADER *) pIH)->bV4GreenMask;
            dwR = ((BITMAPV4HEADER *) pIH)->bV4RedMask;
            dwA = ((BITMAPV4HEADER *) pIH)->bV4AlphaMask;

            switch(pIH->biBitCount)
            {
                case 16:
                    if(dwB == 0x00ff && dwG == 0x00ff && dwR == 0x00ff && dwA == 0xff00)
                        Format = D3DFMT_A8L8;

                    else if(dwB == 0x001f && dwG == 0x07e0 && dwR == 0xf800 && dwA == 0x0000)
                        Format = D3DFMT_R5G6B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x0000)
                        Format = D3DFMT_X1R5G5B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x8000)
                        Format = D3DFMT_A1R5G5B5;

                    else if(dwB == 0x000f && dwG == 0x00f0 && dwR == 0x0f00 && dwA == 0xf000)
                        Format = D3DFMT_A4R4G4B4;
        #if 0
                    else if(dwB == 0x0003 && dwG == 0x001c && dwR == 0x00e0 && dwA == 0xff00)
                        Format = D3DFMT_A8R3G3B2;
        #endif
                    break;

                case 24:
                    if(dwB == 0x0000ff && dwG == 0x00ff00 && dwR == 0xff0000 && dwA == 0x000000)
        #if 0                
                        Format = D3DFMT_R8G8B8;
        #else
                        Format = D3DFMT_X8R8G8B8;
        #endif
                    break;

                case 32:
                    if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0x00000000)
                        Format = D3DFMT_X8R8G8B8;

                    else if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0xff000000)
                        Format = D3DFMT_A8R8G8B8;

                    break;
            }

            break;

        default:
            DPF(0, "LoadBMP: JPEG compression not supported");
            return E_NOTIMPL;
    }


    if(D3DFMT_UNKNOWN == Format)
    {
        return E_FAIL;
    }


    if(D3DFMT_P8 == Format)
    {
        DWORD dwClrUsed = pIH->biClrUsed;

        if(!dwClrUsed)
            dwClrUsed = 1 << pIH->biBitCount;

        m_bDeletePalette = TRUE;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        DWORD dw;
        RGBQUAD* prgb = (RGBQUAD*) (((BYTE *) pIH) + pIH->biSize);

        for(dw = 0; dw < dwClrUsed; dw++, prgb++)
        {
            m_pPalette[dw].peRed   = prgb->rgbRed;
            m_pPalette[dw].peGreen = prgb->rgbGreen;
            m_pPalette[dw].peBlue  = prgb->rgbBlue;
            m_pPalette[dw].peFlags = 0xff;
        }

        for(dw = dwClrUsed; dw < 256; dw++)
        {
            m_pPalette[dw].peRed   = 0xff;
            m_pPalette[dw].peGreen = 0xff;
            m_pPalette[dw].peBlue  = 0xff;
            m_pPalette[dw].peFlags = 0xff;
        }
    }

    DWORD dwWidthBytes;
    DWORD dwSrcInc, dwDstInc;

    switch(pIH->biBitCount)
    {
        case 1:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 3) + 3) & ~3;
            break;

        case 4:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 1) + 3) & ~3;
            break;

        default:
            dwWidthBytes = (dwWidth * (pIH->biBitCount >> 3));
            dwSrcInc = (dwWidthBytes + 3) & ~3;
            break;
    }

    m_Format  = Format;
    m_Pitch   = (DWORD)((dwWidthBytes + 3) & ~3);
    m_Width   = (DWORD)dwWidth;
    m_Height  = (DWORD)dwHeight;
#if 1
    if (pIH->biBitCount == 24 && Format == D3DFMT_X8R8G8B8)
    {
        UNALIGNED BYTE* pbSrc;
        DWORD*          pdwDst;
        int             nStrideDst;
        UINT            i, j;

        dwWidthBytes = (dwWidth * (32 >> 3));
        m_Pitch      = (DWORD)((dwWidthBytes + 3) & ~3);

        m_bDeleteData = TRUE;

        m_pData = new BYTE[dwHeight * m_Pitch];
        if (!m_pData)
            return E_OUTOFMEMORY;

        pbSrc = ((BYTE*)pvData) + dwOffset;
        if (pIH->biHeight < 0)
        {
            pdwDst = (DWORD*)m_pData;
            nStrideDst = m_Pitch >> 2;
        }
        else
        {
            pdwDst = (DWORD*)((BYTE*)m_pData + m_Pitch * (dwHeight - 1));
            nStrideDst = -(int)(m_Pitch >> 2);
        }

        for (i = 0; i < dwHeight; i++)
        {
            for (j = 0; j < dwWidth; j++)
            {
                pdwDst[j] = pbSrc[2] << 16 | pbSrc[1] << 8 | *pbSrc;
                pbSrc += 3;
            }

            pdwDst += nStrideDst;
        }

        return S_OK;
    }
#endif
    if(pIH->biHeight < 0 && pIH->biBitCount >= 8)
    {
        // The data is in the correct format already in the file.
        m_pData  = new BYTE[dwHeight * m_Pitch];
        memcpy( m_pData, ((BYTE *)pvData) + dwOffset, dwHeight * m_Pitch );
        m_bDeleteData = TRUE;

        return S_OK;
    }

    // Data in file needs to be converted.. so lets allocate the destination
    // buffer which will contain the image..

    m_bDeleteData = TRUE;
    m_pData  = new BYTE[dwHeight * m_Pitch];

    if(!m_pData)
        return E_OUTOFMEMORY;

    UNALIGNED BYTE *pbSrc, *pbDest, *pbDestMin, *pbDestLim, *pbDestLine;

    pbSrc = ((BYTE *) pvData) + dwOffset;

    if(pIH->biHeight < 0)
    {
        dwDstInc = m_Pitch;
        pbDest = (BYTE *) m_pData;
    }
    else
    {
        dwDstInc = 0 - (DWORD)m_Pitch;
        pbDest = (BYTE *) m_pData + (dwHeight - 1) * m_Pitch;
    }

    pbDestLine = pbDest;
    pbDestMin = (BYTE *) m_pData;
    pbDestLim = (BYTE *) m_pData + dwHeight * m_Pitch;



    if(BI_RLE4 == pIH->biCompression)
    {
        // RLE4. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        for(int i = 0; i < pbSrc[1]; i++)
                            pbDest[i] = (i & 1) ?  (pbSrc[2 + (i >> 1)] & 0x0f) : (pbSrc[2 + (i >> 1)] >> 4);

                        pbDest += pbSrc[1];
                        pbSrc += ((pbSrc[1] >> 1) + 1) & ~1;
                        break;
                }
            }
            else
            {
                for(int i = 0; i < pbSrc[0]; i++)
                    pbDest[i] = (i & 1) ? (pbSrc[1] & 0x0f) : (pbSrc[1] >> 4);

                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }

    if(pIH->biCompression == BI_RLE8)
    {
        // RLE8. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        memcpy(pbDest, pbSrc + 2, pbSrc[1]);
                        pbDest += pbSrc[1];
                        pbSrc += (pbSrc[1] + 1) & ~1;
                        break;
                }
            }
            else
            {
                memset(pbDest, pbSrc[1], pbSrc[0]);
                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }


    if(1 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (pbSrc[i >> 3] >> (7 - (i & 7))) & 1;

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }

    if(4 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (i & 1) ? pbSrc[i >> 1] & 0x0f : (pbSrc[i >> 1] >> 4);

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }


    while(pbDest >= pbDestMin && pbDest < pbDestLim)
    {
        memcpy(pbDest, pbSrc, dwWidthBytes);

        pbDest += dwDstInc;
        pbSrc  += dwSrcInc;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: struct TGAHEADER
// Desc: Defines the header format for TGA files
//-----------------------------------------------------------------------------
#pragma pack(1)
struct TGAHEADER
{
    BYTE IDLength;
    BYTE ColormapType;
    BYTE ImageType;

    WORD wColorMapIndex;
    WORD wColorMapLength;
    BYTE bColorMapBits;

    WORD wXOrigin;
    WORD wYOrigin;
    WORD wWidth;
    WORD wHeight;
    BYTE PixelDepth;
    BYTE ImageDescriptor;
};
#pragma pack()




//-----------------------------------------------------------------------------
// Name: LoadTGA()
// Desc: Attempts to load the given data as a TGA file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadTGA( const VOID* pvData, DWORD cbData )
{
    // Validate header.  TGA files don't seem to have any sort of magic number
    // to identify them.  Therefore, we will proceed as if this is a real TGA
    // file, until we see something we don't understand.

    BYTE*      pbData = (BYTE*)pvData;
    TGAHEADER* pFH    = (TGAHEADER*)pbData;

    if( cbData < sizeof(TGAHEADER) )
        return E_FAIL;

    if( pFH->ColormapType & ~0x01 )
        return E_FAIL;

    if( pFH->ImageType & ~0x0b )
        return E_FAIL;

    if( !pFH->wWidth || !pFH->wHeight )
        return E_FAIL;



    // Colormap size and format
    UINT uColorMapBytes = ((UINT) pFH->bColorMapBits + 7) >> 3;
    D3DFORMAT ColorMapFormat = D3DFMT_UNKNOWN;

    if(pFH->ColormapType)
    {
        switch(pFH->bColorMapBits)
        {
            case 15: ColorMapFormat = D3DFMT_X1R5G5B5; break;
            case 16: ColorMapFormat = D3DFMT_A1R5G5B5; break;
            case 24: ColorMapFormat = D3DFMT_X8R8G8B8; break;
            case 32: ColorMapFormat = D3DFMT_A8R8G8B8; break;
            default: return E_FAIL;
        }
    }


    // Image size and format
    UINT uBytes = ((UINT) pFH->PixelDepth + 7) >> 3;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pFH->ImageType & 0x03)
    {
        case 1:
            if(!pFH->ColormapType)
                return E_FAIL;

            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_P8; break;
                default: return E_FAIL;
            }
            break;

        case 2:
            switch(pFH->PixelDepth)
            {
                case 15: Format = D3DFMT_X1R5G5B5; break;
                case 16: Format = D3DFMT_A1R5G5B5; break;
                case 24: Format = D3DFMT_X8R8G8B8;   break;
                case 32: Format = D3DFMT_A8R8G8B8; break;
                default: return E_FAIL;
            }
            break;

        case 3:
            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_L8; break;
                default: return E_FAIL;
            }
            break;

        default:
            return E_FAIL;
    }

    BOOL bRLE         = pFH->ImageType & 0x08;
    BOOL bTopToBottom = 0x20 == (pFH->ImageDescriptor & 0x20);
    BOOL bLeftToRight = 0x10 != (pFH->ImageDescriptor & 0x10);

    pbData += sizeof(TGAHEADER);
    cbData -= sizeof(TGAHEADER);


    // Skip ID
    if(cbData < pFH->IDLength)
        return E_FAIL;

    pbData += pFH->IDLength;
    cbData -= pFH->IDLength;


    // Color map
    UINT cbColorMap = (UINT) pFH->wColorMapLength * uColorMapBytes;

    if(cbData < cbColorMap)
        return E_FAIL;

    if(D3DFMT_P8 == Format)
    {
        if(pFH->wColorMapIndex + pFH->wColorMapLength > 256)
            return E_FAIL;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        m_bDeletePalette = TRUE;
        memset(m_pPalette, 0xff, 256 * sizeof(PALETTEENTRY));

        BYTE *pb = pbData;
        PALETTEENTRY *pColor = m_pPalette + pFH->wColorMapIndex;
        PALETTEENTRY *pColorLim = pColor + pFH->wColorMapLength;

        while(pColor < pColorLim)
        {
            UINT u, uA, uR, uG, uB;

            switch(ColorMapFormat)
            {
                case D3DFMT_X1R5G5B5:
                    u = *((WORD *) pb);

                    uA = 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

                case D3DFMT_A1R5G5B5:
                    u = *((WORD *) pb);

                    uA = (u >> 15) * 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

                case D3DFMT_X8R8G8B8:
                    uA = 0xff;
                    uR = pb[2];
                    uG = pb[1];
                    uB = pb[0];

                    pb += 3;
                    break;

                case D3DFMT_A8R8G8B8:
                    u = *((DWORD *) pb);

                    uA = (u >> 24) & 0xff;
                    uR = (u >> 16) & 0xff;
                    uG = (u >>  8) & 0xff;
                    uB = (u >>  0) & 0xff;

                    pb += 4;
                    break;
            }
            
            pColor->peRed   = (BYTE) uR;
            pColor->peGreen = (BYTE) uG;
            pColor->peBlue  = (BYTE) uB;
            pColor->peFlags = (BYTE) uA;
        
            pColor++;
        }
    }

    pbData += cbColorMap;
    cbData -= cbColorMap;


    // Image data
    UINT cbImage;
    if(Format == D3DFMT_X8R8G8B8)
        cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * (uBytes+1);
    else
        cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * uBytes;

    m_Format  = Format;
    m_pData   = pbData;
    m_Pitch   = (UINT) pFH->wWidth * uBytes;

    m_Width  = pFH->wWidth;
    m_Height = pFH->wHeight;


    if(!bRLE && bTopToBottom && bLeftToRight )
    {
        // Data is already in a format usable to D3D.. no conversion is necessary
        
        m_pData = new BYTE[cbImage];
        memcpy( m_pData, pbData, min(cbData, cbImage) );
        m_bDeleteData = TRUE;

        pbData += cbImage;
        cbData -= cbImage;
    }
    else
    {
        // Image data is compressed, or does not have origin at top-left
        if(!(m_pData = new BYTE[cbImage]))
            return E_OUTOFMEMORY;

        m_bDeleteData = TRUE;


        BYTE *pbDestY = bTopToBottom ? (BYTE *) m_pData : ((BYTE *) m_pData + (pFH->wHeight - 1) * m_Pitch);

        for(UINT uY = 0; uY < pFH->wHeight; uY++)
        {
            BYTE *pbDestX = bLeftToRight ? pbDestY : (pbDestY + m_Pitch - uBytes);

            for(UINT uX = 0; uX < pFH->wWidth; )
            {
                BOOL bRunLength;
                UINT uCount;

                if(bRLE)
                {
                    if(cbData < 1)
                        return E_FAIL;

                    bRunLength = *pbData & 0x80;
                    uCount = (*pbData & 0x7f) + 1;

                    pbData++;
                    cbData--;
                }
                else
                {
                    bRunLength = FALSE;
                    uCount = pFH->wWidth;
                }

                uX += uCount;

                while(uCount--)
                {
                    if(cbData < uBytes)
                        return E_FAIL;

                    memcpy(pbDestX, pbData, uBytes);

                    if(!bRunLength)
                    {
                        pbData += uBytes;
                        cbData -= uBytes;
                    }

                    pbDestX = bLeftToRight ? (pbDestX + uBytes) : (pbDestX - uBytes);
                }

                if(bRunLength)
                {
                    pbData += uBytes;
                    cbData -= uBytes;
                }
            }

            pbDestY = bTopToBottom ? (pbDestY + m_Pitch) : (pbDestY - m_Pitch);
        }
    }

    if(Format == D3DFMT_X8R8G8B8)
    {
        //convert from 24-bit R8G8B8 to 32-bit X8R8G8B8
        // do the conversion in-place
        BYTE *pSrc, *pDst;
        pSrc = (BYTE *)m_pData + (m_Height)*(m_Width*uBytes) - uBytes;
        pDst = (BYTE *)m_pData + (m_Height)*(m_Width*(uBytes+1)) - (uBytes+1);
            
        while(pSrc >= m_pData)
        {
            *(pDst+3) = 0xff;       //A
            *(pDst+2) = *(pSrc+2);  //R
            *(pDst+1) = *(pSrc+1);  //G
            *(pDst+0) = *pSrc;      //B
            pSrc -= 3;
            pDst -= 4;
        }
        m_Pitch   = m_Width * (uBytes+1);
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Anonymous enum
// Desc: Enumerations used for loading PPM files
//-----------------------------------------------------------------------------
enum
{
    PPM_WIDTH, PPM_HEIGHT, PPM_MAX, PPM_DATA_R, PPM_DATA_G, PPM_DATA_B
};




//-----------------------------------------------------------------------------
// Name: LoadPPM()
// Desc: Attempts to load the given data as a PPM file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadPPM( const VOID* pvData, DWORD cbData )
{
    BYTE *pbData = (BYTE *)pvData;

    // Check header
    BOOL bAscii;

    if(cbData < 2)
        return E_FAIL;

    if('P' == pbData[0] && '3' == pbData[1])
        bAscii = TRUE;
    else if('P' == pbData[0] && '6' == pbData[1])
        bAscii = FALSE;
    else
        return E_FAIL;

    pbData += 2;
    cbData -= 2;

    // Image data
    UINT uMode   = PPM_WIDTH;
    UINT uWidth  = 0;
    UINT uHeight = 0;
    UINT uMax    = 255;

    DWORD *pdw, *pdwLim;

    while(cbData)
    {
        if(!bAscii && PPM_DATA_R == uMode)
        {
            // Binary image data
            if(uMax > 255)
                return E_FAIL;

            if(cbData > 1 && '\r' == *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;

            while(cbData && pdw < pdwLim)
            {
                *pdw++ = ((255 * pbData[0] / uMax) << 16) |
                         ((255 * pbData[1] / uMax) <<  8) |
                         ((255 * pbData[2] / uMax) <<  0) | 0xff000000;

                pbData += 3;
                cbData -= 3;
            }

            if(pdw != pdwLim)
                return E_FAIL;

            return S_OK;
        }
        if(isspace(*pbData))
        {
            // Whitespace
            pbData++;
            cbData--;
        }
        else if('#' == *pbData)
        {
            // Comment
            while(cbData && '\n' != *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;
        }
        else
        {
            // Number
            UINT u = 0;

            while(cbData && !isspace(*pbData))
            {
                if(!isdigit(*pbData))
                    return E_FAIL;

                u = u * 10 + (*pbData - '0');

                pbData++;
                cbData--;
            }

            switch(uMode)
            {
                case PPM_WIDTH:
                    uWidth = u;

                    if(0 == uWidth)
                        return E_FAIL;

                    break;

                case PPM_HEIGHT:
                    uHeight = u;

                    if(0 == uHeight)
                        return E_FAIL;

                    if(!(m_pData = new BYTE[uWidth * uHeight * sizeof(DWORD)]))
                        return E_OUTOFMEMORY;

                    m_bDeleteData = TRUE;

                    pdw = (DWORD *) m_pData;
                    pdwLim = pdw + uWidth * uHeight;

                    m_Format = D3DFMT_X8R8G8B8;
                    m_Pitch  = uWidth * sizeof(DWORD);

                    m_Width  = uWidth;
                    m_Height = uHeight;
                    break;

                case PPM_MAX:
                    uMax = u;

                    if(0 == uMax)
                        return E_FAIL;

                    break;

                case PPM_DATA_R:
                    if(pdw >= pdwLim)
                        return E_FAIL;

                    *pdw  = ((u * 255 / uMax) << 16) | 0xff000000;
                    break;

                case PPM_DATA_G:
                    *pdw |= ((u * 255 / uMax) <<  8);
                    break;

                case PPM_DATA_B:
                    *pdw |= ((u * 255 / uMax) <<  0);

                    if(++pdw == pdwLim)
                        return S_OK;

                    uMode = PPM_DATA_R - 1;
                    break;
            }

            uMode++;
        }
    }

    return E_FAIL;
}




BOOL IsUvl( D3DFORMAT format )
{
    switch( format )
    {
//    case D3DFMT_LIN_V16U16:
//    case D3DFMT_LIN_V8U8:
//    case D3DFMT_LIN_L6V5U5:
//    case D3DFMT_LIN_X8L8V8U8:
//    case D3DFMT_LIN_Q8W8V8U8:
    case D3DFMT_V16U16:
    case D3DFMT_V8U8:
    case D3DFMT_L6V5U5:
    case D3DFMT_X8L8V8U8:
    case D3DFMT_Q8W8V8U8:
        return TRUE;
    default:
        return FALSE;
    }
}


HRESULT LoadImageFromImage( CImage* pDestImage, CImage* pSrcImage, DWORD dwFilter )
{
    RECT        srcRect;
    RECT        destRect;
    DWORD       dwRealFilter = dwFilter;
    CXD3DXBlt   Blt;
    HRESULT     hr;

    srcRect.left    = 0;
    srcRect.top     = 0;
    srcRect.right   = pSrcImage->m_Width;
    srcRect.bottom  = pSrcImage->m_Height;

    destRect.left   = 0;
    destRect.top    = 0;
    destRect.right  = pDestImage->m_Width;
    destRect.bottom = pDestImage->m_Height;

    if(D3DX_DEFAULT == dwRealFilter)
    {
        if(IsUvl(pSrcImage->m_Format))
            dwRealFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwRealFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }
    
    // Blt using specified filter
    D3DX_BLT DestBlt, SrcBlt;

    DestBlt.pData            = pDestImage->m_pData;
    DestBlt.RowPitch         = pDestImage->m_Pitch;
    DestBlt.SlicePitch       = 0;
    DestBlt.Format           = pDestImage->m_Format;
    DestBlt.ColorKey         = 0;
    DestBlt.pPalette         = pDestImage->m_pPalette;

    DestBlt.Region.Left      = 0;
    DestBlt.Region.Right     = (UINT) pDestImage->m_Width;
    DestBlt.Region.Top       = 0;
    DestBlt.Region.Bottom    = (UINT) pDestImage->m_Height;
    DestBlt.Region.Front     = 0;
    DestBlt.Region.Back      = 1;

    DestBlt.SubRegion.Left   = (UINT) destRect.left;
    DestBlt.SubRegion.Top    = (UINT) destRect.top;
    DestBlt.SubRegion.Right  = (UINT) destRect.right;
    DestBlt.SubRegion.Bottom = (UINT) destRect.bottom;
    DestBlt.SubRegion.Front  = 0;
    DestBlt.SubRegion.Back   = 1;


    SrcBlt.pData             = pSrcImage->m_pData;
    SrcBlt.RowPitch          = pSrcImage->m_Pitch;
    SrcBlt.SlicePitch        = 0;
    SrcBlt.Format            = pSrcImage->m_Format;
    SrcBlt.ColorKey          = 0;
    SrcBlt.pPalette          = pSrcImage->m_pPalette;

    SrcBlt.SubRegion.Left    = (UINT) srcRect.left;
    SrcBlt.SubRegion.Top     = (UINT) srcRect.top;
    SrcBlt.SubRegion.Right   = (UINT) srcRect.right;
    SrcBlt.SubRegion.Bottom  = (UINT) srcRect.bottom;
    SrcBlt.SubRegion.Front   = 0;
    SrcBlt.SubRegion.Back    = 1;

    if( FAILED( hr = Blt.Blt( &DestBlt, &SrcBlt, dwRealFilter ) ) )
        goto LDone;


    hr = S_OK;
    goto LDone;

LDone:
    return hr;
}

//-----------------------------------------------------------------------------
// Name: CVolume()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CVolume::CVolume()
{
    m_Format         = D3DFMT_UNKNOWN;
    m_pData          = NULL;
}




//-----------------------------------------------------------------------------
// Name: CVolume()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CVolume::CVolume( DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, D3DFORMAT format )
{
    m_Format            = format;
    m_Width             = dwWidth;
    m_Height            = dwHeight;
    m_Depth             = dwDepth;

    m_Box.Left         = 0;
    m_Box.Top          = 0;
    m_Box.Front        = 0;
    m_Box.Right        = dwWidth;
    m_Box.Bottom       = dwHeight;
    m_Box.Back         = dwDepth;

    // TODO: This needs to get straightened out
    m_RowPitch          = m_Width * sizeof( DWORD );
    m_SlicePitch        = m_Height * m_Width * sizeof( DWORD );
    m_pData             = new BYTE[ m_SlicePitch * m_Depth ];
}




//-----------------------------------------------------------------------------
// Name: ~CVolume()
// Desc: Frees resources held by the object
//-----------------------------------------------------------------------------
CVolume::~CVolume()
{
    delete[] m_pData;
}





HRESULT LoadVolumeFromVolume( CVolume* pDestVolume, CVolume* pSrcVolume, DWORD dwFilter )
{
    D3DBOX      srcBox;
    D3DBOX      destBox;
    DWORD       dwRealFilter = dwFilter;
    CXD3DXBlt   Blt;
    HRESULT     hr;

    srcBox.Left    = 0;
    srcBox.Top     = 0;
    srcBox.Front   = 0;
    srcBox.Right   = pSrcVolume->m_Width;
    srcBox.Bottom  = pSrcVolume->m_Height;
    srcBox.Back    = pSrcVolume->m_Depth;

    destBox.Left   = 0;
    destBox.Top    = 0;
    destBox.Front  = 0;
    destBox.Right  = pDestVolume->m_Width;
    destBox.Bottom = pDestVolume->m_Height;
    destBox.Back   = pDestVolume->m_Depth;

    if(D3DX_DEFAULT == dwRealFilter)
    {
        if(IsUvl(pSrcVolume->m_Format))
            dwRealFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwRealFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }
    
    // Blt using specified filter
    D3DX_BLT DestBlt, SrcBlt;

    DestBlt.pData            = pDestVolume->m_pData;
    DestBlt.RowPitch         = pDestVolume->m_RowPitch;
    DestBlt.SlicePitch       = pDestVolume->m_SlicePitch;
    DestBlt.Format           = pDestVolume->m_Format;
    DestBlt.ColorKey         = 0;
    DestBlt.pPalette         = NULL;

    DestBlt.Region.Left      = 0;
    DestBlt.Region.Top       = 0;
    DestBlt.Region.Front     = 0;
    DestBlt.Region.Right     = (UINT) pDestVolume->m_Width;
    DestBlt.Region.Bottom    = (UINT) pDestVolume->m_Height;
    DestBlt.Region.Back      = (UINT) pDestVolume->m_Depth;

    DestBlt.SubRegion.Left   = (UINT) destBox.Left;
    DestBlt.SubRegion.Top    = (UINT) destBox.Top;
    DestBlt.SubRegion.Front  = (UINT) destBox.Front;
    DestBlt.SubRegion.Right  = (UINT) destBox.Right;
    DestBlt.SubRegion.Bottom = (UINT) destBox.Bottom;
    DestBlt.SubRegion.Back   = (UINT) destBox.Back;


    SrcBlt.pData             = pSrcVolume->m_pData;
    SrcBlt.RowPitch          = pSrcVolume->m_RowPitch;
    SrcBlt.SlicePitch        = pSrcVolume->m_SlicePitch;
    SrcBlt.Format            = pSrcVolume->m_Format;
    SrcBlt.ColorKey          = 0;
    SrcBlt.pPalette          = NULL;

    SrcBlt.SubRegion.Left    = (UINT) srcBox.Left;
    SrcBlt.SubRegion.Top     = (UINT) srcBox.Top;
    SrcBlt.SubRegion.Front   = (UINT) srcBox.Front;
    SrcBlt.SubRegion.Right   = (UINT) srcBox.Right;
    SrcBlt.SubRegion.Bottom  = (UINT) srcBox.Bottom;
    SrcBlt.SubRegion.Back    = (UINT) srcBox.Back;

    if( FAILED( hr = Blt.Blt( &DestBlt, &SrcBlt, dwRealFilter ) ) )
        goto LDone;

    hr = S_OK;
    goto LDone;

LDone:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\LoadImage.h ===
//-----------------------------------------------------------------------------
// File: LoadImage.h
//
// Desc: Loads image files
//
// Hist: 04.13.01 - New for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef LOADIMAGE_H
#define LOADIMAGE_H

#include "bundler.h"

#define DPF(x,y)
#define D3DXASSERT(x)
#define D3DXERR_INVALIDDATA -1




//-----------------------------------------------------------------------------
// Name: class CImage
// Desc: Class to load different image formats
//-----------------------------------------------------------------------------
class CImage
{
public:
    CImage();
    CImage( DWORD dwWidth, DWORD dwHeight, D3DFORMAT format );
    ~CImage();

    VOID*           m_pData;
    D3DFORMAT       m_Format;
    DWORD           m_Width;
    DWORD           m_Height;
    DWORD           m_Pitch;
    PALETTEENTRY*   m_pPalette;

    RECT            m_Rect;

    BOOL            m_bDeleteData;
    BOOL            m_bDeletePalette;

    HRESULT LoadBMP( const VOID* pData, DWORD dwSize );
    HRESULT LoadDIB( const VOID* pData, DWORD dwSize );
    HRESULT LoadTGA( const VOID* pData, DWORD dwSize );
    HRESULT LoadPPM( const VOID* pData, DWORD dwSize );

public:
    HRESULT Load( const VOID* pData, DWORD dwSize );
    HRESULT Load( CHAR* strFilename );

    HRESULT Depalettize();
};

class CVolume
{
public:
    CVolume();
    CVolume( DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, D3DFORMAT format );
    ~CVolume();

    VOID*           m_pData;
    D3DFORMAT       m_Format;
    DWORD           m_Width;
    DWORD           m_Height;
    DWORD           m_Depth;
    DWORD           m_RowPitch;
    DWORD           m_SlicePitch;

    D3DBOX          m_Box;
};


HRESULT LoadImageFromImage( CImage* pDestImage, CImage* pSrcImage, DWORD dwFilter );
HRESULT LoadVolumeFromVolume( CVolume* pDestVolume, CVolume* pSrcVolume, DWORD dwFilter );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\texture.cpp ===
//-----------------------------------------------------------------------------
// File: Texture.cpp
//
// Desc: Contains the texture-specific logic for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//       04.13.01 - Reorganized for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include "Texture.h"
#include "Bundler.h"
#include "LoadImage.h"




//-----------------------------------------------------------------------------
// Name: CTexture2D()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CTexture2D::CTexture2D( CBundler* pBundler )
           :CBaseTexture( pBundler )
{
    m_strSource[0]      = 0;
    m_strAlphaSource[0] = 0;
    m_pImage            = NULL;
    m_dwWidth           = 0;
    m_dwHeight          = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CTexture2D()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CTexture2D::~CTexture2D()
{
    delete m_pImage;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CTexture2D::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    // Load the texture from disk, and set default values from it
    hr = LoadTexture();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save texture data
    (*pcbData) = 0;
    SaveImage( pcbData, m_dwLevels, m_pImage );
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadTexture()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CTexture2D::LoadTexture()
{
    HRESULT hr;

    // Load the imagesurfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    hr = LoadImage( m_strSource, m_strAlphaSource, &m_pImage );
    if( hr == E_HANDLE )
    {
        if( m_strAlphaSource[0] )
            m_pBundler->ErrorMsg( "Texture: Couldn't open source file <%s> or <%s>\n", m_strSource, m_strAlphaSource );
        else
            m_pBundler->ErrorMsg( "Texture: Couldn't open source file <%s>\n", m_strSource );

        return hr;
    }
    else if( FAILED( hr ) )
    {
        // If the conventional load methods failed, we can try using D3DX as a
        // last ditch effort. This will load DDS files, JPGs, etc., but has
        // limitations like only pow-2 dimensions.

        hr = LoadImageUsingD3DX( m_strSource, m_strAlphaSource, &m_pImage );
        if( FAILED( hr ) )
        {
            if( m_strAlphaSource[0] )
                m_pBundler->ErrorMsg( "Texture: Couldn't load source file <%s> or <%s>\n", m_strSource, m_strAlphaSource );
            else
                m_pBundler->ErrorMsg( "Texture: Couldn't load source file <%s>\n", m_strSource );
            return hr;
        }
    }

    // Try to look up our format string
    if( m_strFormat[0] )
    {
        m_nFormat = FormatFromString( m_strFormat );
        if( m_nFormat < -1 )
        {
            m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
            return E_FAIL;
        }
    }

    // If the format is still not determined, resort to A8R8G8B8
    if( m_nFormat < 0 )
    {
        lstrcpyA( m_strFormat, "D3DFMT_A8R8G8B8" );
        m_nFormat = FormatFromString( m_strFormat );
    }

    // Determine final width and height
    if( m_dwWidth==0 || m_dwHeight==0 )
    {
        if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
        {
            // Linear textures can have any size
            m_dwWidth  = m_pImage->m_Width;
            m_dwHeight = m_pImage->m_Height;
        }
        else
        {
            // Enforce power-of-two dimensions for swizzled and compressed textures
            for( m_dwWidth=1;  m_dwWidth  < m_pImage->m_Width;  m_dwWidth<<=1 );
            for( m_dwHeight=1; m_dwHeight < m_pImage->m_Height; m_dwHeight<<=1 );
        }
    }

    // Determine final number of miplevels
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_dwLevels = 1;
    }
    else
    {
        // Count levels
        DWORD dwLevels = 1; 
        while( ( (1UL<<(dwLevels-1)) < m_dwWidth ) && ( (1UL<<(dwLevels-1))<m_dwHeight ) )
            dwLevels++;
            
        if( m_dwLevels < 1 || m_dwLevels > dwLevels )
            m_dwLevels = dwLevels;
    }

    // Change the size of the surface
    hr = ResizeImage( m_dwWidth, m_dwHeight, &m_pImage );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CTexture2D::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
    D3DTexture d3dtex;

    XGSetTextureHeader(m_dwWidth, m_dwHeight, m_dwLevels, 0,
                       (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                       D3DPOOL_DEFAULT, (IDirect3DTexture8*)&d3dtex,
                       dwStart, 0);

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( d3dtex );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\IndexBuffer.cpp ===
//-----------------------------------------------------------------------------
// File: IndexBuffer.cpp
//
// Desc: Contains the index buffer-specific logic for the bundler tool
//
// Hist: 11.30.01 - New for December
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "IndexBuffer.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CIndexBuffer()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CIndexBuffer::CIndexBuffer( CBundler* pBundler )
{
    m_pBundler  = pBundler;
    m_dwIndices = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CIndexBuffer (destructor)
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CIndexBuffer::~CIndexBuffer()
{
}




//-----------------------------------------------------------------------------
// Name: AddVertexData()
// Desc: Adds a single value to the vertex data stream
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::AddIndex( WORD wVal )
{
    if( m_dwIndices >= MAX_INDICES )
    {
        m_pBundler->ErrorMsg( "Error: Index Data Buffer Overflow\n" );
        return E_FAIL;
    }
    m_Indices[ m_dwIndices++ ] = wVal;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadIndicesFromFile
// Desc: Loads entire vertex data stream from file
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::LoadIndicesFromFile( CHAR* strFilename )
{
    // Open the file
    HANDLE hFile = CreateFileA( strFilename, 
                                GENERIC_READ, 
                                FILE_SHARE_READ, 
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Make sure we can fit the whole thing in memory.
    // TODO: Dynamically allocate memory for index buffers
    DWORD dwSize = GetFileSize( hFile, NULL );
    if( dwSize > sizeof( m_Indices ) )
    {
        m_pBundler->ErrorMsg( "Error: Index data file too large.\n" );
        return E_FAIL;
    }

    // Read the data
    DWORD dwRead;
    ReadFile( hFile, m_Indices, dwSize, &dwRead, NULL );
    if( dwRead != dwSize )
        return E_FAIL;

    CloseHandle( hFile );

    m_dwIndices = dwRead / sizeof( WORD );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::SaveToBundle( DWORD * pcbHeader, DWORD * pcbData )
{
    HRESULT hr;

    if(m_dwIndices == 0)
    {
        m_pBundler->ErrorMsg( "Error: No indices specified\n" );
        return E_FAIL;
    }
    
    // Pad data file to proper alignment for the start of the vertex buffer
    hr = m_pBundler->PadToAlignment( D3DINDEXBUFFER_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save vertexbuffer data
    hr = SaveIndexBufferData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
    D3DIndexBuffer d3dvb;

    d3dvb.Common =  D3DCOMMON_TYPE_INDEXBUFFER |    // Type
                    1;                              // Initial Refcount

    d3dvb.Data   = dwStart;                    // Offset of data in data file
    d3dvb.Lock   = 0;                          // Must be zero


    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dvb, sizeof( d3dvb ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( d3dvb );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveIndexBufferData()
// Desc: Saves the raw VertexBuffer data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::SaveIndexBufferData( DWORD * pcbData )
{
    *pcbData = m_dwIndices * sizeof( WORD );
    m_pBundler->WriteData( m_Indices, *pcbData );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\IndexBuffer.h ===
//-----------------------------------------------------------------------------
// File: IndexBuffer.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the index buffer-related functionality of the bundler tool
//
// Hist: 11.30.01 - New for December
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef INDEXBUFFER_H
#define INDEXBUFFER_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h

#define D3DINDEXBUFFER_ALIGNMENT     4

#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_VIDEOMEMORY        0x00800000


// IndexBuffer Format
typedef struct 
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
} D3DIndexBuffer;


#define MAX_INDICES 65536




//-----------------------------------------------------------------------------
// Name: class CVertexBuffer
// Desc: Handles all vb-specific processing
//-----------------------------------------------------------------------------
class CIndexBuffer
{
public:
    CIndexBuffer( CBundler * pBundler );
    ~CIndexBuffer();

    HRESULT SaveToBundle( DWORD *pcbHeader, DWORD *pcbData );
    HRESULT AddIndex( WORD wVal );
    HRESULT LoadIndicesFromFile( CHAR* strFilename );

    DWORD  m_dwIndices;

private:
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader );
    HRESULT SaveIndexBufferData( DWORD * pcbData );

    CBundler * m_pBundler;
    WORD   m_Indices[MAX_INDICES];
};


#endif // IndexBuffer_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\texture.h ===
//-----------------------------------------------------------------------------
// File: Texture.h
//
// Desc: Header file containing class definition for the 2d texture-related 
//       functionality of the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//       04.13.01 - Reorganized for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TEXTURE_H
#define TEXTURE_H


#include "LoadImage.h"
#include "BaseTexture.h"




//-----------------------------------------------------------------------------
// Name: class CTexture2D
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CTexture2D : public CBaseTexture
{
public:
    CTexture2D( CBundler* pBundler );
    ~CTexture2D();

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CHAR  m_strSource[MAX_PATH];
    CHAR  m_strAlphaSource[MAX_PATH];
    DWORD m_dwWidth;
    DWORD m_dwHeight;

protected:
    HRESULT LoadTexture();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

    CImage* m_pImage;
};


#endif // TEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\userdata.cpp ===
//-----------------------------------------------------------------------------
// File: UserData.cpp
//
// Desc: Contains the userdata-specific logic for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "UserData.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CUserData()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CUserData::CUserData( CBundler* pBundler )
{
    m_pBundler     = pBundler;
    m_strSource[0] = '\0';
    m_pData        = NULL;
    m_dwDataSize   = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CUserData()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CUserData::~CUserData()
{
    if( m_pData )
        delete[] m_pData;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    if( 0 == m_strSource[0] )
    {
        m_pBundler->ErrorMsg( "Error: No source specified\n" );
        return E_FAIL;
    }

    // Add the path (if necessary) to the source filename
    CHAR strUserDataFilePath[MAX_PATH];
    if( strchr( m_strSource, ':' ) )
        strcpy( strUserDataFilePath, m_strSource );
    else
    {
        strcpy( strUserDataFilePath, m_pBundler->m_strPath );
        strcat( strUserDataFilePath, m_strSource );
    }

    HANDLE hFile = CreateFileA( strUserDataFilePath, GENERIC_READ, FILE_SHARE_READ,
                                NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        m_pBundler->ErrorMsg( "Error: Could not find userdata source: %s\n", m_strSource );
        return E_FAIL;
    }

    // Allocate memory
    m_dwDataSize = GetFileSize( hFile, NULL );
    m_pData      = new BYTE[8+m_dwDataSize];

    ((DWORD*)m_pData)[0] = 0x80000000;
    ((DWORD*)m_pData)[1] = m_dwDataSize;

    // Read the file
    DWORD dwRead;
    ReadFile( hFile, (BYTE*)m_pData+8, m_dwDataSize, &dwRead, NULL );
    CloseHandle( hFile );

    // Pad data file to proper alignment for the start of the userdata
    hr = m_pBundler->PadToAlignment( USERDATA_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save userdata data
    hr = SaveUserDataData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
/*
    DWORD dwUserDataID = 0x8000000;

    // Write the userdata tag to the resource header
    if( FAILED( m_pBundler->WriteHeader( &dwUserDataID, sizeof(DWORD) ) ) )
        return E_FAIL;

    // Write the userdata size to the resource header
    if( FAILED( m_pBundler->WriteHeader( &m_dwDataSize, sizeof(DWORD) ) ) )
        return E_FAIL;

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( m_pData, m_dwDataSize ) ) )
        return E_FAIL;
*/
    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( m_pData, m_dwDataSize+8 ) ) )
        return E_FAIL;

    (*pcbHeader) = m_dwDataSize+8;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveUserDataData()
// Desc: Saves the raw UserData data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveUserDataData( DWORD* pcbData )
{
    // There shouldn't be any video memory data to write
    (*pcbData) = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\vb.h ===
//-----------------------------------------------------------------------------
// File: vb.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the vertexbuffer-related functionality of the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VB_H
#define VB_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h

#define D3DVERTEXBUFFER_ALIGNMENT     4

#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_VIDEOMEMORY        0x00800000

// Vertex attribute formats
#define XD3DVSDT_FLOAT1      0x00    // 1D float expanded to (value, 0., 0., 1.)
#define XD3DVSDT_FLOAT2      0x01    // 2D float expanded to (value, value, 0., 1.)
#define XD3DVSDT_FLOAT3      0x02    // 3D float expanded to (value, value, value, 1.)
#define XD3DVSDT_FLOAT4      0x03    // 4D float
#define XD3DVSDT_D3DCOLOR    0x04    // 4D packed unsigned bytes mapped to 0. to 1. range
#define XD3DVSDT_SHORT2      0x06    // 2D signed short expanded to (value, value, 0., 1.)
#define XD3DVSDT_SHORT4      0x07    // 4D signed short
#define XD3DVSDT_NORMSHORT1  0x08    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
#define XD3DVSDT_NORMSHORT2  0x09    // 2D signed, normalized short expanded to (value, value, 0., 1.)
#define XD3DVSDT_NORMSHORT3  0x0A    // 3D signed, normalized short expanded to (value, value, value, 1.)  
#define XD3DVSDT_NORMSHORT4  0x0B    // 4D signed, normalized short expanded to (value, value, value, value)  
#define XD3DVSDT_NORMPACKED3 0x0C    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
#define XD3DVSDT_SHORT1      0x0D    // 1D signed short expanded to (value, 0., 0., 1.)  
#define XD3DVSDT_SHORT3      0x0E    // 3D signed short expanded to (value, value, value, 1.)
#define XD3DVSDT_PBYTE1      0x0F    // 1D packed byte expanded to (value, 0., 0., 1.)  
#define XD3DVSDT_PBYTE2      0x10    // 2D packed byte expanded to (value, value, 0., 1.)
#define XD3DVSDT_PBYTE3      0x11    // 3D packed byte expanded to (value, value, value, 1.)
#define XD3DVSDT_PBYTE4      0x12    // 4D packed byte expanded to (value, value, value, value) 
#define XD3DVSDT_FLOAT2H     0x13    // 2D homogeneous float expanded to (value, value,0., value.)


// VertexBuffer Format
typedef struct 
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
} D3DVertexBuffer;


#define MAX_VB_DATA 655360
#define MAX_VB_FORMATS 32




//-----------------------------------------------------------------------------
// Name: class CVertexBuffer
// Desc: Handles all vb-specific processing
//-----------------------------------------------------------------------------
class CVertexBuffer
{
public:
    CVertexBuffer( CBundler * pBundler );
    ~CVertexBuffer();

    HRESULT SaveToBundle( DWORD *pcbHeader, DWORD *pcbData );
    HRESULT AddVertexData( DOUBLE val );
    HRESULT AddVertexFormat( DWORD format );
    HRESULT LoadVertexDataFromFile( CHAR* strFilename );
    DWORD   m_cBytesPerVertex;
    DWORD   m_cInputValuesPerVertex;
    DWORD   m_cVertices;
    DWORD   m_cTotalBytesinVB;

private:
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader );
    HRESULT SaveVertexBufferData( DWORD * pcbData );

    CBundler * m_pBundler;
    DOUBLE m_Data[MAX_VB_DATA];
    DWORD  m_Format[MAX_VB_FORMATS];
    DWORD  m_DataCount;
    DWORD  m_FormatCount;
    BOOL   m_bRawVertices;
};


#endif // VB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\token.cpp ===
//-----------------------------------------------------------------------------
// File: Token.cpp
//
// Desc: Contains the logic for extracting tokens from the resource
//       description file
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Bundler.h"
#include <stdio.h>


// Token defintions
const BUNDLERTOKEN g_Tokens[] =
{
    // Token string         token enumeration                   type            handler function
    { "",                   TOKEN_RESOURCE_EOF,                 TT_ANY,         CBundler::HandleEOFToken        },
    { "{",                  TOKEN_RESOURCE_OPENBRACE,           TT_ANY,         NULL                            },
    { "}",                  TOKEN_RESOURCE_CLOSEBRACE,          TT_ANY,         NULL                            },
    { "out_packedresource", TOKEN_RESOURCE_OUT_PACKEDRESOURCE,  TT_ANY,         CBundler::HandleOutPackedResourceToken      },
    { "out_header",         TOKEN_RESOURCE_OUT_HEADER,          TT_ANY,         CBundler::HandleOutHeaderToken  },
    { "out_prefix",         TOKEN_RESOURCE_OUT_PREFIX,          TT_ANY,         CBundler::HandleOutPrefixToken  },
    { "out_error",          TOKEN_RESOURCE_OUT_ERROR,           TT_ANY,         CBundler::HandleOutErrorToken   },

    { "Texture",            TOKEN_RESOURCE_TEXTURE,             TT_ANY,         CBundler::HandleTextureToken    },
    { "Source",             TOKEN_PROPERTY_TEXTURE_SOURCE,      TT_FILENAME,    NULL                            },
    { "AlphaSource",        TOKEN_PROPERTY_TEXTURE_ALPHASOURCE, TT_FILENAME,    NULL                            },
    { "Filter",             TOKEN_PROPERTY_TEXTURE_FILTER,      TT_ANY,         NULL                            },
    { "Format",             TOKEN_PROPERTY_TEXTURE_FORMAT,      TT_IDENTIFIER,  NULL                            },
    { "Width",              TOKEN_PROPERTY_TEXTURE_WIDTH,       TT_INTEGER,     NULL                            },
    { "Height",             TOKEN_PROPERTY_TEXTURE_HEIGHT,      TT_INTEGER,     NULL                            },
    { "Levels",             TOKEN_PROPERTY_TEXTURE_LEVELS,      TT_INTEGER,     NULL                            },
    
    { "Cubemap",            TOKEN_RESOURCE_CUBEMAP,                TT_ANY,         CBundler::HandleCubemapToken    },
    { "SourceXP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_XP,      TT_FILENAME,    NULL                            },
    { "SourceXN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_XN,      TT_FILENAME,    NULL                            },
    { "SourceYP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_YP,      TT_FILENAME,    NULL                            },
    { "SourceYN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_YN,      TT_FILENAME,    NULL                            },
    { "SourceZP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP,      TT_FILENAME,    NULL                            },
    { "SourceZN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN,      TT_FILENAME,    NULL                            },
    { "AlphaSourceXP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP, TT_FILENAME,    NULL                            },
    { "AlphaSourceXN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN, TT_FILENAME,    NULL                            },
    { "AlphaSourceYP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP, TT_FILENAME,    NULL                            },
    { "AlphaSourceYN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN, TT_FILENAME,    NULL                            },
    { "AlphaSourceZP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP, TT_FILENAME,    NULL                            },
    { "AlphaSourceZN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN, TT_FILENAME,    NULL                            },
    { "Size",               TOKEN_PROPERTY_CUBEMAP_SIZE,           TT_INTEGER,     NULL                            },

    { "VolumeTexture",      TOKEN_RESOURCE_VOLUMETEXTURE,             TT_ANY,         CBundler::HandleVolumeTextureToken },
//    { "Source",             TOKEN_PROPERTY_VOLUMETEXTURE_SOURCE,      TT_FILENAME,    NULL                             },
//    { "AlphaSource",        TOKEN_PROPERTY_VOLUMETEXTURE_ALPHASOURCE, TT_FILENAME,    NULL                             },
    { "Depth",              TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH,       TT_INTEGER,     NULL                               },

    { "VertexBuffer",       TOKEN_RESOURCE_VERTEXBUFFER,        TT_ANY,         CBundler::HandleVertexBufferToken  },
    { "VertexData",         TOKEN_PROPERTY_VB_VERTEXDATA,       TT_ANY,         NULL                               },
    { "VertexFormat",       TOKEN_PROPERTY_VB_VERTEXFORMAT,     TT_ANY,         NULL                               },
    { "VertexFile",         TOKEN_PROPERTY_VB_VERTEXFILE,       TT_FILENAME,    NULL                               },

    { "UserData",           TOKEN_RESOURCE_USERDATA,            TT_ANY,         CBundler::HandleUserDataToken},
    { "DataFile",           TOKEN_PROPERTY_USERDATA_DATAFILE,   TT_ANY,         NULL },

    { "IndexBuffer",        TOKEN_RESOURCE_INDEXBUFFER,             TT_ANY,         CBundler::HandleIndexBufferToken   },
    { "IndexData",          TOKEN_PROPERTY_INDEXBUFFER_INDEXDATA,   TT_ANY,         NULL                               },
    { "IndexFile",          TOKEN_PROPERTY_INDEXBUFFER_INDEXFILE,   TT_FILENAME,    NULL                               },

};




//-----------------------------------------------------------------------------
// Name: IsAlphaChar()
// Desc: TRUE for [a-zA-Z]
//-----------------------------------------------------------------------------
BOOL IsAlphaChar( char ch )
{
    return( ( ( ch >= 'a' ) && ( ch <= 'z' ) )  ||
            ( ( ch >= 'A' ) && ( ch <= 'Z' ) ) );
}




//-----------------------------------------------------------------------------
// Name: IsNumberChar()
// Desc: TRUE for [0-9]
//-----------------------------------------------------------------------------
BOOL IsNumberChar( char ch )
{
    return( ( ch >= '0' ) && ( ch <= '9' ) );
}




//-----------------------------------------------------------------------------
// Name: IsIdentifierChar()
// Desc: TRUE for [a-zA-Z0-9_]
//-----------------------------------------------------------------------------
BOOL IsIdentifierChar( char ch )
{
    return( IsAlphaChar( ch )  ||
            IsNumberChar( ch ) ||
            ch == '_' );
}




//-----------------------------------------------------------------------------
// Name: IsHexChar()
// Desc: TRUE for [a-fA-F0-9]
//-----------------------------------------------------------------------------
BOOL IsHexChar( char ch )
{
    return( ( ( ch >= 'a' ) && ( ch <= 'f' ) )  ||
            ( ( ch >= 'A' ) && ( ch <= 'F' ) )  ||
            IsNumberChar( ch ) );
}
            



//-----------------------------------------------------------------------------
// Name: IsWhiteSpaceChar()
// Desc: TRUE for [ \t\r\n]
//-----------------------------------------------------------------------------
BOOL IsWhiteSpaceChar( char ch )
{
    return( ( ch == ' '  ) ||
            ( ch == '\t' ) ||
            ( ch == '\r' ) ||
            ( ch == '\n' ) ||
            ( ch == ','  ) );   // commas are whitespace for this parser
}




//-----------------------------------------------------------------------------
// Name: TerminatesToken()
// Desc: True if next char starts new token or breaks between token
//-----------------------------------------------------------------------------
BOOL TerminatesToken( char ch )
{
    if(IsWhiteSpaceChar( ch )) return TRUE;
    if((ch == '{') ||
       (ch == '}') ||
       (ch == TOKEOF)) return TRUE;

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: IsFilenameChar()
// Desc: TRUE for [^\[\]\:\\/<>\=;,\t\r\n ]
//-----------------------------------------------------------------------------
BOOL IsFilenameChar( char ch )
{
    return( ch != '[' &&
            ch != ']' &&
            ch != ':' &&
            ch != '\\' &&
            ch != '/' &&
            ch != '<' &&
            ch != '>' &&
            ch != '=' &&
            ch != ';' &&
            ch != ',' &&
            ch != '\t' &&
            ch != '\r' &&
            ch != '\n' );
}




//-----------------------------------------------------------------------------
// Name: GetChar()
// Desc: Gets the next character from the input file, removed comments
//-----------------------------------------------------------------------------
CHAR CBundler::GetChar()
{
    DWORD cb;
    CHAR tmp = m_cNext0;
    m_cNext0 = m_cNext1;
    m_cNext1 = m_cNext2;
    m_cNext2 = m_cNext3;
    ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
    if(cb == 0)
        m_cNext3 = TOKEOF;

    if((m_cNext0 == (CHAR)0xff) && (m_cNext1 == (CHAR)0xfe))
    {
        ErrorMsg( "Error: Unicode files are not supported\n");
        return TOKEOF;
    }
    
    while(TRUE)
    {
        // check for // comment
        if((m_cNext2 == '/') && (m_cNext3 == '/'))
        {
            // skip until \n for eof
            while((m_cNext2 != '\n') && (m_cNext2 != TOKEOF))
            {
                m_cNext2 = m_cNext3;
                ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
                if(cb == 0)
                    m_cNext3 = TOKEOF;
            }
        }
        // check for /* comment
        if((m_cNext2 == '/') && (m_cNext3 == '*'))
        {
            // skip until */ or eof
            while(!(((m_cNext2 == '*') && (m_cNext3 == '/')) || (m_cNext2 == TOKEOF)))
            {
                m_cNext2 = m_cNext3;
                ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
                if(cb == 0)
                    m_cNext3 = TOKEOF;
            }
            ReadFile( m_hfRDF, &m_cNext2, 1, &cb, NULL );
            if(cb == 0)
                m_cNext2 = TOKEOF;
            ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
            if(cb == 0)
                m_cNext3 = TOKEOF;
        }
        return tmp;
    }
}




//-----------------------------------------------------------------------------
// Name: PeekChar()
// Desc: Gets the next character from the input file without advancing the read
//       pointer.
//-----------------------------------------------------------------------------
CHAR CBundler::PeekChar()
{
    return m_cNext0;
}




//-----------------------------------------------------------------------------
// Name: GetNextTokenString()
// Desc: Gets the next token from the resource definition file.  
//-----------------------------------------------------------------------------
HRESULT CBundler::GetNextTokenString( char *strTokenString, TOKENTYPE tt )
{
    CHAR *cPtr = strTokenString;
    CHAR c;

    // skip whitespace
    while(IsWhiteSpaceChar(c=GetChar()));
    
    if(c == TOKEOF)
        return S_OK;        // eof

    *cPtr++ = c;

    if((c == '{') ||
       (c == '}'))
        return S_OK;        // single character tokens
    
    while(!TerminatesToken(PeekChar()))
        *cPtr++ = GetChar();

    *cPtr++ = '\0';     // terminate the string

    // Check that it's an appropriate type
    if( FAILED( ValidateType( strTokenString, tt ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ValidateIdentifier()
// Desc: Verifies that the token is in the proper form for an identifier:
// ([A-za-z]+[A-Za-z0-9_]*)
//-----------------------------------------------------------------------------
static BOOL ValidateIdentifier( char* strToken )
{
    int i;

    if( !IsAlphaChar( strToken[0] ) )
        return FALSE;

    for( i = 1; strToken[i] != 0; i++ )
    {
        if( !IsIdentifierChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateHexNumber()
// Desc: Verifies that the token is in the proper form for a hex number:
// (0[x|X][0-9A-Fa-f]+)
//-----------------------------------------------------------------------------
static BOOL ValidateHexNumber( char* strToken )
{
    int i;

    if( strToken[0] != '0' )
        return FALSE;
    if( strToken[1] != 'x' &&
        strToken[1] != 'X' )
        return FALSE;
    
    for( i = 2; strToken[i] != 0; i++ )
    {
        if( !IsHexChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateInteger()
// Desc: Verifies that the token is in the proper form for a integer:
// ([-|][0-9]+)
//-----------------------------------------------------------------------------
static BOOL ValidateInteger( char* strToken )
{
    int i = 0;

    if( strToken[0] == '-' )
        i++;

    for( ; strToken[i] != 0; i++ )
    {
        if( !IsNumberChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateFloat()
// Desc: Verifies that the token is in the proper form for a float:
// [-|](([0-9]+(\.[0-9]+|)|\.[0-9]+)([Ee](\+|-|)[0-9]+|))
//-----------------------------------------------------------------------------
static BOOL ValidateFloat( char* strToken )
{
    int i = 0;
    BOOL bDecimal = FALSE;
    BOOL bExponent = FALSE;
    
    if( strToken[0] == '-' )
        i++;

    for( ; strToken[i] != 0; i++ )
    {
        if( strToken[i] == '.' )
        {
            if( bDecimal )
                return FALSE;
            bDecimal = TRUE;
        }
        else if( strToken[i] == 'e' ||
                 strToken[i] == 'E' )
        {
            if( bExponent )
                return FALSE;

            bDecimal = bExponent = TRUE;
            if( strToken[i + 1] == '+' ||
                strToken[i + 1] == '-' )
                i++;
        }
        else if( !IsNumberChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateFilename()
// Desc: Verifies that the token is in the proper form for a filename:
// (([A-Za-z]:|)(\\|/)(\:f(\\|/))*\:f)  where :f is a sequence of filename chars
//-----------------------------------------------------------------------------
static BOOL ValidateFilename( char* strToken )
{
    int i = 0;
    BOOL bLastWasSlash = FALSE;

    if( IsAlphaChar( strToken[0] ) &&
        strToken[1] == ':' )
    {
        i = 2;
    }

    for( ; strToken[i] != 0; i++ )
    {
        if( strToken[i] == '\\' ||
            strToken[i] == '/' )
        {
            bLastWasSlash = TRUE;
            continue;
        }

        if( !IsFilenameChar( strToken[i] ) )
            return FALSE;

        bLastWasSlash = FALSE;
    }

    return !bLastWasSlash;
}




//-----------------------------------------------------------------------------
// Name: ValidateType()
// Desc: Checks to see if the token is of the appropriate type.  If not, 
//       outputs an error message
//-----------------------------------------------------------------------------
HRESULT CBundler::ValidateType( char* strToken, TOKENTYPE tt )
{
    BOOL bValid;

    switch( tt )
    {
		case TT_ANY:
			bValid = TRUE;
			break;
		case TT_IDENTIFIER:
			bValid = ValidateIdentifier( strToken );
			break;
		case TT_HEXNUMBER:
			bValid = ValidateHexNumber( strToken );
			break;
		case TT_INTEGER:
			bValid = ValidateInteger( strToken );
			break;
		case TT_FLOAT:
			bValid = ValidateFloat( strToken );
			break;
		case TT_FILENAME:
			bValid = ValidateFilename( strToken );
			break;
    }

    if( !bValid )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTokenFromString()
// Desc: Finds the token matching the given string
//-----------------------------------------------------------------------------
HRESULT CBundler::GetTokenFromString( char * strTokenString, BUNDLERTOKEN * pTok )
{
    // This lookup could be made faster via binary search or hashing
    for( int i = 0; i < sizeof( g_Tokens ) / sizeof( g_Tokens[0] ); i++ )
    {
        // Do we have a match?
        if( !lstrcmpi( strTokenString, g_Tokens[i].strKeyword ) )
        {
            *pTok = g_Tokens[i];
            return S_OK;
        }
    }

    ErrorMsg( "Unknown token <%s>\n", strTokenString );
    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: GetNextToken()
// Desc: Gets the next token from the resource definition file
//-----------------------------------------------------------------------------
HRESULT CBundler::GetNextToken( BUNDLERTOKEN* pTok )
{
    HRESULT hr;
    char strTemp[MAX_PATH];

    ZeroMemory(strTemp, MAX_PATH);   // clear out old token string
    hr = GetNextTokenString( strTemp, TT_ANY );
    if( FAILED( hr ) )
        return hr;

    hr = GetTokenFromString( strTemp, pTok );
    if( FAILED( hr ) )
        return hr;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\userdata.h ===
//-----------------------------------------------------------------------------
// File: UserData.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the userdata-related functionality of the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef USERDATA_H
#define USERDATA_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h

#define USERDATA_ALIGNMENT     4




//-----------------------------------------------------------------------------
// Name: class CUserData
// Desc: Handles all vb-specific processing
//-----------------------------------------------------------------------------
class CUserData
{
    CBundler* m_pBundler;

    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );
    HRESULT SaveUserDataData( DWORD* pcbData );

public:
    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CHAR  m_strSource[MAX_PATH];
    VOID* m_pData;
    DWORD m_dwDataSize;

    CUserData( CBundler* pBundler );
    ~CUserData();
};


#endif // USERDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\VolumeTexture.h ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the volume texture-related functionality of the bundler tool
//
// Hist: 05.25.01 - New for July XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VOLUMETEXTURE_H
#define VOLUMETEXTURE_H

#include "Texture.h"


typedef CHAR FILENAME[80];

//-----------------------------------------------------------------------------
// Name: class CVolumeTexture
// Desc: Handles all VolumeTexture-specific processing, such as loading slices,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CVolumeTexture : public CBaseTexture
{
    CVolume* m_pVolume;
    CImage** m_apImages;

    HRESULT LoadVolumeTexture();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

public:
    FILENAME* m_astrSource;
    FILENAME* m_astrAlphaSource;
    DWORD     m_dwWidth;
    DWORD     m_dwHeight;
    DWORD     m_dwDepth;

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CVolumeTexture( CBundler* pBundler );
    ~CVolumeTexture();
};


#endif // VOLUMETEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\vb.cpp ===
//-----------------------------------------------------------------------------
// File: VB.cpp
//
// Desc: Contains the vertexbuffer-specific logic for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "VB.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CVertexBuffer()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CVertexBuffer::CVertexBuffer( CBundler* pBundler )
{
    m_pBundler = pBundler;
    m_DataCount = m_FormatCount = 0;
    m_bRawVertices = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CVertexBuffer (destructor)
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CVertexBuffer::~CVertexBuffer()
{
}




//-----------------------------------------------------------------------------
// Name: AddVertexData()
// Desc: Adds a single value to the vertex data stream
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::AddVertexData( DOUBLE val )
{
    if(m_DataCount >= MAX_VB_DATA)
    {
        m_pBundler->ErrorMsg( "Error: Vertex Data Buffer Overflow\n" );
        return E_FAIL;
    }
    m_Data[m_DataCount++] = val;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadVertexDataFromFile
// Desc: Loads entire vertex data stream from file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::LoadVertexDataFromFile( CHAR* strFilename )
{
    // Open the file
    HANDLE hFile = CreateFileA( strFilename, 
                                GENERIC_READ, 
                                FILE_SHARE_READ, 
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Make sure we can fit the whole thing in memory.
    // TODO: Dynamically allocate memory for vertex buffers
    DWORD dwSize = GetFileSize( hFile, NULL );
    if( dwSize > sizeof( m_Data ) )
    {
        m_pBundler->ErrorMsg( "Error: Vertex data file too large.\n" );
        return E_FAIL;
    }

    // Read the data
    DWORD dwRead;
    ReadFile( hFile, m_Data, dwSize, &dwRead, NULL );
    if( dwRead != dwSize )
        return E_FAIL;

    CloseHandle( hFile );

    m_bRawVertices = TRUE;
    m_DataCount = dwRead;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AddVertexFormat()
// Desc: Adds a single value to the vertex data format
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::AddVertexFormat( DWORD format )
{
    if(m_FormatCount >= MAX_VB_FORMATS)
    {
        m_pBundler->ErrorMsg( "Error: Vertex Format Buffer Overflow\n" );
        return E_FAIL;
    }
    m_Format[m_FormatCount++] = format;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveToBundle( DWORD * pcbHeader, DWORD * pcbData )
{
    HRESULT hr;

    if(m_FormatCount == 0)
    {
        m_pBundler->ErrorMsg( "Error: No attribute formats specified\n" );
        return E_FAIL;
    }
    
    if(m_DataCount == 0)
    {
        m_pBundler->ErrorMsg( "Error: No attribute data specified\n" );
        return E_FAIL;
    }
    
    // Pad data file to proper alignment for the start of the vertex buffer
    hr = m_pBundler->PadToAlignment( D3DVERTEXBUFFER_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save vertexbuffer data
    hr = SaveVertexBufferData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
    D3DVertexBuffer d3dvb;

    d3dvb.Common =  D3DCOMMON_TYPE_VERTEXBUFFER |    // Type
                    D3DCOMMON_VIDEOMEMORY |          // VB lives in video memory
                    1;                               // Initial Refcount

    d3dvb.Data   = dwStart;                    // Offset of data in data file
    d3dvb.Lock   = 0;                          // Must be zero


    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dvb, sizeof( d3dvb ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( d3dvb );

    return S_OK;
}




// This structure specifies how many values are read by each attribute
// type and how many bytes are output.
struct inout
{
    DWORD inputs;
    DWORD bytesout;
} FormatInfo[] =
{
    {1, sizeof(FLOAT)},   //XD3DVSDT_FLOAT1
    {2, 2*sizeof(FLOAT)}, //XD3DVSDT_FLOAT2
    {3, 3*sizeof(FLOAT)}, //XD3DVSDT_FLOAT3
    {4, 4*sizeof(FLOAT)}, //XD3DVSDT_FLOAT4
    {4, 4*sizeof(BYTE)},  //XD3DVSDT_D3DCOLOR
    {2, 2*sizeof(SHORT)}, //XD3DVSDT_SHORT2
    {4, 4*sizeof(SHORT)}, //XD3DVSDT_SHORT4
    {1, sizeof(SHORT)},   //XD3DVSDT_NORMSHORT1
    {2, 2*sizeof(SHORT)}, //XD3DVSDT_NORMSHORT2
    {3, 3*sizeof(SHORT)}, //XD3DVSDT_NORMSHORT3
    {4, 4*sizeof(SHORT)}, //XD3DVSDT_NORMSHORT4
    {3, sizeof(DWORD)},   //XD3DVSDT_NORMPACKED3
    {1, sizeof(SHORT)},   //XD3DVSDT_SHORT1
    {3, 3*sizeof(SHORT)}, //XD3DVSDT_SHORT3
    {1, sizeof(BYTE)},    //XD3DVSDT_PBYTE1
    {2, 2*sizeof(BYTE)},  //XD3DVSDT_PBYTE2
    {3, 3*sizeof(BYTE)},  //XD3DVSDT_PBYTE3
    {4, 4*sizeof(BYTE)},  //XD3DVSDT_PBYTE4
    {3, 3*sizeof(FLOAT)}, //XD3DVSDT_FLOAT2H
};




//-----------------------------------------------------------------------------
// Name: SaveVertexBufferData()
// Desc: Saves the raw VertexBuffer data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveVertexBufferData( DWORD * pcbData )
{
    DWORD cData, cFormat, cVertex;
    FLOAT fOut[4];
    DWORD dwOut[4];
    SHORT sOut[4];
    BYTE  bOut[4];

    // calculate how many bytes per vertex
    m_cBytesPerVertex = 0;
    m_cInputValuesPerVertex = 0;
    for(cFormat=0; cFormat < m_FormatCount; cFormat++)
    {
        m_cBytesPerVertex += FormatInfo[m_Format[cFormat]].bytesout;
        m_cInputValuesPerVertex += FormatInfo[m_Format[cFormat]].inputs;
    }

    // If we read raw vertex info from a file, just spew it out
    if( m_bRawVertices )
    {
        m_cVertices = m_DataCount / m_cBytesPerVertex;
        m_cTotalBytesinVB = m_DataCount;
        *pcbData = m_DataCount;

        if( FAILED( m_pBundler->WriteData( m_Data, m_DataCount ) ) )
            return E_FAIL;
        else
            return S_OK;
    }
    else
    {
        m_cVertices = m_DataCount/m_cInputValuesPerVertex;
        m_cTotalBytesinVB = m_cVertices*m_cBytesPerVertex;
        *pcbData = 0;
    }

    if((m_cVertices * m_cInputValuesPerVertex) != m_DataCount)
    {
        m_pBundler->ErrorMsg( "Warning: Extra Vertex Buffer Data:\n");
        m_pBundler->ErrorMsg( "         Format specifies %d values per vertex\n", m_cInputValuesPerVertex);
        m_pBundler->ErrorMsg( "         %d values supplied\n", m_DataCount);
        m_pBundler->ErrorMsg( "         Enough for %d vertices with %d values left over\n", m_cVertices, 
                             m_DataCount - m_cVertices * m_cInputValuesPerVertex);
    }

    for(cData = 0, cVertex = 0; cVertex < m_cVertices; cVertex++ )
    {
        for(cFormat=0; cFormat < m_FormatCount; cFormat++)
        {
            switch(m_Format[cFormat])
            {
				case XD3DVSDT_FLOAT1:
					*pcbData += sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT2:
					*pcbData += 2*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 2*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT2H:
				case XD3DVSDT_FLOAT3:
					*pcbData += 3*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					fOut[2] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 3*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT4:
					*pcbData += 4*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					fOut[2] = (FLOAT)m_Data[cData++];
					fOut[3] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 4*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_D3DCOLOR:
					*pcbData += 4*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[3] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 4*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT1:
					*pcbData += sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT2:
					*pcbData += 2*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 2*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT3:
					*pcbData += 3*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					sOut[2] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 3*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT4:
					*pcbData += 4*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					sOut[2] = (SHORT)m_Data[cData++];
					sOut[3] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 4*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT1:
					*pcbData += sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT2:
					*pcbData += 2*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 2*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT3:
					*pcbData += 3*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[2] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 3*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT4:
					*pcbData += 4*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[2] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[3] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 4*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMPACKED3:
					*pcbData += sizeof(DWORD);
					dwOut[0] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[1] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[2] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[3] = (dwOut[0] & 0xffe00000) |
							   ((dwOut[1] >> 11) & 0x001ffc00) |
							   ((dwOut[2] >> 22) & 0x000003ff);
					if( FAILED( m_pBundler->WriteData( &(dwOut[3]), sizeof(DWORD) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE1:
					*pcbData += sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE2:
					*pcbData += 2*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 2*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE3:
					*pcbData += 3*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 3*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE4:
					*pcbData += 4*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[3] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 4*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Bundler\VolumeTexture.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.cpp
//
// Desc: Contains the VolumeTexture-specific logic for the bundler tool
//
// Hist: 04.11.01 - New for May XDK release
//       01.29.02 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "VolumeTexture.h"
#include "Bundler.h"




//-----------------------------------------------------------------------------
// Name: CVolumeTexture()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CVolumeTexture::CVolumeTexture( CBundler* pBundler )
               :CBaseTexture( pBundler )
{
    m_apImages        = NULL;
    m_pVolume         = NULL;
    m_astrSource      = NULL;
    m_astrAlphaSource = NULL;
    m_dwWidth         = 0L;
    m_dwHeight        = 0L;
    m_dwDepth         = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CVolumeTexture()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CVolumeTexture::~CVolumeTexture()
{
    if( m_apImages )
    {
        for( DWORD i = 0; i < m_dwDepth; i++ )
        {
                delete m_apImages[i];
        }
        delete[] m_apImages;
    }

    delete m_pVolume;

    if( m_astrSource )
        delete[] m_astrSource;
    if( m_astrAlphaSource )
        delete[] m_astrAlphaSource;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    hr = LoadVolumeTexture();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save voleume texture data
    (*pcbData) = 0;

    SaveVolumeTexture( pcbData, m_dwLevels, m_pVolume );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadVolumeTexture()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::LoadVolumeTexture()
{
    HRESULT hr;

    // Try to look up our format string
    m_nFormat = FormatFromString( m_strFormat );
    if( m_nFormat < -1 )
    {
        m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
        return E_FAIL;
    }
    lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );

    // Make sure depth is a power of two for non-linear textures
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_pBundler->ErrorMsg( "Error: Volume textures must be swizzled or compressed.\n" );
        return E_FAIL;
    }

    // Make sure depth is a power of two
    DWORD dwDepth;
    for( dwDepth=1; dwDepth < m_dwDepth; dwDepth<<=1 );
    if( dwDepth != m_dwDepth )
    {
        m_pBundler->ErrorMsg( "Error: Volume texture dimensions must be a power-of-two" );
        return E_FAIL;
    }

    // If an alpha source was specified, make sure the format supports alpha
    for( DWORD i=0; i<m_dwDepth; i++ )
    {
        if( m_astrAlphaSource[i][0] ) 
        {
            if( g_TextureFormats[m_nFormat].dwNumAlphaBits == 0 )
            {
                m_pBundler->ErrorMsg( "Warning: an ALPHASOURCE was specified, yet the " \
                                      "requested texture format, %s,  does not have " \
                                      "any alpha.\n", m_strFormat );
            }
        }
    }

    // Load the image surfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    m_apImages = new CImage*[m_dwDepth];
    for( i = 0; i < m_dwDepth; i++ )
    {
        if( FAILED( hr = LoadImage( m_astrSource[i], m_astrAlphaSource[i], &m_apImages[i] ) ) )
        {
			if( m_astrAlphaSource[i] )
				m_pBundler->ErrorMsg( "Volume texture: Couldn't load source file <%s> or <%s>", m_astrSource[i], m_astrAlphaSource[i] );
			else
				m_pBundler->ErrorMsg( "Volume texture: Couldn't load source file <%s>", m_astrSource[i] );
            return hr;
        }
    }

    // If width or height wasn't specified, use dimensions from first source texture
    if( m_dwWidth==0 || m_dwHeight==0 )
    {
        DWORD dwWidth = m_apImages[0]->m_Width;
        DWORD dwHeight = m_apImages[0]->m_Height;

        // Enforce power-of-two dimensions
        for( m_dwWidth=1;   m_dwWidth  < dwWidth;   m_dwWidth<<=1 );
        for( m_dwHeight=1;  m_dwHeight < dwHeight;  m_dwHeight<<=1 );
    }

    // Keep dimensions in check
    if( m_dwWidth>512 || m_dwHeight>512 || m_dwDepth>512 )
    {
        m_pBundler->ErrorMsg( "Error: The max for volume texture dimensions is 512.\n" );
        return hr;
    }

    // Determine final number of miplevels
    DWORD dwLevels = 1; 
    while( (1UL<<(dwLevels-1)) < min( m_dwWidth, min( m_dwHeight, m_dwDepth ) ) )
        dwLevels++;
    
    if( m_dwLevels < 1 || m_dwLevels > dwLevels )
        m_dwLevels = dwLevels;

    // Change the size of the surfaces
    for( i=0; i<m_dwDepth; i++ )
    {
        hr = ResizeImage( m_dwWidth, m_dwHeight, &m_apImages[i] );
    }

    m_pVolume = new CVolume( m_dwWidth, m_dwHeight, m_dwDepth, D3DFMT_A8R8G8B8 );

    BYTE* pDest = (BYTE *)m_pVolume->m_pData;

    for( i = 0; i < m_dwDepth; i++ )
    {
        memcpy( pDest, m_apImages[i]->m_pData, m_dwWidth * m_dwHeight * sizeof( DWORD ) );
        pDest += m_dwWidth * m_dwHeight * sizeof( DWORD );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader )
{
    D3DTexture d3dtex;

    XGSetVolumeTextureHeader( m_dwWidth, m_dwHeight, m_dwDepth, m_dwLevels, 0,
                              (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                              D3DPOOL_DEFAULT, (IDirect3DVolumeTexture8*)&d3dtex,
                              dwStart, 0 );

    // Overwrite the error in XGSetVolumeTextureHeader
    {
        for( DWORD LogWidth=0;  (1UL<<LogWidth)  <= m_dwWidth;  LogWidth++ )
        for( DWORD LogHeight=0; (1UL<<LogHeight) <= m_dwHeight; LogHeight++ )
        for( DWORD LogDepth=0;  (1UL<<LogDepth)  <= m_dwDepth;  LogDepth++ )
        d3dtex.Format =  3 << D3DFORMAT_DIMENSION_SHIFT /* UNDONE: verify */
                         | g_TextureFormats[m_nFormat].dwXboxFormat << D3DFORMAT_FORMAT_SHIFT
                         | m_dwLevels << D3DFORMAT_MIPMAP_SHIFT
                         | LogWidth   << D3DFORMAT_USIZE_SHIFT
                         | LogHeight  << D3DFORMAT_VSIZE_SHIFT
                         | LogDepth   << D3DFORMAT_PSIZE_SHIFT
                         | D3DFORMAT_DMACHANNEL_B
                         | D3DFORMAT_BORDERSOURCE_COLOR;
    }

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    (*pcbHeader) = sizeof(d3dtex);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_




// pack the structure as we're reading it from the disk
#pragma pack( 1 )

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning( push )
#pragma warning( disable:4200 )




//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'




//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};




//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};




#pragma warning( pop )
#pragma pack( )




//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;




//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load( const char* filename );

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength( DWORD *pdwWidth, DWORD *pdwHeight, 
                              const char* Message );

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText( IDirect3DSurface8 *pSurface, const char* str, int iX,
                            int iY, DWORD dwFlags, D3DCOLOR colFore, 
                            D3DCOLOR colBack );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "bitfont.h"




//----------------------------------------------------------------------------
DWORD BitsPerPixelOfD3DFORMAT( DWORD Format );
DWORD dwColorFromD3DXColor( D3DFORMAT dwSurfaceFormat, D3DCOLOR color );




//----------------------------------------------------------------------------
// default font
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000f, 0x00000060, 0x00000008,
    0x000f0800, 0x1e080000, 0x08000000, 0x0000002d,
    0x00003c08, 0x004b0800, 0x5a080000, 0x08000000,
    0x00000069, 0x00007808, 0x00870800, 0x96080000,
    0x08000000, 0x000000a5, 0x0000b408, 0x00c30800,
    0xd2080000, 0x08000000, 0x000000e1, 0x0000f008,
    0x00ff0800, 0x0e080000, 0x08000001, 0x0000011d,
    0x00012c08, 0x013b0800, 0x4a080000, 0x08000001,
    0x00000159, 0x00016808, 0x01770800, 0x86080000,
    0x08000001, 0x00000195, 0x0001a408, 0x01b30800,
    0xc2080000, 0x08000001, 0x000001d1, 0x0001e008,
    0x01ef0800, 0xfe080000, 0x08000001, 0x0000020d,
    0x00021c08, 0x022b0800, 0x3a080000, 0x08000002,
    0x00000249, 0x00025808, 0x02670800, 0x76080000,
    0x08000002, 0x00000285, 0x00029408, 0x02a30800,
    0xb2080000, 0x08000002, 0x000002c1, 0x0002d008,
    0x02df0800, 0xee080000, 0x08000002, 0x000002fd,
    0x00030c08, 0x031b0800, 0x2a080000, 0x08000003,
    0x00000339, 0x00034808, 0x03570800, 0x66080000,
    0x08000003, 0x00000375, 0x00038408, 0x03930800,
    0xa2080000, 0x08000003, 0x000003b1, 0x0003c008,
    0x03cf0800, 0xde080000, 0x08000003, 0x000003ed,
    0x0003fc08, 0x040b0800, 0x1a080000, 0x08000004,
    0x00000429, 0x00043808, 0x04470800, 0x56080000,
    0x08000004, 0x00000465, 0x00047408, 0x04830800,
    0x92080000, 0x08000004, 0x000004a1, 0x0004b008,
    0x04bf0800, 0xce080000, 0x08000004, 0x000004dd,
    0x0004ec08, 0x04fb0800, 0x0a080000, 0x08000005,
    0x00000519, 0x00052808, 0x05370800, 0x46080000,
    0x08000005, 0x00000555, 0x00056408, 0x05730800,
    0x82080000, 0x08000005, 0x00000591, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc3e7ffff,
    0xe7e7c3c3, 0xffe7e7ff, 0xffffffff, 0x999999ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc980c9c9,
    0xc980c9c9, 0xffffffc9, 0xc3e7e7ff, 0xe7cf9f99,
    0xc399f9f3, 0xffffe7e7, 0x25278fff, 0xcfe7f389,
    0xf1e4a491, 0xffffffff, 0x9393c7ff, 0x99909fc7,
    0xffffc499, 0xffffffff, 0xffe7e7e7, 0xffffffff,
    0xffffffff, 0xf3ffffff, 0xcfcfe7e7, 0xe7cfcfcf,
    0xfffff3e7, 0xe7cfffff, 0xf3f3f3e7, 0xe7e7f3f3,
    0xffffffcf, 0xc9ffffff, 0xc9e380e3, 0xffffffff,
    0xffffffff, 0xe7e7ffff, 0xffe7e781, 0xffffffff,
    0xffffffff, 0xffffffff, 0xe3e3ffff, 0xffffe7f3,
    0xffffffff, 0xff81ffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffe3e3, 0xffffffff,
    0xf3f3f9f9, 0xcfcfe7e7, 0xffff9f9f, 0xe1ffffff,
    0xccc8c8cc, 0xe1ccc4c4, 0xffffffff, 0xe3f3ffff,
    0xf3f3f383, 0xfff3f3f3, 0xffffffff, 0x9999c3ff,
    0xcfe7f3f9, 0xffff819f, 0xffffffff, 0xf99999c3,
    0x9999f9e3, 0xffffffc3, 0xcfffffff, 0xc9c9c9cf,
    0xf9f98099, 0xffffffff, 0x9f81ffff, 0xf9839f9f,
    0xff87f3f9, 0xffffffff, 0xcfe7e3ff, 0x99999983,
    0xffffc399, 0xffffffff, 0xf3f3f981, 0xcfcfe7e7,
    0xffffffcf, 0xc3ffffff, 0xc3899999, 0xc3999991,
    0xffffffff, 0x99c3ffff, 0xc1999999, 0xffc7e7f3,
    0xffffffff, 0xe3ffffff, 0xffffffe3, 0xffffe3e3,
    0xffffffff, 0xe3e3ffff, 0xe3ffffff, 0xffe7f3e3,
    0xf9ffffff, 0x9fcfe7f3, 0xf9f3e7cf, 0xffffffff,
    0xffffffff, 0x81ff81ff, 0xffffffff, 0xffffffff,
    0xe7cf9fff, 0xe7f3f9f3, 0xffff9fcf, 0xffffffff,
    0xf39999c3, 0xe7ffe7e7, 0xffffffe7, 0x81ffffff,
    0x24303c3c, 0x803f3024, 0xffffffff, 0xc3e7ffff,
    0x81999999, 0xff999999, 0xffffffff, 0x999983ff,
    0x99998399, 0xffff8399, 0xffffffff, 0x9f9999c3,
    0x99999f9f, 0xffffffc3, 0x87ffffff, 0x99999993,
    0x87939999, 0xffffffff, 0x9f81ffff, 0x9f839f9f,
    0xff819f9f, 0xffffffff, 0x9f9f81ff, 0x9f9f839f,
    0xffff9f9f, 0xffffffff, 0x9f9999c3, 0x9999919f,
    0xffffffc1, 0x99ffffff, 0x81999999, 0x99999999,
    0xffffffff, 0xe7c3ffff, 0xe7e7e7e7, 0xffc3e7e7,
    0xffffffff, 0xf9f9f9ff, 0x99f9f9f9, 0xffffc399,
    0xffffffff, 0x93939999, 0x99939387, 0xffffff99,
    0x9fffffff, 0x9f9f9f9f, 0x819f9f9f, 0xffffffff,
    0x9c9cffff, 0x94949488, 0xff9c9c9c, 0xffffffff,
    0x8c9c9cff, 0x9c989084, 0xffff9c9c, 0xffffffff,
    0x999999c3, 0x99999999, 0xffffffc3, 0x83ffffff,
    0x83999999, 0x9f9f9f9f, 0xffffffff, 0x99c3ffff,
    0x99999999, 0xf3c39999, 0xfffffff9, 0x999983ff,
    0x99938399, 0xffff9999, 0xffffffff, 0xcf9f99c3,
    0x99f9f3e7, 0xffffffc3, 0x81ffffff, 0xe7e7e7e7,
    0xe7e7e7e7, 0xffffffff, 0x9999ffff, 0x99999999,
    0xffc39999, 0xffffffff, 0x999999ff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949c9c9c, 0xc9c99494,
    0xffffffc9, 0x99ffffff, 0xe7e7cb99, 0x999999d3,
    0xffffffff, 0x9999ffff, 0xe7c39999, 0xffe7e7e7,
    0xffffffff, 0xf9f981ff, 0x9fcfe7f3, 0xffff819f,
    0xffffffff, 0xcfcfcfc3, 0xcfcfcfcf, 0xc3cfcfcf,
    0x9fffffff, 0xe7cfcf9f, 0xf9f3f3e7, 0xfffffff9,
    0xf3c3ffff, 0xf3f3f3f3, 0xf3f3f3f3, 0xe7ffc3f3,
    0xffff99c3, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0x00ffffff, 0xf3e7c7ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xc1f9f9c3, 0xffc19999, 0xffffffff, 0x839f9fff,
    0x99999999, 0xffff8399, 0xffffffff, 0x99c3ffff,
    0x999f9f9f, 0xffffffc3, 0xf9ffffff, 0x9999c1f9,
    0xc1999999, 0xffffffff, 0xffffffff, 0x819999c3,
    0xffc39f9f, 0xffffffff, 0xcfcfe1ff, 0xcfcf81cf,
    0xffffcfcf, 0xffffffff, 0x99c1ffff, 0x99999999,
    0x83f9f9c1, 0x9fffffff, 0x9999839f, 0x99999999,
    0xffffffff, 0xffe7e7ff, 0xe7e7e787, 0xff81e7e7,
    0xffffffff, 0xc3fff3f3, 0xf3f3f3f3, 0xf3f3f3f3,
    0xffffff87, 0x99999f9f, 0x99938793, 0xffffff99,
    0x87ffffff, 0xe7e7e7e7, 0x81e7e7e7, 0xffffffff,
    0xffffffff, 0x94949481, 0xff9c9494, 0xffffffff,
    0x83ffffff, 0x99999999, 0xffff9999, 0xffffffff,
    0x99c3ffff, 0x99999999, 0xffffffc3, 0xffffffff,
    0x999983ff, 0x83999999, 0xff9f9f9f, 0xffffffff,
    0x999999c1, 0xf9c19999, 0xfffff9f9, 0x99ffffff,
    0x9f9f8f91, 0xffff9f9f, 0xffffffff, 0x9fc1ffff,
    0xf9f9c39f, 0xffffff83, 0xcfffffff, 0xcfcf81cf,
    0xe1cfcfcf, 0xffffffff, 0xffffffff, 0x99999999,
    0xffc19999, 0xffffffff, 0x99ffffff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949cffff, 0xc9949494,
    0xffffffc9, 0xffffffff, 0xc39999ff, 0x9999c3e7,
    0xffffffff, 0xffffffff, 0x99999999, 0xf3c39999,
    0xffff0fe7, 0x81ffffff, 0xcfe7f3f9, 0xffff819f,
    0xffffffff, 0xe7e7e7f3, 0xe7cf9fcf, 0xfff3e7e7,
    0xe7ffffff, 0xe7e7e7e7, 0xe7e7e7e7, 0xffe7e7e7,
    0xe7cfffff, 0xf9f3e7e7, 0xe7e7e7f3, 0xffffffcf,
    0x71248eff, 0xffffffff, 0xffffffff, 0xffffffff,
    0x81818181, 0x81818181, 0xffffff81
};




//----------------------------------------------------------------------------
// Name: Constructor
//
// Desc: 
//----------------------------------------------------------------------------
BitFont::BitFont( )
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}




//----------------------------------------------------------------------------
// Name: Destructor
//
// Desc: 
//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if( m_pBitFontInfo != (BitFontInfo *)rgSmallFont )
        delete m_pBitFontInfo;
}




//----------------------------------------------------------------------------
// Name: Load
//
// Desc: Intialize a BitFont from a specified filename -- DELETE THIS??
//----------------------------------------------------------------------------
bool BitFont::Load( const char* filename )
{
#ifdef NEVER
    HFILE hf = _lopen( filename, OF_READ );

    if( hf != HFILE_ERROR )
    {
        // get the file size and move back to the start
        LONG lSize = _llseek( hf, 0, FILE_END );
        _llseek( hf, 0, FILE_BEGIN );

        // need at least a BITFONT and one BITFONTINFO
        if(lSize < sizeof( BitFontInfo ) + sizeof( BitFontCharInfo ) )
            goto err;

        // malloc our BITFONT block and read it in
        m_pBitFontInfo = (BitFontInfo *)new BYTE[lSize];
        if( !m_pBitFontInfo )
            goto err;

        if(_lread( hf, m_pBitFontInfo, (UINT)lSize ) != (UINT)lSize )
            goto err;

        // if the sig doesn't match or we don't have any bitfontinfos then bail
        if( m_pBitFontInfo->dwSig != BITFONT_SIG || !m_pBitFontInfo->cBfis )
            goto err;

        _lclose( hf );
        return true;
    }

err:
    if( hf != HFILE_ERROR )
        _lclose( hf );

    delete [] m_pBitFontInfo;
    m_pBitFontInfo = NULL;
#endif
    return false;
}




//----------------------------------------------------------------------------
// Name: GetTextStringLength
// 
// Desc: Returns pixel height and width of string
//----------------------------------------------------------------------------
void BitFont::GetTextStringLength( DWORD *pdwWidth, DWORD *pdwHeight, 
                                   const char *str )
{
    if( pdwHeight )
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if( pdwWidth )
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for( const char *sz = str; *sz; sz++ )
        {
            DWORD iBfi = *sz - 32;

            if( iBfi >= m_pBitFontInfo->cBfis )
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}




//----------------------------------------------------------------------------
// Name: DrawText16
//
// Desc: Renders the font to a 16-bit surface
//----------------------------------------------------------------------------
void DrawText16( D3DSURFACE_DESC* pDesc, D3DLOCKED_RECT* pLock,
                 BitFontInfo* m_pBitFontInfo, const char* str, int iX, int iY,
                 DWORD dwFlags, DWORD dwcolFore,DWORD dwcolBack )
{
    bool fdrawBkgnd = !( dwFlags & DRAWTEXT_TRANSPARENTBKGND );

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD( dwcolBack ), LOWORD( dwcolFore ) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];

    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)( (BYTE *)pLock->pBits + pLock->Pitch * 
                                    pDesc->Height );

    // go through the string
    for( const char *sz = str; *sz; sz++ )
    {
        DWORD iBfi = *sz - 32;

        if( iBfi >= m_pBitFontInfo->cBfis )
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)( (BYTE *)pLock->pBits + pLock->Pitch * iY )
                                             + iX;

        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                                * iY ) + pDesc->Width;

        // go through bitfont drawing each line
        for( DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++ )
        {
            DWORD dwWidth = pbfi->bWidth;

            while( dwWidth )
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min( dwWidth, 8 );

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while( dwNumBits-- && ( pwSurface < pwSurfaceMaxX ) )
                {
                    DWORD iIndex = !( dwByte & 0x80 );

                    if( fdrawBkgnd || iIndex )
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)( (BYTE *)( pwSurface - pbfi->bWidth - dwWidth ) 
                                            + pLock->Pitch );
            pwSurfaceMaxX = (WORD *)( (BYTE *)pwSurfaceMaxX + pLock->Pitch );

            // check clipping
            if( pwSurface >= pwSurfaceMaxY )
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}




//----------------------------------------------------------------------------
// Name: DrawText32
//
// Desc: Renders the font to a 32-bit surface
//----------------------------------------------------------------------------
void DrawText32( D3DSURFACE_DESC* pDesc, D3DLOCKED_RECT* pLock,
                 BitFontInfo* m_pBitFontInfo, const char* str, int iX, int iY,
                 DWORD dwFlags, DWORD dwcolFore, DWORD dwcolBack)
{
    bool fdrawBkgnd = !( dwFlags & DRAWTEXT_TRANSPARENTBKGND );
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                                * pDesc->Height );

    for( const char *sz = str; *sz; sz++ )
    {
        DWORD iBfi = *sz - 32;

        if( iBfi >= m_pBitFontInfo->cBfis )
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)( (BYTE *)pLock->pBits + pLock->Pitch * iY )
                                                 + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                             * iY ) + pDesc->Width;

        for( DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++ )
        {
            DWORD dwWidth = pbfi->bWidth;

            while( dwWidth )
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min( dwWidth, 8 );

                dwWidth -= dwNumBits;

                while( dwNumBits-- && ( pdwSurface < pdwSurfaceMaxX ) )
                {
                    DWORD iIndex = !( dwByte & 0x80 );

                    if( fdrawBkgnd || iIndex )
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)( (BYTE *)(pdwSurface - pbfi->bWidth - dwWidth ) 
                                            + pLock->Pitch );
            pdwSurfaceMaxX = (DWORD *)( (BYTE *)pdwSurfaceMaxX + pLock->Pitch );
            if( pdwSurface >= pdwSurfaceMaxY )
                break;
        }

        iX += pbfi->bWidth;
    }
}




//----------------------------------------------------------------------------
// Name: DrawText
// 
// Desc: Draw the specified text to a surface
//----------------------------------------------------------------------------
void BitFont::DrawText( IDirect3DSurface8 *pSurface, const char* str, int iX,
                        int iY, DWORD dwFlags, D3DCOLOR colFore, 
                        D3DCOLOR colBack )
{
    typedef void ( *PFNDRAWTEXT )( D3DSURFACE_DESC* pDesc, D3DLOCKED_RECT* pLock,
                                   BitFontInfo* m_pBitFontInfo, const char* str,
                                   int iX, int iY, DWORD dwFlags, DWORD dwcolFore,
                                   DWORD dwcolBack);

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if( pSurface->LockRect( &lockRect, NULL, D3DLOCK_TILED ) != S_OK )
    {
        _asm int 3;
        return;
    }

    D3DSURFACE_DESC desc;
    if( FAILED( pSurface->GetDesc( &desc ) ) )
    {
        _asm int 3;
        return;
    }

    UINT BitsPerPixel = BitsPerPixelOfD3DFORMAT( desc.Format );

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32]( &desc, &lockRect,m_pBitFontInfo, str, iX,
                                       iY, dwFlags, 
                                       dwColorFromD3DXColor( desc.Format, colFore ),
                                       dwColorFromD3DXColor( desc.Format, colBack ) );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}




//----------------------------------------------------------------------------
// Name: dwColorFromD3DXColor
//
// Desc: Given a surfaceformat and color, return the color as a native pixel
DWORD dwColorFromD3DXColor( D3DFORMAT dwSurfaceFormat, D3DCOLOR color )
{
    DWORD dwColor;
    D3DXCOLOR col( color );

    switch( dwSurfaceFormat )
    {
        // 32-bit
        case D3DFMT_A8R8G8B8:
        case D3DFMT_LIN_A8R8G8B8:
            dwColor = ( ( (long)( col.a * 255 ) ) << 24 ) |
                      ( ( (long)( col.r * 255 ) ) << 16 ) |
                      ( ( (long)( col.g * 255) ) << 8 ) |
                      (long)( col.b * 255 );
        break;

        // 32-bit
        case D3DFMT_X8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
            dwColor = 0xff000000L |
                      ( ( (long)( col.r * 255 ) ) << 16 ) |
                      ( ( (long)( col.g * 255 ) ) << 8 ) |
                      (long)( col.b * 255 );
        break;

        // 16-bit
        case D3DFMT_R5G6B5:
        case D3DFMT_LIN_R5G6B5:
            dwColor = ( ( (long)( col.r * 255 ) ) << 11 ) |
                      ( ( (long)( col.g * 255 ) ) << 5 ) |
                      (long)( col.b * 255 );
        break;

        case D3DFMT_X1R5G5B5:
        case D3DFMT_LIN_X1R5G5B5:
            dwColor = ( 1 << 15 ) |
                      ( ( (long)( col.r * 255 ) ) << 10 ) |
                      ( ( (long)( col.g * 255) ) << 5 ) |
                      (long)( col.b * 255 );
        break;

        case D3DFMT_A4R4G4B4:
        case D3DFMT_LIN_R4G4B4A4:
            dwColor = ( ( (long)( col.a * 15 ) ) << 12 ) |
                      ( ( (long)( col.r * 15 ) ) << 8 ) |
                      ( ( (long)( col.g * 15 ) ) << 4 ) |
                      (long)( col.b * 15 );
        break;

        case D3DFMT_A1R5G5B5:
        case D3DFMT_LIN_A1R5G5B5:
            dwColor = ( ( (long)( col.a > .9f ) ) << 15 ) |
                      ( ( (long)( col.r * 31 ) ) << 10 ) |
                      ( ( (long)( col.g * 31 ) ) << 5 ) |
                      (long)( col.b * 31 );
        break;

        default:
            dwColor = 0;
            _asm int 3;
        break;
    }

    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\fillrate.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: Tool to help demonstrate different fillrates of the Xbox GPU
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <assert.h>
#include <d3d8perf.h>

#include "utils.h"
#include "inifile.h"
#include "fillrate.h"




//-----------------------------------------------------------------------------
// Define for whether we use the VisibilityTest apis. Note that
// BeginVisibilityTest() will turn off some blend optimizations and
// it doesn't count pixels which aren't drawn due to alpha test or
// the like so we don't use it by default.
#define NO_VIS_TEST




//-----------------------------------------------------------------------------
// Globals
IDirect3DDevice8       *g_pDev = NULL;                  // our device
IDirect3DVertexBuffer8 *g_pVB = NULL;                   // our vertex buffer
IDirect3DBaseTexture8  *g_pTexture[4] = { NULL };       // 4 textures
IDirect3DSurface8      *g_pBackBuffer = NULL;

DWORD                   g_ShaderHandle = 0;             // pixel shader handle

DWORD                   g_dwFVFSize;                    // FVF size

UINT                    g_cindices = 0;                 // count of indices
WORD*                   g_pindices = NULL;              // indices allocation

HANDLE                  g_hInpDevice = NULL;            // input device

CScrText                g_scrtext;                      // text helper
CIniFile                g_inifile("d:\\fillrate.ini");  // Ini file

bool                    g_fRedrawScreen = true;         // refresh screen?
bool                    g_fdumpZ = false;               // dump Z val

FRSETTINGS              g_var = {0};                    // current settings

bool                    g_noINIFile = true;             //Do we have an INI file to test?


//-----------------------------------------------------------------------------
// Suite of available tests. Selectable via g_iCurTest in ini file
//  or by using left/right gamepad trigger.
//-----------------------------------------------------------------------------
struct
{
    LPCSTR szDesc;
    void (*pfnTest)();
} g_rgTests[] =
{
    { "Current",        DoQuickTimedTest },
    { "MultiSample",    DoMultiSampleTimedTest },
    { "FillRate",       DoCompleteTimedTest },
    { "Texture",   DoTextureTest },
};

UINT g_iCurTest = 0;




//-----------------------------------------------------------------------------
// Name: InitD3D
//
// Desc: Starts D3D
//-----------------------------------------------------------------------------
bool InitD3D()
{
    static D3DPRESENT_PARAMETERS d3dppCur = {0};
    D3DPRESENT_PARAMETERS d3dpp = {0};

    // Set the screen mode.
    d3dpp.BackBufferWidth                   = g_var.screenwidth;
    d3dpp.BackBufferHeight                  = g_var.screenheight;
    d3dpp.BackBufferFormat                  = g_var.BackBufferFormat;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.EnableAutoDepthStencil            = !!g_var.AutoDepthStencilFormat;
    d3dpp.AutoDepthStencilFormat            = g_var.AutoDepthStencilFormat;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz        = 60;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.Flags                             = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

    if( g_var.MSType != D3DMULTISAMPLE_NONE )
        d3dpp.MultiSampleType = (D3DMULTISAMPLE_TYPE)((DWORD)(g_var.MSType) | 
                                                      (DWORD)(g_var.MSFormat));

    // if nothing has changed - don't reinit
    if( !memcmp( &d3dppCur, &d3dpp, sizeof( D3DPRESENT_PARAMETERS ) ) )
        return true;

    d3dppCur = d3dpp;

    if( g_pDev )
    {
        if( g_ShaderHandle )
        {
            CheckHR( g_pDev->SetPixelShader(0) );
            CheckHR( g_pDev->DeletePixelShader(g_ShaderHandle) );
            g_ShaderHandle = 0;
        }

        // make sure everything is freed
        RELEASE( g_pVB );
        for( int itex = 0; itex < 4; itex++ )
            RELEASE( g_pTexture[itex] );

        RELEASE( g_pBackBuffer );
        RELEASE( g_pDev );
    }

    // Create the device.
    if FAILED(Direct3D_CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
        NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDev) )
    {
        CheckHR( E_FAIL );
        return false;
    }

    D3DDevice_GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &g_pBackBuffer );
    return true;
}




//-----------------------------------------------------------------------------
// Name: FillTextureBits3D
//
// Desc: Fill a volume texture with stuff
//-----------------------------------------------------------------------------
void FillTextureBits3D( D3DLOCKED_BOX *plockVol, D3DFORMAT d3dFormat, 
                        DWORD dwHeight, DWORD dwWidth, DWORD dwDepth ) 
{
    DWORD dwBits = BitsPerPixelOfD3DFORMAT( d3dFormat );

    assert( !IsLinearFormat( d3dFormat ) );

    BYTE *pBits = (BYTE *)plockVol->pBits;
    for( DWORD d = 0; d < dwDepth; d++ )
    {
        for( DWORD y = 0; y < dwHeight; y++ )
        {
            for( DWORD x = 0; x < dwWidth; x++ )
            {
                DWORD c = ( ~y & 1 ) * ( y + 1 ) * 0xff / dwHeight;
                DWORD c2 = d * 0xff / ( dwDepth - 1 );

                switch( dwBits )
                {
                case 4:
                    x++;
                case 8:
                    *pBits++ = LOBYTE( c );
                    break;
                case 16:
                    *(WORD *)pBits = MAKEWORD( c2, c );
                    pBits += 2;
                    break;
                case 32:
                    *(DWORD *)pBits = D3DCOLOR_ARGB( 0x0, c, c, c );
                    pBits += 4;
                    break;
                default:
                    CheckHR( E_FAIL );
                    break;
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FillTextureBits
//
// Desc: Fill a 2D cubemap face or texture with stuff
//-----------------------------------------------------------------------------
void FillTextureBits( D3DLOCKED_RECT *plockRect, D3DFORMAT d3dFormat, 
                     DWORD dwHeight, DWORD dwWidth )
{
    bool fIsLinear = IsLinearFormat( d3dFormat );
    DWORD dwBits = BitsPerPixelOfD3DFORMAT( d3dFormat );
    DWORD dwLine = (DWORD)plockRect->pBits;

    for ( DWORD y = 0; y < dwHeight; y++ )
    {
        DWORD dwAddr = dwLine;
        DWORD c = (~y & 1 ) * ( y + 1 ) * 0xff / dwHeight;

        for ( DWORD x = 0; x < dwWidth; x++ )
        {
            switch( dwBits )
            {
            case 4:
                *(BYTE *)dwAddr = LOBYTE( c );
                dwAddr += 1;
                x++;
                break;
            case 8:
                *(BYTE *)dwAddr = LOBYTE( c );
                dwAddr += 1;
                break;
            case 16:
                *(WORD *)dwAddr = MAKEWORD( c, c );
                dwAddr += 2;
                break;
            case 32:
                *(DWORD *)dwAddr = D3DCOLOR_ARGB( 0x0, c, c, c );
                dwAddr += 4;
                break;
            }
        }

        // pitch is only valid for linear textures
        if( fIsLinear )
            dwLine += plockRect->Pitch;
        else
            dwLine += dwWidth * dwBits / 8;
    }
}




//-----------------------------------------------------------------------------
// Name: MyCreateTexture
//
// Desc: Create a texture
//-----------------------------------------------------------------------------
IDirect3DBaseTexture8 *MyCreateTexture( D3DRESOURCETYPE d3dtype, 
                                       D3DFORMAT d3dFormat, DWORD dwWidth, 
                                       DWORD dwHeight, DWORD Levels )
{
    IDirect3DBaseTexture8 *pTexRet = NULL;

    if( d3dtype == D3DRTYPE_TEXTURE )
    {
        D3DLOCKED_RECT lockRect;
        IDirect3DTexture8 *pTexture = NULL;

        CheckHR( g_pDev->CreateTexture(dwWidth, dwHeight, Levels, 0, d3dFormat,
            D3DPOOL_MANAGED, &pTexture ) );

        for( DWORD ilevel = 0; ilevel < pTexture->GetLevelCount(); ilevel++ )
        {
            CheckHR( pTexture->LockRect( ilevel, &lockRect, NULL, 0 ) );
            FillTextureBits( &lockRect, d3dFormat, dwHeight, dwWidth );
            CheckHR( pTexture->UnlockRect( ilevel ) );
        }

        pTexRet = pTexture;
    }
    else if( d3dtype == D3DRTYPE_CUBETEXTURE )
    {
        D3DLOCKED_RECT lockRect;
        IDirect3DCubeTexture8 *pCubeTexture = NULL;

        CheckHR( g_pDev->CreateCubeTexture( dwWidth, Levels, 0, d3dFormat,
            D3DPOOL_MANAGED, &pCubeTexture ) );

        for( DWORD ilevel = 0; ilevel < pCubeTexture->GetLevelCount(); ilevel++ )
        {
            for( int iFace = 0; iFace < D3DCUBEMAP_FACE_NEGATIVE_Z; iFace++ )
            {
                D3DCUBEMAP_FACES cmFace = (D3DCUBEMAP_FACES)iFace;

                CheckHR( pCubeTexture->LockRect( cmFace, ilevel, 
                                                 &lockRect, NULL, 0 ) );
                FillTextureBits( &lockRect, d3dFormat, dwHeight, dwWidth );
                CheckHR( pCubeTexture->UnlockRect( cmFace, ilevel ) );
            }
        }

        pTexRet = pCubeTexture;
    }
    else
    {
        assert( d3dtype == D3DRTYPE_VOLUMETEXTURE );

        D3DLOCKED_BOX lockVol;
        IDirect3DVolumeTexture8 *pVolumeTexture = NULL;

        CheckHR( g_pDev->CreateVolumeTexture( dwWidth, dwHeight, 
                                              dwHeight, Levels, 0,
                                              d3dFormat, D3DPOOL_MANAGED, 
                                              &pVolumeTexture ) );

        for( DWORD ilevel = 0; ilevel < pVolumeTexture->GetLevelCount(); ilevel++ )
        {
            CheckHR( pVolumeTexture->LockBox( ilevel, &lockVol, NULL, 0 ) );
            FillTextureBits3D( &lockVol, d3dFormat, dwHeight, dwWidth, dwWidth );
            CheckHR( pVolumeTexture->UnlockBox( ilevel ) );
        }

        pTexRet = pVolumeTexture;
    }

   return pTexRet;
}




//-----------------------------------------------------------------------------
// Name: CreateQuadList
//
// Desc: Create a quadlist vb with X quads and decreasing z values
//-----------------------------------------------------------------------------
void CreateQuadList( int nquads )
{
    RELEASE( g_pVB );

    if( g_cindices ) 
    {
        delete [] g_pindices;
        g_cindices = 0;
    }

    g_dwFVFSize = D3DXGetFVFVertexSize( g_var.FVF );

    if( g_var.verboselevel >= 2 )
        dprintf( "FVF:0x%08lx, FVFSize: %d\n", g_var.FVF, g_dwFVFSize );

    UINT VBLength = g_dwFVFSize * 4 * nquads;

    CheckHR( g_pDev->CreateVertexBuffer( VBLength,
        D3DUSAGE_WRITEONLY, g_var.FVF, D3DPOOL_MANAGED, &g_pVB ) );

    float *pVerts;
    CheckHR( g_pVB->Lock( 0, g_dwFVFSize, (BYTE **)&pVerts, 0 ) );

    float texscale = g_var.rgtex[0].type && 
                     IsLinearFormat( g_var.rgtex[0].d3dFormat ) ? 
                     g_var.rgtex[0].texsize : 1.0f;

    float dz = 1.0f / ( nquads * 2 );
    float zval = 1.0f - dz;
    for( int iquad = 0; iquad < nquads; iquad++, zval -= dz )
    {
        for( int y = 0; y <= 1; y++ )
        {
            for( int x = 0; x <= 1; x++ )
            {
                D3DXVECTOR4 pos;
                D3DXVECTOR4 tex0;

                // position
                pos.x = g_var.quadx + x * g_var.quadwidth;
                pos.y = g_var.quady + y * g_var.quadheight;
                pos.z = g_var.tiltz ? y : zval;
                pos.w = 1.0f;

                // texture coordinates
                if( g_var.rotatetex )
                {
                    tex0.x = ( 1.0f - y ) * texscale;
                    tex0.y = x * texscale;
                }
                else
                {
                    tex0.x = x * texscale;
                    tex0.y = y * texscale;
                }
                tex0.z = ( 1.0f - x ) * texscale;
                tex0.w = 1.0f;

                // diffuse color
                DWORD diffuse = D3DCOLOR_COLORVALUE( tex0.x,
                    tex0.y, 1.0f - tex0.x, 2.0f / 0xff );

                if( g_var.FVF & D3DFVF_XYZRHW )
                {
                    *(D3DXVECTOR4 *)pVerts = pos;
                    pVerts += 4;
                }
                else if( g_var.FVF & D3DFVF_XYZ )
                {
                    *(D3DXVECTOR3 *)pVerts = *(D3DXVECTOR3 *)&pos;
                    pVerts += 3;
                }

                if( g_var.FVF & D3DFVF_NORMAL )
                {
                    *(D3DXVECTOR3 *)pVerts = D3DXVECTOR3( 0, .707f, .707f );
                    pVerts += 3;
                }

                if( g_var.FVF & D3DFVF_DIFFUSE )
                    *(DWORD *)pVerts++ = diffuse;

                if( g_var.FVF & D3DFVF_SPECULAR )
                    *(DWORD *)pVerts++ = ~diffuse;

                // Texture coordinates
                UINT uNumTexCoords = ( ( ( g_var.FVF ) & D3DFVF_TEXCOUNT_MASK ) 
                                       >> D3DFVF_TEXCOUNT_SHIFT );
                UINT uTextureFormats = g_var.FVF >> 16;

                if( uTextureFormats )
                {
                    for( UINT i = 0; i < uNumTexCoords; i++ )
                    {
                        switch( uTextureFormats & 3 )
                        {
                        case D3DFVF_TEXTUREFORMAT1:     // u
                            *pVerts++ = tex0.x;
                            break;
                        case D3DFVF_TEXTUREFORMAT2:     // u,v
                            *(D3DXVECTOR2 *)pVerts = *(D3DXVECTOR2 *)&tex0;
                            pVerts += 2;
                            break;
                        case D3DFVF_TEXTUREFORMAT3:     // s,t,r
                            *(D3DXVECTOR3 *)pVerts = *(D3DXVECTOR3 *)&tex0;
                            pVerts += 3;
                            break;
                        case D3DFVF_TEXTUREFORMAT4:     // s,t,r,q
                            *(D3DXVECTOR4 *)pVerts = tex0;
                            pVerts += 4;
                            break;
                        }

                        uTextureFormats >>= 2;
                    }
                }
                else while( uNumTexCoords-- )
                {
                    // u,v
                    *(D3DXVECTOR2 *)pVerts = *(D3DXVECTOR2 *)&tex0;
                    pVerts += 2;
                }
            }
        }
    }

    CheckHR( g_pVB->Unlock( ) );
    g_pVB->MoveResourceMemory( D3DMEM_VIDEO );

    // create out index buffer
    g_cindices = nquads * 4;
    g_pindices = new WORD [g_cindices];

    WORD *pindices = g_pindices;

    for( iquad = 0; iquad < nquads; iquad++ )
    {
        *pindices++ = iquad * 4 + 0;
        *pindices++ = iquad * 4 + 1;
        *pindices++ = iquad * 4 + 3;
        *pindices++ = iquad * 4 + 2;
    }
}




//-----------------------------------------------------------------------------
// Name: InitFR
//
// Desc: Initialize fillrate app
//-----------------------------------------------------------------------------
bool InitFR( bool freadINIFile )
{
    if( freadINIFile && !ReadFRIniFile( ) )
        dprintf( "%s not found.\n", g_inifile.GetFileName( ) );

    // init d3d
    if( !InitD3D( ) )
    {
        dprintf( "InitD3D failed.\n" );
        return false;
    }

    CheckHR( g_pDev->SetRenderState( D3DRS_SPECULARENABLE, g_var.specularenable ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_SWATHWIDTH, g_var.SwathWidth ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_FILLMODE, g_var.d3dfillmode ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_COLORWRITEENABLE, g_var.colorwriteenable ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_ZENABLE, g_var.zenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ZWRITEENABLE, g_var.zwriteenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ZFUNC, g_var.d3dcmpfunc ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHABLENDENABLE, g_var.alphablendenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_BLENDOP, D3DBLENDOP_ADD ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHATESTENABLE, g_var.alphatestenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHAREF, 0x00000001 ) );

    if( g_var.userpixelshader )
        CheckHR( g_pDev->CreatePixelShader( &g_var.shaderdef, &g_ShaderHandle ) );

    for( int itex = 0; itex < 4; itex++ )
    {
        RELEASE( g_pTexture[itex] );

        if( g_var.rgtex[itex].type )
        {
            assert( g_var.rgtex[itex].type < TEX_Max );
            g_var.rgtex[itex].type = min( g_var.rgtex[itex].type, TEX_Max - 1 );

            static const D3DRESOURCETYPE rgrestype[] =
                { D3DRTYPE_TEXTURE, D3DRTYPE_CUBETEXTURE, D3DRTYPE_VOLUMETEXTURE };
            assert( TEX_2d == 1 && TEX_Cubemap == 2 && TEX_Volume == 3 );

            g_pTexture[itex] = MyCreateTexture(
                rgrestype[g_var.rgtex[itex].type - 1],
                g_var.rgtex[itex].d3dFormat,
                g_var.rgtex[itex].texsize,
                g_var.rgtex[itex].texsize,
                (g_var.rgtex[itex].mipfilter != D3DTEXF_NONE) ? 0 : 1 );

            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MINFILTER, 
                                                   g_var.rgtex[itex].filtertype ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MAGFILTER, 
                                                   g_var.rgtex[itex].filtertype ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MIPFILTER, 
                                                   g_var.rgtex[itex].mipfilter ) );

            // Set the texture stage states appropriately
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_COLORARG1, 
                                                   D3DTA_TEXTURE ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_COLOROP, 
                                                   g_var.ColorOp ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_COLORARG2, 
                                                   D3DTA_DIFFUSE ) );

            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ALPHAARG1, 
                                                   D3DTA_TEXTURE ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ALPHAOP, 
                                                   g_var.AlphaOp ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ALPHAARG2, 
                                                   D3DTA_DIFFUSE ) );
        }
        else
        {
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_COLOROP, 
                                                   D3DTOP_DISABLE ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ALPHAOP, 
                                                   D3DTOP_DISABLE ) );

            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MINFILTER, 
                                                   D3DTEXF_LINEAR ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MAGFILTER, 
                                                   D3DTEXF_LINEAR ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MIPFILTER, 
                                                   D3DTEXF_NONE ) );
        }

        CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ADDRESSU, 
                                               D3DTADDRESS_CLAMP ) );
        CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ADDRESSV, 
                                               D3DTADDRESS_CLAMP ) );
    }

    CreateQuadList( g_var.overdraw );
    return true;
}




//-----------------------------------------------------------------------------
// Name: DumpZ
//
// Desc: Dump the first entry in the z buffer
//-----------------------------------------------------------------------------
void DumpZ( )
{
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    IDirect3DSurface8 *pZBuffer = NULL;

    if( !g_var.AutoDepthStencilFormat )
        return;

    CheckHR( g_pDev->GetDepthStencilSurface( &pZBuffer ) );

    CheckHR( pZBuffer->LockRect( &lockRect, NULL, D3DLOCK_READONLY ) );
    CheckHR( pZBuffer->GetDesc( &desc ) );

    DWORD dwVal;
    switch( desc.Format )
    {
    case D3DFMT_LIN_D16:
    case D3DFMT_D16:
        // v = z[15:0]  0.0 to 65535.0
        dprintf("D3DFMT_D16: 0x%08lx", *(WORD *)lockRect.pBits);
        break;

    case D3DFMT_LIN_D24S8:
    case D3DFMT_D24S8:
        // v = z[24:0] 0.0 to 16,777,215.0  (0 to FFFFFF)
        dwVal = ( *(DWORD *)lockRect.pBits );
        dprintf("D3DFMT_D24S8: 0x%08lx:%02lx %.2f", dwVal >> 8, LOBYTE( dwVal ),
               ( dwVal >> 8 ) / 16777215.0f );
        break;

    case D3DFMT_LIN_F16:
    case D3DFMT_F16:
        // e4m12
        // e = z[15:12]
        // m = z[11:0]
        // value = 2^(e-7) * (1 + m/4096)
        // value = 0.0 when e == 0 and m == 0
        dprintf( "D3DFMT_F16: 0x%08lx", *(WORD *)lockRect.pBits );
        break;

    case D3DFMT_LIN_F24S8:
    case D3DFMT_F24S8:
        // e8m16
        // e = z[23:16]
        // m = z[15:0]
        // value = 2^(e-127) * (1 + m/65536)
        // value = 0.0 when e == 0 and m == 0
        dprintf( "D3DFMT_F24S8: 0x%08lx", *(DWORD *)lockRect.pBits );
        break;
    }

    pZBuffer->UnlockRect();

    RELEASE( pZBuffer );
}




//-----------------------------------------------------------------------------
// Name: RenderFrame
//
// Desc: render the quads X # of times
//-----------------------------------------------------------------------------
void RenderFrame( int overdraw )
{
    UINT coverdrawverts = overdraw * 4;

    // clear stuff
    DWORD dwCFlags = g_var.clearflags;
    if( !g_var.AutoDepthStencilFormat )
        dwCFlags &= ~( D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL );

    CheckHR( g_pDev->Clear( 0, NULL, dwCFlags, g_var.cclearval,
        g_var.zclearval, g_var.sclearval ) );

    // begin scene
    CheckHR( g_pDev->BeginScene() );

    // set textures
    for( int itex = 0; itex < 4; itex++ )
        CheckHR( g_pDev->SetTexture( itex, g_pTexture[itex] ) );

    CheckHR( g_pDev->SetVertexShader( g_var.FVF ) );
    CheckHR( g_pDev->SetStreamSource( 0, g_pVB, g_dwFVFSize ) );

    CheckHR( g_pDev->SetPixelShader( g_ShaderHandle ) );

    if( g_var.zenable && g_var.primez )
    {
        // prime the z buffer to 0.5f
        CheckHR( g_pDev->SetRenderState( D3DRS_ZFUNC, g_var.primezcmpfunc ) );
        CheckHR( g_pDev->SetRenderState( D3DRS_ZWRITEENABLE, TRUE ) );

        // draw one quad (not the first one) to prime the z buffer
        CheckHR( g_pDev->DrawIndexedVertices( D3DPT_QUADLIST, 4, g_pindices + 4 ) );
        coverdrawverts -= 4;

        CheckHR( g_pDev->SetRenderState( D3DRS_ZFUNC, g_var.d3dcmpfunc ) );
        CheckHR( g_pDev->SetRenderState( D3DRS_ZWRITEENABLE, g_var.zwriteenable ) );
    }

    while( coverdrawverts )
    {
        UINT VertexCount = min( g_cindices, coverdrawverts );
        CheckHR( g_pDev->DrawIndexedVertices( D3DPT_QUADLIST, VertexCount, g_pindices ) );

        coverdrawverts -= VertexCount;
    }

    if( g_fdumpZ )
        DumpZ();

    CheckHR( g_pDev->EndScene() );
}




//-----------------------------------------------------------------------------
// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.24f

//-----------------------------------------------------------------------------
// Global instance of input states
XINPUT_STATE g_InputStates[4];




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};

//-----------------------------------------------------------------------------
// Global instance of custom gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_InputStates[i], sizeof(XINPUT_STATE) );
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( )
{
    XBGAMEPAD *pGamepads = g_Gamepads;

    // TCR 3-21 Controller Discovery
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
            pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( pGamepads[i].hDevice, &pGamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XInputGetState( pGamepads[i].hDevice, &g_InputStates[i] );

            // Copy gamepad to local structure
            memcpy( &pGamepads[i], &g_InputStates[i].Gamepad, sizeof(XINPUT_GAMEPAD) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            pGamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            pGamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            pGamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            pGamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] > XINPUT_GAMEPAD_MAX_CROSSTALK );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FButtonDown
//
// Desc: Check if button is pressed.
//-----------------------------------------------------------------------------
bool FButtonDown( DWORD button )
{
    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // If we have a valid device, poll it's state and track button changes
        if( g_Gamepads[i].hDevice && g_Gamepads[i].bPressedAnalogButtons[button] )
            return true;
    }

    return false;
}




//-----------------------------------------------------------------------------
// Name: ChkButtonDown
//
// Desc: Check if non-analog button is pressed.
//-----------------------------------------------------------------------------
bool ChkButtonDown( DWORD button )
{
    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // If we have a valid device, poll it's state and track button changes
        if( g_Gamepads[i].hDevice && g_Gamepads[i].wPressedButtons & button )
            return true;
    }

    return false;
}




//-----------------------------------------------------------------------------
// Name: ChkReboot
//
// Desc: Check if they hit the magic reboot sequence
//-----------------------------------------------------------------------------
bool ChkReboot( void )
{
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // If we have a valid device, poll it's state and track button changes
        if( g_Gamepads[i].hDevice )
        {
            if( g_Gamepads[i].bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            {
                if( g_Gamepads[i].bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                {
                    if( g_Gamepads[i].bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                    {
                        return true;
                    }
                }
            }
        }
    }


    return false;
}




//-----------------------------------------------------------------------------
// Name: HandleInput
//
// Desc: Handle Gamepad input
//-----------------------------------------------------------------------------
void HandleInput( DWORD dwTicks )
{
    static BOOL fRunTestRightNow = FALSE;

    if( g_inifile.FileChanged() )
    {
        InitFR( true );

        fRunTestRightNow = g_var.runtestonreload;

        g_fRedrawScreen = true;

        g_noINIFile = false;
    }

    // If we don't have a device don't let them start any tests.
    // They're going to have to change their settings in fillrate.ini
    // and just try again.
    if( g_noINIFile )
    {
        InitD3D();
        g_scrtext.cls();
        g_scrtext.printf("\n");
        g_scrtext.printf("Please be sure INI file was copied to d: drive on Xbox.\n");
        g_scrtext.printf("No INI File or could not parse INI file.\nNothing I can do.");
        g_scrtext.printf("You can copy INI right now!  I restart when it changes!");

        return;
    }

    XBInput_GetInput();

    if( fRunTestRightNow || FButtonDown( XINPUT_GAMEPAD_A ) )
    {
        fRunTestRightNow = FALSE;

        // run current test
        g_rgTests[g_iCurTest].pfnTest();

        // draw one frame with current settings
        RenderFrame( 1 );

        // flip that dude to the front
        CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

        g_scrtext.drawtext( g_var.verboselevel >= 1 );
        g_fRedrawScreen = false;
    }

#ifdef _DEBUG
    if( FButtonDown( XINPUT_GAMEPAD_B ) )
    {
        D3DPUSHBUFFERINFO PushBufferInfo;
        D3DPERF_GetPushBufferInfo( &PushBufferInfo );

        D3DPERF_Dump();
        D3DPERF_Reset();
    }
#endif

    if( FButtonDown(XINPUT_GAMEPAD_LEFT_TRIGGER ) )
    {
        g_iCurTest = ( g_iCurTest + ARRAYSIZE( g_rgTests ) - 1 ) % 
                        ARRAYSIZE( g_rgTests );
        g_fRedrawScreen = true;
    }

    if( FButtonDown( XINPUT_GAMEPAD_RIGHT_TRIGGER ) )
    {
        g_iCurTest = ( g_iCurTest + 1 ) % ARRAYSIZE( g_rgTests );
        g_fRedrawScreen = true;
    }

    if( FButtonDown( XINPUT_GAMEPAD_Y ) )
    {
        // toggle wireframe and solid fill modes
        g_var.d3dfillmode = ( g_var.d3dfillmode == D3DFILL_WIREFRAME ) ?
            D3DFILL_SOLID : D3DFILL_WIREFRAME;

        CheckHR( g_pDev->SetRenderState( D3DRS_FILLMODE, g_var.d3dfillmode ) );
        g_fRedrawScreen = true;
    }

    if ( ChkButtonDown( XINPUT_GAMEPAD_BACK ) )
    {
        g_fRedrawScreen = true;
    }

    // Handle special input combo to trigger a reboot to the Xbox Dashboard
    if( ChkReboot() )
    {
        LD_LAUNCH_DASHBOARD LaunchData = { XLD_LAUNCH_DASHBOARD_MAIN_MENU };
        XLaunchNewImage( NULL, (LAUNCH_DATA*)&LaunchData );
    }
}




//-----------------------------------------------------------------------------
// Name: DoMultiSampleTimedTest
//
// Desc: Run through a suite of multisample/supersample tests
//-----------------------------------------------------------------------------
void DoMultiSampleTimedTest()
{
    D3DMULTISAMPLE_TYPE rgMSType[] =
    {
        D3DMS_NONE,
        D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR,
        D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX,
        D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR,
        D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN,
        D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN,
        D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR,
        D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR,
        D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR,
        D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN,
        D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN
    };

    static const int cMSTypes = ARRAYSIZE( rgMSType );

    D3DFORMAT rgBackBuf[] = { D3DFMT_R5G6B5, D3DFMT_X8R8G8B8 };
    static const cBBufs = ARRAYSIZE( rgBackBuf );

    g_scrtext.cls();
    g_scrtext.printf( "" );
    for( int iBuf = 0; iBuf < cBBufs; iBuf++ )
    {
        g_scrtext.printf( "BackBufFmt: %-38s %-8s %-8s %s",
            GetD3DFormatStr( rgBackBuf[iBuf] ), "MPix/s", "fps", "frames" );

        for( int iType = 0; iType < cMSTypes; iType++ )
        {
            TIMETESTRESULTS ttres;

            g_var.MSType = rgMSType[iType];
            g_var.BackBufferFormat = rgBackBuf[iBuf];

            InitFR( false );
            DoTimedTest( &ttres );

            g_scrtext.printf( "    %-45s %7.2f  %8.2f  %d",
                GetMultiSampleStr( rgMSType[iType] ),
                ttres.fillrate, ttres.fps, ttres.cFrames );
        }

        //Display current results.
        // Hang out here until they press "a" to continue.
        if( (iBuf+1) < cBBufs )
        {
            g_scrtext.printf( "" );
            g_scrtext.printf( "Button (A)-Continue test.", 
                                g_rgTests[g_iCurTest].szDesc );

            // clear back buffer
            RenderFrame( 1 );

            // swap that guy to the front
            CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

            // clear new back buffer
            RenderFrame( 1 );

            //DumpCurrentSettings();
            g_scrtext.drawtext( g_var.verboselevel >= 1 );

            g_scrtext.cls();

            g_scrtext.printf( "" );

            XBInput_GetInput();
    
            while( !FButtonDown( XINPUT_GAMEPAD_A ) )
                XBInput_GetInput();
        }
    }

    g_scrtext.printf( "" );
    g_scrtext.printf( "Button (A)-Run '%s' test.  Button (BACK)-Return to Main Screen.", 
                      g_rgTests[g_iCurTest].szDesc );

    // restore settings from ini file
    InitFR( true );
}




//-----------------------------------------------------------------------------
// Name: DoQuickTimedTest
//
// Desc: Do a quick test with the current settings
//-----------------------------------------------------------------------------
void DoQuickTimedTest()
{
    TIMETESTRESULTS ttres;

    DoTimedTest( &ttres );

    g_scrtext.cls();
    DumpCurrentSettings();

    g_scrtext.printf( " " );
    g_scrtext.printf( "fillrate: %.2fMP/s",  ttres.fillrate );
    g_scrtext.printf( "fps:      %.2f",      ttres.fps );
    g_scrtext.printf( "frames:   %d",        ttres.cFrames );
    g_scrtext.printf( "time:     %.2fms",    ttres.TimeTillIdle );
    g_scrtext.printf( "pixels:   %I64u",     ttres.cNumPixelsDrawn );
    g_scrtext.printf( " " );

    g_scrtext.printf( "" );
    g_scrtext.printf( "Button (A)-Run '%s' test.  Button (BACK)-Return to Main Screen.", 
                      g_rgTests[g_iCurTest].szDesc );

}




//-----------------------------------------------------------------------------
// Name: DoTextureTest
//
// Desc: Texture fillrate test
//-----------------------------------------------------------------------------
void DoTextureTest()
{
    D3DFORMAT rgFormats[] =
    {
        D3DFMT_A4R4G4B4,
        D3DFMT_A8R8G8B8,
        D3DFMT_DXT1,
        D3DFMT_DXT2,
        D3DFMT_P8,
        D3DFMT_LIN_A8R8G8B8
    };

    int rgTexSize[] = { 1, 16, 256 };
    float rgResults[ARRAYSIZE( rgTexSize )];

    g_scrtext.cls();

    g_scrtext.printf( "" );
    g_scrtext.printf( "%-20s %-10s %-10s %-10s",
        "texturefmt", "1x1", "16x16", "256x256" );

    for( int id3dformat = 0; id3dformat < ARRAYSIZE( rgFormats ); id3dformat++ )
    {
        char szBuf[128];

        szBuf[0] = 0;
        for( int itexsize = 0; itexsize < ARRAYSIZE( rgTexSize ); itexsize++ )
        {
            g_var.rgtex[0].type = TEX_2d;
            g_var.rgtex[0].texsize = rgTexSize[itexsize];
            g_var.rgtex[0].d3dFormat = rgFormats[id3dformat];

            InitFR( false );
            rgResults[itexsize] = DoTimedTest();
        }

        g_scrtext.printf(
            "%-20s %-10.2f %-10.2f %-10.2f",
            GetD3DFormatStr( g_var.rgtex[0].d3dFormat ),
            rgResults[0], rgResults[1], rgResults[2] );
    }

    g_scrtext.printf( "" );
    g_scrtext.printf( "Button (A)-Run '%s' test.  Button (BACK)-Return to Main Screen.", 
                      g_rgTests[g_iCurTest].szDesc );

    // restore settings from ini file
    InitFR( true );
}




//-----------------------------------------------------------------------------
// Name: DoCompleteTimedTest
//
// Desc: Run through a suite of fillrate tests
//-----------------------------------------------------------------------------
void DoCompleteTimedTest()
{
    D3DFORMAT rgFormats[] = { D3DFMT_DXT1, D3DFMT_A8R8G8B8, D3DFMT_A4R4G4B4 };

    g_scrtext.cls();

    g_scrtext.printf( "" );

    g_scrtext.printf(
        "zwrite zread texturefmt      texturesize fillrate  (alphablendenable:%d)",
        g_var.alphablendenable );

    for( int id3dformat = 0; id3dformat < ARRAYSIZE( rgFormats ); id3dformat++ )
    {
        for( int texsize = 0; texsize <= 512; texsize += 256 )
        {
            for( int zenable = 0; zenable < 2; zenable++ )
            {
                for( int zwriteenable = 0; zwriteenable < 2; zwriteenable++ )
                {
                    g_var.zenable = !!zenable;
                    g_var.zwriteenable = !!zwriteenable;

                    g_var.d3dcmpfunc = D3DCMP_NOTEQUAL;

                    g_var.rgtex[0].texsize = texsize;
                    g_var.rgtex[0].type = !!texsize;
                    g_var.rgtex[0].d3dFormat = rgFormats[id3dformat];

                    if( !g_var.zenable && zwriteenable )
                        continue;

                    if( !g_var.rgtex[0].type && id3dformat )
                        continue;

                    InitFR( false );
                    float fResult = DoTimedTest();

                    g_scrtext.printf(
                        "%-6d %-5d %-15s %-11d %.2f",
                        g_var.zwriteenable,
                        g_var.zenable,
                        texsize ? GetD3DFormatStr(g_var.rgtex[0].d3dFormat) : "",
                        texsize,
                        fResult );
                }
            }
        }
    }

    g_scrtext.printf( "" );
    g_scrtext.printf( "Button (A)-Run '%s' test.  Button (BACK)-Return to Main Screen.", 
                      g_rgTests[g_iCurTest].szDesc );

    // restore settings from ini file
    InitFR( true );
}




//-----------------------------------------------------------------------------
// Name: DumpCurrentSettings
//
// Desc: Dump the current options
//=========================================================================
void DumpCurrentSettings()
{
    g_scrtext.printf( "" );
    g_scrtext.printf( "Button (A) - Run '%s' test.", g_rgTests[g_iCurTest].szDesc );

#ifdef _DEBUG
    g_scrtext.printf( "Button (B) - Dump Performance counter Info (DEBUG Version ONLY!).", 
                      g_rgTests[g_iCurTest].szDesc );
#endif

    g_scrtext.printf( "Left/Right Trigger - Scroll through tests.");
    g_scrtext.printf( "" );


    g_scrtext.printf(
        "AutoDepthStencilFormat:%s "
        "BackBufferFormat:%s ",
        g_var.AutoDepthStencilFormat ? 
            GetD3DFormatStr( g_var.AutoDepthStencilFormat ) : "none",
        GetD3DFormatStr( g_var.BackBufferFormat ) );

    g_scrtext.printf(
        "MultiSampleType:%s ",
        GetMultiSampleStr( g_var.MSType ) );

    g_scrtext.printf(
        "MultiSampleFormat:%s",
        GetMultiSampleStr( g_var.MSFormat ) );

    g_scrtext.printf(
        "zenable:%d "
        "z-write:%d "
        "d3dcmpfunc:%s",
        g_var.zenable,
        g_var.zenable && g_var.zwriteenable,
        GetD3DCMPStr( g_var.d3dcmpfunc ) );

    g_scrtext.printf(
        "alpha-blend:%d "
        "alpha-test:%d "
        "swathwidth:%d ",
        g_var.alphablendenable,
        g_var.alphatestenable,
        ( g_var.SwathWidth == D3DSWATH_OFF ) ? -1 : ( 0x8 << g_var.SwathWidth ) );

    g_scrtext.printf(
        "timeflags:%s%s",
        ( g_var.timeflags & TIME_Render ) ? "TIME_Render " : "",
        ( g_var.timeflags & TIME_Present ) ? "TIME_Present" : "" );
                                         
    for( int itex = 0; itex < 4; itex++ )
    {
        if( g_var.rgtex[itex].type )
        {
            g_scrtext.printf(
                "%d) texfmt:%s "
                "texel size (bytes):%0.1f "
                "texsize: %d "
                "mips: %d",
                itex,
                GetD3DFormatStr( g_var.rgtex[itex].d3dFormat ),
                BitsPerPixelOfD3DFORMAT( g_var.rgtex[itex].d3dFormat ) / 8.0f,
                g_var.rgtex[itex].texsize,
                g_pTexture[itex]->GetLevelCount()
                );
        }
    }

    if( g_var.userpixelshader )
    {
        g_scrtext.printf(
            "CombinerCount:%d",
            g_var.shaderdef.PSCombinerCount & 0xf );

        UINT TexModes = g_var.shaderdef.PSTextureModes;
        for( int texmode = 0; texmode < 4; texmode++, TexModes >>= 5 )
        {
            if( TexModes & 0x1f )
            {
                g_scrtext.printf( "  T%d Mode:%s",
                    texmode, GetTextureModeStr( TexModes & 0x1f ) );
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: EstimateTimeForScene
//
// Desc: Estimates how long GPU is spending rendering the scene
//-----------------------------------------------------------------------------
float EstimateTimeForScene()
{
    CTimer timer;
    int overdraw = min( 10, g_var.overdraw );

    // update the screen
    RenderFrame( 1 );
    CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

    // wait until everything is cleared out
    g_pDev->BlockUntilIdle();

    // start timing
    timer.Start();

    if( g_var.timeflags & TIME_Render )
        RenderFrame(10);

    if( g_var.timeflags & TIME_Present )
    {
        CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );
    }

    // wait until GPU is idle again
    g_pDev->BlockUntilIdle();

    // stop timer
    timer.Stop();

    return g_var.overdraw * timer.getTime() / overdraw;
}




//-----------------------------------------------------------------------------
// Name: DoTimedTest
//
// Desc: Do a timed test and spit out the results
//-----------------------------------------------------------------------------
float DoTimedTest( TIMETESTRESULTS *pttres )
{
    CTimer timer;
    int frames = 0;
    int visibilityindex = 0;
    float TimeTillDoneDrawing = 0;

    // wait until everything is cleared out
    g_pDev->BlockUntilIdle();

    int numberscenes = g_var.numberscenes;

    if( !numberscenes )
    {
        // if there isn't an explicit count of scenes to render
        // guesstimate the time required for each scene
        float fEstimatedTimePerScene = EstimateTimeForScene();

        // and figure out how many scenes to render
        numberscenes = int( g_var.testtime / fEstimatedTimePerScene );
    }

    // put an upper cap and lower bound on the number of scenes
    numberscenes = max( 2, min( numberscenes, 2047 ) );

    // start timing
    timer.Start();

    // render X number of scenes
    for( frames = 0; frames < numberscenes; frames++ )
    {
#ifndef NO_VIS_TEST

        CheckHR( g_pDev->BeginVisibilityTest() );

#endif

        if( g_var.timeflags & TIME_Render )
            RenderFrame( g_var.overdraw );

        if( g_var.timeflags & TIME_Present )
        {
            CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );
        }

#ifndef NO_VIS_TEST

        CheckHR( g_pDev->EndVisibilityTest( visibilityindex++ ) );

#endif
    }

    TimeTillDoneDrawing = timer.getTime();

    // wait until GPU is idle again
    g_pDev->BlockUntilIdle();

    // stop timer
    timer.Stop();
    float TimeTillIdle = timer.getTime();

    // get count of pixels drawn
    UINT64 dwNumPixelsDrawn = 0;

#ifdef NO_VIS_TEST

    if( ( g_var.timeflags & TIME_Present ) == TIME_Present )
    {
        dwNumPixelsDrawn = (UINT64)g_var.screenwidth * 
                                   g_var.screenheight * frames;
    }
    else if( g_var.timeflags & TIME_Render ) 
    {
        // Get backbuffer size.
        D3DSURFACE_DESC Desc;
        CheckHR( g_pBackBuffer->GetDesc( &Desc ) );

        // Scale this bugger by the backbuffer size.
        DWORD Scale = ( Desc.Width * Desc.Height ) / 
                        ( g_var.screenwidth * g_var.screenheight );

        dwNumPixelsDrawn = (UINT64)g_var.screenwidth * g_var.screenheight *
                                    frames * g_var.overdraw * Scale;

        if( g_var.timeflags & TIME_Present )
            dwNumPixelsDrawn += (UINT64)g_var.screenwidth * 
                                        g_var.screenheight * frames;
    }

#else

    for( int ivis = 0; ivis < visibilityindex; ivis++ )
    {
        // Check the number of pixels drawn.
        UINT dwT;
        while( g_pDev->GetVisibilityTestResult( ivis, &dwT, NULL ) 
               == D3DERR_TESTINCOMPLETE )
            ;

        if( g_var.verboselevel >= 2 )
            dprintf( "pass:%d  %ld pixels\n", ivis, dwT );

        if( dwT == 0xffffffff )
            dwT = 0;

        dwNumPixelsDrawn += dwT;
    }

#endif

    // Calculate fillrate
    float fillrate = dwNumPixelsDrawn / ( TimeTillIdle * 1000.0f );

    if( pttres )
    {
        pttres->fillrate = fillrate;
        pttres->fps = frames * 1000 / TimeTillIdle;
        pttres->cFrames = frames;
        pttres->TimeTillDoneDrawing = TimeTillDoneDrawing;
        pttres->TimeTillIdle = TimeTillIdle;
        pttres->cNumPixelsDrawn = dwNumPixelsDrawn;
    }

    return fillrate;
}




//-----------------------------------------------------------------------------
// macros to help read entries from the ini file
//-----------------------------------------------------------------------------
static const char g_szOpts[] = "options";
#define get_option_val(_var)          g_inifile.GetIniInt(g_szOpts, #_var, g_var._var)
#define get_option_valf(_var)         g_inifile.GetIniFloat(g_szOpts, #_var, g_var._var)
#define get_option_val3(_s, _var, _d) g_inifile.GetIniInt(_s, _var, _d)




//-----------------------------------------------------------------------------
// Name: ReadFRIniFile
//
// Desc: Read ini file and update all fillrate settings
//-----------------------------------------------------------------------------
bool ReadFRIniFile()
{
    if( !g_inifile.ReadFile() )
        return false;

    if( g_ShaderHandle )
    {
        assert( g_pDev );
        CheckHR( g_pDev->SetPixelShader(0) );
        CheckHR( g_pDev->DeletePixelShader(g_ShaderHandle) );
        g_ShaderHandle = 0;
    }

    // read the verbose flag(s) first
    g_inifile.m_fverbose            = !!get_option_val3( g_szOpts, "verboseinireads", false );
    g_var.verboselevel              = get_option_val( verboselevel );

    // if the g_iCurTest entry exists, read it in
    if( g_inifile.IniEntryExists( g_szOpts, "g_iCurTest" ) )
        g_iCurTest = g_inifile.GetIniInt( g_szOpts, "g_iCurTest", g_iCurTest );

    g_var.runtestonreload           = !!get_option_val( runtestonreload );

    g_var.AutoDepthStencilFormat    = (D3DFORMAT)get_option_val( AutoDepthStencilFormat );
    g_var.BackBufferFormat          = (D3DFORMAT)get_option_val( BackBufferFormat );

    g_var.MSType                    = (D3DMULTISAMPLE_TYPE)get_option_val( MSType );
    g_var.MSFormat                  = (D3DMULTISAMPLE_TYPE)get_option_val( MSFormat );

    g_var.specularenable            = !!get_option_val( specularenable );
    g_var.zenable                   = !!get_option_val( zenable );
    g_var.zwriteenable              = !!get_option_val( zwriteenable );
    g_var.d3dcmpfunc                = (D3DCMPFUNC)get_option_val( d3dcmpfunc );

    g_var.primez                    = !!get_option_val( primez );
    g_var.primezcmpfunc             =  (D3DCMPFUNC)get_option_val( primezcmpfunc );

    g_var.alphablendenable          = !!get_option_val( alphablendenable );
    g_var.alphatestenable           = !!get_option_val( alphatestenable );

    g_var.rotatetex                 = !!get_option_val( rotatetex );
    g_var.tiltz                     = !!get_option_val( tiltz );

    g_var.testtime                  = get_option_valf( testtime );
    g_var.numberscenes              = get_option_val( numberscenes );
    g_var.timeflags                 = get_option_val( timeflags );

    g_var.SwathWidth                = (D3DSWATHWIDTH)get_option_val( SwathWidth );

    g_var.colorwriteenable          = get_option_val( colorwriteenable );

    g_var.quadwidth                 = get_option_valf( quadwidth );
    g_var.quadheight                = get_option_valf( quadheight );

    g_var.quadx                     = ( g_var.screenwidth - min( g_var.screenwidth, g_var.quadwidth ) ) / 2;
    g_var.quady                     = ( g_var.screenheight - min( g_var.screenheight, g_var.quadheight ) ) / 2;
    g_var.quadx                     = get_option_valf( quadx );
    g_var.quady                     = get_option_valf( quady );

    g_var.FVF                       = get_option_val( FVF );

    g_var.clearflags                = get_option_val( clearflags );
    g_var.zclearval                 = get_option_valf( zclearval );
    g_var.sclearval                 = get_option_val( sclearval );
    g_var.cclearval                 = get_option_val( cclearval );

    //First check if we have a pixel shader definition file.
    static const char *szDefPixelShader = "None";

    g_inifile.GetIniStrBuf( "Options", "userpixelshaderfile", szDefPixelShader, 
                            g_var.pixelShaderFileName, 1023 );

    if( memcmp( szDefPixelShader, g_var.pixelShaderFileName, 4 ) == 0)
        g_var.userpixelshader = 0;
    else
        g_var.userpixelshader = 1;

    if( g_var.userpixelshader )
        ReadPixelShaderFile( &g_var.shaderdef );
    else
    {
        //If not, we should look for the INI version of the definition for completeness.
        g_var.userpixelshader = !!get_option_val( userpixelshader );
        if (g_var.userpixelshader)
        {
            ReadPixelShaderIni( &g_var.shaderdef );
        }
    }

    for( int itex = 0; itex < 4; itex++ )
    {
        char szSect[128];
        _snprintf( szSect, sizeof(szSect), "texture%d", itex );
		szSect[127] = '\0';

        g_var.rgtex[itex].type = get_option_val3( szSect, "type", TEX_None );
        g_var.rgtex[itex].texsize = get_option_val3( szSect, "texsize", 8 );
        g_var.rgtex[itex].d3dFormat = (D3DFORMAT)get_option_val3( szSect, "d3dFormat", D3DFMT_DXT1 );
        g_var.rgtex[itex].filtertype = (D3DTEXTUREFILTERTYPE)get_option_val3( szSect, "filtertype", D3DTEXF_LINEAR );
        g_var.rgtex[itex].mipfilter = (D3DTEXTUREFILTERTYPE)get_option_val3( szSect, "mipfilter", D3DTEXF_NONE );
    }

    return true;
}

#if _DEBUG
    extern "C" { extern DWORD D3D__DeadlockTimeOutVal; }
#endif




//-----------------------------------------------------------------------------
// Name: main
//
// Desc: Main Entry point for fillrate app
//-----------------------------------------------------------------------------
void __cdecl main()
{
#if _DEBUG
    // Bump the dbg deadlock timeout value to 20 seconds otherwise some
    // of the tests will complain about d3d being deadlocked.
    D3D__DeadlockTimeOutVal = 20000;
#endif

    XInitDevices( 0, NULL );
    XBInput_CreateGamepads();

    // init vars
    g_var.screenwidth = 640;
    g_var.screenheight = 480;

    g_var.quadwidth = 640;
    g_var.quadheight = 480;

    g_var.quadx = ( g_var.screenwidth - 
                    min(g_var.screenwidth, g_var.quadwidth ) ) / 2;
    g_var.quady = ( g_var.screenheight - 
                    min(g_var.screenheight, g_var.quadheight ) ) / 2;

    g_var.FVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;

    g_var.alphablendenable = false;
    g_var.alphatestenable = false;

    // default to drawing 10 seconds
    g_var.numberscenes = 0;
    g_var.overdraw = 100;
    g_var.testtime = 10000.0f;
    g_var.timeflags = TIME_Render;

    g_var.SwathWidth = D3DSWATH_128;

    g_var.colorwriteenable = D3DCOLORWRITEENABLE_ALL;

    g_var.ColorOp = D3DTOP_SELECTARG1;
    g_var.AlphaOp = D3DTOP_SELECTARG1;
    g_var.d3dfillmode = D3DFILL_SOLID;

    g_var.zenable = false;
    g_var.zwriteenable = false;

    g_var.d3dcmpfunc = D3DCMP_NOTEQUAL;

    g_var.primez = false;
    g_var.primezcmpfunc = D3DCMP_ALWAYS;

    g_var.BackBufferFormat = D3DFMT_A8R8G8B8;
    g_var.AutoDepthStencilFormat = D3DFMT_D24S8;

    g_var.clearflags = D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
    g_var.cclearval = 0x00006688;

    DWORD dwLastTickCount = GetTickCount();
    for( ;; )
    {
        DWORD dwTickCount = GetTickCount();
        DWORD dwTicks = dwTickCount - dwLastTickCount;

        dwLastTickCount = dwTickCount;

        HandleInput( dwTicks );

        if( g_pDev && !g_noINIFile)
        {
            if( g_fRedrawScreen )
            {
                // clear back buffer
                RenderFrame( 1 );

                // swap that guy to the front
                CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

                // clear new back buffer
                RenderFrame( 1 );

                // display current options on front buffer
                g_scrtext.cls();
                DumpCurrentSettings();
                g_scrtext.drawtext( g_var.verboselevel >= 1 );

                g_fRedrawScreen = false;
            }
            else
            {
                // 33.3 fps baby!
                Sleep( 30 );
            }
        }
        else
        {
            //No INI file.
            // Display the help text telling them to copy one over!!
            if( g_fRedrawScreen )
            {
                // clear back buffer
                RenderFrame( 0 );

                // swap that guy to the front
                CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

                // clear new back buffer
                RenderFrame( 0 );

                // display current options on front buffer
                g_scrtext.drawtext( false );

                g_fRedrawScreen = false;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: ReadPixelShaderFile
//
// Desc: Initialize and create our pixel shader from a file
//-----------------------------------------------------------------------------
void ReadPixelShaderFile( D3DPIXELSHADERDEF *pshaderdef )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD BytesRead;

    hFile = CreateFile( g_var.pixelShaderFileName,
                        GENERIC_READ, 
                        0, 
                        NULL, 
                        OPEN_EXISTING, 
                        0, 
                        NULL );
    
    if( INVALID_HANDLE_VALUE == hFile )
    {
        dprintf( "Unable to open file %s:  error %x\n", 
                 g_var.pixelShaderFileName, GetLastError() );
        g_var.userpixelshader = 0;
    }
    
    D3DPIXELSHADERDEF_FILE psdf;
    if(!ReadFile(hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &BytesRead, NULL) ||
        BytesRead != sizeof(D3DPIXELSHADERDEF_FILE) )
	{
		CloseHandle(hFile);
		return;
	}

	   

    CloseHandle(hFile);

    memcpy( pshaderdef, &(psdf.Psd), sizeof(psdf.Psd) );
}




//-----------------------------------------------------------------------------
// Name: ReadPixelShaderIni
//
// Desc: Initialize and create our pixel shader 
//-----------------------------------------------------------------------------
void ReadPixelShaderIni( D3DPIXELSHADERDEF *pshaderdef )
{
    enum
    {
        SE_PSTextureModes,
        SE_PSDotMapping,
        SE_PSInputTexture,
        SE_PSCompareMode,
        SE_PSCombinerCount,
        SE_PSFinalCombinerConstant0,
        SE_PSFinalCombinerConstant1,
        SE_PSFinalCombinerInputsABCD,
        SE_PSFinalCombinerInputsEFG,
        SE_Max
    };

#define SE_ENTRY(_x) SE_##_x, #_x
    struct ShaderEntry
    {
        DWORD dwSectionID;
        LPCSTR szSectionName;
        LPCSTR rgkeys[4];
        int rgvals[4];
    } rgEntries[] =
    {
        { SE_ENTRY(PSTextureModes),             { "t0", "t1", "t2", "t3" } },
        { SE_ENTRY(PSDotMapping),               { "t0", "t1", "t2", "t3" } },
        { SE_ENTRY(PSInputTexture),             { "t2", "t3" } },
        { SE_ENTRY(PSCompareMode),              { "t0", "t1", "t2", "t3" } },
        { SE_ENTRY(PSCombinerCount),            { "count", "flags" } },
        { SE_ENTRY(PSFinalCombinerConstant0),   { "c" } },
        { SE_ENTRY(PSFinalCombinerConstant1),   { "c" } },
        { SE_ENTRY(PSFinalCombinerInputsABCD),  { "A", "B", "C", "D" } },
        { SE_ENTRY(PSFinalCombinerInputsEFG),   { "E", "F", "G", "flags" } },
    };

    enum
    {
        SSE_PSConstant0,
        SSE_PSConstant1,
        SSE_PSRGBInputs,
        SSE_PSAlphaInputs,
        SSE_PSRGBOutputs,
        SSE_PSAlphaOutputs,
        SSE_Max
    };

#define SSE_ENTRY(_x) SSE_##_x, #_x
    struct ShaderStageEntry
    {
        DWORD dwSectionID;
        LPCSTR szSectionName;
        LPCSTR rgkeys[4];
        int rgvals[4][8];
    } rgStageEntries[] =
    {
        { SSE_ENTRY(PSConstant0),       { "c" } },
        { SSE_ENTRY(PSConstant1),       { "c" } },
        { SSE_ENTRY(PSRGBInputs),       { "A", "B", "C", "D" } },
        { SSE_ENTRY(PSAlphaInputs),     { "A", "B", "C", "D" } },
        { SSE_ENTRY(PSRGBOutputs),      { "ab", "cd", "mux_sum", "flags" } },
        { SSE_ENTRY(PSAlphaOutputs),    { "ab", "cd", "mux_sum", "flags" } },
    };

    // read all the shader entries
    for(int iSE = 0; iSE < SE_Max; iSE++)
    {
        ShaderEntry *pse = &rgEntries[iSE];

        for(int ikey = 0; ikey < 4; ikey++)
        {
            if(pse->rgkeys[ikey])
            {
                int val = g_inifile.GetIniInt(pse->szSectionName, pse->rgkeys[ikey], -1);
                if(val != -1)
                {
                    pse->rgvals[ikey] = val;
                    if(g_var.verboselevel >= 2)
                    {
                        dprintf("%s.%s = 0x%lx\n",
                            pse->szSectionName,
                            pse->rgkeys[ikey],
                            val);
                    }
                }
            }
        }
    }

    // read all the shader stage entries
    for(int iSSE = 0; iSSE < SSE_Max; iSSE++)
    {
        char szKey[128];
        ShaderStageEntry *psse = &rgStageEntries[iSSE];

        for(int ikey = 0; ikey < 4; ikey++)
        {
            if(psse->rgkeys[ikey])
            {
                for(int istage = 0; istage < 8; istage++)
                {
                    _snprintf(szKey, sizeof(szKey), "%s%d", psse->rgkeys[ikey], istage);
					szKey[127] = '\0';
                    int val = g_inifile.GetIniInt(psse->szSectionName, szKey, -1);
                    if(val != -1)
                    {
                        psse->rgvals[ikey][istage] = val;
                        if(g_var.verboselevel >= 2)
                        {
                            dprintf("%s.%s[%d] = 0x%lx\n",
                                psse->szSectionName,
                                psse->rgkeys[ikey],
                                istage,
                                val);
                        }
                    }
                }
            }
        }
    }

    ZeroMemory(pshaderdef, sizeof(*pshaderdef));

    /*---------------------------------------------------------------------------*/
    /*  Texture configuration - The following members of the D3DPixelShaderDef   */
    /*  structure define the addressing modes of each of the four texture stages */
    /*---------------------------------------------------------------------------*/
    pshaderdef->PSTextureModes = PS_TEXTUREMODES(
        rgEntries[SE_PSTextureModes].rgvals[0],
        rgEntries[SE_PSTextureModes].rgvals[1],
        rgEntries[SE_PSTextureModes].rgvals[2],
        rgEntries[SE_PSTextureModes].rgvals[3]);

    pshaderdef->PSDotMapping = PS_DOTMAPPING(
        rgEntries[SE_PSDotMapping].rgvals[0],
        rgEntries[SE_PSDotMapping].rgvals[1],
        rgEntries[SE_PSDotMapping].rgvals[2],
        rgEntries[SE_PSDotMapping].rgvals[3]);

    pshaderdef->PSInputTexture = PS_INPUTTEXTURE(
        0,
        0,
        rgEntries[SE_PSInputTexture].rgvals[0],  // 0 and 1 valid
        rgEntries[SE_PSInputTexture].rgvals[1]); // 0, 1, and 2 valid

    pshaderdef->PSCompareMode = PS_COMPAREMODE(
        rgEntries[SE_PSCompareMode].rgvals[0],
        rgEntries[SE_PSCompareMode].rgvals[1],
        rgEntries[SE_PSCompareMode].rgvals[2],
        rgEntries[SE_PSCompareMode].rgvals[3]);

    /*---------------------------------------------------------------------------------*/
    /*  Color combiners - The following members of the D3DPixelShaderDef structure     */
    /*  define the state for the eight stages of color combiners                       */
    /*---------------------------------------------------------------------------------*/
    pshaderdef->PSCombinerCount = PS_COMBINERCOUNT(
        rgEntries[SE_PSCombinerCount].rgvals[0],
        rgEntries[SE_PSCombinerCount].rgvals[1]);

    for(int istage = 0; istage < 8; istage++)
    {
        pshaderdef->PSConstant0[istage] = rgStageEntries[SSE_PSConstant0].rgvals[0][istage];
        pshaderdef->PSConstant1[istage] = rgStageEntries[SSE_PSConstant1].rgvals[0][istage];

        // R0_ALPHA is initialized to T0_ALPHA in stage0

        // a,b,c,d each contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING
        pshaderdef->PSRGBInputs[istage] = PS_COMBINERINPUTS(
            rgStageEntries[SSE_PSRGBInputs].rgvals[0][istage],      // A
            rgStageEntries[SSE_PSRGBInputs].rgvals[1][istage],      // B
            rgStageEntries[SSE_PSRGBInputs].rgvals[2][istage],      // C
            rgStageEntries[SSE_PSRGBInputs].rgvals[3][istage]);     // D

        // R0_ALPHA is initialized to T0_ALPHA in stage0
        pshaderdef->PSAlphaInputs[istage] = PS_COMBINERINPUTS(
            rgStageEntries[SSE_PSAlphaInputs].rgvals[0][istage],    // A
            rgStageEntries[SSE_PSAlphaInputs].rgvals[1][istage],    // B
            rgStageEntries[SSE_PSAlphaInputs].rgvals[2][istage],    // C
            rgStageEntries[SSE_PSAlphaInputs].rgvals[3][istage]);   // D

        // mux_sum must be DISCARD if either AB_DOT_PRODUCT or CD_DOT_PRODUCT are set
        //  ie: Dot / Dot / Discard || Dot / Mult / Discard || Mult / Dot / Discard

        // ab,cd,mux_sum contain a value from PS_REGISTER
        // flags contains values from PS_COMBINEROUTPUT
        pshaderdef->PSRGBOutputs[istage] = PS_COMBINEROUTPUTS(
            rgStageEntries[SSE_PSRGBOutputs].rgvals[0][istage],     // ab
            rgStageEntries[SSE_PSRGBOutputs].rgvals[1][istage],     // cd
            rgStageEntries[SSE_PSRGBOutputs].rgvals[2][istage],     // mux_sum
            rgStageEntries[SSE_PSRGBOutputs].rgvals[3][istage]);    // flags
        pshaderdef->PSAlphaOutputs[istage] = PS_COMBINEROUTPUTS(
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[0][istage],   // ab
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[1][istage],   // cd
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[2][istage],   // mux_sum
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[3][istage]);  // flags
    }

    pshaderdef->PSFinalCombinerConstant0 = rgEntries[SE_PSFinalCombinerConstant0].rgvals[0];
    pshaderdef->PSFinalCombinerConstant1 = rgEntries[SE_PSFinalCombinerConstant1].rgvals[0];

    // FOG ALPHA is only available in final combiner
    // V1R0_SUM and EF_PROD are only available in final combiner A,B,C,D inputs
    // V1R0_SUM_ALPHA and EF_PROD_ALPHA are not available

    // AB + (1-A)C + D
    pshaderdef->PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[0],          // A
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[1],          // B
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[2],          // C
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[3]);         // D

    // E,F,G contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING
    // flags contains values from PS_FINALCOMBINERSETTING:
    //    PS_FINALCOMBINERSETTING_CLAMP_SUM         // V1+R0 sum clamped to [0,1]
    //    PS_FINALCOMBINERSETTING_COMPLEMENT_V1     // unsigned invert mapping
    //    PS_FINALCOMBINERSETTING_COMPLEMENT_R0     // unsigned invert mapping
    pshaderdef->PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[0],           // E
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[1],           // F
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[2],           // G (alpha)
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[3]);          // flags
}




//-----------------------------------------------------------------------------
// Name: GetIniConstf
//
// Desc: Callback from inifile.cpp to get float string value
//-----------------------------------------------------------------------------
bool GetIniConstf(const char *szStr, int cchStr, float *pval)
{
    return false;
}




//-----------------------------------------------------------------------------
// Name: GetIniConst
//
// Desc: Callback from inifile.cpp to get int string value
//-----------------------------------------------------------------------------
bool GetIniConst( const char *szStr, int cchStr, int *pval )
{
    #undef XTAG
    #define XTAG( _tag ) { _tag, #_tag }
    static const struct
    {
        int Val;
        const char *szStr;
    } rgszConsts[] =
    {
        // Pixel Shaders
        XTAG( PS_TEXTUREMODES_NONE ), XTAG( PS_TEXTUREMODES_PROJECT2D ), 
        XTAG( PS_TEXTUREMODES_PROJECT3D ), XTAG( PS_TEXTUREMODES_CUBEMAP ), 
        XTAG( PS_TEXTUREMODES_PASSTHRU ), XTAG( PS_TEXTUREMODES_CLIPPLANE ),
        XTAG( PS_TEXTUREMODES_BUMPENVMAP ), XTAG( PS_TEXTUREMODES_BUMPENVMAP_LUM ), 
        XTAG( PS_TEXTUREMODES_BRDF ), XTAG( PS_TEXTUREMODES_DOT_ST ), 
        XTAG( PS_TEXTUREMODES_DOT_ZW ), XTAG( PS_TEXTUREMODES_DOT_RFLCT_DIFF ),
        XTAG( PS_TEXTUREMODES_DOT_RFLCT_SPEC ), XTAG( PS_TEXTUREMODES_DOT_STR_3D ), 
        XTAG( PS_TEXTUREMODES_DOT_STR_CUBE ), XTAG( PS_TEXTUREMODES_DPNDNT_AR ), 
        XTAG( PS_TEXTUREMODES_DPNDNT_GB ), XTAG( PS_TEXTUREMODES_DOTPRODUCT ),
        XTAG( PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST ), XTAG( PS_COMPAREMODE_S_LT ), 
        XTAG( PS_COMPAREMODE_S_GE ), XTAG( PS_COMPAREMODE_T_LT ), 
        XTAG( PS_COMPAREMODE_T_GE ), XTAG( PS_COMPAREMODE_R_LT ),
        XTAG( PS_COMPAREMODE_R_GE ), XTAG( PS_COMPAREMODE_Q_LT ), 
        XTAG( PS_COMPAREMODE_Q_GE ), XTAG( PS_COMBINERCOUNT_MUX_LSB ), 
        XTAG( PS_COMBINERCOUNT_MUX_MSB ), XTAG( PS_COMBINERCOUNT_SAME_C0 ),
        XTAG( PS_COMBINERCOUNT_UNIQUE_C0 ), XTAG( PS_COMBINERCOUNT_SAME_C1 ), 
        XTAG( PS_COMBINERCOUNT_UNIQUE_C1 ), XTAG( PS_INPUTMAPPING_UNSIGNED_IDENTITY ), 
        XTAG( PS_INPUTMAPPING_UNSIGNED_INVERT ), XTAG( PS_INPUTMAPPING_EXPAND_NORMAL ),
        XTAG( PS_INPUTMAPPING_EXPAND_NEGATE ), XTAG( PS_INPUTMAPPING_HALFBIAS_NORMAL ), 
        XTAG( PS_INPUTMAPPING_HALFBIAS_NEGATE ), XTAG( PS_INPUTMAPPING_SIGNED_IDENTITY ), 
        XTAG( PS_INPUTMAPPING_SIGNED_NEGATE ), XTAG( PS_REGISTER_ZERO ),
        XTAG( PS_REGISTER_DISCARD ), XTAG( PS_REGISTER_C0 ), XTAG( PS_REGISTER_C1 ),
        XTAG( PS_REGISTER_FOG ), XTAG( PS_REGISTER_V0 ), XTAG( PS_REGISTER_V1 ),
        XTAG( PS_REGISTER_T0 ), XTAG( PS_REGISTER_T1 ), XTAG( PS_REGISTER_T2 ),
        XTAG( PS_REGISTER_T3 ), XTAG( PS_REGISTER_R0 ), XTAG( PS_REGISTER_R1 ),
        XTAG( PS_REGISTER_V1R0_SUM ), XTAG( PS_REGISTER_EF_PROD ), 
        XTAG( PS_REGISTER_ONE ), XTAG( PS_REGISTER_NEGATIVE_ONE ), 
        XTAG( PS_REGISTER_ONE_HALF ), XTAG( PS_REGISTER_NEGATIVE_ONE_HALF ),
        XTAG( PS_CHANNEL_RGB ), XTAG( PS_CHANNEL_BLUE ), XTAG( PS_CHANNEL_ALPHA ),
        XTAG( PS_FINALCOMBINERSETTING_CLAMP_SUM ), 
        XTAG( PS_FINALCOMBINERSETTING_COMPLEMENT_V1 ), 
        XTAG( PS_FINALCOMBINERSETTING_COMPLEMENT_R0 ),
        XTAG( PS_COMBINEROUTPUT_IDENTITY ), XTAG( PS_COMBINEROUTPUT_BIAS ), 
        XTAG( PS_COMBINEROUTPUT_SHIFTLEFT_1 ), XTAG( PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS ), 
        XTAG( PS_COMBINEROUTPUT_SHIFTLEFT_2 ), XTAG( PS_COMBINEROUTPUT_SHIFTRIGHT_1 ),
        XTAG( PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA ), 
        XTAG( PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA ), XTAG( PS_COMBINEROUTPUT_AB_MULTIPLY ),
        XTAG( PS_COMBINEROUTPUT_AB_DOT_PRODUCT ), XTAG( PS_COMBINEROUTPUT_CD_MULTIPLY ), 
        XTAG( PS_COMBINEROUTPUT_CD_DOT_PRODUCT ), XTAG( PS_COMBINEROUTPUT_AB_CD_SUM ), 
        XTAG( PS_COMBINEROUTPUT_AB_CD_MUX ), XTAG( PS_DOTMAPPING_ZERO_TO_ONE ), 
        XTAG( PS_DOTMAPPING_MINUS1_TO_1_D3D ), XTAG( PS_DOTMAPPING_MINUS1_TO_1_GL ),
        XTAG( PS_DOTMAPPING_MINUS1_TO_1 ), XTAG( PS_DOTMAPPING_HILO_1 ), 
        XTAG( PS_DOTMAPPING_HILO_HEMISPHERE_D3D ), 
        XTAG( PS_DOTMAPPING_HILO_HEMISPHERE_GL ),
        XTAG( PS_DOTMAPPING_HILO_HEMISPHERE ),

        // D3DFORMATs
        XTAG( D3DFMT_A8R8G8B8 ), XTAG( D3DFMT_X8R8G8B8 ), XTAG( D3DFMT_R5G6B5 ), 
        XTAG( D3DFMT_R6G5B5 ), XTAG( D3DFMT_X1R5G5B5 ), XTAG( D3DFMT_A1R5G5B5 ), 
        XTAG( D3DFMT_A4R4G4B4 ), XTAG( D3DFMT_A8 ), XTAG( D3DFMT_A8B8G8R8 ), 
        XTAG( D3DFMT_B8G8R8A8 ), XTAG( D3DFMT_R4G4B4A4 ), XTAG( D3DFMT_R5G5B5A1 ),
        XTAG( D3DFMT_R8G8B8A8 ), XTAG( D3DFMT_R8B8 ), XTAG( D3DFMT_G8B8 ), 
        XTAG( D3DFMT_P8 ), XTAG( D3DFMT_L8 ), XTAG( D3DFMT_A8L8 ), XTAG( D3DFMT_AL8 ), 
        XTAG( D3DFMT_L16 ), XTAG( D3DFMT_V8U8 ), XTAG( D3DFMT_L6V5U5 ), 
        XTAG( D3DFMT_X8L8V8U8 ), XTAG( D3DFMT_Q8W8V8U8 ), XTAG( D3DFMT_V16U16 ), 
        XTAG( D3DFMT_D16_LOCKABLE ), XTAG( D3DFMT_D16 ), XTAG( D3DFMT_D24S8 ),
        XTAG( D3DFMT_F16 ), XTAG( D3DFMT_F24S8 ), XTAG( D3DFMT_UYVY ), 
        XTAG( D3DFMT_YUY2 ), XTAG( D3DFMT_DXT1 ), XTAG( D3DFMT_DXT2 ), 
        XTAG( D3DFMT_DXT3 ), XTAG( D3DFMT_DXT4 ), XTAG( D3DFMT_DXT5 ), 
        XTAG( D3DFMT_LIN_A1R5G5B5 ), XTAG( D3DFMT_LIN_A4R4G4B4 ), XTAG( D3DFMT_LIN_A8 ),
        XTAG( D3DFMT_LIN_A8B8G8R8 ), XTAG( D3DFMT_LIN_A8R8G8B8 ), 
        XTAG( D3DFMT_LIN_B8G8R8A8 ), XTAG( D3DFMT_LIN_G8B8 ), XTAG( D3DFMT_LIN_R4G4B4A4 ), 
        XTAG( D3DFMT_LIN_R5G5B5A1 ), XTAG( D3DFMT_LIN_R5G6B5 ), XTAG( D3DFMT_LIN_R6G5B5 ),
        XTAG( D3DFMT_LIN_R8B8 ), XTAG( D3DFMT_LIN_R8G8B8A8 ), XTAG( D3DFMT_LIN_X1R5G5B5 ), 
        XTAG( D3DFMT_LIN_X8R8G8B8 ), XTAG( D3DFMT_LIN_A8L8 ), XTAG( D3DFMT_LIN_AL8 ), 
        XTAG( D3DFMT_LIN_L16 ), XTAG( D3DFMT_LIN_L8 ), XTAG( D3DFMT_LIN_D24S8 ), 
        XTAG( D3DFMT_LIN_F24S8 ), XTAG( D3DFMT_LIN_D16 ), XTAG( D3DFMT_LIN_F16 ),

        XTAG( D3DMULTISAMPLE_NONE ), XTAG( D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX ), 
        XTAG( D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR ),
        XTAG( D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR ), 
        XTAG( D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN ),
        XTAG( D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR ),
        XTAG( D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN ),
        XTAG( D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT ),
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5 ), 
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5 ),
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8 ), 
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8 ),

        XTAG( D3DMS_NONE ), XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX ), 
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR ), 
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN ),
        XTAG( D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_PREFILTER_FORMAT_DEFAULT ),
        XTAG( D3DMS_PREFILTER_FORMAT_X1R5G5B5 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_R5G6B5 ),
        XTAG( D3DMS_PREFILTER_FORMAT_X8R8G8B8 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_A8R8G8B8 ),

        XTAG( D3DCLEAR_TARGET ), XTAG( D3DCLEAR_ZBUFFER ), XTAG( D3DCLEAR_STENCIL ),

        // FVFs
        XTAG( D3DFVF_XYZ ), XTAG( D3DFVF_XYZRHW ), XTAG( D3DFVF_NORMAL ), 
        XTAG( D3DFVF_DIFFUSE ), XTAG( D3DFVF_SPECULAR ), XTAG( D3DFVF_TEX0 ), 
        XTAG( D3DFVF_TEX1 ), XTAG( D3DFVF_TEX2 ),
        XTAG( D3DFVF_TEX3 ), XTAG( D3DFVF_TEX4 ),

        // textcoord sizes
        XTAG( T0_SIZE1 ), XTAG( T0_SIZE2 ), XTAG( T0_SIZE3 ), XTAG( T0_SIZE4 ),
        XTAG( T1_SIZE1 ), XTAG( T1_SIZE2 ), XTAG( T1_SIZE3 ), XTAG( T1_SIZE4 ),
        XTAG( T2_SIZE1 ), XTAG( T2_SIZE2 ), XTAG( T2_SIZE3 ), XTAG( T2_SIZE4 ),
        XTAG( T3_SIZE1 ), XTAG( T3_SIZE2 ), XTAG( T3_SIZE3 ), XTAG( T3_SIZE4 ),

        // D3DCMPs
        XTAG( D3DCMP_NEVER ), XTAG( D3DCMP_LESS ), XTAG( D3DCMP_EQUAL ), 
        XTAG( D3DCMP_LESSEQUAL ), XTAG( D3DCMP_GREATER ), XTAG( D3DCMP_NOTEQUAL ), 
        XTAG( D3DCMP_GREATEREQUAL ), XTAG( D3DCMP_ALWAYS ),

        XTAG( D3DTEXF_NONE ), XTAG( D3DTEXF_POINT ), XTAG( D3DTEXF_LINEAR ), 
        XTAG( D3DTEXF_ANISOTROPIC ), XTAG( D3DTEXF_QUINCUNX ), 
        XTAG( D3DTEXF_GAUSSIANCUBIC ),

        XTAG( TEX_None ), XTAG( TEX_2d ), XTAG( TEX_Cubemap ), XTAG( TEX_Volume ),

        XTAG( TIME_Present ), XTAG( TIME_Render ),

        // swaths
        XTAG( D3DSWATH_8 ), XTAG( D3DSWATH_16 ), XTAG( D3DSWATH_32 ),
        XTAG( D3DSWATH_64 ), XTAG( D3DSWATH_128 ), XTAG( D3DSWATH_OFF ),

        XTAG( D3DCOLORWRITEENABLE_RED ), XTAG( D3DCOLORWRITEENABLE_GREEN ), 
        XTAG( D3DCOLORWRITEENABLE_BLUE ), XTAG( D3DCOLORWRITEENABLE_ALPHA ), 
        XTAG( D3DCOLORWRITEENABLE_ALL ),

        // misc
        XTAG( FALSE  ), XTAG( TRUE )
    };

    for( int ifmt = 0; ifmt < ARRAYSIZE( rgszConsts ); ifmt++ )
    {
        if( !_strnicmp( rgszConsts[ifmt].szStr, szStr, cchStr ) )
        {
            // set val
            *pval = rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\makefile.inc ===
!include "..\..\samples\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\fillrate.h ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.H
//
// Desc: fillrate header
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

enum { TEX_None, TEX_2d, TEX_Cubemap, TEX_Volume, TEX_Max };
enum { TIME_Present = 0x1, TIME_Render = 0x2 };

struct TIMETESTRESULTS
{
    float   fillrate;
    float   fps;
    int     cFrames;
    float   TimeTillDoneDrawing;
    float   TimeTillIdle;
    UINT64  cNumPixelsDrawn;
};

struct FRSETTINGS
{
    UINT overdraw;                      // number of overdraws in a scene
    UINT verboselevel;                  // chatty when loading pixelshader defs, etc.
    UINT runtestonreload;               // after reloading fillrate.ini run test

    UINT screenwidth;                   // screen width
    UINT screenheight;                  // screen height
    D3DFORMAT BackBufferFormat;         // back buffer d3dformat
    D3DFORMAT AutoDepthStencilFormat;   // z buffer format (0 for none)

    D3DMULTISAMPLE_TYPE MSType;         // multisample type
    D3DMULTISAMPLE_TYPE MSFormat;       // multisample format

    DWORD FVF;                          // fvf type
    float quadwidth;                    // quad width
    float quadheight;                   // quad height
    float quadx;
    float quady;

    bool specularenable;                // specularenable
    bool zenable;                       // enable z buffer
    bool zwriteenable;                  // enable z write
    D3DCMPFUNC d3dcmpfunc;              // z compare function

    bool primez;                        // prime z with quad/D3DCMP_ALWAYS before drawing scene
    D3DCMPFUNC primezcmpfunc;           // z prime compare function

    UINT timeflags;                     // what to time: TIME_Present, TIME_Render, ...
    int numberscenes;                   // number of scenes to time (0 to use testtime)
    float testtime;                     // number of seconds to time

    DWORD clearflags;                   // Clear() flags
    DWORD cclearval;                    // color clear val
    float zclearval;                    // z clear val
    DWORD sclearval;                    // stencil clear val

    bool userpixelshader;               // use a userpixelshader
    D3DPIXELSHADERDEF shaderdef;        // the users pixel shader def
    char pixelShaderFileName[1024];     // File name of the user pixel shader to load

    bool alphablendenable;              // turn on alphablending
    bool alphatestenable;               // turn on alphatesting
    bool rotatetex;                     // rotate texture
    bool tiltz;                         // top edge z of 0, bottom edge z of 1.0

    struct FRTEX
    {
        UINT type;                      // type of texture (TEX_None, TEX_2d, TEX_Cubemap, TEX_Volume)
        UINT texsize;                   // size of texture
        D3DFORMAT d3dFormat;            // format of tetxure
        D3DTEXTUREFILTERTYPE filtertype;// filtertype
        D3DTEXTUREFILTERTYPE mipfilter;
    } rgtex[4];

    D3DSWATHWIDTH SwathWidth;           // swadth width

    D3DTEXTUREOP ColorOp;               // color op (if !userpixelshader)
    D3DTEXTUREOP AlphaOp;               // alpha op (if !userpixelshader)

    D3DFILLMODE d3dfillmode;            // SOLID, WIREFRAME, ...
    DWORD colorwriteenable;             // D3DRS_COLORWRITEENABLE flags
};

// macros to help us define the size of our texcoords in fillrate.ini
static const DWORD T0_SIZE1 = D3DFVF_TEXCOORDSIZE1( 0 );
static const DWORD T0_SIZE2 = D3DFVF_TEXCOORDSIZE2( 0 );
static const DWORD T0_SIZE3 = D3DFVF_TEXCOORDSIZE3( 0 );
static const DWORD T0_SIZE4 = D3DFVF_TEXCOORDSIZE4( 0 );
                                                    
static const DWORD T1_SIZE1 = D3DFVF_TEXCOORDSIZE1( 1 );
static const DWORD T1_SIZE2 = D3DFVF_TEXCOORDSIZE2( 1 );
static const DWORD T1_SIZE3 = D3DFVF_TEXCOORDSIZE3( 1 );
static const DWORD T1_SIZE4 = D3DFVF_TEXCOORDSIZE4( 1 );
                                                    
static const DWORD T2_SIZE1 = D3DFVF_TEXCOORDSIZE1( 2 );
static const DWORD T2_SIZE2 = D3DFVF_TEXCOORDSIZE2( 2 );
static const DWORD T2_SIZE3 = D3DFVF_TEXCOORDSIZE3( 2 );
static const DWORD T2_SIZE4 = D3DFVF_TEXCOORDSIZE4( 2 );
                                                    
static const DWORD T3_SIZE1 = D3DFVF_TEXCOORDSIZE1( 3 );
static const DWORD T3_SIZE2 = D3DFVF_TEXCOORDSIZE2( 3 );
static const DWORD T3_SIZE3 = D3DFVF_TEXCOORDSIZE3( 3 );
static const DWORD T3_SIZE4 = D3DFVF_TEXCOORDSIZE4( 3 );

// fillrate.cpp
float DoTimedTest( TIMETESTRESULTS *pttres = NULL );
void DoCompleteTimedTest();
void DoQuickTimedTest();
void DoMultiSampleTimedTest();
void DumpCurrentSettings();
void DoTextureTest();

void ReadPixelShaderFile( D3DPIXELSHADERDEF *pshaderdef );
void ReadPixelShaderIni( D3DPIXELSHADERDEF *pshaderdef );
bool ReadFRIniFile();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\inifile.h ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.H
//
// Desc: Quick and dirty INI file routines
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// Routines supplied by the main application to return the values for a given
// string found in an ini file.
bool GetIniConst( const char *szStr, int cchStr, int *pval );
bool GetIniConstf( const char *szStr, int cchStr, float *pval );




//-----------------------------------------------------------------------------
// IniFile class
//-----------------------------------------------------------------------------
class CIniFile
{
public:
    CIniFile( LPCSTR szFileName ) : m_szFile( NULL ), 
                                    m_fverbose( false ), 
                                    m_recurselevel( 0 )
    { 
        lstrcpyA( m_szFileName, szFileName ); 
        m_ftFileReadTime.dwLowDateTime =
        m_ftFileReadTime.dwHighDateTime = 0;
    }

    ~CIniFile()
    {
        if( m_szFile )
        {
            free( m_szFile );
            m_szFile = NULL;
        }
    };

    // get int entry
    int GetIniInt( LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault );

    // get float entry
    float GetIniFloat( LPCSTR lpSectionName, LPCSTR lpKeyName, float nDefault );

    // check for entry existance
    bool IniEntryExists( LPCSTR lpSectionName, LPCSTR lpKeyName );

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    bool GetIniStrBuf( LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, char *buf, int buflen );

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    LPCSTR GetIniStr( LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, LPCSTR *ppszLineStart );

    // read/refresh an ini file
    bool ReadFile();

    // get name of ini file
    LPCSTR GetFileName()
    { 
        return m_szFileName; 
    }

    // has ini file timestamp changed?
    bool FileChanged()
    { 
        HANDLE hFile = CreateFile( m_szFileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

        if( hFile != INVALID_HANDLE_VALUE )
        {
            FILETIME chkFileTime;
            if (GetFileTime(hFile,NULL,NULL,&chkFileTime))
            {
                CloseHandle(hFile);
                return (chkFileTime.dwLowDateTime != m_ftFileReadTime.dwLowDateTime) ||
                        (chkFileTime.dwHighDateTime != m_ftFileReadTime.dwHighDateTime); 
            }
            else    //No file.  Therefore, it didn't change!
            {
                CloseHandle(hFile);
                return false;
            }
        }
        else
            return false;
    }

    bool m_fverbose;

private:
    enum 
    { 
        INIVAL_INT, 
        INIVAL_FLOAT 
    };

    struct INIVAL
    {
        int type;

        int val;
        float valf;

        void SetVal( int newval )
        { 
            val = newval; 
            valf = (float)newval; 
        }

        void SetVal( float newval )
        { 
            val = (int)newval; 
            valf = newval; 
        }
    };

    LPCSTR GetIniConstValue( const char *szStr, INIVAL *pinival );

    bool ParseIntVal( LPCSTR szLineStart, LPCSTR szLine, int *pval );
    bool ParseFloatVal( LPCSTR szLineStart, LPCSTR szLine, float *pval );

    char m_szFileName[MAX_PATH];
    char *m_szFile;
    FILETIME m_ftFileReadTime;

    UINT m_recurselevel;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\inifile.cpp ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.CPP
//
// Desc: INI file routines
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <assert.h>

#include "utils.h"
#include "inifile.h"




//-----------------------------------------------------------------------------
// Name: GetIniConstValue
//
// Desc: Get the value of a constant
//-----------------------------------------------------------------------------
LPCSTR CIniFile::GetIniConstValue( const char *szStr, INIVAL *pinival )
{
    // skip whitespace
    while( *szStr == ' ' || *szStr == '\t' )
        szStr++;

    if( ( *szStr >= '0' && *szStr <= '9' ) || ( *szStr == '.' ) )
    {
        char *endptr;
        int base = 10;

        if( szStr[1] == 'x' )
        {
            // hexadecimal: skip over leading '0x'
            base = 16;
            szStr += 2;
        }
        else if( pinival->type == INIVAL_FLOAT )
        {
            // check for floating point value
            for( const char *szT = szStr;
                *szT && ( ( *szT >= '0' && *szStr <= '9' ) || *szT == '.' );
                szT++ )
            {
                if( *szT == '.' )
                {
                    for( szT++; *szT && ( *szT >= '0' && *szStr <= '9' ); szT++ )
                        ;

                    // check for trailing f
                    if( *szT == 'f' )
                        szT++;

                    pinival->SetVal( (float) atof( szStr ) );
                    return szT;
                }
            }
        }

        pinival->SetVal( (int) strtoul( szStr, &endptr, base ) );
        return endptr;
    }

    // token length
    int cchStr = 0;

    // find token length
    for( const char *szT = szStr; 
         *szT && ( *szT != ';' ) && ( *szT != '|' ) && !isspace( *szT ); szT++ )
        cchStr++;

    // see if the token is known by the app
    if( GetIniConstf( szStr, cchStr, &pinival->valf ) )
    {
        pinival->val = (int)pinival->valf;
        return szStr + cchStr;
    }
    else if( GetIniConst( szStr, cchStr, &pinival->val ) )
    {
        pinival->valf = (float)pinival->val;
        return szStr + cchStr;
    }

    // couldn't find token - search in [defines] section
    if( m_recurselevel < 10 )
    {
        char szKeyName[64];
        static const char szSectName[] = "defines";

        lstrcpynA( szKeyName, szStr, min( sizeof( szKeyName ), cchStr + 1 ) );

        LPCSTR szLineStart;
        LPCSTR szLine = GetIniStr( szSectName, szKeyName, NULL, &szLineStart );

        if( szLine )
        {
            bool fFoundDefine = false;

            m_recurselevel++;

            // did not find entry - search in defines section
            if( pinival->type == INIVAL_FLOAT )
            {
                fFoundDefine = ParseFloatVal( szLineStart, szLine, &pinival->valf );
                pinival->val = (int)pinival->valf;
            }
            else
            {
                fFoundDefine = ParseIntVal( szLineStart, szLine, &pinival->val );
                pinival->valf = (float)pinival->val;
            }

            m_recurselevel--;

            if( fFoundDefine )
                return szStr + cchStr;
        }
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: SzReadFile
//
// Desc: Read a file and return malloc'd pointer to data
//-----------------------------------------------------------------------------
char *SzReadFile( LPCSTR szFileName )
{

    HANDLE hFile = CreateFile( szFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );
    if( hFile != INVALID_HANDLE_VALUE )
    {
        DWORD dwSize = GetFileSize( hFile, NULL );
        char *szFile = (char *)malloc( dwSize + 1 );
        assert( szFile != NULL);

        DWORD NumberOfBytesRead;
		BOOL bReadOK;
		bReadOK = ReadFile( hFile, szFile, dwSize, &NumberOfBytesRead, NULL );
		assert(bReadOK);
        assert(dwSize == NumberOfBytesRead );

        szFile[NumberOfBytesRead] = 0;

        CloseHandle( hFile );
        return szFile;
    }
    else
    {
        HRESULT result = GetLastError();
        dprintf( "Could not open %s   Error: %d\n", szFileName, result);
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: ReadFile
//
// Desc: Read/refresh ini file
//-----------------------------------------------------------------------------
bool CIniFile::ReadFile()
{
    if( m_szFile )
    {
        free( m_szFile );
        m_szFile = NULL;
    }

    m_szFile = SzReadFile( m_szFileName );
    if( !m_szFile )
    {
        // if file read failed - sleep a short bit in case xbcp
        // had file open still.
        Sleep( 500 );
        m_szFile = SzReadFile( m_szFileName);
    }

    if( m_szFile )
    {
        HANDLE hFile = CreateFile( m_szFileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

        if( hFile != INVALID_HANDLE_VALUE )
            GetFileTime( hFile, NULL, NULL, &m_ftFileReadTime );

        CloseHandle(hFile);

        return true;
    }

    return false;
}




//-----------------------------------------------------------------------------
// Name: GetLine
//
// Desc: Find the next real line and return pointer
//-----------------------------------------------------------------------------
LPCSTR GetLine( LPCSTR szLine )
{
    for( ;; )
    {
        // skip whitespace
        while( isspace( *szLine ) )
            szLine++;

        // check for comments
        if( *szLine == ';' || ( szLine[0] == '/' && szLine[1] == '/' ) )
        {
            // found a comment - cruise to end of line
            while( *szLine && *szLine != '\n' )
                szLine++;
            continue;
        }

        return szLine;
    }
}




//-----------------------------------------------------------------------------
// Name: FindFirst
//
// Desc: Get first line of INI file
//-----------------------------------------------------------------------------
LPCSTR FindFirstLine( LPCSTR szFile )
{
    if( szFile )
        return GetLine( szFile );

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: FindNextLine
//
// Desc: Get line after szLine
//-----------------------------------------------------------------------------
LPCSTR FindNextLine( LPCSTR szLine )
{
    if( szLine )
    {
        while( *szLine && *szLine++ != '\n' )
            ;
        return GetLine( szLine );
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: FindNextChar
//
// Desc: Find the next token's first char
//-----------------------------------------------------------------------------
char FindNextChar( LPCSTR szLine, LPCSTR *ppszLine = NULL )
{
    // skip whitespace
    while( *szLine == ' ' || *szLine == '\t' )
        szLine++;

    if( ppszLine )
        *ppszLine = szLine;
    return *szLine;
}




//-----------------------------------------------------------------------------
// Name: OuputLineErr
//
// Desc: Print out error message for something we couldn't parse
//-----------------------------------------------------------------------------
void OutputLineErr(LPCSTR szErr, LPCSTR szLine)
{
    LPCSTR szEnd = szLine;
    while( *szEnd && ( *szEnd != '\r' && *szEnd != '\n' ) )
        szEnd++;

    char chSav = *szEnd;
    *(char *)szEnd = 0;

    OutputDebugStringA( szErr );
    OutputDebugStringA( ":" );
    OutputDebugStringA( szLine );
    OutputDebugStringA( "\n" );

    *(char *)szEnd = chSav;
}




//-----------------------------------------------------------------------------
// Name: ParseFloatVal
//
// Desc: Parse a token stream and return the value
//-----------------------------------------------------------------------------
bool CIniFile::ParseFloatVal( LPCSTR szLineStart, LPCSTR szLine, float *pval )
{
    INIVAL valT = { INIVAL_FLOAT };
    if( GetIniConstValue( szLine, &valT ) )
    {
        *pval = valT.valf;
        return true;
    }

    OutputLineErr("unknown token", szLineStart );
    return false;
}




//-----------------------------------------------------------------------------
// Name: ParseIntVal
//
// Desc: Parse a token stream and return the value
//-----------------------------------------------------------------------------
bool CIniFile::ParseIntVal( LPCSTR szLineStart, LPCSTR szLine, int *pval )
{
    INIVAL valT = { INIVAL_INT };
    int val = 0;

    while( szLine = GetIniConstValue( szLine, &valT ) )
    {
        val |= valT.val;

        char ch = FindNextChar( szLine, &szLine );
        switch( ch )
        {
        case '|':
            szLine++;
            break;
             
        case '\r':
        case '\n':
        case '\0':
        case ';':
            // end of the line
            *pval = val;
            return true;

        default:
            OutputLineErr( "unknown char", szLineStart );
            return false;
        }
    }

    OutputLineErr( "unknown token", szLineStart );
    return false;
}




//-----------------------------------------------------------------------------
// Name: GetIniFloat
//
// Desc: Get float value for ini entry
//-----------------------------------------------------------------------------
float CIniFile::GetIniFloat( LPCSTR lpSectionName, LPCSTR lpKeyName, 
                             float nDefault )
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, &szLineStart );

    if( !szLine )
        return nDefault;

    ParseFloatVal( szLineStart, szLine, &nDefault );
    return nDefault;
}




//-----------------------------------------------------------------------------
// Name: GetIniInt
//
// Desc: Get int value for ini entry
//-----------------------------------------------------------------------------
int CIniFile::GetIniInt( LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault )
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, &szLineStart );

    if( !szLine )
        return nDefault;

    ParseIntVal( szLineStart, szLine, &nDefault );
    return nDefault;
}




//-----------------------------------------------------------------------------
// Name: IniEntryExists
//
// Desc: Check if an ini entry exists
//-----------------------------------------------------------------------------
bool CIniFile::IniEntryExists( LPCSTR lpSectionName, LPCSTR lpKeyName )
{
    bool fverboseBak = m_fverbose;
    m_fverbose = false;

    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, NULL );

    m_fverbose = fverboseBak;
    return !!szLine;
}




//-----------------------------------------------------------------------------
// Name: GetIniStrBuf
//
// Desc: Get an INI string and shtuff it into a buffer
//-----------------------------------------------------------------------------
bool CIniFile::GetIniStrBuf( LPCSTR lpSectionName, LPCSTR lpKeyName,
                             LPCSTR szDefault, char *buf, int buflen )
{
    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, NULL );
    if( szLine )
    {
        strncpy( buf, szLine, buflen );

        for( int nT = 0; nT < buflen; nT++ )
        {
            if( buf[nT] == '\n' || buf[nT] == '\r' || buf[nT] == ';' )
            {
                buf[nT] = 0;
                break;
            }
        }
    }
    else
    {
        strncpy( buf, szDefault, buflen );
    }

    buf[buflen - 1] = 0;
    return !!szLine;
}




//-----------------------------------------------------------------------------
// Name: GetIniStr
//
// Desc: Return non-nil terminated string for keyname
//-----------------------------------------------------------------------------
LPCSTR CIniFile::GetIniStr( LPCSTR lpSectionName, LPCSTR lpKeyName, 
                            LPCSTR szDefault, LPCSTR *ppszLineStart )
{
    assert( m_szFile );
    if( !m_szFile )
        return szDefault;

    bool finsection = false;
    int cchSectionName = lstrlenA( lpSectionName );
    int cchKeyName = lstrlenA( lpKeyName );
    LPCSTR szLine = FindFirstLine( m_szFile );

    while( szLine && *szLine )
    {
        if( ppszLineStart )
            *ppszLineStart = szLine;

        if( finsection )
        {
            if( *szLine == '[' )
            {
                // new section - not found
                break;
            }
            else if( !_strnicmp(lpKeyName, szLine, cchKeyName ) &&
                   ( FindNextChar(szLine + cchKeyName, &szLine ) == '=' ) )
            {
                // skip over '='
                szLine++;

                // skip whitespace
                while( *szLine == ' ' || *szLine == '\t' )
                    szLine++;

                return szLine;
            }
        }
        else if( *szLine == '[' )
        {
            // section name matches?
            szLine++;
            finsection = !_strnicmp( lpSectionName, szLine, cchSectionName ) &&
                                   ( FindNextChar( szLine + cchSectionName ) == ']' );
        }

        szLine = FindNextLine( szLine );
    }

    if( m_fverbose )
        dprintf( "entry [%s]/%s not found\n", lpSectionName, lpKeyName );

    return szDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\utils.h ===
//----------------------------------------------------------------------------
// FILE: UTILS.H
//
// Desc: utils header file
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define ARRAYSIZE( _a )     ( sizeof( _a ) / sizeof( ( _a )[0] ) )




//----------------------------------------------------------------------------
// Release helper function
//----------------------------------------------------------------------------
template <class T> inline void RELEASE( T& punk )
{
    if( punk )
    {
        punk->Release();
        punk = NULL;
    }
}




//----------------------------------------------------------------------------
// Class to help time things
//----------------------------------------------------------------------------
class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency( (LARGE_INTEGER*)&ticksPerSecond );
        ticksPerSecond /= 1000;
    }

    ~CTimer() 
    {
    };

    void Start()
    { 
        frunning = true; 
        QueryPerformanceCounter( (LARGE_INTEGER *)&ticksstart ); 
    }

    void Stop()
    { 
        frunning = false; 
        QueryPerformanceCounter( (LARGE_INTEGER *)&ticksend ); 
    }

    float getTime()
    {
        if( frunning )
            QueryPerformanceCounter( (LARGE_INTEGER *)&ticksend );
        return ( ( ticksend - ticksstart ) * 1.0f / ticksPerSecond );
    }

    bool frunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};




//----------------------------------------------------------------------------
// Screen Text helper class
//----------------------------------------------------------------------------
class CScrText
{
public:
    CScrText()
    { 
        cls(); 
    }

    ~CScrText() 
    {
    }

    void cls()
    {
        m_iLine = 0;
        for( int i = 0; i < NUM_LINES; i++ )
            m_rgText[i][0] = 0;
    }

    void _cdecl printf( LPCSTR lpFmt, ... );

    void drawtext( bool fDebug );

private:
    enum 
    { 
        LINE_WIDTH = 80, 
        NUM_LINES = 40 
    };

    char m_rgText[NUM_LINES][LINE_WIDTH];
    int m_iLine;
};




// redefine these guys to make them shorter and remove the misleading D3DMULTISAMPLE_ part
#define D3DMS_NONE                                         D3DMULTISAMPLE_NONE
#define D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX               D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR      D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR
#define D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR        D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR
#define D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_PREFILTER_FORMAT_DEFAULT                     D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT
#define D3DMS_PREFILTER_FORMAT_X1R5G5B5                    D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5
#define D3DMS_PREFILTER_FORMAT_R5G6B5                      D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5
#define D3DMS_PREFILTER_FORMAT_X8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8
#define D3DMS_PREFILTER_FORMAT_A8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8




//----------------------------------------------------------------------------
// utils.cpp
bool IsLinearFormat( DWORD Format );
DWORD BitsPerPixelOfD3DFORMAT( DWORD Format );
LPCSTR GetD3DCMPStr( D3DCMPFUNC d3dcmpfunc );
LPCSTR GetD3DFormatStr( D3DFORMAT d3dformat );
LPCSTR GetMultiSampleStr( DWORD mstype );
LPCSTR GetTextureModeStr( DWORD TextureMode );




//----------------------------------------------------------------------------
void DisplayError( const char *szCall, HRESULT hr );

#define CheckHR( x ) { HRESULT _hr = ( x ); if ( FAILED( _hr ) ) { DisplayError( #x, _hr ); } }

void _cdecl dprintf( LPCSTR lpFmt, ... );

//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FontMaker\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FontMaker.rc
//
#define IDD_FONTMAKER                   1543
#define IDC_FONT                        1136 // Don't change this!
#define IDC_GLYPHRANGE_START            9004
#define IDC_GLYPHRANGE_END              9005
#define IDC_STATIC                      -1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FontMaker\fontmaker.cpp ===
//-----------------------------------------------------------------------------
// File: FontMaker.cpp
//
// Desc: Creates an Xbox font file (.abc) for the specified font. This app
//       overides the common font selection dialog. After the user selects a
//       font and a glyph range, this app creates a bitmap containing all
//       glyphs in the selected range. Finally, the bitmap is saved as a .tga
//       texture file, and the glyph spacing info is saved in a .abc binary
//       file. Both files (the .tga and the .abe) are used by Xbox XDK samples
//       to render texture-based text. Additionally, please note that the .tga
//       file can be modified with image-editing software to add colors,
//       drop shadows and other effects.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.07.01 - Added glyph range selection for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <commdlg.h>   // To get to the common font dialog
#include "resource.h"  // To override the common font dialog

// Note: In case you plan to modify the dialog in this app's .rc file, keep in
// mind that the common font dialog uses pre-determined constants for it's 
// controls.




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: A structure to hold attributes for one glpyh. The left, right, etc.
//       values are texture coordinate offsets into the resulting texture image
//       (which ends up in the .tga file). The offset, width, etc. values are
//       spacing information, used when rendering the font.
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom;
    SHORT wOffset;
    SHORT wWidth;
    SHORT wAdvance;
};




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
TCHAR        g_strFontName[512];         // Font properties
DWORD        g_dwFontHeight;
DWORD        g_dwFontEffectiveHeight;
DWORD        g_dwFontWeight = 400;       // Default value of 400 = normal weight
BOOL         g_bItalicized  = 0;         // Default value of FALSE = not-italicized

WCHAR        g_dwStartGlyph = 0;         // Range of glyphs to render
WCHAR        g_dwEndGlyph   = 0;
DWORD        g_dwNumGlyphs  = 0;

DWORD        g_dwVersion   = 0x00000004; // Texture file properties
DWORD        g_dwTexWidth  = 64;         // Default texture dimensions
DWORD        g_dwTexHeight = 64;       
DWORD        g_dwTexBPP    = 16;




//-----------------------------------------------------------------------------
// Name: CalcTextureSize()
// Desc: Calculates how big a texture will need to be to hold the glyphs
//       for a given font. Before calling this function, the caller needs to
//       load the font into the DC passed as input here.
//-----------------------------------------------------------------------------
HRESULT CalcTextureSize( HDC hFontDC, WCHAR dwStartGlyph, WCHAR dwEndGlyph, 
                         DWORD* pdwTexWidth, DWORD* pdwTexHeight )
{
    DWORD dwTexWidth  = 64; // Initial (minimum) texture dimensions
    DWORD dwTexHeight = 64;
    DWORD x           =  0; // Initial cursor position is (0,0)
    DWORD y           =  0; 
    
    // Loop through the glyph range to calculate how big the texture should be
    for( WCHAR c = dwStartGlyph; c && c <= dwEndGlyph; c++ )
    {
        WCHAR str[2] = L"x";
        SIZE  size;
        ABC   abc;

        // Get the size needed to render the glyph
        str[0] = c;
        GetTextExtentPoint32W( hFontDC, str, 1, &size );

        // Check if the glpyh would exceed the right edge of the texture
        if( (x+2*size.cx+1) > dwTexWidth )
        {
            // If so, advance the cursor down a line
            x  = 0;
            y += size.cy+1;

            // Now check if we go past the bottom edge of the texture
            if( (y+size.cy+1) > dwTexHeight )
            {
                // If so, grow the texture size by a power of two
                if( dwTexWidth < dwTexHeight )
                    dwTexWidth *= 2;
                else
                    dwTexHeight *= 2;

                // And restart the loop at the first glyph
                x = 0;
                y = 0;
                c = dwStartGlyph;
                str[0] = c;
                GetTextExtentPoint32W( hFontDC, str, 1, &size );
            }
        }

        // Update the cursor from the ABC widths for the letter
        if( FALSE == GetCharABCWidthsW( hFontDC, str[0], str[0], &abc ) )
            x += size.cx + 2;
        else
            x += abc.abcB + 2;
    }

    // Return the result
    (*pdwTexWidth)  = dwTexWidth;
    (*pdwTexHeight) = dwTexHeight;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteTargaFile()
// Desc: Writes 32-bit RGBA data to a .tga file
//-----------------------------------------------------------------------------
HRESULT WriteTargaFile( TCHAR* strFileName, DWORD dwWidth, DWORD dwHeight,
                        DWORD* pRGBAData )
{
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tga;

    // Create the file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
        return E_FAIL;

    // Write the TGA header
    ZeroMemory( &tga, sizeof(tga) );
    tga.IDLength        = 0;
    tga.ImageType       = 2;
    tga.ImageWidth      = (WORD)dwWidth;
    tga.ImageHeight     = (WORD)dwHeight;
    tga.PixelDepth      = 32;
    tga.ImageDescriptor = 0x28;
    fwrite( &tga, sizeof(TargaHeader), 1, file );

    // Write the pixels
    fwrite( pRGBAData, sizeof(DWORD), dwHeight*dwWidth, file );

    // Close the file and return okay
    fclose( file );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteFontInfoFile()
// Desc: Writes the font's glyph info to a file
//-----------------------------------------------------------------------------
HRESULT WriteFontInfoFile( TCHAR* strFileName, GLYPH_ATTR* pGlyphs )
{
    // Create the info file
    FILE* file = fopen( strFileName, "wb" );

    // Write out the file version
    fwrite( &g_dwVersion,    sizeof(DWORD), 1, file ); 

    // Write out the font height
    fwrite( &g_dwFontEffectiveHeight, sizeof(DWORD), 1, file ); 

    // Write out the texture values
    fwrite( &g_dwTexWidth,   sizeof(DWORD), 1, file ); 
    fwrite( &g_dwTexHeight,  sizeof(DWORD), 1, file ); 
    fwrite( &g_dwTexBPP,     sizeof(DWORD), 1, file ); 

    // Write out the glpyh range
    fwrite( &g_dwStartGlyph, sizeof(WCHAR), 1, file ); 
    fwrite( &g_dwEndGlyph,   sizeof(WCHAR), 1, file ); 

    // Write the glyph attributes to the file
    fwrite( &g_dwNumGlyphs, sizeof(DWORD), 1, file ); 
    fwrite( pGlyphs, sizeof(GLYPH_ATTR), g_dwNumGlyphs, file ); 

    // Close the file and return okay
    fclose( file );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateFontFiles()
// Desc: Creates the font and renders all glyphs to a bitmap. Then, the bitmap
//       image is written out to a .tga file, and the glyph spacing info is
//       written to a .abc file.
//-----------------------------------------------------------------------------
HRESULT CreateFontFiles()
{
    // Note: if you want to expand this app to accept more unicode characters, 
    // start by allocating space to hold glyph ranges as here:
    //    GLYPHSET* pGlyphSet = (GLYPHSET*)new BYTE[GetFontUnicodeRanges( hDC, NULL )];
    //    GetFontUnicodeRanges( hDC, pGlyphSet );
    //    delete pGlyphSet;
    // This information will then need to be saved to the font info (.abc) file
    // which will be read and used by code to render the font on an Xbox. (In 
    // other words, if using the XBFont sample code, you will need to modify
    // that code as well.)

    // Allocate space for the glyph attributes
    GLYPH_ATTR* pGlyphs = new GLYPH_ATTR[g_dwNumGlyphs];

    // Create a DC for rendering text
    HDC hDC = CreateCompatibleDC( NULL );

    // Create a font. Note that the the font height is converted to what a form
    // that CreateFont expects. Also note that by specifying ANTIALIASED_QUALITY,
    // we might get an antialiased font, but this is not guaranteed.
    HFONT hFont = CreateFont( -MulDiv( g_dwFontHeight, GetDeviceCaps( hDC, LOGPIXELSY ), 72 ), 
                              0, 0, 0, g_dwFontWeight, g_bItalicized,
                              FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                              CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                              VARIABLE_PITCH, g_strFontName );
    if( NULL==hFont )
        return E_FAIL;

    // Setup the DC for the font
    SetTextColor( hDC, RGB(255,255,255) );
    SetBkColor( hDC, 0x00000000 );
    SetBkMode( hDC, TRANSPARENT );
    SelectObject( hDC, hFont );
    SetTextAlign( hDC, TA_TOP );
    SetMapMode( hDC, MM_TEXT );

    // Determine the texture size
    CalcTextureSize( hDC, g_dwStartGlyph, g_dwEndGlyph,
                          &g_dwTexWidth, &g_dwTexHeight );

    // Recreate the font. Okay, this is weird, but, apparently, calling text
    // functions such as GetTextExtentPoint32() or GetCharABCWidths() before
    // creating a DIB section (the bitmap below) breaks antialiasing of the
    // font. The CalcTextureSize() function made some of these calls, so we
    // now get around the problem by re-creating the font.
    DeleteObject( hFont );
    hFont = CreateFont( -MulDiv( g_dwFontHeight, GetDeviceCaps( hDC, LOGPIXELSY ), 72 ), 
                    0, 0, 0, g_dwFontWeight, g_bItalicized,
                    FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                    CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                    VARIABLE_PITCH, g_strFontName );
    if( NULL==hFont )
        return E_FAIL;
    SelectObject( hDC, hFont );

    // Prepare to create a bitmap
    DWORD*     pBitmapBits;
    BITMAPINFO bmi;
    ZeroMemory( &bmi.bmiHeader, sizeof(BITMAPINFOHEADER) );
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       =  (int)g_dwTexWidth;
    bmi.bmiHeader.biHeight      = -(int)g_dwTexHeight;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biBitCount    = 32;

    // Create a bitmap for the font
    HBITMAP hbmBitmap = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS,
                                          (VOID**)&pBitmapBits, NULL, 0 );
    SelectObject( hDC, hbmBitmap );

    // Get the effective font height
    WCHAR str[2] = L"A";
    SIZE  size;
    GetTextExtentPoint32W( hDC, str, 1, &size );
    g_dwFontEffectiveHeight = size.cy;

    // Loop through all printable character and output them to the bitmap..
    // Meanwhile, keep track of the corresponding tex coords for each character.
    DWORD index = 0;
    DWORD x     = 0;
    DWORD y     = 0;

    for( WCHAR c = g_dwStartGlyph; c && c <= g_dwEndGlyph; c++ )
    {
        str[0] = c;
        GetTextExtentPoint32W( hDC, str, 1, &size );

        if( (DWORD)(x+2*size.cx+1) > g_dwTexWidth )
        {
            x  = 0;
            y += size.cy+1;
        }

        // Get the ABC widths for the letter
        ABC abc;
        if( FALSE == GetCharABCWidthsW( hDC, str[0], str[0], &abc ) )
        {
            abc.abcA = 0;
            abc.abcB = size.cx;
            abc.abcC = 0;
        }

        int w = abc.abcB + 1;
        int h = size.cy + 1;

        // Store the letter attributes
        pGlyphs[index].wOffset  = (short)(abc.abcA);
        pGlyphs[index].wWidth   = (short)(abc.abcB);
        pGlyphs[index].wAdvance = (short)(abc.abcB + abc.abcC);
        pGlyphs[index].left     = (FLOAT)(x+0) / (FLOAT)(g_dwTexWidth-1);
        pGlyphs[index].top      = (FLOAT)(y+0) / (FLOAT)(g_dwTexHeight-1);
        pGlyphs[index].right    = (FLOAT)(x+w) / (FLOAT)(g_dwTexWidth-1);
        pGlyphs[index].bottom   = (FLOAT)(y+h) / (FLOAT)(g_dwTexHeight-1);
        index++;

        // Output the letter
        ExtTextOutW( hDC, x-abc.abcA, y, ETO_OPAQUE, NULL, str, 1, NULL );

        // Advance the cursor to the next position
        x += abc.abcB + 2;
    }

    // Add alpha channel
    for( y=0; y < g_dwTexHeight; y++ )
    {
        for( x=0; x < g_dwTexWidth; x++ )
        {
            DWORD color = 0x00000000;
            DWORD alpha = ( pBitmapBits[g_dwTexWidth*y + x] & 0x000000ff );
            if( alpha > 0 )
                color = (alpha<<24) | 0x00ffffff;
            pBitmapBits[g_dwTexWidth*y + x] = color;
        }
    }

    // Write out the files
    TCHAR strFileName[80];

    // Write out the texture file
    sprintf( strFileName, "%s_%d.tga", g_strFontName, g_dwFontHeight );
    WriteTargaFile( strFileName, g_dwTexWidth, g_dwTexHeight, pBitmapBits );

    // Write the info file
    sprintf( strFileName, "%s_%d.abc", g_strFontName, g_dwFontHeight );
    WriteFontInfoFile( strFileName, pGlyphs );

    // Clean up used objects and return
    DeleteObject( hbmBitmap );
    DeleteDC( hDC );
    DeleteObject( hFont );
    delete pGlyphs;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ChooseFontProc()
// Desc: The window's message handler
//-----------------------------------------------------------------------------
LRESULT WINAPI ChooseFontProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    static TCHAR strStartGlyph[80] = _T("");
    static TCHAR strEndGlyph[80]   = _T("");
    static TCHAR strFontName[80]   = _T("");

    switch( msg )
    {
        case WM_COMMAND:
            // Handle a font selection change
            if( CBN_SELCHANGE == HIWORD(wParam) && IDC_FONT == LOWORD(wParam) )
            {
                LONG lCurSel = SendDlgItemMessage( hWnd, IDC_FONT, CB_GETCURSEL, 0, 0 );
                SendDlgItemMessage( hWnd, IDC_FONT, CB_GETLBTEXT, (WPARAM)lCurSel, (LPARAM)strFontName );

                HDC   hDC   = CreateCompatibleDC( NULL );
                HFONT hFont = CreateFont( 0, 0, 0, 0, FW_DONTCARE,  FALSE,
                                          FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                                          CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                                          VARIABLE_PITCH, strFontName );
                if( hFont )
                {
                    SelectObject( hDC, hFont );

                    // Get the starting and ending glyph range
                    GLYPHSET* pGlyphSet = (GLYPHSET*)new BYTE[GetFontUnicodeRanges( hDC, NULL )];
                    GetFontUnicodeRanges( hDC, pGlyphSet );
                    DWORD dwStartGlyph = pGlyphSet->ranges[0].wcLow;
                    DWORD dwEndGlyph   = dwStartGlyph + (WCHAR)pGlyphSet->ranges[0].cGlyphs;

                    // Update the dialog edit controls
                    _stprintf( strStartGlyph, "%ld", dwStartGlyph );
                    _stprintf( strEndGlyph,   "%ld", dwEndGlyph );
                    SendDlgItemMessage( hWnd, IDC_GLYPHRANGE_START, WM_SETTEXT, 0, (LPARAM)strStartGlyph );
                    SendDlgItemMessage( hWnd, IDC_GLYPHRANGE_END,   WM_SETTEXT, 0, (LPARAM)strEndGlyph );

                    delete pGlyphSet;
                    DeleteObject( hFont );
                }
                DeleteDC( hDC );
            }

            // Handle the dialog's OK button
            if( IDOK == LOWORD(wParam) )
            {
                // Report an error if no font was chosen
                if( 0 == strFontName[0] )
                {
                    MessageBox( hWnd, _T("Please choose a font!"), 
                                      _T("XBFontMaker"), MB_ICONERROR | MB_OK ); 
                    return TRUE;
                }

                // Extract the glyph range
                SendDlgItemMessage( hWnd, IDC_GLYPHRANGE_START, WM_GETTEXT, 80, (LPARAM)strStartGlyph );
                SendDlgItemMessage( hWnd, IDC_GLYPHRANGE_END,   WM_GETTEXT, 80, (LPARAM)strEndGlyph );
                LONG lStartGlyph = atol( strStartGlyph );
                LONG lEndGlyph   = atol( strEndGlyph );

                // Report an error if the glyph range does not make sense
                if( ( lStartGlyph >= lEndGlyph ) || ( lStartGlyph <= 0 ) || ( lEndGlyph > 65535 ) )
                {
                    MessageBox( hWnd, _T("Invalid glyph range! The glyph\n")
                                      _T("range must be 1 and 65535"), 
                                      _T("XBFontMaker"), MB_ICONERROR | MB_OK ); 
                    return TRUE;
                }

                // Globally store the glyph range
                g_dwStartGlyph = (WCHAR)lStartGlyph;
                g_dwEndGlyph   = (WCHAR)lEndGlyph;
                g_dwNumGlyphs  = (DWORD)(g_dwEndGlyph - g_dwStartGlyph + 1);
            }

            break;
    }

    // Return zero to invoke the default font dialog handler
    return 0;
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
int _cdecl main( int argc, CHAR** argv )
{
    // Get the font's properties from a customized ChooseFont dialog
    CHOOSEFONT cf;
    LOGFONT    lf;
    ZeroMemory( &cf, sizeof(cf) );
    cf.lStructSize    = sizeof(cf);
    cf.lpLogFont      = &lf;
    cf.Flags          = CF_ENABLEHOOK | CF_SCREENFONTS | CF_ENABLETEMPLATE;
    cf.hInstance      = GetModuleHandle(NULL);
    cf.lpTemplateName = MAKEINTRESOURCE(IDD_FONTMAKER); // The custom dialog
    cf.lpfnHook       = (LPCFHOOKPROC)ChooseFontProc;   // The custom dlg proc
    if( !ChooseFont( &cf ) )
        return 0;

    // Store font properties globally
    _tcscpy( g_strFontName, cf.lpLogFont->lfFaceName );
    g_dwFontHeight = cf.iPointSize / 10;
    g_dwFontWeight = cf.lpLogFont->lfWeight;
    g_bItalicized  = cf.lpLogFont->lfItalic;

    // Create the texture and the info file for the font
    if( FAILED( CreateFontFiles() ) )
        printf( "ERROR: Could not create font files!\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\Installer.cpp ===
//-----------------------------------------------------------------------------
// File: Installer.cpp
//
// Desc: 
//
// Hist: 04.18.01 - New for CliffG
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBFont.h>
#include <XBUtil.h>
#include "Installer.h"
#include "Resource.h"

static const WCHAR* g_RStrings[] =

{	//    RS_BUILD_NUMBER_FORMAT
    L"Xbox version %hs",

	//    RS_INSERT_UDF    
    L"Your UDF CD-R/W or DVD Media\n"
	L"should have been placed in the drive\n"
	L"prior to running the Installer\n"
	L"\nPlease press any button to start copying\n",

	//    RS_NOMEDIA,
    L"The CDR/RW or DVD-R that you've inserted\n" 
    L"cannot be accessed, please reinsert or\n" 
    L"check the disc you've inserted and try again\n"
	L"Press any gamepad button to reboot.",

	//	  RS_CANT_CREATE_DIR
    L"Cannot create directory\n"
	L"Please Recover Machine and try again\n"
    L"Press any gamepad button to reboot.",

	//    RS_COPYING    
    L"Copying files to the hard disk...\n"
    L"(please wait until drive opens)\n",

	//    RS_DONECOPYING
    L"Done copying files. Remove media and press\n"
    L"any gamepad button to reboot.",

    //    RS_ERRORCOPY
    L"An error has occurred during file copy\n" 
    L"Either the source media is corrupt\n"
	L"It is not a UDFS filesystem\n"
    L"or hard disk is full\n"
	L"Press any button on the gamepad to reboot",

};

enum RECOVSTR_INDEX
{
    RS_BUILD_NUMBER_FORMAT = 0,
    
    RS_INSERT_UDF,
    
    RS_NOMEDIA,

	RS_CANT_CREATE_DIR,
    
    RS_COPYING,
    
    RS_DONECOPYING,
    
    RS_ERRORCOPY,
    
    RS_MAX
};


//-----------------------------------------------------------------------------
// Global rendering variables
//-----------------------------------------------------------------------------
LPDIRECT3D8        g_pD3D               = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice         = NULL;
LPDIRECT3DTEXTURE8 g_pBackgroundTexture = NULL;
CXBPackedResource  g_xprResource;
CXBFont            g_Font;

// Global instance of gamepad devices
HANDLE g_hGamepads[4];

//-----------------------------------------------------------------------------
// Name: InitGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT InitGamepads()
{
    XDEVICE_PREALLOC_TYPE deviceTypes[] =
    {
        { XDEVICE_TYPE_GAMEPAD,     4 },
        { XDEVICE_TYPE_MEMORY_UNIT, 2 }
    };

    // Initialize core peripheral port support
    XInitDevices( sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE),
                  deviceTypes );

    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_hGamepads[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                         XDEVICE_NO_SLOT, NULL );
        }
        else
            g_hGamepads[i] = NULL;
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object, which is used to create the D3DDevice.
    g_pD3D = Direct3DCreate8( D3D_SDK_VERSION );

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    
    // Set fullscreen 640x480x32 mode
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;

    // Create one backbuffer and a zbuffer
    d3dpp.BackBufferCount        = 1;


    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    // Set up how the backbuffer is "presented" to the frontbuffer each frame
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device. Hardware vertex processing is specified 
    // since all vertex processing takes place on Xbox hardware.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // Create the font
    if( FAILED( g_Font.Create( g_pd3dDevice, "Font.xpr" ) ) )
    {
        OutputDebugString( _T("ERROR: Could not find Font.xpr\n") );
        return E_FAIL;
    }

    // Create the resource to get the background texture
    if( FAILED( g_xprResource.Create( g_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
    {
        OutputDebugString( _T("ERROR: Could not find Resource.xpr\n") );
        return E_FAIL;
    }

    g_pBackgroundTexture = g_xprResource.GetTexture( resource_Background_OFFSET );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawMessage()
// Desc: 
//-----------------------------------------------------------------------------
VOID DrawMessage( const WCHAR* str, VOID*, int )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        g_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  v[0].tu =   0; v[0].tv =   0;
        v[1].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  v[1].tu = 640; v[1].tv =   0;
        v[2].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  v[2].tu =   0; v[2].tv = 480;
        v[3].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  v[3].tu = 640; v[3].tv = 480;
        g_pVB->Unlock();
    }

    // Set states
    g_pd3dDevice->SetTexture( 0, g_pBackgroundTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetStreamSource( 0, g_pVB, 6*sizeof(FLOAT) );

    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title
    g_Font.DrawText( 135.0f, 80.0f, 0xffffffff, L"Installer" );

    // Show text
    FLOAT fXStart = 115.0f;
    FLOAT fYStart = 135.0f;

    g_Font.DrawText( fXStart, fYStart, 0xffffffff, str );

    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}

//-----------------------------------------------------------------------------
// Name: GamepadButtonPressed()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
BOOL GamepadButtonPressed()
{
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        if( dwRemovals & (1<<i) ) 
        {
            XInputClose( g_hGamepads[i] );
            g_hGamepads[i] = NULL;
        }

        // Handle inserted devices
        if( dwInsertions & (1<<i) ) 
        {
            g_hGamepads[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                         XDEVICE_NO_SLOT, NULL );
        }

        // If we have a valid device, poll it's state and track button changes
        if( g_hGamepads[i] )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( g_hGamepads[i], &xiState );

            // Check for a button down
            if( xiState.Gamepad.wButtons ) 
			{
				// Return true once the buttons are let up
				while(TRUE)
				{
		            XInputGetState( g_hGamepads[i], &xiState );
					if( 0 == xiState.Gamepad.wButtons )
						return TRUE;
				}
			}

            // Check for an analog button down
            for( DWORD i=0; i<8; i++ )
			{
				if( xiState.Gamepad.bAnalogButtons[i] > XINPUT_ANALOGBUTTONTHRESHOLD )
				{
					// Return true once the buttons are let up
					while(TRUE)
					{
						XInputGetState( g_hGamepads[i], &xiState );
						if( xiState.Gamepad.bAnalogButtons[i] <= XINPUT_ANALOGBUTTONTHRESHOLD )
							return TRUE;
					}
				}
			}
        }
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D & Backround Image
    if( FAILED( InitD3D() ) )
        return;
    
    // Initialize gamepads
    if( FAILED( InitGamepads() ) )
        return;

    // Give the main partition a drive letter C:
    if( !NT_SUCCESS( IoCreateSymbolicLink( (POBJECT_STRING)&CDrive, 
                                           (POBJECT_STRING)&HdPartition1 ) ) )
    {
        OutputDebugString( _T("ERROR: Could not map a drive letter to partition1\n") );
        return;
    }

    // Give the DVD Drive a drive letter V:
    if( !NT_SUCCESS( IoCreateSymbolicLink( (POBJECT_STRING)&VDrive, 
                                           (POBJECT_STRING)&DVDDevice ) ) )
    {
        OutputDebugString( _T("ERROR: Could not map a drive letter to the DVD Drive\n") );
        return;
    }

    // Put up the initial screen
    DrawMessage( g_RStrings[RS_INSERT_UDF], NULL, 5 );


	//We cannot eject a DVD as the filesystem will have lost it's mounted drive...
    //EjectDVD();  

    // Wait for a button to be pressed
    while( FALSE == GamepadButtonPressed() );

	//Create the subdirectory

	if ( !CreateDirectory( (LPCSTR)"C:\\DEVKIT\\SAMPLES\\INSTALLED" ,NULL) )
	{
		OutputDebugString("Could not CreateDirectory \n");
		//Need to output a message that we didn't work
		DrawMessage( g_RStrings[RS_CANT_CREATE_DIR], NULL, 5 );
	    // Wait for a button to be pressed
		while( FALSE == GamepadButtonPressed() );
		//reboot
		XLaunchNewImage( NULL, NULL );
	}

    // Put up a screen saying we are copying
    DrawMessage( g_RStrings[RS_COPYING], NULL, 5 );

    // Now do the file copy from the DVD to the HD
    if( !CopyFiles( OTEXT("V:\\*"), OTEXT("C:\\DEVKIT\\SAMPLES\\INSTALLED\\"), TRUE ) )
    {
        OutputDebugString( _T("Could not copy files to the hard disk \n") );
		//Need to output a message that we didn't work and reboot!
		DrawMessage( g_RStrings[RS_ERRORCOPY], NULL, 5 );
	    // Wait for a button to be pressed
		while( FALSE == GamepadButtonPressed() );

		// We should delete the directory we created since this didn't work

		if ( !RemoveDirectory( (LPCSTR)"C:\\DEVKIT\\SAMPLES\\INSTALLED") )
		{
			// We should never get here since we just created this directory above!

			OutputDebugString("Could not CreateDirectory \n");
			//Need to output a message that we didn't work
			DrawMessage( g_RStrings[RS_CANT_CREATE_DIR], NULL, 5 );
			// Wait for a button to be pressed
			while( FALSE == GamepadButtonPressed() );
			//reboot
			XLaunchNewImage( NULL, NULL );
		}
		//reboot
		XLaunchNewImage( NULL, NULL );
    }

    // Put up a screen saying we are done copying
    DrawMessage( g_RStrings[RS_DONECOPYING], NULL, 5 );

    EjectDVD();

    // Wait for a button to be pressed
    while( FALSE == GamepadButtonPressed() );

    // Reboot the machine
    XLaunchNewImage( NULL, NULL );
}

//-----------------------------------------------------------------------------
// Name: EjectDVD()
// Desc: 
//-----------------------------------------------------------------------------
VOID EjectDVD()
{
    HANDLE hDevice;
    hDevice = CreateFile(OTEXT("CdRom0:"),
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        SCSI_PASS_THROUGH_DIRECT PassThrough;
        DWORD cbBytes;
        PCDB Cdb;
        SENSE_DATA SenseData;

        RtlZeroMemory(&PassThrough, sizeof(PassThrough));

        PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
        PassThrough.DataIn = SCSI_IOCTL_DATA_IN;

        Cdb = (PCDB)&PassThrough.Cdb;

        Cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
        Cdb->START_STOP.LoadEject = 1;
        Cdb->START_STOP.Start = 0;

        DeviceIoControl(hDevice,
                        IOCTL_SCSI_PASS_THROUGH_DIRECT,
                        &PassThrough,
                        sizeof(PassThrough),
                        &SenseData,
                        sizeof(SenseData),
                        &cbBytes,
                        NULL);

        CloseHandle(hDevice);
    }
    else
    {
        OutputDebugString( _T("EjectDVD() could not open DVD device\n") );
    }
}

//-----------------------------------------------------------------------------
// Name: CopyFiles()
// Desc: Copies files from a source path to a destination path. The source path
//       is a filter that can be passed to FindFirstFile() and is currently
//       required to end in "<\\*>".  The destination path should end with a 
//       trailing backslash ('\')
//-----------------------------------------------------------------------------
BOOL CopyFiles( IN PCOSTR pcszSrcPath, IN PCOSTR pcszDestPath,
                IN BOOL fRootDir )
{
    WIN32_FIND_DATA wfd;
    BOOL bRet = FALSE;
    int nSrcLen = ocslen(pcszSrcPath);
    int nDestLen = ocslen(pcszDestPath);
    HANDLE hFind = FindFirstFile(pcszSrcPath, &wfd);
    
    if (INVALID_HANDLE_VALUE != hFind)
    {
        OCHAR szSrcFile[MAX_PATH], szDestFile[MAX_PATH];
        ocscpy(szSrcFile, pcszSrcPath);
        ocscpy(szDestFile, pcszDestPath);

        do
        {
            BOOL fCopyThis = TRUE;
            
            if (fRootDir)
            {
                int i;
                for (i = 0; i < ARRAYSIZE(g_RootDirExceptions); i++)
                {
                    if (0 == _ocsicmp(wfd.cFileName, g_RootDirExceptions[i]))
                    {
                        fCopyThis = FALSE;
                        break;
                    }
                }
            }

            if (!fCopyThis)
            {
                continue;
            }
            
            lstrcpynO(&(szSrcFile[nSrcLen - 1]),
                      wfd.cFileName,
                      ARRAYSIZE(szSrcFile) - (nSrcLen - 1));
            lstrcpynO(&(szDestFile[nDestLen]),
                      wfd.cFileName,
                      ARRAYSIZE(szDestFile) - nDestLen);
                     
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                int nFileLen = ocslen(wfd.cFileName);
                
                bRet = CreateDirectory(szDestFile, NULL);

                if (!bRet)
                {
                    break;
                }

                lstrcpynO(&(szSrcFile[nSrcLen + nFileLen - 1]),
                          OTEXT("\\*"),
                          ARRAYSIZE(szSrcFile) - (nSrcLen + nFileLen - 1));

                lstrcpynO(&(szDestFile[nDestLen + nFileLen]),
                          OTEXT("\\"),
                          ARRAYSIZE(szDestFile) - (nDestLen + nFileLen));

                bRet = CopyFiles(szSrcFile, szDestFile, FALSE);

                if (!bRet)
                {
                    break;
                }
            }
            else
            {
                bRet = CopyFile(szSrcFile, szDestFile, FALSE);

                //
                // Files coming off of CD/DVD end up read-only, so clear
                // all of the attributes.. (otherwise dosnet won't work)
                //
                
                SetFileAttributes(szDestFile, FILE_ATTRIBUTE_NORMAL);

                if (!bRet)
                {
                    break;
                }

                DrawMessage( g_RStrings[RS_COPYING],
                            NULL,
                            5 + min((++g_FilesCopied * 90) / APPROX_FILE_COUNT, 90));
            }
            
        } while (FindNextFile(hFind, &wfd));
        
        FindClose(hFind);
    }
    else if (ERROR_FILE_NOT_FOUND == GetLastError())
    {
        OutputDebugString( _T("FindFirstFile error FILE_NOT_FOUND\n") );

        bRet = TRUE;
    }
    

    else if ( ERROR_INVALID_PARAMETER == GetLastError())
    {
        OutputDebugString( _T("FindFirstFile error INVALID_PARAMETER\n") );

		//We need to bail here.  Incorrect Media or an Unmounted Filesystem

//BUG BUG RS_ERRORCOPY
		DrawMessage( g_RStrings[RS_ERRORCOPY], NULL, 5 );
	    // Wait for a button to be pressed
		while( FALSE == GamepadButtonPressed() );
		//reboot
		XLaunchNewImage( NULL, NULL );
//BUG BUG OVER



        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\FillRate\utils.cpp ===
//-----------------------------------------------------------------------------
// FILE: UTILS.CPP
//
// Desc: Utility functions used by FillRate App
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>

#include "bitfont.h"
#include "utils.h"




//----------------------------------------------------------------------------
// CScrText font class
BitFont g_bitfont;




//----------------------------------------------------------------------------
// Name: GetTextureModeStr
//
// Desc: Stringtize PS_TEXTUREMODES_*
//----------------------------------------------------------------------------
LPCSTR GetTextureModeStr( DWORD TextureMode )
{
    #undef XTAG
    #define XTAG( _tag ) { PS_TEXTUREMODES##_tag, "PS_TM" #_tag }
    
    static const struct
    {
        DWORD texturemode;
        const char *szD3DMSStr;
    } rgszTMStr[] =
    {
        XTAG( _NONE ),           XTAG( _PROJECT2D ),      XTAG( _PROJECT3D ),
        XTAG( _CUBEMAP ),        XTAG( _PASSTHRU ),       XTAG( _CLIPPLANE ),
        XTAG( _BUMPENVMAP ),     XTAG( _BUMPENVMAP_LUM ), XTAG( _BRDF ),
        XTAG( _DOT_ST ),         XTAG( _DOT_ZW ),         XTAG( _DOT_RFLCT_DIFF ),
        XTAG( _DOT_RFLCT_SPEC ), XTAG( _DOT_STR_3D ),     XTAG( _DOT_STR_CUBE ),
        XTAG( _DPNDNT_AR ),      XTAG( _DPNDNT_GB ),      XTAG( _DOTPRODUCT ),
        XTAG( _DOT_RFLCT_SPEC_CONST ),
    };

    static const int cFmts = sizeof( rgszTMStr ) / sizeof( rgszTMStr[0] );

    for( int ifmt = 0; ifmt < cFmts; ifmt++ )
    {
        if( rgszTMStr[ifmt].texturemode == TextureMode )
            return rgszTMStr[ifmt].szD3DMSStr;
    }

    return rgszTMStr[cFmts - 1].szD3DMSStr;
}




//----------------------------------------------------------------------------
// Name: GetMultiSampleStr
//
// Desc: Stringtize D3DMS_*
//----------------------------------------------------------------------------
LPCSTR GetMultiSampleStr( DWORD mstype )
{
    #undef XTAG
    #define XTAG( _tag ) { _tag, #_tag }
    static const struct
    {
        DWORD mstype;
        const char *szD3DMSStr;
    } rgszMSStr[] =
    {
        XTAG( D3DMS_NONE ), 
        XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX ), 
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR ), 
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN ),
        XTAG( D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_PREFILTER_FORMAT_DEFAULT ),
        XTAG( D3DMS_PREFILTER_FORMAT_X1R5G5B5 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_R5G6B5 ),
        XTAG( D3DMS_PREFILTER_FORMAT_X8R8G8B8 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_A8R8G8B8 ),
    };

    static const int cFmts = sizeof( rgszMSStr ) / sizeof( rgszMSStr[0] );

    for( int ifmt = 0; ifmt < cFmts; ifmt++ )
    {
        if( rgszMSStr[ifmt].mstype == mstype )
            return rgszMSStr[ifmt].szD3DMSStr;
    }

    return rgszMSStr[cFmts - 1].szD3DMSStr;
}




//----------------------------------------------------------------------------
// Name: GetD3DCMPStr
//
// Desc: Stringtize D3DCMP_*
//----------------------------------------------------------------------------
LPCSTR GetD3DCMPStr( D3DCMPFUNC d3dcmpfunc )
{
    static const char *rgszD3DCmp[] =
    {
        "D3DCMP_NEVER",       
        "D3DCMP_LESS",        
        "D3DCMP_EQUAL",       
        "D3DCMP_LESSEQUAL",   
        "D3DCMP_GREATER",     
        "D3DCMP_NOTEQUAL",    
        "D3DCMP_GREATEREQUAL",
        "D3DCMP_ALWAYS",      
        "??",
    };

    DWORD id3dcmp = min( d3dcmpfunc & 0xf, 
                         sizeof( rgszD3DCmp ) / sizeof( rgszD3DCmp[0] ) );
    return rgszD3DCmp[id3dcmp];
}




//----------------------------------------------------------------------------
// Name: GetD3dFormatStr
//
// Desc: Stringtize D3DFMT_*
//----------------------------------------------------------------------------
LPCSTR GetD3DFormatStr( D3DFORMAT d3dformat )
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        D3DFORMAT d3dformat;
        const char *szD3DFormat;
    } rgszD3DFmt[] =
    {
        XTAG( D3DFMT_A8R8G8B8 ), XTAG( D3DFMT_X8R8G8B8 ), 
        XTAG( D3DFMT_R5G6B5 ), XTAG( D3DFMT_R6G5B5 ), 
        XTAG( D3DFMT_X1R5G5B5 ), XTAG( D3DFMT_A1R5G5B5 ),
        XTAG( D3DFMT_A4R4G4B4 ), XTAG( D3DFMT_A8 ), 
        XTAG( D3DFMT_A8B8G8R8 ), XTAG( D3DFMT_B8G8R8A8 ), 
        XTAG( D3DFMT_R4G4B4A4 ), XTAG( D3DFMT_R5G5B5A1 ),
        XTAG( D3DFMT_R8G8B8A8 ), XTAG( D3DFMT_R8B8 ), 
        XTAG( D3DFMT_G8B8 ), XTAG( D3DFMT_P8 ), 
        XTAG( D3DFMT_L8 ), XTAG( D3DFMT_A8L8 ),
        XTAG( D3DFMT_AL8 ), XTAG( D3DFMT_L16 ), 
        XTAG( D3DFMT_V8U8 ), XTAG( D3DFMT_L6V5U5 ), 
        XTAG( D3DFMT_X8L8V8U8 ), XTAG( D3DFMT_Q8W8V8U8 ),
        XTAG( D3DFMT_V16U16 ), XTAG( D3DFMT_D16_LOCKABLE ), 
        XTAG( D3DFMT_D16 ), XTAG( D3DFMT_D24S8 ), 
        XTAG( D3DFMT_F16 ), XTAG( D3DFMT_F24S8 ),
        XTAG( D3DFMT_UYVY ), XTAG( D3DFMT_YUY2 ), 
        XTAG( D3DFMT_DXT1 ), XTAG( D3DFMT_DXT2 ), 
        XTAG( D3DFMT_DXT3 ), XTAG( D3DFMT_DXT4 ),
        XTAG( D3DFMT_DXT5 ), XTAG( D3DFMT_LIN_A1R5G5B5 ), 
        XTAG( D3DFMT_LIN_A4R4G4B4 ), XTAG( D3DFMT_LIN_A8 ), 
        XTAG( D3DFMT_LIN_A8B8G8R8 ), XTAG( D3DFMT_LIN_A8R8G8B8 ), 
        XTAG( D3DFMT_LIN_B8G8R8A8 ), XTAG( D3DFMT_LIN_G8B8 ), 
        XTAG( D3DFMT_LIN_R4G4B4A4 ), XTAG( D3DFMT_LIN_R5G5B5A1 ), 
        XTAG( D3DFMT_LIN_R5G6B5 ), XTAG( D3DFMT_LIN_R6G5B5 ),
        XTAG( D3DFMT_LIN_R8B8 ), XTAG( D3DFMT_LIN_R8G8B8A8 ), 
        XTAG( D3DFMT_LIN_X1R5G5B5 ), XTAG( D3DFMT_LIN_X8R8G8B8 ), 
        XTAG( D3DFMT_LIN_A8L8 ), XTAG( D3DFMT_LIN_AL8 ), 
        XTAG( D3DFMT_LIN_L16 ), XTAG( D3DFMT_LIN_L8 ), 
        XTAG( D3DFMT_LIN_D24S8 ), XTAG( D3DFMT_LIN_F24S8 ), 
        XTAG( D3DFMT_LIN_D16 ), XTAG( D3DFMT_LIN_F16 ),
        XTAG( D3DFMT_UNKNOWN ),
    };

    static const int cFmts = sizeof( rgszD3DFmt ) / sizeof( rgszD3DFmt[0] );

    for( int ifmt = 0; ifmt < cFmts; ifmt++ )
    {
        if( rgszD3DFmt[ifmt].d3dformat == d3dformat )
            return rgszD3DFmt[ifmt].szD3DFormat;
    }

    return rgszD3DFmt[cFmts - 1].szD3DFormat;
}




//----------------------------------------------------------------------------
// Name: IsLinearFormat
//
// Desc: Check whether specified format is linear
//----------------------------------------------------------------------------
bool IsLinearFormat( DWORD Format )
{
    switch( Format )
    {
        case D3DFMT_LIN_A1R5G5B5:
        case D3DFMT_LIN_A4R4G4B4:
        case D3DFMT_LIN_A8:
        case D3DFMT_LIN_A8B8G8R8:
        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_B8G8R8A8:
        case D3DFMT_LIN_G8B8:
        case D3DFMT_LIN_R4G4B4A4:
        case D3DFMT_LIN_R5G5B5A1:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_R6G5B5:
        case D3DFMT_LIN_R8B8:
        case D3DFMT_LIN_R8G8B8A8:
        case D3DFMT_LIN_X1R5G5B5:
        case D3DFMT_LIN_X8R8G8B8:
    
        case D3DFMT_LIN_A8L8:
        case D3DFMT_LIN_AL8:
        case D3DFMT_LIN_L16:
        case D3DFMT_LIN_L8:
    
        case D3DFMT_LIN_D24S8:
        case D3DFMT_LIN_F24S8:
        case D3DFMT_LIN_D16:
        case D3DFMT_LIN_F16:
            return true;
    }

    return false;
}




//----------------------------------------------------------------------------
// Name: BitsPerPixelOfD3DFORMAT
//
// Desc:nReturn number of bits per pixel/texel.
//----------------------------------------------------------------------------
DWORD BitsPerPixelOfD3DFORMAT( DWORD Format )
{
    DWORD retval = 0;

    switch( Format )
    {
        case D3DFMT_A8R8G8B8:   // Q8W8V8U8
        case D3DFMT_X8R8G8B8:   // X8L8V8U8
        case D3DFMT_A8B8G8R8:
        case D3DFMT_B8G8R8A8:
        case D3DFMT_R8G8B8A8:
        case D3DFMT_V16U16:
        case D3DFMT_D24S8:
        case D3DFMT_F24S8:
        case D3DFMT_UYVY:
        case D3DFMT_YUY2:
        case D3DFMT_LIN_A8B8G8R8:
        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_B8G8R8A8:
        case D3DFMT_LIN_R8G8B8A8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_D24S8:
        case D3DFMT_LIN_F24S8:
            retval = 32;
            break;
    
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_R4G4B4A4:
        case D3DFMT_R5G5B5A1:
        case D3DFMT_R8B8:
        case D3DFMT_G8B8:   // V8U8
        case D3DFMT_A8L8:
        case D3DFMT_L16:
        case D3DFMT_L6V5U5:
        case D3DFMT_D16_LOCKABLE:  // D16
        case D3DFMT_F16:
        case D3DFMT_LIN_A1R5G5B5:
        case D3DFMT_LIN_A4R4G4B4:
        case D3DFMT_LIN_G8B8:
        case D3DFMT_LIN_R4G4B4A4:
        case D3DFMT_LIN_R5G5B5A1:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_R6G5B5:
        case D3DFMT_LIN_R8B8:
        case D3DFMT_LIN_X1R5G5B5:
        case D3DFMT_LIN_A8L8:
        case D3DFMT_LIN_L16:
        case D3DFMT_LIN_D16:
        case D3DFMT_LIN_F16:
            retval = 16;
            break;
    
        case D3DFMT_A8:
        case D3DFMT_P8:
        case D3DFMT_L8:
        case D3DFMT_AL8:
        case D3DFMT_LIN_A8:
        case D3DFMT_LIN_AL8:
        case D3DFMT_LIN_L8:
            retval = 8;
            break;
    
        case D3DFMT_DXT1:
            retval = 4;
            break;
    
        case D3DFMT_DXT2: // DXT3
        case D3DFMT_DXT4: // DXT5
            retval = 8;
            break;
    
        default:
            CheckHR(E_FAIL);
            retval = 0;
            break;
    }

    return retval;
}




//----------------------------------------------------------------------------
// Name: DisplayError
//
// Desc: Display d3d error then break into debugger
//----------------------------------------------------------------------------
void DisplayError( const char *szCall, HRESULT hr )
{
    char szErr[512];

    if FAILED( hr )
    {
        UINT cch = _snprintf( szErr, sizeof( szErr ), 
                              "FATAL: %s failed 0x%08lX: ", szCall, hr );
		szErr[511] = '\0';

        D3DXGetErrorStringA( hr, &szErr[cch], sizeof( szErr ) - cch - 1 );
    }
    else
    {
        lstrcpynA( szErr, szCall, sizeof( szErr ) - 1 );
    }

    lstrcatA( szErr, "\n" );
    OutputDebugStringA( szErr );

    _asm int 3;
}




//----------------------------------------------------------------------------
// Name: dprintf
//
// Desc: Formatted debug Output
//----------------------------------------------------------------------------
void _cdecl dprintf( LPCSTR lpFmt, ... )
{
    va_list arglist;
    char lpOutput[256];

    va_start( arglist, lpFmt );
    _vsnprintf( lpOutput, sizeof( lpOutput ), lpFmt, arglist );
    va_end( arglist );

    OutputDebugStringA( lpOutput );
}




//----------------------------------------------------------------------------
// Name: drawtext
//
// Desc: Draw CScrText text buffer to front buffer
//----------------------------------------------------------------------------
void CScrText::drawtext( bool fDebug )
{
    IDirect3DSurface8 *pFrontBuffer = NULL;

    D3DDevice_GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer );
    if( pFrontBuffer )
    {
        // render results to the frontbuffer
        DWORD dx = 40;
        DWORD dy = 20;
        DWORD dwHeight;

        g_bitfont.GetTextStringLength( NULL, &dwHeight, NULL );
        dwHeight += 2;

        for( int iBuf = 0; iBuf < m_iLine; iBuf++ )
        {
            if( fDebug )
                dprintf( "%s\n", m_rgText[iBuf] );

            if( m_rgText[iBuf][0] )
                g_bitfont.DrawText( pFrontBuffer, m_rgText[iBuf], dx, dy, 
                                    0, 0xff9f9f9f, 0 );

            dy += dwHeight;
        }

        RELEASE( pFrontBuffer );
    }
}




//----------------------------------------------------------------------------
// Name: printf
//
// Desc: Add a string to the CScrText string buffer
//----------------------------------------------------------------------------
void _cdecl CScrText::printf( LPCSTR lpFmt, ... )
{
    va_list arglist;

    va_start( arglist, lpFmt );
    _vsnprintf( m_rgText[m_iLine], LINE_WIDTH, lpFmt, arglist );
    va_end( arglist );

	//7 sep 2001: prevent buffer overrun when printing text on the last line
	m_rgText[m_iLine][LINE_WIDTH - 1] = '\0'; 

    m_iLine = ( m_iLine + 1 ) % NUM_LINES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\Installer.h ===
//-----------------------------------------------------------------------------
// File: Installer.h
//
// Desc: 
//
// Hist: 04.18.01 - New for CliffG
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "scsi.h"
#include "ntddscsi.h"

typedef struct _LSA_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;
 
typedef LSA_STRING STRING, *PSTRING ;

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)     // winnt

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;


typedef STRING OBJECT_STRING;
typedef CSTRING COBJECT_STRING;
typedef PSTRING POBJECT_STRING;
typedef PCSTRING PCOBJECT_STRING;
typedef CHAR OCHAR;
typedef CHAR* POCHAR;
typedef PSTR POSTR;
typedef PCSTR PCOSTR;

typedef struct _OBJECT_ATTRIBUTES {
    HANDLE RootDirectory;
    POBJECT_STRING ObjectName;
    ULONG Attributes;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

// 
// NTSTATUS
//
 
typedef LONG NTSTATUS;

typedef NTSTATUS *PNTSTATUS;
 
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
 
//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//
 
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
 
// begin_ntddk begin_wdm begin_nthal
//
// Define the base asynchronous I/O argument types
//
 
typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };
 
    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef char OCHAR;
#define __OTEXT(quote) quote
#define OTEXT(quote) __OTEXT(quote)

extern "C"
{
NTSYSCALLAPI
NTSTATUS
NTAPI
IoCreateSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName,
    IN POBJECT_STRING DeviceName
    );
}

#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#define OBJ_CASE_INSENSITIVE    0x00000040L

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    }

extern "C"
{
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess, // SYNCHRONIZE | FILE_READ_DATA
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess, // 0
    IN ULONG OpenOptions // FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING
    );
}

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010

//
// Define values for pass-through DataIn field.
//

#define SCSI_IOCTL_DATA_OUT          0
#define SCSI_IOCTL_DATA_IN           1
#define SCSI_IOCTL_DATA_UNSPECIFIED  2

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

#define FILE_DEVICE_CONTROLLER          0x00000004

#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define ocslen      lstrlenA
#define ocscpy      lstrcpyA
#define _ocsicmp _stricmp
#define lstrcpynO lstrcpynA

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
ULONG g_FilesCopied = 0;

#define APPROX_FILE_COUNT   1350

const POSTR g_RootDirExceptions[] =
{
    OTEXT("default.xbe"),
    OTEXT("RECMEDIA"),
    OTEXT("XDASH")
};



//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------

COBJECT_STRING CDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\C:") );
COBJECT_STRING HdPartition1 =      CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1") );
COBJECT_STRING VDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\V:") );
COBJECT_STRING DVDDevice =         CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Cdrom0") );

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 20






//-----------------------------------------------------------------------------
// Name: EjectDVD()
// Desc: 
//-----------------------------------------------------------------------------
VOID EjectDVD();



//-----------------------------------------------------------------------------
// Name: CopyFiles()
// Desc: Copies files from a source path to a destination path. The source path
//       is a filter that can be passed to FindFirstFile() and is currently
//       required to end in "<\\*>".  The destination path should end with a 
//       trailing backslash ('\')
//-----------------------------------------------------------------------------
BOOL CopyFiles( IN PCOSTR pcszSrcPath, IN PCOSTR pcszDestPath,
                IN BOOL fRootDir );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\Resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Background_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\ntddscsi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddscsi.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the SCSI port adapters.

Author:

    Jeff Havens

Revision History:

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddscsi.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddscsi.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

DEFINE_GUID(ScsiRawInterfaceGuid, 0x53f56309L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(WmiScsiAddressGuid,   0x53f5630fL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
#endif

#ifndef _NTDDSCSIH_
#define _NTDDSCSIH_

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER

#define DD_SCSI_DEVICE_NAME "\\Device\\ScsiPort"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_SCSI_PASS_THROUGH         CTL_CODE(IOCTL_SCSI_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_MINIPORT             CTL_CODE(IOCTL_SCSI_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_INQUIRY_DATA     CTL_CODE(IOCTL_SCSI_BASE, 0x0403, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_CAPABILITIES     CTL_CODE(IOCTL_SCSI_BASE, 0x0404, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_ADDRESS          CTL_CODE(IOCTL_SCSI_BASE, 0x0406, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_RESCAN_BUS           CTL_CODE(IOCTL_SCSI_BASE, 0x0407, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_DUMP_POINTERS    CTL_CODE(IOCTL_SCSI_BASE, 0x0408, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_FREE_DUMP_POINTERS   CTL_CODE(IOCTL_SCSI_BASE, 0x0409, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Define the SCSI pass through structure.
//

typedef struct _SCSI_PASS_THROUGH {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG_PTR DataBufferOffset;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH, *PSCSI_PASS_THROUGH;

//
// Define the SCSI pass through direct structure.
//

typedef struct _SCSI_PASS_THROUGH_DIRECT {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT;

//
// Define SCSI information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_BUS_DATA {
    UCHAR NumberOfLogicalUnits;
    UCHAR InitiatorBusId;
    ULONG InquiryDataOffset;
}SCSI_BUS_DATA, *PSCSI_BUS_DATA;

//
// Define SCSI adapter bus information structure..
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_ADAPTER_BUS_INFO {
    UCHAR NumberOfBuses;
    SCSI_BUS_DATA BusData[1];
} SCSI_ADAPTER_BUS_INFO, *PSCSI_ADAPTER_BUS_INFO;

//
// Define SCSI adapter bus information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_INQUIRY_DATA {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    ULONG InquiryDataLength;
    ULONG NextInquiryDataOffset;
    UCHAR InquiryData[1];
}SCSI_INQUIRY_DATA, *PSCSI_INQUIRY_DATA;

//
// Define header for I/O control SRB.
//

typedef struct _SRB_IO_CONTROL {
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

//
// SCSI port driver capabilities structure.
//

typedef struct _IO_SCSI_CAPABILITIES {

    //
    // Length of this structure
    //

    ULONG Length;

    //
    // Maximum transfer size in single SRB
    //

    ULONG MaximumTransferLength;

    //
    // Maximum number of physical pages per data buffer
    //

    ULONG MaximumPhysicalPages;

    //
    // Async calls from port to class
    //

    ULONG SupportedAsynchronousEvents;

    //
    // Alignment mask for data transfers.
    //

    ULONG AlignmentMask;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Host adapter scans down for bios devices.
    //

    BOOLEAN AdapterScansDown;

    //
    // The host adapter uses programmed I/O.
    //

    BOOLEAN AdapterUsesPio;

} IO_SCSI_CAPABILITIES, *PIO_SCSI_CAPABILITIES;

typedef struct _SCSI_ADDRESS {
    ULONG Length;
    UCHAR PortNumber;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
}SCSI_ADDRESS, *PSCSI_ADDRESS;

//
// Define structure for returning crash dump pointers.
//

struct _ADAPTER_OBJECT;

typedef struct _DUMP_POINTERS {
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID DumpData;
    PVOID CommonBufferVa;
    LARGE_INTEGER CommonBufferPa;
    ULONG CommonBufferSize;
    BOOLEAN AllocateCommonBuffers;
    UCHAR Spare1[3];
    PVOID DeviceObject;
} DUMP_POINTERS, *PDUMP_POINTERS;

//
// Define values for pass-through DataIn field.
//

#define SCSI_IOCTL_DATA_OUT          0
#define SCSI_IOCTL_DATA_IN           1
#define SCSI_IOCTL_DATA_UNSPECIFIED  2

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\scsi.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scsi.h

Abstract:

    These are the structures and defines that are used in the
    SCSI port and class drivers.

Authors:

Revision History:

--*/
#ifndef _NTSCSI_
#define _NTSCSI_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4200)

// begin_ntminitape

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#include <pshpack1.h>
typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC, *PCDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE, *PCDB6READWRITE;

    //
    // SCSI Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY, *PCDB6INQUIRY;

    struct _CDB6VERIFY {
        UCHAR OperationCode;
        UCHAR Fixed : 1;
        UCHAR ByteCompare : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR VerificationLength[3];
        UCHAR Control;
    } CDB6VERIFY, *PCDB6VERIFY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT, *PCDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        union {
            struct {
                UCHAR LogicalBlockByte0;
                UCHAR LogicalBlockByte1;
                UCHAR LogicalBlockByte2;
                UCHAR LogicalBlockByte3;
            };
            ULONG LogicalBlock;
        };
        UCHAR Reserved2;
        union {
            struct {
                UCHAR TransferBlocksMsb;
                UCHAR TransferBlocksLsb;
            };
            ULONG TransferBlocks;
        };
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // Standard 12-byte CDB
    //

    struct _CDB12 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];      // [0]=MSB, [3]=LSB
        UCHAR TransferLength[4];    // [0]=MSB, [3]=LSB
        UCHAR Reserved2;
        UCHAR Control;
    } CDB12, *PCDB12;

    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME, *PPAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Format2 : 4;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3[3];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC, *PREAD_TOC;

    struct _READ_DISK_INFORMATION {
        UCHAR OperationCode;    // 0x51
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_DISK_INFORMATION, *PREAD_DISK_INFORMATION;

    struct _READ_TRACK_INFORMATION {
        UCHAR OperationCode;    // 0x52
        UCHAR Track : 1;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2 : 1;
        UCHAR Lun : 3;
        UCHAR BlockAddress[4];  // or Track Number
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_TRACK_INFORMATION, *PREAD_TRACK_INFORMATION;

    struct _READ_HEADER {
        UCHAR OperationCode;    // 0x44
        UCHAR Reserved1 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved2 : 3;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_HEADER, *PREAD_HEADER;

    struct _PLAY_AUDIO {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingBlockAddress[4];
        UCHAR Reserved2;
        UCHAR PlayLength[2];
        UCHAR Control;
    } PLAY_AUDIO, *PPLAY_AUDIO;

    struct _PLAY_AUDIO_MSF {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF, *PPLAY_AUDIO_MSF;

    struct _PLAY_CD {
        UCHAR OperationCode;    // 0xBC
        UCHAR Reserved1 : 1;
        UCHAR CMSF : 1;         // LBA = 0, MSF = 1
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;

        union {
            struct _LBA {
                UCHAR StartingBlockAddress[4];
                UCHAR PlayLength[4];
            } LBA;

            struct _MSF {
                UCHAR Reserved1;
                UCHAR StartingM;
                UCHAR StartingS;
                UCHAR StartingF;
                UCHAR EndingM;
                UCHAR EndingS;
                UCHAR EndingF;
                UCHAR Reserved2;
            } MSF;
        };

        UCHAR Audio : 1;
        UCHAR Composite : 1;
        UCHAR Port1 : 1;
        UCHAR Port2 : 1;
        UCHAR Reserved2 : 3;
        UCHAR Speed : 1;
        UCHAR Control;
    } PLAY_CD, *PPLAY_CD;

    struct _SCAN_CD {
        UCHAR OperationCode;    // 0xBA
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 3;
        UCHAR Direct : 1;
        UCHAR Lun : 3;
        UCHAR StartingAddress[4];
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 6;
        UCHAR Type : 2;
        UCHAR Reserved4;
        UCHAR Control;
    } SCAN_CD, *PSCAN_CD;

    struct _STOP_PLAY_SCAN {
        UCHAR OperationCode;    // 0x4E
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } STOP_PLAY_SCAN, *PSTOP_PLAY_SCAN;

    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL, *PSUBCHANNEL;

    //
    // Read CD. Used by Atapi for raw sector reads.
    //

    struct _READ_CD {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved0 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR StartingLBA[4];
        UCHAR TransferBlocks[3];
        UCHAR Reserved2 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved3 : 5;
        UCHAR Control;
    } READ_CD, *PREAD_CD;

    struct _READ_CD_MSF {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved3;
        UCHAR Reserved4 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved5 : 5;
        UCHAR Control;
    } READ_CD_MSF, *PREAD_CD_MSF;

    //
    // Plextor Read CD-DA
    //

    struct _PLXTR_READ_CDDA {
        UCHAR OperationCode;
        UCHAR Reserved0 : 5;
        UCHAR LogicalUnitNumber :3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR TransferBlockByte2;
        UCHAR TransferBlockByte3;
        UCHAR SubCode;
        UCHAR Control;
    } PLXTR_READ_CDDA, *PPLXTR_READ_CDDA;

    //
    // NEC Read CD-DA
    //

    struct _NEC_READ_CDDA {
        UCHAR OperationCode;
        UCHAR Reserved0;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved1;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR Control;
    } NEC_READ_CDDA, *PNEC_READ_CDDA;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE, *PMODE_SENSE;

    struct _MODE_SENSE10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3[4];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } MODE_SENSE10, *PMODE_SENSE10;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT, *PMODE_SELECT;

    struct _MODE_SELECT10 {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[5];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } MODE_SELECT10, *PMODE_SELECT10;

    struct _LOCATE {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE, *PLOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];  // [0]=MSB, [1]=LSB
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSENSE, *PLOGSENSE;

    struct _LOGSELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PCRBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSELECT, *PLOGSELECT;

    struct _PRINT {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT, *PPRINT;

    struct _SEEK {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK, *PSEEK;

    struct _ERASE {
        UCHAR OperationCode;
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE, *PERASE;

    struct _START_STOP {
        UCHAR OperationCode;
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP, *PSTART_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL, *PMEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK, *PSEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS, *PREQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION, *PPARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS, *PWRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS, *PSPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION, *PREAD_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
    } CDB6READWRITETAPE, *PCDB6READWRITETAPE;

    //
    // Medium changer CDB's
    //

    struct _INIT_ELEMENT_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 7;
        UCHAR NoBarCode : 1;
    } INIT_ELEMENT_STATUS, *PINIT_ELEMENT_STATUS;

    struct _INITIALIZE_ELEMENT_RANGE {
        UCHAR OperationCode;
        UCHAR Range : 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR FirstElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved3;
        UCHAR Reserved4 : 7;
        UCHAR NoBarCode : 1;
    } INITIALIZE_ELEMENT_RANGE, *PINITIALIZE_ELEMENT_RANGE;

    struct _POSITION_TO_ELEMENT {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } POSITION_TO_ELEMENT, *PPOSITION_TO_ELEMENT;

    struct _MOVE_MEDIUM {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } MOVE_MEDIUM, *PMOVE_MEDIUM;

    struct _EXCHANGE_MEDIUM {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR Destination1ElementAddress[2];
        UCHAR Destination2ElementAddress[2];
        UCHAR Flip1 : 1;
        UCHAR Flip2 : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } EXCHANGE_MEDIUM, *PEXCHANGE_MEDIUM;

    struct _READ_ELEMENT_STATUS {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } READ_ELEMENT_STATUS, *PREAD_ELEMENT_STATUS;

    struct _SEND_VOLUME_TAG {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR Reserved1 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR Reserved2;
        UCHAR ActionCode : 5;
        UCHAR Reserved3 : 3;
        UCHAR Reserved4[2];
        UCHAR ParameterListLength[2];
        UCHAR Reserved5;
        UCHAR Control;
    } SEND_VOLUME_TAG, *PSEND_VOLUME_TAG;

    struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } REQUEST_VOLUME_ELEMENT_ADDRESS, *PREQUEST_VOLUME_ELEMENT_ADDRESS;

    //
    // Atapi 2.5 Changer 12-byte CDBs
    //

    struct _LOAD_UNLOAD {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3: 6;
        UCHAR Reserved4[3];
        UCHAR Slot;
        UCHAR Reserved5[3];
    } LOAD_UNLOAD, *PLOAD_UNLOAD;

    struct _MECH_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[6];
        UCHAR AllocationLength[2];
        UCHAR Reserved2[1];
        UCHAR Control;
    } MECH_STATUS, *PMECH_STATUS;

    //
    // C/DVD 0.9 CDBs
    //

    struct _SYNCHRONIZE_CACHE10 {

        UCHAR OperationCode;    // 0x35

        UCHAR RelAddr : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 3;
        UCHAR Lun : 3;

        UCHAR LogicalBlockAddress[4];   // Unused - set to zero
        UCHAR Reserved2;
        UCHAR BlockCount[2];            // Unused - set to zero
        UCHAR Control;
    } SYNCHRONIZE_CACHE10, *PSYNCHRONIZE_CACHE10;

    struct _GET_EVENT_STATUS_NOTIFICATION {
        UCHAR OperationCode;    // 0x4a

        UCHAR Immediate : 1;
        UCHAR Reserved : 4;
        UCHAR Lun : 3;

        UCHAR Reserved2[2];
        UCHAR NotificationClassRequest;
        UCHAR Reserved3[2];
        UCHAR EventListLength[2];  // [0]=MSB, [1]=LSB

        UCHAR Control;
    } GET_EVENT_STATUS_NOTIFICATION, *PGET_EVENT_STATUS_NOTIFICATION;

    struct _READ_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xAD
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR RMDBlockNumber[4];
        UCHAR LayerNumber;
        UCHAR Format;
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Reserved3 : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } READ_DVD_STRUCTURE, *PREAD_DVD_STRUCTURE;

    struct _SEND_KEY {
        UCHAR OperationCode;    // 0xA3
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[6];
        UCHAR ParameterListLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } SEND_KEY, *PSEND_KEY;

    struct _REPORT_KEY {
        UCHAR OperationCode;    // 0xA4
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];   // for title key
        UCHAR Reserved2[2];
        UCHAR AllocationLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } REPORT_KEY, *PREPORT_KEY;

    struct _SET_READ_AHEAD {
        UCHAR OperationCode;    // 0xA7
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR TriggerLBA[4];
        UCHAR ReadAheadLBA[4];
        UCHAR Reserved2;
        UCHAR Control;
    } SET_READ_AHEAD, *PSET_READ_AHEAD;

    struct _READ_FORMATTED_CAPACITIES {
        UCHAR OperationCode;    // 0xA7
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_FORMATTED_CAPACITIES, *PREAD_FORMATTED_CAPACITIES;

    //
    // SCSI-3
    //

    struct _REPORT_LUNS {
        UCHAR OperationCode;    // 0xA0
        UCHAR Reserved1[5];
        UCHAR AllocationLength[4];
        UCHAR Reserved2[1];
        UCHAR Control;
    } REPORT_LUNS, *PREPORT_LUNS;

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#include <poppack.h>

//
// C/DVD CDB Constants & Structures.
//

//
// GET_EVENT_STATUS_NOTIFICATION
//

#define NOTIFICATION_NO_CLASS_EVENTS                0x0
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS  0x2
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS      0x4
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS       0x6

typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {

    UCHAR EventDataLength[2];   // [0]=MSB, [1]=LSB

    UCHAR NotificationClass : 3;
    UCHAR Reserved : 4;
    UCHAR NEA : 1;

    UCHAR SupportedEventClasses;
    UCHAR ClassEventData[0];
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;

//
// Class event data may be one or more (or none) of the following:
//

#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3

typedef struct _NOTIFICATION_POWER_STATUS {
    UCHAR PowerEvent : 4;
    UCHAR Reserved : 4;
    UCHAR PowerStatus;
    UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;


#define NOTIFICATION_MEDIA_EVENT_NO_EVENT           0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3

typedef struct _NOTIFICATION_MEDIA_STATUS {
    UCHAR MediaStatus : 4;
    UCHAR Reserved : 4;

    UCHAR PowerStatus;
    UCHAR StartSlot;
    UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;


#define NOTIFICATION_BUSY_EVENT_NO_EVENT            0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

typedef struct _NOTIFICATION_BUSY_STATUS {
    UCHAR DeviceBusyEvent : 4;
    UCHAR Reserved : 4;

    UCHAR DeviceBusyStatus;
    UCHAR Time[2];     // [0]=MSB, [1]=LSB
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;

//
// Read DVD Structure Definitions and Constants
//

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

typedef struct _READ_DVD_STRUCTURES_HEADER {
    UCHAR Length[2];
    UCHAR Reserved[2];

    UCHAR Data[0];
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;

//
// DiskKey, BCA & Manufacturer information will provide byte arrays as their
// data.
//

//
// CDVD 0.9 Send & Report Key Definitions and Structures
//

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

typedef struct _CDVD_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
    UCHAR Data[0];
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
    UCHAR Reserved1[3];
    UCHAR Reserved2 : 6;
    UCHAR AGID : 2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
    UCHAR ChallengeKeyValue[10];
    UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
    UCHAR Key[5];
    UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
    UCHAR Reserved1[3];
    UCHAR Success : 1;
    UCHAR Reserved2 : 7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved1[1];
    UCHAR Reserved2 : 3;
    UCHAR CGMS : 2;
    UCHAR CP_SEC : 1;
    UCHAR CPM : 1;
    UCHAR Zero : 1;
    CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;

//
// Read Formatted Capacity Data - returned in Big Endian Format
//

typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
    UCHAR NumberOfBlocks[4];
    UCHAR Maximum : 1;
    UCHAR Valid : 1;
    UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
    UCHAR Reserved[3];
    UCHAR CapacityListLength;
    FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;

//
// PLAY_CD definitions and constants
//

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

//
// Read Disk Information Definitions and Capabilities
//

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02

#define LAST_SESSION_EMPTY      0x00
#define LAST_SESSION_INCOMPLETE 0x01
#define LAST_SESSION_COMPLETE   0x03

#define DISK_TYPE_CDDA          0x01
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF

typedef struct _OPC_TABLE_ENTRY {
    UCHAR Speed[2];
    UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISK_INFORMATION {
    UCHAR Length[2];

    UCHAR DiskStatus : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable : 1;
    UCHAR Reserved1 : 3;

    UCHAR FirstTrackNumber;
    UCHAR NumberOfSessions;
    UCHAR LastSessionFirstTrack;
    UCHAR LastSessionLastTrack;

    UCHAR Reserved2 : 5;
    UCHAR GEN : 1;
    UCHAR DBC_V : 1;
    UCHAR DID_V : 1;

    UCHAR DiskType;
    UCHAR Reserved3[3];

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // MSF
    UCHAR LastPossibleStartTime[4]; // MSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[0];
} DISK_INFORMATION, *PDISK_INFORMATION;

//
// Read Header definitions and structures
//

typedef struct _DATA_BLOCK_HEADER {
    UCHAR DataMode;
    UCHAR Reserved[4];
    union {
        UCHAR LogicalBlockAddress[4];
        struct {
            UCHAR Reserved;
            UCHAR M;
            UCHAR S;
            UCHAR F;
        } MSF;
    };
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;

#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

//
// Read TOC Format Codes
//

#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

typedef struct _TRACK_INFORMATION {
    UCHAR Length[2];
    UCHAR TrackNumber;
    UCHAR SessionNumber;
    UCHAR Reserved1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR Damage : 1;
    UCHAR Reserved2 : 2;
    UCHAR DataMode : 4;
    UCHAR FP : 1;
    UCHAR Packet : 1;
    UCHAR Blank : 1;
    UCHAR RT : 1;
    UCHAR NWA_V : 1;
    UCHAR Reserved3 : 7;
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;



//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0


//
// SCSI CDB operation codes
//

#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_INIT_ELEMENT_STATUS 0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17

#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E
#define SCSIOP_READ_FORMATTED_CAPACITY 0x23
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_POSITION_TO_ELEMENT 0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D
#define SCSIOP_STOP_PLAY_SCAN      0x4E
#define SCSIOP_READ_DISK_INFORMATION 0x51
#define SCSIOP_READ_TRACK_INFORMATION 0x52
#define SCSIOP_MODE_SELECT10       0x55
#define SCSIOP_MODE_SENSE10        0x5A
#define SCSIOP_REPORT_LUNS         0xA0
#define SCSIOP_SEND_KEY            0xA3
#define SCSIOP_REPORT_KEY          0xA4
#define SCSIOP_MOVE_MEDIUM         0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT    0xA6
#define SCSIOP_EXCHANGE_MEDIUM     0xA6
#define SCSIOP_SET_READ_AHEAD      0xA7
#define SCSIOP_READ_DVD_STRUCTURE  0xAD
#define SCSIOP_REQUEST_VOL_ELEMENT 0xB5
#define SCSIOP_SEND_VOLUME_TAG     0xB6
#define SCSIOP_READ_ELEMENT_STATUS 0xB8
#define SCSIOP_READ_CD_MSF         0xB9
#define SCSIOP_SCAN_CD             0xBA
#define SCSIOP_PLAY_CD             0xBC
#define SCSIOP_MECHANISM_STATUS    0xBD
#define SCSIOP_READ_CD             0xBE
#define SCSIOP_INIT_ELEMENT_RANGE  0xE7

//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

// end_ntminitape

//
// CDB Force media access used in extended read and write commands.
//

#define CDB_FORCE_MEDIA_ACCESS 0x08

//
// Denon CD ROM operation codes
//

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

//
// SCSI Bus Messages
//

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

//
// SCSI Extended Message operation codes
//

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

//
// SCSI Extended Message Lengths
//

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

//
// SCSI extended message structure
//

#pragma pack (1)
typedef struct _SCSI_EXTENDED_MESSAGE {
    UCHAR InitialMessageCode;
    UCHAR MessageLength;
    UCHAR MessageType;
    union _EXTENDED_ARGUMENTS {

        struct {
            UCHAR Modifier[4];
        } Modify;

        struct {
            UCHAR TransferPeriod;
            UCHAR ReqAckOffset;
        } Synchronous;

        struct{
            UCHAR Width;
        } Wide;
    }ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;
#pragma pack ()

//
// SCSI bus status codes.
//

#define SCSISTAT_GOOD                  0x00
#define SCSISTAT_CHECK_CONDITION       0x02
#define SCSISTAT_CONDITION_MET         0x04
#define SCSISTAT_BUSY                  0x08
#define SCSISTAT_INTERMEDIATE          0x10
#define SCSISTAT_INTERMEDIATE_COND_MET 0x14
#define SCSISTAT_RESERVATION_CONFLICT  0x18
#define SCSISTAT_COMMAND_TERMINATED    0x22
#define SCSISTAT_QUEUE_FULL            0x28

//
// Enable Vital Product Data Flag (EVPD)
// used with INQUIRY command.
//

#define CDB_INQUIRY_EVPD           0x01

//
// Defines for format CDB
//

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB  0
#define USE_DEFAULTLSB  0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE  0x00

// begin_ntminitape

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR ReservedBit : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

#define DEVICE_QUALIFIER_ACTIVE         0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE     0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Sense Data Format
//

typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE       0x00
#define SCSI_ADSENSE_LUN_NOT_READY  0x04

#define SCSI_ADSENSE_TRACK_ERROR    0x14
#define SCSI_ADSENSE_SEEK_ERROR     0x15
#define SCSI_ADSENSE_REC_DATA_NOECC 0x17
#define SCSI_ADSENSE_REC_DATA_ECC   0x18

#define SCSI_ADSENSE_ILLEGAL_COMMAND 0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK  0x21
#define SCSI_ADSENSE_INVALID_CDB    0x24
#define SCSI_ADSENSE_INVALID_LUN    0x25
#define SCSI_ADWRITE_PROTECT        0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED 0x28
#define SCSI_ADSENSE_BUS_RESET      0x29

#define SCSI_ADSENSE_INVALID_MEDIA  0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE 0x3a
#define SCSI_ADSENSE_POSITION_ERROR 0x3b

// the second is for legacy apps.
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED

#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE 0x6f

#define SCSI_ADSENSE_VENDOR_UNIQUE  0x80

#define SCSI_ADSENSE_MUSIC_AREA     0xA0
#define SCSI_ADSENSE_DATA_AREA      0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW 0xA7

//
// SCSI_ADSENSE_LUN_NOT_READY (0x04) qualifiers
//

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE         0x00
#define SCSI_SENSEQ_BECOMING_READY               0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED        0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS           0x04
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS        0x07

//
// SCSI_ADSENSE_NO_SENSE (0x00) qualifiers
//

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI_ADSENSE_ILLEGAL_BLOCK (0x21) qualifiers
//

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

//
// SCSI_ADSENSE_POSITION_ERROR (0x3b) qualifiers
//

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

// end_ntminitape

//
// SCSI_ADSENSE_INVALID_MEDIA (0x30) qualifiers
//

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02

//
// SCSI_ADSENSE_COPY_PROTECTION_FAILURE (0x6f) qualifiers
//
#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05


//
// SCSI IO Device Control Codes
//

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN   ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT  ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

//
// SMART support in atapi
//

#define IOCTL_SCSI_MINIPORT_SMART_VERSION           ((FILE_DEVICE_SCSI << 16) + 0x0500)
#define IOCTL_SCSI_MINIPORT_IDENTIFY                ((FILE_DEVICE_SCSI << 16) + 0x0501)
#define IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS      ((FILE_DEVICE_SCSI << 16) + 0x0502)
#define IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS   ((FILE_DEVICE_SCSI << 16) + 0x0503)
#define IOCTL_SCSI_MINIPORT_ENABLE_SMART            ((FILE_DEVICE_SCSI << 16) + 0x0504)
#define IOCTL_SCSI_MINIPORT_DISABLE_SMART           ((FILE_DEVICE_SCSI << 16) + 0x0505)
#define IOCTL_SCSI_MINIPORT_RETURN_STATUS           ((FILE_DEVICE_SCSI << 16) + 0x0506)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE ((FILE_DEVICE_SCSI << 16) + 0x0507)
#define IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES   ((FILE_DEVICE_SCSI << 16) + 0x0508)
#define IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS   ((FILE_DEVICE_SCSI << 16) + 0x0509)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE ((FILE_DEVICE_SCSI << 16) + 0x050a)

//
// CLUSTER support
// deliberately skipped some values to allow for expansion above.
//
#define IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE     ((FILE_DEVICE_SCSI << 16) + 0x0520)
#define IOCTL_SCSI_MINIPORT_NOT_CLUSTER_CAPABLE    ((FILE_DEVICE_SCSI << 16) + 0x0521)


// begin_ntminitape

//
// Read Capacity Data - returned in Big Endian format
//

typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;

//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;


//
// Mode data structures.
//

//
// Define Mode parameter header.
//

typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
    UCHAR ModeDataLength[2];
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR Reserved[2];
    UCHAR BlockDescriptorLength[2];
}MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;

//
// Define Disconnect-Reconnect page.
//

typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;

//
// Define mode caching page.
//

typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefetch[2];
    UCHAR MaximumPrefetch[2];
    UCHAR MaximumPrefetchCeiling[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;

//
// Define mode flexible disk page.
//

typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
}MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;

//
// Define mode format page.
//

typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternateSectorsPerZone[2];
    UCHAR AlternateTracksPerZone[2];
    UCHAR AlternateTracksPerLogicalUnit[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[3];
}MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;

//
// Define rigid disk driver geometry page.
//

typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[3];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[3];
    UCHAR StartReducedCurrent[3];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[3];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;

//
// Define read write recovery page
//

typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR ARRE : 1;
    UCHAR AWRE : 1;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;

//
// Define read recovery page - cdrom
//

typedef struct _MODE_READ_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];

} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;


//
// Define Informational Exception Control Page. Used for failure prediction
//

typedef struct _MODE_INFO_EXCEPTIONS
{
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    UCHAR LogErr : 1;
    UCHAR Reserved2 : 1;
    UCHAR Test : 1;
    UCHAR Dexcpt : 1;
    UCHAR Reserved3 : 3;
    UCHAR Perf : 1;

    UCHAR ReportMethod : 4;
    UCHAR Reserved4 : 4;

    UCHAR IntervalTimer[4];       // [0]=MSB, [3]=LSB
    UCHAR ReportCount[4];         // [0]=MSB, [3]=LSB

} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;

//
// Begin C/DVD 0.9 definitions
//

//
// Power Condition Mode Page Format
//

typedef struct _POWER_CONDITION_PAGE {
    UCHAR PageCode : 6;         // 0x1A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;           // 0x0A
    UCHAR Reserved2;

    UCHAR Standby : 1;
    UCHAR Idle : 1;
    UCHAR Reserved3 : 6;

    UCHAR IdleTimer[4];         // [0]=MSB, [3]=LSB
    UCHAR StandbyTimer[4];      // [0]=MSB, [3]=LSB
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;

//
// CD-Audio Control Mode Page Format
//

typedef struct _CDDA_OUTPUT_PORT {
    UCHAR ChannelSelection : 4;
    UCHAR Reserved : 4;
    UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;


typedef struct _CDAUDIO_CONTROL_PAGE {
    UCHAR PageCode : 6;     // 0x0E
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x0E

    UCHAR Reserved2 : 1;
    UCHAR StopOnTrackCrossing : 1;         // Default 0
    UCHAR Immediate : 1;    // Always 1
    UCHAR Reserved3 : 5;

    UCHAR Reserved4[3];
    UCHAR Obsolete[2];

    CDDA_OUTPUT_PORT CDDAOutputPorts[4];

} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

//
// C/DVD Feature Set Support & Version Page
//

typedef struct _CDVD_FEATURE_SET_PAGE {
    UCHAR PageCode : 6;     // 0x18
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x16

    UCHAR CDAudio[2];       // [0]=MSB, [1]=LSB
    UCHAR EmbeddedChanger[2];
    UCHAR PacketSMART[2];
    UCHAR PersistantPrevent[2];
    UCHAR EventStatusNotification[2];
    UCHAR DigitalOutput[2];
    UCHAR CDSequentialRecordable[2];
    UCHAR DVDSequentialRecordable[2];
    UCHAR RandomRecordable[2];
    UCHAR KeyExchange[2];
    UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;

//
// CDVD Inactivity Time-out Page Format
//

typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
    UCHAR PageCode : 6;     // 0x1D
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x08
    UCHAR Reserved2[2];

    UCHAR SWPP : 1;
    UCHAR DISP : 1;
    UCHAR Reserved3 : 6;

    UCHAR Reserved4;
    UCHAR GroupOneMinimumTimeout[2];
    UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;

//
// CDVD Capabilities & Mechanism Status Page
//

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7


typedef struct _CDVD_CAPABILITIES_PAGE {
    UCHAR PageCode : 6;     // 0x2A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // 0x18         // offset 1

    UCHAR CDRRead : 1;
    UCHAR CDERead : 1;
    UCHAR Method2 : 1;
    UCHAR DVDROMRead : 1;
    UCHAR DVDRRead : 1;
    UCHAR DVDRAMRead : 1;
    UCHAR Reserved2 : 2;                    // offset 2

    UCHAR CDRWrite : 1;
    UCHAR CDEWrite : 1;
    UCHAR TestWrite : 1;
    UCHAR Reserved3 : 1;
    UCHAR DVDRWrite : 1;
    UCHAR DVDRAMWrite : 1;
    UCHAR Reserved4 : 2;                    // offset 3

    UCHAR AudioPlay : 1;
    UCHAR Composite : 1;
    UCHAR DigitalPortOne : 1;
    UCHAR DigitalPortTwo : 1;
    UCHAR Mode2Form1 : 1;
    UCHAR Mode2Form2 : 1;
    UCHAR MultiSession : 1;
    UCHAR Reserved5 : 1;                    // offset 4

    UCHAR CDDA : 1;
    UCHAR CDDAAccurate : 1;
    UCHAR RWSupported : 1;
    UCHAR RWDeinterleaved : 1;
    UCHAR C2Pointers : 1;
    UCHAR ISRC : 1;
    UCHAR UPC : 1;
    UCHAR ReadBarCodeCapable : 1;           // offset 5

    UCHAR Lock : 1;
    UCHAR LockState : 1;
    UCHAR PreventJumper : 1;
    UCHAR Eject : 1;
    UCHAR Reserved6 : 1;
    UCHAR LoadingMechanismType : 3;         // offset 6

    UCHAR SeparateVolume : 1;
    UCHAR SeperateChannelMute : 1;
    UCHAR SupportsDiskPresent : 1;
    UCHAR SWSlotSelection : 1;
    UCHAR SideChangeCapable : 1;
    UCHAR RWInLeadInReadable : 1;
    UCHAR Reserved7 : 2;                    // offset 7

    UCHAR ObsoleteReserved[2];              // offset 8
    UCHAR NumberVolumeLevels[2];            // offset 10
    UCHAR BufferSize[2];                    // offset 12
    UCHAR ObsoleteReserved2[2];             // offset 14
    UCHAR ObsoleteReserved3;                // offset 16

    UCHAR Reserved8 : 1;
    UCHAR BCK : 1;
    UCHAR RCK : 1;
    UCHAR LSBF : 1;
    UCHAR Length : 2;
    UCHAR Reserved9 : 2;                    // offset 17

    UCHAR ObsoleteReserved4[2];             // offset 18
    UCHAR CopyManagementRevision[2];        // offset 20
    UCHAR Reserved10[2];                    // offset 22
} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;


typedef struct _LUN_LIST {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
    UCHAR Lun[0][8];        // 4 level of addressing.  2 bytes each.
} LUN_LIST, *PLUN_LIST;


#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

//
// end C/DVD 0.9 mode page definitions

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8
#define MODE_HEADER_LENGTH                   4
#define MODE_HEADER_LENGTH10                 8

typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;

// end_ntminitape

//
// CDROM audio control (0x0E)
//

#define CDB_AUDIO_PAUSE 0
#define CDB_AUDIO_RESUME 1

#define CDB_DEVICE_START 0x11
#define CDB_DEVICE_STOP 0x10

#define CDB_EJECT_MEDIA 0x10
#define CDB_LOAD_MEDIA 0x01

#define CDB_SUBCHANNEL_HEADER      0x00
#define CDB_SUBCHANNEL_BLOCK       0x01

#define CDROM_AUDIO_CONTROL_PAGE   0x0E
#define MODE_SELECT_IMMEDIATE      0x04
#define MODE_SELECT_PFBIT          0x10

#define CDB_USE_MSF                0x01

typedef struct _PORT_OUTPUT {
    UCHAR ChannelSelection;
    UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
    UCHAR CodePage;
    UCHAR ParameterLength;
    UCHAR Immediate;
    UCHAR Reserved[2];
    UCHAR LbaFormat;
    UCHAR LogicalBlocksPerSecond[2];
    PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;

//
// Multisession CDROM
//

#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02;

//
// Atapi 2.5 changer
//

typedef struct _MECHANICAL_STATUS_INFORMATION_HEADER {
    UCHAR CurrentSlot : 5;
    UCHAR ChangerState : 2;
    UCHAR Fault : 1;
    UCHAR Reserved : 5;
    UCHAR MechanismState : 3;
    UCHAR CurrentLogicalBlockAddress[3];
    UCHAR NumberAvailableSlots;
    UCHAR SlotTableLength[2];
} MECHANICAL_STATUS_INFORMATION_HEADER, *PMECHANICAL_STATUS_INFORMATION_HEADER;

typedef struct _SLOT_TABLE_INFORMATION {
    UCHAR DiscChanged : 1;
    UCHAR Reserved : 6;
    UCHAR DiscPresent : 1;
    UCHAR Reserved2[3];
} SLOT_TABLE_INFORMATION, *PSLOT_TABLE_INFORMATION;

typedef struct _MECHANICAL_STATUS {
    MECHANICAL_STATUS_INFORMATION_HEADER MechanicalStatusHeader;
    SLOT_TABLE_INFORMATION SlotTableInfo[1];
} MECHANICAL_STATUS, *PMECHANICAL_STATUS;


// begin_ntminitape

//
// Tape definitions
//

typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB 4 byte big endians values.
//

typedef union _FOUR_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };

    ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
    };

    USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES(Destination, Source) {                \
    PFOUR_BYTE d = (PFOUR_BYTE)(Destination);               \
    PFOUR_BYTE s = (PFOUR_BYTE)(Source);                    \
    d->Byte3 = s->Byte0;                                    \
    d->Byte2 = s->Byte1;                                    \
    d->Byte1 = s->Byte2;                                    \
    d->Byte0 = s->Byte3;                                    \
}

//
// Byte reversing macro for converting
// USHORTS from big to little endian in place
//

#define REVERSE_SHORT(Short) {          \
    UCHAR tmp;                          \
    PTWO_BYTE w = (PTWO_BYTE)(Short);   \
    tmp = w->Byte0;                     \
    w->Byte0 = w->Byte1;                \
    w->Byte1 = tmp;                     \
    }

//
// Byte reversing macro for convering
// ULONGS between big & little endian in place
//

#define REVERSE_LONG(Long) {            \
    UCHAR tmp;                          \
    PFOUR_BYTE l = (PFOUR_BYTE)(Long);  \
    tmp = l->Byte3;                     \
    l->Byte3 = l->Byte0;                \
    l->Byte0 = tmp;                     \
    tmp = l->Byte2;                     \
    l->Byte2 = l->Byte1;                \
    l->Byte1 = tmp;                     \
    }

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    UCHAR tmp;                                      \
    for (tmp = 0; tmp < 32; tmp++) {                \
        if (((Data) >> tmp) == 1) {                 \
            break;                                  \
        }                                           \
    }                                               \
    ASSERT(tmp != 32);                              \
    (Bit) = tmp;                                    \
}

// end_ntminitape

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif

#endif // !defined _NTSCSI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    //m_xprResource.Destroy(); !!!

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 5, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 6 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset )
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset )
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset )
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset )
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset )
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset )
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName );

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName )
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName )
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName )
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName )
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName )
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName )
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Under UMA emulation, we copy the data from AGP memory to video memory.
    // This will not be necessary with final hardware
    D3D_CopyContiguousMemoryToVideo( m_pVidMemData );

    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\D3DFile.cpp ===
//-----------------------------------------------------------------------------
// File: D3DFile.cpp
//
// Desc: Code to manage file-based geoemtry models. These models are read in
//       by the code in ReadX.cpp and/or ReadXBG.cpp and written out by the
//       code in WriteXBG.cpp.
//
//       See the XBG.h header file for a better description of .xbg geometry
//       files.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <d3dx8.h>
#include "XBG.h"
#include "TriStripper.h"
#include "FVF.h"




//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool g_bVisualizeStrips = false;


D3DMATERIAL8 g_VisualizationColors[6] =
{
	{
		{ 1.0f, 0.0f, 0.0f, 1.0f },
		{ 1.0f, 0.0f, 0.0f, 1.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		0.0f,
	},

	{
		{ 0.0f, 1.0f, 0.0f, 1.0f },
		{ 0.0f, 1.0f, 0.0f, 1.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		0.0f,
	},

	{
		{ 0.0f, 0.0f, 1.0f, 1.0f },
		{ 0.0f, 0.0f, 1.0f, 1.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		0.0f,
	},

	{
		{ 0.0f, 1.0f, 1.0f, 1.0f },
		{ 0.0f, 1.0f, 1.0f, 1.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		0.0f,
	},

	{
		{ 1.0f, 0.0f, 1.0f, 1.0f },
		{ 1.0f, 0.0f, 1.0f, 1.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		0.0f,
	},

	{
		{ 1.0f, 1.0f, 0.0f, 1.0f },
		{ 1.0f, 1.0f, 0.0f, 1.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		0.0f,
	},
};




//-----------------------------------------------------------------------------
// Name: D3DFile_CreateTexture()
// Desc: Helper function to load a texture file
//-----------------------------------------------------------------------------
HRESULT D3DFile_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strTexture,
                               LPDIRECT3DTEXTURE8* ppTexture )
{

    // Check the current directory
    if( SUCCEEDED( D3DXCreateTextureFromFile( pd3dDevice, strTexture, 
                                              ppTexture ) ) )
        return S_OK;

    // Check the "..\Textures" directory
    TCHAR strFilename[80];
    _stprintf( strFilename, "..\\Textures\\%s", strTexture );
    if( SUCCEEDED( D3DXCreateTextureFromFile( pd3dDevice, strFilename, 
                                              ppTexture ) ) )
        return S_OK;

    (*ppTexture) = NULL;
    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: ComputeNormals()
// Desc: Compute the normals for the mesh
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::ComputeNormals()
{
    LPDIRECT3DVERTEXBUFFER8 pVB    = m_pMeshVB;
    LPDIRECT3DINDEXBUFFER8  pIB    = m_pMeshIB;
    DWORD            dwNumVertices = m_dwNumMeshVertices;
    DWORD            dwNumIndices  = m_dwNumMeshIndices;
    DWORD            dwFVF         = m_dwMeshFVF;
    DWORD            dwVertexSize  = m_dwMeshVertexSize;
    D3DPRIMITIVETYPE dwPrimType    = m_dwMeshPrimType;
    DWORD            dwNumSubsets  = m_dwNumMeshSubsets;
    XBMESH_SUBSET*   pSubsets      = m_pMeshSubsets;

    // Make sure the vertices have normals
    if( 0 == ( dwFVF & D3DFVF_NORMAL ) )
        return E_FAIL;

    // Compute the vertices' byte offset to their normals
    DWORD dwNormalOffset = 12;
    DWORD dwPositionFVF  = dwFVF & D3DFVF_POSITION_MASK;
    if( dwPositionFVF >= D3DFVF_XYZB1 )
        dwNormalOffset += 4*((dwPositionFVF-4)/2);

    // Gain access to vertices and faces
    BYTE* pVertices;
    WORD* pIndices;
    pIB->Lock( 0, 0, (BYTE**)&pIndices,  0 );
    pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Zero out the existing normals
    for( DWORD vtx = 0; vtx < dwNumVertices; vtx++ )
    {
        BYTE*        pVertex = ( (BYTE*)pVertices + (vtx * dwVertexSize) );
        D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertex + dwNormalOffset );
        (*pNormal) = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    }

	DWORD dwNumFaces = dwPrimType==D3DPT_TRIANGLELIST ? dwNumIndices/3: dwNumIndices-2;

    // Add in face normals
    for( DWORD face = 0; face < dwNumFaces; face++ )
    {
        WORD wFaceVtx[3];
		if( dwPrimType==D3DPT_TRIANGLELIST )
		{
	        wFaceVtx[0] = pIndices[ 3*face+0 ];
		    wFaceVtx[1] = pIndices[ 3*face+1 ];
			wFaceVtx[2] = pIndices[ 3*face+2 ];
		}
		else
		{
			if( 0 == face%2 )
			{
		        wFaceVtx[0] = pIndices[ face+0 ];
			    wFaceVtx[1] = pIndices[ face+1 ];
				wFaceVtx[2] = pIndices[ face+2 ];
			}
			else
			{
		        wFaceVtx[0] = pIndices[ face+1 ];
			    wFaceVtx[1] = pIndices[ face+0 ];
				wFaceVtx[2] = pIndices[ face+2 ];
			}
		}

        D3DXVECTOR3* pPos0 = (D3DXVECTOR3*)( pVertices + (wFaceVtx[0] * dwVertexSize) );
        D3DXVECTOR3* pPos1 = (D3DXVECTOR3*)( pVertices + (wFaceVtx[1] * dwVertexSize) );
        D3DXVECTOR3* pPos2 = (D3DXVECTOR3*)( pVertices + (wFaceVtx[2] * dwVertexSize) );

        // Calculate the normal of the face from the two edge vectors
        D3DXVECTOR3  vNormal;
        D3DXVECTOR3  vEdge1 = *pPos0 - *pPos1;
        D3DXVECTOR3  vEdge2 = *pPos0 - *pPos2;
        D3DXVec3Cross( &vNormal, &vEdge1, &vEdge2 );

        for( DWORD point = 0; point < 3; point++ )
        {
            BYTE*        pVertex = ( pVertices + (wFaceVtx[point] * dwVertexSize) );
            D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertex + dwNormalOffset );
            (*pNormal) += vNormal;
        }
    }

    // Renormalize all normals
    for( vtx = 0; vtx < dwNumVertices; vtx++ )
    {
        BYTE*        pVertex = ( pVertices + (vtx * dwVertexSize) );
        D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertex + dwNormalOffset );
        D3DXVec3Normalize( pNormal, pNormal );
    }

    pIB->Unlock();
    pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetMeshFVF()
// Desc: Changes the FVF of the mesh
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::SetMeshFVF( DWORD dwFVF )
{
    if( 0 == dwFVF )
        return E_FAIL;

    LPDIRECT3DVERTEXBUFFER8 pOldVB = m_pMeshVB;
    LPDIRECT3DVERTEXBUFFER8 pNewVB = NULL;
    DWORD dwNumVertices = m_dwNumMeshVertices;
    DWORD dwOldFVF      = m_dwMeshFVF;
    DWORD dwNewFVF      = dwFVF;

    if( pOldVB && dwNewFVF != dwOldFVF )
    {
        // Create a copy of the vertex buffer, using the new FVF
        if( FAILED( CopyVertexBufferWithNewFVF( pOldVB, dwNumVertices,
                                                dwOldFVF, dwNewFVF, &pNewVB ) ) )
            return E_FAIL;

        // Assign the new vertex buffer
        m_pMeshVB->Release();
        m_pMeshVB          = pNewVB;
        m_dwMeshFVF        = dwNewFVF;
        m_dwMeshVertexSize = D3DXGetFVFVertexSize( dwNewFVF );

        // Compute normals if necessary
        if( ( dwNewFVF & D3DFVF_NORMAL ) && ( 0 == ( dwOldFVF & D3DFVF_NORMAL ) ) )
            ComputeNormals();
    }

    // Set the Mesh FVF for any child and sibling frames
    if( m_pChild ) m_pChild->SetMeshFVF( dwFVF );
    if( m_pNext )  m_pNext->SetMeshFVF( dwFVF );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CD3DFrame()
// Desc: Constructor
//-----------------------------------------------------------------------------
CD3DFrame::CD3DFrame( TCHAR* strName )
{
    // Frame info
    _tcscpy( m_strFrameName, strName );
    D3DXMatrixIdentity( &m_matTransform );

    m_pParent = NULL;
    m_pChild  = NULL;
    m_pNext   = NULL;

    m_bVisible        = TRUE;
    m_lSelectedSubset = -1;
    m_hFVFTreeItem    = 0L;
    m_TreeData        = 0L;

    // Mesh info
    m_pMeshVB              = NULL;
    m_pMeshIB              = NULL;
    m_pMeshSubsets         = NULL;

    m_vMeshCenter          = D3DXVECTOR3(0,0,0);
    m_fMeshRadius          = 0L;
    m_dwNumMeshVertices    = 0L;
    m_dwNumMeshIndices     = 0L;
    m_dwNumMeshPolygons    = 0L;
    m_dwMeshFVF            = 0L;
    m_dwMeshVertexSize     = 0L;
    m_dwMeshPrimType       = D3DPT_TRIANGLELIST;
    m_dwNumMeshSubsets     = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CD3DFrame()
// Desc: Destructor
//-----------------------------------------------------------------------------
CD3DFrame::~CD3DFrame()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the mesh
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::Destroy()
{
    for( UINT i=0; i<m_dwNumMeshSubsets; i++ )
        if( m_pMeshSubsets[i].pTexture )
            m_pMeshSubsets[i].pTexture->Release();

    if( m_pMeshVB )          m_pMeshVB->Release();
    if( m_pMeshIB )          m_pMeshIB->Release();

    if( m_pMeshSubsets )
        delete[] m_pMeshSubsets;
    m_dwNumMeshSubsets = 0L;

    m_pMeshVB              = NULL;
    m_pMeshIB              = NULL;
    m_pMeshSubsets         = NULL;

    if( m_pChild ) delete m_pChild;
    if( m_pNext )  delete m_pNext;
    m_pNext  = NULL;
    m_pChild = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CD3DFile()
// Desc: Constructor
//-----------------------------------------------------------------------------
CD3DFile::CD3DFile() 
         :CD3DFrame( _T("CD3DFile_Root") )
{
    m_dwNumFrames   = 0L;
    m_dwNumMeshes   = 0L;
    m_dwNumVertices = 0L;
    m_dwNumIndices  = 0L;
    m_dwNumPolygons = 0L;
    m_vCenter       = D3DXVECTOR3(0,0,0);
    m_fRadius       = 0.0f;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates a mesh from a file. The bCollapseMesh parameter is for loading
//       .x files. If true, the geometry will be collapsed to one mesh. If
//       false, the frame hierarchy (if any) will be retained.
//-----------------------------------------------------------------------------
HRESULT CD3DFile::Create( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename,
                          BOOL bCollapseMesh )
{
    if( bCollapseMesh )
    {
        // Try loading .x file, collapsing all geometry to one mesh
        if( SUCCEEDED( LoadCollapsedMeshFromX( pd3dDevice, strFilename ) ) )
            return S_OK;
    }
    else
    {
        // Try loading .x file, retaining the frame hierarchy
        if( SUCCEEDED( LoadFromX( pd3dDevice, strFilename ) ) )
            return S_OK;
    }

    // Try loading .xbg file
    if( SUCCEEDED( LoadFromXBG( pd3dDevice, strFilename ) ) )
        return S_OK;


    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: EnumFrames()
// Desc: Called recursively to walk the frame hierarchy, calling a user 
//       supplied callback function for every frame.
//-----------------------------------------------------------------------------
BOOL CD3DFrame::EnumFrames( BOOL (*EnumFramesCB)(CD3DFrame*,VOID*),
                            VOID* pData )
{
    EnumFramesCB( this, pData );

    if( m_pChild )
        m_pChild->EnumFrames( EnumFramesCB, pData );
    
    if( m_pNext )
        m_pNext->EnumFrames( EnumFramesCB, pData );

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: EnumFrames()
// Desc: Called recursively to walk the frame hierarchy, calling a user 
//       supplied callback function for every frame.
//-----------------------------------------------------------------------------
BOOL CD3DFrame::EnumFrames( BOOL (*EnumFramesCB)(CD3DFrame*,D3DXMATRIX*,VOID*),
                            VOID* pData )
{
    static D3DXMATRIX matWorld(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);

    D3DXMATRIX matSavedWorld = matWorld;
    D3DXMatrixMultiply( &matWorld, &m_matTransform, &matSavedWorld );
    
    EnumFramesCB( this, &matWorld, pData );

    if( m_pChild )
        m_pChild->EnumFrames( EnumFramesCB, pData );
    
    matWorld = matSavedWorld;

    if( m_pNext )
        m_pNext->EnumFrames( EnumFramesCB, pData );

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: RenderMeshSubsets()
// Desc: Renders the mesh geometry for the frame.
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::RenderMeshSubsets( LPDIRECT3DDEVICE8 pd3dDevice, 
                                      DWORD dwFirstSubset, DWORD dwLastSubset,
                                      DWORD dwFlags )
{
    if( NULL == m_pMeshVB )
        return E_FAIL;

    pd3dDevice->SetVertexShader( m_dwMeshFVF);
    pd3dDevice->SetStreamSource( 0, m_pMeshVB, m_dwMeshVertexSize );
    pd3dDevice->SetIndices( m_pMeshIB, 0 );

    // First, draw the subsets without alpha
    if( dwFlags & D3DFILE_RENDEROPAQUESUBSETS )
    {
        for( DWORD i=dwFirstSubset; i<=dwLastSubset; i++ )
        {
            if( m_pMeshSubsets[i].mtrl.Diffuse.a < 1.0f )
                continue;

			if ( D3DPT_TRIANGLESTRIP == m_dwMeshPrimType && g_bVisualizeStrips )
			{
				int iVisIndex = 0;

				UINT uIndexStart = m_pMeshSubsets[i].dwIndexStart;
				UINT uIndexEnd;

				UINT uIndexBufferEnd = m_pMeshSubsets[i].dwIndexStart + m_pMeshSubsets[i].dwIndexCount;

				WORD* pIndices = 0;
				UINT uIndexBufferSize = sizeof(WORD) * m_pMeshSubsets[i].dwIndexCount;
				m_pMeshIB->Lock(0, uIndexBufferSize, (BYTE**)&pIndices, D3DLOCK_READONLY);

				while (uIndexStart < uIndexBufferEnd)
				{
					// Find end of strip.
					for (uIndexEnd = uIndexStart+2; uIndexEnd < uIndexBufferEnd-1; uIndexEnd++)
					{
						// Check for duplicate verts.
						if (pIndices[uIndexEnd+1] == pIndices[uIndexEnd])
							break;
					}

					// Draw strip.
					pd3dDevice->SetMaterial( &g_VisualizationColors[iVisIndex++] );
					if (iVisIndex >= 6) iVisIndex = 0;

					pd3dDevice->DrawIndexedPrimitive( m_dwMeshPrimType, 0, m_dwNumMeshVertices, 
					                                  uIndexStart, uIndexEnd-uIndexStart-1 );

					if ((uIndexEnd-uIndexStart-1) & 1)
						uIndexStart = uIndexEnd+2;
					else
						uIndexStart = uIndexEnd+3;
				}

				m_pMeshIB->Unlock();
			}
			else
			{
				pd3dDevice->SetMaterial( &m_pMeshSubsets[i].mtrl );
				pd3dDevice->SetTexture( 0, m_pMeshSubsets[i].pTexture );

				DWORD dwNumPrimitives = m_pMeshSubsets[i].dwIndexCount/3;
				if( D3DPT_TRIANGLESTRIP == m_dwMeshPrimType ) 
					dwNumPrimitives = m_pMeshSubsets[i].dwIndexCount-2;

				pd3dDevice->DrawIndexedPrimitive( m_dwMeshPrimType, 0, m_dwNumMeshVertices,
												  m_pMeshSubsets[i].dwIndexStart, dwNumPrimitives );
			}
        }
    }

    // Then, draw the subsets with alpha
    if( dwFlags & D3DFILE_RENDERALPHASUBSETS )
    {
        for( DWORD i=dwFirstSubset; i<=dwLastSubset; i++ )
        {
            if( m_pMeshSubsets[i].mtrl.Diffuse.a >= 1.0f )
                continue;

			if ( D3DPT_TRIANGLESTRIP == m_dwMeshPrimType && g_bVisualizeStrips )
			{
				int iVisIndex = 0;

				UINT uIndexStart = m_pMeshSubsets[i].dwIndexStart;
				UINT uIndexEnd;

				UINT uIndexBufferEnd = m_pMeshSubsets[i].dwIndexStart + m_pMeshSubsets[i].dwIndexCount;

				WORD* pIndices = 0;
				UINT uIndexBufferSize = sizeof(WORD) * m_pMeshSubsets[i].dwIndexCount;
				m_pMeshIB->Lock(0, uIndexBufferSize, (BYTE**)&pIndices, D3DLOCK_READONLY);

				while (uIndexStart < uIndexBufferEnd)
				{
					// Find end of strip.
					for (uIndexEnd = uIndexStart+2; uIndexEnd < uIndexBufferEnd-1; uIndexEnd++)
					{
						// Check for duplicate verts.
						if (pIndices[uIndexEnd+1] == pIndices[uIndexEnd])
							break;
					}

					// Draw strip.
					pd3dDevice->SetMaterial( &g_VisualizationColors[iVisIndex++] );
					if (iVisIndex >= 6) iVisIndex = 0;

					pd3dDevice->DrawIndexedPrimitive( m_dwMeshPrimType, 0, m_dwNumMeshVertices, 
					                                  uIndexStart, uIndexEnd-uIndexStart-1 );

					if ((uIndexEnd-uIndexStart-1) & 1)
						uIndexStart = uIndexEnd+2;
					else
						uIndexStart = uIndexEnd+3;
				}

				m_pMeshIB->Unlock();
			}
			else
			{
				pd3dDevice->SetMaterial( &m_pMeshSubsets[i].mtrl );
				pd3dDevice->SetTexture( 0, m_pMeshSubsets[i].pTexture );

				DWORD dwNumPrimitives = m_pMeshSubsets[i].dwIndexCount/3;
				if( D3DPT_TRIANGLESTRIP == m_dwMeshPrimType ) 
					dwNumPrimitives = m_pMeshSubsets[i].dwIndexCount-2;
           
				pd3dDevice->DrawIndexedPrimitive( m_dwMeshPrimType, 0, m_dwNumMeshVertices,
												  m_pMeshSubsets[i].dwIndexStart, dwNumPrimitives );
			}
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the current frame's mesh. This function is called recursively
//       to render the entire frame hierarchy.
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags )
{
    // Apply the matrix transform for this frame
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &m_matTransform, &matSavedWorld );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Render the mesh subsets
    if( m_dwNumMeshSubsets )
    {
        // Render the mesh. This hubbub is simply to allow different rendering
        // options, specifically allowing to highlight "visible" frames and a
        // "selected" subset.
        if( ( TRUE == m_bVisible ) && ( dwFlags & D3DFILE_RENDERVISIBLEFRAMES ) )
        {
            if( m_lSelectedSubset != -1 )
                RenderMeshSubsets( pd3dDevice, m_lSelectedSubset, m_lSelectedSubset, dwFlags );
            else
                RenderMeshSubsets( pd3dDevice, 0, m_dwNumMeshSubsets-1, dwFlags );
        }
        if( dwFlags & D3DFILE_RENDERALLFRAMES )
        {
            RenderMeshSubsets( pd3dDevice, 0, m_dwNumMeshSubsets-1, dwFlags );
        }
    }

    // Render any child frames
    if( m_pChild )
        m_pChild->Render( pd3dDevice, dwFlags );

    // Restore the matrix transform
    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );

    // Render any sibling frames
    if( m_pNext )
        m_pNext->Render( pd3dDevice, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Unstrip()
// Desc: Turn strips back into triangle a triangle list, removing degenerates.
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::Unstrip()
{
    if( D3DPT_TRIANGLESTRIP != m_dwMeshPrimType ) 
	{
		return E_FAIL;
	}

    // Get a d3d device (needed for creating buffers)
    LPDIRECT3DDEVICE8 pd3dDevice;
    m_pMeshVB->GetDevice( &pd3dDevice );
    pd3dDevice->Release();

    // Gain access to the vertices and indices for the mesh
    BYTE* pSrcVertices;
    WORD* pSrcIndices;
    m_pMeshVB->Lock( 0, 0, (BYTE**)&pSrcVertices, 0 );
    m_pMeshIB->Lock( 0, 0, (BYTE**)&pSrcIndices, 0 );

    WORD*  pGlobalTriangleIndices     = new WORD[m_dwNumMeshIndices*3];
    DWORD  dwGlobalTriangleIndexCount = 0;

    for( DWORD i = 0; i < m_dwNumMeshSubsets; i++ )
    {
        WORD* pIndices     = &pSrcIndices[m_pMeshSubsets[i].dwIndexStart];
        DWORD dwNumIndices = m_pMeshSubsets[i].dwIndexCount;

        WORD* pTriangleIndices     = &pGlobalTriangleIndices[dwGlobalTriangleIndexCount];
		DWORD dwNumTriangleIndices = 0;
            
        // Unstrip the indices.
		WORD ind0 = 0;
		WORD ind1 = pIndices[0];
		WORD ind2 = pIndices[1];

		for( DWORD src = 2; src < dwNumIndices; src++ )
		{
			ind0 = ind1;
			ind1 = ind2;
			ind2 = pIndices[src];
			
			if (ind0 != ind1 && ind1 != ind2 && ind2 != ind0)
			{
				if (src & 1)
				{
					pTriangleIndices[dwNumTriangleIndices] = ind2;
					dwNumTriangleIndices++;

					pTriangleIndices[dwNumTriangleIndices] = ind1;
					dwNumTriangleIndices++;

					pTriangleIndices[dwNumTriangleIndices] = ind0;
					dwNumTriangleIndices++;
				}
				else
				{
					pTriangleIndices[dwNumTriangleIndices] = ind0;
					dwNumTriangleIndices++;

					pTriangleIndices[dwNumTriangleIndices] = ind1;
					dwNumTriangleIndices++;

					pTriangleIndices[dwNumTriangleIndices] = ind2;
					dwNumTriangleIndices++;
				}
			}
		}

        m_pMeshSubsets[i].dwIndexStart = dwGlobalTriangleIndexCount;
        m_pMeshSubsets[i].dwIndexCount = dwNumTriangleIndices;
		dwGlobalTriangleIndexCount += dwNumTriangleIndices;
    }

    // Create an index buffer for using DrawIndexedPrimitive.
    LPDIRECT3DINDEXBUFFER8 pNewIB;
    pd3dDevice->CreateIndexBuffer( dwGlobalTriangleIndexCount * sizeof(WORD),
                                   D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                   D3DPOOL_MANAGED, &pNewIB );

    // Lock and fill the index buffer
    WORD* pDstIndices;
    pNewIB->Lock( 0, 0, (BYTE**)&pDstIndices, 0 );
    memcpy( pDstIndices, pGlobalTriangleIndices, dwGlobalTriangleIndexCount * sizeof(WORD) );
    pNewIB->Unlock();

    // Free our copy of the indices.
    delete[] pGlobalTriangleIndices;

    // Assign the new buffers
    m_pMeshIB->Unlock();
    m_pMeshIB->Release();
    m_dwMeshPrimType   = D3DPT_TRIANGLELIST;
    m_pMeshIB          = pNewIB;
    m_dwNumMeshIndices = dwGlobalTriangleIndexCount;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Stripify()
// Desc: Turn the meshdata from a triangle list into an optimized triangle
//       strip.
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::Stripify( DWORD dwFlags )
{
    if( D3DPT_TRIANGLESTRIP == m_dwMeshPrimType ) 
	{
		Unstrip();
	}

    if( D3DPT_TRIANGLELIST != m_dwMeshPrimType ) 
	{
		return E_FAIL;
	}

    // Get a d3d device (needed for creating buffers)
    LPDIRECT3DDEVICE8 pd3dDevice;
    m_pMeshVB->GetDevice( &pd3dDevice );
    pd3dDevice->Release();

    // Gain access to the vertices and indices for the mesh
    BYTE* pSrcVertices;
    WORD* pSrcIndices;
    m_pMeshVB->Lock( 0, 0, (BYTE**)&pSrcVertices, 0 );
    m_pMeshIB->Lock( 0, 0, (BYTE**)&pSrcIndices, 0 );

    WORD*  pGlobalStrippedIndices     = NULL;
    DWORD  dwGlobalStrippedIndexCount = 0;

    for( DWORD i = 0; i < m_dwNumMeshSubsets; i++ )
    {
        WORD* pIndices     = &pSrcIndices[m_pMeshSubsets[i].dwIndexStart];
        DWORD dwNumIndices = m_pMeshSubsets[i].dwIndexCount;
            
        // Run the tri-list through our tri-stripper
        WORD* pStrippedIndices;
        DWORD dwNumStrippedIndices;
        ::Stripify( dwNumIndices/3, pIndices, &dwNumStrippedIndices, 
                    &pStrippedIndices, dwFlags );

        m_pMeshSubsets[i].dwIndexStart = dwGlobalStrippedIndexCount;
        m_pMeshSubsets[i].dwIndexCount = dwNumStrippedIndices;

        // Copy the new tri-stripped list into a public spot
        WORD* pNewStripData = new WORD[dwGlobalStrippedIndexCount+dwNumStrippedIndices];
        memcpy( &pNewStripData[0], pGlobalStrippedIndices, 
                sizeof(WORD)*dwGlobalStrippedIndexCount );
        memcpy( &pNewStripData[dwGlobalStrippedIndexCount], pStrippedIndices, 
                sizeof(WORD)*dwNumStrippedIndices );

		delete[] pStrippedIndices;
        
        if( pGlobalStrippedIndices )
            delete pGlobalStrippedIndices;
        pGlobalStrippedIndices      = pNewStripData;
        dwGlobalStrippedIndexCount += dwNumStrippedIndices;
    }

    // Sort the vertices...
    WORD* pVertexPermutation; // Array for sorting
    ComputeVertexPermutation( dwGlobalStrippedIndexCount, pGlobalStrippedIndices,
                              m_dwNumMeshVertices, &pVertexPermutation );

    // Create a new vertex buffer
    LPDIRECT3DVERTEXBUFFER8 pNewVB;
    pd3dDevice->CreateVertexBuffer( m_dwNumMeshVertices * m_dwMeshVertexSize, 
                                    D3DUSAGE_WRITEONLY, 0, D3DPOOL_MANAGED, 
                                    &pNewVB );

    // Lock and fill the vertex buffer, remapping vertices through the
    // vertex permutation array.
    BYTE* pDstVertices;
    pNewVB->Lock( 0, 0, (BYTE**)&pDstVertices, 0 );
    for( i = 0; i < m_dwNumMeshVertices; i++ )
        memcpy( &pDstVertices[m_dwMeshVertexSize*i], 
                &pSrcVertices[m_dwMeshVertexSize*pVertexPermutation[i]], 
                m_dwMeshVertexSize );
    pNewVB->Unlock();

    // Free the array allocated by the ComputeVertexPermutation() call
    delete[] pVertexPermutation;

    // Create an index buffer for using DrawIndexedPrimitive.
    LPDIRECT3DINDEXBUFFER8 pNewIB;
    pd3dDevice->CreateIndexBuffer( dwGlobalStrippedIndexCount * sizeof(WORD),
                                   D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                   D3DPOOL_MANAGED, &pNewIB );

    // Lock and fill the index buffer
    WORD* pDstIndices;
    pNewIB->Lock( 0, 0, (BYTE**)&pDstIndices, 0 );
    memcpy( pDstIndices, pGlobalStrippedIndices, dwGlobalStrippedIndexCount * sizeof(WORD) );
    pNewIB->Unlock();

    // Free the array allocated by the Stripify() call
    delete[] pGlobalStrippedIndices;

    // Assign the new buffers
    m_pMeshVB->Unlock();
    m_pMeshIB->Unlock();
    m_pMeshVB->Release();
    m_pMeshIB->Release();
    m_pMeshVB          = pNewVB;
    m_pMeshIB          = pNewIB;

	if( dwFlags & OUTPUT_TRILIST )
		m_dwMeshPrimType   = D3DPT_TRIANGLELIST;
	else
		m_dwMeshPrimType   = D3DPT_TRIANGLESTRIP;

    m_dwNumMeshIndices = dwGlobalStrippedIndexCount;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\Installer\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\FVF.h ===
//-----------------------------------------------------------------------------
// File: FVF.h
//
// Desc: Code for dealing with flexible vertex formats.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef FVF_H
#define FVF_H




//-----------------------------------------------------------------------------
// Name: struct VERTEXFORMAT
// Desc: Holds informations about vertex components
//-----------------------------------------------------------------------------
struct VERTEXFORMAT
{
    BOOL  bPosition;
    DWORD dwNumBlendWeights;
    BOOL  bNormal;
    BOOL  bDiffuse;
    BOOL  bSpecular;
    DWORD dwNumTexCoords[4];

    DWORD dwPositionOffset;
    DWORD dwBlendWeightsOffset;
    DWORD dwNormalOffset;
    DWORD dwDiffuseOffset;
    DWORD dwSpecularOffset;
    DWORD dwTexCoordsOffset[4];

    DWORD dwVertexSize;
};




//-----------------------------------------------------------------------------
// Name: CrackFVF()
// Desc: Dissects an FVF code into vertex component descriptions stored in
//       the VERTEXFORMAT structure.
//-----------------------------------------------------------------------------
VOID  CrackFVF( DWORD dwFVF, VERTEXFORMAT& fvf );




//-----------------------------------------------------------------------------
// Name: EncodeFVF()
// Desc: Builds an FVF code from the vertex component descriptions stores in
//       the VERTEXFORMAT structure.
//-----------------------------------------------------------------------------
DWORD EncodeFVF( VERTEXFORMAT& fvf );




//-----------------------------------------------------------------------------
// Name: CopyVertexBufferWithNewFVF()
// Desc: Makes a copy of a vertex buffer, using a new FVF code.
//-----------------------------------------------------------------------------
HRESULT CopyVertexBufferWithNewFVF( LPDIRECT3DVERTEXBUFFER8 pOldVB, DWORD dwNumVertices,
                                    DWORD dwOldFVF, DWORD dwNewFVF,
                                    LPDIRECT3DVERTEXBUFFER8* ppNewVB );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\FVF.cpp ===
//-----------------------------------------------------------------------------
// File: FVF.cpp
//
// Desc: Code for dealing with flexible vertex formats.
//
// Hist: 03.01.01 - New for April XDK release
//       11.08.01 - Fixed FVF-cracking problem
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include <d3dx8.h>
#include "FVF.h"




//-----------------------------------------------------------------------------
// Name: CrackFVF()
// Desc: Cracks an FVF code into individual pieces stored in a VERTEXFORMAT
//       structure. It makes life easier when deailing with vertices of any
//       format.
//-----------------------------------------------------------------------------
VOID CrackFVF( DWORD dwFVF, VERTEXFORMAT& fvf )
{
    DWORD dwOffset = 0;
    ZeroMemory( &fvf, sizeof(fvf) );

    // Handle position
    if( dwFVF & D3DFVF_XYZ )
    {
        fvf.bPosition        = TRUE;
        fvf.dwPositionOffset = dwOffset;
        dwOffset += 3 * sizeof(FLOAT);
    }

    // Handle blendweights
    switch( dwFVF & D3DFVF_POSITION_MASK )
    {
        case D3DFVF_XYZB1: fvf.dwNumBlendWeights = 1; break;
        case D3DFVF_XYZB2: fvf.dwNumBlendWeights = 2; break;
        case D3DFVF_XYZB3: fvf.dwNumBlendWeights = 3; break;
        case D3DFVF_XYZB4: fvf.dwNumBlendWeights = 4; break;
        default:           fvf.dwNumBlendWeights = 0; break;
    }
    fvf.dwBlendWeightsOffset = dwOffset;
    dwOffset += fvf.dwNumBlendWeights * sizeof(FLOAT);

    // Handle normal
    if( dwFVF & D3DFVF_NORMAL )
    {
        fvf.bNormal        = TRUE;
        fvf.dwNormalOffset = dwOffset;
        dwOffset += 3 * sizeof(FLOAT);
    }

    // Handle diffuse
    if( dwFVF & D3DFVF_DIFFUSE )
    {
        fvf.bDiffuse        = TRUE;
        fvf.dwDiffuseOffset = dwOffset;
        dwOffset += sizeof(DWORD);
    }

    // Handle specular
    if( dwFVF & D3DFVF_SPECULAR )
    {
        fvf.bSpecular        = TRUE;
        fvf.dwSpecularOffset = dwOffset;
        dwOffset += sizeof(DWORD);
    }

    // Handle texturecoods
    DWORD dwNumTexStages = ( dwFVF & D3DFVF_TEXCOUNT_MASK ) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<4; i++ )
    {
        fvf.dwNumTexCoords[i] = 0;

        if( i < dwNumTexStages )
        {
            DWORD dwNumTexturesCode = 0x00000003 & ( dwFVF >> (i*2+16) );
            if( D3DFVF_TEXTUREFORMAT1 == dwNumTexturesCode )
                fvf.dwNumTexCoords[i] = 1;
            if( D3DFVF_TEXTUREFORMAT2 == dwNumTexturesCode )
                fvf.dwNumTexCoords[i] = 2;
            if( D3DFVF_TEXTUREFORMAT3 == dwNumTexturesCode )
                fvf.dwNumTexCoords[i] = 3;
            if( D3DFVF_TEXTUREFORMAT4 == dwNumTexturesCode )
                fvf.dwNumTexCoords[i] = 4;
        
            fvf.dwTexCoordsOffset[i] = dwOffset;
            dwOffset += fvf.dwNumTexCoords[i] * sizeof(FLOAT);
        }
    }

    fvf.dwVertexSize = dwOffset;
}




//-----------------------------------------------------------------------------
// Name: EncodeFVF()
// Desc: The opposite of CrackFVF, this builds an FVF code from the vertex
//       description in the VERTEXFORMAT structure.
//-----------------------------------------------------------------------------
DWORD EncodeFVF( VERTEXFORMAT& fvf )
{
    DWORD dwFVF = 0;

    // Handle position and blendweights
    switch( fvf.dwNumBlendWeights )
    {
        case 0: dwFVF = D3DFVF_XYZ;   break;
        case 1: dwFVF = D3DFVF_XYZB1; break;
        case 2: dwFVF = D3DFVF_XYZB2; break;
        case 3: dwFVF = D3DFVF_XYZB3; break;
        case 4: dwFVF = D3DFVF_XYZB4; break;
    }

    // Handle normal, diffuse, and specular
    if( fvf.bNormal )   dwFVF |= D3DFVF_NORMAL;
    if( fvf.bDiffuse )  dwFVF |= D3DFVF_DIFFUSE;
    if( fvf.bSpecular ) dwFVF |= D3DFVF_SPECULAR;

    DWORD dwNumTexStages = 0;

    // Handle texturecoods
    for( DWORD i=0; i<4; i++ )
    {
        if( fvf.dwNumTexCoords[i] > 0 )
        {
            dwNumTexStages++;
            if( fvf.dwNumTexCoords[i] == 1 ) dwFVF |= D3DFVF_TEXCOORDSIZE1(i);
            if( fvf.dwNumTexCoords[i] == 2 ) dwFVF |= D3DFVF_TEXCOORDSIZE2(i);
            if( fvf.dwNumTexCoords[i] == 3 ) dwFVF |= D3DFVF_TEXCOORDSIZE3(i);
            if( fvf.dwNumTexCoords[i] == 4 ) dwFVF |= D3DFVF_TEXCOORDSIZE4(i);
        }
    }

    dwFVF |= ( dwNumTexStages << D3DFVF_TEXCOUNT_SHIFT );

    return dwFVF;
}




//-----------------------------------------------------------------------------
// Name: CopyVertexBufferWithNewFVF()
// Desc: Makes a copy of a vertex buffer, using a new FVF code.
//-----------------------------------------------------------------------------
HRESULT CopyVertexBufferWithNewFVF( LPDIRECT3DVERTEXBUFFER8 pOldVB, DWORD dwNumVertices,
                                    DWORD dwOldFVF, DWORD dwNewFVF,
                                    LPDIRECT3DVERTEXBUFFER8* ppNewVB )
{
    // Crack the FVF codes
    VERTEXFORMAT fvfOld;
    VERTEXFORMAT fvfNew;
    CrackFVF( dwOldFVF, fvfOld );
    CrackFVF( dwNewFVF, fvfNew );

    // Create new vertex buffer
    LPDIRECT3DDEVICE8 pd3dDevice;
    pOldVB->GetDevice( &pd3dDevice );
    pd3dDevice->CreateVertexBuffer( dwNumVertices * fvfNew.dwVertexSize, 
                                    D3DUSAGE_WRITEONLY, 0, D3DPOOL_MANAGED, 
                                    ppNewVB );
    pd3dDevice->Release();
    
    // Copy vertices
    BYTE* pDstVertices;
    BYTE* pSrcVertices;
    pOldVB->Lock( 0, 0, (BYTE**)&pSrcVertices, 0 );
    (*ppNewVB)->Lock( 0, 0, (BYTE**)&pDstVertices, 0 );
    
    for( DWORD i=0; i<dwNumVertices; i++ )
    {
        D3DXVECTOR3 vPos( 0.0f, 0.0f, 0.0f );
        FLOAT       fWeights[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
        D3DXVECTOR3 vNormal( 0.0f, 0.0f, 0.0f );
        DWORD       dwDiffuse  = 0x00000000;
        DWORD       dwSpecular = 0x00000000;
        D3DXVECTOR4 vT0( 0.0f, 0.0f, 0.0f, 0.0f );
        D3DXVECTOR4 vT1( 0.0f, 0.0f, 0.0f, 0.0f );
        D3DXVECTOR4 vT2( 0.0f, 0.0f, 0.0f, 0.0f );
        D3DXVECTOR4 vT3( 0.0f, 0.0f, 0.0f, 0.0f );

        // Get source position
        if( fvfOld.bPosition )
            memcpy( &vPos, pSrcVertices+fvfOld.dwPositionOffset, sizeof(D3DXVECTOR3) );

        // Get source blend weights
        memcpy( &fWeights[0], pSrcVertices+fvfOld.dwBlendWeightsOffset, fvfOld.dwNumBlendWeights * sizeof(FLOAT) );

        // Get source normal, diffuse, and specular
        if( fvfOld.bNormal )   memcpy( &vNormal,    pSrcVertices+fvfOld.dwNormalOffset, sizeof(D3DXVECTOR3) );
        if( fvfOld.bDiffuse )  memcpy( &dwDiffuse,  pSrcVertices+fvfOld.dwDiffuseOffset, sizeof(DWORD) );
        if( fvfOld.bSpecular ) memcpy( &dwSpecular, pSrcVertices+fvfOld.dwSpecularOffset, sizeof(DWORD) );

        // Get source texture coords
        memcpy( &vT0, pSrcVertices+fvfOld.dwTexCoordsOffset[0], fvfOld.dwNumTexCoords[0] * sizeof(FLOAT) );
        memcpy( &vT1, pSrcVertices+fvfOld.dwTexCoordsOffset[1], fvfOld.dwNumTexCoords[1] * sizeof(FLOAT) );
        memcpy( &vT2, pSrcVertices+fvfOld.dwTexCoordsOffset[2], fvfOld.dwNumTexCoords[2] * sizeof(FLOAT) );
        memcpy( &vT3, pSrcVertices+fvfOld.dwTexCoordsOffset[3], fvfOld.dwNumTexCoords[3] * sizeof(FLOAT) );

        // Write destination position
        if( fvfNew.bPosition )
            memcpy( pDstVertices+fvfNew.dwPositionOffset, &vPos, sizeof(D3DXVECTOR3) );

        // Write destination blend weights
        memcpy( pDstVertices+fvfNew.dwBlendWeightsOffset, &fWeights[0], fvfOld.dwNumBlendWeights * sizeof(FLOAT) );

        // Write destination normal, diffuse, and specular
        if( fvfNew.bNormal )   memcpy( pDstVertices+fvfNew.dwNormalOffset,   &vNormal,    sizeof(D3DXVECTOR3) );
        if( fvfNew.bDiffuse )  memcpy( pDstVertices+fvfNew.dwDiffuseOffset,  &dwDiffuse,  sizeof(DWORD) );
        if( fvfNew.bSpecular ) memcpy( pDstVertices+fvfNew.dwSpecularOffset, &dwSpecular, sizeof(DWORD) );

        // Write destination texture coords
        memcpy( pDstVertices+fvfNew.dwTexCoordsOffset[0], &vT0, fvfNew.dwNumTexCoords[0] * sizeof(FLOAT) );
        memcpy( pDstVertices+fvfNew.dwTexCoordsOffset[1], &vT1, fvfNew.dwNumTexCoords[1] * sizeof(FLOAT) );
        memcpy( pDstVertices+fvfNew.dwTexCoordsOffset[2], &vT2, fvfNew.dwNumTexCoords[2] * sizeof(FLOAT) );
        memcpy( pDstVertices+fvfNew.dwTexCoordsOffset[3], &vT3, fvfNew.dwNumTexCoords[3] * sizeof(FLOAT) );
        
        // Advance to the new vertex
        pSrcVertices += fvfOld.dwVertexSize;
        pDstVertices += fvfNew.dwVertexSize;
    }
    
    pOldVB->Unlock();
    (*ppNewVB)->Unlock();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\LoadOptionsDlg.cpp ===
//-----------------------------------------------------------------------------
// File: LoadOptionsDlg.cpp
//
// Desc: Code to implement a dialog to let the user specifiy load options.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "MakeXBG.h"
#include "LoadOptionsDlg.h"
#include "FVF.h"




//-----------------------------------------------------------------------------
// Name: CLoadOptionsDlg()
// Desc: Constructor
//-----------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(CLoadOptionsDlg, CDialog)

CLoadOptionsDlg::CLoadOptionsDlg( CWnd* pParent /*=NULL*/ )
	      :CDialog(CLoadOptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLoadOptionsDlg)
	//}}AFX_DATA_INIT
}




//-----------------------------------------------------------------------------
// Name: DoDataExchange()
// Desc: 
//-----------------------------------------------------------------------------
void CLoadOptionsDlg::DoDataExchange( CDataExchange* pDX )
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLoadOptionsDlg)
	//}}AFX_DATA_MAP

	if( pDX->m_bSaveAndValidate )
	{
		m_bCollapseMesh = ((CButton*)GetDlgItem(IDC_COLLAPSEMESH))->GetCheck();
	}
	else
	{
		((CButton*)GetDlgItem(IDC_COLLAPSEMESH))->SetCheck( TRUE );
	}
}




BEGIN_MESSAGE_MAP(CLoadOptionsDlg, CDialog)
	//{{AFX_MSG_MAP(CLoadOptionsDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\MakeXBG.h ===
//-----------------------------------------------------------------------------
// File: MakeXBG.h
//
// Desc: App to convert DirectX geoemtry files (.x) into .xbg geometry files that
//       are more suited for Xbox apps. See the XBG.h header file for a better
//       description of .xbg geometry files.
//
// Hist: 03.01.00 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "AFXCView.h"
#include "Resource.h"
#include "XBG.h"




//-----------------------------------------------------------------------------
// Name: class CMakeXBGApp
// Desc: The main application class
//-----------------------------------------------------------------------------
class CMakeXBGApp : public CWinApp
{
public:
    CMakeXBGApp();
    ~CMakeXBGApp();

// Overrides
    virtual BOOL InitInstance();

// Implementation
    //{{AFX_MSG(CMakeXBGApp)
    afx_msg void OnAppAbout();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};




//-----------------------------------------------------------------------------
// Name: class CXBGDocument
// Desc: The main document class
//-----------------------------------------------------------------------------
class CXBGDocument : public CDocument
{
protected: // create from serialization only
    CXBGDocument();
    DECLARE_SERIAL(CXBGDocument)

public:
    // Load options
    CString m_strFilename;    // Filename
    BOOL    m_bCollapseMesh;  // Whether to collapse geometry to one mesh

    // Data from loaded file
    CD3DFile*  m_pD3DFile;

    // Data for displaying object's attributes
    CTreeCtrl* m_pTreeCtrl;
    CD3DFrame* m_pSelectedFrame;
    LONG       m_lSelectedSubset;

// Implementation
public:
    virtual ~CXBGDocument();
    virtual void Serialize(CArchive& ar);   // overridden for document i/o
protected:
    virtual BOOL    OnOpenDocument( LPCTSTR strFilename );

// Generated message map functions
protected:
    //{{AFX_MSG(CXBGDocument)
    afx_msg void OnSetMeshFVF();
    afx_msg void OnStripify();
    afx_msg void OnFileSave();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};




//-----------------------------------------------------------------------------
// Name: class CModelTreeView
// Desc: The tree view class
//-----------------------------------------------------------------------------
class CModelTreeView : public CTreeView
{
protected: // create from serialization only
    CModelTreeView();
    DECLARE_DYNCREATE(CModelTreeView)

// Attributes
public:
    CXBGDocument* GetDocument() { return (CXBGDocument*)m_pDocument; }

// Operations
public:

// Implementation
public:
    virtual ~CModelTreeView();
    virtual void OnUpdate( CView* pSender, LPARAM lHint, CObject* pHint );

// Generated message map functions
protected:
    //{{AFX_MSG(CModelTreeView)
    afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};




//-----------------------------------------------------------------------------
// Name: class CModelRenderView
// Desc: The render view (renders the geoemtry model using D3D)
//-----------------------------------------------------------------------------
class CModelRenderView : public CView
{
    // ArcBall parameters
    D3DXQUATERNION m_qDown;          // Quaternion before button down
    D3DXQUATERNION m_qNow;           // Composite quaternion for current drag
    D3DXMATRIX     m_matRotation;    // Matrix for arcball's orientation
    D3DXMATRIX     m_matTranslation; // Matrix for arcball's position
    BOOL           m_bDrag;          // Whether user is dragging arcball
    D3DXVECTOR3    m_vDown;          // Button down vector
    D3DXVECTOR3    m_vCur;           // Current vector
    D3DXVECTOR3 ScreenToVector( int sx, int sy );

    // Rendering objects
    LPDIRECT3DDEVICE8 m_pd3dDevice;
    D3DXMATRIX        m_matWorld; 

protected: // create from serialization only
    CModelRenderView();
    DECLARE_DYNCREATE(CModelRenderView)

// Attributes
public:
    CXBGDocument* GetDocument() { return (CXBGDocument*) m_pDocument; }

// Operations
public:

// Implementation
public:
    virtual ~CModelRenderView();
    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    virtual void OnInitialUpdate();

// Generated message map functions
protected:
    //{{AFX_MSG(CModelRenderView)
    afx_msg void OnDestroy();
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};




//-----------------------------------------------------------------------------
// Name: class CSplitterFrame
// Desc: Class to implement a splitter.
//-----------------------------------------------------------------------------
class CSplitterFrame : public CMDIChildWnd
{
    DECLARE_DYNCREATE(CSplitterFrame)
protected:
    CSplitterFrame();   // protected constructor used by dynamic creation

// Attributes
protected:
    CSplitterWnd      m_wndSplitter;
public:
    CModelTreeView*   m_pTreeView;
    CModelRenderView* m_pD3DRenderView;

// Implementation
public:
    virtual ~CSplitterFrame();
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

    // Generated message map functions
    //{{AFX_MSG(CSplitterFrame)
    afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};




//-----------------------------------------------------------------------------
// Name: class CMainSplitterWnd
// Desc: Class to implement a splitter.
//-----------------------------------------------------------------------------
class CMainSplitterWnd : public CSplitterWnd
{
    DECLARE_DYNAMIC(CMainSplitterWnd)

// Implementation
public:
    CMainSplitterWnd();
    ~CMainSplitterWnd();
    CWnd* GetActivePane(int* pRow = NULL, int* pCol = NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\MakeXBG.cpp ===
//-----------------------------------------------------------------------------
// File: MakeXBG.cpp
//
// Desc: App to convert DirectX geoemtry files (.x) into .xbg geometry files that
//       are more suited for Xbox apps.
//
//       See the XBG.h header file for a better description of .xbg geometry
//       files.
//
// Hist: 02.01.01 - New for March XDK release
//       03.01.01 - Heavily revised for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "MakeXBG.h"
#include "SetMeshFvfDlg.h"
#include "StripifyDlg.h"
#include "LoadOptionsDlg.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------
CMakeXBGApp NEAR g_App;
LPDIRECT3D8      g_pD3D  = NULL;
D3DDISPLAYMODE   g_d3ddm;




//-----------------------------------------------------------------------------
// Name: CMakeXBGApp()
// Desc: Constructor
//-----------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CMakeXBGApp, CWinApp)
    //{{AFX_MSG_MAP(CMakeXBGApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

CMakeXBGApp::CMakeXBGApp()
{
}

CMakeXBGApp::~CMakeXBGApp()
{
    // Done with the D3D object
    if( g_pD3D )
        g_pD3D->Release();
}




//-----------------------------------------------------------------------------
// Name: InitInstance()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CMakeXBGApp::InitInstance()
{
    // Create the D3D object, which is needed to create the D3DDevice.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return FALSE;

    // Get the current desktop display mode
    if( FAILED( g_pD3D->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &g_d3ddm ) ) )
        return FALSE;

    // Standard initialization
    Enable3dControls();

    // Add a splitter frame with a tree view and a d3d render view
    AddDocTemplate(new CMultiDocTemplate( IDR_DOCTEMPLATETYPE,
                                          RUNTIME_CLASS(CXBGDocument),
                                          RUNTIME_CLASS(CSplitterFrame),
                                          RUNTIME_CLASS(CModelRenderView)) );

    // create main MDI Frame window
    // Please note that for simple MDI Frame windows with no toolbar,
    //   status bar or other special behavior, the CMDIFrameWnd class
    //   can be used directly for the main frame window just as the
    //   CMDIChildWnd can be use for a document frame window.

    CMDIFrameWnd* pMainFrame = new CMDIFrameWnd;

    // Tell MFC to let us have at least a little control over the menus
    pMainFrame->m_bAutoMenuEnable = FALSE;
    
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;

    // Also in this example, there is only one menubar shared between
    //  all the views.  The automatic menu enabling support of MFC
    //  will disable the menu items that don't apply based on the
    //  currently active view.  The one MenuBar is used for all
    //  document types, including when there are no open documents.

    // Now finally show the main menu
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();
    m_pMainWnd = pMainFrame;


    // command line arguments are ignored, create a new (empty) document
    OnFileOpen();

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: OnAppAbout()
// Desc: 
//-----------------------------------------------------------------------------
void CMakeXBGApp::OnAppAbout()
{
    CDialog(IDD_ABOUTBOX).DoModal();
}




//-----------------------------------------------------------------------------
// Name: CXBGDocument()
// Desc: Message map, constructor and destructor
//-----------------------------------------------------------------------------
IMPLEMENT_SERIAL(CXBGDocument, CDocument, 0 /* schema number*/ )

BEGIN_MESSAGE_MAP(CXBGDocument, CDocument)
    //{{AFX_MSG_MAP(CXBGDocument)
    ON_COMMAND(IDM_SETMESHFVF, OnSetMeshFVF)
    ON_COMMAND(IDM_STRIPIFY, OnStripify)
    ON_COMMAND(ID_FILE_SAVE, OnFileSave)
    ON_COMMAND(ID_FILE_SAVE_AS, OnFileSave)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CXBGDocument::CXBGDocument()
{
    m_pD3DFile         = NULL;
    m_pSelectedFrame   = NULL;
    m_lSelectedSubset  = -1;
}

CXBGDocument::~CXBGDocument()
{
    if( m_pD3DFile )
        delete m_pD3DFile;
}




//-----------------------------------------------------------------------------
// Name: OnOpenDocument()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CXBGDocument::OnOpenDocument( LPCTSTR strFilename )
{
    if (!CDocument::OnNewDocument())
        return FALSE;
    
    m_strFilename   = strFilename;
    m_bCollapseMesh = FALSE;

    // Check if this is a .x file
    TCHAR* strFileType = _tcsrchr( strFilename, _T('.') );
    if( strFileType && !_tcsicmp( strFileType, _T(".x") ) )
    {
        // If so, display an options dialog, to see if the user wants to load
        // the geometry collapsed into one mesh, or to retain the frame
        // hierarchy
        CLoadOptionsDlg dlg;
        if (dlg.DoModal() != IDOK)
            return TRUE;

        m_bCollapseMesh = dlg.m_bCollapseMesh;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: Serialize()
// Desc: 
//-----------------------------------------------------------------------------
void CXBGDocument::Serialize(CArchive&)
{
    OnFileSave();
}




//-----------------------------------------------------------------------------
// Name: OnSetMeshFVF()
// Desc: 
//-----------------------------------------------------------------------------
void CXBGDocument::OnSetMeshFVF()
{
    if( m_pSelectedFrame && m_pSelectedFrame->m_dwMeshFVF )
    {
        CSetMeshFvfDlg dlg;
        dlg.m_dwFVF = m_pSelectedFrame->m_dwMeshFVF;

        if (dlg.DoModal() != IDOK)
            return;

        // A new FVF was chosen, so enact it
        m_pSelectedFrame->SetMeshFVF( dlg.m_dwFVF );

        // Rewrite the FVF code
        TCHAR strFVF[20];
        _stprintf( strFVF, _T("FVF = 0x%08lx"), m_pSelectedFrame->m_dwMeshFVF );
        m_pTreeCtrl->SetItemText( m_pSelectedFrame->m_hFVFTreeItem, strFVF );

        // Tag the document as modified
        SetModifiedFlag( TRUE );
    }
}




//-----------------------------------------------------------------------------
// Name: OnStripify()
// Desc: 
//-----------------------------------------------------------------------------
void CXBGDocument::OnStripify()
{
    if( m_pSelectedFrame && m_pSelectedFrame->m_dwMeshFVF )
    {
        StripifyDlg dlg;
        dlg.m_pFrame = m_pSelectedFrame;

        if (dlg.DoModal() != IDOK)
            return;
    }
}




//-----------------------------------------------------------------------------
// Name: OnFileSave()
// Desc: Writes the .xbg geoemtry file
//-----------------------------------------------------------------------------
void CXBGDocument::OnFileSave() 
{
    // Get the filename, with the .xbg prepended
    TCHAR strFilename[512]="*.xbg";
    _tcscpy( strFilename, m_strFilename );
    if( _tcsrchr( strFilename, _T('.') ) )
        _tcscpy( _tcsrchr( strFilename, _T('.') ), _T(".xbg") );
    
    // Build the filter string
    CString strFilter;
    strFilter += _T("Geometry Files (*.xbg)"); strFilter += _T('\0');
    strFilter += _T("*.xbg");                  strFilter += _T('\0');
    strFilter += _T("All Files (*.*)");        strFilter += _T('\0');
    strFilter += _T("*.*");                    strFilter += _T('\0');

    // Display the "file save as" dialog
    CFileDialog dlg( FALSE );
    dlg.m_ofn.nMaxCustFilter++;
    dlg.m_ofn.nMaxCustFilter++;
    dlg.m_ofn.lpstrFilter = strFilter;
    dlg.m_ofn.lpstrTitle  = _T("Save XBG File As...");
    dlg.m_ofn.lpstrFile   = strFilename;
    if( dlg.DoModal() )
    {
        // Save the file
        m_pD3DFile->WriteToXBG( strFilename );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\LoadOptionsDlg.h ===
//-----------------------------------------------------------------------------
// File: LoadOptionsDlg.h
//
// Desc: Code to implement a dialog to let the user specifiy load options.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// Name: class CLoadOptionsDlg
// Desc: A dialog to let the user specifiy load options.
//-----------------------------------------------------------------------------
class CLoadOptionsDlg : public CDialog
{
    DECLARE_DYNAMIC(CLoadOptionsDlg)
// Construction
public:
    CLoadOptionsDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
    //{{AFX_DATA(CLoadOptionsDlg)
    enum { IDD = IDD_XFILELOADOPTIONS };
    BOOL       m_bCollapseMesh;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CLoadOptionsDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\ReadXBG.cpp ===
//-----------------------------------------------------------------------------
// File: ReadXBG.cpp
//
// Desc: Reads a .xbg file into a CD3DFile class (with a hierarchy of CD3DFrame
//       classes).
//
//       See the XBG.h header file for a better description of .xbg geometry
//       files.
//
// NOTE: THIS CODE, AND THE FILE FORMAT IT CREATES, IS SUBJECT TO CHANGE. FEEL
//       FREE, AS WELL, TO EXPAND OR MODIFY THE FILE FORMAT TO FIT YOUR 
//       PERSONAL REQUIREMENTS.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <d3dx8.h>
#include "xbg.h"




//-----------------------------------------------------------------------------
// Name: PostLoadCB()
// Desc: Frame enumeration callback to compute the bounding sphere radius
//-----------------------------------------------------------------------------
BOOL PostLoadCB( CD3DFrame* pFrame, D3DXMATRIX* pmatWorld, VOID* pData )
{
    CD3DFile* pRoot = (CD3DFile*)pData;

    // Tag the frame
    pFrame->m_dwEnumeratedID = pRoot->m_dwNumFrames;

    // Add one to the frame count
    pRoot->m_dwNumFrames++;

    // Per mesh stuff
    if( pFrame->m_pMeshVB )
    {
        // Count primitives
        pRoot->m_dwNumMeshes++;
        pRoot->m_dwNumVertices += pFrame->m_dwNumMeshVertices;
        pRoot->m_dwNumIndices  += pFrame->m_dwNumMeshIndices;
        pRoot->m_dwNumPolygons += pFrame->m_dwNumMeshPolygons;

        // Compute the bounding sphere
        BYTE* pVertices;
        pFrame->m_pMeshVB->Lock( 0, 0, &pVertices, D3DLOCK_NOSYSLOCK );
        D3DXComputeBoundingSphere( pVertices, pFrame->m_dwNumMeshVertices, pFrame->m_dwMeshFVF, 
                                   &pFrame->m_vMeshCenter, &pFrame->m_fMeshRadius );
        pFrame->m_pMeshVB->Unlock();

        D3DXVECTOR3 vMeshCenter = pFrame->m_vMeshCenter;
        D3DXVECTOR3 vMeshRadius = D3DXVECTOR3(pFrame->m_fMeshRadius,0,0);
        D3DXVec3TransformCoord( &vMeshCenter, &vMeshCenter, pmatWorld );
        D3DXVec3TransformCoord( &vMeshRadius, &vMeshRadius, pmatWorld );
        FLOAT fDistance = D3DXVec3Length( &vMeshCenter );
        FLOAT fRadius   = D3DXVec3Length( &vMeshRadius );
        pRoot->m_fRadius = max( pRoot->m_fRadius, fDistance + fRadius );
    }

    return TRUE;
}





//-----------------------------------------------------------------------------
// Name: LoadFromXBG()
// Desc: Loads a .xbg file
//-----------------------------------------------------------------------------
HRESULT CD3DFile::LoadFromXBG( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename )
{
    // Open the file
    FILE* file = fopen( strFilename, "rb" );
    if( file == NULL )
        return E_FAIL;

    // Read the magic number
    DWORD dwFileID;
    fread( &dwFileID, 1, sizeof(DWORD), file ); 

    if( dwFileID != XBG_FILE_ID )
    {
        fclose( file );
        return E_FAIL;
    }

    // Read in header
    DWORD dwNumMeshes;  // Number of meshes in files
    DWORD dwSysMemSize; // Num bytes needed for system memory objects
    DWORD dwVidMemSize; // Num bytes needed for video memory objects

    fread( &dwNumMeshes,  1, sizeof(DWORD), file );
    fread( &dwSysMemSize, 1, sizeof(DWORD), file );
    fread( &dwVidMemSize, 1, sizeof(DWORD), file );

    // Read in system memory objects
    VOID* pSysMemData = (VOID*)new BYTE[dwSysMemSize];
    fread( pSysMemData, dwSysMemSize, 1, file );

    // Read in video memory objects
    VOID* pVidMemData = (VOID*)new BYTE[dwVidMemSize];
    fread( pVidMemData, dwVidMemSize, 1, file ); 
    
    // Done with the file
    fclose( file );

    // Do post-load, per-mesh processing
    XBMESH_FRAME* pFrameData = (XBMESH_FRAME*)pSysMemData;

    DWORD dwSysMemBaseAddr = (DWORD)pSysMemData;
    DWORD dwVidMemBaseAddr = (DWORD)pVidMemData;

    for( DWORD i=0; i<dwNumMeshes; i++ )
    {
        XBMESH_FRAME* pFrame = &pFrameData[i];
        XBMESH_DATA*  pMesh  = &pFrameData[i].m_MeshData;

        // Patch the mesh data. Any pointers read from the file were stored as
        // file offsets. So, we simply need to add a base address to patch
        // things up.
        if( pFrame->m_pChild )
            pFrame->m_pChild  = (XBMESH_FRAME*)( (DWORD)pFrame->m_pChild - 16 + dwSysMemBaseAddr );
        if( pFrame->m_pNext )
            pFrame->m_pNext   = (XBMESH_FRAME*)( (DWORD)pFrame->m_pNext - 16 + dwSysMemBaseAddr );
        if( pMesh->m_pSubsets )
            pMesh->m_pSubsets = (XBMESH_SUBSET*)( (DWORD)pMesh->m_pSubsets - 16 + dwSysMemBaseAddr );
        if( pMesh->m_dwNumIndices )
            pMesh->m_IB.Data  = pMesh->m_IB.Data -16 + dwSysMemBaseAddr;
        if( pMesh->m_dwNumVertices )
            pMesh->m_VB.Data  = pMesh->m_VB.Data + dwVidMemBaseAddr;

        // Create any textures used by the meshes' subsets.
        for( DWORD j = 0; j < pMesh->m_dwNumSubsets; j++ )
        {
            XBMESH_SUBSET* pSubset = &pMesh->m_pSubsets[j];
    
            if( pSubset->strTexture[0] )
            {
                D3DFile_CreateTexture( pd3dDevice, pSubset->strTexture, 
                                       &pSubset->pTexture );
            }
            else
                pSubset->pTexture = NULL;
        }
    }

    // In one fail swoop, create the frame hierarchy
    m_pChild = new CD3DFrame( pd3dDevice, this, pFrameData );

    // Cleanup allocated memory
    delete pSysMemData;
    delete pVidMemData;

    // After loading the file, walk the nodes to count primitives and
    // compute the bounding sphere    
    m_dwNumFrames   = 0L;
    m_dwNumMeshes   = 0L;
    m_dwNumVertices = 0L;
    m_dwNumIndices  = 0L;
    m_dwNumPolygons = 0L;
    m_vCenter       = D3DXVECTOR3(0,0,0);
    m_fRadius       = 0.0f;
    EnumFrames( PostLoadCB, this );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CD3DFrame()
// Desc: Construct a new CD3DFrame from the data in a XBMESH_FRAME structure.
//-----------------------------------------------------------------------------
CD3DFrame::CD3DFrame( LPDIRECT3DDEVICE8 pd3dDevice, CD3DFrame* pParent, 
                      XBMESH_FRAME* pFrameData )
{
    // Frame info
    strcpy( m_strFrameName, pFrameData->m_strName );
    m_pParent         = pParent;
    m_pChild          = NULL;
    m_pNext           = NULL;
    
    m_bVisible        = TRUE;
    m_lSelectedSubset = -1;
    m_hFVFTreeItem    = 0L;
    m_TreeData        = 0L;

    // Mesh info
    m_vMeshCenter          = D3DXVECTOR3(0,0,0);
    m_fMeshRadius          = 0L;
    m_dwNumMeshPolygons    = 0L;

    // Copy info from XBMESH_FRAME structure
    m_matTransform = pFrameData->m_matTransform;

    m_pMeshVB           = NULL;
    m_dwNumMeshVertices = pFrameData->m_MeshData.m_dwNumVertices;
    m_pMeshIB           = NULL;
    m_dwNumMeshIndices  = pFrameData->m_MeshData.m_dwNumIndices;
    m_dwMeshFVF         = pFrameData->m_MeshData.m_dwFVF;
    m_dwMeshVertexSize  = pFrameData->m_MeshData.m_dwVertexSize;
    m_dwNumMeshSubsets  = pFrameData->m_MeshData.m_dwNumSubsets;
    m_pMeshSubsets      = NULL;

    // Convet the primitive type
    if( pFrameData->m_MeshData.m_dwPrimType == (D3DPRIMITIVETYPE)5 )
        m_dwMeshPrimType = D3DPT_TRIANGLELIST;
    else
        m_dwMeshPrimType = D3DPT_TRIANGLESTRIP;

    // Compute num polygons
    if( m_dwMeshPrimType == D3DPT_TRIANGLELIST )
        m_dwNumMeshPolygons = m_dwNumMeshIndices / 3;
    else // if D3DPT_TRIANGLESTRIP
        m_dwNumMeshPolygons = m_dwNumMeshIndices - 2;

    // Create the vertex buffer
    if( m_dwNumMeshVertices )
    {
        pd3dDevice->CreateVertexBuffer( m_dwNumMeshVertices*m_dwMeshVertexSize, 
                                        D3DUSAGE_WRITEONLY, 0, D3DPOOL_MANAGED, 
                                        &m_pMeshVB );
        VOID* pVertices;
        m_pMeshVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
        memcpy( pVertices, (VOID*)pFrameData->m_MeshData.m_VB.Data, m_dwNumMeshVertices*m_dwMeshVertexSize );
        m_pMeshVB->Unlock();
    }

    // Create the index buffer
    if( m_dwNumMeshIndices )
    {
        pd3dDevice->CreateIndexBuffer( m_dwNumMeshIndices*sizeof(WORD), 
                                       D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, 
                                       &m_pMeshIB );
        WORD* pIndices;
        m_pMeshIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );
        memcpy( pIndices, (VOID*)pFrameData->m_MeshData.m_IB.Data, m_dwNumMeshIndices*sizeof(WORD) );
        m_pMeshIB->Unlock();
    }

    // Create the subsets
    if( m_dwNumMeshSubsets )
    {
        m_pMeshSubsets = new XBMESH_SUBSET[m_dwNumMeshSubsets];
        memcpy( m_pMeshSubsets, pFrameData->m_MeshData.m_pSubsets, m_dwNumMeshSubsets*sizeof(XBMESH_SUBSET) );

    }

    // Create the child frame
    if( pFrameData->m_pChild )
        m_pChild = new CD3DFrame( pd3dDevice, this, pFrameData->m_pChild );

    // Create the sibling frame
    if( pFrameData->m_pNext )
        m_pNext = new CD3DFrame( pd3dDevice, pParent, pFrameData->m_pNext );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\ReadX.cpp ===
//-----------------------------------------------------------------------------
// File: ReadX.cpp
//
// Desc: Reads a .x file into a CD3DFile class (with a hierarchy of CD3DFrame
//       classes).
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <d3dx8.h>
#include <dxfile.h>
#include <rmxfguid.h>
#include <rmxftmpl.h>
#include "xbg.h"




//-----------------------------------------------------------------------------
// Name: FindRadiusCB()
// Desc: Frame enumeration callback to compute the bounding sphere radius
//-----------------------------------------------------------------------------
BOOL FindRadiusCB( CD3DFrame* pFrame, D3DXMATRIX* pmatWorld, VOID* pData )
{
    CD3DFile* pRoot = (CD3DFile*)pData;

    // Tag the frame
    pFrame->m_dwEnumeratedID = pRoot->m_dwNumFrames;

    // Add one to the frame count
    pRoot->m_dwNumFrames++;
    
    if( pFrame->m_pMeshVB )
    {
        pRoot->m_dwNumMeshes++;
        pRoot->m_dwNumVertices += pFrame->m_dwNumMeshVertices;
        pRoot->m_dwNumIndices  += pFrame->m_dwNumMeshIndices;
        pRoot->m_dwNumPolygons += pFrame->m_dwNumMeshPolygons;

        D3DXVECTOR3 vMeshCenter = pFrame->m_vMeshCenter;
        D3DXVECTOR3 vMeshRadius = D3DXVECTOR3(pFrame->m_fMeshRadius,0,0);
        D3DXVec3TransformCoord( &vMeshCenter, &vMeshCenter, pmatWorld );
        D3DXVec3TransformCoord( &vMeshRadius, &vMeshRadius, pmatWorld );
        FLOAT fDistance = D3DXVec3Length( &vMeshCenter );
        FLOAT fRadius   = D3DXVec3Length( &vMeshRadius );
        pRoot->m_fRadius = max( pRoot->m_fRadius, fDistance + fRadius );
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: LoadCollapsedMeshFromX()
// Desc: Reads .x file and collapses all frames to one mesh
//-----------------------------------------------------------------------------
HRESULT CD3DFile::LoadCollapsedMeshFromX( LPDIRECT3DDEVICE8 pd3dDevice, 
                                          TCHAR* strFilename )
{
    // Create the frame
    CD3DFrame* pFrame = new CD3DFrame( _T("") );
    if( FAILED( pFrame->CreateMesh( pd3dDevice, strFilename ) ) )
    {
        delete pFrame;
        return E_FAIL;
    }

    // Add new frame to the current frame
    m_pChild = pFrame;
    pFrame->m_pParent = this;

    // After loading the file, walk the nodes to count primitives and
    // compute the bounding sphere    
    m_dwNumFrames   = 0L;
    m_dwNumMeshes   = 0L;
    m_dwNumVertices = 0L;
    m_dwNumIndices  = 0L;
    m_dwNumPolygons = 0L;
    m_vCenter       = D3DXVECTOR3(0,0,0);
    m_fRadius       = 0.0f;
    EnumFrames( FindRadiusCB, this );

    if( m_dwNumVertices == 0)
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadFromX()
// Desc: Reads .x file, retaining the frame hierarchy
//-----------------------------------------------------------------------------
HRESULT CD3DFile::LoadFromX( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename )
{
    LPDIRECTXFILE           pDXFile   = NULL;
    LPDIRECTXFILEENUMOBJECT pEnumObj  = NULL;
    LPDIRECTXFILEDATA       pFileData = NULL;
    HRESULT hr;

    // Set the name
    if( _tcsrchr( strFilename, '\\' ) )
        _tcscpy( m_strFrameName, _tcsrchr( strFilename, '\\' ) + 1 );
    else
        _tcscpy( m_strFrameName, strFilename );

    // Create a x file object
    if( FAILED( hr = DirectXFileCreate( &pDXFile ) ) )
        return E_FAIL;

    // Register templates for d3drm and patch extensions.
    if( FAILED( hr = pDXFile->RegisterTemplates( (VOID*)D3DRM_XTEMPLATES,
                                                 D3DRM_XTEMPLATE_BYTES ) ) )
    {
        pDXFile->Release();
        return E_FAIL;
    }

    // Create enum object
    hr = pDXFile->CreateEnumObject( (VOID*)strFilename, DXFILELOAD_FROMFILE, 
                                    &pEnumObj );
    if( FAILED(hr) )
    {
        pDXFile->Release();
        return hr;
    }

    // Enumerate top level objects (which are always frames)
    while( SUCCEEDED( pEnumObj->GetNextDataObject( &pFileData ) ) )
    {
        hr = LoadFrame( pd3dDevice, pFileData, this );
        pFileData->Release();
        if( FAILED(hr) )
        {
            pEnumObj->Release();
            pDXFile->Release();
            return E_FAIL;
        }
    }

    if( pFileData ) pFileData->Release();
    if( pEnumObj )  pEnumObj->Release();
    if( pDXFile )   pDXFile->Release();

    // After loading the file, walk the nodes to count primitives and
    // compute the bounding sphere    
    m_dwNumFrames   = 0L;
    m_dwNumMeshes   = 0L;
    m_dwNumVertices = 0L;
    m_dwNumIndices  = 0L;
    m_dwNumPolygons = 0L;
    m_vCenter       = D3DXVECTOR3(0,0,0);
    m_fRadius       = 0.0f;
    EnumFrames( FindRadiusCB, this );

    if( m_dwNumVertices == 0)
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadFrame()
// Desc: Load a .x frame
//-----------------------------------------------------------------------------
HRESULT CD3DFile::LoadFrame( LPDIRECT3DDEVICE8 pd3dDevice,
                             LPDIRECTXFILEDATA pFileData,
                             CD3DFrame* pParentFrame )
{
    LPDIRECTXFILEDATA   pChildData = NULL;
    LPDIRECTXFILEOBJECT pChildObj = NULL;
    const GUID* pGUID;
    DWORD       cbSize;
    CD3DFrame*  pCurrentFrame;
    HRESULT     hr;

    // Get the type of the object
    if( FAILED( hr = pFileData->GetType( &pGUID ) ) )
        return hr;

    if( *pGUID == TID_D3DRMMesh )
    {
        // Get the mesh name
        TCHAR strName[MAX_PATH] = _T("");
        DWORD dwNameLength;
        pFileData->GetName( NULL, &dwNameLength );
        if( dwNameLength > 0 )
            pFileData->GetName( strName, &dwNameLength );

        // Create a new frame for the mesh
        CD3DFrame* pNewFrame = new CD3DFrame( strName );
        pNewFrame->m_pParent   = pParentFrame;
        pNewFrame->m_pNext     = pParentFrame->m_pChild;
        pParentFrame->m_pChild = pNewFrame;

        hr = pNewFrame->CreateMesh( pd3dDevice, pFileData );
        if( FAILED(hr) )
            return hr;
    }
    if( *pGUID == TID_D3DRMFrameTransformMatrix )
    {
        D3DXMATRIX* pmatMatrix;
        hr = pFileData->GetData( NULL, &cbSize, (VOID**)&pmatMatrix );
        if( FAILED(hr) )
            return hr;

        // Update the parent's matrix with the new one
        pParentFrame->m_matTransform = (*pmatMatrix);
    }
    if( *pGUID == TID_D3DRMFrame )
    {
        // Get the frame name
        TCHAR strName[MAX_PATH] = _T("");
        DWORD dwNameLength;
        pFileData->GetName( NULL, &dwNameLength );
        if( dwNameLength > 0 )
            pFileData->GetName( strName, &dwNameLength );

        // Create the frame
        pCurrentFrame = new CD3DFrame( strName );
        pCurrentFrame->m_pParent = pParentFrame;
        pCurrentFrame->m_pNext   = pParentFrame->m_pChild;
        pParentFrame->m_pChild   = pCurrentFrame;

        // Enumerate child objects
        while( SUCCEEDED( pFileData->GetNextObject( &pChildObj ) ) )
        {
            // Query the child for its FileData
            hr = pChildObj->QueryInterface( IID_IDirectXFileData,
                                            (VOID**)&pChildData );
            if( SUCCEEDED(hr) )
            {
                hr = LoadFrame( pd3dDevice, pChildData, pCurrentFrame );
                pChildData->Release();
            }

            pChildObj->Release();

            if( FAILED(hr) )
                return hr;
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateMesh()
// Desc: Creates a mesh object from within a frame
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::CreateMesh( LPDIRECT3DDEVICE8 pd3dDevice,
                               LPDIRECTXFILEDATA pFileData )
{
    LPD3DXMESH   pSysMemMesh      = NULL;
    LPD3DXMESH   pLocalMemMesh    = NULL;
    LPD3DXBUFFER pAdjacencyBuffer = NULL;
    LPD3DXBUFFER pMtrlBuffer      = NULL;
    DWORD        dwNumMaterials;
    HRESULT      hr;

    // Use D3DX to load the mesh from the DXFILEDATA object
    if( FAILED( hr = D3DXLoadMeshFromXof( pFileData, D3DXMESH_SYSTEMMEM, pd3dDevice,
                                          &pAdjacencyBuffer, &pMtrlBuffer, 
                                          &dwNumMaterials, &pSysMemMesh ) ) )
        return hr;

    // Attribute sort the mesh
    DWORD* rgdwAdjacencyTemp = new DWORD[ pSysMemMesh->GetNumFaces() * 3 ];
    pSysMemMesh->OptimizeInplace( D3DXMESHOPT_COMPACT|D3DXMESHOPT_ATTRSORT,
                                (DWORD*)pAdjacencyBuffer->GetBufferPointer(),
                                rgdwAdjacencyTemp, NULL, NULL );
    delete[] rgdwAdjacencyTemp;

    // Make a local memory version of the mesh. Note: because we are passing in
    // no flags, the default behavior is to clone into local memory.
    if( FAILED( pSysMemMesh->CloneMeshFVF( D3DXMESH_MANAGED, pSysMemMesh->GetFVF(),
                                           pd3dDevice, &pLocalMemMesh ) ) )
        return E_FAIL;

    // We're done with the system memory mesh
    pSysMemMesh->Release();

    //-----------------------------------------------------------------------------
    // Now, convert the objects into a form better suited for our XBG file
    //-----------------------------------------------------------------------------

    // Store mesh properties
    pLocalMemMesh->GetVertexBuffer( &m_pMeshVB );
    pLocalMemMesh->GetIndexBuffer( &m_pMeshIB );
    m_dwNumMeshVertices = pLocalMemMesh->GetNumVertices();
    m_dwNumMeshIndices  = pLocalMemMesh->GetNumFaces() * 3;
    m_dwNumMeshPolygons = pLocalMemMesh->GetNumFaces();
    m_dwMeshFVF         = pLocalMemMesh->GetFVF();
    m_dwMeshVertexSize  = D3DXGetFVFVertexSize( m_dwMeshFVF );
    m_dwMeshPrimType    = D3DPT_TRIANGLELIST;

    // Compute the object center and radius
    BYTE* pVertices;
    m_pMeshVB->Lock( 0, 0, &pVertices, D3DLOCK_NOSYSLOCK );
    D3DXComputeBoundingSphere( pVertices, m_dwNumMeshVertices, m_dwMeshFVF,
                               &m_vMeshCenter, &m_fMeshRadius );
    m_pMeshVB->Unlock();

    // Build the array of subsets, used to render the mesh
    pLocalMemMesh->GetAttributeTable( NULL, &m_dwNumMeshSubsets );
    m_pMeshSubsets  = new XBMESH_SUBSET[ max(1,m_dwNumMeshSubsets) ];
    
    if( m_dwNumMeshSubsets > 0 )
    {
        // Get subset info from mesh's attribute table
        D3DXATTRIBUTERANGE* pAttributes;
        pAttributes = new D3DXATTRIBUTERANGE[ max(1,m_dwNumMeshSubsets) ];
        pLocalMemMesh->GetAttributeTable( pAttributes, NULL );
        for( DWORD i = 0; i < m_dwNumMeshSubsets; i++ )
        {
            m_pMeshSubsets[i].dwVertexStart = pAttributes[i].VertexStart;
            m_pMeshSubsets[i].dwVertexCount = pAttributes[i].VertexCount;
            m_pMeshSubsets[i].dwIndexStart  = pAttributes[i].FaceStart*3;
            m_pMeshSubsets[i].dwIndexCount  = pAttributes[i].FaceCount*3;
        }

        delete pAttributes;
    }
    else
    {
        // Set default subset
        m_dwNumMeshSubsets = 1; 
        m_pMeshSubsets[0].dwVertexStart = 0;
        m_pMeshSubsets[0].dwVertexCount = m_dwNumMeshVertices;
        m_pMeshSubsets[0].dwIndexStart  = 0;
        m_pMeshSubsets[0].dwIndexCount  = m_dwNumMeshIndices;
    }

    // Initialize materials and textures
    for( DWORD i=0; i<m_dwNumMeshSubsets; i++ )
    {
        m_pMeshSubsets[i].strTexture[0] = 0;
        m_pMeshSubsets[i].pTexture      = NULL;

        D3DMATERIAL8* pmtrl = &m_pMeshSubsets[i].mtrl;
        ZeroMemory( pmtrl, sizeof(D3DMATERIAL8) );
        pmtrl->Diffuse.r = pmtrl->Diffuse.g = pmtrl->Diffuse.b = pmtrl->Diffuse.a = 1.0f;
        pmtrl->Ambient.r = pmtrl->Ambient.g = pmtrl->Ambient.b = pmtrl->Ambient.a = 1.0f;
    }

    // Create materials and textures for the mesh
    if( pMtrlBuffer && m_dwNumMeshSubsets > 0 )
    {
        // Allocate memory for the materials and textures
        D3DXMATERIAL* d3dxMtrls = (D3DXMATERIAL*)pMtrlBuffer->GetBufferPointer();

        // Copy each material and create it's texture
        for( DWORD i=0; i<m_dwNumMeshSubsets; i++ )
        {
            // Copy the material
            m_pMeshSubsets[i].mtrl = d3dxMtrls[i].MatD3D;
            if( m_pMeshSubsets[i].mtrl.Diffuse.a == 0.0f )
                m_pMeshSubsets[i].mtrl.Diffuse.a = 1.0f;
            m_pMeshSubsets[i].mtrl.Ambient = m_pMeshSubsets[i].mtrl.Diffuse;
            m_pMeshSubsets[i].pTexture     = NULL;

            // Create a texture
            if( d3dxMtrls[i].pTextureFilename )
            {
				if( strlen( d3dxMtrls[i].pTextureFilename ) < sizeof(m_pMeshSubsets[i].strTexture) )
					strcpy( m_pMeshSubsets[i].strTexture, d3dxMtrls[i].pTextureFilename );
				else
					strcpy( m_pMeshSubsets[i].strTexture, strrchr( d3dxMtrls[i].pTextureFilename, '\\' ) );

                // Load the texture
                if( FAILED( D3DFile_CreateTexture( pd3dDevice, m_pMeshSubsets[i].strTexture, 
                                                   &m_pMeshSubsets[i].pTexture ) ) )
				{
					// If the load failed, prompt the user for a path
					strcpy( m_pMeshSubsets[i].strTexture, "Woman.dds" );

					D3DFile_CreateTexture( pd3dDevice, m_pMeshSubsets[i].strTexture, 
                                           &m_pMeshSubsets[i].pTexture );
				}
            }
        }
    }

    // Release objects
    if( pMtrlBuffer )
        pMtrlBuffer->Release();
    if( pAdjacencyBuffer ) 
        pAdjacencyBuffer->Release();
    if( pLocalMemMesh )
        pLocalMemMesh->Release();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateMesh()
// Desc: Creates a mesh object from within a frame
//-----------------------------------------------------------------------------
HRESULT CD3DFrame::CreateMesh( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename )
{
    LPD3DXMESH   pSysMemMesh      = NULL;
    LPD3DXMESH   pLocalMemMesh    = NULL;
    LPD3DXBUFFER pAdjacencyBuffer = NULL;
    LPD3DXBUFFER pMtrlBuffer      = NULL;
    DWORD        dwNumMaterials;
    HRESULT      hr;

    // Use D3DX to load the mesh from a .x file
    if( FAILED( hr = D3DXLoadMeshFromX( strFilename, D3DXMESH_SYSTEMMEM, 
                                        pd3dDevice, &pAdjacencyBuffer, &pMtrlBuffer, 
                                        &dwNumMaterials, &pSysMemMesh ) ) )
        return hr;

    // Attribute sort the mesh
    DWORD* rgdwAdjacencyTemp = new DWORD[ pSysMemMesh->GetNumFaces() * 3 ];
    pSysMemMesh->OptimizeInplace( D3DXMESHOPT_COMPACT|D3DXMESHOPT_ATTRSORT,
                                (DWORD*)pAdjacencyBuffer->GetBufferPointer(),
                                rgdwAdjacencyTemp, NULL, NULL );
    delete[] rgdwAdjacencyTemp;

    // Make a local memory version of the mesh. Note: because we are passing in
    // no flags, the default behavior is to clone into local memory.
    if( FAILED( pSysMemMesh->CloneMeshFVF( D3DXMESH_MANAGED, pSysMemMesh->GetFVF(),
                                           pd3dDevice, &pLocalMemMesh ) ) )
        return E_FAIL;

    // We're done with the system memory mesh
    pSysMemMesh->Release();

    //-----------------------------------------------------------------------------
    // Now, convert the objects into a form better suited for our XBG file
    //-----------------------------------------------------------------------------

    // Store mesh properties
    pLocalMemMesh->GetVertexBuffer( &m_pMeshVB );
    pLocalMemMesh->GetIndexBuffer( &m_pMeshIB );
    m_dwNumMeshVertices = pLocalMemMesh->GetNumVertices();
    m_dwNumMeshIndices  = pLocalMemMesh->GetNumFaces() * 3;
    m_dwNumMeshPolygons = pLocalMemMesh->GetNumFaces();
    m_dwMeshFVF         = pLocalMemMesh->GetFVF();
    m_dwMeshVertexSize  = D3DXGetFVFVertexSize( m_dwMeshFVF );
    m_dwMeshPrimType    = D3DPT_TRIANGLELIST;

    // Compute the object center and radius
    BYTE* pVertices;
    m_pMeshVB->Lock( 0, 0, &pVertices, D3DLOCK_NOSYSLOCK );
    D3DXComputeBoundingSphere( pVertices, m_dwNumMeshVertices, m_dwMeshFVF,
                               &m_vMeshCenter, &m_fMeshRadius );
    m_pMeshVB->Unlock();

    // Build the array of subsets, used to render the mesh
    pLocalMemMesh->GetAttributeTable( NULL, &m_dwNumMeshSubsets );
    m_pMeshSubsets  = new XBMESH_SUBSET[ max(1,m_dwNumMeshSubsets) ];
    
    if( m_dwNumMeshSubsets > 0 )
    {
        // Get subset info from mesh's attribute table
        D3DXATTRIBUTERANGE* pAttributes;
        pAttributes = new D3DXATTRIBUTERANGE[ max(1,m_dwNumMeshSubsets) ];
        pLocalMemMesh->GetAttributeTable( pAttributes, NULL );
        for( DWORD i = 0; i < m_dwNumMeshSubsets; i++ )
        {
            m_pMeshSubsets[i].dwVertexStart = pAttributes[i].VertexStart;
            m_pMeshSubsets[i].dwVertexCount = pAttributes[i].VertexCount;
            m_pMeshSubsets[i].dwIndexStart  = pAttributes[i].FaceStart*3;
            m_pMeshSubsets[i].dwIndexCount  = pAttributes[i].FaceCount*3;
        }

        delete pAttributes;
    }
    else
    {
        // Set default subset
        m_dwNumMeshSubsets = 1; 
        m_pMeshSubsets[0].dwVertexStart = 0;
        m_pMeshSubsets[0].dwVertexCount = m_dwNumMeshVertices;
        m_pMeshSubsets[0].dwIndexStart  = 0;
        m_pMeshSubsets[0].dwIndexCount  = m_dwNumMeshIndices;
    }

    // Initialize materials and textures
    for( DWORD i=0; i<m_dwNumMeshSubsets; i++ )
    {
        m_pMeshSubsets[i].strTexture[0] = 0;
        m_pMeshSubsets[i].pTexture      = NULL;

        D3DMATERIAL8* pmtrl = &m_pMeshSubsets[i].mtrl;
        ZeroMemory( pmtrl, sizeof(D3DMATERIAL8) );
        pmtrl->Diffuse.r = pmtrl->Diffuse.g = pmtrl->Diffuse.b = pmtrl->Diffuse.a = 1.0f;
        pmtrl->Ambient.r = pmtrl->Ambient.g = pmtrl->Ambient.b = pmtrl->Ambient.a = 1.0f;
    }

    // Create materials and textures for the mesh
    if( pMtrlBuffer && m_dwNumMeshSubsets > 0 )
    {
        // Allocate memory for the materials and textures
        D3DXMATERIAL* d3dxMtrls = (D3DXMATERIAL*)pMtrlBuffer->GetBufferPointer();

        // Copy each material and create it's texture
        for( DWORD i=0; i<m_dwNumMeshSubsets; i++ )
        {
            // Copy the material
            m_pMeshSubsets[i].mtrl = d3dxMtrls[i].MatD3D;
            if( m_pMeshSubsets[i].mtrl.Diffuse.a == 0.0f )
                m_pMeshSubsets[i].mtrl.Diffuse.a = 1.0f;
            m_pMeshSubsets[i].mtrl.Ambient = m_pMeshSubsets[i].mtrl.Diffuse;
            m_pMeshSubsets[i].pTexture     = NULL;

            // Create a texture
            if( d3dxMtrls[i].pTextureFilename )
            {
				if( strlen( d3dxMtrls[i].pTextureFilename ) < sizeof(m_pMeshSubsets[i].strTexture) )
					strcpy( m_pMeshSubsets[i].strTexture, d3dxMtrls[i].pTextureFilename );
				else
					strcpy( m_pMeshSubsets[i].strTexture, strrchr( d3dxMtrls[i].pTextureFilename, '\\' ) );

                // Load the texture
                if( FAILED( D3DFile_CreateTexture( pd3dDevice, m_pMeshSubsets[i].strTexture, 
                                                   &m_pMeshSubsets[i].pTexture ) ) )
				{
					// If the load failed, prompt the user for a path
					strcpy( m_pMeshSubsets[i].strTexture, "Woman.dds" );

					D3DFile_CreateTexture( pd3dDevice, m_pMeshSubsets[i].strTexture, 
                                           &m_pMeshSubsets[i].pTexture );
				}
            }
        }
    }

    // Release objects
    if( pMtrlBuffer )
        pMtrlBuffer->Release();
    if( pAdjacencyBuffer ) 
        pAdjacencyBuffer->Release();
    if( pLocalMemMesh )
        pLocalMemMesh->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MakeXBG.rc
//
#define IDR_DOCTEMPLATETYPE             6
#define IDD_STRIPIFY                    103
#define IDD_XFILELOADOPTIONS            104
#define IDR_MAINFRAME                   128
#define IDM_SETMESHFVF                  1001
#define IDC_NORMAL                      1034
#define IDC_BLENDWEIGHTS                1035
#define IDC_NUMBLENDWEIGHTS             1036
#define IDC_DIFFUSE                     1037
#define IDC_SPECULAR                    1038
#define IDC_TEXTURE0                    1039
#define IDC_TEXCOORDS0                  1040
#define IDC_TEXCOORDS1                  1041
#define IDC_TEXTURE1                    1042
#define IDC_TEXTURE2                    1043
#define IDC_TEXTURE3                    1044
#define IDC_TEXCOORDS2                  1045
#define IDC_TEXCOORDS3                  1046
#define IDC_FVF                         1047
#define IDC_POSITION                    1049
#define IDC_ORIGINAL_NUMTRIANGLES       1050
#define IDC_ORIGINAL_NUMVERTICES        1051
#define IDC_ORIGINAL_NUMINDICES         1052
#define IDC_ORIGINAL_NUMDEGENERATETRIS  1053
#define IDC_ORIGINAL_NUMCACHEMISSES     1054
#define IDC_ORIGINAL_NUMPAGESCROSSED    1055
#define IDC_COLLAPSEMESH                1055
#define IDC_ORIGINAL_VERTSPERTRI        1056
#define IDC_DONTCOLLAPSEMESH            1056
#define IDC_ORIGINAL_MISSESPERTRI       1057
#define IDC_STRIPPED_VERTSPERTRI        1059
#define IDC_STRIPPED_NUMTRIANGLES       1060
#define IDC_STRIPPED_NUMVERTICES        1061
#define IDC_STRIPPED_NUMINDICES         1062
#define IDC_STRIPPED_NUMDEGENERATETRIS  1063
#define IDC_STRIPPED_NUMCACHEMISSES     1064
#define IDC_STRIPPED_NUMPAGESCROSSED    1065
#define IDC_STRIPPED_MISSESPERTRI       1066
#define IDC_SORTTRIS                    1067
#define IDC_RADIO1                      1068
#define IDC_RADIO2                      1069
#define IDC_RADIO3                      1070
#define IDC_RADIO4                      1071
#define IDD_ABOUTBOX                    2000
#define IDC_STRIP                       2000
#define IDD_SETMESHFVF                  2002
#define IDM_STRIPIFY                    32769

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         32770
#define _APS_NEXT_CONTROL_VALUE         1072
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\SetMeshFvfDlg.cpp ===
//-----------------------------------------------------------------------------
// File: SetMeshFVFDlg.cpp
//
// Desc: Code to implement a dialog to let the user modify the FVF code of a
//       mesh.
//
// Hist: 03.01.01 - New for April XDK release
//       11.08.01 - Made checkboxes work according to FVF code restrictions
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "MakeXBG.h"
#include "SetMeshFvfDlg.h"
#include "FVF.h"




//-----------------------------------------------------------------------------
// Name: CSetMeshFvfDlg()
// Desc: Constructor
//-----------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(CSetMeshFvfDlg, CDialog)

CSetMeshFvfDlg::CSetMeshFvfDlg( CWnd* pParent /*=NULL*/ )
          :CDialog(CSetMeshFvfDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSetMeshFvfDlg)
    //}}AFX_DATA_INIT
}




//-----------------------------------------------------------------------------
// Name: DoDataExchange()
// Desc: 
//-----------------------------------------------------------------------------
void CSetMeshFvfDlg::DoDataExchange( CDataExchange* pDX )
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSetMeshFvfDlg)
    //}}AFX_DATA_MAP

    if( pDX->m_bSaveAndValidate )
    {
    }
    else
    {
        VERTEXFORMAT fvf;
        CrackFVF( m_dwFVF, fvf );
        
        // Set controls for position, normal, diffuse, and specular
        ((CButton*)GetDlgItem(IDC_POSITION))->SetCheck( fvf.bPosition );
        ((CButton*)GetDlgItem(IDC_NORMAL))->SetCheck( fvf.bNormal );
        ((CButton*)GetDlgItem(IDC_DIFFUSE))->SetCheck( fvf.bDiffuse );
        ((CButton*)GetDlgItem(IDC_SPECULAR))->SetCheck( fvf.bSpecular );

        // Set controls for blend weight
        ((CButton*)GetDlgItem(IDC_BLENDWEIGHTS))->SetCheck( fvf.dwNumBlendWeights > 0 );
        GetDlgItem(IDC_NUMBLENDWEIGHTS)->EnableWindow( fvf.dwNumBlendWeights > 0 );
        ((CComboBox*)GetDlgItem(IDC_NUMBLENDWEIGHTS))->SetCurSel(fvf.dwNumBlendWeights-1);

        // Handle texture coordinates
        ((CButton*)GetDlgItem(IDC_TEXTURE0))->SetCheck( fvf.dwNumTexCoords[0] > 0 );
        ((CButton*)GetDlgItem(IDC_TEXTURE1))->SetCheck( fvf.dwNumTexCoords[1] > 0 );
        ((CButton*)GetDlgItem(IDC_TEXTURE2))->SetCheck( fvf.dwNumTexCoords[2] > 0 );
        ((CButton*)GetDlgItem(IDC_TEXTURE3))->SetCheck( fvf.dwNumTexCoords[3] > 0 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS0))->EnableWindow( fvf.dwNumTexCoords[0] > 0 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS1))->EnableWindow( fvf.dwNumTexCoords[1] > 0 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS2))->EnableWindow( fvf.dwNumTexCoords[2] > 0 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS3))->EnableWindow( fvf.dwNumTexCoords[3] > 0 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS0))->SetCurSel( fvf.dwNumTexCoords[0] ? fvf.dwNumTexCoords[0]-1 : 1 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS1))->SetCurSel( fvf.dwNumTexCoords[1] ? fvf.dwNumTexCoords[1]-1 : 1 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS2))->SetCurSel( fvf.dwNumTexCoords[2] ? fvf.dwNumTexCoords[2]-1 : 1 );
        ((CComboBox*)GetDlgItem(IDC_TEXCOORDS3))->SetCurSel( fvf.dwNumTexCoords[3] ? fvf.dwNumTexCoords[3]-1 : 1 );

        // Display the FVF
        TCHAR strText[20];
        _stprintf( strText, "0x%08lx", m_dwFVF );
        GetDlgItem(IDC_FVF)->SetWindowText( strText );
    }
}




BEGIN_MESSAGE_MAP(CSetMeshFvfDlg, CDialog)
    //{{AFX_MSG_MAP(CSetMeshFvfDlg)
    ON_BN_CLICKED(IDC_POSITION, OnControl)
    ON_BN_CLICKED(IDC_NORMAL,   OnControl)
    ON_BN_CLICKED(IDC_DIFFUSE,  OnControl)
    ON_BN_CLICKED(IDC_SPECULAR, OnControl)
    ON_BN_CLICKED(IDC_BLENDWEIGHTS, OnControl)
    ON_CBN_SELCHANGE(IDC_NUMBLENDWEIGHTS, OnControl)
    ON_BN_CLICKED(IDC_TEXTURE0, OnControl)
    ON_BN_CLICKED(IDC_TEXTURE1, OnControl)
    ON_BN_CLICKED(IDC_TEXTURE2, OnControl)
    ON_BN_CLICKED(IDC_TEXTURE3, OnControl)
    ON_CBN_SELCHANGE(IDC_TEXCOORDS0, OnControl)
    ON_CBN_SELCHANGE(IDC_TEXCOORDS1, OnControl)
    ON_CBN_SELCHANGE(IDC_TEXCOORDS2, OnControl)
    ON_CBN_SELCHANGE(IDC_TEXCOORDS3, OnControl)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




//-----------------------------------------------------------------------------
// Name: OnControl()
// Desc: 
//-----------------------------------------------------------------------------
void CSetMeshFvfDlg::OnControl() 
{
    VERTEXFORMAT fvf;
    ZeroMemory( &fvf, sizeof(fvf) );

    // Handle position, normal, diffuse, and specular
    fvf.bPosition = ((CButton*)GetDlgItem(IDC_POSITION))->GetCheck();
    fvf.bNormal   = ((CButton*)GetDlgItem(IDC_NORMAL))->GetCheck();
    fvf.bDiffuse  = ((CButton*)GetDlgItem(IDC_DIFFUSE))->GetCheck();
    fvf.bSpecular = ((CButton*)GetDlgItem(IDC_SPECULAR))->GetCheck();

    // Handle blend weights
    if( ((CButton*)GetDlgItem(IDC_BLENDWEIGHTS))->GetCheck() )
    {
        GetDlgItem(IDC_NUMBLENDWEIGHTS)->EnableWindow(TRUE);

        fvf.dwNumBlendWeights = ((CComboBox*)GetDlgItem(IDC_NUMBLENDWEIGHTS))->GetCurSel() + 1;
    }
    else
        GetDlgItem(IDC_NUMBLENDWEIGHTS)->EnableWindow(FALSE);

    // Handle texture coordinates
    CButton* pTextureButtons[4];
    pTextureButtons[0] = ((CButton*)GetDlgItem(IDC_TEXTURE0));
    pTextureButtons[1] = ((CButton*)GetDlgItem(IDC_TEXTURE1));
    pTextureButtons[2] = ((CButton*)GetDlgItem(IDC_TEXTURE2));
    pTextureButtons[3] = ((CButton*)GetDlgItem(IDC_TEXTURE3));
    CComboBox* pTextureComboBoxes[4];
    pTextureComboBoxes[0] = ((CComboBox*)GetDlgItem(IDC_TEXCOORDS0));
    pTextureComboBoxes[1] = ((CComboBox*)GetDlgItem(IDC_TEXCOORDS1));
    pTextureComboBoxes[2] = ((CComboBox*)GetDlgItem(IDC_TEXCOORDS2));
    pTextureComboBoxes[3] = ((CComboBox*)GetDlgItem(IDC_TEXCOORDS3));

    for( DWORD i=0; i<4; i++ )
    {
        if( pTextureButtons[i]->GetCheck() )
        {
            pTextureComboBoxes[i]->EnableWindow(TRUE);

            fvf.dwNumTexCoords[i] = pTextureComboBoxes[i]->GetCurSel() + 1;
        }
        else
        {
            pTextureComboBoxes[i]->EnableWindow(FALSE);

            // Turn all above stages off
            for( DWORD j=i; j<4; j++ )
                pTextureButtons[j]->SetCheck( FALSE );
        }
    }

    // Compute the resulting FVF code
    m_dwFVF = EncodeFVF( fvf );

    // Display the FVF
    TCHAR strText[20];
    _stprintf( strText, "0x%08lx", m_dwFVF );
    GetDlgItem(IDC_FVF)->SetWindowText( strText );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\RenderView.cpp ===
//-----------------------------------------------------------------------------
// File: RenderView.cpp
//
// Desc: MFC view class for render the geoemtry model using D3D.
//
// Hist: 03.01.00 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "MakeXBG.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------
extern LPDIRECT3D8      g_pD3D;
extern D3DDISPLAYMODE   g_d3ddm;




//-----------------------------------------------------------------------------
// Name: class CModelRenderView
// Desc: A view class to render the geometry model loaded from a file.
//-----------------------------------------------------------------------------
IMPLEMENT_DYNCREATE(CModelRenderView, CView)

BEGIN_MESSAGE_MAP(CModelRenderView, CView)
    //{{AFX_MSG_MAP(CModelRenderView)
    ON_WM_MOUSEACTIVATE()
    ON_WM_DESTROY()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_CREATE()
    ON_WM_SIZE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CModelRenderView::CModelRenderView()
{
    m_pd3dDevice = NULL;
}

CModelRenderView::~CModelRenderView()
{
}




//-----------------------------------------------------------------------------
// Name: OnDestroy()
// Desc: Destroys the model view
//-----------------------------------------------------------------------------
void CModelRenderView::OnDestroy() 
{
    CView::OnDestroy();

    if( m_pd3dDevice )
        m_pd3dDevice->Release();
}




//-----------------------------------------------------------------------------
// Name: OnInitialUpdate()
// Desc: Creates objects for the view (i.e. the d3d rendering device and loads
//       the object's geometry).
//-----------------------------------------------------------------------------
void CModelRenderView::OnInitialUpdate()
{
    // Now that we have a file to load, create a d3ddevice and use to it load
    // the geometry file (and also, of course, to render the geometry).
    CXBGDocument* pDoc = GetDocument();
    pDoc->m_pD3DFile        = NULL;
    pDoc->m_pSelectedFrame  = NULL;
    pDoc->m_lSelectedSubset = NULL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.hDeviceWindow          = m_hWnd;
    d3dpp.Windowed               = TRUE;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
    d3dpp.BackBufferFormat       = g_d3ddm.Format;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0L, D3DDEVTYPE_HAL, m_hWnd,
                                      D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                                      &d3dpp, &m_pd3dDevice ) ) )
    {
        MessageBox( _T("Could not create a D3D rendering device!\n\n")
                    _T("This app requires a D3D hardware rendering device\n")
                    _T("in order to run. The D3D device is used to display\n")
                    _T("loaded geometry.\n"),
                    _T("MakeXBG Error"), MB_ICONERROR|MB_OK );
        GetParentFrame()->PostMessage( WM_CLOSE );
        return;
    }

    // Load the mesh
    TCHAR* strInputFilename = pDoc->m_strFilename.GetBuffer(MAX_PATH);
    pDoc->m_pD3DFile = new CD3DFile();

    if( FAILED( pDoc->m_pD3DFile->Create( m_pd3dDevice, strInputFilename, 
                                          pDoc->m_bCollapseMesh ) ) )
    {
        MessageBox( _T("Could not load file!\n\n")
                    _T("Please note that .x files with more than\n")
                    _T("one mesh per frame cannot be loaded by\n")
                    _T("this app."), _T("File Error"), MB_ICONERROR|MB_OK );
        GetParentFrame()->PostMessage( WM_CLOSE );
        return;
    }

    // Set ArcBall info
    RECT rc;
    GetClientRect( &rc );
    D3DXQuaternionIdentity( &m_qDown );
    D3DXQuaternionIdentity( &m_qNow );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixIdentity( &m_matRotation );
    D3DXMatrixIdentity( &m_matTranslation );
    m_bDrag = FALSE;

    // Setup the light
    D3DLIGHT8 light;
    light.Type         = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r    = light.Diffuse.g  = light.Diffuse.b  = 1.0f; light.Diffuse.a  = 1.0f;
    light.Specular.r   = light.Specular.g = light.Specular.b = 0.0f; light.Specular.a = 1.0f;
    light.Ambient.r    = light.Ambient.g  = light.Ambient.b  = 0.3f; light.Ambient.a  = 1.0f;
    light.Position     = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &D3DXVECTOR3( 0.3f, -1.0f, 1.0f ) );
    light.Attenuation0 = light.Attenuation1 = light.Attenuation2 = 0.0f;
    light.Range        = sqrtf(FLT_MAX);
    m_pd3dDevice->SetLight(0, &light );
    m_pd3dDevice->LightEnable(0, TRUE );

    // Setup render state
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    // Setup transforms
    D3DXMATRIX matView, matProj;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0, 0,-3.0f*pDoc->m_pD3DFile->m_fRadius ),
                                  &D3DXVECTOR3( 0, 0, 0 ), &D3DXVECTOR3( 0, 1, 0 ) );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 
                                pDoc->m_pD3DFile->m_fRadius/64.0f, pDoc->m_pD3DFile->m_fRadius*200.0f );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,  &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION,  &matProj );

    // Update the treeview
    ((CSplitterFrame*)GetParentFrame())->m_pTreeView->OnUpdate( this, 0, NULL );
}




//-----------------------------------------------------------------------------
// Name: OnDraw()
// Desc: Draws the geometry in the model view window
//-----------------------------------------------------------------------------
void CModelRenderView::OnDraw( CDC* pDC )
{
    CXBGDocument*     pDoc  = GetDocument();
    CD3DFile*         pMesh = pDoc->m_pD3DFile;

    // Draw scene
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         0xff0000ff, 1.0f, 0L );
    m_pd3dDevice->BeginScene();

    // Setup viewing postion from ArcBall
    D3DXMATRIX matRotationInverse;
    D3DXMatrixTranslation( &m_matWorld, -pMesh->m_vCenter.x,
                                        -pMesh->m_vCenter.y,
                                        -pMesh->m_vCenter.z );
    D3DXMatrixInverse( &matRotationInverse, NULL, &m_matRotation );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &matRotationInverse );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &m_matTranslation );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

    // Set states
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0xff404040 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

    // Render opaque subsets of the visible frame
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
    pMesh->Render( m_pd3dDevice, D3DFILE_RENDERVISIBLEFRAMES|D3DFILE_RENDEROPAQUESUBSETS );

    // Render alpha subsets of the visible frame
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    pMesh->Render( m_pd3dDevice, D3DFILE_RENDERVISIBLEFRAMES|D3DFILE_RENDERALPHASUBSETS );

    // Transparently draw subsets for all other frames
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0x30303030 );
    pMesh->Render( m_pd3dDevice, D3DFILE_RENDERALLFRAMES|D3DFILE_RENDERALLSUBSETS );

    m_pd3dDevice->EndScene();
    m_pd3dDevice->Present( NULL,  NULL,  NULL,  NULL );
}




//-----------------------------------------------------------------------------
// Name: ScreenToVector()
// Desc: Helper function to turn a screen coordinate into a vector. Used by the
//       code below that controls object rotations with the mouse.
//-----------------------------------------------------------------------------
D3DXVECTOR3 CModelRenderView::ScreenToVector( int sx, int sy )
{
    RECT rc;
    GetClientRect( &rc );
    FLOAT fViewportWidth  = ( rc.right - rc.left ) / 2.0f;
    FLOAT fViewportHeight = ( rc.bottom - rc.top ) / 2.0f;

    // Scale to screen
    FLOAT x   =  (sx - fViewportWidth)  / fViewportWidth;
    FLOAT y   = -(sy - fViewportHeight) / fViewportHeight;
    FLOAT z   = 0.0f;
    FLOAT mag = x*x + y*y;

    if( mag > 1.0f )
    {
        FLOAT scale = 1.0f/sqrtf(mag);
        x *= scale;
        y *= scale;
    }
    else
        z = sqrtf( 1.0f - mag );

    // Return vector
    return D3DXVECTOR3( x, y, z );
}




//-----------------------------------------------------------------------------
// Name: OnLButtonDown()
// Desc: Handle mouse buttons, used to control the object rotation.
//-----------------------------------------------------------------------------
void CModelRenderView::OnLButtonDown( UINT nFlags, CPoint point ) 
{
    // Start arcball drag mode
    m_bDrag = TRUE;
    m_vDown = ScreenToVector( point.x, point.y );

    CView::OnLButtonDown(nFlags, point);
}




//-----------------------------------------------------------------------------
// Name: OnLButtonUp()
// Desc: Handle mouse buttons, used to control the object rotation.
//-----------------------------------------------------------------------------
void CModelRenderView::OnLButtonUp( UINT nFlags, CPoint point ) 
{
    // End arcball drag mode
    m_bDrag = FALSE;
    m_qDown = m_qNow;

    CView::OnLButtonUp(nFlags, point);
}




//-----------------------------------------------------------------------------
// Name: OnMouseMove()
// Desc: Handle mouse move messages. Used here when the mouse left button is
//       down, to change the object rotation matrix.
//-----------------------------------------------------------------------------
void CModelRenderView::OnMouseMove( UINT nFlags, CPoint point ) 
{
    if( m_bDrag && m_pd3dDevice )
    {
        // Update arcball
        D3DXVECTOR3 vPart;
        D3DXVECTOR3 vCur = ScreenToVector( point.x, point.y );
        D3DXVec3Cross( &vPart, &m_vDown, &vCur );
        m_qNow = m_qDown * D3DXQUATERNION( vPart.x, vPart.y, vPart.z,
                                           D3DXVec3Dot( &m_vDown, &vCur ) );

        D3DXQUATERNION qConj;
        D3DXQuaternionConjugate( &qConj, &m_qNow );

        D3DXMATRIX matRotationDelta;
        D3DXMatrixRotationQuaternion( &matRotationDelta, &qConj );
        D3DXMatrixTranspose( &matRotationDelta, &matRotationDelta );
        D3DXMatrixMultiply( &m_matRotation, &m_matRotation, &matRotationDelta );

        D3DXQuaternionIdentity( &m_qDown );
        D3DXQuaternionIdentity( &m_qNow );
        m_vDown = ScreenToVector( point.x, point.y );
        m_bDrag = TRUE;

        // Render the scene
        OnDraw( NULL );
    }
    
    CView::OnMouseMove(nFlags, point);
}




//-----------------------------------------------------------------------------
// Name: OnSize()
// Desc: Handle resizing of the model view window, which will trigger a reset
//       for the d3ddevice, and all of it's state.
//-----------------------------------------------------------------------------
void CModelRenderView::OnSize( UINT nType, int cx, int cy ) 
{
    CView::OnSize( nType, cx, cy );
    
    if( m_pd3dDevice )
    {
        CXBGDocument*     pDoc  = GetDocument();
        CD3DFile*         pMesh = pDoc->m_pD3DFile;

        // Set up the structure used to create the D3DDevice.
        D3DPRESENT_PARAMETERS d3dpp; 
        ZeroMemory( &d3dpp, sizeof(d3dpp) );
        d3dpp.hDeviceWindow          = m_hWnd;
        d3dpp.Windowed               = TRUE;
        d3dpp.EnableAutoDepthStencil = TRUE;
        d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
        d3dpp.BackBufferFormat       = g_d3ddm.Format;
        d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

        // Resize the Direct3D device.
        if( FAILED( m_pd3dDevice->Reset( &d3dpp ) ) )
            return;

        // Setup the light
        D3DLIGHT8 light;
        light.Type         = D3DLIGHT_DIRECTIONAL;
        light.Diffuse.r    = light.Diffuse.g  = light.Diffuse.b  = 1.0f; light.Diffuse.a  = 1.0f;
        light.Specular.r   = light.Specular.g = light.Specular.b = 0.0f; light.Specular.a = 1.0f;
        light.Ambient.r    = light.Ambient.g  = light.Ambient.b  = 0.3f; light.Ambient.a  = 1.0f;
        light.Position     = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
        D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &D3DXVECTOR3( 0.3f, -1.0f, 1.0f ) );
        light.Attenuation0 = light.Attenuation1 = light.Attenuation2 = 0.0f;
        light.Range        = sqrtf(FLT_MAX);
        m_pd3dDevice->SetLight(0, &light );
        m_pd3dDevice->LightEnable(0, TRUE );

        // Setup render state
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

        // Setup transforms
        D3DXMATRIX matView, matProj;
        D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0, 0,-3.0f*pDoc->m_pD3DFile->m_fRadius ),
                                      &D3DXVECTOR3( 0, 0, 0 ), &D3DXVECTOR3( 0, 1, 0 ) );
        D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 
                                    pDoc->m_pD3DFile->m_fRadius/64.0f, pDoc->m_pD3DFile->m_fRadius*200.0f );
        m_pd3dDevice->SetTransform( D3DTS_VIEW,  &matView );
        m_pd3dDevice->SetTransform( D3DTS_PROJECTION,  &matProj );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\StdAfx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\StdAfx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define VC_EXTRALEAN

#include <afxwin.h>
#include <afxext.h>         // MFC extensions like CFormView, CSplitterWnd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\SplitterWnd.cpp ===
//-----------------------------------------------------------------------------
// File: SplitterWnd.cpp
//
// Desc: MFC class for implementing a splitter window.
//
// Hist: 03.01.00 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "MakeXBG.h"


extern CMakeXBGApp g_App;




//-----------------------------------------------------------------------------
// Name: class CSplitterFrame
// Desc: The splitter frame class
//-----------------------------------------------------------------------------
IMPLEMENT_DYNCREATE(CSplitterFrame, CMDIChildWnd)

CSplitterFrame::CSplitterFrame()
{
}

CSplitterFrame::~CSplitterFrame()
{
}




//-----------------------------------------------------------------------------
// Name: OnCreateClient()
// Desc: Creates a split-view for the document. View 0 is the tree view for the
//       geometry model, and view 1 is the d3d rendering view for the geometry
//       model.
//-----------------------------------------------------------------------------
BOOL CSplitterFrame::OnCreateClient( LPCREATESTRUCT, CCreateContext* pContext )
{
    // Create a splitter with 1 row, 2 columns
    if( FALSE == m_wndSplitter.CreateStatic( this, 1, 2 ) )
        return FALSE;

    // Add the first splitter pane - the default view in column 0
    if( FALSE == m_wndSplitter.CreateView( 0, 0, RUNTIME_CLASS(CModelTreeView), 
                                           CSize(200, 50), pContext ) )
        return FALSE;

    // Add the second splitter pane - an input view in column 1
    if( FALSE == m_wndSplitter.CreateView( 0, 1, pContext->m_pNewViewClass, 
                                           CSize(0, 0), pContext ) )
        return FALSE;

    // Gain access to the views
    m_pTreeView      = (CModelTreeView*)m_wndSplitter.GetPane(0,0);
    m_pD3DRenderView = (CModelRenderView*)m_wndSplitter.GetPane(0,1);

    // Activate the render view
    SetActiveView( m_pTreeView );

    return TRUE;
}




BEGIN_MESSAGE_MAP(CSplitterFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CSplitterFrame)
    ON_WM_SIZE()
    ON_WM_MDIACTIVATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




//-----------------------------------------------------------------------------
// Name: class CMainSplitterWnd
// Desc: The splitter window class
//-----------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(CMainSplitterWnd, CSplitterWnd)

CMainSplitterWnd::CMainSplitterWnd()
{
}

CMainSplitterWnd::~CMainSplitterWnd()
{
}




//-----------------------------------------------------------------------------
// Name: GetActivePane()
// Desc: Retreives the active pane of the main splitter window
//-----------------------------------------------------------------------------
CWnd* CMainSplitterWnd::GetActivePane( int* pRow, int* pCol )
{
    // Attempt to use active view of frame window
    CFrameWnd* pFrameWnd = GetParentFrame();
    CWnd*      pView     = pFrameWnd->GetActiveView();

    // Failing that, use the current focus
    if( NULL == pView  )
        pView = GetFocus();

    return pView;
}




void CSplitterFrame::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd) 
{
    CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

    // Set menu item states
    CMenu* pMenu = g_App.m_pMainWnd->GetMenu();
    if( bActivate )
    {
        pMenu->EnableMenuItem( ID_FILE_CLOSE, MF_ENABLED );
        pMenu->EnableMenuItem( ID_FILE_SAVE_AS, MF_ENABLED );

        if( m_pTreeView->GetDocument()->m_pSelectedFrame )
        {
            if( m_pTreeView->GetDocument()->m_pSelectedFrame->m_dwMeshFVF )
            {
                pMenu->EnableMenuItem( IDM_SETMESHFVF, MF_ENABLED );
                pMenu->EnableMenuItem( IDM_STRIPIFY, MF_ENABLED );
            }
        }
    }
    else
    {
        pMenu->EnableMenuItem( ID_FILE_CLOSE,  MF_GRAYED );
        pMenu->EnableMenuItem( ID_FILE_SAVE_AS,   MF_GRAYED );
        pMenu->EnableMenuItem( IDM_SETMESHFVF, MF_GRAYED );
        pMenu->EnableMenuItem( IDM_STRIPIFY, MF_GRAYED );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\StripifyDlg.cpp ===
//-----------------------------------------------------------------------------
// File: StripifyDlg.cpp
//
// Desc: Code to implement a dialog to let the user stripify a mesh.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "MakeXBG.h"
#include "StripifyDlg.h"
#include "fvf.h"
#include "TriStripper.h"




//-----------------------------------------------------------------------------
// Name: XBPerf_CalcCacheHits()
// Desc: Calculate the number of cache hits and degenerate triangles
//-----------------------------------------------------------------------------
HRESULT XBPerf_CalcCacheHits( D3DPRIMITIVETYPE dwPrimType, DWORD dwVertexSize,
                              LPDIRECT3DINDEXBUFFER8 pIB, 
                              DWORD dwFirstIndex, DWORD dwNumIndices,
                              DWORD* pdwNumDegenerateTris,
                              DWORD* pdwNumCacheMisses,
                              DWORD* pdwNumPagesCrossed )
{
    // Check arguments
    if( NULL == pdwNumDegenerateTris || NULL == pdwNumCacheMisses || 
        NULL == pdwNumPagesCrossed )
        return E_INVALIDARG;

    // Initialize results
    (*pdwNumDegenerateTris) = 0;
    (*pdwNumCacheMisses)    = 0;
    (*pdwNumPagesCrossed)   = 1;

    // Gain access to indices
    WORD* pIndices;
    pIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );
        
    // Simulate a vertex cache
    static const int CACHE_SIZE = 18;
    static const int PAGE_SIZE  = 4096;
    DWORD rgdwCache[CACHE_SIZE];
    INT   iCachePtr      = 0;
    BOOL  bIsTriStrip    = (dwPrimType == D3DPT_TRIANGLESTRIP);
    DWORD dwLastPageAddr = 0;
    memset( rgdwCache, 0xff, sizeof(rgdwCache) );

    // Run all vertices through the sumilated vertex cache, tallying cache hits,
    // degenerate triangles, and pages crossed.
    for( DWORD i = dwFirstIndex; i < dwFirstIndex+dwNumIndices; i++ )
    {
        // This makes all kinds of assumptions such as page size is 4k,
        // page across then back is ok, etc etc. Seems to be an ok
        // estimate on data locality though.
        DWORD dwPage = dwVertexSize * pIndices[i] / PAGE_SIZE;

        if( ( dwPage > dwLastPageAddr ) || ( dwPage+1 < dwLastPageAddr ) )
        {
            (*pdwNumPagesCrossed)++;
            dwLastPageAddr = dwPage;
        }

        // Update our count of degenerate tris
        if( bIsTriStrip && (i > 1) )
            if( ( pIndices[i-0] == pIndices[i-1] ) ||
                ( pIndices[i-0] == pIndices[i-2] ) ||
                ( pIndices[i-1] == pIndices[i-2] ) )
                (*pdwNumDegenerateTris)++;

        // Check to see if the vertex would be in the cache
        BOOL bVertexInCache = FALSE;
        for( int cache_index = 0; cache_index < CACHE_SIZE; cache_index++ )
        {
            if( pIndices[i] == rgdwCache[cache_index] )
            {
                bVertexInCache = TRUE;
                break;
            }
        }

        if( bVertexInCache )
        {
            // Do nothing
        }
        else 
        {
            // Keep track of cache misses
            (*pdwNumCacheMisses)++;

            // Add vertex to simulated cache
            rgdwCache[iCachePtr] = pIndices[i];
            iCachePtr = (iCachePtr + 1) % CACHE_SIZE;
        }
    }

    // Done with the index buffer
    pIB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: StripifyDlg()
// Desc: Constructor
//-----------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(StripifyDlg, CDialog)

StripifyDlg::StripifyDlg( CWnd* pParent /*=NULL*/ )
          :CDialog(StripifyDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(ViewCacheHitsDlg)
    //}}AFX_DATA_INIT

	m_dwOptimizeFlag = OPTIMIZE_FOR_CACHE;
	m_dwOutputFlag = OUTPUT_TRISTRIP;
}




//-----------------------------------------------------------------------------
// Name: DoDataExchange()
// Desc: 
//-----------------------------------------------------------------------------
void StripifyDlg::DoDataExchange( CDataExchange* pDX )
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(StripifyDlg)
    //}}AFX_DATA_MAP

    if( pDX->m_bSaveAndValidate )
    {
    }
    else
    {
        // Figure out how many degenerate triangles and cache hits we've got
        DWORD dwNumTotalIndices        = 0;
        DWORD dwNumTotalVertices       = 0;
        DWORD dwNumTotalTriangles      = 0;
        DWORD dwNumTotalDegenerateTris = 0;
        DWORD dwNumTotalCacheMisses    = 0;
        DWORD dwNumTotalPagesCrossed   = 0;

        for( DWORD i=0; i<m_pFrame->m_dwNumMeshSubsets; i++ )
        {
            DWORD dwDegenerateTris;
            DWORD dwCacheMisses;
            DWORD dwPagesCrossed;

            XBPerf_CalcCacheHits( m_pFrame->m_dwMeshPrimType, m_pFrame->m_dwMeshVertexSize,
                                  m_pFrame->m_pMeshIB, 
                                  m_pFrame->m_pMeshSubsets[i].dwIndexStart,
                                  m_pFrame->m_pMeshSubsets[i].dwIndexCount,
                                  &dwDegenerateTris, &dwCacheMisses, &dwPagesCrossed );

            dwNumTotalIndices   += m_pFrame->m_pMeshSubsets[i].dwIndexCount;
            dwNumTotalVertices  += m_pFrame->m_pMeshSubsets[i].dwVertexCount;

			if( D3DPT_TRIANGLESTRIP == m_pFrame->m_dwMeshPrimType )
	            dwNumTotalTriangles += m_pFrame->m_pMeshSubsets[i].dwIndexCount - 2;
			else
				dwNumTotalTriangles += m_pFrame->m_pMeshSubsets[i].dwIndexCount/3;

            dwNumTotalDegenerateTris += dwDegenerateTris;
            dwNumTotalCacheMisses    += dwCacheMisses;
            dwNumTotalPagesCrossed   += dwPagesCrossed;
        }

        // Update the UI
        TCHAR strText[20];
        _stprintf( strText, "%ld", dwNumTotalTriangles );
        GetDlgItem(IDC_ORIGINAL_NUMTRIANGLES)->SetWindowText( strText );
        _stprintf( strText, "%ld", dwNumTotalVertices );
        GetDlgItem(IDC_ORIGINAL_NUMVERTICES)->SetWindowText( strText );
        _stprintf( strText, "%ld", dwNumTotalIndices );
        GetDlgItem(IDC_ORIGINAL_NUMINDICES)->SetWindowText( strText );

        _stprintf( strText, "%6.3f", ((FLOAT)dwNumTotalVertices)/(dwNumTotalTriangles-dwNumTotalDegenerateTris) );
        GetDlgItem(IDC_ORIGINAL_VERTSPERTRI)->SetWindowText( strText );
        _stprintf( strText, "%6.3f", ((FLOAT)dwNumTotalCacheMisses)/(dwNumTotalTriangles-dwNumTotalDegenerateTris) );
        GetDlgItem(IDC_ORIGINAL_MISSESPERTRI)->SetWindowText( strText );

        _stprintf( strText, "%ld", dwNumTotalDegenerateTris );
        GetDlgItem(IDC_ORIGINAL_NUMDEGENERATETRIS)->SetWindowText( strText );
        _stprintf( strText, "%ld", dwNumTotalCacheMisses );
        GetDlgItem(IDC_ORIGINAL_NUMCACHEMISSES)->SetWindowText( strText );
        _stprintf( strText, "%ld", dwNumTotalPagesCrossed );
        GetDlgItem(IDC_ORIGINAL_NUMPAGESCROSSED)->SetWindowText( strText );

        GetDlgItem(IDC_STRIPPED_NUMTRIANGLES)->EnableWindow( FALSE );
        GetDlgItem(IDC_STRIPPED_NUMVERTICES)->EnableWindow( FALSE );
        GetDlgItem(IDC_STRIPPED_NUMINDICES)->EnableWindow( FALSE );
        GetDlgItem(IDC_STRIPPED_NUMDEGENERATETRIS)->EnableWindow( FALSE );
        GetDlgItem(IDC_STRIPPED_NUMCACHEMISSES)->EnableWindow( FALSE );
        GetDlgItem(IDC_STRIPPED_NUMPAGESCROSSED)->EnableWindow( FALSE );

		GetDlgItem(IDC_RADIO2)->SendMessage( BM_SETCHECK, BST_CHECKED, 0 );
		GetDlgItem(IDC_RADIO3)->SendMessage( BM_SETCHECK, BST_CHECKED, 0 );
    }
}




BEGIN_MESSAGE_MAP(StripifyDlg, CDialog)
    //{{AFX_MSG_MAP(StripifyDlg)
    ON_BN_CLICKED(IDC_STRIP, OnStrip)
	ON_BN_CLICKED(IDC_RADIO1, OnOptForIndices)
	ON_BN_CLICKED(IDC_RADIO2, OnOptForCache)
	ON_BN_CLICKED(IDC_RADIO4, OnOutputTriList)
	ON_BN_CLICKED(IDC_RADIO3, OnOutputTriStrip)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()




//-----------------------------------------------------------------------------
// Name: OnStrip()
// Desc: 
//-----------------------------------------------------------------------------
void StripifyDlg::OnStrip() 
{
	// Turn off the button right away.
    GetDlgItem(IDC_STRIP)->EnableWindow( FALSE );
	HCURSOR oldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

    // Run the stripper
    m_pFrame->Stripify( m_dwOptimizeFlag | m_dwOutputFlag );

    // Figure out how many degenerate triangles and cache hits we've got
    DWORD dwNumTotalIndices        = 0;
    DWORD dwNumTotalVertices       = 0;
    DWORD dwNumTotalTriangles      = 0;
    DWORD dwNumTotalDegenerateTris = 0;
    DWORD dwNumTotalCacheMisses    = 0;
    DWORD dwNumTotalPagesCrossed   = 0;

    for( DWORD i=0; i<m_pFrame->m_dwNumMeshSubsets; i++ )
    {
        DWORD dwDegenerateTris;
        DWORD dwCacheMisses;
        DWORD dwPagesCrossed;

        XBPerf_CalcCacheHits( m_pFrame->m_dwMeshPrimType, m_pFrame->m_dwMeshVertexSize,
                              m_pFrame->m_pMeshIB, 
                              m_pFrame->m_pMeshSubsets[i].dwIndexStart,
                              m_pFrame->m_pMeshSubsets[i].dwIndexCount,
                              &dwDegenerateTris, &dwCacheMisses, &dwPagesCrossed );

        dwNumTotalIndices   += m_pFrame->m_pMeshSubsets[i].dwIndexCount;
        dwNumTotalVertices  += m_pFrame->m_pMeshSubsets[i].dwVertexCount;

		if( D3DPT_TRIANGLESTRIP == m_pFrame->m_dwMeshPrimType )
	        dwNumTotalTriangles += m_pFrame->m_pMeshSubsets[i].dwIndexCount - 2;
		else
			dwNumTotalTriangles += m_pFrame->m_pMeshSubsets[i].dwIndexCount/3;

        dwNumTotalDegenerateTris += dwDegenerateTris;
        dwNumTotalCacheMisses    += dwCacheMisses;
        dwNumTotalPagesCrossed   += dwPagesCrossed;
    }

    // Activate controls
    GetDlgItem(IDC_STRIPPED_NUMTRIANGLES)->EnableWindow( TRUE );
    GetDlgItem(IDC_STRIPPED_NUMVERTICES)->EnableWindow( TRUE );
    GetDlgItem(IDC_STRIPPED_NUMINDICES)->EnableWindow( TRUE );
    GetDlgItem(IDC_STRIPPED_NUMDEGENERATETRIS)->EnableWindow( TRUE );
    GetDlgItem(IDC_STRIPPED_NUMCACHEMISSES)->EnableWindow( TRUE );
    GetDlgItem(IDC_STRIPPED_NUMPAGESCROSSED)->EnableWindow( TRUE );

    // Write out results
    TCHAR strText[20];
    _stprintf( strText, "%ld", dwNumTotalTriangles );
    GetDlgItem(IDC_STRIPPED_NUMTRIANGLES)->SetWindowText( strText );
    _stprintf( strText, "%ld", dwNumTotalVertices );
    GetDlgItem(IDC_STRIPPED_NUMVERTICES)->SetWindowText( strText );
    _stprintf( strText, "%ld", dwNumTotalIndices );
    GetDlgItem(IDC_STRIPPED_NUMINDICES)->SetWindowText( strText );

    _stprintf( strText, "%6.3f", ((FLOAT)dwNumTotalVertices)/(dwNumTotalTriangles-dwNumTotalDegenerateTris) );
    GetDlgItem(IDC_STRIPPED_VERTSPERTRI)->SetWindowText( strText );
    _stprintf( strText, "%6.3f", ((FLOAT)dwNumTotalCacheMisses)/(dwNumTotalTriangles-dwNumTotalDegenerateTris) );
    GetDlgItem(IDC_STRIPPED_MISSESPERTRI)->SetWindowText( strText );
    
    _stprintf( strText, "%ld", dwNumTotalDegenerateTris );
    GetDlgItem(IDC_STRIPPED_NUMDEGENERATETRIS)->SetWindowText( strText );
    _stprintf( strText, "%ld", dwNumTotalCacheMisses );
    GetDlgItem(IDC_STRIPPED_NUMCACHEMISSES)->SetWindowText( strText );
    _stprintf( strText, "%ld", dwNumTotalPagesCrossed );
    GetDlgItem(IDC_STRIPPED_NUMPAGESCROSSED)->SetWindowText( strText );

	// Turn button back on when we are done.
    GetDlgItem(IDC_STRIP)->EnableWindow( TRUE );
	SetCursor( oldCursor );
}




//-----------------------------------------------------------------------------
// Name: OnOptForIndices()
// Desc: 
//-----------------------------------------------------------------------------
void StripifyDlg::OnOptForIndices() 
{
	m_dwOptimizeFlag = OPTIMIZE_FOR_INDICES;
}




//-----------------------------------------------------------------------------
// Name: OnOptForCache()
// Desc: 
//-----------------------------------------------------------------------------
void StripifyDlg::OnOptForCache() 
{
	m_dwOptimizeFlag = OPTIMIZE_FOR_CACHE;
}




//-----------------------------------------------------------------------------
// Name: OnOutputTriList()
// Desc: 
//-----------------------------------------------------------------------------
void StripifyDlg::OnOutputTriList() 
{
	m_dwOutputFlag = OUTPUT_TRILIST;
}




//-----------------------------------------------------------------------------
// Name: OnOutputTriStrip()
// Desc: 
//-----------------------------------------------------------------------------
void StripifyDlg::OnOutputTriStrip() 
{
	m_dwOutputFlag = OUTPUT_TRISTRIP;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\SetMeshFvfDlg.h ===
//-----------------------------------------------------------------------------
// File: SetMeshFVFDlg.h
//
// Desc: Code to implement a dialog to let the user modify the FVF code of a
//       mesh.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// Name: class CSetMeshFvfDlg
// Desc: A dialog to let the user modify the FVF code of a mesh
//-----------------------------------------------------------------------------
class CSetMeshFvfDlg : public CDialog
{
    DECLARE_DYNAMIC(CSetMeshFvfDlg)
// Construction
public:
    CSetMeshFvfDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
    //{{AFX_DATA(CSetMeshFvfDlg)
    enum { IDD = IDD_SETMESHFVF };
    DWORD      m_dwFVF;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CSetMeshFvfDlg)
    afx_msg void OnControl();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\WriteXBG.cpp ===
//-----------------------------------------------------------------------------
// File: WriteXBG.cpp
//
// Desc: Writes a .xbg file from a CD3DFile class (with a hierarchy of CD3DFrame
//       classes).
//
//       See the XBG.h header file for a better description of .xbg geometry
//       files.
//
// NOTE: THIS CODE, AND THE FILE FORMAT IT CREATES, IS SUBJECT TO CHANGE. FEEL
//       FREE, AS WELL, TO EXPAND OR MODIFY THE FILE FORMAT TO FIT YOUR 
//       PERSONAL REQUIREMENTS.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include "xbg.h"


// File offset variables used during the writing of a geometry file to convert
// object pointers to file offsets.
DWORD g_dwMeshFileOffset;
DWORD g_dwSubsetFileOffset;
DWORD g_dwIndicesFileOffset;
DWORD g_dwVerticesFileOffset;

// Variables for how much file space each section of the file requires
DWORD g_dwNumFrames;
DWORD g_dwFrameSpace;
DWORD g_dwSubsetSpace;
DWORD g_dwIndicesSpace;
DWORD g_dwVerticesSpace;




//-----------------------------------------------------------------------------
// Name: ComputeMemoryRequirementsCB()
// Desc: Frame enumeration callback to compute memory requirements
//-----------------------------------------------------------------------------
BOOL ComputeMemoryRequirementsCB( CD3DFrame* pFrame, VOID* )
{
    g_dwNumFrames++;

    // Compute memory requirements
    g_dwFrameSpace    += sizeof(XBMESH_FRAME);
    g_dwSubsetSpace   += sizeof(XBMESH_SUBSET) * pFrame->m_dwNumMeshSubsets;
    g_dwIndicesSpace  += sizeof(WORD) * pFrame->m_dwNumMeshIndices;
    g_dwVerticesSpace += pFrame->m_dwMeshVertexSize * pFrame->m_dwNumMeshVertices;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: WriteMeshInfoCB()
// Desc: Writes mesh info to a file
//-----------------------------------------------------------------------------
BOOL WriteMeshInfoCB( CD3DFrame* pFrame, VOID* pData )
{
    FILE* file = (FILE*)pData;

    // Set up mesh info to be written. Note that, in order for Xbox fast math
	// (via xgmath.h) to work, all D3DXMATRIX's must be 16-byte aligned.
    XBMESH_FRAME frame;
    strcpy( frame.m_strName, pFrame->m_strFrameName );
    frame.m_pChild       = NULL;
    frame.m_pNext        = NULL;
    frame.m_matTransform = pFrame->m_matTransform;

    frame.m_MeshData.m_VB.Common     = 1 | D3DCOMMON_TYPE_VERTEXBUFFER;
    frame.m_MeshData.m_VB.Data       = 0L;
    frame.m_MeshData.m_VB.Lock       = 0L;
    frame.m_MeshData.m_dwNumVertices = pFrame->m_dwNumMeshVertices;
    frame.m_MeshData.m_IB.Common     = 1 | D3DCOMMON_TYPE_INDEXBUFFER;
    frame.m_MeshData.m_IB.Data       = 0L;
    frame.m_MeshData.m_IB.Lock       = 0L;
    frame.m_MeshData.m_dwNumIndices  = pFrame->m_dwNumMeshIndices;
    frame.m_MeshData.m_dwFVF         = pFrame->m_dwMeshFVF;
    frame.m_MeshData.m_dwVertexSize  = pFrame->m_dwMeshVertexSize;
    frame.m_MeshData.m_dwPrimType    = (pFrame->m_dwMeshPrimType == D3DPT_TRIANGLELIST) ? (D3DPRIMITIVETYPE)5 : (D3DPRIMITIVETYPE)6;;
    frame.m_MeshData.m_dwNumSubsets  = pFrame->m_dwNumMeshSubsets;
    frame.m_MeshData.m_pSubsets      = NULL;

	DWORD size = sizeof(frame);


    // Write pointers as file offsets
    if( pFrame->m_pChild )  
        frame.m_pChild = (XBMESH_FRAME*)( g_dwMeshFileOffset + ( pFrame->m_pChild->m_dwEnumeratedID - 1 )* sizeof(XBMESH_FRAME) );
    if( pFrame->m_pNext )   
        frame.m_pNext  = (XBMESH_FRAME*)( g_dwMeshFileOffset + ( pFrame->m_pNext->m_dwEnumeratedID - 1 ) * sizeof(XBMESH_FRAME) );
    if( pFrame->m_dwNumMeshSubsets )
        frame.m_MeshData.m_pSubsets = (XBMESH_SUBSET*)g_dwSubsetFileOffset;
    if( frame.m_MeshData.m_dwNumIndices )
        frame.m_MeshData.m_IB.Data  = (DWORD)g_dwIndicesFileOffset;
    if( frame.m_MeshData.m_dwNumVertices )
        frame.m_MeshData.m_VB.Data  = (DWORD)g_dwVerticesFileOffset;

    g_dwSubsetFileOffset   += sizeof(XBMESH_SUBSET) * pFrame->m_dwNumMeshSubsets;
    g_dwIndicesFileOffset  += sizeof(WORD) * pFrame->m_dwNumMeshIndices;
    g_dwVerticesFileOffset += pFrame->m_dwMeshVertexSize * pFrame->m_dwNumMeshVertices;

    // Write out mesh info
    fwrite( &frame, 1, sizeof(XBMESH_FRAME), file ); 

    return TRUE;
}


    

//-----------------------------------------------------------------------------
// Name: WriteSubsetsCB()
// Desc: Write out the mesh subsets
//-----------------------------------------------------------------------------
BOOL WriteSubsetsCB( CD3DFrame* pFrame, VOID* pData )
{
    FILE* file = (FILE*)pData;

    VOID* pTexturePtr = NULL;

    for( DWORD i=0; i<pFrame->m_dwNumMeshSubsets; i++ )
    {
        fwrite( &pFrame->m_pMeshSubsets[i].mtrl, sizeof(D3DMATERIAL8), 1, file ); 
        fwrite( &pTexturePtr, sizeof(VOID*), 1, file ); 
        fwrite(  pFrame->m_pMeshSubsets[i].strTexture,    sizeof(CHAR), 64, file ); 
        fwrite( &pFrame->m_pMeshSubsets[i].dwVertexStart, sizeof(DWORD), 1, file ); 
        fwrite( &pFrame->m_pMeshSubsets[i].dwVertexCount, sizeof(DWORD), 1, file ); 
        fwrite( &pFrame->m_pMeshSubsets[i].dwIndexStart,  sizeof(DWORD), 1, file ); 
        fwrite( &pFrame->m_pMeshSubsets[i].dwIndexCount,  sizeof(DWORD), 1, file ); 
    }

    return TRUE;
}


    

//-----------------------------------------------------------------------------
// Name: WriteIndicesCB()
// Desc: Write out the mesh indices
//-----------------------------------------------------------------------------
BOOL WriteIndicesCB( CD3DFrame* pFrame, VOID* pData )
{
    FILE* file = (FILE*)pData;

    if( pFrame->m_dwNumMeshIndices )
    {
        BYTE* pIndexData;
        pFrame->m_pMeshIB->Lock( 0, 0, &pIndexData, 0 );
        fwrite( pIndexData, sizeof(WORD), pFrame->m_dwNumMeshIndices, file ); 
        pFrame->m_pMeshIB->Unlock();
    }

    return TRUE;
}


    

//-----------------------------------------------------------------------------
// Name: WriteVerticesCB()
// Desc: Write out the mesh vertices
//-----------------------------------------------------------------------------
BOOL WriteVerticesCB( CD3DFrame* pFrame, VOID* pData )
{
    FILE* file = (FILE*)pData;

    if( pFrame->m_dwNumMeshVertices )
    {
        BYTE* pVertexData;
        pFrame->m_pMeshVB->Lock( 0, 0, &pVertexData, 0 );
        fwrite( pVertexData, pFrame->m_dwMeshVertexSize, pFrame->m_dwNumMeshVertices, file ); 
        pFrame->m_pMeshVB->Unlock();
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: WriteToXBG()
// Desc: Writes the geometry objects to a file
//-----------------------------------------------------------------------------
HRESULT CD3DFile::WriteToXBG( TCHAR* strFilename  )
{
    g_dwNumFrames = 0;

    // Before writing the file, walk the nodes to compute memory requirements
    g_dwFrameSpace    = 0;
    g_dwSubsetSpace   = 0;
    g_dwIndicesSpace  = 0;
    g_dwVerticesSpace = 0;
    m_pChild->EnumFrames( ComputeMemoryRequirementsCB, NULL );

    // As parts of the file are written, these global file offset variables
    // are used to convert object pointers to file offsets
    g_dwMeshFileOffset     = sizeof(XBG_HEADER);
    g_dwSubsetFileOffset   = g_dwMeshFileOffset + g_dwFrameSpace;
    g_dwIndicesFileOffset  = g_dwSubsetFileOffset + g_dwSubsetSpace;
    g_dwVerticesFileOffset = 0;

    // Setup the file header
    XBG_HEADER xbgHeader;
    xbgHeader.dwMagic         = XBG_FILE_ID;
    xbgHeader.dwNumMeshFrames = g_dwNumFrames;
    xbgHeader.dwSysMemSize    = g_dwFrameSpace + g_dwSubsetSpace + g_dwIndicesSpace;
    xbgHeader.dwVidMemSize    = g_dwVerticesSpace;

    // Open the file to write
    FILE* file = fopen( strFilename, "wb" );

    // Write out the header
    fwrite( &xbgHeader, sizeof(XBG_HEADER), 1, file ); 

    // Write the mesh's parts. Note that, starting at this file offset, in
	// order for Xbox fast math (via xgmath.h) to work, all D3DXMATRIX's must
	// be 16-byte aligned.
    m_pChild->EnumFrames( WriteMeshInfoCB, file );
    m_pChild->EnumFrames( WriteSubsetsCB,  file );
    m_pChild->EnumFrames( WriteIndicesCB,  file );
    m_pChild->EnumFrames( WriteVerticesCB, file );

    // Close the file
    fclose( file );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\TriStripper.h ===
//-----------------------------------------------------------------------------
// File: XBStrip.h
//
// Desc: Tristrip routines (which convert a mesh into a list of optimized
//       triangle strips).
//
// Hist: 02.01.01 - New for March XDK release
//       06.10.01 - Revised algorithm for better cache performance
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
#define OPTIMIZE_FOR_CACHE      0x00
#define OPTIMIZE_FOR_INDICES    0x01
#define OUTPUT_TRISTRIP         0x00
#define OUTPUT_TRILIST          0x02




//-----------------------------------------------------------------------------
// Name: Stripify()
// Desc: Main stripify routine. Stripifies a mesh and returns the number of 
//       strip indices contained in ppStripIndices.
// Note: Caller must make sure to call delete[] on the ppStripIndices array
//       when finished with it.
//-----------------------------------------------------------------------------
DWORD Stripify( DWORD  dwNumTriangles,   // Number of triangles
                WORD*  pTriangles,       // Ptr to triangle indices
                DWORD* pdwNumIndices,    // Number of output indices
                WORD** ppStripIndices,   // Output indices
                DWORD  dwFlags = 0 );    // Flags controlling optimizer.



//-----------------------------------------------------------------------------
// Name: ComputeVertexPermutation()
// Desc: Re-arrange vertices so that they occur in the order that they are
//       first used. Instead of actually moving vertex data around, this
//       function returns an array that specifies where (in the new vertex
//       array) each old vertex should go. It also re-maps the strip indices
//       to use the new vertex locations.
// Note: Caller must make sure to call delete[] on the pVertexPermutation array
//       when finished with it.
//-----------------------------------------------------------------------------
VOID ComputeVertexPermutation( DWORD  dwNumStripIndices,     // Number of strip indices
                               WORD*  pStripIndices,         // Ptr to strip indices
                               DWORD  dwNumVertices,         // Number of verticess in
                               WORD** ppVertexPermutation ); // Map from orignal index to remapped index
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VideoTest\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\TreeView.cpp ===
//-----------------------------------------------------------------------------
// File: TreeView.cpp
//
// Desc: MFC tree view class for displaying model information.
//
// Hist: 03.01.00 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "MakeXBG.h"


extern CMakeXBGApp g_App;




//-----------------------------------------------------------------------------
// Name: class CModelTreeView
// Desc: Tree view class to visualize mesh data.
//-----------------------------------------------------------------------------
IMPLEMENT_DYNCREATE(CModelTreeView, CTreeView)

BEGIN_MESSAGE_MAP(CModelTreeView, CTreeView)
    //{{AFX_MSG_MAP(CModelTreeView)
    ON_WM_MOUSEACTIVATE()
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CModelTreeView::CModelTreeView()
{
}

CModelTreeView::~CModelTreeView()
{
}




//-----------------------------------------------------------------------------
// Name: BuildTreeCB()
// Desc: Callback to build the tree view with detailed mesh information.
//-----------------------------------------------------------------------------
BOOL BuildTreeCB( CD3DFrame* pFrame, VOID* pData )
{
    CTreeCtrl* pTree = (CTreeCtrl*)pData;
    HTREEITEM  hParentItem;
    TCHAR      strBuffer[512];

    if( pFrame->m_pParent )
        hParentItem = pFrame->m_pParent->m_TreeData;
    else
        hParentItem = TVI_ROOT;

    TV_INSERTSTRUCT tvis;
    tvis.hInsertAfter   = TVI_LAST;
    tvis.item.mask      = TVIF_TEXT | TVIF_PARAM | TVIF_STATE;
    tvis.item.stateMask = TVIS_USERMASK;
    tvis.item.state     = 0x8000;

    if( pFrame->m_dwNumMeshSubsets > 0 )
    {
        // Fill tree info for mesh frames

        if( pFrame->m_strFrameName[0] )
            _stprintf( strBuffer, _T("Mesh: \"%s\""), pFrame->m_strFrameName );
        else
            _stprintf( strBuffer, _T("Mesh") );
        
        tvis.hParent        = hParentItem;
        tvis.item.pszText   = strBuffer;
        tvis.item.lParam    = (LONG)pFrame;
        hParentItem = pTree->InsertItem(&tvis);
        tvis.item.mask      = TVIF_TEXT | TVIF_PARAM;

        if( pFrame->m_pMeshVB )
        {
            _stprintf( strBuffer, _T("Num Polygons = %ld"), pFrame->m_dwNumMeshPolygons );
            tvis.hParent      = hParentItem;
            tvis.item.pszText = strBuffer;
            tvis.item.lParam  = 0;
            pTree->InsertItem(&tvis);

            _stprintf( strBuffer, _T("Num Vertices = %ld"), pFrame->m_dwNumMeshVertices );
            tvis.hParent      = hParentItem;
            tvis.item.pszText = strBuffer;
            tvis.item.lParam  = 0;
            pTree->InsertItem(&tvis);

            _stprintf( strBuffer, _T("Num Indices = %ld"), pFrame->m_dwNumMeshIndices );
            tvis.hParent      = hParentItem;
            tvis.item.pszText = strBuffer;
            tvis.item.lParam  = 0;
            pTree->InsertItem(&tvis);

            _stprintf( strBuffer, _T("FVF = 0x%08lx"), pFrame->m_dwMeshFVF );
            tvis.hParent      = hParentItem;
            tvis.item.pszText = strBuffer;
            tvis.item.lParam  = 2;
            pFrame->m_hFVFTreeItem = pTree->InsertItem(&tvis);
        }

        // Print subset info
        for( DWORD i=0; i < pFrame->m_dwNumMeshSubsets; i++ )
        {
            _stprintf( strBuffer, _T("Subset %d"), i );
            tvis.hParent        = hParentItem;
            tvis.item.mask      = TVIF_TEXT | TVIF_PARAM | TVIF_STATE;
            tvis.item.stateMask = TVIS_USERMASK;
            tvis.item.state     = 0x4000;
            tvis.item.pszText   = strBuffer;
            tvis.item.lParam    = i;
            HTREEITEM hSubsetSubTree = pTree->InsertItem(&tvis);
            tvis.item.mask      = TVIF_TEXT | TVIF_PARAM;

            {
                _stprintf( strBuffer, _T("Material") );
                tvis.hParent      = hSubsetSubTree;
                tvis.item.pszText = strBuffer;
                tvis.item.lParam  = 1;
                HTREEITEM hMaterialSubTree = pTree->InsertItem(&tvis);

                {
                    _stprintf( strBuffer, _T("Diffuse = (%f,%f,%f,%f)"), pFrame->m_pMeshSubsets[i].mtrl.Diffuse.r, pFrame->m_pMeshSubsets[i].mtrl.Diffuse.g, pFrame->m_pMeshSubsets[i].mtrl.Diffuse.b, pFrame->m_pMeshSubsets[i].mtrl.Diffuse.a );
                    tvis.hParent      = hMaterialSubTree;
                    tvis.item.pszText = strBuffer;
                    tvis.item.lParam  = 0;
                    pTree->InsertItem(&tvis);

                    _stprintf( strBuffer, _T("Ambient = (%f,%f,%f,%f)"), pFrame->m_pMeshSubsets[i].mtrl.Ambient.r, pFrame->m_pMeshSubsets[i].mtrl.Ambient.g, pFrame->m_pMeshSubsets[i].mtrl.Ambient.b, pFrame->m_pMeshSubsets[i].mtrl.Ambient.a );
                    tvis.item.pszText = strBuffer;
                    tvis.item.lParam  = 1;
                    pTree->InsertItem(&tvis);

                    _stprintf( strBuffer, _T("Specular = (%f,%f,%f,%f)"), pFrame->m_pMeshSubsets[i].mtrl.Specular.r, pFrame->m_pMeshSubsets[i].mtrl.Specular.g, pFrame->m_pMeshSubsets[i].mtrl.Specular.b, pFrame->m_pMeshSubsets[i].mtrl.Specular.a );
                    tvis.item.pszText = strBuffer;
                    tvis.item.lParam  = 2;
                    pTree->InsertItem(&tvis);

                    _stprintf( strBuffer, _T("Emissive = (%f,%f,%f,%f)"), pFrame->m_pMeshSubsets[i].mtrl.Emissive.r, pFrame->m_pMeshSubsets[i].mtrl.Emissive.g, pFrame->m_pMeshSubsets[i].mtrl.Emissive.b, pFrame->m_pMeshSubsets[i].mtrl.Emissive.a );
                    tvis.item.pszText = strBuffer;
                    tvis.item.lParam  = 3;
                    pTree->InsertItem(&tvis);

                    _stprintf( strBuffer, _T("Power = %f"), pFrame->m_pMeshSubsets[i].mtrl.Power );
                    tvis.item.pszText = strBuffer;
                    tvis.item.lParam  = 4;
                    pTree->InsertItem(&tvis);

                    if( pFrame->m_pMeshSubsets[i].strTexture[0] )
                        _stprintf( strBuffer, _T("Texture = \"%s\""), pFrame->m_pMeshSubsets[i].strTexture );
                    else
                        _stprintf( strBuffer, _T("Texture = NULL") );
                    tvis.item.pszText = strBuffer;
                    tvis.item.lParam  = 5;
                    pTree->InsertItem(&tvis);
                }

                _stprintf( strBuffer, _T("Vertex Start = %ld"), pFrame->m_pMeshSubsets[i].dwVertexStart );
                tvis.hParent      = hSubsetSubTree;
                tvis.item.pszText = strBuffer;
                tvis.item.lParam  = 0;
                pTree->InsertItem(&tvis);

                _stprintf( strBuffer, _T("Vertex Count = %ld"), pFrame->m_pMeshSubsets[i].dwVertexCount );
                tvis.item.pszText = strBuffer;
                tvis.item.lParam  = 1;
                pTree->InsertItem(&tvis);

                _stprintf( strBuffer, _T("Index Start = %ld"), pFrame->m_pMeshSubsets[i].dwIndexStart );
                tvis.item.pszText = strBuffer;
                tvis.item.lParam  = 2;
                pTree->InsertItem(&tvis);

                _stprintf( strBuffer, _T("Index Count = %ld"), pFrame->m_pMeshSubsets[i].dwIndexCount );
                tvis.item.pszText = strBuffer;
                tvis.item.lParam  = 3;
                pTree->InsertItem(&tvis);
            }
        }
    }
    else
    {
        if( pFrame->m_pParent == NULL )
        {
            // Fill tree info for the root frame

            _stprintf( strBuffer, _T("File: \"%s\""), pFrame->m_strFrameName );

            tvis.hParent        = hParentItem;
            tvis.item.pszText   = strBuffer;
            tvis.item.lParam    = (LONG)pFrame;
            hParentItem = pTree->InsertItem(&tvis);
            tvis.item.mask      = TVIF_TEXT | TVIF_PARAM;

            CD3DFile* pRoot = (CD3DFile*)pFrame;

            _stprintf( strBuffer, _T("Num Polygons = %ld"), pRoot->m_dwNumPolygons );
            tvis.hParent      = hParentItem;
            tvis.item.pszText = strBuffer;
            tvis.item.lParam  = 0;
            pTree->InsertItem(&tvis);

            _stprintf( strBuffer, _T("Num Vertices = %ld"), pRoot->m_dwNumVertices );
            tvis.hParent      = hParentItem;
            tvis.item.pszText = strBuffer;
            tvis.item.lParam  = 0;
            pTree->InsertItem(&tvis);

            _stprintf( strBuffer, _T("Num Indices = %ld"), pRoot->m_dwNumIndices );
            tvis.hParent      = hParentItem;
            tvis.item.pszText = strBuffer;
            tvis.item.lParam  = 0;
            pTree->InsertItem(&tvis);
        }
        else
        {
            // Fill tree info for transformation frames
            
            if( pFrame->m_strFrameName[0] )
                _stprintf( strBuffer, _T("Frame: \"%s\""), pFrame->m_strFrameName );
            else
                _stprintf( strBuffer, _T("Frame") );

            tvis.hParent        = hParentItem;
            tvis.item.pszText   = strBuffer;
            tvis.item.lParam    = (LONG)pFrame;
            hParentItem = pTree->InsertItem(&tvis);
            tvis.item.mask      = TVIF_TEXT | TVIF_PARAM;

            // Insert the matrix info   
            if( ( pFrame->m_pParent != NULL ) )
            {
                _stprintf( strBuffer, _T("Matrix") );
                tvis.hParent      = hParentItem;
                tvis.item.pszText = strBuffer;
                tvis.item.lParam  = 0;
                HTREEITEM hMatrixSubTree = pTree->InsertItem(&tvis);

                for( DWORD r = 0; r < 4; r++ )
                {
                    _stprintf( strBuffer, _T("(%f,%f,%f,%f)"), ((FLOAT*)pFrame->m_matTransform)[r*4+0], 
                                                               ((FLOAT*)pFrame->m_matTransform)[r*4+1], 
                                                               ((FLOAT*)pFrame->m_matTransform)[r*4+2], 
                                                               ((FLOAT*)pFrame->m_matTransform)[r*4+3] );
                    tvis.hParent      = hMatrixSubTree;
                    tvis.item.pszText = strBuffer;
                    tvis.item.lParam  = r;
                    pTree->InsertItem(&tvis);
                }
            }
        }
    }

    // Set the HTREEITEM for this frame
    pFrame->m_TreeData = hParentItem;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: SelectFrameCB()
// Desc: Callback to tag certain frames as selected.
//-----------------------------------------------------------------------------
BOOL SelectFrameCB( CD3DFrame* pFrame, VOID* pData )
{
    CD3DFrame* pSelectedFrame = (CD3DFrame*)pData;
    CD3DFrame* pSeekFrame     = pFrame;

    while( pSeekFrame )
    {
        if( pSeekFrame == pSelectedFrame )
        {
            pFrame->m_bVisible = TRUE;
            return TRUE;
        }
        pSeekFrame = pSeekFrame->m_pParent;
    }
    pFrame->m_bVisible = FALSE;

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ClearSubsetSelectionCB()
// Desc: Simple callback to clear all the mesh subset selections.
//-----------------------------------------------------------------------------
BOOL ClearSubsetSelectionCB( CD3DFrame* pFrame, VOID* pData )
{
    pFrame->m_lSelectedSubset = -1;
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: OnUpdate()
// Desc: Builds the tree view. All the work is done in the callback, which adds
//       detailed mesh info into the tree view.
//-----------------------------------------------------------------------------
void CModelTreeView::OnUpdate( CView* pSender, LPARAM lHint, CObject* pHint )
{
    CTreeCtrl&    tree  = GetTreeCtrl();
    CXBGDocument* pDoc  = GetDocument();
    CD3DFile*     pMesh = pDoc->m_pD3DFile;

    if( pMesh )
    {
        // Empty the tree
        tree.DeleteAllItems();

        // Set a base style for the tree control
        tree.ModifyStyle( 0L, TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | 
                              TVS_DISABLEDRAGDROP | TVS_SHOWSELALWAYS );

        // Add items to the control
        pMesh->EnumFrames( BuildTreeCB, &tree );

        // Expand the root tree item
        tree.Expand( tree.GetFirstVisibleItem(), TVE_EXPAND );
        tree.SelectItem(tree.GetFirstVisibleItem());
    }
}




//-----------------------------------------------------------------------------
// Name: OnSelchanged()
// Desc: Handle the tree view's selection changes.
//-----------------------------------------------------------------------------
VOID CModelTreeView::OnSelchanged( NMHDR*, LRESULT* pResult ) 
{
    // Select a subset if one is chosen on the tree ctrl
    CXBGDocument* pDoc = GetDocument();

    CTreeCtrl& tree  = GetTreeCtrl();
    HTREEITEM  hItem = tree.GetSelectedItem();

    pDoc->m_pD3DFile->EnumFrames( ClearSubsetSelectionCB, NULL );
    pDoc->m_pSelectedFrame  = NULL;
    pDoc->m_lSelectedSubset = -1;

    while( hItem )
    {
        // If this was tagged as a mesh, select it
        if( ( TVIS_USERMASK & tree.GetItemState(hItem, TVIS_USERMASK) ) == 0x00004000 )
        {
            pDoc->m_lSelectedSubset = tree.GetItemData(hItem);
        }

        // If this was tagged as a frame, select it
        if( ( TVIS_USERMASK & tree.GetItemState(hItem, TVIS_USERMASK) ) == 0x00008000 )
        {
            pDoc->m_pSelectedFrame = (CD3DFrame*)tree.GetItemData(hItem);
            pDoc->m_pD3DFile->EnumFrames( SelectFrameCB, pDoc->m_pSelectedFrame );
            pDoc->m_pSelectedFrame->m_lSelectedSubset = pDoc->m_lSelectedSubset;

            pDoc->m_pTreeCtrl = &tree;

            if( pDoc->m_pSelectedFrame->m_dwMeshFVF )
            {
                CMenu* pMenu = g_App.m_pMainWnd->GetMenu();
                pMenu->EnableMenuItem( IDM_SETMESHFVF, MF_ENABLED );
                pMenu->EnableMenuItem( IDM_STRIPIFY, MF_ENABLED );
            }
            else
            {
                CMenu* pMenu = g_App.m_pMainWnd->GetMenu();
                pMenu->EnableMenuItem( IDM_SETMESHFVF, MF_GRAYED|MF_DISABLED );
                pMenu->EnableMenuItem( IDM_STRIPIFY, MF_GRAYED|MF_DISABLED );
            }

            break;
        }

        hItem = tree.GetParentItem( hItem );
    }

    // Render the scene with the changes
    ((CSplitterFrame*)GetParentFrame())->m_pD3DRenderView->OnDraw( NULL );

    if( pResult )
        (*pResult) = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\TriStripper.cpp ===
//-----------------------------------------------------------------------------
// File: XBStrip.cpp
//
// Desc: Tristrip routines (which convert a mesh into a list of optimized
//       triangle strips).
//
// Hist: 02.01.01 - New for March XDK release
//       06.10.01 - Revised algorithm for better cache performance
//       02.14.01 - Fixed some memory leaks
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <stdarg.h>
#include <algorithm> // This is the STL header for the sort template

#include <assert.h>

#if defined(_XBOX)
#include <xtl.h>
#else
#include <limits.h>
#include <D3D8.h>
#endif

#include "TriStripper.h"




// Cache size to optimize for.  The actual cache size is 24, but it is in 
// general not good to use the oldest 6 entries.
#define CACHE_SIZE 18


// Estimated length of the vertex shader to use when comparing the cost of
// different stripifications.
#define SHADER_CYCLES 20




//-----------------------------------------------------------------------------
// structs
//-----------------------------------------------------------------------------
typedef WORD (*TRIANGLELIST)[3];


struct TRIANGLEINFO
{
    int neighbortri[3];     // Triangle sharing edge (i,i+1), or -1
    int neighboredge[3];    // Edge (j,j+1) of neighboring triangle.
};




//-----------------------------------------------------------------------------
// Name: struct CStrip
// Desc: A single triangle strip. After a mesh is stripified, it typically is 
//       composed of several of these.
//-----------------------------------------------------------------------------
struct CStrip
{
    BOOL  m_bIsStripCW;

    DWORD m_dwNumTriangles;
    int*  m_pTriangles;

    DWORD m_dwNumIndices;
    WORD* m_pIndices;

    DWORD m_dwNumNeighbors;

    CStrip( DWORD num_tris, DWORD num_indices ) 
    {
        m_dwNumTriangles = num_tris;
        m_pTriangles = new int[ num_tris ]; 

        m_dwNumIndices = num_indices;
        m_pIndices = new WORD[ num_indices ];
    }

    ~CStrip()
    {
        delete[] m_pTriangles;
        delete[] m_pIndices;
    }
};




//-----------------------------------------------------------------------------
// Name: struct CSubStrip
// Desc: A structure that specifies part of a strip in a striplist.
//-----------------------------------------------------------------------------
struct CSubStrip
{
    int m_iStrip;   // Index into striplist.
    int m_iStart;   // Starting triangle index
    int m_iEnd;     // Ending triangle index.
};




//-----------------------------------------------------------------------------
// Name: struct CStripList
// Desc: A list of triangle strips.
//-----------------------------------------------------------------------------
struct CStripList
{
    CStrip** m_pStrips;
    DWORD    m_dwNumStrips;

    CStrip** begin() { return (m_dwNumStrips) ? &m_pStrips[0] : NULL; }

    VOID RemoveStripFromList( CStrip** pStrip )
    {
        for( DWORD i=0; i<m_dwNumStrips; i++ )
        {
            if( &m_pStrips[i] == pStrip )
            {
                delete m_pStrips[i];
                m_dwNumStrips--;

                while( i < m_dwNumStrips )
                {
                    m_pStrips[i] = m_pStrips[i+1];
                    i++;
                }
                break;
            }
        }
    }
    
    VOID RemoveFirst()
    {
        RemoveStripFromList( &m_pStrips[0] );
    }

    VOID AddStripToList( CStrip* pStrip )
    {
        m_pStrips[m_dwNumStrips++] = pStrip;
    }

    CStripList(DWORD dwMaxSize)
    {
        m_pStrips     = new CStrip*[dwMaxSize];
        m_dwNumStrips = 0L;
    }

    ~CStripList()
    {
        for( DWORD i=0; i<m_dwNumStrips; i++ )
        {
            delete m_pStrips[i];
        }

        delete[] m_pStrips;
    }
};




//-----------------------------------------------------------------------------
// Class used to vertices for locality of access.
//-----------------------------------------------------------------------------
struct SortEntry
{
    int iFirstUsed;
    int iOrigIndex;

    // Define the < operator, which is needed for the STL sort() routine.
    BOOL operator<( const SortEntry& rhs ) { return iFirstUsed < rhs.iFirstUsed; }
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: vertex cache class
//-----------------------------------------------------------------------------
class CVertCache
{
public:
    CVertCache()    { Reset(); }
    ~CVertCache()   {};

    // Reset cache
    void Reset()
    {
        m_iCachePtr = 0;
        m_cachehits = 0;
        memset( m_rgCache, 0xff, sizeof(m_rgCache) );
    }

    // Add vertindex to cache
    int Add(int strip, int vertindex);

    // Check if a vert is in the cache.
    BOOL IsCached(int vertindex)
    {
        for( int iCache = 0; iCache < CACHE_SIZE; iCache++ )
        {
            if( vertindex == m_rgCache[iCache] )
            {
                // Item is in the cache
                return TRUE;
            }
        }

        return FALSE;
    }

    // Check if a vert uses one of the last two cached verts.
    BOOL IsOld(int vertindex)
    {
        if( vertindex == m_rgCache[m_iCachePtr] )
        {
            // Item is in the cache
            return TRUE;
        }

        return FALSE;
    }

    int NumCacheHits() const
    {
        return m_cachehits;
    }

private:
    int  m_cachehits;                // current # of cache hits
    WORD m_rgCache[CACHE_SIZE];      // vertex cache
    int  m_rgCacheStrip[CACHE_SIZE]; // strip # which added or re-used vert
    int  m_iCachePtr;                // fifo ptr
    bool m_bReUsed[CACHE_SIZE];      // true if vert was re-used.
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: main stripper class
//-----------------------------------------------------------------------------
class CStripper
{
public:
    int           m_dwNumTris;   // # tris
    TRIANGLELIST  m_pTriangles;  // trilist

    TRIANGLEINFO* m_pTriInfo;    // tri edge, neighbor info
    int*          m_pUsed;       // tri used flag

    // ctors/dtors
    CStripper( int dwNumtris, TRIANGLELIST pTriangles );
    ~CStripper();

    // initialize tri info
    VOID InitTriangleInfo( int tri, int vert );

    // get maximum length strip from tri/vert
    int CreateStrip( int tri, int vert, int maxlen, int *pswaps, 
                     BOOL bLookAhead, BOOL bNonSequential, BOOL bStartCW, 
                     int* pTris );

    // Turn a list of triangles into indices.
    int CreateIndices( BOOL bStartCW, int iNumTriangles, int* pTriangles, 
                       WORD* pStripVerts );

    // stripify entire mesh
    VOID BuildStrips( CStripList* pStripList, int maxlen, BOOL bLookAhead, 
                      BOOL bNonSequential, BOOL bSwapOrientation );

    // blast strip indices to ppstripindices
    int CreateManyStrips( CStripList *pstriplist, WORD **ppstripindices );
    int CreateLongStrip( CStripList *pstriplist, WORD **ppstripindices );
    int CreateCachedStrip( CStripList *pstriplist, WORD **ppstripindices );

    // find the best cached strip.
    CStrip** FindBestCachedStrip( CStripList* pStripList, const CVertCache &VertexCache );

    int GetNeighborCount( int tri )
    {
        int count = 0;
        for( int vert = 0; vert < 3; vert++ )
        {
            int neighbortri = m_pTriInfo[tri].neighbortri[vert];
            count += (neighbortri != -1) && !m_pUsed[neighbortri];
        }
        return count;
    }
};




//-----------------------------------------------------------------------------
// Name: CreateStrip()
// Desc: Get maximum length of strip starting at tri/vert
//-----------------------------------------------------------------------------
int CStripper::CreateStrip( int tri, int vert, int maxlen, int *pswaps,
                            BOOL bLookAhead, BOOL bNonSequential, 
                            BOOL bStartCW, int* pTris )
{
    *pswaps = 0;

    // this guy has already been used?
    if(m_pUsed[tri])
        return 0;

    // mark tri as used
    m_pUsed[tri] = 1;

    int swaps = 0;

    // add first tri
    int iNumTris = 0;
    pTris[iNumTris++] = tri;

    bStartCW = !bStartCW;

    // get next tri information
    int edge     = (bStartCW ? vert + 2 : vert + 1) % 3;
    int nexttri  = m_pTriInfo[tri].neighbortri[edge];
    int nextvert = m_pTriInfo[tri].neighboredge[edge];

    // start building the strip until we run out of room or indices
    for(int stripcount = 3; stripcount < maxlen; stripcount++)
    {
        // dead end?
        if(nexttri == -1 || m_pUsed[nexttri])
            break;

        // move to next tri
        tri  = nexttri;
        vert = nextvert;

        // toggle orientation
        bStartCW = !bStartCW;

        // find the next natural edge
        int edge = (bStartCW ? vert + 2 : vert + 1) % 3;
        nexttri  = m_pTriInfo[tri].neighbortri[edge];
        nextvert = m_pTriInfo[tri].neighboredge[edge];

        BOOL bSwap = FALSE;
        if(nexttri == -1 || m_pUsed[nexttri])
        {
            // if the next tri is a dead end - try swapping orientation
            bSwap = TRUE;
        }
        else if( bLookAhead )
        {
            // try a swap and see who our new neighbor would be
            int edgeswap     = (bStartCW ? vert + 1 : vert + 2) % 3;
            int nexttriswap  = m_pTriInfo[tri].neighbortri[edgeswap];
            int nextvertswap = m_pTriInfo[tri].neighboredge[edgeswap];

            if( nexttriswap != -1 && !m_pUsed[nexttriswap] )
            {
                // if the swap neighbor has a lower count, change directions
                if( GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri) )
                {
                    bSwap = TRUE;
                }
                else if( GetNeighborCount(nexttriswap) == GetNeighborCount(nexttri) )
                {
                    // if they have the same number of neighbors - check their neighbors
                    edgeswap    = (bStartCW ? nextvertswap + 2 : nextvertswap + 1) % 3;
                    nexttriswap = m_pTriInfo[nexttriswap].neighbortri[edgeswap];

                    int edge1    = (bStartCW ? nextvert + 1 : nextvert + 2) % 3;
                    int nexttri1 = m_pTriInfo[nexttri].neighbortri[edge1];

                    if( nexttri1 == -1 || m_pUsed[nexttri1] )
                    {
                        // natural winding order leads us to a dead end so turn
                        bSwap = TRUE;
                    }
                    else if( nexttriswap != -1 && !m_pUsed[nexttriswap] )
                    {
                        // check neighbor counts on both directions and swap if it's better
                        if( GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri1) )
                            bSwap = TRUE;
                    }
                }
            }
        }

        if( bSwap && bNonSequential )
        {
            // we've been told to change directions so make sure we actually can
            // and then add the swap vertex
            int edgeswap = (bStartCW ? vert + 1 : vert + 2) % 3;
            nexttri      = m_pTriInfo[tri].neighbortri[edgeswap];
            nextvert     = m_pTriInfo[tri].neighboredge[edgeswap];

            if( nexttri != -1 && !m_pUsed[nexttri] )
            {
                stripcount++;
                swaps++;
                bStartCW = !bStartCW;
            }
        }

        pTris[iNumTris++] = tri;

        // mark triangle as used
        m_pUsed[tri] = 1;
    }

    // clear the used flags
    for( int j = 0; j < iNumTris; j++ )
        m_pUsed[pTris[j]] = 0;

    // return swap count and striplen
    *pswaps = swaps;

    return iNumTris;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateIndices()
// Desc: Make strip indices from triangle list.
//-----------------------------------------------------------------------------
int CStripper::CreateIndices( BOOL bStartCW, int iNumTriangles, int* pTriangles, WORD* pStripVerts )
{
    int stripcount = 0;
    BOOL bCW = bStartCW;
    int in_edge = -1;

    for( int i = 0; i < iNumTriangles; i++ )
    {
        int out_edge;

        int tri = pTriangles[i];

        // get next tri information
        if( i < iNumTriangles-1 )
        {
            int nexttri = pTriangles[i+1];

            for( out_edge = 0; out_edge < 3; out_edge++ )
                if( m_pTriInfo[tri].neighbortri[out_edge] == nexttri )
                    break;
        }
        else
        {
            out_edge = (bCW ? (in_edge + 1) : (in_edge + 2)) % 3;
        }

        if( i == 0 )
        {
            if( bCW )
            {
                pStripVerts[0] = m_pTriangles[tri][(out_edge + 2) % 3];
                pStripVerts[1] = m_pTriangles[tri][(out_edge + 0) % 3];
                pStripVerts[2] = m_pTriangles[tri][(out_edge + 1) % 3];
            }
            else
            {
                pStripVerts[0] = m_pTriangles[tri][(out_edge + 2) % 3];
                pStripVerts[1] = m_pTriangles[tri][(out_edge + 1) % 3];
                pStripVerts[2] = m_pTriangles[tri][(out_edge + 0) % 3];
            }

            stripcount = 3;
        }
        else
        {
            if( out_edge == (bCW ? (in_edge + 1) : (in_edge + 2)) % 3 )
            {
                // In order.
                pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
            }
            else
            {
                // Swap.
                if( bCW )
                {
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 0) % 3];
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
                }
                else
                {
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 1) % 3];
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
                }

                bCW = !bCW;
            }
        }

        in_edge = m_pTriInfo[tri].neighboredge[out_edge];
        bCW = !bCW;
    }

    return stripcount;
}




//-----------------------------------------------------------------------------
// Name: FindBestStrip()
// Desc: Given a striplist and current cache state, pick the best next strip
//-----------------------------------------------------------------------------
CStrip** FindBestStrip( CStripList* pStripList,
                              const CVertCache &VertexCache )
{
    if( 0 == pStripList->m_dwNumStrips ) 
        return NULL;

    CStrip** ppBestStrip       = pStripList->begin();
    DWORD    dwBestStripLen    = (*ppBestStrip)->m_dwNumIndices;
    BOOL     bStartCW          = (*ppBestStrip)->m_bIsStripCW;
    BOOL     bBestStripFlipped = FALSE;
    int      MaxCacheHits      = -1;

    // Go through all the other strips looking for the best caching
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip        = pStripList->m_pStrips[i];
        DWORD   dwStripLen    = pStrip->m_dwNumIndices;
        BOOL    bStripFlipped = FALSE;

        // Check cache if this strip is the same type as us (ie: cw/odd)
        if( ( pStrip->m_bIsStripCW == bStartCW) && ( (dwBestStripLen & 0x1) == (dwStripLen & 0x1) ) )
        {
            // Copy current state of cache
            CVertCache NewVertexCache = VertexCache;

            // Figure out what this guy would do to our cache
            for( DWORD ivert = 0; ivert < dwStripLen; ivert++ )
                NewVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

            // For even length strips - see if we can get better cache hits
            // if we reverse the vertex cache contents
            if( !(dwStripLen & 0x1) )
            {
                // Create a copy of the vertex cache, with all vertices flipped
                CVertCache FlippedVertexCache = VertexCache;
                for( int ivert = pStrip->m_dwNumIndices-1; ivert >= 0; ivert-- )
                    FlippedVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

                // Accept the flipped cache if it gives us more cahce hits
                if( FlippedVertexCache.NumCacheHits() > NewVertexCache.NumCacheHits() )
                {
                    NewVertexCache = FlippedVertexCache;
                    bStripFlipped  = TRUE;
                }
            }

            // Record the best number of cache hits to date
            int NumCacheHits = NewVertexCache.NumCacheHits() - VertexCache.NumCacheHits();
            
            if( NumCacheHits > MaxCacheHits )
            {
                MaxCacheHits      = NumCacheHits;
                ppBestStrip       = &pStripList->m_pStrips[i];
                dwBestStripLen    = dwStripLen;//? added by mikey
                bBestStripFlipped = bStripFlipped;
            }
        }
    }

    if( bBestStripFlipped )
    {
        CStrip* pStrip = *ppBestStrip;
        int first = 0;
        int last  = pStrip->m_dwNumIndices - 1;

        while( first < last )
        {
            // Swap vertex indices
            WORD temp                 = pStrip->m_pIndices[first];
            pStrip->m_pIndices[first] = pStrip->m_pIndices[last];
            pStrip->m_pIndices[last]  = temp;
            first++;
            last--;
        }
    }

    // Make sure we keep the list in order and always pull off
    // the first dude.
    if( ppBestStrip != pStripList->begin() )
    {
        // Swap strips
        CStrip* temp           = (*ppBestStrip);
        (*ppBestStrip)         = (*pStripList->begin());
        (*pStripList->begin()) = temp;
    }

    return pStripList->begin();
}




//-----------------------------------------------------------------------------
// Name: CStripper::FindBestCachedStrip()
// Desc: Given a striplist and current cache state, pick the best next strip
//-----------------------------------------------------------------------------
CStrip** CStripper::FindBestCachedStrip( CStripList* pStripList,
                                         const CVertCache &VertexCache )
{
    if( 0 == pStripList->m_dwNumStrips ) 
        return NULL;

    CStrip** ppBestStrip       = pStripList->begin();

    BOOL     bBestStripFlipped = FALSE;

    int      MaxCacheHits      = -1;

    DWORD    dwBestNeighborCount = (*ppBestStrip)->m_dwNumNeighbors;

    // Go through all the other strips looking for the best caching
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip        = pStripList->m_pStrips[i];
        DWORD   dwStripLen    = pStrip->m_dwNumIndices;
        BOOL    bStripFlipped = FALSE;

        // Copy current state of cache
        CVertCache NewVertexCache = VertexCache;

        // Figure out what this guy would do to our cache
        for( DWORD ivert = 0; ivert < dwStripLen; ivert++ )
            NewVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

        // See if we can get better cache hits if we reverse the order we draw
        // the strip in.
        {
            // Create a copy of the vertex cache, with all vertices flipped
            CVertCache FlippedVertexCache = VertexCache;
            for( int ivert = pStrip->m_dwNumIndices-1; ivert >= 0; ivert-- )
                FlippedVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

            // Accept the flipped cache if it gives us more cahce hits
            if( FlippedVertexCache.NumCacheHits() > NewVertexCache.NumCacheHits() )
            {
                NewVertexCache = FlippedVertexCache;
                bStripFlipped  = TRUE;
            }
        }

        // Record the best number of cache hits to date
        int NumCacheHits = NewVertexCache.NumCacheHits() - VertexCache.NumCacheHits();
        
        if( NumCacheHits > MaxCacheHits )
        {
            MaxCacheHits        = NumCacheHits;
            ppBestStrip         = &pStripList->m_pStrips[i];
            bBestStripFlipped   = bStripFlipped;
            dwBestNeighborCount = pStripList->m_pStrips[i]->m_dwNumNeighbors;
        }
        else if ( NumCacheHits == MaxCacheHits && 
                  pStripList->m_pStrips[i]->m_dwNumNeighbors < dwBestNeighborCount )
        {
            ppBestStrip         = &pStripList->m_pStrips[i];
            bBestStripFlipped   = bStripFlipped;
            dwBestNeighborCount = pStripList->m_pStrips[i]->m_dwNumNeighbors;
        }
    }

    if( bBestStripFlipped )
    {
        CStrip* pStrip = *ppBestStrip;
        int first = 0;
        int last  = pStrip->m_dwNumIndices - 1;

        while( first < last )
        {
            // Swap vertex indices
            WORD temp                 = pStrip->m_pIndices[first];
            pStrip->m_pIndices[first] = pStrip->m_pIndices[last];
            pStrip->m_pIndices[last]  = temp;
            first++;
            last--;
        }

        // We must also reverse the starting winding for odd length strips.
        if( (pStrip->m_dwNumIndices & 0x1) )
        {
            pStrip->m_bIsStripCW = !pStrip->m_bIsStripCW;
        }
    }

    // Make sure we keep the list in order and always pull off
    // the first dude.
    if( ppBestStrip != pStripList->begin() )
    {
        // Swap strips
        CStrip* temp           = (*ppBestStrip);
        (*ppBestStrip)         = (*pStripList->begin());
        (*pStripList->begin()) = temp;
    }

    return pStripList->begin();
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateManyStrips()
// Desc: Don't merge the strips - just blast em into the stripbuffer one by one
//       (useful for debugging)
//-----------------------------------------------------------------------------
int CStripper::CreateManyStrips( CStripList* pStripList, WORD** ppStripIndices )
{
    // Count the number of indices. Allow room for each of the strips size
    // plus the final 0
    DWORD dwIndexCount = pStripList->m_dwNumStrips + 1;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        // Add striplength plus potential degenerate to swap ccw --> cw
        dwIndexCount += pStripList->m_pStrips[i]->m_dwNumIndices + 1;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    DWORD      dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Loop through all strips
    CStrip** ppStrip = pStripList->begin();

    while( pStripList->m_dwNumStrips > 0 )
    {
        CStrip* pStrip = *ppStrip;

        if( !pStrip->m_bIsStripCW )
        {
            // add an extra index if it's ccw
            pStripIndices[dwNumStripIndices++] = (WORD)pStrip->m_dwNumIndices + 1;
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[0];
        }
        else
        {
            // add the strip length
            pStripIndices[dwNumStripIndices++] = (WORD)pStrip->m_dwNumIndices;
        }

        // add all the strip indices
        for( DWORD i = 0; i < pStrip->m_dwNumIndices; i++)
        {
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[i];
            VertexCache.Add( 1, pStrip->m_pIndices[i] );
        }

        // free this guy and pop him off the list
        pStripList->RemoveFirst();

        // Get the next best strip
        ppStrip = FindBestStrip( pStripList, VertexCache );
    }

    // add terminating zero
    pStripIndices[dwNumStripIndices++] = 0;
    (*ppStripIndices) = pStripIndices;

    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateLongStrip()
// Desc: Merge striplist into one big uberlist with (hopefully) optimal caching
//-----------------------------------------------------------------------------
int CStripper::CreateLongStrip( CStripList* pStripList, WORD** ppwStripIndices )
{
    // Allow room for one strip length plus a possible 3 extra indices per
    // concatenated strip list plus the final 0
    int dwIndexCount = (pStripList->m_dwNumStrips * 3) + 2;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( DWORD i=0; i < pStripList->m_dwNumStrips; i ++ )
    {
        dwIndexCount += pStripList->m_pStrips[i]->m_dwNumIndices;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    int        dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Add first strip
    CStrip** ppStrip = pStripList->begin();
    CStrip*  pStrip = *ppStrip;

    // Note: first strip should be cw

    for( DWORD ivert = 0; ivert < pStrip->m_dwNumIndices; ivert++ )
    {
        pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[ivert];
        VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
    }

    // Kill first dude
    pStripList->RemoveStripFromList( ppStrip );

    // Add all the others
    while( pStripList->m_dwNumStrips )
    {
        ppStrip = FindBestStrip( pStripList, VertexCache );
        CStrip* pStrip = *ppStrip;
        WORD wLastVertex  = pStripIndices[dwNumStripIndices - 1];
        WORD wFirstVertex = pStrip->m_pIndices[0];

        if( wFirstVertex != wLastVertex )
        {
            // Add degenerate from last strip
            pStripIndices[dwNumStripIndices++] = wLastVertex;

            // Add degenerate from our strip
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // If we're not orientated correctly, we need to add a degenerate
        if( pStrip->m_bIsStripCW != !(dwNumStripIndices & 0x1) )
        {
            // This shouldn't happen - we're currently trying very hard
            // to keep everything oriented correctly.
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // Add these verts
        for( DWORD ivert = 0; ivert < pStrip->m_dwNumIndices; ivert++ )
        {
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[ivert];
            VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
        }

        // Free these guys
        pStripList->RemoveStripFromList( ppStrip );
    }

    (*ppwStripIndices) = pStripIndices;
    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateCachedStrip()
// Desc: Merge striplist into one big uberlist with (hopefully) optimal caching
//-----------------------------------------------------------------------------
int CStripper::CreateCachedStrip( CStripList* pStripList, WORD** ppwStripIndices )
{
    DWORD i;
    WORD pTempVerts[CACHE_SIZE*4];

    // Split up the strips into cache friendly pieces.
    CStripList* pNewList = new CStripList(m_dwNumTris);

    while( pStripList->m_dwNumStrips )
    {
        CStrip** ppStrip = pStripList->begin();
        CStrip* pStrip = *ppStrip;

        int start = 0;
        int ssize = pStrip->m_dwNumTriangles;

        do
        {
            int dsize = ssize;

            if (dsize > CACHE_SIZE)
                dsize = CACHE_SIZE;

            int j = pNewList->m_dwNumStrips++;

            // Create temp triaingle list/index list.
            int num_indices = CreateIndices( pStrip->m_bIsStripCW, dsize, 
                                             pStrip->m_pTriangles + start, 
                                             pTempVerts );
    
            // Make new strip.
            pNewList->m_pStrips[j] = new CStrip( dsize, num_indices );

            pNewList->m_pStrips[j]->m_bIsStripCW = pStrip->m_bIsStripCW;

            // Copy triangles.
            memcpy( pNewList->m_pStrips[j]->m_pTriangles, 
                    pStrip->m_pTriangles + start, dsize * sizeof(int) );

            // Copy indices.
            memcpy( pNewList->m_pStrips[j]->m_pIndices, 
                    pTempVerts, num_indices * sizeof(WORD) );

            start += dsize;
            ssize -= dsize;
        }
        while (ssize > 0);

        pStripList->RemoveStripFromList( ppStrip );
    }

    // Count the number of adjacent triangles to each strip.
    // an edge of the mesh.
    for( i = 0; i < pNewList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip = pNewList->m_pStrips[i];

        DWORD count = 0;

        for( DWORD j = 0; j < pStrip->m_dwNumTriangles; j++ )
        {
            // Count the number of neighbors.
            for( int vert = 0; vert < 3; vert++ )
            {
                if (m_pTriInfo[pStrip->m_pTriangles[j]].neighbortri[vert] != -1)
                    count++;
            }
        }

        pStrip->m_dwNumNeighbors = count;
    }

    // Should we remove/ignore very small strips?

    // Allow room for one strip length plus a possible 3 extra indices per
    // concatenated strip list plus the final 0
    int dwIndexCount = (pNewList->m_dwNumStrips * 3) + 2;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( i = 0; i < pNewList->m_dwNumStrips; i++ )
    {
        dwIndexCount += pNewList->m_pStrips[i]->m_dwNumIndices;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    DWORD      dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Add the strips.
    while( pNewList->m_dwNumStrips )
    {
        CStrip** ppStrip = FindBestCachedStrip( pNewList, VertexCache );
        CStrip* pStrip = *ppStrip;

        WORD wFirstVertex = pStrip->m_pIndices[0];

        DWORD ivert = 0;

        if (dwNumStripIndices > 0)
        {
            WORD wLastVertex = pStripIndices[dwNumStripIndices - 1];
        
            assert( dwNumStripIndices > 2 );

            if( wLastVertex == pStrip->m_pIndices[1] &&
                pStripIndices[dwNumStripIndices - 2] == wFirstVertex &&
                pStrip->m_bIsStripCW == !(dwNumStripIndices & 0x1) )
            {
                // We are re-stitching strips together, so skip the first two
                // verts of this strip.
                ivert = 2;
            }
            else if( wFirstVertex != wLastVertex )
            {
                // Add degenerate from last strip
                pStripIndices[dwNumStripIndices++] = wLastVertex;

                // Add degenerate from our strip
                pStripIndices[dwNumStripIndices++] = wFirstVertex;
            }
        }

        // If we're not orientated correctly, we need to add a degenerate
        if( pStrip->m_bIsStripCW != !(dwNumStripIndices & 0x1) )
        {
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // Add these verts and update cache.
        while( ivert < pStrip->m_dwNumIndices )
        {
            pStripIndices[dwNumStripIndices] = pStrip->m_pIndices[ivert];
            VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
            dwNumStripIndices++;
            ivert++;
        }

        // Free these guys
        pNewList->RemoveStripFromList( ppStrip );
    }

    delete pNewList;

    (*ppwStripIndices) = pStripIndices;
    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::BuildStrips()
// Desc: Build a (hopefully) optimal set of strips from a trilist
//-----------------------------------------------------------------------------
void CStripper::BuildStrips( CStripList* pStripList, int maxlen, BOOL bLookAhead, 
                             BOOL bNonSequential, BOOL bSwapOrientation )
{
    // temp indices storage
    const int cNumTmpVerts = 1024;
    WORD pStripVerts[cNumTmpVerts + 1];
    int pStripTris[cNumTmpVerts + 1];

    // clear all the used flags for the tris
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );

    BOOL bStartCW = TRUE;

    while( TRUE )
    {
        int   besttri;
        int   bestvert;
        float bestratio = 2.0f;
        int   bestneighborcount = INT_MAX;

        for( int tri = 0; tri < m_dwNumTris; tri++)
        {
            // if used the continue
            if(m_pUsed[tri])
                continue;

            // get the neighbor count
            int curneighborcount = GetNeighborCount(tri);

            // push all the singletons to the very end
            if( !curneighborcount )
                curneighborcount = 4;

            // if this guy has more neighbors than the current best - bail
            if( curneighborcount > bestneighborcount )
                continue;

            // try starting the strip with each of this tris verts
            for( int vert = 0; vert < 3; vert++ )
            {
                int swaps;
                int num_tris = CreateStrip( tri, vert, maxlen, &swaps, bLookAhead, 
                                            bNonSequential, bStartCW, pStripTris );

                int len = 2 + num_tris + swaps;
                float ratio = (len == 3) ? 1.0f : (float)swaps / len;

                // check if this ratio is better than what we've already got for
                // this neighborcount
                if( (curneighborcount < bestneighborcount) ||
                    (curneighborcount == bestneighborcount && ratio < bestratio) )
                {
                    bestneighborcount = curneighborcount;
                    besttri = tri;
                    bestvert = vert;
                    bestratio = ratio;
                }

            }
        }

        // no strips found?
        if( bestneighborcount == INT_MAX )
            break;

        // recreate this strip
        int swaps;
        int num_tris = CreateStrip( besttri, bestvert, maxlen, &swaps, bLookAhead, 
                                    bNonSequential, bStartCW, pStripTris );

        // Mark the tris on the best strip as used
        for( tri = 0; tri < num_tris; tri++ )
            m_pUsed[pStripTris[tri]] = 1;

        // Make the indices from the triangle verts.
        int num_indices = CreateIndices( bStartCW, num_tris, pStripTris, pStripVerts );

        // Create a new CStrip and stuff in the list.
        CStrip* pStrip = new CStrip( num_tris, num_indices );

        pStrip->m_bIsStripCW = bStartCW;

        for( int j = 0; j < num_tris; j++ )
            pStrip->m_pTriangles[j] = pStripTris[j];

        for( int k = 0; k < num_indices; k++ )
            pStrip->m_pIndices[k] = pStripVerts[k];

        // Store the CStrip
        pStripList->AddStripToList( pStrip );

        if( bSwapOrientation )
        {
            // if strip was odd - swap orientation
            if( (num_indices & 0x1) )
              bStartCW = !bStartCW;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: CStripper::InitTriangleInfo()
// Desc: Initialize triangle information (edges, #neighbors, etc.)
//-----------------------------------------------------------------------------
void CStripper::InitTriangleInfo(int tri, int vert)
{
    WORD* ptriverts = &m_pTriangles[tri + 1][0];
    int   vert1     =  m_pTriangles[tri][(vert + 1) % 3];
    int   vert2     =  m_pTriangles[tri][vert];

    for( int itri = tri + 1; itri < m_dwNumTris; itri++, ptriverts += 3 )
    {
        if( m_pUsed[itri] != 0x7 )
        {
            for( int ivert = 0; ivert < 3; ivert++ )
            {
                if( ( ptriverts[ivert] == vert1) &&
                    ( ptriverts[(ivert + 1) % 3] == vert2 ) )
                {
                    // add the triangle info
                    m_pTriInfo[tri].neighbortri[vert]  = itri;
                    m_pTriInfo[tri].neighboredge[vert] = ivert;
                    m_pUsed[tri] |= (1 << vert);

                    m_pTriInfo[itri].neighbortri[ivert]  = tri;
                    m_pTriInfo[itri].neighboredge[ivert] = vert;
                    m_pUsed[itri] |= (1 << ivert);
                    return;
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: CStripper()
// Desc: CStripper ctor
//-----------------------------------------------------------------------------
CStripper::CStripper( int dwNumTris, TRIANGLELIST pTriangles )
{
    // store trilist info
    m_dwNumTris  = dwNumTris;
    m_pTriangles = pTriangles;
    m_pUsed      = new int[dwNumTris];
    m_pTriInfo   = new TRIANGLEINFO[dwNumTris];

    // init triinfo
    for( int itri = 0; itri < dwNumTris; itri++ )
    {
        m_pTriInfo[itri].neighbortri[0] = -1;
        m_pTriInfo[itri].neighbortri[1] = -1;
        m_pTriInfo[itri].neighbortri[2] = -1;
    }

    // Clear the used flag
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );

    // Go through all the triangles and find edges, neighbor counts
    for( itri = 0; itri < dwNumTris; itri++ )
    {
        for( int ivert = 0; ivert < 3; ivert++ )
        {
            if( !(m_pUsed[itri] & (1 << ivert)) )
                InitTriangleInfo( itri, ivert );
        }
    }

    // Clear the used flags from InitTriangleInfo
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );
}




//-----------------------------------------------------------------------------
// Name: ~CStripper
// Desc: CStripper dtor
//-----------------------------------------------------------------------------
CStripper::~CStripper()
{
    // free stuff
    delete[] m_pUsed;
    m_pUsed = NULL;

    delete[] m_pTriInfo;
    m_pTriInfo = NULL;
}




//-----------------------------------------------------------------------------
// Name: CVertCache::Add()
// Desc: Add an index to the cache - returns true if it was added, false otherwise
//-----------------------------------------------------------------------------
int CVertCache::Add( int strip, int vertindex )
{
    // Find index in cache
    for( int iCache = 0; iCache < CACHE_SIZE; iCache++ )
    {
        if( vertindex == m_rgCache[iCache] )
        {
            // If it's in the cache and it's from a different strip
            // change the strip to the new one and count the cache hit
            if( strip != m_rgCacheStrip[iCache] )
            {
                m_cachehits++;
                m_rgCacheStrip[iCache] = strip;
                m_bReUsed[iCache] = true;
            }

            // Item is already in the cache, so no need to add it
            return 0;
        }
    }

    int retval = 1;

    // If we are push one of the verts add by our strip out of the cache, return two.
    if ( m_rgCache[m_iCachePtr] != -1 && m_rgCacheStrip[m_iCachePtr] == strip && 
         !m_bReUsed[m_iCachePtr] )
        retval = 2;

    // Not in cache, add vert and strip
    m_rgCache[m_iCachePtr]      = (WORD)vertindex;
    m_rgCacheStrip[m_iCachePtr] = strip;
    m_bReUsed[m_iCachePtr]      = false;
    m_iCachePtr                 = (m_iCachePtr + 1) % CACHE_SIZE;
    
    return retval;
}




//-----------------------------------------------------------------------------
// Name: CountCacheMisses()
// Desc: Count the number of cache misses for a given strip.
//-----------------------------------------------------------------------------
DWORD CountCacheMisses( DWORD dwIndexCount, WORD *pStripIndices )
{
    CVertCache VertexCache;

    DWORD dwMisses = 0;

    for ( DWORD i = 0; i < dwIndexCount; i++ )
        dwMisses += (VertexCache.Add( 1, pStripIndices[i] ) != 0);

    return dwMisses;
}




//-----------------------------------------------------------------------------
// Name: TriStripToTriList()
// Desc: Convert a tri-strip to a tri-list.
//-----------------------------------------------------------------------------
DWORD TriStripToTriList( DWORD dwNumStripIndices, const WORD *pStripIndices, 
                         WORD *pTriangleIndices )
{
    DWORD dwNumTriangleIndices = 0;
        
    // Unstrip the indices.
    WORD ind0 = 0;
    WORD ind1 = pStripIndices[0];
    WORD ind2 = pStripIndices[1];

    for( DWORD src = 2; src < dwNumStripIndices; src++ )
    {
        ind0 = ind1;
        ind1 = ind2;
        ind2 = pStripIndices[src];
    
        // Check for null-triangles.    
        if( ind0 != ind1 && ind1 != ind2 && ind2 != ind0 )
        {
            if( src & 1 )
            {
                pTriangleIndices[dwNumTriangleIndices] = ind1;
                dwNumTriangleIndices++;

                pTriangleIndices[dwNumTriangleIndices] = ind0;
                dwNumTriangleIndices++;

                // always put the new index last
                pTriangleIndices[dwNumTriangleIndices] = ind2;
                dwNumTriangleIndices++;
            }
            else
            {
                pTriangleIndices[dwNumTriangleIndices] = ind0;
                dwNumTriangleIndices++;

                pTriangleIndices[dwNumTriangleIndices] = ind1;
                dwNumTriangleIndices++;

                // always put the new index last
                pTriangleIndices[dwNumTriangleIndices] = ind2;
                dwNumTriangleIndices++;
            }
        }
    }

    return dwNumTriangleIndices;
}




//-----------------------------------------------------------------------------
// Name: Stripify()
// Desc: Stripify routine
//-----------------------------------------------------------------------------
DWORD Stripify( DWORD dwNumTriangles, WORD* pTriangles, 
                DWORD* pdwNumIndices, WORD** ppStripIndices, DWORD dwFlags )
{
    if( 0 == dwNumTriangles || NULL == pTriangles )
        return 0;

    *ppStripIndices = 0;

    // The stipper, and storage for it's best results
    CStripper   stripper( dwNumTriangles, (TRIANGLELIST)pTriangles );

    DWORD       dwBestCost = 0xffffffff;
    DWORD       dwBestIndexCount;
    WORD*       pTempStripIndices;

    // Map of various args to try stripifying mesh with
    struct ARGMAP
    {
        DWORD   dwMaxLength;    // Maximum length of strips
        BOOL    bLookAhead;     // Whether to use sgi greedy lookahead
        BOOL    bNonSequential; // Take non-sequential exits to lengthen strips.
    };
    
    ARGMAP argmap[] =
    {
        { 1024,  TRUE, TRUE  },
        { 1024,  FALSE, TRUE },
        { 1024,  FALSE, FALSE },
    };
    const int dwNumArgMaps = sizeof(argmap)/sizeof(ARGMAP);

    // Build strips with the various maxlength and lookahead arguments, and
    // pick the one with the least result index count.
    for( int map = 0; map < dwNumArgMaps; map++ )
    {
        // Build the strip with the various maxlength and lookahead arguments
        CStripList* pStripList = new CStripList(dwNumTriangles);

        stripper.BuildStrips( pStripList, argmap[map].dwMaxLength, 
                              argmap[map].bLookAhead, argmap[map].bNonSequential,
                              (dwFlags & OPTIMIZE_FOR_INDICES) != 0 );

        DWORD dwIndexCount;
        DWORD dwCost;

        // Build strip (freeing the strip list).
        if( dwFlags & OPTIMIZE_FOR_INDICES )
        {
            dwIndexCount = stripper.CreateLongStrip( pStripList, &pTempStripIndices );

            // Cost is just the number of indices.
            dwCost = dwIndexCount;
        }
        else
        {
            dwIndexCount = stripper.CreateCachedStrip( pStripList, &pTempStripIndices );

            // Count number of cache misses.
            DWORD dwMisses = CountCacheMisses( dwIndexCount, pTempStripIndices );

            if( dwFlags & OUTPUT_TRILIST )
            {
                // Nulls don't matter for tri-lists.
                dwCost = dwMisses;
            }
            else
            {
                // Cost is the (shader length) / 2 + (# null tris) * 2
                dwCost = dwMisses * (SHADER_CYCLES/2) + 
                         (dwIndexCount - (dwNumTriangles + 2)) * 2;
            }
        }

        if ( dwCost < dwBestCost )
        {
            // Free the old best list
            if( *ppStripIndices )
                delete[] *ppStripIndices;

            // store the new best list
            *ppStripIndices  = pTempStripIndices;
            dwBestCost       = dwCost;
            dwBestIndexCount = dwIndexCount;
        }
        else
        {
            delete[] pTempStripIndices;
        }

        delete pStripList;
    }

    if( dwFlags & OUTPUT_TRILIST )
    {
        // Convert to triangle list.
        WORD* pTempIndices = new WORD[dwNumTriangles*3];

        dwBestIndexCount = TriStripToTriList( dwBestIndexCount, *ppStripIndices, 
                                              pTempIndices );

        assert( dwBestIndexCount <= dwNumTriangles*3 );

        delete[] *ppStripIndices;
        *ppStripIndices = pTempIndices;
    }

    if( pdwNumIndices )
        (*pdwNumIndices) = dwBestIndexCount;
    
    return dwBestIndexCount;
}




//-----------------------------------------------------------------------------
// Name: ComputeVertexPermutation()
// Desc: Reorder the vertices
//-----------------------------------------------------------------------------
VOID ComputeVertexPermutation( DWORD dwNumStripIndices, WORD* pStripIndices,
                               DWORD dwNumVertices, WORD** ppVertexPermutation )
{
    // Sort verts to maximize locality.
    SortEntry* pSortTable = new SortEntry[dwNumVertices];

    // Fill in original index.
    for( DWORD i = 0; i < dwNumVertices; i++ )
    {
        pSortTable[i].iOrigIndex = i;
        pSortTable[i].iFirstUsed = -1;
    }

    // Fill in first used flag.
    for( i = 0; i < dwNumStripIndices; i++ )
    {
        int index = pStripIndices[i];

        if( pSortTable[index].iFirstUsed == -1 )
            pSortTable[index].iFirstUsed = i;
    }

    // Sort the table, using the STL sort() routine.
    std::sort( pSortTable, pSortTable + dwNumVertices );

    // Copy re-mapped to orignal vertex permutaion into output array.
    (*ppVertexPermutation) = new WORD[dwNumVertices];

    for( i = 0; i < dwNumVertices; i++ )
    {
        (*ppVertexPermutation)[i] = (WORD)pSortTable[i].iOrigIndex;
    }

    // Build original to re-mapped permutation.
    WORD* pInversePermutation = new WORD[dwNumVertices];

    for( i = 0; i < dwNumVertices; i++ )
    {
        pInversePermutation[pSortTable[i].iOrigIndex] = (WORD)i;
    }

    // We need to remap indices as well.
    for( i = 0; i < dwNumStripIndices; i++ )
    {
        pStripIndices[i] = pInversePermutation[ pStripIndices[i] ];
    }

    delete[] pSortTable;
    delete[] pInversePermutation;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\XBG.h ===
//-----------------------------------------------------------------------------
// File: XBG.h
//
// Desc: Structs for converting a DirectX geometry file (.x) into a geometry
//       file (.xbg) that can be more conveniently used by Xbox apps. An XBG
//       file stores the pre-parsed information needed to load and render
//       geometry. For comparison, parsing in .x files at load times requires
//       a large amount of code (internal to D3DX) and processing time.
//
//       After conversion from a .x file, geometry is typically a hierarchy of
//       frames, each potentially with a transformation matrix and meshdata.
//       Furthermore, each mesh has one or more subsets. A subset has the
//       material, texture, and range of primitives to use for rendering.
//
//       The .xbg file format is designed to load in two easy chunks: one
//       file read for the system memory objects (frames and indices) and one
//       file read for the video memory objects (vertices). Note that the
//       file format is forced (via the __declspec(align(16)) declarator) to
//       align structures such that D3XMATRIX structures are on 16-byte
//       boundaries. This is to be compatible with the Xbox fast math
//       functions (see xgmath.h).
//
//       The common framework used by XDK samples contain functions to load
//       XBG files. See the Common\include\XBMesh.h and Common\src\XBMesh.cpp
//       files for more information. All graphics samples on the XDK use
//       this common code to load .xbg files.
//
//       The file format of a .xbg looks like:
//
//       // Header info
//       struct XBG_HEADER
//       {
//          DWORD dwMagic;             // A file-type identifier
//          DWORD dwNumMeshFrames;     // Num of frames in the file
//          DWORD dwSysMemSize;        // Num system memory bytes req'd
//          DWORD dwVidMemSize;        // Num videro memorty bytes req'd
//       };
//
//       // Array of frames (XBMESH_FRAME x dwNumMeshFrames)
//       struct XBMESH_FRAME
//       {
//          D3DXMATRIX    m_matTransform; // Transformation matrix
//          XBMESH_DATA   m_MeshData;     // Mesh data
//          CHAR          m_strName[64];  // Name of this frame
//          XBMESH_FRAME* m_pChild;       // File offset to child frame
//          XBMESH_FRAME* m_pNext;        // File offset to siblingframe
//
//          // Where the mesh data is:
//          struct XBMESH_DATA
//          {
//             D3DVertexBuffer  m_VB;            // Xbox vertex buffer
//             DWORD            m_dwNumVertices; // Vertex count
//             D3DIndexBuffer   m_IB;            // Xbox index buffer
//             DWORD            m_dwNumIndices;  // Index count
//             DWORD            m_dwFVF;         // Vertex FVF
//             DWORD            m_dwVertexSize;  // Vertex size
//             D3DPRIMITIVETYPE m_dwPrimType;    // Primitive type
//             DWORD            m_dwNumSubsets;  // Num rendering subsets
//             XBMESH_SUBSET*   m_pSubsets;      // File offset to first subset
//           };
//       };
//
//       // Array of rendering subsets (all subsets for all frame's meshdata)
//       struct XBMESH_SUBSET
//       {
//          D3DMATERIAL8       mtrl;           // Material to render with
//          LPDIRECT3DTEXTURE8 pTexture;       // Texture to render with
//          CHAR               strTexture[64]; // Name of texture
//          DWORD              dwVertexStart;  // First vertex for this subset
//          DWORD              dwVertexCount;  // Num vertices for this subset
//          DWORD              dwIndexStart;   // First index for this subset
//          DWORD              dwIndexCount;   // Num indices for this subset
//       };
//
//       // The array of indices for all meshes in the file
//       WORD   indices[];             // Dump of index buffers contents

//       // Finally, the array of vertices for all meshes in the file
//       VERTEX vertices[];            // Dump of vertex buffers contents
//
// NOTE: THIS CODE, AND THE FILE FORMAT IT CREATES, IS SUBJECT TO CHANGE. FEEL
//       FREE, AS WELL, TO EXPAND OR MODIFY THE FILE FORMAT TO FIT YOUR 
//       PERSONAL REQUIREMENTS.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <d3dx8.h>




// Rendering flags
#define D3DFILE_RENDEROPAQUESUBSETS    0x00000001
#define D3DFILE_RENDERALPHASUBSETS     0x00000002
#define D3DFILE_RENDERALLSUBSETS       (D3DFILE_RENDEROPAQUESUBSETS|D3DFILE_RENDERALPHASUBSETS)
#define D3DFILE_RENDERVISIBLEFRAMES    0x00000004
#define D3DFILE_RENDERALLFRAMES        0x00000008

// File writing flags
#define D3DFILE_WRITEMESHINFO    0x00000001
#define D3DFILE_WRITESUBSETS     0x00000002
#define D3DFILE_WRITEINDICES     0x00000004
#define D3DFILE_WRITEVERTICES    0x00000008

// The magic number to identify .xbg files
#define XBG_FILE_ID (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'G'<<16))|(2<<24))




//-----------------------------------------------------------------------------
// Mimicking resource structures as the Xbox will see them
//-----------------------------------------------------------------------------
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000

typedef struct D3DResource
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
} D3DVertexBuffer, D3DIndexBuffer;




//-----------------------------------------------------------------------------
// Name: struct XBG_HEADER
// Desc: Header for a .xbg file
//-----------------------------------------------------------------------------
struct XBG_HEADER
{
    DWORD dwMagic;
    DWORD dwNumMeshFrames;
    DWORD dwSysMemSize;
    DWORD dwVidMemSize;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    D3DMATERIAL8       mtrl;
    LPDIRECT3DTEXTURE8 pTexture;
    CHAR               strTexture[64];
    DWORD              dwVertexStart;
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_DATA
// Desc: Struct to hold data for a mesh
//-----------------------------------------------------------------------------
struct XBMESH_DATA
{
    D3DVertexBuffer    m_VB;           // Mesh geometry
    DWORD              m_dwNumVertices;
    D3DIndexBuffer     m_IB;
    DWORD              m_dwNumIndices;
    
    DWORD              m_dwFVF;         // Mesh vertex info
    DWORD              m_dwVertexSize;
    D3DPRIMITIVETYPE   m_dwPrimType;

    DWORD              m_dwNumSubsets;  // Subset info, for rendering
    XBMESH_SUBSET*     m_pSubsets;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_FRAME
// Desc: Struct to provide a hierarchial layout of meshes. Note: in order for
//       Xbox fast math (via xgmath.h) to work, all D3DXMATRIX's must be
//       16-byte aligned.
//-----------------------------------------------------------------------------
__declspec(align(16)) struct XBMESH_FRAME
{
    D3DXMATRIX         m_matTransform;  // Make sure this is 16-byte aligned!
    
    XBMESH_DATA        m_MeshData;
    
    CHAR               m_strName[64];
    
    XBMESH_FRAME*      m_pChild;
    XBMESH_FRAME*      m_pNext;
};




//-----------------------------------------------------------------------------
// Name: class CD3DFrame
// Desc: Class for providing a hierarchial layout of meshes.
//-----------------------------------------------------------------------------
class CD3DFrame
{
public:
    TCHAR      m_strFrameName[512];
    DWORD      m_dwEnumeratedID;   // Frame ID
    D3DXMATRIX m_matTransform;

    BOOL       m_bVisible;         // Allows visualization of a selected frame
    LONG       m_lSelectedSubset;  // Allows visualization of a selected mesh subset
    HTREEITEM  m_hFVFTreeItem;     // Tree ctrl item for updating the FVF text
    HTREEITEM  m_TreeData;         // Tree ctrl data

    CD3DFrame* m_pParent;          // Ptrs for the hierarchy
    CD3DFrame* m_pNext;
    CD3DFrame* m_pChild;

public:
    // Mesh properties
    D3DXVECTOR3             m_vMeshCenter;
    FLOAT                   m_fMeshRadius;

    // Mesh properties
    LPDIRECT3DVERTEXBUFFER8 m_pMeshVB;
    LPDIRECT3DINDEXBUFFER8  m_pMeshIB;
    DWORD                   m_dwNumMeshVertices;
    DWORD                   m_dwNumMeshIndices;
    DWORD                   m_dwNumMeshPolygons;
    DWORD                   m_dwMeshFVF;
    DWORD                   m_dwMeshVertexSize;
    D3DPRIMITIVETYPE        m_dwMeshPrimType;
    DWORD                   m_dwNumMeshSubsets;    // Subset info, for rendering
    XBMESH_SUBSET*          m_pMeshSubsets;

public:
    // Modification options
    HRESULT ComputeNormals();
    HRESULT SetMeshFVF( DWORD dwFVF );
    HRESULT Stripify( DWORD dwFlags );
	HRESULT Unstrip();

    // Functions to call a callback for every frame in the hierarchy
    BOOL    EnumFrames( BOOL (*EnumMeshCB)(CD3DFrame*,VOID*), VOID* pData );
    BOOL    EnumFrames( BOOL (*EnumMeshCB)(CD3DFrame*,D3DXMATRIX*,VOID*), VOID* pData );

    // Functions to render the frame hierarchy
    HRESULT RenderMeshSubsets( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFirstSubset, 
                               DWORD dwLastSubset, DWORD dwFlags );
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags );

    // Creation/destruction
    HRESULT CreateMesh( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename );
    HRESULT CreateMesh( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData );
    HRESULT Destroy();

    // Construction
    CD3DFrame( LPDIRECT3DDEVICE8 pd3dDevice, CD3DFrame* pParent, XBMESH_FRAME* pXBFrame );
    CD3DFrame( TCHAR* strName = _T("") );
    virtual ~CD3DFrame();
};




//-----------------------------------------------------------------------------
// Name: class CD3DFile
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CD3DFile : public CD3DFrame
{
public:
    // Global geoemtry attribtes
    DWORD       m_dwNumFrames;
    DWORD       m_dwNumMeshes;
    DWORD       m_dwNumVertices;
    DWORD       m_dwNumIndices;
    DWORD       m_dwNumPolygons;
    D3DXVECTOR3 m_vCenter;
    FLOAT       m_fRadius;

    // Functions for loading from a .x file
    HRESULT LoadFrame( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData, 
                       CD3DFrame* pParentFrame );

public:
    // Functions to read and write geometry files
    HRESULT LoadCollapsedMeshFromX( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename );
    HRESULT LoadFromX( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename );
    HRESULT LoadFromXBG( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename );
    HRESULT WriteToXBG( TCHAR* strFilename );

    // Create method
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strFilename, 
                    BOOL bCollapseMesh = FALSE );

    CD3DFile();
};




//-----------------------------------------------------------------------------
// Name: D3DFile_CreateTexture()
// Desc: Helper function to load a texture file
//-----------------------------------------------------------------------------
HRESULT D3DFile_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, TCHAR* strTexture,
                               LPDIRECT3DTEXTURE8* ppTexture );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_




// pack the structure as we're reading it from the disk
#pragma pack( 1 )

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning( push )
#pragma warning( disable:4200 )




//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'




//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};




//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};




#pragma warning( pop )
#pragma pack( )




//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;




//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load( const char* filename );

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength( DWORD *pdwWidth, DWORD *pdwHeight, 
                              const char* Message );

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText( IDirect3DSurface8 *pSurface, const char* str, int iX,
                            int iY, DWORD dwFlags, D3DCOLOR colFore, 
                            D3DCOLOR colBack );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\inifile.h ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.H
//
// Desc: Quick and dirty INI file routines
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// Routines supplied by the main application to return the values for a given
// string found in an ini file.
bool GetIniConst( const char *szStr, int cchStr, int *pval );
bool GetIniConstf( const char *szStr, int cchStr, float *pval );




//-----------------------------------------------------------------------------
// IniFile class
//-----------------------------------------------------------------------------
class CIniFile
{
public:
    CIniFile( LPCSTR szFileName ) : m_szFile( NULL ), 
                                    m_fverbose( false ), 
                                    m_recurselevel( 0 )
    { 
        lstrcpyA( m_szFileName, szFileName ); 
        m_ftFileReadTime.dwLowDateTime =
        m_ftFileReadTime.dwHighDateTime = 0;
    }

    ~CIniFile()
    {
        if( m_szFile )
        {
            free( m_szFile );
            m_szFile = NULL;
        }
    };

    // get int entry
    int GetIniInt( LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault );

    // get float entry
    float GetIniFloat( LPCSTR lpSectionName, LPCSTR lpKeyName, float nDefault );

    // check for entry existance
    bool IniEntryExists( LPCSTR lpSectionName, LPCSTR lpKeyName );

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    bool GetIniStrBuf( LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, char *buf, int buflen );

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    LPCSTR GetIniStr( LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, LPCSTR *ppszLineStart );

    // read/refresh an ini file
    bool ReadFile();

    // get name of ini file
    LPCSTR GetFileName()
    { 
        return m_szFileName; 
    }

    // has ini file timestamp changed?
    bool FileChanged()
    { 
        HANDLE hFile = CreateFile( m_szFileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

        if( hFile != INVALID_HANDLE_VALUE )
        {
            FILETIME chkFileTime;
            if (GetFileTime(hFile,NULL,NULL,&chkFileTime))
            {
                CloseHandle(hFile);
                return (chkFileTime.dwLowDateTime != m_ftFileReadTime.dwLowDateTime) ||
                        (chkFileTime.dwHighDateTime != m_ftFileReadTime.dwHighDateTime); 
            }
            else    //No file.  Therefore, it didn't change!
            {
                CloseHandle(hFile);
                return false;
            }
        }
        else
            return false;
    }

    bool m_fverbose;

private:
    enum 
    { 
        INIVAL_INT, 
        INIVAL_FLOAT 
    };

    struct INIVAL
    {
        int type;

        int val;
        float valf;

        void SetVal( int newval )
        { 
            val = newval; 
            valf = (float)newval; 
        }

        void SetVal( float newval )
        { 
            val = (int)newval; 
            valf = newval; 
        }
    };

    LPCSTR GetIniConstValue( const char *szStr, INIVAL *pinival );

    bool ParseIntVal( LPCSTR szLineStart, LPCSTR szLine, int *pval );
    bool ParseFloatVal( LPCSTR szLineStart, LPCSTR szLine, float *pval );

    char m_szFileName[MAX_PATH];
    char *m_szFile;
    FILETIME m_ftFileReadTime;

    UINT m_recurselevel;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\makefile.inc ===
!include "..\..\samples\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\MakeXBG\StripifyDlg.h ===
//-----------------------------------------------------------------------------
// File: StripifyDlg.h
//
// Desc: Code to implement a dialog to let the user stripify a mesh.
//
// Hist: 03.01.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// Name: class StripifyDlg
// Desc: A dialog to let the user stripify a mesh
//-----------------------------------------------------------------------------
class StripifyDlg : public CDialog
{
    DECLARE_DYNAMIC(StripifyDlg)
// Construction
public:
    StripifyDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
    //{{AFX_DATA(StripifyDlg)
    enum { IDD = IDD_STRIPIFY };
    CD3DFrame* m_pFrame;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(StripifyDlg)
    afx_msg void OnStrip();
	afx_msg void OnOptForIndices();
	afx_msg void OnOptForCache();
	afx_msg void OnOutputTriList();
	afx_msg void OnOutputTriStrip();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	DWORD m_dwOptimizeFlag;
	DWORD m_dwOutputFlag;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VideoTest\Resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_TestPattern_OFFSET 0UL
#define resource_Speaker_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "bitfont.h"




//----------------------------------------------------------------------------
DWORD BitsPerPixelOfD3DFORMAT( DWORD Format );
DWORD dwColorFromD3DXColor( D3DFORMAT dwSurfaceFormat, D3DCOLOR color );




//----------------------------------------------------------------------------
// default font
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000f, 0x00000060, 0x00000008,
    0x000f0800, 0x1e080000, 0x08000000, 0x0000002d,
    0x00003c08, 0x004b0800, 0x5a080000, 0x08000000,
    0x00000069, 0x00007808, 0x00870800, 0x96080000,
    0x08000000, 0x000000a5, 0x0000b408, 0x00c30800,
    0xd2080000, 0x08000000, 0x000000e1, 0x0000f008,
    0x00ff0800, 0x0e080000, 0x08000001, 0x0000011d,
    0x00012c08, 0x013b0800, 0x4a080000, 0x08000001,
    0x00000159, 0x00016808, 0x01770800, 0x86080000,
    0x08000001, 0x00000195, 0x0001a408, 0x01b30800,
    0xc2080000, 0x08000001, 0x000001d1, 0x0001e008,
    0x01ef0800, 0xfe080000, 0x08000001, 0x0000020d,
    0x00021c08, 0x022b0800, 0x3a080000, 0x08000002,
    0x00000249, 0x00025808, 0x02670800, 0x76080000,
    0x08000002, 0x00000285, 0x00029408, 0x02a30800,
    0xb2080000, 0x08000002, 0x000002c1, 0x0002d008,
    0x02df0800, 0xee080000, 0x08000002, 0x000002fd,
    0x00030c08, 0x031b0800, 0x2a080000, 0x08000003,
    0x00000339, 0x00034808, 0x03570800, 0x66080000,
    0x08000003, 0x00000375, 0x00038408, 0x03930800,
    0xa2080000, 0x08000003, 0x000003b1, 0x0003c008,
    0x03cf0800, 0xde080000, 0x08000003, 0x000003ed,
    0x0003fc08, 0x040b0800, 0x1a080000, 0x08000004,
    0x00000429, 0x00043808, 0x04470800, 0x56080000,
    0x08000004, 0x00000465, 0x00047408, 0x04830800,
    0x92080000, 0x08000004, 0x000004a1, 0x0004b008,
    0x04bf0800, 0xce080000, 0x08000004, 0x000004dd,
    0x0004ec08, 0x04fb0800, 0x0a080000, 0x08000005,
    0x00000519, 0x00052808, 0x05370800, 0x46080000,
    0x08000005, 0x00000555, 0x00056408, 0x05730800,
    0x82080000, 0x08000005, 0x00000591, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc3e7ffff,
    0xe7e7c3c3, 0xffe7e7ff, 0xffffffff, 0x999999ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc980c9c9,
    0xc980c9c9, 0xffffffc9, 0xc3e7e7ff, 0xe7cf9f99,
    0xc399f9f3, 0xffffe7e7, 0x25278fff, 0xcfe7f389,
    0xf1e4a491, 0xffffffff, 0x9393c7ff, 0x99909fc7,
    0xffffc499, 0xffffffff, 0xffe7e7e7, 0xffffffff,
    0xffffffff, 0xf3ffffff, 0xcfcfe7e7, 0xe7cfcfcf,
    0xfffff3e7, 0xe7cfffff, 0xf3f3f3e7, 0xe7e7f3f3,
    0xffffffcf, 0xc9ffffff, 0xc9e380e3, 0xffffffff,
    0xffffffff, 0xe7e7ffff, 0xffe7e781, 0xffffffff,
    0xffffffff, 0xffffffff, 0xe3e3ffff, 0xffffe7f3,
    0xffffffff, 0xff81ffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffe3e3, 0xffffffff,
    0xf3f3f9f9, 0xcfcfe7e7, 0xffff9f9f, 0xe1ffffff,
    0xccc8c8cc, 0xe1ccc4c4, 0xffffffff, 0xe3f3ffff,
    0xf3f3f383, 0xfff3f3f3, 0xffffffff, 0x9999c3ff,
    0xcfe7f3f9, 0xffff819f, 0xffffffff, 0xf99999c3,
    0x9999f9e3, 0xffffffc3, 0xcfffffff, 0xc9c9c9cf,
    0xf9f98099, 0xffffffff, 0x9f81ffff, 0xf9839f9f,
    0xff87f3f9, 0xffffffff, 0xcfe7e3ff, 0x99999983,
    0xffffc399, 0xffffffff, 0xf3f3f981, 0xcfcfe7e7,
    0xffffffcf, 0xc3ffffff, 0xc3899999, 0xc3999991,
    0xffffffff, 0x99c3ffff, 0xc1999999, 0xffc7e7f3,
    0xffffffff, 0xe3ffffff, 0xffffffe3, 0xffffe3e3,
    0xffffffff, 0xe3e3ffff, 0xe3ffffff, 0xffe7f3e3,
    0xf9ffffff, 0x9fcfe7f3, 0xf9f3e7cf, 0xffffffff,
    0xffffffff, 0x81ff81ff, 0xffffffff, 0xffffffff,
    0xe7cf9fff, 0xe7f3f9f3, 0xffff9fcf, 0xffffffff,
    0xf39999c3, 0xe7ffe7e7, 0xffffffe7, 0x81ffffff,
    0x24303c3c, 0x803f3024, 0xffffffff, 0xc3e7ffff,
    0x81999999, 0xff999999, 0xffffffff, 0x999983ff,
    0x99998399, 0xffff8399, 0xffffffff, 0x9f9999c3,
    0x99999f9f, 0xffffffc3, 0x87ffffff, 0x99999993,
    0x87939999, 0xffffffff, 0x9f81ffff, 0x9f839f9f,
    0xff819f9f, 0xffffffff, 0x9f9f81ff, 0x9f9f839f,
    0xffff9f9f, 0xffffffff, 0x9f9999c3, 0x9999919f,
    0xffffffc1, 0x99ffffff, 0x81999999, 0x99999999,
    0xffffffff, 0xe7c3ffff, 0xe7e7e7e7, 0xffc3e7e7,
    0xffffffff, 0xf9f9f9ff, 0x99f9f9f9, 0xffffc399,
    0xffffffff, 0x93939999, 0x99939387, 0xffffff99,
    0x9fffffff, 0x9f9f9f9f, 0x819f9f9f, 0xffffffff,
    0x9c9cffff, 0x94949488, 0xff9c9c9c, 0xffffffff,
    0x8c9c9cff, 0x9c989084, 0xffff9c9c, 0xffffffff,
    0x999999c3, 0x99999999, 0xffffffc3, 0x83ffffff,
    0x83999999, 0x9f9f9f9f, 0xffffffff, 0x99c3ffff,
    0x99999999, 0xf3c39999, 0xfffffff9, 0x999983ff,
    0x99938399, 0xffff9999, 0xffffffff, 0xcf9f99c3,
    0x99f9f3e7, 0xffffffc3, 0x81ffffff, 0xe7e7e7e7,
    0xe7e7e7e7, 0xffffffff, 0x9999ffff, 0x99999999,
    0xffc39999, 0xffffffff, 0x999999ff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949c9c9c, 0xc9c99494,
    0xffffffc9, 0x99ffffff, 0xe7e7cb99, 0x999999d3,
    0xffffffff, 0x9999ffff, 0xe7c39999, 0xffe7e7e7,
    0xffffffff, 0xf9f981ff, 0x9fcfe7f3, 0xffff819f,
    0xffffffff, 0xcfcfcfc3, 0xcfcfcfcf, 0xc3cfcfcf,
    0x9fffffff, 0xe7cfcf9f, 0xf9f3f3e7, 0xfffffff9,
    0xf3c3ffff, 0xf3f3f3f3, 0xf3f3f3f3, 0xe7ffc3f3,
    0xffff99c3, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0x00ffffff, 0xf3e7c7ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xc1f9f9c3, 0xffc19999, 0xffffffff, 0x839f9fff,
    0x99999999, 0xffff8399, 0xffffffff, 0x99c3ffff,
    0x999f9f9f, 0xffffffc3, 0xf9ffffff, 0x9999c1f9,
    0xc1999999, 0xffffffff, 0xffffffff, 0x819999c3,
    0xffc39f9f, 0xffffffff, 0xcfcfe1ff, 0xcfcf81cf,
    0xffffcfcf, 0xffffffff, 0x99c1ffff, 0x99999999,
    0x83f9f9c1, 0x9fffffff, 0x9999839f, 0x99999999,
    0xffffffff, 0xffe7e7ff, 0xe7e7e787, 0xff81e7e7,
    0xffffffff, 0xc3fff3f3, 0xf3f3f3f3, 0xf3f3f3f3,
    0xffffff87, 0x99999f9f, 0x99938793, 0xffffff99,
    0x87ffffff, 0xe7e7e7e7, 0x81e7e7e7, 0xffffffff,
    0xffffffff, 0x94949481, 0xff9c9494, 0xffffffff,
    0x83ffffff, 0x99999999, 0xffff9999, 0xffffffff,
    0x99c3ffff, 0x99999999, 0xffffffc3, 0xffffffff,
    0x999983ff, 0x83999999, 0xff9f9f9f, 0xffffffff,
    0x999999c1, 0xf9c19999, 0xfffff9f9, 0x99ffffff,
    0x9f9f8f91, 0xffff9f9f, 0xffffffff, 0x9fc1ffff,
    0xf9f9c39f, 0xffffff83, 0xcfffffff, 0xcfcf81cf,
    0xe1cfcfcf, 0xffffffff, 0xffffffff, 0x99999999,
    0xffc19999, 0xffffffff, 0x99ffffff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949cffff, 0xc9949494,
    0xffffffc9, 0xffffffff, 0xc39999ff, 0x9999c3e7,
    0xffffffff, 0xffffffff, 0x99999999, 0xf3c39999,
    0xffff0fe7, 0x81ffffff, 0xcfe7f3f9, 0xffff819f,
    0xffffffff, 0xe7e7e7f3, 0xe7cf9fcf, 0xfff3e7e7,
    0xe7ffffff, 0xe7e7e7e7, 0xe7e7e7e7, 0xffe7e7e7,
    0xe7cfffff, 0xf9f3e7e7, 0xe7e7e7f3, 0xffffffcf,
    0x71248eff, 0xffffffff, 0xffffffff, 0xffffffff,
    0x81818181, 0x81818181, 0xffffff81
};




//----------------------------------------------------------------------------
// Name: Constructor
//
// Desc: 
//----------------------------------------------------------------------------
BitFont::BitFont( )
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}




//----------------------------------------------------------------------------
// Name: Destructor
//
// Desc: 
//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if( m_pBitFontInfo != (BitFontInfo *)rgSmallFont )
        delete m_pBitFontInfo;
}




//----------------------------------------------------------------------------
// Name: Load
//
// Desc: Intialize a BitFont from a specified filename -- DELETE THIS??
//----------------------------------------------------------------------------
bool BitFont::Load( const char* filename )
{
#ifdef NEVER
    HFILE hf = _lopen( filename, OF_READ );

    if( hf != HFILE_ERROR )
    {
        // get the file size and move back to the start
        LONG lSize = _llseek( hf, 0, FILE_END );
        _llseek( hf, 0, FILE_BEGIN );

        // need at least a BITFONT and one BITFONTINFO
        if(lSize < sizeof( BitFontInfo ) + sizeof( BitFontCharInfo ) )
            goto err;

        // malloc our BITFONT block and read it in
        m_pBitFontInfo = (BitFontInfo *)new BYTE[lSize];
        if( !m_pBitFontInfo )
            goto err;

        if( _lread( hf, m_pBitFontInfo, (UINT)lSize ) != (UINT)lSize )
            goto err;

        // if the sig doesn't match or we don't have any bitfontinfos then bail
        if( m_pBitFontInfo->dwSig != BITFONT_SIG || !m_pBitFontInfo->cBfis )
            goto err;

        _lclose( hf );
        return true;
    }

err:
    if( hf != HFILE_ERROR )
        _lclose( hf );

    delete [] m_pBitFontInfo;
    m_pBitFontInfo = NULL;
#endif
    return false;
}




//----------------------------------------------------------------------------
// Name: GetTextStringLength
// 
// Desc: Returns pixel height and width of string
//----------------------------------------------------------------------------
void BitFont::GetTextStringLength( DWORD *pdwWidth, DWORD *pdwHeight, 
                                   const char *str )
{
    if( pdwHeight )
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if( pdwWidth )
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for( const char *sz = str; *sz; sz++ )
        {
            DWORD iBfi = *sz - 32;

            if( iBfi >= m_pBitFontInfo->cBfis )
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}




//----------------------------------------------------------------------------
// Name: DrawText16
//
// Desc: Renders the font to a 16-bit surface
//----------------------------------------------------------------------------
void DrawText16( D3DSURFACE_DESC* pDesc, D3DLOCKED_RECT* pLock,
                 BitFontInfo* m_pBitFontInfo, const char* str, int iX, int iY,
                 DWORD dwFlags, DWORD dwcolFore,DWORD dwcolBack )
{
    bool fdrawBkgnd = !( dwFlags & DRAWTEXT_TRANSPARENTBKGND );

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD( dwcolBack ), LOWORD( dwcolFore ) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];

    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                    * pDesc->Height );

    // go through the string
    for( const char *sz = str; *sz; sz++ )
    {
        DWORD iBfi = *sz - 32;

        if( iBfi >= m_pBitFontInfo->cBfis )
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)( (BYTE *)pLock->pBits + pLock->Pitch * iY ) 
                                    + iX;

        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                        * iY ) + pDesc->Width;

        // go through bitfont drawing each line
        for( DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++ )
        {
            DWORD dwWidth = pbfi->bWidth;

            while( dwWidth )
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min( dwWidth, 8 );

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while( dwNumBits-- && ( pwSurface < pwSurfaceMaxX ) )
                {
                    DWORD iIndex = !( dwByte & 0x80 );

                    if( fdrawBkgnd || iIndex )
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)( (BYTE *)( pwSurface - pbfi->bWidth - dwWidth ) 
                                  + pLock->Pitch );
            pwSurfaceMaxX = (WORD *)( (BYTE *)pwSurfaceMaxX + pLock->Pitch );

            // check clipping
            if( pwSurface >= pwSurfaceMaxY )
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}




//----------------------------------------------------------------------------
// Name: DrawText32
//
// Desc: Renders the font to a 32-bit surface
//----------------------------------------------------------------------------
void DrawText32( D3DSURFACE_DESC* pDesc, D3DLOCKED_RECT* pLock,
                 BitFontInfo* m_pBitFontInfo, const char* str, int iX, int iY,
                 DWORD dwFlags, DWORD dwcolFore, DWORD dwcolBack)
{
    bool fdrawBkgnd = !( dwFlags & DRAWTEXT_TRANSPARENTBKGND );
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                       * pDesc->Height );

    for( const char *sz = str; *sz; sz++ )
    {
        DWORD iBfi = *sz - 32;

        if( iBfi >= m_pBitFontInfo->cBfis )
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                       * iY ) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)( (BYTE *)pLock->pBits + pLock->Pitch 
                                           * iY ) + pDesc->Width;

        for( DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++ )
        {
            DWORD dwWidth = pbfi->bWidth;

            while( dwWidth )
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min( dwWidth, 8 );

                dwWidth -= dwNumBits;

                while( dwNumBits-- && ( pdwSurface < pdwSurfaceMaxX ) )
                {
                    DWORD iIndex = !( dwByte & 0x80 );

                    if( fdrawBkgnd || iIndex )
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)( (BYTE *)(pdwSurface - pbfi->bWidth - dwWidth )
                                     + pLock->Pitch );
            pdwSurfaceMaxX = (DWORD *)( (BYTE *)pdwSurfaceMaxX + pLock->Pitch );
            if( pdwSurface >= pdwSurfaceMaxY )
                break;
        }

        iX += pbfi->bWidth;
    }
}




//----------------------------------------------------------------------------
// Name: DrawText
// 
// Desc: Draw the specified text to a surface
//----------------------------------------------------------------------------
void BitFont::DrawText( IDirect3DSurface8 *pSurface, const char* str, int iX,
                        int iY, DWORD dwFlags, D3DCOLOR colFore, 
                        D3DCOLOR colBack )
{
    typedef void ( *PFNDRAWTEXT )( D3DSURFACE_DESC* pDesc, D3DLOCKED_RECT* pLock,
                                   BitFontInfo* m_pBitFontInfo, const char* str,
                                   int iX, int iY, DWORD dwFlags, DWORD dwcolFore,
                                   DWORD dwcolBack);

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if( pSurface->LockRect( &lockRect, NULL, D3DLOCK_TILED ) != S_OK )
    {
        _asm int 3;
        return;
    }

    D3DSURFACE_DESC desc;
    if( FAILED( pSurface->GetDesc( &desc ) ) )
    {
        _asm int 3;
        return;
    }

    UINT BitsPerPixel = BitsPerPixelOfD3DFORMAT( desc.Format );

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32]( &desc, &lockRect,m_pBitFontInfo, str, iX,
                                       iY, dwFlags, 
                                       dwColorFromD3DXColor( desc.Format, colFore ),
                                       dwColorFromD3DXColor( desc.Format, colBack ) );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}




//----------------------------------------------------------------------------
// Name: dwColorFromD3DXColor
//
// Desc: Given a surfaceformat and color, return the color as a native pixel
DWORD dwColorFromD3DXColor( D3DFORMAT dwSurfaceFormat, D3DCOLOR color )
{
    DWORD dwColor;
    D3DXCOLOR col( color );

    switch( dwSurfaceFormat )
    {
        // 32-bit
        case D3DFMT_A8R8G8B8:
        case D3DFMT_LIN_A8R8G8B8:
            dwColor = ( ( (long)( col.a * 255 ) ) << 24 ) |
                      ( ( (long)( col.r * 255 ) ) << 16 ) |
                      ( ( (long)( col.g * 255) ) << 8 ) |
                      (long)( col.b * 255 );
        break;

        // 32-bit
        case D3DFMT_X8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
            dwColor = 0xff000000L |
                      ( ( (long)( col.r * 255 ) ) << 16 ) |
                      ( ( (long)( col.g * 255 ) ) << 8 ) |
                      (long)( col.b * 255 );
        break;

        // 16-bit
        case D3DFMT_R5G6B5:
        case D3DFMT_LIN_R5G6B5:
            dwColor = ( ( (long)( col.r * 255 ) ) << 11 ) |
                      ( ( (long)( col.g * 255 ) ) << 5 ) |
                      (long)( col.b * 255 );
        break;

        case D3DFMT_X1R5G5B5:
        case D3DFMT_LIN_X1R5G5B5:
            dwColor = ( 1 << 15 ) |
                      ( ( (long)( col.r * 255 ) ) << 10 ) |
                      ( ( (long)( col.g * 255) ) << 5 ) |
                      (long)( col.b * 255 );
        break;

        case D3DFMT_A4R4G4B4:
        case D3DFMT_LIN_R4G4B4A4:
            dwColor = ( ( (long)( col.a * 15 ) ) << 12 ) |
                      ( ( (long)( col.r * 15 ) ) << 8 ) |
                      ( ( (long)( col.g * 15 ) ) << 4 ) |
                      (long)( col.b * 15 );
        break;

        case D3DFMT_A1R5G5B5:
        case D3DFMT_LIN_A1R5G5B5:
            dwColor = ( ( (long)( col.a > .9f ) ) << 15 ) |
                      ( ( (long)( col.r * 31 ) ) << 10 ) |
                      ( ( (long)( col.g * 31 ) ) << 5 ) |
                      (long)( col.b * 31 );
        break;

        default:
            dwColor = 0;
            _asm int 3;
        break;
    }

    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VideoTest\VideoTest.cpp ===
//-----------------------------------------------------------------------------
// File: VideoTest.cpp
//
// Desc: This sample is a standalone program used to do basic calibration on a
//       TV. It supplies a set of on-screen instructions to ensure that the
//       TV is set to optimimum output settings.
//
// Hist: 04.14.00 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <DSound.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBSound.h>
#include "Resource.h"




//-----------------------------------------------------------------------------
// Structures and Macros
//-----------------------------------------------------------------------------
struct SCREENVERTEX
{
    D3DXVECTOR4 pos;   // The transformed position for the vertex point.
    DWORD       color; // The vertex color. 
};
#define D3DFVF_SCREENVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)


struct SCREENVERTEX_TEX
{
    FLOAT x, y, z, rhw;
    FLOAT tu, tv;
};
#define D3DFVF_SCREENVERTEX_TEX (D3DFVF_XYZRHW|D3DFVF_TEX1)


struct D3DVERTEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
};
#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


struct D3DVERTEX_TEX
{
    D3DXVECTOR3 p;           // position
    D3DCOLOR    c;           // color
    FLOAT       tu, tv;     // texture
};
#define D3DFVF_D3DVERTEX_TEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)


enum State
{
   START,
   STAGE1,
   STAGE2,
   STAGE3,
   STAGE4,
   ENDSTAGE
};

// Constants to define our world space
#define XMIN -10
#define XMAX 10
#define ZMIN -10
#define ZMAX 10
#define YMIN 0
#define YMAX 5


// Some colors
#define SEMITRANS_BLACK 0x40000000
#define BLACK           0xff000000
#define WHITE           0xffffffff
#define YELLOW          0xffffff00
#define RED             0xffff0000
#define DARK_RED        0xff500000
#define DARK_GREEN      0xff008000




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Packed resources
    CXBPackedResource       m_xprResource;

    // Font
    CXBFont                 m_Font;

    // Current display state
    enum State              m_eCurrentState;

    // Track last button pressed
    INT                     m_iLastButton;

    // Geometry
    LPDIRECT3DVERTEXBUFFER8 m_pTestPatternVB; // Buffer to hold vertices for test pattern
    LPDIRECT3DTEXTURE8      m_pTestPatternTexture;
    
    // Geometry for floor, source, and listener
    LPDIRECT3DVERTEXBUFFER8 m_pFloorVB;             // Quad for the floor
    LPDIRECT3DVERTEXBUFFER8 m_pSourceVB;            // Quad for the source
    LPDIRECT3DVERTEXBUFFER8 m_pListenerVB;          // Quad for the listener
    LPDIRECT3DVERTEXBUFFER8 m_pGridVB;              // Lines to grid the floor
    LPDIRECT3DTEXTURE8      m_pSpeakerTexture;

    // Sound variables
    CWaveFile               m_wfSound;              // Wave file
    LONG                    m_lVolume;              // Current volume
    LPDIRECTSOUND8          m_pDSound;              // DirectSound object
    LPDIRECTSOUNDBUFFER8    m_pDSBuffer;            // DirectSoundBuffer
    BYTE*                   m_pSampleData;          // Sample data from wav

    // Sound source and listener positions
    D3DXVECTOR3             m_vSourcePosition;      // Source position vector
    D3DXVECTOR3             m_vListenerPosition;    // Listener position vector

    // Transform matrices
    D3DXMATRIX              m_matWorld;             // World transform
    D3DXMATRIX              m_matView;              // View transform
    D3DXMATRIX              m_matProj;              // Projection transform

    // Drawing functions
    VOID    DrawLine( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, DWORD dwStartColor, DWORD dwEndColor );
    VOID    DrawRectOutline( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, DWORD dwColor );
    VOID    DrawRect( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, DWORD dwStartColor, DWORD dwEndColor );
    VOID    DrawTextBox( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, WCHAR* strText );
    VOID    DrawTestPattern();
    VOID    DrawStartText();
    VOID    DrawStage1Text();
    VOID    DrawStage2Text();
    VOID    DrawStage3Text();
    VOID    DrawStage4Text();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_iLastButton       = XINPUT_GAMEPAD_A;
    m_eCurrentState     = START;

    m_pTestPatternVB      = NULL;
    m_pTestPatternTexture = NULL;

    m_pFloorVB          = NULL;
    m_pSourceVB         = NULL;
    m_pListenerVB       = NULL;
    m_pGridVB           = NULL;
    m_pSpeakerTexture   = NULL;

    m_lVolume           = DSBVOLUME_MAX;
    m_pSampleData       = NULL;
    m_vSourcePosition   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vListenerPosition = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    WAVEFORMATEX    wfSoundFormat;
    DWORD           dwSoundSampleSize;
    VOID*           pvBuffer;
    int i,j;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return E_FAIL;

    // Load the packed resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return E_FAIL;
    m_pTestPatternTexture = m_xprResource.GetTexture( resource_TestPattern_OFFSET );
    m_pSpeakerTexture     = m_xprResource.GetTexture( resource_Speaker_OFFSET );

    // Initialize vertices for rendering a square
    SCREENVERTEX_TEX g_TestPatternVertices[] =
    {
        {   0 - 0.5f, 480 - 0.5f, 0.0f, 1.0f,    0, 480 },
        {   0 - 0.5f,   0 - 0.5f, 0.0f, 1.0f,    0,   0 },
        { 640 - 0.5f, 480 - 0.5f, 0.0f, 1.0f,  640, 480 },

        { 640 - 0.5f, 480 - 0.5f, 0.0f, 1.0f,  640, 480 },
        {   0 - 0.5f,   0 - 0.5f, 0.0f, 1.0f,    0,   0 },
        { 640 - 0.5f,   0 - 0.5f, 0.0f, 1.0f,  640,   0 },
    };

    // Create the vertex buffer.
    m_pd3dDevice->CreateVertexBuffer( 6*sizeof(SCREENVERTEX_TEX),
                                      D3DUSAGE_WRITEONLY, 0, D3DPOOL_DEFAULT, 
                                      &m_pTestPatternVB );

    // Fill the vertex buffer.
    VOID* pVertices;
    m_pTestPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
    memcpy( pVertices, g_TestPatternVertices, sizeof(g_TestPatternVertices) );
    m_pTestPatternVB->Unlock();

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( XMIN, 45.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( XMIN,  0.0f,  ZMAX / 2.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f,  0.0f,  1.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create our vertex buffers
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pFloorVB );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX_TEX ), 0, 0, 0, &m_pSourceVB );
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( D3DVERTEX ), 0, 0, 0, &m_pListenerVB );
    m_pd3dDevice->CreateVertexBuffer( 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) * sizeof( D3DVERTEX ), 0, 0, 0, &m_pGridVB );
    
    // Fill the VB for the floor
    D3DVERTEX* pSoundVertices;
    m_pFloorVB->Lock( 0, 0, (BYTE **)&pSoundVertices, 0 );
    pSoundVertices[0].p = D3DXVECTOR3( XMIN, 0.0f, ZMIN ); pSoundVertices[0].c = 0xFF101010;
    pSoundVertices[1].p = D3DXVECTOR3( XMIN, 0.0f, ZMAX ); pSoundVertices[1].c = 0xFF101010;
    pSoundVertices[2].p = D3DXVECTOR3( XMAX, 0.0f, ZMIN ); pSoundVertices[2].c = 0xFF101010;
    pSoundVertices[3].p = D3DXVECTOR3( XMAX, 0.0f, ZMAX ); pSoundVertices[3].c = 0xFF101010;
    m_pFloorVB->Unlock();

    // Fill the VB for the grid
    m_pGridVB->Lock( 0, 0, (BYTE **)&pSoundVertices, 0 );
    for( i = ZMIN, j = 0; i <= ZMAX; i++, j++ )
    {
        pSoundVertices[ j * 2 ].p     = D3DXVECTOR3( XMIN, 0, (FLOAT)i ); pSoundVertices[ j * 2 ].c     = 0xFF00A000;
        pSoundVertices[ j * 2 + 1 ].p = D3DXVECTOR3( XMAX, 0, (FLOAT)i ); pSoundVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    for( i = XMIN; i <= XMAX; i++, j++ )
    {
        pSoundVertices[ j * 2 ].p     = D3DXVECTOR3( (FLOAT)i, 0, ZMIN ); pSoundVertices[ j * 2 ].c     = 0xFF00A000;
        pSoundVertices[ j * 2 + 1 ].p = D3DXVECTOR3( (FLOAT)i, 0, ZMAX ); pSoundVertices[ j * 2 + 1 ].c = 0xFF00A000;
    }
    m_pGridVB->Unlock();

    // Create DirectSound interface to the MCP
    if( FAILED( DirectSoundCreate( DSDEVID_MCPX, &m_pDSound, NULL ) ) )
        return E_FAIL;

    // Load up a wave file
    if( FAILED( m_wfSound.Open( "D:\\Media\\Sounds\\TestTone.wav" ) ) )
        return E_FAIL;

    // Check that it is a mono wav as we are going to use it for 3D positioning
    if( FAILED( m_wfSound.GetFormat( &wfSoundFormat, sizeof( WAVEFORMATEX ) ) ) )
        return E_FAIL;

    if( wfSoundFormat.nChannels != 1 )
    {
        OutputDebugString( _T(".wav file must be mono \n") );
            return E_FAIL;
    }

    // Create a sound buffer, we will be handling the memory for the buffer
    // ourselves in the sample, not via DSound
    DSBUFFERDESC dsbdesc;
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    // Note that DSBCAPS_LOCDEFER means that the hardware voice will not
    // be allocated until playback
    dsbdesc.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_LOCDEFER;

    // NOTE: Retail dsound will have problems if we pass in dwBufferBytes=0
    // So in retail we patch this to 1.
#ifdef _DEBUG
    dsbdesc.dwBufferBytes = 0;
#else
    dsbdesc.dwBufferBytes = 1;
#endif
    dsbdesc.lpwfxFormat = &wfSoundFormat;

    if( FAILED( m_pDSound->CreateSoundBuffer( &dsbdesc, &m_pDSBuffer, NULL ) ) )
        return E_FAIL;

    // now load in the sound sample data into the DSound buffer

    // Find out how big the sample is
    m_wfSound.GetDuration( &dwSoundSampleSize );

    // Set our allocation to that size
    pvBuffer = malloc( dwSoundSampleSize );
    if( !pvBuffer )
        return E_FAIL;
    m_pSampleData = (BYTE *)pvBuffer;

    // Read sample data from the file
    m_wfSound.ReadSample( 0, m_pSampleData, dwSoundSampleSize, &dwSoundSampleSize );

    // Set up values for the new buffer
    m_pDSBuffer->SetBufferData( m_pSampleData, dwSoundSampleSize );
    m_pDSBuffer->SetLoopRegion( 0, dwSoundSampleSize );
    m_pDSBuffer->SetCurrentPosition( 0 );

    // Note: If the application doesn't care about vertical HRTF positioning,
    //       calling Set3DHRTFAzimuthOnly() can save about 60k of memory.
//  m_pDSound->Set3DHRTFAzimuthOnly();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene. As this code only changes text, there is no real animation
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DVERTEX*     pVertices;
    D3DVERTEX_TEX* pTexVertices;
    D3DXVECTOR3    vListenerOld = m_vListenerPosition;
    D3DXVECTOR3    vSourceOld   = m_vSourcePosition;

    if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > 0 )
    {
        if( m_iLastButton != XINPUT_GAMEPAD_A )
        {
            m_iLastButton = XINPUT_GAMEPAD_A;

            switch(m_eCurrentState)
            {
                case START:
                    m_eCurrentState = STAGE1;
                    break;

                case STAGE1:
                    m_eCurrentState = STAGE2;
                    break;

                case STAGE2:
                    m_eCurrentState = STAGE3;
                    break;

                case STAGE3:
                    m_eCurrentState = STAGE4;
                    break;

                case STAGE4:
                    m_eCurrentState = START;
                    break;
                default:
                    m_eCurrentState = START;
            }
        }
    }
    else
    {
        m_iLastButton = !XINPUT_GAMEPAD_A;
    }

    // Increase/Decrease volume
    m_lVolume += LONG( ( ( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP   ) - 
                         ( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN ) ) * 50 );

    // Increase/Decrease volume
    m_lVolume += LONG( ( m_DefaultGamepad.fY2 ) * 50 );

    // Make sure volume is in the appropriate range
    if( m_lVolume < DSBVOLUME_MIN )
        m_lVolume = DSBVOLUME_MIN;
    if( m_lVolume > DSBVOLUME_MAX )
        m_lVolume = DSBVOLUME_MAX;

    // Handle movement of sound
    m_vSourcePosition.x += m_DefaultGamepad.fX1 * 0.2f;
    if( m_vSourcePosition.x < XMIN )
        m_vSourcePosition.x = XMIN;
    else if( m_vSourcePosition.x > XMAX )
        m_vSourcePosition.x = XMAX;

    m_vSourcePosition.z += m_DefaultGamepad.fY1 * 0.2f;
    if( m_vSourcePosition.z < ZMIN )
        m_vSourcePosition.z = ZMIN;
    else if( m_vSourcePosition.z > ZMAX )
        m_vSourcePosition.z = ZMAX;

    // Update source/listener vertex buffers
    #define SIZE 1.0f

    m_pSourceVB->Lock( 0, 0, (BYTE **)&pTexVertices, 0 );
    pTexVertices[0].p = m_vSourcePosition + D3DXVECTOR3( -(SIZE), 0.0f, -(SIZE) ); pTexVertices[0].c = D3DCOLOR_RGBA(0xff,0x00,0x00,0xff); pTexVertices[0].tu = 0.0f; pTexVertices[0].tv = 0.0f; 
    pTexVertices[1].p = m_vSourcePosition + D3DXVECTOR3( -(SIZE), 0.0f,  (SIZE) ); pTexVertices[1].c = D3DCOLOR_RGBA(0xff,0x00,0x00,0xff); pTexVertices[1].tu = 0.0f; pTexVertices[1].tv = 1.0f; 
    pTexVertices[2].p = m_vSourcePosition + D3DXVECTOR3(  (SIZE), 0.0f, -(SIZE) ); pTexVertices[2].c = D3DCOLOR_RGBA(0xff,0x00,0x00,0xff); pTexVertices[2].tu = 1.0f; pTexVertices[2].tv = 0.0f; 
    pTexVertices[3].p = m_vSourcePosition + D3DXVECTOR3(  (SIZE), 0.0f,  (SIZE) ); pTexVertices[3].c = D3DCOLOR_RGBA(0xff,0x00,0x00,0xff); pTexVertices[3].tu = 1.0f; pTexVertices[3].tv = 1.0f; 
    m_pSourceVB->Lock( 0, 0, (BYTE **)&pTexVertices, 0 );

    m_pListenerVB->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f, -0.5f ); pVertices[0].c = D3DCOLOR_RGBA(0xff,0xff,0x00,0xff);
    pVertices[1].p = m_vListenerPosition + D3DXVECTOR3( -0.5f, 0.0f,  0.5f ); pVertices[1].c = D3DCOLOR_RGBA(0xff,0xff,0x00,0xff);
    pVertices[2].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f, -0.5f ); pVertices[2].c = D3DCOLOR_RGBA(0xff,0xff,0x00,0xff);
    pVertices[3].p = m_vListenerPosition + D3DXVECTOR3(  0.5f, 0.0f,  0.5f ); pVertices[3].c = D3DCOLOR_RGBA(0xff,0xff,0x00,0xff);
    m_pListenerVB->Lock( 0, 0, (BYTE **)&pVertices, 0 );

    // Position the sound and listener in 3D. 
    // We use DS3D_DEFERRED so that all the changes will 
    // be commited at once.
    D3DXVECTOR3 vListenerVelocity = ( m_vListenerPosition - vListenerOld ) / m_fElapsedTime;
    D3DXVECTOR3 vSoundVelocity = ( m_vSourcePosition - vSourceOld ) / m_fElapsedTime;

    // Source position/velocity/volume
    m_pDSBuffer->SetPosition( m_vSourcePosition.x, m_vSourcePosition.y, m_vSourcePosition.z, DS3D_DEFERRED );
    m_pDSBuffer->SetVelocity( vSoundVelocity.x, vSoundVelocity.y, vSoundVelocity.z, DS3D_DEFERRED );
    m_pDSBuffer->SetVolume( m_lVolume );

    // Listener position/velocity
    m_pDSound->SetPosition( m_vListenerPosition.x, m_vListenerPosition.y, m_vListenerPosition.z, DS3D_DEFERRED  );
    m_pDSound->SetVelocity( vListenerVelocity.x, vListenerVelocity.y, vListenerVelocity.z, DS3D_DEFERRED );

    // Commit position/velocity changes
    m_pDSound->CommitDeferredSettings();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawLine()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawLine( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                            DWORD dwStartColor, DWORD dwEndColor )
{
    SCREENVERTEX v[2];
    v[0].pos = D3DXVECTOR4( x1, y1, 0.5f, 1.0f );   v[0].color = dwStartColor;
    v[1].pos = D3DXVECTOR4( x2, y2, 0.5f, 1.0f );   v[1].color = dwEndColor;
    
    // Render the line
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    m_pd3dDevice->SetVertexShader( D3DFVF_SCREENVERTEX) ;
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, v, sizeof(SCREENVERTEX) );
}





//-----------------------------------------------------------------------------
// Name: DrawRectOutline()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawRectOutline( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                                   DWORD dwColor )
{
    DrawLine( x1, y1, x1, y2, dwColor, dwColor );
    DrawLine( x1, y1, x2, y1, dwColor, dwColor );
    DrawLine( x2, y1, x2, y2, dwColor, dwColor );
    DrawLine( x1, y2, x2, y2, dwColor, dwColor );
}




//-----------------------------------------------------------------------------
// Name: DrawRect()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawRect( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                            DWORD dwStartColor, DWORD dwEndColor )
{
    SCREENVERTEX v[4];
    v[0].pos = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = dwStartColor;
    v[1].pos = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = dwStartColor;
    v[2].pos = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = dwEndColor;
    v[3].pos = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = dwEndColor;
    
    // Render the rectangle
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    m_pd3dDevice->SetVertexShader( D3DFVF_SCREENVERTEX );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(SCREENVERTEX) );
}




//-----------------------------------------------------------------------------
// Name: DrawTextBox()
// Desc: Renders text in an outlined, semi-transparent box
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawTextBox( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                               WCHAR* strText )
{
    DrawRect( x1, y1, x2, y2, SEMITRANS_BLACK, SEMITRANS_BLACK );
    DrawRectOutline( x1, y1, x2, y2, BLACK );
    m_Font.DrawText( x1+5, y1+5, WHITE, strText );
}




//-----------------------------------------------------------------------------
// Name: DrawTestPattern()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawTestPattern()
{
    // Set state for rendering the quad
    m_pd3dDevice->SetTexture( 0, m_pTestPatternTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    m_pd3dDevice->SetStreamSource( 0, m_pTestPatternVB, sizeof(SCREENVERTEX_TEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_SCREENVERTEX_TEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 2 );
}




//-----------------------------------------------------------------------------
// Name: DrawStartText()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawStartText()
{
    // Stop the sound if it is playing
    m_pDSBuffer->Stop();

    // Render instructions in an outlined, semi-transparent box
    DrawTextBox( 64, 50, 576, 135, L"Turn CONTRAST up to full, then turn BRIGHTNESS up\n"
                                   L"until you can see five different shades of black\n"
                                   L"between these lines." );

    // Draw lines
    DrawLine( 468, 135, 468, 340, BLACK,  YELLOW );
    DrawLine( 336, 340, 600, 340, YELLOW, YELLOW );
    DrawLine( 336, 340, 336, 360, YELLOW, YELLOW );
    DrawLine( 600, 340, 600, 360, YELLOW, YELLOW );
}




//-----------------------------------------------------------------------------
// Name: DrawStage1Text()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawStage1Text()
{
    // Render instructions in an outlined, semi-transparent box
    DrawTextBox( 64, 50, 576, 135, L"Now reduce BRIGHTNESS until the grey bar\n"
                                   L"disappears, then turn the BRIGHTNESS back up\n"
                                   L"until it becomes just visible." );

    // Draw lines
    DrawLine( 536, 135, 536, 340, BLACK,  YELLOW );
    DrawLine( 520, 340, 552, 340, YELLOW, YELLOW );
    DrawLine( 520, 340, 520, 360, YELLOW, YELLOW );
    DrawLine( 552, 340, 552, 360, YELLOW, YELLOW );
}




//-----------------------------------------------------------------------------
// Name: DrawStage2Text()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawStage2Text()
{
    m_pd3dDevice->SetTexture( 0, NULL );

    // Render instructions in an outlined, semi-transparent box
    DrawTextBox( 64, 50, 576, 160, L"Set CONTRAST by lowering it until the edges of the\n"
                                   L"white bar look sharp, continue lowering until white\n"
                                   L"bar begins to look not-white, then turn back up until\n"
                                   L"white bar looks white again." );

    // Draw lines
    DrawLine( 173, 160, 173, 340, BLACK,  YELLOW );
    DrawLine( 113, 340, 223, 340, YELLOW, YELLOW );
    DrawLine( 113, 340, 113, 360, YELLOW, YELLOW );
    DrawLine( 223, 340, 223, 360, YELLOW, YELLOW );
}




//-----------------------------------------------------------------------------
// Name: DrawStage3Text()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawStage3Text()
{
    m_pd3dDevice->SetTexture( 0, NULL );

    // Render instructions in an outlined, semi-transparent box
    DrawTextBox( 64, 50, 576, 110, L"Now adjust COLOR to minimise bleeding, using\n"
                                   L"the red bar as your main reference." );
}




//-----------------------------------------------------------------------------
// Name: DrawStage4Text()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawStage4Text()
{
    // Start Sound
    m_pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    // Render a background
    RenderGradientBackground( DARK_GREEN, BLACK );

    // Render instructions in an outlined, semi-transparent box
    DrawTextBox( 64, 50, 576, 135, L"Adjust TV sound to desired level, use UP/DOWN to\n"
                                   L"control program volume for testing and use sticks\n"
                                   L"to move the direction of the sound to test speakers." );

    // Render the volume bar
    FLOAT fVolumePercent = 100.0f * ( m_lVolume - DSBVOLUME_MIN ) / (DSBVOLUME_MAX - DSBVOLUME_MIN );
    DrawRect( 64, 390-fVolumePercent, 84, 390, RED, DARK_RED );
    DrawRectOutline( 64, 290, 84, 390, YELLOW );

    // Render the volume text
    WCHAR strVolumeText[40];
    swprintf( strVolumeText, L"Volume: %d%%", (DWORD)fVolumePercent );
    m_Font.DrawText( 64, 390, 0xffffff00, strVolumeText);

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX );

    // Draw the floor
    m_pd3dDevice->SetStreamSource( 0, m_pFloorVB, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the grid
    m_pd3dDevice->SetStreamSource( 0, m_pGridVB, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, 2 * ( ( ZMAX - ZMIN + 1 ) + ( XMAX - XMIN + 1 ) ) );

    // Draw the listener
    m_pd3dDevice->SetStreamSource( 0, m_pListenerVB, sizeof( D3DVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Draw the source
    m_pd3dDevice->SetTexture( 0, m_pSpeakerTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    m_pd3dDevice->SetVertexShader( D3DFVF_D3DVERTEX_TEX );
    m_pd3dDevice->SetStreamSource( 0, m_pSourceVB, sizeof( D3DVERTEX_TEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Depending on the app state, call one of the following methods
    switch( m_eCurrentState )
    {
        case START:
            DrawTestPattern();
            DrawStartText();
            break;

        case STAGE1:
            DrawTestPattern();
            DrawStage1Text();
            break;
        
        case STAGE2:
            DrawTestPattern();
            DrawStage2Text();
            break;
        
        case STAGE3:
            DrawTestPattern();
            DrawStage3Text();
            break;
        
        case STAGE4:
            DrawStage4Text();
            break;
        
        case ENDSTAGE:
            break;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\inifile.cpp ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.CPP
//
// Desc: INI file routines
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <assert.h>

#include "utils.h"
#include "inifile.h"




//-----------------------------------------------------------------------------
// Name: GetIniConstValue
//
// Desc: Get the value of a constant
//-----------------------------------------------------------------------------
LPCSTR CIniFile::GetIniConstValue( const char *szStr, INIVAL *pinival )
{
    // skip whitespace
    while( *szStr == ' ' || *szStr == '\t' )
        szStr++;

    if( ( *szStr >= '0' && *szStr <= '9' ) || ( *szStr == '.' ) )
    {
        char *endptr;
        int base = 10;

        if( szStr[1] == 'x' )
        {
            // hexadecimal: skip over leading '0x'
            base = 16;
            szStr += 2;
        }
        else if( pinival->type == INIVAL_FLOAT )
        {
            // check for floating point value
            for( const char *szT = szStr;
                *szT && ( ( *szT >= '0' && *szStr <= '9' ) || *szT == '.' );
                szT++ )
            {
                if( *szT == '.' )
                {
                    for( szT++; *szT && ( *szT >= '0' && *szStr <= '9' ); szT++ )
                        ;

                    // check for trailing f
                    if( *szT == 'f' )
                        szT++;

                    pinival->SetVal( (float) atof( szStr ) );
                    return szT;
                }
            }
        }

        pinival->SetVal( (int) strtoul( szStr, &endptr, base ) );
        return endptr;
    }

    // token length
    int cchStr = 0;

    // find token length
    for( const char *szT = szStr; 
         *szT && ( *szT != ';' ) && ( *szT != '|' ) && !isspace( *szT ); szT++ )
        cchStr++;

    // see if the token is known by the app
    if( GetIniConstf( szStr, cchStr, &pinival->valf ) )
    {
        pinival->val = (int)pinival->valf;
        return szStr + cchStr;
    }
    else if( GetIniConst( szStr, cchStr, &pinival->val ) )
    {
        pinival->valf = (float)pinival->val;
        return szStr + cchStr;
    }

    // couldn't find token - search in [defines] section
    if( m_recurselevel < 10 )
    {
        char szKeyName[64];
        static const char szSectName[] = "defines";

        lstrcpynA( szKeyName, szStr, min( sizeof( szKeyName ), cchStr + 1 ) );

        LPCSTR szLineStart;
        LPCSTR szLine = GetIniStr( szSectName, szKeyName, NULL, &szLineStart );

        if( szLine )
        {
            bool fFoundDefine = false;

            m_recurselevel++;

            // did not find entry - search in defines section
            if( pinival->type == INIVAL_FLOAT )
            {
                fFoundDefine = ParseFloatVal( szLineStart, szLine, &pinival->valf );
                pinival->val = (int)pinival->valf;
            }
            else
            {
                fFoundDefine = ParseIntVal( szLineStart, szLine, &pinival->val );
                pinival->valf = (float)pinival->val;
            }

            m_recurselevel--;

            if( fFoundDefine )
                return szStr + cchStr;
        }
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: SzReadFile
//
// Desc: Read a file and return malloc'd pointer to data
//-----------------------------------------------------------------------------
char *SzReadFile( LPCSTR szFileName )
{

    HANDLE hFile = CreateFile( szFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );
    if( hFile != INVALID_HANDLE_VALUE )
    {
        DWORD dwSize = GetFileSize( hFile, NULL );
        char *szFile = (char *)malloc( dwSize + 1 );
        assert( szFile != NULL);

        DWORD NumberOfBytesRead;
		BOOL bReadOK;
        bReadOK = ReadFile( hFile, szFile, dwSize, &NumberOfBytesRead, NULL );
		assert(bReadOK);
        assert(dwSize == NumberOfBytesRead );
        
		szFile[NumberOfBytesRead] = 0;

        CloseHandle( hFile );
        return szFile;
    }
    else
    {
        HRESULT result = GetLastError();
        dprintf( "Could not open %s   Error: %d\n", szFileName, result);
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: ReadFile
//
// Desc: Read/refresh ini file
//-----------------------------------------------------------------------------
bool CIniFile::ReadFile()
{
    if( m_szFile )
    {
        free( m_szFile );
        m_szFile = NULL;
    }

    m_szFile = SzReadFile( m_szFileName );
    if( !m_szFile )
    {
        // if file read failed - sleep a short bit in case xbcp
        // had file open still.
        Sleep( 500 );
        m_szFile = SzReadFile( m_szFileName);
    }

    if( m_szFile )
    {
        HANDLE hFile = CreateFile( m_szFileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

        if( hFile != INVALID_HANDLE_VALUE )
            GetFileTime( hFile, NULL, NULL, &m_ftFileReadTime );

        CloseHandle(hFile);

        return true;
    }

    return false;
}




//-----------------------------------------------------------------------------
// Name: GetLine
//
// Desc: Find the next real line and return pointer
//-----------------------------------------------------------------------------
LPCSTR GetLine( LPCSTR szLine )
{
    for( ;; )
    {
        // skip whitespace
        while( isspace( *szLine ) )
            szLine++;

        // check for comments
        if( *szLine == ';' || ( szLine[0] == '/' && szLine[1] == '/' ) )
        {
            // found a comment - cruise to end of line
            while( *szLine && *szLine != '\n' )
                szLine++;
            continue;
        }

        return szLine;
    }
}




//-----------------------------------------------------------------------------
// Name: FindFirst
//
// Desc: Get first line of INI file
//-----------------------------------------------------------------------------
LPCSTR FindFirstLine( LPCSTR szFile )
{
    if( szFile )
        return GetLine( szFile );

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: FindNextLine
//
// Desc: Get line after szLine
//-----------------------------------------------------------------------------
LPCSTR FindNextLine( LPCSTR szLine )
{
    if( szLine )
    {
        while( *szLine && *szLine++ != '\n' )
            ;
        return GetLine( szLine );
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: FindNextChar
//
// Desc: Find the next token's first char
//-----------------------------------------------------------------------------
char FindNextChar( LPCSTR szLine, LPCSTR *ppszLine = NULL )
{
    // skip whitespace
    while( *szLine == ' ' || *szLine == '\t' )
        szLine++;

    if( ppszLine )
        *ppszLine = szLine;
    return *szLine;
}




//-----------------------------------------------------------------------------
// Name: OuputLineErr
//
// Desc: Print out error message for something we couldn't parse
//-----------------------------------------------------------------------------
void OutputLineErr(LPCSTR szErr, LPCSTR szLine)
{
    LPCSTR szEnd = szLine;
    while( *szEnd && ( *szEnd != '\r' && *szEnd != '\n' ) )
        szEnd++;

    char chSav = *szEnd;
    *(char *)szEnd = 0;

    OutputDebugStringA( szErr );
    OutputDebugStringA( ":" );
    OutputDebugStringA( szLine );
    OutputDebugStringA( "\n" );

    *(char *)szEnd = chSav;
}




//-----------------------------------------------------------------------------
// Name: ParseFloatVal
//
// Desc: Parse a token stream and return the value
//-----------------------------------------------------------------------------
bool CIniFile::ParseFloatVal( LPCSTR szLineStart, LPCSTR szLine, float *pval )
{
    INIVAL valT = { INIVAL_FLOAT };
    if( GetIniConstValue( szLine, &valT ) )
    {
        *pval = valT.valf;
        return true;
    }

    OutputLineErr("unknown token", szLineStart );
    return false;
}




//-----------------------------------------------------------------------------
// Name: ParseIntVal
//
// Desc: Parse a token stream and return the value
//-----------------------------------------------------------------------------
bool CIniFile::ParseIntVal( LPCSTR szLineStart, LPCSTR szLine, int *pval )
{
    INIVAL valT = { INIVAL_INT };
    int val = 0;

    while( szLine = GetIniConstValue( szLine, &valT ) )
    {
        val |= valT.val;

        char ch = FindNextChar( szLine, &szLine );
        switch( ch )
        {
        case '|':
            szLine++;
            break;
             
        case '\r':
        case '\n':
        case '\0':
        case ';':
            // end of the line
            *pval = val;
            return true;

        default:
            OutputLineErr( "unknown char", szLineStart );
            return false;
        }
    }

    OutputLineErr( "unknown token", szLineStart );
    return false;
}




//-----------------------------------------------------------------------------
// Name: GetIniFloat
//
// Desc: Get float value for ini entry
//-----------------------------------------------------------------------------
float CIniFile::GetIniFloat( LPCSTR lpSectionName, LPCSTR lpKeyName, 
                             float nDefault )
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, &szLineStart );

    if( !szLine )
        return nDefault;

    ParseFloatVal( szLineStart, szLine, &nDefault );
    return nDefault;
}




//-----------------------------------------------------------------------------
// Name: GetIniInt
//
// Desc: Get int value for ini entry
//-----------------------------------------------------------------------------
int CIniFile::GetIniInt( LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault )
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, &szLineStart );

    if( !szLine )
        return nDefault;

    ParseIntVal( szLineStart, szLine, &nDefault );
    return nDefault;
}




//-----------------------------------------------------------------------------
// Name: IniEntryExists
//
// Desc: Check if an ini entry exists
//-----------------------------------------------------------------------------
bool CIniFile::IniEntryExists( LPCSTR lpSectionName, LPCSTR lpKeyName )
{
    bool fverboseBak = m_fverbose;
    m_fverbose = false;

    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, NULL );

    m_fverbose = fverboseBak;
    return !!szLine;
}




//-----------------------------------------------------------------------------
// Name: GetIniStrBuf
//
// Desc: Get an INI string and shtuff it into a buffer
//-----------------------------------------------------------------------------
bool CIniFile::GetIniStrBuf( LPCSTR lpSectionName, LPCSTR lpKeyName,
                             LPCSTR szDefault, char *buf, int buflen )
{
    LPCSTR szLine = GetIniStr( lpSectionName, lpKeyName, NULL, NULL );
    if( szLine )
    {
        strncpy( buf, szLine, buflen );

        for( int nT = 0; nT < buflen; nT++ )
        {
            if( buf[nT] == '\n' || buf[nT] == '\r' || buf[nT] == ';' )
            {
                buf[nT] = 0;
                break;
            }
        }
    }
    else
    {
        strncpy( buf, szDefault, buflen );
    }

    buf[buflen - 1] = 0;
    return !!szLine;
}




//-----------------------------------------------------------------------------
// Name: GetIniStr
//
// Desc: Return non-nil terminated string for keyname
//-----------------------------------------------------------------------------
LPCSTR CIniFile::GetIniStr( LPCSTR lpSectionName, LPCSTR lpKeyName, 
                            LPCSTR szDefault, LPCSTR *ppszLineStart )
{
    assert( m_szFile );
    if( !m_szFile )
        return szDefault;

    bool finsection = false;
    int cchSectionName = lstrlenA( lpSectionName );
    int cchKeyName = lstrlenA( lpKeyName );
    LPCSTR szLine = FindFirstLine( m_szFile );

    while( szLine && *szLine )
    {
        if( ppszLineStart )
            *ppszLineStart = szLine;

        if( finsection )
        {
            if( *szLine == '[' )
            {
                // new section - not found
                break;
            }
            else if( !_strnicmp(lpKeyName, szLine, cchKeyName ) &&
                   ( FindNextChar(szLine + cchKeyName, &szLine ) == '=' ) )
            {
                // skip over '='
                szLine++;

                // skip whitespace
                while( *szLine == ' ' || *szLine == '\t' )
                    szLine++;

                return szLine;
            }
        }
        else if( *szLine == '[' )
        {
            // section name matches?
            szLine++;
            finsection = !_strnicmp( lpSectionName, szLine, cchSectionName ) &&
                                   ( FindNextChar( szLine + cchSectionName ) == ']' );
        }

        szLine = FindNextLine( szLine );
    }

    if( m_fverbose )
        dprintf( "entry [%s]/%s not found\n", lpSectionName, lpKeyName );

    return szDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\utils.cpp ===
//-----------------------------------------------------------------------------
// FILE: UTILS.CPP
//
// Desc: Utility functions used by FillRate App
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>

#include "bitfont.h"
#include "utils.h"




//----------------------------------------------------------------------------
// CScrText font class
BitFont g_bitfont;




//----------------------------------------------------------------------------
// Name: GetTextureModeStr
//
// Desc: Stringtize PS_TEXTUREMODES_*
//----------------------------------------------------------------------------
LPCSTR GetTextureModeStr( DWORD TextureMode )
{
    #undef XTAG
    #define XTAG( _tag ) { PS_TEXTUREMODES##_tag, "PS_TM" #_tag }
    
    static const struct
    {
        DWORD texturemode;
        const char *szD3DMSStr;
    } rgszTMStr[] =
    {
        XTAG( _NONE ),           XTAG( _PROJECT2D ),      XTAG( _PROJECT3D ),
        XTAG( _CUBEMAP ),        XTAG( _PASSTHRU ),       XTAG( _CLIPPLANE ),
        XTAG( _BUMPENVMAP ),     XTAG( _BUMPENVMAP_LUM ), XTAG( _BRDF ),
        XTAG( _DOT_ST ),         XTAG( _DOT_ZW ),         XTAG( _DOT_RFLCT_DIFF ),
        XTAG( _DOT_RFLCT_SPEC ), XTAG( _DOT_STR_3D ),     XTAG( _DOT_STR_CUBE ),
        XTAG( _DPNDNT_AR ),      XTAG( _DPNDNT_GB ),      XTAG( _DOTPRODUCT ),
        XTAG( _DOT_RFLCT_SPEC_CONST ),
    };

    static const int cFmts = sizeof( rgszTMStr ) / sizeof( rgszTMStr[0] );

    for( int ifmt = 0; ifmt < cFmts; ifmt++ )
    {
        if( rgszTMStr[ifmt].texturemode == TextureMode )
            return rgszTMStr[ifmt].szD3DMSStr;
    }

    return rgszTMStr[cFmts - 1].szD3DMSStr;
}




//----------------------------------------------------------------------------
// Name: GetMultiSampleStr
//
// Desc: Stringtize D3DMS_*
//----------------------------------------------------------------------------
LPCSTR GetMultiSampleStr( DWORD mstype )
{
    #undef XTAG
    #define XTAG( _tag ) { _tag, #_tag }
    static const struct
    {
        DWORD mstype;
        const char *szD3DMSStr;
    } rgszMSStr[] =
    {
        XTAG( D3DMS_NONE ), 
        XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX ), 
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR ), 
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN ),
        XTAG( D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_PREFILTER_FORMAT_DEFAULT ),
        XTAG( D3DMS_PREFILTER_FORMAT_X1R5G5B5 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_R5G6B5 ),
        XTAG( D3DMS_PREFILTER_FORMAT_X8R8G8B8 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_A8R8G8B8 ),
    };

    static const int cFmts = sizeof( rgszMSStr ) / sizeof( rgszMSStr[0] );

    for( int ifmt = 0; ifmt < cFmts; ifmt++ )
    {
        if( rgszMSStr[ifmt].mstype == mstype )
            return rgszMSStr[ifmt].szD3DMSStr;
    }

    return rgszMSStr[cFmts - 1].szD3DMSStr;
}




//----------------------------------------------------------------------------
// Name: GetD3DCMPStr
//
// Desc: Stringtize D3DCMP_*
//----------------------------------------------------------------------------
LPCSTR GetD3DCMPStr( D3DCMPFUNC d3dcmpfunc )
{
    static const char *rgszD3DCmp[] =
    {
        "D3DCMP_NEVER",       
        "D3DCMP_LESS",        
        "D3DCMP_EQUAL",       
        "D3DCMP_LESSEQUAL",   
        "D3DCMP_GREATER",     
        "D3DCMP_NOTEQUAL",    
        "D3DCMP_GREATEREQUAL",
        "D3DCMP_ALWAYS",      
        "??",
    };

    DWORD id3dcmp = min( d3dcmpfunc & 0xf, sizeof( rgszD3DCmp ) / 
                         sizeof( rgszD3DCmp[0] ) );
    return rgszD3DCmp[id3dcmp];
}




//----------------------------------------------------------------------------
// Name: GetD3dFormatStr
//
// Desc: Stringtize D3DFMT_*
//----------------------------------------------------------------------------
LPCSTR GetD3DFormatStr( D3DFORMAT d3dformat )
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        D3DFORMAT d3dformat;
        const char *szD3DFormat;
    } rgszD3DFmt[] =
    {
        XTAG( D3DFMT_A8R8G8B8 ), XTAG( D3DFMT_X8R8G8B8 ), 
        XTAG( D3DFMT_R5G6B5 ), XTAG( D3DFMT_R6G5B5 ), 
        XTAG( D3DFMT_X1R5G5B5 ), XTAG( D3DFMT_A1R5G5B5 ),
        XTAG( D3DFMT_A4R4G4B4 ), XTAG( D3DFMT_A8 ), 
        XTAG( D3DFMT_A8B8G8R8 ), XTAG( D3DFMT_B8G8R8A8 ), 
        XTAG( D3DFMT_R4G4B4A4 ), XTAG( D3DFMT_R5G5B5A1 ),
        XTAG( D3DFMT_R8G8B8A8 ), XTAG( D3DFMT_R8B8 ), 
        XTAG( D3DFMT_G8B8 ), XTAG( D3DFMT_P8 ), 
        XTAG( D3DFMT_L8 ), XTAG( D3DFMT_A8L8 ),
        XTAG( D3DFMT_AL8 ), XTAG( D3DFMT_L16 ), 
        XTAG( D3DFMT_V8U8 ), XTAG( D3DFMT_L6V5U5 ), 
        XTAG( D3DFMT_X8L8V8U8 ), XTAG( D3DFMT_Q8W8V8U8 ),
        XTAG( D3DFMT_V16U16 ), XTAG( D3DFMT_D16_LOCKABLE ), 
        XTAG( D3DFMT_D16 ), XTAG( D3DFMT_D24S8 ), 
        XTAG( D3DFMT_F16 ), XTAG( D3DFMT_F24S8 ),
        XTAG( D3DFMT_UYVY ), XTAG( D3DFMT_YUY2 ), 
        XTAG( D3DFMT_DXT1 ), XTAG( D3DFMT_DXT2 ), 
        XTAG( D3DFMT_DXT3 ), XTAG( D3DFMT_DXT4 ),
        XTAG( D3DFMT_DXT5 ), XTAG( D3DFMT_LIN_A1R5G5B5 ), 
        XTAG( D3DFMT_LIN_A4R4G4B4 ), XTAG( D3DFMT_LIN_A8 ), 
        XTAG( D3DFMT_LIN_A8B8G8R8 ), XTAG( D3DFMT_LIN_A8R8G8B8 ), 
        XTAG( D3DFMT_LIN_B8G8R8A8 ), XTAG( D3DFMT_LIN_G8B8 ), 
        XTAG( D3DFMT_LIN_R4G4B4A4 ), XTAG( D3DFMT_LIN_R5G5B5A1 ), 
        XTAG( D3DFMT_LIN_R5G6B5 ), XTAG( D3DFMT_LIN_R6G5B5 ),
        XTAG( D3DFMT_LIN_R8B8 ), XTAG( D3DFMT_LIN_R8G8B8A8 ), 
        XTAG( D3DFMT_LIN_X1R5G5B5 ), XTAG( D3DFMT_LIN_X8R8G8B8 ), 
        XTAG( D3DFMT_LIN_A8L8 ), XTAG( D3DFMT_LIN_AL8 ), 
        XTAG( D3DFMT_LIN_L16 ), XTAG( D3DFMT_LIN_L8 ), 
        XTAG( D3DFMT_LIN_D24S8 ), XTAG( D3DFMT_LIN_F24S8 ), 
        XTAG( D3DFMT_LIN_D16 ), XTAG( D3DFMT_LIN_F16 ),
        XTAG( D3DFMT_UNKNOWN ),
    };

    static const int cFmts = sizeof( rgszD3DFmt ) / sizeof( rgszD3DFmt[0] );

    for( int ifmt = 0; ifmt < cFmts; ifmt++ )
    {
        if( rgszD3DFmt[ifmt].d3dformat == d3dformat )
            return rgszD3DFmt[ifmt].szD3DFormat;
    }

    return rgszD3DFmt[cFmts - 1].szD3DFormat;
}




//----------------------------------------------------------------------------
// Name: IsLinearFormat
//
// Desc: Check whether specified format is linear
//----------------------------------------------------------------------------
bool IsLinearFormat( DWORD Format )
{
    switch( Format )
    {
        case D3DFMT_LIN_A1R5G5B5:
        case D3DFMT_LIN_A4R4G4B4:
        case D3DFMT_LIN_A8:
        case D3DFMT_LIN_A8B8G8R8:
        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_B8G8R8A8:
        case D3DFMT_LIN_G8B8:
        case D3DFMT_LIN_R4G4B4A4:
        case D3DFMT_LIN_R5G5B5A1:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_R6G5B5:
        case D3DFMT_LIN_R8B8:
        case D3DFMT_LIN_R8G8B8A8:
        case D3DFMT_LIN_X1R5G5B5:
        case D3DFMT_LIN_X8R8G8B8:
    
        case D3DFMT_LIN_A8L8:
        case D3DFMT_LIN_AL8:
        case D3DFMT_LIN_L16:
        case D3DFMT_LIN_L8:
    
        case D3DFMT_LIN_D24S8:
        case D3DFMT_LIN_F24S8:
        case D3DFMT_LIN_D16:
        case D3DFMT_LIN_F16:
            return true;
    }

    return false;
}




//----------------------------------------------------------------------------
// Name: BitsPerPixelOfD3DFORMAT
//
// Desc:nReturn number of bits per pixel/texel.
//----------------------------------------------------------------------------
DWORD BitsPerPixelOfD3DFORMAT( DWORD Format )
{
    DWORD retval = 0;

    switch( Format )
    {
        case D3DFMT_A8R8G8B8:   // Q8W8V8U8
        case D3DFMT_X8R8G8B8:   // X8L8V8U8
        case D3DFMT_A8B8G8R8:
        case D3DFMT_B8G8R8A8:
        case D3DFMT_R8G8B8A8:
        case D3DFMT_V16U16:
        case D3DFMT_D24S8:
        case D3DFMT_F24S8:
        case D3DFMT_UYVY:
        case D3DFMT_YUY2:
        case D3DFMT_LIN_A8B8G8R8:
        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_B8G8R8A8:
        case D3DFMT_LIN_R8G8B8A8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_D24S8:
        case D3DFMT_LIN_F24S8:
            retval = 32;
            break;
    
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_R4G4B4A4:
        case D3DFMT_R5G5B5A1:
        case D3DFMT_R8B8:
        case D3DFMT_G8B8:   // V8U8
        case D3DFMT_A8L8:
        case D3DFMT_L16:
        case D3DFMT_L6V5U5:
        case D3DFMT_D16_LOCKABLE:  // D16
        case D3DFMT_F16:
        case D3DFMT_LIN_A1R5G5B5:
        case D3DFMT_LIN_A4R4G4B4:
        case D3DFMT_LIN_G8B8:
        case D3DFMT_LIN_R4G4B4A4:
        case D3DFMT_LIN_R5G5B5A1:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_R6G5B5:
        case D3DFMT_LIN_R8B8:
        case D3DFMT_LIN_X1R5G5B5:
        case D3DFMT_LIN_A8L8:
        case D3DFMT_LIN_L16:
        case D3DFMT_LIN_D16:
        case D3DFMT_LIN_F16:
            retval = 16;
            break;
    
        case D3DFMT_A8:
        case D3DFMT_P8:
        case D3DFMT_L8:
        case D3DFMT_AL8:
        case D3DFMT_LIN_A8:
        case D3DFMT_LIN_AL8:
        case D3DFMT_LIN_L8:
            retval = 8;
            break;
    
        case D3DFMT_DXT1:
            retval = 4;
            break;
    
        case D3DFMT_DXT2: // DXT3
        case D3DFMT_DXT4: // DXT5
            retval = 8;
            break;
    
        default:
            CheckHR(E_FAIL);
            retval = 0;
            break;
    }

    return retval;
}




//----------------------------------------------------------------------------
// Name: DisplayError
//
// Desc: Display d3d error then break into debugger
//----------------------------------------------------------------------------
void DisplayError( const char *szCall, HRESULT hr )
{
    char szErr[512];

    if FAILED( hr )
    {
        UINT cch = _snprintf( szErr, sizeof( szErr ), 
                              "FATAL: %s failed 0x%08lX: ", szCall, hr );
		szErr[511] = '\0';

        D3DXGetErrorStringA( hr, &szErr[cch], sizeof( szErr ) - cch - 1 );
    }
    else
    {
        lstrcpynA( szErr, szCall, sizeof( szErr ) - 1 );
    }

    lstrcatA( szErr, "\n" );
    OutputDebugStringA( szErr );

    _asm int 3;
}




//----------------------------------------------------------------------------
// Name: dprintf
//
// Desc: Formatted debug Output
//----------------------------------------------------------------------------
void _cdecl dprintf(LPCSTR lpFmt, ...)
{
    va_list arglist;
    char lpOutput[256];

    va_start( arglist, lpFmt );
    _vsnprintf( lpOutput, sizeof( lpOutput ), lpFmt, arglist );
    va_end( arglist );

    OutputDebugStringA( lpOutput );
}




//----------------------------------------------------------------------------
// Name: drawtext
//
// Desc: Draw CScrText text buffer to front buffer
//----------------------------------------------------------------------------
void CScrText::drawtext( bool fDebug )
{
    IDirect3DSurface8 *pFrontBuffer = NULL;

    D3DDevice_GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer );
    if( pFrontBuffer )
    {
        // render results to the frontbuffer
        DWORD dx = 40;
        DWORD dy = 20;
        DWORD dwHeight;

        g_bitfont.GetTextStringLength( NULL, &dwHeight, NULL );
        dwHeight += 2;

        for( int iBuf = 0; iBuf < m_iLine; iBuf++ )
        {
            if( fDebug )
                dprintf( "%s\n", m_rgText[iBuf] );

            if( m_rgText[iBuf][0] )
                g_bitfont.DrawText( pFrontBuffer, m_rgText[iBuf], dx, dy, 
                                    0, 0xff9f9f9f, 0 );

            dy += dwHeight;
        }

        RELEASE( pFrontBuffer );
    }
}




//----------------------------------------------------------------------------
// Name: printf
//
// Desc: Add a string to the CScrText string buffer
//----------------------------------------------------------------------------
void _cdecl CScrText::printf( LPCSTR lpFmt, ... )
{
    va_list arglist;

    va_start( arglist, lpFmt );
    _vsnprintf( m_rgText[m_iLine], LINE_WIDTH, lpFmt, arglist );
    va_end( arglist );

	//7 sep 2001: prevent buffer overrun when printing text on the last line
	m_rgText[m_iLine][LINE_WIDTH - 1] = '\0'; 

    m_iLine = ( m_iLine + 1 ) % NUM_LINES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\utils.h ===
//----------------------------------------------------------------------------
// FILE: UTILS.H
//
// Desc: utils header file
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define ARRAYSIZE( _a )     ( sizeof( _a ) / sizeof( ( _a )[0] ) )




//----------------------------------------------------------------------------
// Release helper function
//----------------------------------------------------------------------------
template <class T> inline void RELEASE( T& punk )
{
    if( punk )
    {
        punk->Release();
        punk = NULL;
    }
}




//----------------------------------------------------------------------------
// Class to help time things
//----------------------------------------------------------------------------
class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() 
    {
    };

    void Start()
    { 
        frunning = true; 
        QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart); 
    }

    void Stop()
    { 
        frunning = false; 
        QueryPerformanceCounter((LARGE_INTEGER *)&ticksend); 
    }

    float getTime()
    {
        if( frunning )
            QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
        return ( ( ticksend - ticksstart ) * 1.0f / ticksPerSecond );
    }

    bool frunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};




//----------------------------------------------------------------------------
// Screen Text helper class
//----------------------------------------------------------------------------
class CScrText
{
public:
    CScrText()
    { 
        cls(); 
    }

    ~CScrText() 
    {
    }

    void cls()
    {
        m_iLine = 0;
        for( int i = 0; i < NUM_LINES; i++ )
            m_rgText[i][0] = 0;
    }

    void _cdecl printf( LPCSTR lpFmt, ... );

    void drawtext( bool fDebug );

private:
    enum 
    { 
        LINE_WIDTH = 80, 
        NUM_LINES = 40 
    };

    char m_rgText[NUM_LINES][LINE_WIDTH];
    int m_iLine;
};




// redefine these guys to make them shorter and remove the misleading D3DMULTISAMPLE_ part
#define D3DMS_NONE                                         D3DMULTISAMPLE_NONE
#define D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX               D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR      D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR
#define D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR        D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR
#define D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_PREFILTER_FORMAT_DEFAULT                     D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT
#define D3DMS_PREFILTER_FORMAT_X1R5G5B5                    D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5
#define D3DMS_PREFILTER_FORMAT_R5G6B5                      D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5
#define D3DMS_PREFILTER_FORMAT_X8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8
#define D3DMS_PREFILTER_FORMAT_A8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8




//----------------------------------------------------------------------------
// utils.cpp
bool IsLinearFormat( DWORD Format );
DWORD BitsPerPixelOfD3DFORMAT( DWORD Format );
LPCSTR GetD3DCMPStr( D3DCMPFUNC d3dcmpfunc );
LPCSTR GetD3DFormatStr( D3DFORMAT d3dformat );
LPCSTR GetMultiSampleStr( DWORD mstype );
LPCSTR GetTextureModeStr( DWORD TextureMode );




//----------------------------------------------------------------------------
void DisplayError( const char *szCall, HRESULT hr );

#define CheckHR( x ) { HRESULT _hr = ( x ); if ( FAILED( _hr ) ) { DisplayError( #x, _hr ); } }

void _cdecl dprintf( LPCSTR lpFmt, ... );

//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\vstune.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: vertex shader tuning app
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <d3d8perf.h>
#include <stdio.h>
#include <assert.h>




// With the profile build we can spew out how much time
// was spent in pushbuffer waits. However you must link
// with d3d8i.lib so it's off by default.
#define PROFILE     0

#include "utils.h"
#include "inifile.h"
#include "vstune.h"




//----------------------------------------------------------------------------
// globals
IDirect3DDevice8       *g_pDev = NULL;                  // our device
IDirect3DVertexBuffer8 *g_pVB[16] = {NULL};             // stream vertex buffers
IDirect3DTexture8      *g_pTextures[4] = { NULL };

DWORD                  *g_pAlloc = NULL;                // a random WC allocation
const int               g_AllocSize = 1024*1024;        // random allocation size

DWORD                   g_dwVertexShader;               // vertex shader handle

DWORD                   g_dwFVFSize[16];                // FVF sizes for each stream

WORD                   *g_pindices = NULL;              // out indices

HANDLE                  g_hInpDevice = NULL;            // input device

CScrText                g_scrtext;                      // text helper
CIniFile                g_inifile("d:\\vstune.ini");    // Ini file

bool                    g_fRedrawScreen = true;         // refresh screen?
volatile bool           g_gpudrawingdone = false;       // is the gpu done drawing?

VSTSETTINGS             g_var = {0};                    // current settings

DWORD                   g_Declaration[MAX_FVF_DECL_SIZE]; // vertex shader declaration
DWORD                   g_nvclk = 233;

HANDLE                  g_hThread = NULL;

D3DPERF                 *g_pPerf;

bool                    g_noINIFile = true;


struct
{
    LPCSTR szDesc;
    void (*pfnTest)();
} g_rgTests[] =
{
    { "Current",                DoQuickTimedTest },
    { "PushBuffer Call Test",   DoPushBufferCallTest },
};
UINT g_iCurTest = 0;




//----------------------------------------------------------------------------
// Name: InitD3D
//
// Desc: Init Direct3d
//----------------------------------------------------------------------------
bool InitD3D()
{
    static D3DPRESENT_PARAMETERS d3dppCur = {0};
    D3DPRESENT_PARAMETERS d3dpp = {0};

    // Set the screen mode.
    d3dpp.BackBufferWidth                   = UINT(g_var.screenwidth);
    d3dpp.BackBufferHeight                  = UINT(g_var.screenheight);
    d3dpp.BackBufferFormat                  = g_var.BackBufferFormat;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.EnableAutoDepthStencil            = !!g_var.AutoDepthStencilFormat;
    d3dpp.AutoDepthStencilFormat            = g_var.AutoDepthStencilFormat;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz        = 60;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.Flags                             = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

    if( g_var.MSType != D3DMULTISAMPLE_NONE )
        d3dpp.MultiSampleType = ( D3DMULTISAMPLE_TYPE )
                                ( (DWORD)( g_var.MSType) | (DWORD)( g_var.MSFormat ) );

    // if nothing has changed - don't reinit
    if( !memcmp( &d3dppCur, &d3dpp, sizeof( D3DPRESENT_PARAMETERS ) ) )
        return true;

    d3dppCur = d3dpp;

    if( g_pDev )
    {
        for( int itex = 0; itex < 4; itex++ )
            RELEASE( g_pTextures[itex] );

        if( g_dwVertexShader )
        {
            g_pDev->SetVertexShader( D3DFVF_XYZ );
            g_pDev->DeleteVertexShader( g_dwVertexShader );
            g_dwVertexShader = 0;
        }

        // make sure everything is freed
        for( int ivb = 0; ivb < ARRAYSIZE( g_pVB ); ivb++ )
            RELEASE( g_pVB[ivb] );

        RELEASE( g_pDev );
    }

    // Create the device.
    if FAILED( Direct3D_CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
        NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDev ) )
    {
        CheckHR( E_FAIL );
        return false;
    }

    for( int itex = 0; itex < 4; itex++ )
    {
        CheckHR( g_pDev->CreateTexture( 4, 4, 1, 0, D3DFMT_A4R4G4B4,
            D3DPOOL_MANAGED, &g_pTextures[itex] ) );
    }

    g_nvclk = GetNVCLK();
    dprintf( "gpu clk: %d\n", g_nvclk );

    return true;
}




//----------------------------------------------------------------------------
// Name: VSDGetTokenType
//
// Desc: Quick routine to return token type from decl
//----------------------------------------------------------------------------
inline DWORD VSDGetTokenType( DWORD dwDecl )
{
    return ( dwDecl & D3DVSD_TOKENTYPEMASK ) >> D3DVSD_TOKENTYPESHIFT;
}




//----------------------------------------------------------------------------
// Name: VSDGetDataType
//
// Desc: return data type from decl
//----------------------------------------------------------------------------
inline DWORD VSDGetDataType( DWORD dwDecl )
{
    return ( dwDecl & D3DVSD_DATATYPEMASK ) >> D3DVSD_DATATYPESHIFT;
}




//----------------------------------------------------------------------------
// Name: VSDGetSkipCount
//
// Desc: Get skip count from decl
//----------------------------------------------------------------------------
inline DWORD VSDGetSkipCount( DWORD dwDecl )
{
    return ( dwDecl & D3DVSD_SKIPCOUNTMASK ) >> D3DVSD_SKIPCOUNTSHIFT;
}




//----------------------------------------------------------------------------
// Name: dwBytesForStreamData
//
// Desc: Given a D3DVSD_TOKEN_STREAMDATA return # of bytes it requires
//----------------------------------------------------------------------------
DWORD dwBytesForStreamData( DWORD dwDecl )
{
    if( dwDecl & 0x08000000 )
    {
        // D3DVSD_SKIPBYTES
        return VSDGetSkipCount( dwDecl );
    }
    else if( dwDecl & 0x10000000 )
    {
        // D3DVSD_SKIP DWORDS
        return VSDGetSkipCount( dwDecl ) * sizeof( DWORD );
    }
    else
    {
        DWORD dwType = VSDGetDataType( dwDecl );
        DWORD dwCount = ( dwType >> 4 ) & 0xf;

        switch( dwType & 0xf )
        {
            case 0x0:   // D3DCOLOR
                return dwCount * sizeof( BYTE );

            case 0x2:   // float
                return dwCount * sizeof( float );

            case 0x1:   // NORMSHORT
            case 0x5:   // short
                return dwCount * sizeof( short );

            case 0x6:   // NORMPACKED
                return dwCount * sizeof( DWORD );

            case 0x4:   // PBYTE
                return dwCount * sizeof( BYTE );
        }
    }

    return 0;
}




//----------------------------------------------------------------------------
// Name: GetDeclVertexSize
//
// Desc: Return vert size for specific stream in declaration
//----------------------------------------------------------------------------
DWORD GetDeclVertexSize( DWORD dwStream, DWORD *pDecl )
{
    DWORD dwBytes = 0;
    DWORD dwCurStream = ( DWORD ) - 1;

    while( *pDecl != D3DVSD_END() )
    {
        if( VSDGetTokenType( *pDecl ) == D3DVSD_TOKEN_STREAM )
        {
            dwCurStream = *pDecl & D3DVSD_STREAMNUMBERMASK;
        }
        else if( dwCurStream == dwStream &&
            VSDGetTokenType( *pDecl ) == D3DVSD_TOKEN_STREAMDATA )
        {
            dwBytes += dwBytesForStreamData( *pDecl );
        }

        pDecl++;
    }

    return dwBytes;
}




//----------------------------------------------------------------------------
// Name: CreateIB
//
// Desc: Create our index buffer
//----------------------------------------------------------------------------
void CreateIB()
{
    if( g_pindices )
    {
        delete [] g_pindices;
        g_pindices = NULL;
    }

    if( g_var.pushbuffernops )
        g_var.TriCount = g_var.indexcount;
    else
    {
        switch( g_var.primitivetype )
        {
            case D3DPT_POINTLIST:
                g_var.TriCount = g_var.indexcount;
                break;

            case D3DPT_TRIANGLELIST:
                g_var.indexcount = ( g_var.indexcount / 3 ) * 3;
                g_var.TriCount = g_var.indexcount / 3;
                break;

            case D3DPT_TRIANGLESTRIP:
            case D3DPT_TRIANGLEFAN:
                g_var.TriCount = g_var.indexcount - 2;
                break;

            case D3DPT_QUADLIST:
                g_var.indexcount = ( g_var.indexcount / 4 ) * 4;
                g_var.TriCount = g_var.indexcount / 2;
                break;

            case D3DPT_QUADSTRIP:
                g_var.indexcount = ( g_var.indexcount / 2 ) * 2;
                g_var.TriCount = ( g_var.indexcount / 2 - 1 ) * 2;
                break;

            case D3DPT_POLYGON:
            case D3DPT_LINELIST:
            case D3DPT_LINELOOP:
            case D3DPT_LINESTRIP:
            default:
                g_var.TriCount = g_var.indexcount;
                _asm int 3;
                break;
        }
    }

    // create our index buffer
    g_pindices = new WORD [g_var.indexcount];

    WORD *pindices = g_pindices;
    for( UINT ivert = 0; ivert < g_var.indexcount; ivert++ )
    {
        *pindices++ = LOWORD( ivert % g_var.vertcount );
    }
}




//----------------------------------------------------------------------------
// Name: MyMemCpy
//
// Desc: Copy count of floats from src to dst
//----------------------------------------------------------------------------
inline float *MyMemCpy( float *dst, const float *src, int count )
{
    memcpy( dst, src, count * sizeof( float ) );
    return dst + count;
}




//----------------------------------------------------------------------------
// Name: CreateVB
//
// Desc: Create our vertex buffer for specific stream defined in g_pDeclaration
//----------------------------------------------------------------------------
void CreateVB( DWORD istream )
{
    RELEASE( g_pVB[istream] );

    if( !g_var.FVF )
    {
        // calculate stream size and length
        g_dwFVFSize[istream] = GetDeclVertexSize( istream, g_Declaration );

        UINT VBLength = g_dwFVFSize[istream] * g_var.vertcount;

        CheckHR( g_pDev->CreateVertexBuffer( VBLength, 0, 0, 0, &g_pVB[istream] ) );

        byte *pVerts;
        CheckHR( g_pVB[istream]->Lock( 0, VBLength, (BYTE **)&pVerts, 0 ) );

        // Fill it up.
        memset( pVerts, 0x11, VBLength );

        CheckHR( g_pVB[istream]->Unlock( ) );
    }
    else
    {
        g_dwFVFSize[istream] = D3DXGetFVFVertexSize( g_var.FVF );

        UINT VBLength = g_dwFVFSize[istream] * g_var.vertcount;

        CheckHR( g_pDev->CreateVertexBuffer( VBLength, 0, 0, 0, &g_pVB[istream] ) );

        float *pVerts;
        CheckHR( g_pVB[istream]->Lock( 0, VBLength, (BYTE **)&pVerts, 0 ) );

        int dy = 0;
        int iIndex = 0;
        D3DXVECTOR4 tex0( 0, 0, 0, 1.0f );
        D3DXVECTOR4 pos( -2000, -2000, .5f, 1.0f );
        D3DXVECTOR3 norm( 0, .707f, .707f );
        DWORD diffuse = D3DCOLOR_COLORVALUE( tex0.x, tex0.y, 1.0f - tex0.x, 2.0f / 
                                             0xff );

        for( UINT ivert = 0; ivert < g_var.vertcount; ivert++ )
        {
            if( !g_var.degenerates )
            {
                static float xval = 4.0f;
                static float yval = 4.0f;

                pos.x = xval * ( iIndex / 2 );
                pos.y = dy + yval * ( iIndex & 0x1 );

                // if we're not doing just degenerate tris then move along
                // in a nice little grid pattern
                iIndex++;

                if( pos.x + xval > g_var.screenwidth ) 
                {
                    iIndex = 0;
                    dy += int( yval ) + 1;
                }
            }

            if( g_var.FVF & D3DFVF_XYZRHW )
                pVerts = MyMemCpy(pVerts, pos, 4);
            else if( g_var.FVF & D3DFVF_XYZ )
                pVerts = MyMemCpy(pVerts, pos, 3);

            if( g_var.FVF & D3DFVF_NORMAL )
                pVerts = MyMemCpy(pVerts, norm, 3);

            if( g_var.FVF & D3DFVF_DIFFUSE )
                *(DWORD *)pVerts++ = diffuse;

            if( g_var.FVF & D3DFVF_SPECULAR )
                *(DWORD *)pVerts++ = ~diffuse;

            // Texture coordinates
            UINT uNumTexCoords = ( ( ( g_var.FVF ) & D3DFVF_TEXCOUNT_MASK ) 
                                   >> D3DFVF_TEXCOUNT_SHIFT );

            UINT uTextureFormats = g_var.FVF >> 16;

            if( uTextureFormats )
            {
                for( UINT i = 0; i < uNumTexCoords; i++ )
                {
                    switch( uTextureFormats & 3 )
                    {
                        case D3DFVF_TEXTUREFORMAT1:     // u
                            *pVerts++ = tex0.x;
                            break;

                        case D3DFVF_TEXTUREFORMAT2:     // u,v
                            pVerts = MyMemCpy( pVerts, tex0, 2 );
                            break;

                        case D3DFVF_TEXTUREFORMAT3:     // s,t,r
                            pVerts = MyMemCpy( pVerts, tex0, 3 );
                            break;

                        case D3DFVF_TEXTUREFORMAT4:     // s,t,r,q
                            pVerts = MyMemCpy( pVerts, tex0, 4 );
                            break;
                    }

                    uTextureFormats >>= 2;
                }
            }
            else while( uNumTexCoords-- )
            {
                // u,v
                pVerts = MyMemCpy( pVerts, tex0, 2 );
            }
        }

        CheckHR( g_pVB[istream]->Unlock( ) );
    }
}




//----------------------------------------------------------------------------
// Name: InitLights
//
// Desc: Initialize our lights
//----------------------------------------------------------------------------
void InitLights()
{
    // disable all our existing lights
    for( DWORD i = 0; i < g_var.NumLights; i++ )
        CheckHR( g_pDev->LightEnable( g_var.NumLights, FALSE ) );

    // get count of new lights
    g_var.NumLights =
        g_var.numDirectionalLights +
        g_var.numPointLights +
        g_var.numSpotLights;

    // setup lights
    float fIntensity = 1.0f / g_var.NumLights;
    D3DXCOLOR Diffuse( fIntensity, fIntensity, fIntensity, 1.0f );

    DWORD dwIndex = 0;
    for( i = 0; i < g_var.numDirectionalLights; i++ )
    {
        D3DLIGHT8 lig = { D3DLIGHT_DIRECTIONAL };

        lig.Diffuse     =  Diffuse;
        lig.Direction   =  D3DXVECTOR3( 0.2f, 0.3f, -0.8f );

        CheckHR( g_pDev->SetLight( dwIndex, &lig ) );
        CheckHR( g_pDev->LightEnable( dwIndex, TRUE ) );
        dwIndex++;
    }

    for( i = 0; i < g_var.numPointLights; i++ )
    {
        D3DLIGHT8 lig = { D3DLIGHT_POINT };

        lig.Diffuse      =  Diffuse;
        lig.Position     =  D3DXVECTOR3( 0.0f, 0.0f, 5.0f );
        lig.Range        = 9999.0f;
        lig.Attenuation0 = 1.0f;

        CheckHR( g_pDev->SetLight( dwIndex, &lig ) );
        CheckHR( g_pDev->LightEnable( dwIndex, TRUE ) );
        dwIndex++;
    }

    for( i = 0; i < g_var.numSpotLights; i++ )
    {
        D3DLIGHT8 lig = { D3DLIGHT_SPOT };

        lig.Diffuse      = Diffuse;
        lig.Position     = D3DXVECTOR3( -1.0f, -5.0f, 6.0f );
        lig.Direction    = D3DXVECTOR3( 0.1f, 0.5f, -0.6f );
        lig.Range        = 999.0f;
        lig.Theta        = 0.1f;
        lig.Phi          = 0.5f;
        lig.Falloff      = 1.0f;
        lig.Attenuation0 = 1.0f;

        CheckHR(g_pDev->SetLight( dwIndex, &lig ) );
        CheckHR(g_pDev->LightEnable( dwIndex, TRUE ) );
        dwIndex++;                                 
    }
}




//----------------------------------------------------------------------------
// Name: InitVST
//
// Desc: Initialize fillrate app
//----------------------------------------------------------------------------
bool InitVST( bool freadINIFile )
{
    if( freadINIFile && !ReadVSTIniFile() )
        dprintf( "%s not found", g_inifile.GetFileName() );

    // init d3d
    if( !InitD3D() )
    {
        dprintf( "InitD3D failed.\n" );
        return false;
    }

    // init our render states
    CheckHR( g_pDev->SetRenderState( D3DRS_LIGHTING, g_var.lighting ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_SPECULARENABLE, 
                                     g_var.specularenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_LOCALVIEWER, g_var.localviewer ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_NORMALIZENORMALS, 
                                     g_var.normalizenormals ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_COLORVERTEX, g_var.colorvertex ) );

    static DWORD dwMatSource = D3DMCS_COLOR1;
    CheckHR( g_pDev->SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE,  
                                     dwMatSource ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_SPECULARMATERIALSOURCE, 
                                     dwMatSource ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_AMBIENTMATERIALSOURCE,  
                                     dwMatSource ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_EMISSIVEMATERIALSOURCE, 
                                     dwMatSource ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_FOGENABLE, g_var.fogenable ) );

    // z buffer
    CheckHR( g_pDev->SetRenderState( D3DRS_ZENABLE, g_var.zenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ZWRITEENABLE, g_var.zwriteenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ZFUNC, g_var.d3dcmpfunc ) );

    // alpha blending
    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHABLENDENABLE, 
                                     g_var.alphablendenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) );

    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHATESTENABLE, 
                                     g_var.alphatestenable ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_ALWAYS ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_ALPHAREF, 0x00000001 ) );

    // fill and cull mode
    CheckHR( g_pDev->SetRenderState( D3DRS_FILLMODE, g_var.d3dfillmode ) );
    CheckHR( g_pDev->SetRenderState( D3DRS_CULLMODE, g_var.cullmode ) );

    // initialize lights
    InitLights();

    // initialize vertex shader or FVF declaration
    InitVertexShader();

    // set up texture stages
    for( DWORD itex = 0; itex < 4; itex++ )
    {
        if( itex < g_var.numtextures )
        {
            CheckHR( g_pDev->SetTexture( itex, g_pTextures[itex] ) );
                     
            CheckHR( g_pDev->SetTextureStageState( 0, D3DTSS_COLORARG1,
                                                   D3DTA_TEXTURE ) );
            CheckHR( g_pDev->SetTextureStageState( 0, D3DTSS_COLOROP,  
                                                   D3DTOP_MODULATE ) );
            CheckHR( g_pDev->SetTextureStageState( 0, D3DTSS_COLORARG2,
                                                   D3DTA_DIFFUSE ) );

            CheckHR( g_pDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1,
                                                   D3DTA_TEXTURE ) );
            CheckHR( g_pDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,  
                                                   D3DTOP_MODULATE ) );
            CheckHR( g_pDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2,
                                                   D3DTA_DIFFUSE ) );
        }
        else
        {
            CheckHR( g_pDev->SetTexture( itex, NULL ) );

            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_COLOROP, 
                                                   D3DTOP_DISABLE ) );
            CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ALPHAOP, 
                                                   D3DTOP_DISABLE ) );
        }

        CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ADDRESSU, 
                                               D3DTADDRESS_CLAMP ) );
        CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_ADDRESSV, 
                                               D3DTADDRESS_CLAMP ) );

        CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MINFILTER, 
                                               D3DTEXF_LINEAR ) );
        CheckHR( g_pDev->SetTextureStageState( itex, D3DTSS_MAGFILTER, 
                                               D3DTEXF_LINEAR ) );
    }                                                                                   

    // create our index buffer
    CreateIB();

    // create all our vertex buffer streams
    for( DWORD istream = 0; istream < g_var.NumStreams; istream++ )
        CreateVB( istream );

    // Initialize our VAB entries so we have consistent and unique values
    for( DWORD Register = 0; Register < 16; Register++ )
    {
        float val = (float)Register;

        g_pDev->SetVertexData4f( Register,
            val + .1f, val + .2f, val + .3f, val + .4f );
    }

    // if we're not writing stuff in the background then suspend our thread
    if( g_var.wcwritesinbkgnd != 2 )
        SuspendThread( g_hThread );
    else
    {
        while( ResumeThread( g_hThread ) > 1 )
            ;
    }

    return true;
}




//----------------------------------------------------------------------------
// Name: ClearScreen
//
// Desc: clear surface
//----------------------------------------------------------------------------
void ClearScreen()
{
    // clear stuff
    DWORD dwCFlags = g_var.clearflags;

    if( !g_var.AutoDepthStencilFormat )
        dwCFlags &= ~( D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL );

    CheckHR( g_pDev->Clear( 0, NULL, dwCFlags, g_var.cclearval,
                            g_var.zclearval, g_var.sclearval ) );
}




//----------------------------------------------------------------------------
// Name: InitFrame
//
// Desc: Initialize the vertex shader and stream source(s)
//----------------------------------------------------------------------------
void InitFrame()
{
    CheckHR( g_pDev->SetVertexShader( g_dwVertexShader ) );

    for( DWORD istream = 0; istream < g_var.NumStreams; istream++ )
        CheckHR( g_pDev->SetStreamSource( istream, g_pVB[istream], 
                                          g_dwFVFSize[istream] ) );
}




//----------------------------------------------------------------------------
// Name: RenderFrame
// Desc: Render the vertices x times
//----------------------------------------------------------------------------
void RenderFrame( int vbdrawcount, BOOL nops )
{
    if( nops )
    {
        while( vbdrawcount-- )
        {
            for( DWORD index = 0; index < g_var.indexcount; index++ )
                D3DDevice_Nop();
        }
    }
    else
    {
        while( vbdrawcount-- )
        {
            CheckHR( g_pDev->DrawIndexedVertices( g_var.primitivetype, 
                                                  g_var.indexcount, 
                                                  g_pindices ) );
        }
    }
}




//-----------------------------------------------------------------------------
// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.24f

//-----------------------------------------------------------------------------
// Global instance of input states
XINPUT_STATE g_InputStates[4];




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};

//-----------------------------------------------------------------------------
// Global instance of custom gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_InputStates[i], sizeof(XINPUT_STATE) );
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( )
{
    XBGAMEPAD *pGamepads = g_Gamepads;

    // TCR 3-21 Controller Discovery
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
            pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( pGamepads[i].hDevice, &pGamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XInputGetState( pGamepads[i].hDevice, &g_InputStates[i] );

            // Copy gamepad to local structure
            memcpy( &pGamepads[i], &g_InputStates[i].Gamepad, sizeof(XINPUT_GAMEPAD) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            pGamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            pGamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            pGamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            pGamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] > XINPUT_GAMEPAD_MAX_CROSSTALK );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FButtonDown
//
// Desc: Check if button is pressed.
//-----------------------------------------------------------------------------
bool FButtonDown( DWORD button )
{
    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // If we have a valid device, poll it's state and track button changes
        if( g_Gamepads[i].hDevice && g_Gamepads[i].bPressedAnalogButtons[button] )
            return true;
    }

    return false;
}




//-----------------------------------------------------------------------------
// Name: ChkButtonDown
//
// Desc: Check if non-analog button is pressed.
//-----------------------------------------------------------------------------
bool ChkButtonDown( DWORD button )
{
    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // If we have a valid device, poll it's state and track button changes
        if( g_Gamepads[i].hDevice && g_Gamepads[i].wPressedButtons & button )
            return true;
    }

    return false;
}




//-----------------------------------------------------------------------------
// Name: ChkReboot
//
// Desc: Check if they hit the magic reboot sequence
//-----------------------------------------------------------------------------
bool ChkReboot( void )
{
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // If we have a valid device, poll it's state and track button changes
        if( g_Gamepads[i].hDevice )
        {
            if( g_Gamepads[i].bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            {
                if( g_Gamepads[i].bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                {
                    if( g_Gamepads[i].bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_GAMEPAD_MAX_CROSSTALK )
                    {
                        return true;
                    }
                }
            }
        }
    }


    return false;
}




//----------------------------------------------------------------------------
// Name: Handle Input
//
// Desc: Handle gamepad input
//----------------------------------------------------------------------------
void HandleInput( DWORD dwTicks )
{
    static BOOL fRunTestRightNow = FALSE;

    if( g_inifile.FileChanged() )
    {
        InitVST( true );

        fRunTestRightNow = g_var.runtestonreload;

        g_fRedrawScreen = true;
        g_noINIFile = false;
    }

    // If we don't have a device don't let them start any tests.
    // They're going to have to change their settings in fillrate.ini
    // and just try again.
    if( g_noINIFile )
    {
        InitD3D();
        g_scrtext.cls();
        g_scrtext.printf("\n");
        g_scrtext.printf("Please be sure INI file was copied to d: drive on Xbox.\n");
        g_scrtext.printf("No INI File or could not parse INI file.\nNothing I can do.");
        g_scrtext.printf("You can copy INI right now!  I restart when it changes!");

        return;
    }

    XBInput_GetInput();

    if( fRunTestRightNow || FButtonDown( XINPUT_GAMEPAD_A ) )
    {
        fRunTestRightNow = FALSE;

        // run current test
        g_rgTests[g_iCurTest].pfnTest();

        // draw one scene with current settings
        ClearScreen();
        InitFrame();
        RenderFrame( 1 );

        // flip that dude to the front
        CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

        // plaster our results on the front buffer
        g_scrtext.drawtext( g_var.verboselevel >= 1 );
        g_fRedrawScreen = false;
    }

    if( FButtonDown( XINPUT_GAMEPAD_LEFT_TRIGGER ) )
    {
        g_iCurTest = ( g_iCurTest + ARRAYSIZE( g_rgTests ) - 1 ) % 
                       ARRAYSIZE( g_rgTests );
        g_fRedrawScreen = true;
    }

    if( FButtonDown( XINPUT_GAMEPAD_RIGHT_TRIGGER ) )
    {
        g_iCurTest = ( g_iCurTest + 1 ) % ARRAYSIZE( g_rgTests );
        g_fRedrawScreen = true;
    }

    if ( ChkButtonDown( XINPUT_GAMEPAD_BACK ) )
    {
        g_fRedrawScreen = true;
    }

    // Handle special input combo to trigger a reboot to the Xbox Dashboard
    if( ChkReboot() )
    {
        LD_LAUNCH_DASHBOARD LaunchData = { XLD_LAUNCH_DASHBOARD_MAIN_MENU };
        XLaunchNewImage( NULL, (LAUNCH_DATA*)&LaunchData );
    }
}




//----------------------------------------------------------------------------
// Name: szGetPTType
//
// Desc: Returns string with name of primitive type of stream
//----------------------------------------------------------------------------
const char *szGetPTType( DWORD pt )
{
    static const char *rgszD3DPT[] =
    {
        "D3DPT_0",
        "D3DPT_POINTLIST",
        "D3DPT_LINELIST",
        "D3DPT_LINELOOP",
        "D3DPT_LINESTRIP",
        "D3DPT_TRIANGLELIST",
        "D3DPT_TRIANGLESTRIP",
        "D3DPT_TRIANGLEFAN",
        "D3DPT_QUADLIST",
        "D3DPT_QUADSTRIP",
        "D3DPT_POLYGON",
        "D3DPT_?",
    };

    return rgszD3DPT[min( pt, ARRAYSIZE( rgszD3DPT ) )];
}




//----------------------------------------------------------------------------
// Name: DoPushBufferCallTest
//
// Desc: Do a series of pushbuffer calls w/ varying pushbuffer sizes
//----------------------------------------------------------------------------
void DoPushBufferCallTest()
{
    // clear screen text
    g_scrtext.cls();

    g_var.vbdrawcount = 1;
    g_var.framesperpushbuffermax = 1;

    DumpCurrentSettings();

    char szIndices[256];
    static const char *szDefIndices =
        "50, 100, 250, 500, 1000, 1500, 2000, 2500, 5000, 10000, 20000, 40000";

    g_inifile.GetIniStrBuf( "pushbuffercalltest", "indices",
        szDefIndices, szIndices, sizeof( szIndices ) );

    dprintf( "** PushBufferCallTest (%s) **\n", szIndices );

    static const char *rgHdrsNops[2] =
        { "Mnops", "cycles/nop" };
    static const char *rgHdrsIndices[2] =
        { "Mtps", "cycles/vert" };
    const char **rgHdrs = g_var.pushbuffernops ? rgHdrsNops : rgHdrsIndices;
    char *sizehdr = g_var.precompiled ? "pushbufsize" : "# indices";

    g_scrtext.printf( "%-12s %-7s %-7s %-10s(%d)"
#if PROFILE
        " waits waittime(ms)"
#endif
        , sizehdr,
        rgHdrs[0], rgHdrs[1], "throughput", g_var.wcwritesinbkgnd );

    char *token;
    const char seps[]   = " ,\t";
    token = strtok( szIndices, seps );
    while( token )
    {
        g_var.indexcount = atoi( token );

        if( g_var.verboselevel >= 1 )
            dprintf( "%d ", g_var.indexcount );

        if( g_var.indexcount )
        {
            InitVST( false );

            TIMETESTRESULTS ttres = {0};
            DoTimedTest( &ttres );

            g_scrtext.printf( "%11d %6.2f  %12.2f %10.2f"
#if PROFILE
                " %8d-%.2f"
#endif
                , g_var.precompiled ? ttres.pushbuffersize : g_var.indexcount,
                ttres.mtps, ttres.cycles, ttres.throughput,
                ttres.PushBufferWaitInfo.Count,
                (double)( ttres.PushBufferWaitInfo.Cycles / 733 ) / 1000.0 );
        }

        token = strtok( NULL, seps );
    }

    dprintf( "\n\n" );
    g_scrtext.printf( "" );
    g_scrtext.printf( "Button (A) - Run '%s' test again.", 
                      g_rgTests[g_iCurTest].szDesc );
    g_scrtext.printf( "Button (BACK) - Return to VSTune Main Screen." );

    // restore our settings
    InitVST( true );
}




//----------------------------------------------------------------------------
// Name: DoQuickTimedTest
// 
// Desc: Do a quick test with the current settings
//----------------------------------------------------------------------------
void DoQuickTimedTest()
{
    static DWORD testnum = 0;
    dprintf( "\n*** test #%ld ***\n", ++testnum );

    // clear screen text
    g_scrtext.cls();

    // run test
    TIMETESTRESULTS ttres = {0};
    DoTimedTest( &ttres );

    DumpCurrentSettings();

    g_scrtext.printf( "" );

    // if we did the wc writes in the background spew the results
    if( g_var.wcwritesinbkgnd )
    {
        g_scrtext.printf( "writer thread:  %s",
            ( g_var.wcwritesinbkgnd == 1 ) ? "main" : "low prio bkgnd" );
        g_scrtext.printf( "bytes written:  %lu", ttres.byteswritten );
        g_scrtext.printf( "throughput:     %.2f MB/s", ttres.throughput );
        g_scrtext.printf( "" );
    }

    g_scrtext.printf( "pushbuffercalls:%d", ttres.pushbuffercalls );
    g_scrtext.printf( "pushbuffersize :%d", ttres.pushbuffersize );

#if PROFILE
    g_scrtext.printf( "pushbufferwaits:%d",   ttres.PushBufferWaitInfo.Count );
    g_scrtext.printf( "pshbfwaittime:%.2fms", 
                      (double)( ttres.PushBufferWaitInfo.Cycles / 733 ) / 1000.0 );
#endif

    // print out results
    g_scrtext.printf( "" );

    g_scrtext.printf( "fps:            %.2f     frames:         %d",     
                      ttres.fps, ttres.cFrames );
    g_scrtext.printf( "time:           %.2fms",   ttres.TimeTillIdle );

    if( g_var.pushbuffernops )
    {
        g_scrtext.printf( "nops:           %I64u     Mnops:          %.2f",    
                          ttres.cTrisDrawn, ttres.mtps );
        g_scrtext.printf( "cycles/nop:     %.2f",     ttres.cycles );
    }
    else
    {
        g_scrtext.printf( "triangles:      %I64u     Mtps:           %.2f",    
                          ttres.cTrisDrawn, ttres.mtps );
        g_scrtext.printf( "cycles/vert:    %.2f",     ttres.cycles );
    }

    g_scrtext.printf( "" );
    g_scrtext.printf( "Button (A) - Run '%s' test again.", 
                      g_rgTests[g_iCurTest].szDesc );
    g_scrtext.printf( "Button (BACK) - Return to VSTune Main Screen." );

}




//----------------------------------------------------------------------------
// Name: MyStrCpy
//
// Desc: Copies string src to dst
//----------------------------------------------------------------------------
inline char *MyStrCpy( char *dst, const char *src )
{
    while( *src && ( *dst++ = *src++ ) )
        ;

    return dst;
}




//----------------------------------------------------------------------------
// Name: SzGetDeclDescr
//
// Desc: Return a static char buffer with stream declaration
//----------------------------------------------------------------------------
const char *SzGetDeclDescr( DWORD dwStream, DWORD *pDecl )
{
    static char szBuf[128];
    DWORD dwBytes = 0;
    DWORD dwCurStream = ( DWORD ) - 1;

    char *psz = szBuf;

    while( *pDecl != D3DVSD_END() )
    {
        if( VSDGetTokenType( *pDecl ) == D3DVSD_TOKEN_STREAM )
        {
            dwCurStream = *pDecl & D3DVSD_STREAMNUMBERMASK;
        }
        else if( dwStream == dwCurStream &&
            VSDGetTokenType( *pDecl ) == D3DVSD_TOKEN_STREAMDATA )
        {
            static const char rgReg[] = "0123456789abcdef";

            if( psz != szBuf )
                *psz++ = ',';

            if( *pDecl & 0x18000000 )
            {
                psz = MyStrCpy(psz, ( *pDecl & 0x08000000) ? 
                                                "x:BYTES" : "x:DWRDS" );
                *psz++ = char( '0' + VSDGetSkipCount( *pDecl ) );
            }
            else
            {
                static const char *rgType[] =
                    { "CLR", "NRMSHRT", "FLT", "?", "PBYTE", 
                      "SHRT", "NRMPCKD", "??" };

                DWORD dwType = VSDGetDataType( *pDecl );
                DWORD dwCount = ( dwType >> 4 ) & 0xf;

                *psz++ = char( rgReg[*pDecl & 0xf] );
                *psz++ = ':';

                psz = MyStrCpy( psz, rgType[min( dwType & 0xf, 
                                                 ARRAYSIZE( rgType ) )] );
                *psz++ = char( '0' + dwCount );
            }
        }

        pDecl++;
    }

    *psz = 0;
    return szBuf;
}




//----------------------------------------------------------------------------
// Name: DumpCurrentSettings
//
// Desc: Dump the current options
//----------------------------------------------------------------------------
void DumpCurrentSettings()
{
    if( g_var.pushbuffernops )
    {
        g_scrtext.printf( "" );
        g_scrtext.printf( "precompiled:    %d (w/ Kelvin nops)", 
                          g_var.precompiled );
        g_scrtext.printf( "runusingcpucopy:%d", g_var.runusingcpucopy );
        g_scrtext.printf( "nop count:      %d * %d", g_var.indexcount, 
                          g_var.vbdrawcount );
    }
    else
    {
        DWORD dwFVFSizeTot = 0;

        for( DWORD istream = 0; istream < g_var.NumStreams; istream++ )
            dwFVFSizeTot += g_dwFVFSize[istream];

        g_scrtext.printf( "" );
        g_scrtext.printf( "type:          %s", 
                          szGetPTType( g_var.primitivetype ) );

        g_scrtext.printf( "precompiled:   %d - %d pushbuffer(s)",
                          g_var.precompiled, g_var.numberofpushbuffers );

        g_scrtext.printf( "runusingcpucopy: %d     vertshaderlen: %d", 
                          g_var.runusingcpucopy, g_var.uservertexshader );

        g_scrtext.printf( "vertcount:     %d     indexcount:    %d*%d", 
                          g_var.vertcount, g_var.indexcount, g_var.vbdrawcount );

        g_scrtext.printf( "numtextures:   %d     FVF size:      %d bytes",
                          g_var.numtextures, dwFVFSizeTot );

        for( DWORD istream = 0; istream < g_var.NumStreams; istream++ )
            g_scrtext.printf( "  stream % d:   %s", istream,
                              SzGetDeclDescr(istream, g_Declaration ) );

        #undef XTAG
        #define XTAG(_tag)    ((g_var. ## _tag) ? #_tag : "!" #_tag)

        // spew various render states
        g_scrtext.printf( "%s %s %s %s",
            XTAG( zenable ), XTAG( zwriteenable ),
            XTAG( alphablendenable ), XTAG( alphatestenable ) );

        g_scrtext.printf( "%s %s %s %s %s",
            XTAG( localviewer ), XTAG( specularenable ),
            XTAG( fogenable ), XTAG( normalizenormals ), XTAG( colorvertex ) );

        if( g_var.lighting )
        {
            g_scrtext.printf( "%s: directional:%d point:%d spot:%d", 
                              XTAG(lighting), g_var.numDirectionalLights, 
                              g_var.numPointLights, g_var.numSpotLights );
        }
        else
        {
            g_scrtext.printf( "%s", XTAG( lighting ) );
        }
    }
}




//----------------------------------------------------------------------------
// Name: EstimateTimeForScene
//
// Desc: Take a wild guess at the amount of time one scene will take
//----------------------------------------------------------------------------
float EstimateTimeForScene()
{
    CTimer timer;

    // clear the screen
    ClearScreen();
    CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

    InitFrame();

    // wait until everything is cleared out
    g_pDev->BlockUntilIdle();

    // start timing
    timer.Start();

    // draw one scene
    RenderFrame( g_var.vbdrawcount, g_var.pushbuffernops );

    // wait until GPU is idle again
    g_pDev->BlockUntilIdle();

    // stop timer
    timer.Stop();

    return timer.getTime();
}




//----------------------------------------------------------------------------
// helper struct used in PrecompiledCallback
struct GPUINFO
{
    CTimer *ptimer;
    DWORD byteswritten;
    DWORD bytes;
} g_gpuInfo;




//----------------------------------------------------------------------------
// Name: PrecompiledCallback
//
// Desc: Called back at DPC level when the test is done
//----------------------------------------------------------------------------
void __cdecl PrecompiledCallback( DWORD context )
{
    GPUINFO* pgpuInfo = (GPUINFO *)context;

    // stop the timer
    pgpuInfo->ptimer->Stop();

    // record how many bytes we've written
    pgpuInfo->byteswritten = pgpuInfo->bytes;

    g_gpudrawingdone = true;
}




//----------------------------------------------------------------------------
// Name: WaitOrWriteUntilIdle
//
// Desc: Block or do wc writes until GPU is idle
//----------------------------------------------------------------------------
void WaitOrWriteUntilIdle()
{
    DWORD batch = 0;

    g_pDev->InsertCallback( D3DCALLBACK_WRITE, PrecompiledCallback, 
                            (DWORD)&g_gpuInfo );
    g_pDev->KickPushBuffer();

    if( g_var.wcwritesinbkgnd == 1 )
    {
        // do some wc writes w/ the main thread while waiting
        while( !g_gpudrawingdone )
        {
            DWORD* pDst = g_pAlloc;

            batch = g_AllocSize / sizeof(DWORD);

            do {
                *pDst++ = g_gpuInfo.bytes;

                g_gpuInfo.bytes += 4;

            } while ( --batch != 0 );
        }
    }
    else
    {
        // wait until GPU is idle again
        g_pDev->BlockUntilIdle();
    }
}




//----------------------------------------------------------------------------
// Name: CreatePushBuffers
//
// Desc: Creates Push Buffers
//----------------------------------------------------------------------------
void CreatePushBuffers( IDirect3DPushBuffer8 *pPushbuffer[300], 
                        int numberscenes, DWORD *psize, 
                        int *pframesperpushbuffer )
{
    DWORD size;
    int framesperpushbuffer;
    const int MaxPushbufferSize = 32*1024*1024;

    // calculate pushbuffer size
    IDirect3DPushBuffer8 *pPushBufferT;
    CheckHR( g_pDev->CreatePushBuffer( MaxPushbufferSize, 
                                       g_var.runusingcpucopy, 
                                       &pPushBufferT ) );

    // render one frame - and get the size
    CheckHR( g_pDev->BeginPushBuffer( pPushBufferT ) );
    RenderFrame( g_var.vbdrawcount, g_var.pushbuffernops );
    CheckHR( g_pDev->GetPushBufferOffset( &size ) );

    // we're capped by the push-buffer size or the total frame count
    framesperpushbuffer = min( numberscenes, MaxPushbufferSize / (int)size );

    // cap the guy at the max # of frames allowed in our pushbuffer
    if( g_var.framesperpushbuffermax )
        framesperpushbuffer = min( g_var.framesperpushbuffermax, 
                                   (DWORD)framesperpushbuffer );

    // render the remaining frames in there
    for( int i = 1; i < framesperpushbuffer; i++ )
    {
        RenderFrame( g_var.vbdrawcount, g_var.pushbuffernops );
    }

    CheckHR( g_pDev->GetPushBufferOffset( &size ) );

    CheckHR( g_pDev->EndPushBuffer() );

    // cruise through and create X number of pushbuffers
    g_var.numberofpushbuffers = min( 300, max( 1, g_var.numberofpushbuffers ) );

    if( g_var.numberofpushbuffers == 1 )
    {
        pPushbuffer[0] = pPushBufferT;
        pPushBufferT = NULL;
    }
    else
    {
        for( DWORD ipushbuf = 0; 
                   ipushbuf < g_var.numberofpushbuffers; 
                   ipushbuf++ )
        {
            // create precompiled pushbuffer
            CheckHR( g_pDev->CreatePushBuffer( max( 512, size ) + sizeof(DWORD),
                     g_var.runusingcpucopy, &pPushbuffer[ipushbuf] ) );

            assert( pPushbuffer[ipushbuf]->AllocationSize >= pPushBufferT->Size );

            memcpy( (void *)pPushbuffer[ipushbuf]->Data,(void *)pPushBufferT->Data, 
                    pPushBufferT->Size );

            pPushbuffer[ipushbuf]->Size = pPushBufferT->Size;
        }
    }

    *psize = size;
    *pframesperpushbuffer = framesperpushbuffer;

    RELEASE(pPushBufferT);
}




//----------------------------------------------------------------------------
// Name: DoTimedTest
//
// Desc: Do a timed test and spit out the results
//----------------------------------------------------------------------------
float DoTimedTest( TIMETESTRESULTS *pttres )
{
    CTimer timer;
    int frames = 0;
    int visibilityindex = 0;
    float TimeTillDoneDrawing = 0;
    float TimeTillIdle = 0;
    UINT64 cIndicesDrawn = 0;
    UINT64 cTrisDrawn = 0;
    D3DWAITINFO *pPushBufferWaitInfo =
        &g_pPerf->m_PerformanceCounters[PERF_PUSHBUFFER_WAITS];

    // if there isn't an explicit count of scenes to render
    // guesstimate the time required for each scene
    float fEstimatedTimePerScene = EstimateTimeForScene();

    // and figure out how many scenes to render
    int numberscenes = int( g_var.testtime / fEstimatedTimePerScene );

    // put an upper cap and lower bound on the number of scenes
    numberscenes = max( 2, min( numberscenes, INT_MAX ) );

    // set up stream sources
    InitFrame();

    g_gpuInfo.ptimer = &timer;
    g_gpuInfo.byteswritten = 0;
    g_gpuInfo.bytes = 0;

    if( g_var.precompiled )
    {
        DWORD size;
        int framesperpushbuffer;
        static IDirect3DPushBuffer8 *pPushbuffer[300];

        // Create our pushbuffers
        CreatePushBuffers( pPushbuffer, numberscenes, &size, 
                           &framesperpushbuffer );

        int pushbuffercalls = ( numberscenes / framesperpushbuffer ) + 1;

        pPushBufferWaitInfo->Count = 0;
        pPushBufferWaitInfo->Cycles = 0;

        // wait until everything is cleared out
        g_pDev->BlockUntilIdle();

        // start timing
        timer.Start();
        g_gpudrawingdone = false;

        // render X number of scenes
        DWORD ipushbuf = 0;
        for( int pushbuffers = 0; pushbuffers < pushbuffercalls; pushbuffers++ )
        {
            CheckHR(g_pDev->RunPushBuffer( pPushbuffer[ipushbuf], NULL ) );

            if( ++ipushbuf >= g_var.numberofpushbuffers )
                ipushbuf = 0;
        }

        TimeTillDoneDrawing = timer.getTime();

        WaitOrWriteUntilIdle();

        TimeTillIdle = timer.getTime();

        frames = pushbuffercalls * framesperpushbuffer;
        cIndicesDrawn = (UINT64)pushbuffercalls * framesperpushbuffer * 
                                g_var.vbdrawcount * g_var.indexcount;
        cTrisDrawn = (UINT64)pushbuffercalls * framesperpushbuffer * 
                             g_var.vbdrawcount * g_var.TriCount;

        if( pttres )
        {
            pttres->pushbuffercalls = pushbuffercalls;
            pttres->pushbuffersize = size;
        }

        for( ipushbuf = 0; ipushbuf < g_var.numberofpushbuffers; ipushbuf++ )
            RELEASE( pPushbuffer[ipushbuf] );
    }
    else
    {
        pPushBufferWaitInfo->Count = 0;
        pPushBufferWaitInfo->Cycles = 0;

        // wait until everything is cleared out
        g_pDev->BlockUntilIdle();

        // start timing
        timer.Start();
        g_gpudrawingdone = false;

        // render X number of scenes
        for( frames = 0; frames < numberscenes; frames++ )
        {
            RenderFrame(g_var.vbdrawcount);
        }

        TimeTillDoneDrawing = timer.getTime();

        // wait until GPU is idle again
        WaitOrWriteUntilIdle();

        TimeTillIdle = timer.getTime();

        cIndicesDrawn = (UINT64)frames * g_var.vbdrawcount * g_var.indexcount;
        cTrisDrawn = (UINT64)frames * g_var.vbdrawcount * g_var.TriCount;
    }

    if( pttres )
    {
        pttres->fps = frames * 1000 / TimeTillIdle;
        pttres->cFrames = frames;
        pttres->TimeTillDoneDrawing = TimeTillDoneDrawing;
        pttres->TimeTillIdle = TimeTillIdle;
        pttres->cTrisDrawn = cTrisDrawn;
        pttres->mtps = (float)( pttres->cTrisDrawn / 
                              ( pttres->TimeTillIdle * 1000 ) );
        pttres->cycles = g_nvclk * pttres->TimeTillIdle * 1000.0f / cIndicesDrawn;

        pttres->byteswritten = g_gpuInfo.byteswritten;
        pttres->throughput = g_gpuInfo.byteswritten / ( TimeTillIdle * 1000.0f );
        pttres->PushBufferWaitInfo = *pPushBufferWaitInfo;
    }

    return pttres->fps;
}




//----------------------------------------------------------------------------
// macros to help read entries from the ini file
//----------------------------------------------------------------------------
static const char g_szOpts[] = "options";
#define get_option_val( _var )          g_inifile.GetIniInt( g_szOpts, #_var, g_var._var )
#define get_option_valf( _var )         g_inifile.GetIniFloat( g_szOpts, #_var, g_var._var )
#define get_option_val3( _s, _var, _d ) g_inifile.GetIniInt( _s, _var, _d )




//----------------------------------------------------------------------------
// Name: ReadVSTIniFile
//
// Desc: Read ini file and update all settings
//----------------------------------------------------------------------------
bool ReadVSTIniFile()
{
    if( !g_inifile.ReadFile() )
        return false;

    // read the verbose flag(s) first
    g_inifile.m_fverbose            = !!get_option_val3( g_szOpts, 
                                                         "verboseinireads", 
                                                         false );

    g_var.verboselevel              = get_option_val( verboselevel );

    // if the g_iCurTest entry exists, read it in
    if( g_inifile.IniEntryExists(g_szOpts, "g_iCurTest" ) )
        g_iCurTest = g_inifile.GetIniInt( g_szOpts, "g_iCurTest", g_iCurTest );

    g_var.runtestonreload           = !!get_option_val( runtestonreload );

    g_var.AutoDepthStencilFormat    = (D3DFORMAT)get_option_val( AutoDepthStencilFormat );
    g_var.BackBufferFormat          = (D3DFORMAT)get_option_val( BackBufferFormat );

    g_var.MSType                    = (D3DMULTISAMPLE_TYPE)get_option_val( MSType );
    g_var.MSFormat                  = (D3DMULTISAMPLE_TYPE)get_option_val( MSFormat );

    g_var.zenable                   = !!get_option_val( zenable );
    g_var.zwriteenable              = !!get_option_val( zwriteenable );
    g_var.d3dcmpfunc                = (D3DCMPFUNC)get_option_val( d3dcmpfunc );

    g_var.alphablendenable          = !!get_option_val( alphablendenable );
    g_var.alphatestenable           = !!get_option_val( alphatestenable );

    g_var.testtime                  = get_option_valf( testtime );
    g_var.vbdrawcount               = get_option_val( vbdrawcount );
    g_var.precompiled               = get_option_val( precompiled );
    g_var.framesperpushbuffermax    = get_option_val( framesperpushbuffermax );
    g_var.pushbuffernops            = g_var.precompiled ? get_option_val( pushbuffernops ) : 0;
    g_var.runusingcpucopy           = g_var.precompiled && !!get_option_val( runusingcpucopy );
    g_var.numberofpushbuffers       = get_option_val( numberofpushbuffers );
    g_var.wcwritesinbkgnd           = get_option_val( wcwritesinbkgnd );

    g_var.FVF                       = get_option_val( FVF );
    g_var.primitivetype             = (D3DPRIMITIVETYPE)get_option_val( primitivetype );
    g_var.indexcount                = get_option_val( indexcount );
    g_var.vertcount                 = get_option_val( vertcount );

    g_var.cullmode                  = (D3DCULL)get_option_val( cullmode );
    g_var.d3dfillmode               = (D3DFILLMODE)get_option_val( d3dfillmode );

    g_var.degenerates               = !!get_option_val( degenerates );

    g_var.clearflags                = get_option_val( clearflags );
    g_var.zclearval                 = get_option_valf( zclearval );
    g_var.sclearval                 = get_option_val( sclearval );
    g_var.cclearval                 = get_option_val( cclearval );

    static const char *szDefVertexShader = "None";

    g_inifile.GetIniStrBuf( "Options", "uservertexshader", szDefVertexShader, 
                            g_var.vertexShaderFileName, 1023 );

    if( memcmp( szDefVertexShader, g_var.vertexShaderFileName, 4 ) == 0)
        g_var.uservertexshader = 0;
    else
        g_var.uservertexshader = 1;

    g_var.colorvertex               = !!get_option_val( colorvertex );
    g_var.normalizenormals          = !!get_option_val( normalizenormals );
    g_var.fogenable                 = !!get_option_val( fogenable );

    g_var.localviewer               = !!get_option_val( localviewer );
    g_var.specularenable            = !!get_option_val( specularenable );

    g_var.lighting                  = !!get_option_val( lighting );
    g_var.numDirectionalLights      = get_option_val( numDirectionalLights );
    g_var.numPointLights            = get_option_val( numPointLights );
    g_var.numSpotLights             = get_option_val( numSpotLights );

    g_var.numtextures               = get_option_val( numtextures );

    // Read in the explicit declaration if we don't have an FVF code
    g_var.NumStreams = 1;
    if( !g_var.FVF )
    {
        char szStream[20];
        char szEntry[20];
        int idecl = 0;

        for( int istream = 0; istream < 15; istream++ )
        {
            wsprintfA( szStream, "stream%d", istream );
            if( !g_inifile.IniEntryExists( szStream, "Decl0" ) )
            {
                break;
            }
            else
            {
                g_Declaration[idecl++] = D3DVSD_STREAM( istream );

                for( int ientry = 0; ientry < 15; ientry++ )
                {
                    wsprintfA( szEntry, "Decl%d", ientry );
                    if( !g_inifile.IniEntryExists( szStream, szEntry ) )
                        break;

                    DWORD dwDecl = g_inifile.GetIniInt( szStream, szEntry, 0 );

                    if( dwDecl & 0x08000000 )
                        g_Declaration[idecl++] = D3DVSD_SKIPBYTES( LOWORD( dwDecl ) );
                    else if(dwDecl & 0x10000000)
                        g_Declaration[idecl++] = D3DVSD_SKIP( LOWORD( dwDecl ) );
                    else
                        g_Declaration[idecl++] = D3DVSD_REG( LOWORD( dwDecl ), HIWORD( dwDecl ) );
                }
            }
        }

        g_Declaration[idecl] = D3DVSD_END();

        g_var.NumStreams = istream;
    }

    return true;
}




//----------------------------------------------------------------------------
// Name: ThreadProc
//
// Desc: Background thread loop.
//----------------------------------------------------------------------------
DWORD WINAPI ThreadProc( LPVOID lpParameter )
{
    DWORD batch;

    for( ;; )
    {
        if( !g_gpudrawingdone )
        {
            DWORD* pDst = g_pAlloc;

            batch = g_AllocSize / sizeof(DWORD);

            do {
                *pDst++ = g_gpuInfo.bytes;

                g_gpuInfo.bytes += 4;

            } while ( --batch != 0 );
        }
    }

    return 0;
}




//----------------------------------------------------------------------------
// Name: main
//
// Desc:
//----------------------------------------------------------------------------
void __cdecl main()
{
    DWORD dwT = 0x418937;

    dprintf("TEST: %lu %lu\n", dwT * 1000 / 48000, (dwT + 1) * 1000 / 48000);
    
    g_hThread = CreateThread(NULL, 0, ThreadProc, 0, CREATE_SUSPENDED, NULL);
    SetThreadPriority(g_hThread, THREAD_PRIORITY_BELOW_NORMAL);

#if PROFILE
    g_pPerf = D3DPERF_GetStatistics();
#else
    static D3DPERF perf = {0};
    g_pPerf = &perf;
#endif

    XInitDevices( 0, NULL );
    XBInput_CreateGamepads();

    /*
     * init vars
     */
    g_var.screenwidth = 640.0f;
    g_var.screenheight = 480.0f;

    g_var.FVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;
    g_var.primitivetype = D3DPT_TRIANGLELIST;
    g_var.indexcount = 4998;
    g_var.vertcount = 27;

    g_var.cullmode = D3DCULL_NONE;

    g_var.degenerates = false;

    g_var.alphablendenable = false;
    g_var.alphatestenable = false;

    // default to drawing 10 seconds
    g_var.testtime = 10000.0f;
    g_var.vbdrawcount = 50;

    g_var.d3dfillmode = D3DFILL_SOLID;

    g_var.zenable = false;
    g_var.zwriteenable = false;

    g_var.d3dcmpfunc = D3DCMP_NOTEQUAL;

    g_var.BackBufferFormat = D3DFMT_A8R8G8B8;
    g_var.AutoDepthStencilFormat = D3DFMT_D24S8;

    g_var.clearflags = D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
    g_var.cclearval = 0x00006688;


    g_pAlloc = (DWORD*) XPhysicalAlloc(g_AllocSize, MAXULONG_PTR, 4096,
                                       PAGE_READWRITE | PAGE_WRITECOMBINE);

    CheckHR(g_pAlloc != NULL ? S_OK : E_OUTOFMEMORY);

    DWORD dwLastTickCount = GetTickCount();
    for( ;; )
    {
        DWORD dwTickCount = GetTickCount();
        DWORD dwTicks = dwTickCount - dwLastTickCount;

        dwLastTickCount = dwTickCount;

        HandleInput(dwTicks);

        if( g_pDev && !g_noINIFile)
        {
            if( g_fRedrawScreen )
            {
                ClearScreen();

                // draw back frame with current settings
                InitFrame();
                RenderFrame( 1 );

                // swap that guy to the front
                CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

                // display current options on front buffer
                g_scrtext.cls();

                g_scrtext.printf( "" );
                g_scrtext.printf( "Button (A) - Run '%s' test.", 
                                  g_rgTests[g_iCurTest].szDesc );
                g_scrtext.printf( "Right/Left Trigger - Cycle through tests." );
                g_scrtext.printf( "" );
                DumpCurrentSettings();
                g_scrtext.drawtext( g_var.verboselevel >= 1 );

                g_fRedrawScreen = false;
            }
            else
            {
                // 33.3 fps
                Sleep( 30 );
            }
        }
        else
        {
            //No INI file.
            // Display the help text telling them to copy one over!!
            if( g_fRedrawScreen )
            {
                // clear back buffer
                ClearScreen();

                // swap that guy to the front
                CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );

                // display current options on front buffer
                g_scrtext.drawtext( false );

                g_fRedrawScreen = false;
            }
        }
    }
}




//----------------------------------------------------------------------------
// Name: GetIniConstf
//
// Desc: Callback from inifile.cpp to get float string value
//----------------------------------------------------------------------------
bool GetIniConstf( const char *szStr, int cchStr, float *pval )
{
    return false;
}




//----------------------------------------------------------------------------
// Name: GetIniConst
//
// Desc: Callback from inifile.cpp to get int string value
//----------------------------------------------------------------------------
bool GetIniConst( const char *szStr, int cchStr, int *pval )
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        int Val;
        const char *szStr;
    } rgszConsts[] =
    {
        // D3DFORMATs
        XTAG( D3DFMT_A8R8G8B8 ), XTAG( D3DFMT_X8R8G8B8 ), 
        XTAG( D3DFMT_R5G6B5 ), XTAG( D3DFMT_R6G5B5 ), XTAG( D3DFMT_X1R5G5B5 ), 
        XTAG( D3DFMT_A1R5G5B5 ), XTAG( D3DFMT_A4R4G4B4 ), XTAG( D3DFMT_A8 ), 
        XTAG( D3DFMT_A8B8G8R8 ), XTAG( D3DFMT_B8G8R8A8 ), 
        XTAG( D3DFMT_R4G4B4A4 ), XTAG( D3DFMT_R5G5B5A1 ), 
        XTAG( D3DFMT_R8G8B8A8 ), XTAG( D3DFMT_R8B8 ), XTAG( D3DFMT_G8B8 ), 
        XTAG( D3DFMT_P8 ), XTAG( D3DFMT_L8 ), XTAG( D3DFMT_A8L8 ), 
        XTAG( D3DFMT_AL8 ), XTAG( D3DFMT_L16 ), XTAG( D3DFMT_V8U8 ), 
        XTAG( D3DFMT_L6V5U5 ), XTAG( D3DFMT_X8L8V8U8 ), 
        XTAG( D3DFMT_Q8W8V8U8 ), XTAG( D3DFMT_V16U16 ), 
        XTAG( D3DFMT_D16_LOCKABLE ), XTAG( D3DFMT_D16 ), 
        XTAG( D3DFMT_D24S8 ), XTAG( D3DFMT_F16 ), XTAG( D3DFMT_F24S8 ), 
        XTAG( D3DFMT_UYVY ), XTAG( D3DFMT_YUY2 ), XTAG( D3DFMT_DXT1 ), 
        XTAG( D3DFMT_DXT2 ), XTAG( D3DFMT_DXT3 ), XTAG( D3DFMT_DXT4 ),
        XTAG( D3DFMT_DXT5 ), XTAG( D3DFMT_LIN_A1R5G5B5 ), 
        XTAG( D3DFMT_LIN_A4R4G4B4 ), XTAG( D3DFMT_LIN_A8 ), 
        XTAG( D3DFMT_LIN_A8B8G8R8 ), XTAG( D3DFMT_LIN_A8R8G8B8 ), 
        XTAG( D3DFMT_LIN_B8G8R8A8 ), XTAG( D3DFMT_LIN_G8B8 ),
        XTAG( D3DFMT_LIN_R4G4B4A4 ), XTAG( D3DFMT_LIN_R5G5B5A1 ), 
        XTAG( D3DFMT_LIN_R5G6B5 ), XTAG( D3DFMT_LIN_R6G5B5 ),
        XTAG( D3DFMT_LIN_R8B8 ), XTAG( D3DFMT_LIN_R8G8B8A8 ), 
        XTAG( D3DFMT_LIN_X1R5G5B5 ), XTAG( D3DFMT_LIN_X8R8G8B8 ),
        XTAG( D3DFMT_LIN_A8L8 ), XTAG( D3DFMT_LIN_AL8 ), XTAG( D3DFMT_LIN_L16 ), 
        XTAG( D3DFMT_LIN_L8 ), XTAG( D3DFMT_LIN_D24S8 ), 
        XTAG( D3DFMT_LIN_F24S8 ), XTAG( D3DFMT_LIN_D16 ), XTAG( D3DFMT_LIN_F16 ),

        XTAG( D3DMULTISAMPLE_NONE ), 
        XTAG( D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX ), 
        XTAG( D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR ),
        XTAG( D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR ), 
        XTAG( D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN ), 
        XTAG( D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR ),
        XTAG( D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN ),
        XTAG( D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT ),
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5 ), 
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5 ),
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8 ), 
        XTAG( D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8 ),

        XTAG( D3DMS_NONE ), XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX ), 
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR ),
        XTAG( D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR ), 
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR ),
        XTAG( D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN ),
        XTAG( D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN ), 
        XTAG( D3DMS_PREFILTER_FORMAT_DEFAULT ),
        XTAG( D3DMS_PREFILTER_FORMAT_X1R5G5B5 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_R5G6B5 ),
        XTAG( D3DMS_PREFILTER_FORMAT_X8R8G8B8 ), 
        XTAG( D3DMS_PREFILTER_FORMAT_A8R8G8B8 ),

        XTAG( D3DCLEAR_TARGET ), XTAG( D3DCLEAR_ZBUFFER ), 
        XTAG( D3DCLEAR_STENCIL ),

        // FVFs
        XTAG( D3DFVF_XYZ ), XTAG( D3DFVF_XYZRHW ), XTAG( D3DFVF_NORMAL ), 
        XTAG( D3DFVF_DIFFUSE ), XTAG( D3DFVF_SPECULAR ), XTAG( D3DFVF_TEX0 ), 
        XTAG( D3DFVF_TEX1 ), XTAG( D3DFVF_TEX2 ), XTAG( D3DFVF_TEX3 ), 
        XTAG( D3DFVF_TEX4 ),

        // textcoord sizes
        XTAG( T0_SIZE1 ), XTAG( T0_SIZE2 ), XTAG( T0_SIZE3 ), XTAG( T0_SIZE4 ),
        XTAG( T1_SIZE1 ), XTAG( T1_SIZE2 ), XTAG( T1_SIZE3 ), XTAG( T1_SIZE4 ),
        XTAG( T2_SIZE1 ), XTAG( T2_SIZE2 ), XTAG( T2_SIZE3 ), XTAG( T2_SIZE4 ),
        XTAG( T3_SIZE1 ), XTAG( T3_SIZE2 ), XTAG( T3_SIZE3 ), XTAG( T3_SIZE4 ),

        XTAG( VSDT_FLOAT1 ), XTAG( VSDT_FLOAT2 ), XTAG( VSDT_FLOAT3 ), 
        XTAG( VSDT_FLOAT4 ), XTAG( VSDT_D3DCOLOR ), XTAG( VSDT_SHORT2 ), 
        XTAG( VSDT_SHORT4 ), XTAG( VSDT_NORMSHORT1 ), XTAG( VSDT_NORMSHORT2 ), 
        XTAG( VSDT_NORMSHORT3 ), XTAG( VSDT_NORMSHORT4 ), XTAG( VSDT_NORMPACKED3 ),
        XTAG( VSDT_SHORT1 ), XTAG( VSDT_SHORT3 ), XTAG( VSDT_PBYTE1 ),
        XTAG( VSDT_PBYTE2 ), XTAG( VSDT_PBYTE3 ), XTAG( VSDT_PBYTE4 ), 
        XTAG( VSDT_FLOAT2H ), XTAG( VSDT_NONE ),

        XTAG( D3DVSDE_POSITION ), XTAG( D3DVSDE_BLENDWEIGHT ), 
        XTAG( D3DVSDE_NORMAL ), XTAG( D3DVSDE_DIFFUSE ), XTAG( D3DVSDE_SPECULAR ), 
        XTAG( D3DVSDE_FOG ), XTAG( D3DVSDE_BACKDIFFUSE ), 
        XTAG( D3DVSDE_BACKSPECULAR ), XTAG( D3DVSDE_TEXCOORD0 ), 
        XTAG( D3DVSDE_TEXCOORD1 ), XTAG( D3DVSDE_TEXCOORD2 ), 
        XTAG( D3DVSDE_TEXCOORD3 ),

        // primitive types
        XTAG( D3DPT_POINTLIST ), XTAG( D3DPT_LINELIST ), XTAG( D3DPT_LINELOOP ),
        XTAG( D3DPT_LINESTRIP ), XTAG( D3DPT_TRIANGLELIST ), 
        XTAG( D3DPT_TRIANGLESTRIP ), XTAG( D3DPT_TRIANGLEFAN ), 
        XTAG( D3DPT_QUADLIST ), XTAG( D3DPT_QUADSTRIP ), XTAG( D3DPT_POLYGON ),

        XTAG( D3DCULL_NONE ), XTAG( D3DCULL_CCW ), XTAG( D3DCULL_CW ),
        XTAG( D3DFILL_POINT ), XTAG( D3DFILL_WIREFRAME ), XTAG( D3DFILL_SOLID ),

        // D3DCMPs
        XTAG( D3DCMP_NEVER ), XTAG( D3DCMP_LESS ), XTAG( D3DCMP_EQUAL ),
        XTAG( D3DCMP_LESSEQUAL ), XTAG( D3DCMP_GREATER ), XTAG( D3DCMP_NOTEQUAL ), 
        XTAG( D3DCMP_GREATEREQUAL ), XTAG( D3DCMP_ALWAYS ),

        // misc
        XTAG( FALSE ), XTAG( TRUE )
    };

    for( int ifmt = 0; ifmt < ARRAYSIZE( rgszConsts ); ifmt++ )
    {
        if( !_strnicmp( rgszConsts[ifmt].szStr, szStr, cchStr ) )
        {
            // set val
            *pval = rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}




//----------------------------------------------------------------------------
// Name: InitVertexShader
//
// Desc: Initialize the vertex shader
//----------------------------------------------------------------------------
void InitVertexShader()
{
    if( !g_var.FVF )
    {
        // make sure our position is initialized
        g_pDev->SetVertexData4f( D3DVSDE_VERTEX, -2000, -2000, .5f, 1.0f );
    }
    else
    {
        D3DXDeclaratorFromFVF( g_var.FVF, g_Declaration );
    }

    if( g_dwVertexShader )
    {
        g_pDev->SetVertexShader( D3DFVF_XYZ );
        g_pDev->DeleteVertexShader( g_dwVertexShader );
        g_dwVertexShader = 0;
    }

    if( g_var.uservertexshader )
    {
        HANDLE hFile = CreateFile( g_var.vertexShaderFileName,
                                   GENERIC_READ, FILE_SHARE_READ, NULL,
                                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if( hFile != INVALID_HANDLE_VALUE )
        {
            DWORD dwSize = GetFileSize( hFile, NULL );
            DWORD *pdwVertexShader = new DWORD [dwSize / sizeof(DWORD) + 1];

            DWORD NumberOfBytesRead;
			BOOL bReadOK;
            bReadOK = ReadFile( hFile, pdwVertexShader, dwSize, &NumberOfBytesRead, NULL );
			assert(bReadOK);
			assert(dwSize == NumberOfBytesRead);

            CheckHR( g_pDev->CreateVertexShader( g_Declaration, pdwVertexShader,
                                                 &g_dwVertexShader, 0 ) );

            g_var.uservertexshader = HIWORD( *pdwVertexShader );

            delete [] pdwVertexShader;
            CloseHandle( hFile ); 
        }
        else
        {
            dprintf( "load vertex shader '%s' failed: 0x%08lx\n", 
                     g_var.vertexShaderFileName );

            // set this guy to 0 and do the declaration thing below
            g_var.uservertexshader = 0;
        }
    }

    if( !g_var.uservertexshader )
    {
        CheckHR( g_pDev->CreateVertexShader( g_Declaration, NULL, 
                                             &g_dwVertexShader, 0 ) );
    }                                                                                   
}




//----------------------------------------------------------------------------
// Name: GetNVCLK
//
// Desc: Get the NVCLK speed
//----------------------------------------------------------------------------
DWORD GetNVCLK()
{
    return 233;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\VSTune\vstune.h ===
//-----------------------------------------------------------------------------
// FILE: VSTUNE.H
//
// Desc: vertex shader tune header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

struct TIMETESTRESULTS
{
    float fps;
    UINT cFrames;
    float TimeTillDoneDrawing;
    float TimeTillIdle;
    UINT64 cTrisDrawn;
    float mtps;
    float cycles;

    // precompiled results
    DWORD byteswritten;
    float throughput;
    DWORD pushbuffercalls;
    DWORD pushbuffersize;

    D3DWAITINFO PushBufferWaitInfo;
};

struct VSTSETTINGS
{
    UINT verboselevel;                  // chatty when loading pixelshader defs, etc.
    bool runtestonreload;               // after reloading fillrate.ini run test

    float screenwidth;                  // screen width
    float screenheight;                 // screen height
    D3DFORMAT BackBufferFormat;         // back buffer d3dformat
    D3DFORMAT AutoDepthStencilFormat;   // z buffer format (0 for none)

    D3DMULTISAMPLE_TYPE MSType;         // multisample type
    D3DMULTISAMPLE_TYPE MSFormat;       // multisample format

    DWORD FVF;                          // fvf type
    D3DPRIMITIVETYPE primitivetype;     // vertex buffer primitive type
    UINT indexcount;                    // count of indices
    UINT vertcount;                     // count of vertices in VB
    UINT TriCount;                      // count of triangles drawn

    char vertexShaderFileName[1024];    // Name of vertex Shader to use
    DWORD uservertexshader;             // user vertex shader instruction count

    D3DCULL cullmode;                   // cullmode

    bool degenerates;                   // degenerate primitives?

    bool zenable;                       // enable z buffer
    bool zwriteenable;                  // enable z write
    D3DCMPFUNC d3dcmpfunc;              // z compare function

    float testtime;                     // number of seconds to time
    UINT vbdrawcount;                   // count of times to draw VB
    int precompiled;                    // use precompiled pushbuffer?
    int wcwritesinbkgnd;                // do wc background writes or block?
    int pushbuffernops;                 // insert noops into pushbuffer
    DWORD framesperpushbuffermax;       // max frames recorded in pushbuffer
    bool runusingcpucopy;               // copy pushbuffer
    DWORD numberofpushbuffers;          // number of pushbuffers (1 - 300) to use

    DWORD clearflags;                   // Clear() flags
    DWORD cclearval;                    // color clear val
    float zclearval;                    // z clear val
    DWORD sclearval;                    // stencil clear val

    bool alphablendenable;              // turn on alphablend
    bool alphatestenable;               // turn on alphatest

    D3DFILLMODE d3dfillmode;            // SOLID, WIREFRAME, ...

    bool localviewer;                   // D3DRS_LOCALVIEWER
    bool specularenable;                // D3DRS_SPECULARENABLE
    bool fogenable;                     // D3DRS_FOGENABLE
    bool normalizenormals;              // D3DRS_NORMALIZENORMALS
    bool colorvertex;                   // D3DRS_COLORVERTEX

    bool lighting;                      // D3DRS_LIGHTING
    DWORD numDirectionalLights;         // # of directional lights
    DWORD numPointLights;               // # of point lights
    DWORD numSpotLights;                // # of spotlights

    DWORD numtextures;                  // number of textures

    DWORD NumLights;                    // total number of lights enabled
    DWORD NumStreams;                   // total number of VB streams
};

// macros to help us define the size of our texcoords in vstune.ini
static const DWORD T0_SIZE1 = D3DFVF_TEXCOORDSIZE1( 0 );
static const DWORD T0_SIZE2 = D3DFVF_TEXCOORDSIZE2( 0 );
static const DWORD T0_SIZE3 = D3DFVF_TEXCOORDSIZE3( 0 );
static const DWORD T0_SIZE4 = D3DFVF_TEXCOORDSIZE4( 0 );

static const DWORD T1_SIZE1 = D3DFVF_TEXCOORDSIZE1( 1 );
static const DWORD T1_SIZE2 = D3DFVF_TEXCOORDSIZE2( 1 );
static const DWORD T1_SIZE3 = D3DFVF_TEXCOORDSIZE3( 1 );
static const DWORD T1_SIZE4 = D3DFVF_TEXCOORDSIZE4( 1 );

static const DWORD T2_SIZE1 = D3DFVF_TEXCOORDSIZE1( 2 );
static const DWORD T2_SIZE2 = D3DFVF_TEXCOORDSIZE2( 2 );
static const DWORD T2_SIZE3 = D3DFVF_TEXCOORDSIZE3( 2 );
static const DWORD T2_SIZE4 = D3DFVF_TEXCOORDSIZE4( 2 );

static const DWORD T3_SIZE1 = D3DFVF_TEXCOORDSIZE1( 3 );
static const DWORD T3_SIZE2 = D3DFVF_TEXCOORDSIZE2( 3 );
static const DWORD T3_SIZE3 = D3DFVF_TEXCOORDSIZE3( 3 );
static const DWORD T3_SIZE4 = D3DFVF_TEXCOORDSIZE4( 3 );

static const DWORD VSDT_FLOAT1 = D3DVSDT_FLOAT1 << 16;
static const DWORD VSDT_FLOAT2 = D3DVSDT_FLOAT2 << 16;
static const DWORD VSDT_FLOAT3 = D3DVSDT_FLOAT3 << 16;
static const DWORD VSDT_FLOAT4 = D3DVSDT_FLOAT4 << 16;
static const DWORD VSDT_D3DCOLOR = D3DVSDT_D3DCOLOR << 16;
static const DWORD VSDT_SHORT2 = D3DVSDT_SHORT2 << 16;
static const DWORD VSDT_SHORT4 = D3DVSDT_SHORT4 << 16;
static const DWORD VSDT_NORMSHORT1 = D3DVSDT_NORMSHORT1 << 16;
static const DWORD VSDT_NORMSHORT2 = D3DVSDT_NORMSHORT2 << 16;
static const DWORD VSDT_NORMSHORT3 = D3DVSDT_NORMSHORT3 << 16;
static const DWORD VSDT_NORMSHORT4 = D3DVSDT_NORMSHORT4 << 16;
static const DWORD VSDT_NORMPACKED3 = D3DVSDT_NORMPACKED3 << 16;
static const DWORD VSDT_SHORT1 = D3DVSDT_SHORT1 << 16;
static const DWORD VSDT_SHORT3 = D3DVSDT_SHORT3 << 16;
static const DWORD VSDT_PBYTE1 = D3DVSDT_PBYTE1 << 16;
static const DWORD VSDT_PBYTE2 = D3DVSDT_PBYTE2 << 16;
static const DWORD VSDT_PBYTE3 = D3DVSDT_PBYTE3 << 16;
static const DWORD VSDT_PBYTE4 = D3DVSDT_PBYTE4 << 16;
static const DWORD VSDT_FLOAT2H = D3DVSDT_FLOAT2H << 16;
static const DWORD VSDT_NONE = D3DVSDT_NONE << 16;

// vstune.cpp
bool ReadVSTIniFile();

void DoQuickTimedTest();
void DoPushBufferCallTest();
void RandomVS();

void DumpCurrentSettings();
float DoTimedTest( TIMETESTRESULTS *pttres = NULL );
void InitVertexShader();
void ClearScreen();
DWORD GetNVCLK();
void RenderFrame( int vbdrawcount, BOOL nops = FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\anim.h ===
//-----------------------------------------------------------------------------
//  
//  File: anim.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Animation using key frames.
//
//-----------------------------------------------------------------------------
#pragma once

#include "frame.h"

//////////////////////////////////////////////////////////////////////
// When we go to the codegen model, all of this interpretation code
// can go away.  For now, we skip the compile/link step and write out
// a token stream that is interpreted in xbview.
//
#ifndef ANIM_INTERPRETED
#define ANIM_INTERPRETED 1
#endif

#if ANIM_INTERPRETED
enum AnimType {
	ANIM_MATRIX,
	ANIM_ROTATE,
	ANIM_TRANSLATE,
	ANIM_SCALE,
	ANIM_ROTATEBLEND,
	ANIM_TRANSLATEBLEND,
	ANIM_SCALEBLEND,
	ANIM_CONCAT,
};
#endif

////////////////////////////////////////////////////////////////////////////////
// Generic frame animation
//

struct AnimFrame
{
#if !ANIM_INTERPRETED
	
    //////////////////////////////////////////////////////////////////////
    // Compute the transformation matrix based on the current animation keys.
    virtual HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime) = 0;
	
#else	
	AnimType m_Type; // Instead of using virtual functions, we key off the type, which can be written to the preview file.

    //////////////////////////////////////////////////////////////////////
    // Compute the transformation matrix based on the current animation keys.
	//
	// This version does not use virtual functions, but instead
	// uses the m_Type field to choose which subclass to cast the
	// 'this' pointer to.
	HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);

    //////////////////////////////////////////////////////////////////////
	// For writing to a file, we need to compute the size of the
	// structure data and the size of the key data (which may need to be
	// aligned.)
	//
	DWORD GetSize();

    //////////////////////////////////////////////////////////////////////
	// Write the expression to the given memory location, adjusting
	// pointer offsets to be relative to pBase, i.e. pDest - pBase.
	// The number of bytes written must match the value returned by
	// GetSize().
	//
	HRESULT RelocateCopy(BYTE *pDest, const BYTE *pBase);

    //////////////////////////////////////////////////////////////////////
	// Patch file offsets to memory offsets, i.e. convert file offsets
	// to pointers relative to pBase
	//
	HRESULT Patch(const BYTE *pBase);

    //////////////////////////////////////////////////////////////////////
	// Check to see if the animation expression is static, i.e. it
	// has only single-key animations or all the keys are the same.
	BOOL IsConstant();
#endif
};

//////////////////////////////////////////////////////////////////////
// Basic key-framed animation, with variable size keys.  Based on
// the SMIL2.0 semantics for the <animate> tag.
//
struct AnimCurve {
    
    // animation information
    UINT m_KeyCount;    // number of keys in each array
    FLOAT *m_rKeyTimes; // m_KeyCount length
    UINT m_KeySize;     // number of floats in a key
    FLOAT *m_rKeys;     // m_KeySize * m_KeyCount length
    // FLOAT *m_rKeySplines;

    // Local time transformation, fLocal = (fGlobalTime - m_fBegin) * m_fDurationInverse;
    float m_fBegin;             // start of animation
    float m_fDurationInverse;   // inverse duration of animation
    // TODO: more SMIL stuff
    // enum { CalcMode_discrete, CalcMode_linear, CalcMode_paced, CalcMode_spline } CalcMode;
    // float m_fRepeatCount;
    // float m_fRepeatDur;

    //////////////////////////////////////////////////////////////////////
    // Compute local time
    FLOAT LocalTime(FLOAT fGlobalTime) CONST
    {
        // TODO: more SMIL stuff, repeats, fill mode, etc.
        return (fGlobalTime - m_fBegin) * m_fDurationInverse;
    }
    
    //////////////////////////////////////////////////////////////////////
    // Find the bracketing key times
    HRESULT FindKeys(FLOAT fLocalTime, UINT *piKey1, UINT *piKey2, FLOAT *pfLerpValue) CONST;

    //////////////////////////////////////////////////////////////////////
    // Find the bracketing key times, then lerp the values
    HRESULT Sample(FLOAT fLocalTime, FLOAT *rfValue) CONST;

#if ANIM_INTERPRETED
	AnimCurve()
	{
		m_KeyCount = 0;
		m_rKeyTimes = NULL;
		m_KeySize = 0;
		m_rKeys = NULL;
		m_fBegin = 0.f;
		m_fDurationInverse = 1.f;
	}
	
    //////////////////////////////////////////////////////////////////////
	// For writing to a file, we need to compute the size of the key data.
	//
	DWORD GetSizeKeys() CONST;

    //////////////////////////////////////////////////////////////////////
	// Write the keys to the given memory location, then adjust
	// pointer offsets to be relative to pBase, i.e. pDest - pBase.
	// The number of bytes written must match the value returned by
	// GetSizeKeys().
	//
	HRESULT RelocateCopyKeys(BYTE *pDest, const BYTE *pBase) CONST;

    //////////////////////////////////////////////////////////////////////
	// Patch file offsets to memory offsets, i.e. convert file offsets
	// to pointers relative to pBase
	//
	HRESULT PatchKeys(const BYTE *pBase);

    //////////////////////////////////////////////////////////////////////
	// Check to see if the animation curve is static, i.e. it
	// has only single-key animations or all the keys are the same.
	BOOL IsConstant();
#endif
};

////////////////////////////////////////////////////////////////////////////////
// Frame animation types
//
struct AnimMatrix : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimMatrix()
	{
		m_Type = ANIM_MATRIX;
		m_curve.m_KeySize = 16;
	}
	AnimMatrix(D3DXMATRIX *pMatrix)
	{
		// Create a static matrix
		m_Type = ANIM_MATRIX;
		m_curve.m_KeySize = 16;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 16 ];
		memcpy(m_curve.m_rKeys, &pMatrix->m[0][0], sizeof(FLOAT) * 16);
	}
#endif	
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
};

struct AnimRotate : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimRotate()
	{
		m_Type = ANIM_ROTATE;
		m_curve.m_KeySize = 4;
	}
	AnimRotate(D3DXQUATERNION *pQuaternion)
	{
		// Create a static rotation
		m_Type = ANIM_ROTATE;
		m_curve.m_KeySize = 4;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 4 ];
		memcpy(m_curve.m_rKeys, pQuaternion, sizeof(FLOAT) * 4);
	}
#endif
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXQUATERNION *pQuaternion, float fGlobalTime);
};

struct AnimTranslate : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimTranslate()
	{
		m_Type = ANIM_TRANSLATE;
		m_curve.m_KeySize = 3;
	}
	AnimTranslate(D3DXVECTOR3 *pTranslate)
	{
		// Create a static translate
		m_Type = ANIM_TRANSLATE;
		m_curve.m_KeySize = 3;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 3 ];
		memcpy(m_curve.m_rKeys, pTranslate, sizeof(FLOAT) * 3);
	}
#endif	
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime);
};

struct AnimScale : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimScale()
	{
		m_Type = ANIM_SCALE;
		m_curve.m_KeySize = 3;
	}
	AnimScale(D3DXVECTOR3 *pScale)
	{
		// Create a static scale
		m_Type = ANIM_SCALE;
		m_curve.m_KeySize = 3;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 3 ];
		memcpy(m_curve.m_rKeys, pScale, sizeof(FLOAT) * 3);
	}
#endif	
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pScale, float fGlobalTime);
};



////////////////////////////////////////////////////////////////////////////////
// Parameter blending.  Before creating the matrix, parameters are interpolated.
//
struct AnimRotateBlend : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimRotateBlend()
	{
		m_Type = ANIM_ROTATEBLEND;
	}
#endif	
	float m_fBlend;
	AnimRotate *m_pAnimRotateA;
	AnimRotate *m_pAnimRotateB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXQUATERNION *pQuaternion, float fGlobalTime);
};

struct AnimTranslateBlend : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimTranslateBlend()
	{
		m_Type = ANIM_TRANSLATEBLEND;
	}
#endif	
	float m_fBlend;
	AnimTranslate *m_pAnimTranslateA;
	AnimTranslate *m_pAnimTranslateB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime);
};

struct AnimScaleBlend : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimScaleBlend()
	{
		m_Type = ANIM_SCALEBLEND;
	}
#endif	
	float m_fBlend;
	AnimScale *m_pAnimScaleA;
	AnimScale *m_pAnimScaleB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pScale, float fGlobalTime);
};



////////////////////////////////////////////////////////////////////////////////
// Matrix concatenation. Returns m_AnimA * m_AnimB
//
struct AnimConcat : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimConcat()
	{
		m_Type = ANIM_CONCAT;
	}
#endif	
	AnimFrame *m_pAnimA;
	AnimFrame *m_pAnimB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
	{
		HRESULT hr;
		D3DXMATRIX matA;
		hr = m_pAnimA->SetTime(&matA, fGlobalTime);
		if (FAILED(hr))
			return hr;
		D3DXMATRIX matB;
		hr = m_pAnimB->SetTime(&matB, fGlobalTime);
		if (FAILED(hr))
			return hr;
		D3DXMatrixMultiply(pMatrix, &matA, &matB);
		return S_OK;
	}
};




////////////////////////////////////////////////////////////////////////////////
// AnimLink attaches matrix animation to a frame.
//
struct AnimLink
{
    AnimLink      *m_pNext;         // next animation in list
    AnimFrame 	  *m_pAnimFrame;    // animation keys
    Frame         *m_pFrame;        // frame we're applying the animation to
};



////////////////////////////////////////////////////////////////////////////////
// Vertex shader parameter setting
//
// TODO: rework this whole class to cleanly separate animations from application of animations, 
// skeleton hierarchy from use of concatenated transformation

struct AnimVertexShaderParameter
{
    AnimVertexShaderParameter *m_pNext; // next animated vertex shader parameter in list
    CHAR *m_strVertexShaderReference;   // name of vertex shader
    UINT m_Index;                       // index into constants
    UINT m_Count;                       // count of constants to write
    CHAR *m_strExpression;              // expression to evaluate
    // TODO: fix this ugliness
    VOID *m_pSource; // this is the only kind of vertex shader animation we currently support
};

struct AnimVSP
{
    DWORD m_VertexShaderReference;  // vertex shader resource to write constant for
    DWORD m_Index;                  // index into constants
    DWORD m_Count;                  // count of constants to write
    VOID *m_pSource;                // pointer to source matrix
};

////////////////////////////////////////////////////////////////////////////////
// Animation resource that holds a list of vertex shader parameters to be set,
// and a list of animation expressions to evaluate.
//
struct Animation
{
    DWORD m_VSPCount;
    AnimVSP *m_rVSP;        // array of vertex shader parameter settings
    DWORD m_AnimCount;
    AnimLink *m_pAnimList;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\anim.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: anim.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//  Key frame animation based on SkinnedMesh DirectX sample.
//-----------------------------------------------------------------------------
#include "anim.h"

//////////////////////////////////////////////////////////////////////
// Look up keys based on local time
//
HRESULT AnimCurve::FindKeys(float fLocalTime, UINT *piKey1, UINT *piKey2, FLOAT *pfLerpValue) CONST
{
    UINT iKey;
    UINT iKey1;
    UINT iKey2;
	iKey1 = iKey2 = 0;
	FLOAT fTime = (float)fmod(fLocalTime, m_rKeyTimes[m_KeyCount-1]);
	if (fTime < 0.f) fTime += m_rKeyTimes[m_KeyCount-1];
	for (iKey = 0 ;iKey < m_KeyCount ; iKey++)
	{
		if (m_rKeyTimes[iKey] > fTime)
		{
			iKey2 = iKey;
			
			if (iKey > 0)
			{
				iKey1= iKey - 1;
			}
			else  // when iKey == 0, then iKey1 == 0
			{
				iKey1 = iKey;
			}
			
			break;
		}
	}
	FLOAT fTime1 = (float)m_rKeyTimes[iKey1];
	FLOAT fTime2 = (float)m_rKeyTimes[iKey2];
	FLOAT fLerpValue;
	if ((fTime2 - fTime1) ==0)
		fLerpValue = 0;
	else
		fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);
	
	*piKey1 = iKey1;
	*piKey2 = iKey2;
	*pfLerpValue = fLerpValue;
	return S_OK;
}
	
//////////////////////////////////////////////////////////////////////
// Find the bracketing key times, then lerp the values
//
HRESULT AnimCurve::Sample(FLOAT fLocalTime, FLOAT *rfValue) CONST
{
	if (m_KeyCount == 0)
		return E_FAIL;
	if (m_KeyCount == 1)
	{
		for (UINT iValue = 0; iValue < m_KeySize; iValue++)
			rfValue[iValue] = m_rKeys[iValue];
		return S_OK;
	}
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	HRESULT hr = FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	if (FAILED(hr))
		return hr;
	FLOAT *rfKey1 = m_rKeys + iKey1 * m_KeySize;
	FLOAT *rfKey2 = m_rKeys + iKey2 * m_KeySize;
	for (UINT iValue = 0; iValue < m_KeySize; iValue++)
		rfValue[iValue] = rfKey1[iValue] + fLerpValue * (rfKey2[iValue] - rfKey1[iValue]);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Look up matrix key based on local time
//
HRESULT AnimMatrix::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
    if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		D3DXMatrixIdentity(pMatrix);
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		memcpy(&pMatrix->m[0][0], m_curve.m_rKeys, 16 * sizeof(FLOAT));
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey, iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	
	// Instead of lerping between the matrices, switch
	// to the next matrix when past the half-way mark.
	if (fLerpValue > 0.5)
	{
		iKey = iKey2;
	}
	else
	{
		iKey = iKey1;
	}
	memcpy(&pMatrix->m[0][0], m_curve.m_rKeys + 16 * iKey, 16 * sizeof(FLOAT));
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Interpolate between nearest rotate keys
//
HRESULT AnimRotate::SetTime(D3DXQUATERNION *pQuaternion, float fGlobalTime)
{
	if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		D3DXQuaternionIdentity(pQuaternion);
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		*pQuaternion = *(D3DXQUATERNION *)m_curve.m_rKeys;
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
//#define USE_SQUAD
#ifdef USE_SQUAD
	int i1 = (int)iKey1;
	int i2 = (int)iKey2;
	int i0 = i1 - 1;
	int i3 = i2 + 1;
	if(i0 < 0)
		i0 += m_curve.m_KeyCount;
	if(i3 >= (INT) m_curve.m_KeyCount)
		i3 -= m_curve.m_KeyCount;
	D3DXQUATERNION qA, qB, qC;
	D3DXQuaternionSquadSetup(&qA, &qB, &qC, 
							 (D3DXQUATERNION *)m_curve.m_rKeys + i0,
							 (D3DXQUATERNION *)m_curve.m_rKeys + i1,
							 (D3DXQUATERNION *)m_curve.m_rKeys + i2,
							 (D3DXQUATERNION *)m_curve.m_rKeys + i3);
	D3DXQuaternionSquad(pQuaternion, (D3DXQUATERNION *)m_curve.m_rKeys + i1, &qA, &qB, &qC, fLerpValue);
#else
	D3DXQuaternionSlerp(pQuaternion,
						(D3DXQUATERNION *)m_curve.m_rKeys + iKey1,
						(D3DXQUATERNION *)m_curve.m_rKeys + iKey2,
						fLerpValue);
#endif
	return S_OK;
}

HRESULT AnimRotate::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXQUATERNION quat;
	HRESULT hr = SetTime(&quat, fGlobalTime);
//	quat.w = -quat.w;
	D3DXMatrixRotationQuaternion(pMatrix, &quat);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between two rotate animations
//
HRESULT AnimRotateBlend::SetTime(D3DXQUATERNION *pRotate, float fGlobalTime)
{
	D3DXQUATERNION quatA;
	HRESULT hr = m_pAnimRotateA->SetTime(&quatA, fGlobalTime);
	if (FAILED(hr))
		return hr;
	
	D3DXQUATERNION quatB;
	hr = m_pAnimRotateB->SetTime(&quatB, fGlobalTime);
	if (FAILED(hr))
		return hr;

	D3DXQuaternionSlerp(pRotate, &quatA, &quatB, m_fBlend);
	return S_OK;
}

HRESULT AnimRotateBlend::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXQUATERNION quat;
	HRESULT hr = SetTime(&quat, fGlobalTime);
//	quat.w = -quat.w;
	D3DXMatrixRotationQuaternion(pMatrix, &quat);
	return hr;
}



//////////////////////////////////////////////////////////////////////
// Interpolate between nearest translation keys
//
HRESULT AnimTranslate::SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime)
{
	if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		pTranslate->x = pTranslate->y = pTranslate->z = 0.f;
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		*pTranslate = *(D3DXVECTOR3 *)m_curve.m_rKeys;
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	D3DXVec3Lerp(pTranslate,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey1,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey2,
				 fLerpValue);
	return S_OK;
}

HRESULT AnimTranslate::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vTranslate;
	HRESULT hr = SetTime(&vTranslate, fGlobalTime);
	D3DXMatrixTranslation(pMatrix, vTranslate.x, vTranslate.y, vTranslate.z);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between two translate animations
//
HRESULT AnimTranslateBlend::SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime)
{
	D3DXVECTOR3 vTranslateA;
	HRESULT hr = m_pAnimTranslateA->SetTime(&vTranslateA, fGlobalTime);
	if (FAILED(hr))
		return hr;
	
	D3DXVECTOR3 vTranslateB;
	hr = m_pAnimTranslateB->SetTime(&vTranslateB, fGlobalTime);
	if (FAILED(hr))
		return hr;

	D3DXVec3Lerp(pTranslate, &vTranslateA, &vTranslateB, m_fBlend);
	return S_OK;
}

HRESULT AnimTranslateBlend::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vTranslate;
	HRESULT hr = SetTime(&vTranslate, fGlobalTime);
	D3DXMatrixTranslation(pMatrix, vTranslate.x, vTranslate.y, vTranslate.z);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between nearest scale keys
//
HRESULT AnimScale::SetTime(D3DXVECTOR3 *pScale, float fGlobalTime)
{
	if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		pScale->x = pScale->y = pScale->z = 1.f;
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		*pScale = *(D3DXVECTOR3 *)m_curve.m_rKeys;
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	D3DXVec3Lerp(pScale,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey1,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey2,
				 fLerpValue);
	return S_OK;
}

HRESULT AnimScale::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vScale;
	HRESULT hr = SetTime(&vScale, fGlobalTime);
	D3DXMatrixScaling(pMatrix, vScale.x, vScale.y, vScale.z);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between two scale animations
//
HRESULT AnimScaleBlend::SetTime(D3DXVECTOR3 *pScale, float fGlobalTime)
{
	D3DXVECTOR3 vScaleA;
	HRESULT hr = m_pAnimScaleA->SetTime(&vScaleA, fGlobalTime);
	if (FAILED(hr))
		return hr;
	
	D3DXVECTOR3 vScaleB;
	hr = m_pAnimScaleB->SetTime(&vScaleB, fGlobalTime);
	if (FAILED(hr))
		return hr;

	D3DXVec3Lerp(pScale, &vScaleA, &vScaleB, m_fBlend);
	return hr;
}

HRESULT AnimScaleBlend::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vScale;
	HRESULT hr = SetTime(&vScale, fGlobalTime);
	D3DXMatrixScaling(pMatrix, vScale.x, vScale.y, vScale.z);
	return hr;
}



#if ANIM_INTERPRETED

//////////////////////////////////////////////////////////////////////
// For writing to a file, we need to compute the size of the key data.
//
DWORD AnimCurve::GetSizeKeys() CONST
{
	return m_KeyCount * (1 /* keyTimes */ + m_KeySize) * sizeof(FLOAT);
}

//////////////////////////////////////////////////////////////////////
// Write the keys to the given memory location, then adjust
// pointer offsets to be relative to pBase, i.e. pDest - pBase.
// The number of bytes written must match the value returned by
// GetSizeKeys().
//
HRESULT AnimCurve::RelocateCopyKeys(BYTE *pDest, const BYTE *pBase) CONST
{
	UINT KeyTimesSize = sizeof(FLOAT) * m_KeyCount;
	memcpy(pDest, m_rKeyTimes, KeyTimesSize);
	*(DWORD *)&m_rKeyTimes = pDest - pBase;	// convert to file offset
	pDest += KeyTimesSize;
	memcpy(pDest, m_rKeys, sizeof(FLOAT) * m_KeyCount * m_KeySize);
	*(DWORD *)&m_rKeys = pDest - pBase;	        // convert to file offset
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Patch file offsets to memory offsets, i.e. convert file offsets
// to pointers relative to pBase
//
HRESULT AnimCurve::PatchKeys(const BYTE *pBase)
{
	*(DWORD *)&m_rKeyTimes += (DWORD)pBase;	// convert to pointer
	*(DWORD *)&m_rKeys += (DWORD)pBase;	    // convert to pointer
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Compute the transformation matrix based on the current animation keys.
HRESULT AnimFrame::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	switch (m_Type)
	{
	case ANIM_MATRIX: 			return ((AnimMatrix         *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_ROTATE: 			return ((AnimRotate         *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_TRANSLATE: 		return ((AnimTranslate      *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_SCALE: 			return ((AnimScale          *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_ROTATEBLEND:		return ((AnimRotateBlend    *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_TRANSLATEBLEND:	return ((AnimTranslateBlend *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_SCALEBLEND: 		return ((AnimScaleBlend     *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_CONCAT: 			return ((AnimConcat         *)this)->SetTime(pMatrix, fGlobalTime);
	default:
		return E_NOTIMPL;
	}
}

//////////////////////////////////////////////////////////////////////
// For writing to a file, we need to compute the size of the
// structure data and the size of the key data.
//
DWORD AnimFrame::GetSize()
{
	DWORD Size;
	switch (m_Type)	{
	case ANIM_MATRIX:
	{
		AnimMatrix *pAnimMatrix = (AnimMatrix *)this;
		Size = sizeof(AnimMatrix);
		Size += pAnimMatrix->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_ROTATE:
	{
		AnimRotate *pAnimRotate = (AnimRotate *)this;
		Size = sizeof(AnimRotate);
		Size += pAnimRotate->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_TRANSLATE:
	{
		AnimTranslate *pAnimTranslate = (AnimTranslate *)this;
		Size = sizeof(AnimTranslate);
		Size += pAnimTranslate->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_SCALE:
	{
		AnimScale *pAnimScale = (AnimScale *)this;
		Size = sizeof(AnimScale);
		Size += pAnimScale->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_ROTATEBLEND:
	{
		AnimRotateBlend *pAnimRotateBlend = (AnimRotateBlend *)this;
		Size = sizeof(AnimRotateBlend);
		Size += pAnimRotateBlend->m_pAnimRotateA->GetSize();
		Size += pAnimRotateBlend->m_pAnimRotateB->GetSize();
		return Size;
	}
	case ANIM_TRANSLATEBLEND:
	{
		AnimTranslateBlend *pAnimTranslateBlend = (AnimTranslateBlend *)this;
		Size = sizeof(AnimTranslateBlend);
		Size += pAnimTranslateBlend->m_pAnimTranslateA->GetSize();
		Size += pAnimTranslateBlend->m_pAnimTranslateB->GetSize();
		return Size;
	}
	case ANIM_SCALEBLEND:
	{
		AnimScaleBlend *pAnimScaleBlend = (AnimScaleBlend *)this;
		Size = sizeof(AnimScaleBlend);
		Size += pAnimScaleBlend->m_pAnimScaleA->GetSize();
		Size += pAnimScaleBlend->m_pAnimScaleB->GetSize();
		return Size;
	}
	case ANIM_CONCAT:
	{
		AnimConcat *pAnimConcat = (AnimConcat *)this;
		Size = sizeof(AnimConcat);
		Size += pAnimConcat->m_pAnimA->GetSize();
		Size += pAnimConcat->m_pAnimB->GetSize();
		return Size;
	}
	default:
		return 0;	// E_NOTIMPL
	}
}

//////////////////////////////////////////////////////////////////////
// Write the expression to the given memory location, adjusting
// pointer offsets to be relative to pBase, i.e. pDest - pBase.
// The number of bytes written must match the value returned by
// GetSize().
//
HRESULT AnimFrame::RelocateCopy(BYTE *pDest, const BYTE *pBase)
{
	HRESULT hr;
	switch (m_Type) {
	case ANIM_MATRIX:
	{
		AnimMatrix *pAnimMatrix = (AnimMatrix *)pDest;
		*pAnimMatrix = *(AnimMatrix *)this;
		pDest += sizeof(AnimMatrix);
		return pAnimMatrix->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_ROTATE:
	{
		AnimRotate *pAnimRotate = (AnimRotate *)pDest;
		*pAnimRotate = *(AnimRotate *)this;
		pDest += sizeof(AnimRotate);
		return pAnimRotate->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_TRANSLATE:
	{
		AnimTranslate *pAnimTranslate = (AnimTranslate *)pDest;
		*pAnimTranslate = *(AnimTranslate *)this;
		pDest += sizeof(AnimTranslate);
		return pAnimTranslate->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_SCALE:
	{
		AnimScale *pAnimScale = (AnimScale *)pDest;
		*pAnimScale = *(AnimScale *)this;
		pDest += sizeof(AnimScale);
		return pAnimScale->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_ROTATEBLEND:
	{
		AnimRotateBlend *pAnimRotateBlend = (AnimRotateBlend *)pDest;
		*pAnimRotateBlend = *(AnimRotateBlend *)this;
		pDest += sizeof(AnimRotateBlend);
		hr = pAnimRotateBlend->m_pAnimRotateA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimRotateBlend->m_pAnimRotateA->GetSize();
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimRotateBlend->m_pAnimRotateB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	case ANIM_TRANSLATEBLEND:
	{
		AnimTranslateBlend *pAnimTranslateBlend = (AnimTranslateBlend *)pDest;
		*pAnimTranslateBlend = *(AnimTranslateBlend *)this;
		pDest += sizeof(AnimTranslateBlend);
		hr = pAnimTranslateBlend->m_pAnimTranslateA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimTranslateBlend->m_pAnimTranslateA->GetSize();
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimTranslateBlend->m_pAnimTranslateB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	case ANIM_SCALEBLEND:
	{
		AnimScaleBlend *pAnimScaleBlend = (AnimScaleBlend *)pDest;
		*pAnimScaleBlend = *(AnimScaleBlend *)this;
		pDest += sizeof(AnimScaleBlend);
		hr = pAnimScaleBlend->m_pAnimScaleA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimScaleBlend->m_pAnimScaleA->GetSize();
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimScaleBlend->m_pAnimScaleB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	case ANIM_CONCAT:
	{
		AnimConcat *pAnimConcat = (AnimConcat *)pDest;
		*pAnimConcat = *(AnimConcat *)this;
		pDest += sizeof(AnimConcat);
		hr = pAnimConcat->m_pAnimA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimConcat->m_pAnimA->GetSize();
		*(DWORD *)&pAnimConcat->m_pAnimA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimConcat->m_pAnimB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimConcat->m_pAnimB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	default:
		return E_NOTIMPL;
	}
}

//////////////////////////////////////////////////////////////////////
// Patch file offsets to memory offsets, i.e. convert file offsets
// to pointers.
//
HRESULT AnimFrame::Patch(const BYTE *pBase)
{
	HRESULT hr;
	switch (m_Type) {
	case ANIM_MATRIX:
	{
		AnimMatrix *pAnimMatrix = (AnimMatrix *)this;
		return pAnimMatrix->m_curve.PatchKeys(pBase);
	}
	case ANIM_ROTATE:
	{
		AnimRotate *pAnimRotate = (AnimRotate *)this;
		return pAnimRotate->m_curve.PatchKeys(pBase);
	}
	case ANIM_TRANSLATE:
	{
		AnimTranslate *pAnimTranslate = (AnimTranslate *)this;
		return pAnimTranslate->m_curve.PatchKeys(pBase);
	}
	case ANIM_SCALE:
	{
		AnimScale *pAnimScale = (AnimScale *)this;
		return pAnimScale->m_curve.PatchKeys(pBase);
	}
	case ANIM_ROTATEBLEND:
	{
		AnimRotateBlend *pAnimRotateBlend = (AnimRotateBlend *)this;
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateA += (DWORD)pBase;	// convert to pointer
		hr = pAnimRotateBlend->m_pAnimRotateA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateB += (DWORD)pBase;	// convert to pointer
		hr = pAnimRotateBlend->m_pAnimRotateB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	case ANIM_TRANSLATEBLEND:
	{
		AnimTranslateBlend *pAnimTranslateBlend = (AnimTranslateBlend *)this;
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateA += (DWORD)pBase;	// convert to pointer
		hr = pAnimTranslateBlend->m_pAnimTranslateA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateB += (DWORD)pBase;	// convert to pointer
		hr = pAnimTranslateBlend->m_pAnimTranslateB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	case ANIM_SCALEBLEND:
	{
		AnimScaleBlend *pAnimScaleBlend = (AnimScaleBlend *)this;
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleA += (DWORD)pBase;	// convert to pointer
		hr = pAnimScaleBlend->m_pAnimScaleA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleB += (DWORD)pBase;	// convert to pointer
		hr = pAnimScaleBlend->m_pAnimScaleB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	case ANIM_CONCAT:
	{
		AnimConcat *pAnimConcat = (AnimConcat *)this;
		*(DWORD *)&pAnimConcat->m_pAnimA += (DWORD)pBase;	// convert to pointer
		hr = pAnimConcat->m_pAnimA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimConcat->m_pAnimB += (DWORD)pBase;	// convert to pointer
		hr = pAnimConcat->m_pAnimB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	default:
		return E_NOTIMPL;
	}
}

//////////////////////////////////////////////////////////////////////
// Check to see if the animation curve is static, i.e. it
// has only single-key animations or all the keys are the same.
BOOL AnimCurve::IsConstant()
{
	// Check if all keys are the same
	FLOAT *rfKey0 = m_rKeys;
	for (UINT iKey = 1; iKey < m_KeyCount ; iKey++)
	{
		FLOAT *rfKey = m_rKeys + iKey * m_KeySize;
		if (memcmp(rfKey0, rfKey, sizeof(FLOAT) * m_KeySize) != 0)
			return FALSE;
	}
	return TRUE;
}

 //////////////////////////////////////////////////////////////////////
// Check to see if the animation expression is static, i.e. it
// has only single-key animations.
BOOL AnimFrame::IsConstant()
{
	switch (m_Type) {
	case ANIM_MATRIX:
	{
		AnimMatrix *pAnimMatrix = (AnimMatrix *)this;
		return pAnimMatrix->m_curve.IsConstant();
	}
	case ANIM_ROTATE:
	{
		AnimRotate *pAnimRotate = (AnimRotate *)this;
		return pAnimRotate->m_curve.IsConstant();
	}
	case ANIM_TRANSLATE:
	{
		AnimTranslate *pAnimTranslate = (AnimTranslate *)this;
		return pAnimTranslate->m_curve.IsConstant();
	}
	case ANIM_SCALE:
	{
		AnimScale *pAnimScale = (AnimScale *)this;
		return pAnimScale->m_curve.IsConstant();
	}

	// TODO: if blend parameter is animated, then we need to compare the
	// two animations, too.

	case ANIM_ROTATEBLEND:
	{
		AnimRotateBlend *pAnimRotateBlend = (AnimRotateBlend *)this;
		if (!pAnimRotateBlend->m_pAnimRotateA->IsConstant())
			return FALSE;
		if (!pAnimRotateBlend->m_pAnimRotateB->IsConstant())
			return FALSE;
		return TRUE;
	}
	case ANIM_TRANSLATEBLEND:
	{
		AnimTranslateBlend *pAnimTranslateBlend = (AnimTranslateBlend *)this;
		if (!pAnimTranslateBlend->m_pAnimTranslateA->IsConstant())
			return FALSE;
		if (!pAnimTranslateBlend->m_pAnimTranslateB->IsConstant())
			return FALSE;
		return TRUE;
	}
	case ANIM_SCALEBLEND:
	{
		AnimScaleBlend *pAnimScaleBlend = (AnimScaleBlend *)this;
		if (!pAnimScaleBlend->m_pAnimScaleA->IsConstant())
			return FALSE;
		if (!pAnimScaleBlend->m_pAnimScaleB->IsConstant())
			return FALSE;
		return TRUE;
	}


	case ANIM_CONCAT:
	{
		AnimConcat *pAnimConcat = (AnimConcat *)this;
		if (!pAnimConcat->m_pAnimA->IsConstant())
			return FALSE;
		if (!pAnimConcat->m_pAnimB->IsConstant())
			return FALSE;
		return TRUE;
	}
	default:
		return FALSE;
	}
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\basetexture.h ===
//-----------------------------------------------------------------------------
// File: BaseTexture.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the basic texture-related functionality of the bundler tool
//
// Hist: 2001.04.13 - New for May XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BASETEXTURE_H
#define BASETEXTURE_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>
#include "xd3d.h"
#include "LoadImage.h"

class CBundler;



// Enum for format definitions
typedef enum { FMT_LINEAR, FMT_SWIZZLED, FMT_COMPRESSED } FMT_TYPE;


// Format definition
struct FORMATSPEC
{
    CHAR*    strFormat;
    DWORD    dwXboxFormat;
    FMT_TYPE Type;
	DWORD    dwNumAlphaBits;
};
extern const FORMATSPEC g_TextureFormats[];




//-----------------------------------------------------------------------------
// Name: class CBaseTexture
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CBaseTexture
{
public:
    CBaseTexture( CBundler* pBundler );
    ~CBaseTexture();

    CHAR  m_strFormat[MAX_PATH];
    int   m_nFormat;
    DWORD m_dwFilter;
    DWORD m_dwLevels;
	D3DCOLOR m_ColorKey;
	
protected:
    int     FormatFromString( CHAR* strFormat );            // Format processing
    int     FormatFromPCFormat( D3DFORMAT d3dFormat );
    HRESULT LoadImage( CHAR* strSource, CHAR* strAlphaSource, CImage** ppImage );
    HRESULT LoadImageUsingD3DX( CHAR* strSource, CHAR* strAlphaSource,
                                CImage** ppImage );
    HRESULT ResizeImage( DWORD dwWidth, DWORD dwHeight, CImage** ppImage );
    HRESULT SaveImage( DWORD* pcbData, DWORD dwLevels, CImage* pImage );

    HRESULT SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, CVolume* pVolume );

    DWORD   WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
                                    DWORD dwHeight, DWORD dwDepth );
    DWORD   WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
                                      DWORD dwHeight, DWORD dwDepth );
    DWORD   WriteCompressedTextureData( VOID* pBits, DWORD dwWidth, 
                                        DWORD dwHeight, DWORD dwDepth );

    CBundler* m_pBundler;
};


#endif // BASETEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\basetexture.cpp ===
//-----------------------------------------------------------------------------
// File: BaseTexture.cpp
//
// Desc: Contains the basic texture-specific logic for the bundler tool
//
// Hist: 2001.04.13 - New for May XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include "BaseTexture.h"
#include "Bundler.h"
#include "LoadImage.h"
#include "xgraphics.h"
#include "cd3dxblt.h"


// Texture formats
const FORMATSPEC g_TextureFormats[] = 
{
    // Format name           Xbox save format        Type           #alphabits
    { "D3DFMT_A8R8G8B8",     X_D3DFMT_A8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8R8G8B8",     X_D3DFMT_X8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_A8B8G8R8",     X_D3DFMT_A8B8G8R8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_B8G8R8A8",     X_D3DFMT_B8G8R8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_R8G8B8A8",     X_D3DFMT_R8G8B8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8L8V8U8",     X_D3DFMT_X8L8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_Q8W8V8U8",     X_D3DFMT_Q8W8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_V16U16",       X_D3DFMT_V16U16,        FMT_SWIZZLED,   0    },
    { "D3DFMT_A4R4G4B4",     X_D3DFMT_A4R4G4B4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_R4G4B4A4",     X_D3DFMT_R4G4B4A4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_X1R5G5B5",     X_D3DFMT_X1R5G5B5,      FMT_SWIZZLED,   0    },
    { "D3DFMT_A1R5G5B5",     X_D3DFMT_A1R5G5B5,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G5B5A1",     X_D3DFMT_R5G5B5A1,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G6B5",       X_D3DFMT_R5G6B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R6G5B5",       X_D3DFMT_R6G5B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_L6V5U5",       X_D3DFMT_L6V5U5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R8B8",         X_D3DFMT_R8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_G8B8",         X_D3DFMT_G8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_V8U8",         X_D3DFMT_V8U8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_A8L8",         X_D3DFMT_A8L8,          FMT_SWIZZLED,   8    },
    { "D3DFMT_AL8",          X_D3DFMT_AL8,           FMT_SWIZZLED,   8    },
    { "D3DFMT_A8",           X_D3DFMT_A8,            FMT_SWIZZLED,   8    },
    { "D3DFMT_L8",           X_D3DFMT_L8,            FMT_SWIZZLED,   0    },
//  { "D3DFMT_P8",           X_D3DFMT_P8,            FMT_SWIZZLED,   8    }, // Bundler doesn't support (yet)
    { "D3DFMT_L16",          X_D3DFMT_L16,           FMT_SWIZZLED,   0    },
    { "D3DFMT_DXT1",         X_D3DFMT_DXT1,          FMT_COMPRESSED, 1    },
    { "D3DFMT_DXT2",         X_D3DFMT_DXT2,          FMT_COMPRESSED, 8    },
    { "D3DFMT_DXT3",         X_D3DFMT_DXT3,          FMT_COMPRESSED, 8    },
    { "D3DFMT_DXT4",         X_D3DFMT_DXT4,          FMT_COMPRESSED, 8    },
    { "D3DFMT_DXT5",         X_D3DFMT_DXT5,          FMT_COMPRESSED, 8    },
    { "D3DFMT_LIN_A8B8G8R8", X_D3DFMT_LIN_A8B8G8R8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_A8R8G8B8", X_D3DFMT_LIN_A8R8G8B8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_B8G8R8A8", X_D3DFMT_LIN_B8G8R8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_R8G8B8A8", X_D3DFMT_LIN_R8G8B8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_X8R8G8B8", X_D3DFMT_LIN_X8R8G8B8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_X8L8V8U8", X_D3DFMT_LIN_X8L8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_Q8W8V8U8", X_D3DFMT_LIN_Q8W8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_V16U16",   X_D3DFMT_LIN_V16U16,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A4R4G4B4", X_D3DFMT_LIN_A4R4G4B4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_R4G4B4A4", X_D3DFMT_LIN_R4G4B4A4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_A1R5G5B5", X_D3DFMT_LIN_A1R5G5B5,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_R5G5B5A1", X_D3DFMT_LIN_R5G5B5A1,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_X1R5G5B5", X_D3DFMT_LIN_X1R5G5B5,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R5G6B5",   X_D3DFMT_LIN_R5G6B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R6G5B5",   X_D3DFMT_LIN_R6G5B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L6V5U5",   X_D3DFMT_LIN_L6V5U5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_G8B8",     X_D3DFMT_LIN_G8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R8B8",     X_D3DFMT_LIN_R8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8L8",     X_D3DFMT_LIN_A8L8,      FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_V8U8",     X_D3DFMT_LIN_V8U8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_AL8",      X_D3DFMT_LIN_AL8,       FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_L16",      X_D3DFMT_LIN_L16,       FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L8",       X_D3DFMT_LIN_L8,        FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8",       X_D3DFMT_LIN_A8,        FMT_LINEAR    , 8    },
};



//-----------------------------------------------------------------------------
// Name: ConvertTextureFormat()
// Desc: 
// TODO: Make this handle the pitch requirements of small textures
//-----------------------------------------------------------------------------
HRESULT ConvertTextureFormat( VOID* pSrcData, 
                              DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, 
                              VOID* pDstData, DWORD dwDstFormat )
{
    // Create convenient access ptrs
    DWORD* pSrcData32 = (DWORD*)pSrcData;
    BYTE*  pDstData8  =  (BYTE*)pDstData;
    WORD*  pDstData16 =  (WORD*)pDstData;
    DWORD* pDstData32 = (DWORD*)pDstData;

    // Look through all pixels
    for( DWORD z=0; z<dwDepth; z++ )
    {
        for( DWORD y=0; y<dwHeight; y++ )
        {
            for( DWORD x=0; x<dwWidth; x++ )
            {
                // Read src pixel
                FLOAT a = (((*pSrcData32)&0xff000000)>>24L)/255.0f;
                FLOAT r = (((*pSrcData32)&0x00ff0000)>>16L)/255.0f;
                FLOAT g = (((*pSrcData32)&0x0000ff00)>> 8L)/255.0f;
                FLOAT b = (((*pSrcData32)&0x000000ff)>> 0L)/255.0f;
                pSrcData32++;

                // Assign values to non-ARGB channels
                // FLOAT q = a;
                // FLOAT w = r;
                FLOAT v = g;
                FLOAT u = b;
                FLOAT l = (r+g+b)/3;

                // Write dst pixel
                switch( dwDstFormat )
                {
                    case X_D3DFMT_A8R8G8B8:     // case X_D3DFMT_Q8W8V8U8:
                    case X_D3DFMT_LIN_A8R8G8B8: // case X_D3DFMT_LIN_Q8W8V8U8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_X8R8G8B8:     // case X_D3DFMT_X8L8V8U8:
                    case X_D3DFMT_LIN_X8R8G8B8: // case X_D3DFMT_LIN_X8L8V8U8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8B8G8R8:
                    case X_D3DFMT_LIN_A8B8G8R8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(b*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(r*0xff))<< 0L);
                        break;
                    case X_D3DFMT_B8G8R8A8:
                    case X_D3DFMT_LIN_B8G8R8A8:
                        (*pDstData32++) = (((DWORD)(b*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(r*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_R8G8B8A8:
                    case X_D3DFMT_LIN_R8G8B8A8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(b*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A1R5G5B5:
                    case X_D3DFMT_LIN_A1R5G5B5:
                        (*pDstData16++) = (WORD)((((WORD)(a*0x01))<<15L) | 
												 (((WORD)(r*0x1f))<<10L) | 
												 (((WORD)(g*0x1f))<< 5L) | 
												 (((WORD)(b*0x1f))<< 0L));
                        break;
                    case X_D3DFMT_X1R5G5B5:
                    case X_D3DFMT_LIN_X1R5G5B5:
                        (*pDstData16++) = (WORD)((((WORD)(r*0x1f))<<10L) | 
												 (((WORD)(g*0x1f))<< 5L) | 
												 (((WORD)(b*0x1f))<< 0L));
                        break;
                    case X_D3DFMT_R5G5B5A1:
                    case X_D3DFMT_LIN_R5G5B5A1:
                        (*pDstData16++) = (WORD)((((WORD)(r*0x1f))<<11L) | 
												 (((WORD)(g*0x1f))<< 6L) | 
												 (((WORD)(b*0x1f))<< 1L) | 
												 (((WORD)(a*0x01))<< 0L));
                        break;
                    case X_D3DFMT_R5G6B5:
                    case X_D3DFMT_LIN_R5G6B5:
                        (*pDstData16++) = (WORD)((((WORD)(r*0x1f))<<11L) | 
												 (((WORD)(g*0x3f))<< 5L) | 
												 (((WORD)(b*0x1f))<< 0L));
                        break;
                    case X_D3DFMT_R6G5B5:     // case X_D3DFMT_L6V5U5:
                    case X_D3DFMT_LIN_R6G5B5: // case X_D3DFMT_LIN_L6V5U5:
                        (*pDstData16++) = (WORD)((((WORD)(r*0x3f))<<10L) | 
												 (((WORD)(g*0x1f))<< 5L) | 
												 (((WORD)(b*0x1f))<< 0L));
                        break;
                    case X_D3DFMT_A4R4G4B4:
                    case X_D3DFMT_LIN_A4R4G4B4:
                        (*pDstData16++) = (WORD)((((WORD)(a*0x0f))<<12L) | 
												 (((WORD)(r*0x0f))<< 8L) | 
												 (((WORD)(g*0x0f))<< 4L) | 
												 (((WORD)(b*0x0f))<< 0L));
                        break;
                    case X_D3DFMT_R4G4B4A4:
                    case X_D3DFMT_LIN_R4G4B4A4:
                        (*pDstData16++) = (WORD)((((WORD)(r*0x0f))<<12L) | 
												 (((WORD)(g*0x0f))<< 8L) | 
												 (((WORD)(b*0x0f))<< 4L) | 
												 (((WORD)(a*0x0f))<< 0L));
                        break;
                    case X_D3DFMT_R8B8:
                    case X_D3DFMT_LIN_R8B8:
                        (*pDstData16++) = (WORD)((((WORD)(r*0xff))<< 8L) | 
												 (((WORD)(b*0xff))<< 0L));
                        break;
                    case X_D3DFMT_G8B8:     // case X_D3DFMT_V8U8:
                    case X_D3DFMT_LIN_G8B8: // case X_D3DFMT_LIN_V8U8:
                        (*pDstData16++) = (WORD)((((WORD)(g*0xff))<< 8L) | 
												 (((WORD)(b*0xff))<< 0L));
                        break;
                    case X_D3DFMT_A8L8:
                    case X_D3DFMT_LIN_A8L8:
                        (*pDstData16++) = (WORD)((((WORD)(a*0xff))<< 8L) | 
												 (((WORD)(l*0xff))<< 0L));
                        break;
                    case X_D3DFMT_L16:
                    case X_D3DFMT_LIN_L16:
                        (*pDstData16++) = (WORD)(l*0xffff);
                        break;
                    case X_D3DFMT_L8:
                    case X_D3DFMT_LIN_L8:
                        (*pDstData8++)  = (BYTE)(l*0xff);
                        break;
                    case X_D3DFMT_A8:
                    case X_D3DFMT_LIN_A8:
                        (*pDstData8++)  = (BYTE)(a*0xff);
                        break;
                    case X_D3DFMT_AL8:
                    case X_D3DFMT_LIN_AL8:
                        (*pDstData8++)  = (BYTE)(l*0xff);
                        break;
                    case X_D3DFMT_V16U16:
                    case X_D3DFMT_LIN_V16U16:
                        (*pDstData32++) = (((DWORD)(v*0xffff))<<16L) | 
                                          (((DWORD)(u*0xffff))<< 0L);
                        break;
                }
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CBaseTexture()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CBaseTexture::CBaseTexture( CBundler * pBundler )
{
    m_nFormat      = -1;
    m_strFormat[0] = 0;
    m_dwFilter     = D3DX_FILTER_TRIANGLE;
    m_dwLevels     = 1;
	m_ColorKey	   = 0;	// color keying is effectively off, since alpha must already be 0 to match
    m_pBundler     = pBundler;
}




//-----------------------------------------------------------------------------
// Name: ~CBaseTexture()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CBaseTexture::~CBaseTexture()
{
}




//-----------------------------------------------------------------------------
// Name: FormatFromString()
// Desc: Returns an index into the format spec array corresponding to the
//       given string
//-----------------------------------------------------------------------------
int CBaseTexture::FormatFromString( char * strFormat )
{
    int nFormats = sizeof( g_TextureFormats ) / sizeof( g_TextureFormats[0] );
    int i;

    if( strFormat[0] == 0 )
        return 0;

    for( i = 0; i < nFormats; i++ )
    {
        if( !lstrcmpi( strFormat, g_TextureFormats[i].strFormat ) )
            return i;
    }

    return -2;
}




//-----------------------------------------------------------------------------
// Name: FormatFromPCFormat()
// Desc: Returns an index into the format spec array corresponding to the
//       given PC format
//-----------------------------------------------------------------------------
int CBaseTexture::FormatFromPCFormat( D3DFORMAT d3dFormat )
{
    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8: return FormatFromString( "D3DFMT_A8R8G8B8" );
        case D3DFMT_X8R8G8B8: return FormatFromString( "D3DFMT_X8R8G8B8" );
//      case D3DFMT_A8B8G8R8: return FormatFromString( "D3DFMT_A8B8G8R8" );
//      case D3DFMT_B8G8R8A8: return FormatFromString( "D3DFMT_B8G8R8A8" );
//      case D3DFMT_R8G8B8A8: return FormatFromString( "D3DFMT_R8G8B8A8" );
        case D3DFMT_X8L8V8U8: return FormatFromString( "D3DFMT_X8L8V8U8" );
        case D3DFMT_Q8W8V8U8: return FormatFromString( "D3DFMT_Q8W8V8U8" );
        case D3DFMT_V16U16:   return FormatFromString( "D3DFMT_V16U16" );
        case D3DFMT_A4R4G4B4: return FormatFromString( "D3DFMT_A4R4G4B4" );
//      case D3DFMT_R4G4B4A4: return FormatFromString( "D3DFMT_R4G4B4A4" );
        case D3DFMT_X1R5G5B5: return FormatFromString( "D3DFMT_X1R5G5B5" );
        case D3DFMT_A1R5G5B5: return FormatFromString( "D3DFMT_A1R5G5B5" );
//      case D3DFMT_R5G5B5A1: return FormatFromString( "D3DFMT_R5G5B5A1" );
        case D3DFMT_R5G6B5:   return FormatFromString( "D3DFMT_R5G6B5" );
//      case D3DFMT_R6G5B5:   return FormatFromString( "D3DFMT_R6G5B5" );
        case D3DFMT_L6V5U5:   return FormatFromString( "D3DFMT_L6V5U5" );
//      case D3DFMT_R8B8:     return FormatFromString( "D3DFMT_R8B8" );
//      case D3DFMT_G8B8:     return FormatFromString( "D3DFMT_G8B8" );
        case D3DFMT_V8U8:     return FormatFromString( "D3DFMT_V8U8" );
        case D3DFMT_A8L8:     return FormatFromString( "D3DFMT_A8L8" );
//      case D3DFMT_AL8:      return FormatFromString( "D3DFMT_AL8" );
        case D3DFMT_A8:       return FormatFromString( "D3DFMT_A8" );
        case D3DFMT_L8:       return FormatFromString( "D3DFMT_L8" );
//      case D3DFMT_A8R8G8B8: return FormatFromString( "D3DFMT_P8" );
//      case D3DFMT_L16:      return FormatFromString( "D3DFMT_L16" );
        case D3DFMT_DXT1:     return FormatFromString( "D3DFMT_DXT1" );
        case D3DFMT_DXT2:     return FormatFromString( "D3DFMT_DXT2" );
//      case D3DFMT_DXT3:     return FormatFromString( "D3DFMT_DXT3" );
        case D3DFMT_DXT4:     return FormatFromString( "D3DFMT_DXT4" );
//      case D3DFMT_DXT5:     return FormatFromString( "D3DFMT_DXT5" );
    }

    return -2;
}




//-----------------------------------------------------------------------------
// Name: LoadImage()
// Desc: Loads source and alphasource surfaces
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::LoadImage( CHAR* strSource, CHAR* strAlphaSource, CImage** ppImage )
{
    CImage             ColorImage;
    CImage             AlphaImage;
    CImage*            pResizedColorImage = NULL;
    CImage*            pResizedAlphaImage = NULL;
    HRESULT hr; 

    // Add the path (if necessary) to the source filename
    CHAR strImageFilePath[MAX_PATH];
    if( strchr( strSource, ':' ) )
        strcpy( strImageFilePath, strSource );
    else
    {
        strcpy( strImageFilePath, m_pBundler->m_strPath );
        strcat( strImageFilePath, strSource );
    }

    // Load the texture from the source file
    hr = ColorImage.Load( strImageFilePath );
    if( FAILED( hr ) )
        return hr;

    // Depalettize any palettized images
    if( D3DFMT_P8 == ColorImage.m_Format )
        ColorImage.Depalettize();

    if( strAlphaSource[0] )
    {
        // Add the path (if necessary) to the source filename
        CHAR strImageFilePath[MAX_PATH];
        if( strchr( strSource, ':' ) )
            strcpy( strImageFilePath, strAlphaSource );
        else
        {
            strcpy( strImageFilePath, m_pBundler->m_strPath );
            strcat( strImageFilePath, strAlphaSource );
        }

        // Load the texture from the alpha source file
        hr = AlphaImage.Load( strImageFilePath );
        if( FAILED( hr ) )
            return hr;

        // Can't currently deal with palettized images
        if( D3DFMT_P8 == AlphaImage.m_Format )
            return E_FAIL;
    }

    // Determine final texture size
    DWORD dwWidth  = ColorImage.m_Width;
    DWORD dwHeight = ColorImage.m_Height;
    
    if( strAlphaSource[0] )
    {
        if( dwWidth  < AlphaImage.m_Width  )   dwWidth  = AlphaImage.m_Width;
        if( dwHeight < AlphaImage.m_Height )   dwHeight = AlphaImage.m_Height;
    }

    // Do the size conversion for the source image
    pResizedColorImage = new CImage( ColorImage.m_Width, ColorImage.m_Height, D3DFMT_A8R8G8B8 );
    hr = LoadImageFromImage( pResizedColorImage, &ColorImage, m_dwFilter, m_ColorKey );

    if( strAlphaSource[0] )
    {
        // Do the size conversion for the alpha source image
        pResizedAlphaImage = new CImage( AlphaImage.m_Width, AlphaImage.m_Height, AlphaImage.m_Format );
        hr = LoadImageFromImage( pResizedAlphaImage, &AlphaImage, m_dwFilter, 0 );
    }

    // Merge in the alpha channel
    if( strAlphaSource[0] )
    {
        DWORD* pColorBits = (DWORD*)pResizedColorImage->m_pData;
        DWORD* pAlphaBits = (DWORD*)pResizedAlphaImage->m_pData;

        for( DWORD yp = 0; yp < dwHeight; yp++ )
        {
            for( DWORD xp = 0; xp < dwWidth; xp++ )
            {
                DWORD dwAlpha = (*pAlphaBits) << 24;
                (*pColorBits) &= 0x00ffffff;
                (*pColorBits) |= dwAlpha;

                pColorBits++;
                pAlphaBits++;
            }
        }
    }
        
    // Return the surface in the output parameter
    (*ppImage) = pResizedColorImage;

    delete pResizedAlphaImage;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadImageUsingD3DX()
// Desc: Loads source and alphasource surfaces. This should be used after other
//       load attempts failed, since D3DX forces surfaces to have dimensions
//       that are a power of two.
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::LoadImageUsingD3DX( CHAR* strSource, CHAR* strAlphaSource, 
                                            CImage** ppImage )
{
    D3DSURFACE_DESC    ColorImageDesc;
    D3DSURFACE_DESC    AlphaImageDesc;
    LPDIRECT3DSURFACE8 pOrigColorSurface;
    LPDIRECT3DSURFACE8 pOrigAlphaSurface;
    LPDIRECT3DSURFACE8 pResizedColorSurface;
    LPDIRECT3DSURFACE8 pResizedAlphaSurface;
    HRESULT hr; 

    if( strAlphaSource[0] )
        printf( "WARNING: Couldn't load %s and/or %s natively - attempting to use D3D runtime.\n", strSource, strAlphaSource );
    else
        printf( "WARNING: Couldn't load %s natively - attempting to use D3D runtime.\n", strSource );

    hr = m_pBundler->InitD3D();
    if( FAILED( hr ) )
    {
        m_pBundler->ErrorMsg( "The bundler requires the D3D reference rasterizer in order\n" );
        m_pBundler->ErrorMsg( "to load certain types of files, but was unable to create it.\n" );
        m_pBundler->ErrorMsg( "Try using BMP or TGA files instead of DDS or JPG files.\n" );
        return hr;
    }

    // Add the path (if necessary) to the source filename
    CHAR strImageFilePath[MAX_PATH];
    if( strchr( strSource, ':' ) )
        strcpy( strImageFilePath, strSource );
    else
    {
        strcpy( strImageFilePath, m_pBundler->m_strPath );
        strcat( strImageFilePath, strSource );
    }


    // Load the texture from the source file
    LPDIRECT3DTEXTURE8 pImageTexture;
    hr = D3DXCreateTextureFromFileEx( m_pBundler->m_pd3ddev, strImageFilePath, 
                                      D3DX_DEFAULT, D3DX_DEFAULT, 1,
                                      0, D3DFMT_UNKNOWN, D3DPOOL_SYSTEMMEM,
                                      D3DX_DEFAULT, D3DX_DEFAULT, 0,
                                      NULL, NULL, &pImageTexture );
    if( FAILED( hr ) )
    {
        m_pBundler->ErrorMsg( "Couldn't load image <%s>\n", strSource );
        return hr;
    }

    // Get a surface for the image
    pImageTexture->GetSurfaceLevel( 0, &pOrigColorSurface );
    pImageTexture->Release();
    pOrigColorSurface->GetDesc( &ColorImageDesc );

    if( m_nFormat < 0 )
    {
        m_nFormat   = FormatFromPCFormat( ColorImageDesc.Format );
        if( m_nFormat < 0 )
        {
            m_pBundler->ErrorMsg( "Unssupported format for image <%s>\n", strSource );
            return E_FAIL;
        }
        lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );
    }

    if( strAlphaSource[0] )
    {
        // Add the path (if necessary) to the source filename
        CHAR strImageFilePath[MAX_PATH];
        if( strchr( strSource, ':' ) )
            strcpy( strImageFilePath, strAlphaSource );
        else
        {
            strcpy( strImageFilePath, m_pBundler->m_strPath );
            strcat( strImageFilePath, strAlphaSource );
        }

        // Load the texture from the alpha source file
        LPDIRECT3DTEXTURE8 pAlphaTexture;
        hr = D3DXCreateTextureFromFileEx( m_pBundler->m_pd3ddev, strImageFilePath, 
                                          D3DX_DEFAULT, D3DX_DEFAULT, 1,
                                          0, D3DFMT_UNKNOWN, D3DPOOL_DEFAULT,
                                          D3DX_DEFAULT, D3DX_DEFAULT, 0,
                                          NULL, NULL, &pAlphaTexture );
        if( FAILED( hr ) )
        {
            m_pBundler->ErrorMsg( "Couldn't load image <%s>\n", strAlphaSource );
            return hr;
        }

        pAlphaTexture->GetSurfaceLevel( 0, &pOrigAlphaSurface );
        pAlphaTexture->Release();
        pOrigAlphaSurface->GetDesc( &AlphaImageDesc );
    }

    // Determine final texture size
    DWORD dwWidth  = ColorImageDesc.Width;
    DWORD dwHeight = ColorImageDesc.Height;
    
    if( strAlphaSource[0] )
    {
        if( dwWidth  < AlphaImageDesc.Width  )   dwWidth  = AlphaImageDesc.Width;
        if( dwHeight < AlphaImageDesc.Height )   dwHeight = AlphaImageDesc.Height;
    }

    // Do the size conversion for the source image
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                    &pResizedColorSurface );

    hr = D3DXLoadSurfaceFromSurface( pResizedColorSurface, NULL, NULL, 
                                     pOrigColorSurface, NULL, NULL,
                                     m_dwFilter, 0 );

    if( strAlphaSource[0] )
    {
        // Do the size conversion for the alpha source image
        hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                        &pResizedAlphaSurface );

        hr = D3DXLoadSurfaceFromSurface( pResizedAlphaSurface, NULL, NULL, 
                                         pOrigAlphaSurface, NULL, NULL,
                                         m_dwFilter, 0 );
    }


    // Merge in the alpha channel
    if( strAlphaSource[0] )
    {
        D3DLOCKED_RECT lockColor;
        D3DLOCKED_RECT lockAlpha;
        hr = pResizedColorSurface->LockRect( &lockColor, NULL, 0 );
        hr = pResizedAlphaSurface->LockRect( &lockAlpha, NULL, 0 );

        DWORD* pColorBits = (DWORD*)lockColor.pBits;
        DWORD* pAlphaBits = (DWORD*)lockAlpha.pBits;

        for( DWORD yp = 0; yp < dwHeight; yp++ )
        {
            for( DWORD xp = 0; xp < dwWidth; xp++ )
            {
                DWORD dwAlpha = (*pAlphaBits) << 24;
                (*pColorBits) &= 0x00ffffff;
                (*pColorBits) |= dwAlpha;

                pColorBits++;
                pAlphaBits++;
            }
        }

        pResizedColorSurface->UnlockRect();
        pResizedAlphaSurface->UnlockRect();
    }

    
    // Copy everything over to the output CImage
    (*ppImage) = new CImage( dwWidth, dwHeight, D3DFMT_A8R8G8B8 );
    D3DLOCKED_RECT lr;
    pResizedColorSurface->LockRect( &lr, NULL, D3DLOCK_READONLY );
	if ((UINT)lr.Pitch == dwWidth * 4)
		memcpy( (*ppImage)->m_pData, lr.pBits, lr.Pitch * dwHeight);
	else
	{
		// Copy row by row
		for (UINT iRow = 0; iRow < dwHeight; iRow++)
		{
			BYTE *pRowSrc = (BYTE *)(lr.pBits) + lr.Pitch * iRow;
			BYTE *pRowDst = (BYTE *)((*ppImage)->m_pData) + (*ppImage)->m_Pitch * iRow;
			memcpy( pRowDst, pRowSrc, dwWidth * 4);
		}
	}
    pResizedColorSurface->UnlockRect();

    // Release the color surfaces
    pOrigColorSurface->Release();
    pResizedColorSurface->Release();

    // Release the alpha surfaces
    if( strAlphaSource[0] )
    {
        pOrigAlphaSurface->Release();
        pResizedAlphaSurface->Release();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ResizeImage()
// Desc: Convert the surface to the new width, height, and format
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::ResizeImage( DWORD dwWidth, DWORD dwHeight, 
                                     CImage** ppImage )
{
    HRESULT hr; 
    CImage* pOldImage = *ppImage;

	// if size and format are the same, leave alone
	if (pOldImage->m_Width == dwWidth
		&& pOldImage->m_Height == dwHeight
		&& pOldImage->m_Format == D3DFMT_A8R8G8B8)
		return S_FALSE;

    *ppImage = new CImage( dwWidth, dwHeight, D3DFMT_A8R8G8B8 );

    hr = LoadImageFromImage( *ppImage, pOldImage, m_dwFilter, 0 );

    // Release the old surface
    delete pOldImage;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteSwizzledTextureData()
// Desc: Swizzles the texture data to NVidia's swizzled format.  
//       XGSwizzleRect requires that the memory being swizzled to is 16-byte
//       aligned.
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
                                              DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a sizzled texture
    // is Width * BytesPerTexel
    DWORD  dwBytesPerTexel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD  dwPitch         = dwWidth*dwBytesPerTexel;
    DWORD  dwTextureSize   = dwPitch * dwHeight * dwDepth;
    BYTE*  pBitsUnaligned  = new BYTE[ dwTextureSize + 16 ];
    int    temp      = (int)pBitsUnaligned;
    BYTE*  pBitsTemp = (BYTE*)(( temp + 15 ) & ~15);   // 16-byte aligned ptr.

    // Swizzle the data into a temporary buffer, and then copy it back
    XGSwizzleBox( pBits, 0, 0, NULL, pBitsTemp, dwWidth, dwHeight, dwDepth,
                  NULL, dwBytesPerTexel );

    if( FAILED( m_pBundler->WriteData( pBitsTemp, dwTextureSize ) ) )
        return 0;

    delete[] pBitsUnaligned;

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: WriteCompressedTextureData()
// Desc: Compresses the texture data
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteCompressedTextureData( VOID* pSrcBits, DWORD dwWidth, 
                                                DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a compressed texture
    // is Width*2 or Width*4, depending on the compression 
    DWORD dwBlockSize;
    DWORD dwCompressedSize;
//    DWORD dwSrcPitch   = (dwWidth*4+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD dwSrcPitch   = dwWidth*sizeof(DWORD);
    BOOL  bPreMultiply = g_TextureFormats[m_nFormat].strFormat[10] == '2' ||
                         g_TextureFormats[m_nFormat].strFormat[10] == '4';

    switch( g_TextureFormats[m_nFormat].dwXboxFormat )
    {
        case X_D3DFMT_DXT1: 
            dwBlockSize      = 8;
            dwCompressedSize = dwWidth*dwHeight/2; 
            break;
        case X_D3DFMT_DXT2:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        case X_D3DFMT_DXT4:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        default:
            return E_FAIL;
    }

    // Allocate space for the compressed data
    BYTE* pCompressedData = new BYTE[dwDepth*dwCompressedSize];
    BYTE* pDstBits        = pCompressedData;

    for( DWORD i=0; i<dwDepth; i++ )
    {
        // Compress the data
        if( FAILED( XGCompressRect( pDstBits,
                                    D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat),
                                    0, dwWidth, dwHeight, pSrcBits, 
                                    D3DFORMAT(X_D3DFMT_LIN_A8R8G8B8), 
                                    dwSrcPitch, 0.5,
                                    bPreMultiply ? XGCOMPRESS_PREMULTIPLY : 0 ) ) )
            return 0;

        pSrcBits = (BYTE*)pSrcBits + dwSrcPitch*dwHeight;
        pDstBits = (BYTE*)pDstBits + dwCompressedSize;
    }

    if( dwDepth == 1 )
    {
        // Write the compressed data
        if( FAILED( m_pBundler->WriteData( pCompressedData, dwCompressedSize ) ) )
            return 0;
    }
    else
    {
        // For volume textures, compressed blocks are stored in block linear
        // format, so we need to write them in the correct order.
        DWORD dwNumXBlocks = dwWidth/4;
        DWORD dwNumYBlocks = dwHeight/4;
        // DWORD dwNumWBlocks = (dwDepth<4) ? 1 : dwDepth/4;

        for( DWORD w=0; w<dwDepth; w+=4 )
        {
            for( DWORD by=0; by<dwNumYBlocks; by++ )
            {
                for( DWORD bx=0; bx<dwNumXBlocks; bx++ )
                {
                    BYTE* pBits0 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+0)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits1 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+1)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits2 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+2)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits3 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+3)*dwNumXBlocks*dwNumYBlocks ) ];
    
                    // Write the compressed data
                    if( dwDepth >= 1 ) 
                        m_pBundler->WriteData( pBits0, dwBlockSize );
                    if( dwDepth >= 2 ) 
                        m_pBundler->WriteData( pBits1, dwBlockSize );
                    if( dwDepth >= 3 ) 
                        m_pBundler->WriteData( pBits2, dwBlockSize );
                    if( dwDepth >= 4 ) 
                        m_pBundler->WriteData( pBits3, dwBlockSize );
                }
            }
        }
    }

    // Cleanup
    delete[] pCompressedData;

    // Return the number of bytes written
    return dwDepth*dwCompressedSize;
}




//-----------------------------------------------------------------------------
// Name: WriteLinearTextureData()
// Desc: 
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
                                            DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a linear texture
    // needs to be a multiple of 64 bytes.
    DWORD dwBytesPerTexel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD dwPitch         = (dwWidth*dwBytesPerTexel+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD dwTextureSize   = dwPitch * dwHeight * dwDepth;

    // Write the texture
    if( dwPitch == dwWidth*dwBytesPerTexel )
    {
        if( FAILED( m_pBundler->WriteData( pBits, dwTextureSize ) ) )
            return 0;
    }
    else
    {
        // For textures with non-conforming pitches, write the data aligned
        // according to the pitch
        BYTE* pTempBits = (BYTE*)pBits;
        BYTE  pZeroes[64];
        ZeroMemory( pZeroes, 64 );
        
        for( DWORD z=0; z<dwDepth; z++ )
        {
            for( DWORD y=0; y<dwHeight; y++ )
            {
                // Write data
                if( FAILED( m_pBundler->WriteData( pTempBits, dwWidth*dwBytesPerTexel ) ) )
                    return 0;
                pTempBits += dwWidth*dwBytesPerTexel;

                // Pad to 64-bytes
                if( FAILED( m_pBundler->WriteData( pZeroes, dwPitch - dwWidth*dwBytesPerTexel ) ) )
                    return 0;
            }
        }
    }

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: SaveImage()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveImage( DWORD* pcbData, DWORD dwLevels, CImage* pImage )
{
    HRESULT hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    DWORD dwWidth = pImage->m_Width;
    DWORD dwHeight = pImage->m_Height;

    // Allocate memory for converting the surface format
    VOID* pSurfaceData = (VOID*)new BYTE[dwWidth*dwHeight*4];

    // Loop over each mipmap level of the texture
    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        CImage* pMipmap = new CImage( dwWidth, dwHeight, pImage->m_Format );
        hr = LoadImageFromImage( pMipmap, pImage, m_dwFilter, 0 );

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( pMipmap->m_pData, dwWidth, dwHeight, 1 );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( pMipmap->m_pData, dwWidth, dwHeight, 1,
                                  pSurfaceData, g_TextureFormats[m_nFormat].dwXboxFormat );

            if( g_TextureFormats[m_nFormat].Type == FMT_SWIZZLED )
            {
                // If we're writing a swizzled format, swizzle the texture data
                (*pcbData) += WriteSwizzledTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
            else
            {
                // Write out linear surface data
                (*pcbData) += WriteLinearTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
        }

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            dwWidth  = max( dwWidth, 4 );
            dwHeight = max( dwHeight, 4 );
        }
            
        // Release the mipmap level
    }

    // Cleanup
    delete[] pSurfaceData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveVolumeTexture()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, CVolume* pVolume )
{
    HRESULT        hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Get the surface desc, used to create mipmap levels
    DWORD dwWidth  = pVolume->m_Width;
    DWORD dwHeight = pVolume->m_Height;
    DWORD dwDepth  = pVolume->m_Depth;

    // Allocate memory for converting the surface format
    VOID* pVolumeData = (VOID*)new BYTE[dwWidth*dwHeight*dwDepth*4];

    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        CVolume* pTempVolume = new CVolume( dwWidth, dwHeight, dwDepth, pVolume->m_Format );

        LoadVolumeFromVolume( pTempVolume, pVolume, m_dwFilter, 0 );

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( pTempVolume->m_pData, dwWidth, 
                                                      dwHeight, dwDepth );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( pTempVolume->m_pData, dwWidth, dwHeight, dwDepth,
                                  pVolumeData, g_TextureFormats[m_nFormat].dwXboxFormat );

            // If we're writing a swizzled format, swizzle the texture data
            (*pcbData) += WriteSwizzledTextureData( pVolumeData, dwWidth, dwHeight, dwDepth );
        }

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;
        if( dwDepth >= 2 )
            dwDepth >>= 1;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            dwWidth  = max( dwWidth, 4 );
            dwHeight = max( dwHeight, 4 );
        }
            
        // Release the mipmap level
        delete pTempVolume;
    }

    // Cleanup
    delete[] pVolumeData;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\axisangle.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: axisangle.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Axis-angle curve to quaternion curve conversion.
//-----------------------------------------------------------------------------
#include "stdafx.h"

inline FLOAT Lerp(FLOAT A, FLOAT B, FLOAT fLerpValue)
{
	return A + fLerpValue * (B - A);
}

//////////////////////////////////////////////////////////////////////
// Set quaternion keys to match axis/angle rotation, with reasonable precision.
//
// NOTE: The other alternative is to add axis/angle animated rotation
// to AnimRotate, but this makes the animation package more complex.
//
HRESULT MatchAxisAngleCurve(AnimRotate *pRotate, CONST D3DXVECTOR3 *pvAxis, CONST AnimCurve *pAngle, FLOAT feps)
{
	// clear arrays and copy over the curve duration, etc.
	if (pRotate->m_curve.m_rKeyTimes) delete pRotate->m_curve.m_rKeyTimes;
	if (pRotate->m_curve.m_rKeys) delete pRotate->m_curve.m_rKeys;
	pRotate->m_curve.m_fBegin = pAngle->m_fBegin;
    pRotate->m_curve.m_fDurationInverse = pAngle->m_fDurationInverse;
	pRotate->m_curve.m_KeyCount = 0;
	pRotate->m_curve.m_KeySize = 4;
	pRotate->m_curve.m_rKeyTimes = NULL;
	pRotate->m_curve.m_rKeys = NULL;
	
	// Set the quaternion directly if there's just one key
	if (pAngle->m_KeyCount == 1)
	{
		pRotate->m_curve.m_KeyCount = 1;
		pRotate->m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		pRotate->m_curve.m_rKeyTimes[0] = pAngle->m_rKeyTimes[0];
		pRotate->m_curve.m_rKeys = new FLOAT [ 1 * 4 ];
		D3DXQuaternionRotationAxis((D3DXQUATERNION *)pRotate->m_curve.m_rKeys, pvAxis, pAngle->m_rKeys[0] );
		return S_OK;
	}

	// Scratch space
	const int MAX_KEYS = 100;
	if (pAngle->m_KeyCount > MAX_KEYS)
		return E_NOTIMPL;
	FLOAT rKeyTimes[MAX_KEYS];
	D3DXQUATERNION rKeys[MAX_KEYS];
	UINT KeyCount = 0;
	
	// For each segment of the input curve, start by setting the quaternion keys
	// to be equal to the input curve, then keep on increasing the number of samples
	// until the desired precision is matched.
	FLOAT fTime0 = pAngle->m_rKeyTimes[0];
	FLOAT fAngle0 = pAngle->m_rKeys[0];
	rKeyTimes[ 0 ] = fTime0;
	D3DXQuaternionRotationAxis(&rKeys[0], pvAxis, fAngle0);
	KeyCount = 1;
	CONST UINT nSample = 10;	// intermediate samples to test quality of match
	CONST FLOAT fLerpSampleScale = 1.f / (nSample - 1);
	CONST FLOAT fFractionMin = 1e-6f;
	for (UINT iKeyAngle = 1; iKeyAngle < pAngle->m_KeyCount; iKeyAngle++)
	{
		FLOAT fFraction = 1.f;	// start with whole interval
		
	try_again: // goto makes restarting from within for-loop easier
		if (KeyCount >= MAX_KEYS)
			return E_NOTIMPL;	// too many keys needed to get desired precision
		FLOAT fTime1 = Lerp(fTime0, pAngle->m_rKeyTimes[ iKeyAngle ], fFraction);
		FLOAT fAngle1 = Lerp(fAngle0, pAngle->m_rKeys[ iKeyAngle ], fFraction);
		rKeyTimes[ KeyCount ] = fTime1;
		D3DXQuaternionRotationAxis(&rKeys[ KeyCount ], pvAxis, fAngle1);

		// Check the error at a few intermediate points
		for (UINT iSample = 1; iSample < nSample; iSample++)
		{
			FLOAT fLerp = (FLOAT)iSample * fLerpSampleScale;
			FLOAT fAngle = fAngle0 + fLerp * (fAngle1 - fAngle0);
			D3DXQUATERNION A;
			D3DXQuaternionRotationAxis(&A, pvAxis, fAngle);
			D3DXQUATERNION B;
			D3DXQuaternionSlerp(&B, &rKeys[ KeyCount - 1 ], &rKeys[ KeyCount ], fLerp);
			D3DXQUATERNION C = B - A;
			FLOAT fError = D3DXQuaternionLengthSq(&C);
			if (fError > feps)
			{
				fFraction *= 0.5f;	// try again with a smaller fraction
				if (fFraction < fFractionMin)
					return E_FAIL;	// Could not find a good quaternion key, no matter how small the fraction.
				goto try_again;
			}
		}

		// Error was small enough at all the intermediate points, so keep the key
		KeyCount++;
		fTime0 = fTime1;
		fAngle0 = fAngle1;
		if (fFraction < 1.f)
		{
			fFraction = 1.f;
			goto try_again; // try again to span all the way to current key
		}
	}

	// Copy keys to quaternion curve
	pRotate->m_curve.m_KeyCount = KeyCount;
	pRotate->m_curve.m_KeySize = 4;
	pRotate->m_curve.m_rKeyTimes = new FLOAT [ KeyCount ];
	pRotate->m_curve.m_rKeys = new FLOAT [ KeyCount * 4 ];
	if (pRotate->m_curve.m_rKeyTimes == NULL
		|| pRotate->m_curve.m_rKeys == NULL)
		return E_OUTOFMEMORY;
	memcpy(pRotate->m_curve.m_rKeyTimes, rKeyTimes, sizeof(FLOAT) * KeyCount );
	memcpy(pRotate->m_curve.m_rKeys, rKeys, sizeof(FLOAT) * KeyCount * 4);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\animate.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: animate.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of the XBContent class for skeleton animation, i.e.
//  the <Frame> <Matrix> and <animate> tags.
//-----------------------------------------------------------------------------
#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// FrameExtra routines.
//
FrameExtra::FrameExtra()
{
	D3DXMatrixIdentity(&m_Matrix);			// initialize frame
	ZeroMemory(m_strName, sizeof(m_strName)); // empty identifier
	m_pChild = NULL;
	m_pNext = NULL;
	m_pAnim = NULL;
	m_pAnimLocal = NULL;
	m_Offset = 0;
}

FrameExtra::~FrameExtra()
{
	// does nothing
}

HRESULT FrameExtra::AddChild(FrameExtra *pFrame)
{
	// Add to end of child list
	Frame **ppFrameEnd = &m_pChild;
	while (*ppFrameEnd != NULL)
		ppFrameEnd = &((*ppFrameEnd)->m_pNext);
	*ppFrameEnd = pFrame;
	return S_OK;
}

HRESULT FrameExtra::Premult(AnimFrame *pAnim)
{
	if (pAnim == NULL)
		return S_OK;	// nothing to premultiply
	
	// Add to animation expression
	if (m_pAnim == NULL)
	{
#if 1
		m_pAnim = pAnim;
		return S_OK;
#else
		if (D3DXMatrixIsIdentity(&m_Matrix))
		{
			// No animation has been set, and the current matrix
			// is the identity, so no need to concatenate.
			m_pAnim = pAnim;
			return S_OK;
		}
		else
		{
			// If the current transformation has already been set
			// with scale's and translate's, etc., then we need
			// to include it in the animation expression.
			m_pAnim = new AnimMatrix(&m_Matrix);
			if (m_pAnim == NULL)
				return E_OUTOFMEMORY;
		}
#endif
	}

	AnimConcat *pAnimConcat = new AnimConcat;
	if (pAnimConcat == NULL)
		return E_OUTOFMEMORY;
	pAnimConcat->m_pAnimA = pAnim;		// prepend matrix...
	pAnimConcat->m_pAnimB = m_pAnim;	// ... to what was there before
	m_pAnim = pAnimConcat;
	return S_OK;
}

HRESULT FrameExtra::DeleteHierarchy(FrameExtra *pFrame)
{
	FrameExtra *rFrameStack[FRAME_MAX_STACK];
	int iFrameStack = 1;	// depth of stack
	rFrameStack[0] = pFrame;
	while (iFrameStack)
	{
		// Pop the stack and process the top element
		iFrameStack--;
		pFrame = rFrameStack[iFrameStack];
		
		// Push sibling
		if (pFrame->m_pNext != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack] = (FrameExtra *)(pFrame->m_pNext);
			iFrameStack++;
		}
		
		// Push child
		if (pFrame->m_pChild != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack] = (FrameExtra *)(pFrame->m_pChild);
			iFrameStack++;
		}
	
		// Delete the current frame
		delete pFrame;
	}
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Frame Handler
//
HRESULT XBContent::BeginFrame(ISAXAttributes *pAttributes)
{
	FrameExtra *pFrameParent = NULL;
	if (m_rContextStack[m_iContext].m_Context == Frame_Context)
		pFrameParent = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	else
	{
		// We're starting a frame context, so the current animation list should be empty
		// TODO: What about multiple, independent animations of the same hierarchy?
		// TODO: What about separate animation time-lines for separate parts?
		if (m_pAnimList != NULL)
			ignorableWarning(m_pLocator, L"Clearing animation list (which should have been empty already.)\n", E_NOTIMPL);
		m_pAnimList = NULL;
	}
	PushContext(Frame_Context);

	// Create a new frame and add to the parent list
	FrameExtra *pFrame = new FrameExtra;						// make a new frame
	if (pFrame == NULL)
		return E_OUTOFMEMORY;
	if (pFrameParent)
		pFrameParent->AddChild(pFrame);
	m_rContextStack[m_iContext].m_pData = pFrame;	// keep frame pointer in context data

	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(id))
		{
			// Set frame identifier
			CHAR *strID = CharString(pwchValue, cchValue);
			ZeroMemory(pFrame->m_strName, FRAME_IDENTIFIER_SIZE);
			strncpy(pFrame->m_strName, strID, FRAME_IDENTIFIER_SIZE);
			pFrame->m_strName[FRAME_IDENTIFIER_SIZE - 1] = 0;	// make sure string is terminated
		}
		else if (MATCH(name))
		{
			// TODO: make names and ids work differently.  Id's must be unique.  Names should generate id's.
			
			// Set frame name
			CHAR *strID = CharString(pwchValue, cchValue);
			ZeroMemory(pFrame->m_strName, FRAME_IDENTIFIER_SIZE);
			strncpy(pFrame->m_strName, strID, FRAME_IDENTIFIER_SIZE);
			pFrame->m_strName[FRAME_IDENTIFIER_SIZE - 1] = 0;	// make sure string is terminated
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	return S_OK;
}

HRESULT XBContent::EndFrame()
{
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PopContext();

	if (m_rContextStack[m_iContext].m_Context == Frame_Context)
	{
		// Not the last frame in the hierarchy, so continue without
		// dumping skeleton resource
		return S_OK;
	}
	else
	{
		// This is the closing of a top-level frame, so write skeleton
		// and associated animation resources.
		HRESULT hr = WriteSkeleton(pFrame);
		if (FAILED(hr))
			return hr;
	
		// If the skeleton is animated, also make an animation resource that
		// points to the skeleton.
		if (m_pAnimList != NULL)
		{
			hr = WriteAnimation(m_pAnimList);
			if (FAILED(hr))
				return hr;

			// Clear animation list
			AnimLink *pAnimSrc = m_pAnimList;
			while (pAnimSrc)
			{
				AnimLink *pNext = pAnimSrc->m_pNext;
				delete pAnimSrc;
				
				// TODO: delete AnimFrame hierarchy, too
				
				pAnimSrc = pNext;
			}
			m_pAnimList = NULL;
		}

		// Clear the frame hierarchy
		hr = FrameExtra::DeleteHierarchy(pFrame);
		if (FAILED(hr))
			return hr;
		
		return S_OK;
	}
}

//////////////////////////////////////////////////////////////////////
// Matrix Handler
//
HRESULT XBContent::BeginMatrix(ISAXAttributes *pAttributes)
{
	// sanity check
	if (m_rContextStack[m_iContext].m_Context != Frame_Context
		&& m_rContextStack[m_iContext].m_Context != Matrix_Context)
		return fatalError(m_pLocator,
						  L"<Matrix> tag must be within <Frame> or <Matrix> context\n",
						  E_INVALIDARG);
	
	// Save context
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PushContext(Matrix_Context);
	m_rContextStack[m_iContext].m_pData = pFrame;
	
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(value))
		{
			D3DXMATRIX mat;
			UINT iValueCount = 0;
			CHAR *strFull = CharString(pwchValue, cchValue);
			CHAR *strSeparators = " \t\n";
			CHAR *strBuff = strtok(strFull, strSeparators);
			CHAR *pEnd;
			while (strBuff != NULL)
			{
				if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
				{
					FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
					if (*pEnd != '\0')
					{
						m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
						// leave as just a warning
					}
					if (iValueCount >= 16)
						return fatalError(m_pLocator, L"<Matrix> has too many values (>16).\n", E_INVALIDARG);
					((FLOAT *)mat)[iValueCount] = fValue;
					iValueCount++;
				}
				else
				{
					m_pBundler->ErrorMsg("Can not parse matrix value \"%s\"\n", strBuff);
					return E_FAIL;
				}

				// Get next token
				strBuff = strtok(NULL, strSeparators);
			}
			if (iValueCount < 16)
				return fatalError(m_pLocator, L"<Matrix> has too few values.\n", E_INVALIDARG);
			
			// Premultiply frame matrix
			D3DXMatrixMultiply(&pFrame->m_Matrix, &mat, &pFrame->m_Matrix);

			// If an animation expression is already active, prepare to add matrix as a key
			// If there's an <animate> tag following, it will overwrite this 1-key animation.
			/*
			if (pFrame->m_pAnim)
			{
				if (!D3DXMatrixIsIdentity(&mat))
				{
				*/
					if (pFrame->m_pAnimLocal != NULL)
						return fatalError(m_pLocator, L"Recursive <Matrix> elements not implemented.\n", E_NOTIMPL);
					pFrame->m_pAnimLocal = new AnimMatrix( &mat );	// static matrix key
					if (pFrame->m_pAnimLocal == NULL)
						return E_OUTOFMEMORY;
					/*
				}
			}
			*/
		}
		else if (MATCH(name))
		{
			// TODO: save the name for use later
			// CHAR *strName = CharString(pwchValue, cchValue);
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	return S_OK;
}

HRESULT XBContent::EndMatrix()
{
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PopContext();
 
	// Add to frame's animation list
	if (pFrame->m_pAnimLocal != NULL)
	{
		pFrame->Premult(pFrame->m_pAnimLocal);
		pFrame->m_pAnimLocal = NULL;
	}

	// TODO: why do we need m_pAnimList?  Can't we just leave the animations
	// in the frame hierarchy using the m_pAnim pointers?   For more general
	// animation, we do need to keep track of the animations somewhere.
	
	// If this is the final close </Matrix> tag before we go back to
	// a frame context, add animation to skeleton animation list.
	if (m_rContextStack[m_iContext].m_Context == Frame_Context)
	{
		FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
		if (pFrame->m_pAnim != NULL)
		{
#if ANIM_INTERPRETED
			// Simple optimization.  If the animation is constant, skip it.
			if (pFrame->m_pAnim->IsConstant())
			{
				// TODO: delete pAnim
			}
			else
#endif
			{
			AnimLink *pAnimLink = new AnimLink;
			if (pAnimLink == NULL)
				return fatalError(m_pLocator, L"<Matrix> can not allocate linked list element.\n", E_OUTOFMEMORY);
			pAnimLink->m_pAnimFrame = pFrame->m_pAnim;
			pAnimLink->m_pFrame = pFrame;	// bind animation to current frame
			pAnimLink->m_pNext = NULL;

			// Add to end of list
			AnimLink **ppAnimEnd = &m_pAnimList;
			while (*ppAnimEnd != NULL)
				ppAnimEnd = &(*ppAnimEnd)->m_pNext;
			*ppAnimEnd = pAnimLink;
			}
		}
	}
	return S_OK;
}




//////////////////////////////////////////////////////////////////////
// Translate 
//
HRESULT XBContent::BeginTranslate(ISAXAttributes *pAttributes)
{
 	// sanity check
	if (m_rContextStack[m_iContext].m_Context != Matrix_Context)
		return fatalError(m_pLocator, L"<Translate> tag must be within <Matrix> context\n", E_INVALIDARG);
	
	// Save context
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PushContext(Translate_Context);
	m_rContextStack[m_iContext].m_pData = pFrame;
	
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(value))
		{
			D3DXVECTOR3 vTranslate(0.f, 0.f, 0.f);
			UINT iValueCount = 0;
			CHAR *strFull = CharString(pwchValue, cchValue);
			CHAR *strSeparators = " \t\n";
			CHAR *strBuff = strtok(strFull, strSeparators);
			CHAR *pEnd;
			while (strBuff != NULL)
			{
				if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
				{
					FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
					if (*pEnd != '\0')
					{
						m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
						// leave as just a warning
					}
					if (iValueCount >= 3)
						return fatalError(m_pLocator, L"<Translate> has too many values (>3).\n", E_INVALIDARG);
					((FLOAT *)vTranslate)[iValueCount] = fValue;
					iValueCount++;
				}
				else
				{
					m_pBundler->ErrorMsg("Can not parse <Translate> value \"%s\"\n", strBuff);
					return E_FAIL;
				}

				// Get next token
				strBuff = strtok(NULL, strSeparators);
			}
			if (iValueCount < 3)
				return fatalError(m_pLocator, L"<Translate> has too few values.\n", E_INVALIDARG);
			
			// Premultiply frame matrix
			D3DXMATRIX mat;
			D3DXMatrixTranslation(&mat, vTranslate.x, vTranslate.y, vTranslate.z);
			D3DXMatrixMultiply(&pFrame->m_Matrix, &mat, &pFrame->m_Matrix);

			// If an animation expression is already active, prepare to add translate as a key.
			// If there's an <animate> tag following, it will overwrite this 1-key animation.
			/*
			if (pFrame->m_pAnim)
			{
				if (!D3DXMatrixIsIdentity(&mat))
				{
			*/
					if (pFrame->m_pAnimLocal != NULL)
						return fatalError(m_pLocator, L"Recursive <Matrix> elements not implemented.\n", E_NOTIMPL);
					pFrame->m_pAnimLocal = new AnimTranslate( &vTranslate );	// static translate key
					if (pFrame->m_pAnimLocal == NULL)
						return E_OUTOFMEMORY;
			/*
				}
			}
			*/
		}
		else if (MATCH(name))
		{
			// TODO: save the name for use later
			// CHAR *strName = CharString(pwchValue, cchValue);
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	return S_OK;
}

HRESULT XBContent::EndTranslate(void)
{
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
 	PopContext();
	
	// Add 1-key animation to frame's animation list, since we did not
	// encounter an <animate> tag
	if (pFrame->m_pAnimLocal != NULL)
	{
		pFrame->Premult(pFrame->m_pAnimLocal);
		pFrame->m_pAnimLocal = NULL;
	}
	return S_OK;
}




//////////////////////////////////////////////////////////////////////
// Scale
//
HRESULT XBContent::BeginScale(ISAXAttributes *pAttributes)
{
 	// sanity check
	if (m_rContextStack[m_iContext].m_Context != Matrix_Context)
		return fatalError(m_pLocator, L"<Scale> tag must be within <Matrix> context\n", E_INVALIDARG);
	
	// Save context
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PushContext(Scale_Context);
	m_rContextStack[m_iContext].m_pData = pFrame;
	
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(value))
		{
			D3DXVECTOR3 vScale(1.f, 1.f, 1.f);
			UINT iValueCount = 0;
			CHAR *strFull = CharString(pwchValue, cchValue);
			CHAR *strSeparators = " \t\n";
			CHAR *strBuff = strtok(strFull, strSeparators);
			CHAR *pEnd;
			while (strBuff != NULL)
			{
				if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
				{
					FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
					if (*pEnd != '\0')
					{
						m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
						// leave as just a warning
					}
					if (iValueCount >= 3)
						return fatalError(m_pLocator, L"<Scale> has too many values (>3).\n", E_INVALIDARG);
					((FLOAT *)vScale)[iValueCount] = fValue;
					iValueCount++;
				}
				else
				{
					m_pBundler->ErrorMsg("Can not parse <Scale> value \"%s\"\n", strBuff);
					return E_FAIL;
				}

				// Get next token
				strBuff = strtok(NULL, strSeparators);
			}
			if (iValueCount < 3)
				return fatalError(m_pLocator, L"<Scale> has too few values.\n", E_INVALIDARG);
			
			// Concatenate frame matrix
			D3DXMATRIX mat;
			D3DXMatrixScaling(&mat, vScale.x, vScale.y, vScale.z);
			D3DXMatrixMultiply(&pFrame->m_Matrix, &mat, &pFrame->m_Matrix);
			
			// If an animation expression is already active, prepare to add scale as a key.
			// If there's an <animate> tag following, it will overwrite this 1-key animation.
			/*
			if (pFrame->m_pAnim)
			{
				if (!D3DXMatrixIsIdentity(&mat))
				{
				*/
					if (pFrame->m_pAnimLocal != NULL)
						return fatalError(m_pLocator, L"Recursive <Matrix> elements not implemented.\n", E_NOTIMPL);
					pFrame->m_pAnimLocal = new AnimScale( &vScale );	// static scale key
					if (pFrame->m_pAnimLocal == NULL)
						return E_OUTOFMEMORY;
			/*
				}
			}
			*/
		}
		else if (MATCH(name))
		{
			// TODO: save the name for use later
			// CHAR *strName = CharString(pwchValue, cchValue);
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	return S_OK;
}

HRESULT XBContent::EndScale(void)
{
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
 	PopContext();
	
	// Add 1-key animation to frame's animation list, since we did not
	// encounter an <animate> tag
	if (pFrame->m_pAnimLocal != NULL)
	{
		pFrame->Premult(pFrame->m_pAnimLocal);
		pFrame->m_pAnimLocal = NULL;
	}
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Rotate tag accepts either quaternions or axis/angle.
//
enum RotateContextMode {
	RCM_NONE,
	RCM_QUATERNION,
	RCM_AXIS_ONLY,
	RCM_ANGLE_ONLY,
	RCM_AXISANGLE
};

struct RotateContext {
	FrameExtra *m_pFrame;
	RotateContextMode m_mode;
	D3DXVECTOR3 m_vAxis;
	FLOAT m_fAngle;
	D3DXQUATERNION m_quat;
	AnimRotate *m_pAnim;
};

HRESULT XBContent::BeginRotate(ISAXAttributes *pAttributes)
{
	D3DXMATRIX mat;

	// sanity check
	if (m_rContextStack[m_iContext].m_Context != Matrix_Context)
		return fatalError(m_pLocator, L"<Rotate> tag must be within <Matrix> context\n", E_INVALIDARG);

	// Save context
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PushContext(Rotate_Context);
	RotateContext *pRotateContext = new RotateContext;
	if (pRotateContext == NULL)
		return fatalError(m_pLocator, L"<Rotate> allocation failed\n", E_OUTOFMEMORY);
	pRotateContext->m_pFrame = pFrame;
	pRotateContext->m_mode = RCM_NONE;
	D3DXQuaternionIdentity(&pRotateContext->m_quat);
	pRotateContext->m_pAnim = NULL;
	m_rContextStack[m_iContext].m_pData = pRotateContext;
	
	// Loop through attributes
	CHAR *strSeparators = " \t\n";
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(value))
		{
			if (pRotateContext->m_mode != RCM_NONE)
				goto e_BothQuaternionAndAngleAxis;
			pRotateContext->m_mode = RCM_QUATERNION;
			UINT iValueCount = 0;
			CHAR *strFull = CharString(pwchValue, cchValue);
			CHAR *strBuff = strtok(strFull, strSeparators);
			CHAR *pEnd;
			while (strBuff != NULL)
			{
				if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
				{
					FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
					if (*pEnd != '\0')
					{
						m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
						// leave as just a warning
					}
					if (iValueCount >= 4)
						return fatalError(m_pLocator, L"<Rotate> quaternion has too many values (>4).\n", E_INVALIDARG);
					((FLOAT *)pRotateContext->m_quat)[iValueCount] = fValue;
					iValueCount++;
				}
				else
				{
					m_pBundler->ErrorMsg("Can not parse <Rotate> value \"%s\"\n", strBuff);
					return E_FAIL;
				}

				// Get next token
				strBuff = strtok(NULL, strSeparators);
			}
			if (iValueCount < 4)
				return fatalError(m_pLocator, L"<Rotate> has too few quaternion values.\n", E_INVALIDARG);
			
		}
		else if (MATCH(angle))
		{
			if (pRotateContext->m_mode == RCM_QUATERNION)
				goto e_BothQuaternionAndAngleAxis;
			else if (pRotateContext->m_mode == RCM_AXIS_ONLY)
				pRotateContext->m_mode = RCM_AXISANGLE;
			else // (pRotateContext->m_mode == RCM_NONE)
				pRotateContext->m_mode = RCM_ANGLE_ONLY;
			CHAR *strFull = CharString(pwchValue, cchValue);
			CHAR *strBuff = strtok(strFull, strSeparators);
			CHAR *pEnd;
			pRotateContext->m_fAngle = (FLOAT)strtod(strBuff, &pEnd);
			if (*pEnd != '\0')
			{
				m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
				// leave as just a warning
			}
			strBuff = strtok(NULL, strSeparators);
			if (strBuff != NULL)
			{
				m_pBundler->ErrorMsg( "Extra token \"%s\" on angle attribute.\n", strBuff);
				// leave as just a warning
			}
		}
		else if (MATCH(axis))
		{
			if (pRotateContext->m_mode == RCM_QUATERNION)
				goto e_BothQuaternionAndAngleAxis;
			else if (pRotateContext->m_mode == RCM_ANGLE_ONLY)
				pRotateContext->m_mode = RCM_AXISANGLE;
			else // (pRotateContext->m_mode == RCM_NONE)
				pRotateContext->m_mode = RCM_AXIS_ONLY;
			UINT iValueCount = 0;
			CHAR *strFull = CharString(pwchValue, cchValue);
			CHAR *strBuff = strtok(strFull, strSeparators);
			CHAR *pEnd;
			while (strBuff != NULL)
			{
				if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
				{
					FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
					if (*pEnd != '\0')
					{
						m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
						// leave as just a warning
					}
					if (iValueCount >= 3)
						return fatalError(m_pLocator, L"<Rotate> axis has too many values (>3).\n", E_INVALIDARG);
					((FLOAT *)pRotateContext->m_vAxis)[iValueCount] = fValue;
					iValueCount++;
				}
				else
				{
					m_pBundler->ErrorMsg("Can not parse <Rotate> axis value \"%s\"\n", strBuff);
					return E_FAIL;
				}

				// Get next token
				strBuff = strtok(NULL, strSeparators);
			}
			if (iValueCount < 3)
				return fatalError(m_pLocator, L"<Rotate> has too few axis values.\n", E_INVALIDARG);
		}
		else if (MATCH(name))
		{
			// TODO: save the name for use later
			// CHAR *strName = CharString(pwchValue, cchValue);
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	if (pRotateContext->m_mode == RCM_AXISANGLE)
	{
		// Create angle-axis quaternion
		D3DXQuaternionRotationAxis(&pRotateContext->m_quat, &pRotateContext->m_vAxis, pRotateContext->m_fAngle);
	}
	else if (pRotateContext->m_mode == RCM_AXIS_ONLY)
		return fatalError(m_pLocator, L"<Rotate> axis specified, but missing angle attribute.\n", E_FAIL);
	else if (pRotateContext->m_mode == RCM_ANGLE_ONLY)
		return fatalError(m_pLocator, L"<Rotate> angle specified, but missing axis attribute.\n", E_FAIL);

	// Concatenate frame matrix
	D3DXMatrixRotationQuaternion(&mat, &pRotateContext->m_quat);
	D3DXMatrixMultiply(&pFrame->m_Matrix, &mat, &pFrame->m_Matrix);
	
	// If an animation expression is already active, prepare to add quaternion as a key.
	// If there's an <animate> tag following, it will overwrite this 1-key animation.
	/*
	if (pFrame->m_pAnim)
	{
		if (!D3DXMatrixIsIdentity(&mat))
		{
	*/
			if (pFrame->m_pAnimLocal != NULL)
				return fatalError(m_pLocator, L"Recursive <Matrix> elements not implemented.\n", E_NOTIMPL);
			pFrame->m_pAnimLocal = new AnimRotate( &pRotateContext->m_quat );
			if (pFrame->m_pAnimLocal == NULL)
				return E_OUTOFMEMORY;
	/*
		}
	}
	*/
	return S_OK;
	
 e_BothQuaternionAndAngleAxis:
	return fatalError(m_pLocator,
					  L"<Rotate> tag may have either quaternion \"value\", or \"axis\" and \"angle\", but not both.\n",
					  E_INVALIDARG);
}

HRESULT XBContent::EndRotate(void)
{
	RotateContext *pRotateContext = (RotateContext *)m_rContextStack[m_iContext].m_pData;
 	PopContext();
	
	// Add 1-key animation to frame's animation list, since we did not
	// encounter an <animate> tag
	FrameExtra *pFrame = pRotateContext->m_pFrame;
	if (pFrame->m_pAnimLocal != NULL)
	{
		pFrame->Premult(pFrame->m_pAnimLocal);
		pFrame->m_pAnimLocal = NULL;
	}

	delete pRotateContext;	// clean up
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// animate Handlers
//

HRESULT XBContent::animate(AnimCurve *pCurve, ISAXAttributes *pAttributes, CONST WCHAR *wstrAttribute)
{
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
#define MATCH_VALUE(str) Match(str, pwchValue, cchValue)
		if (MATCH(attribute))
		{
			if (wstrAttribute != NULL)
			{
				// Make sure attribute tag matches desired attribute
				if (!MATCH_VALUE(wstrAttribute))
				{
					const int buflen = 200;
					const int namelen = 50;
					WCHAR buf[buflen];
					_snwprintf(buf, buflen,
							   L"<animate> attribute name \"%.*s\" does not match desired attribute name \"%.*s\"",
							   cchLocalName < namelen ? cchLocalName : namelen, pwchLocalName,
							   namelen, wstrAttribute);
					return fatalError(m_pLocator, buf, E_INVALIDARG);
				}
			}
		}
		else if (MATCH(begin))
		{
			CHAR *strBuff = CharString(pwchValue, cchValue);
			CHAR *pEnd;
			FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
			if (*pEnd != 0)
			{
				if (!(pEnd[0] == 's' && pEnd[1] == 0))	// look for seconds suffix
				{
					// print warning
					m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
				}
			}
			pCurve->m_fBegin = fValue;
		}
		else if (MATCH(dur))
		{
			CHAR *strBuff = CharString(pwchValue, cchValue);
			CHAR *pEnd;
			FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
			if (*pEnd != 0)
			{
				if (!(pEnd[0] == 's' && pEnd[1] == 0))	// look for seconds suffix
				{
					// print warning
					m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
				}
			}
			pCurve->m_fDurationInverse = 1.f / fValue;
		}
		else if (MATCH(values))
		{
			CHAR *str = CharString(pwchValue, cchValue);

			// Count the number of keys
			UINT KeyCount = 0;
			CHAR *strSemi = strchr(str, ';');
			while (strSemi && *strSemi == ';')
			{
				KeyCount++;
				strSemi = strchr(strSemi + 1, ';');
			}
			if (pCurve->m_KeyCount == 0) // first of values, keyTimes, or keySplines, so set number of keys
				pCurve->m_KeyCount = KeyCount;
			else if (pCurve->m_KeyCount != KeyCount)
			{
				const int buflen = 200;
				WCHAR buf[buflen];
				_snwprintf(buf, buflen,
						   L"<animate> number of key values (%d) does not match other key counts (%d)\n",
						   KeyCount, pCurve->m_KeyCount);
				return fatalError(m_pLocator, buf, E_INVALIDARG);
			}

			// Allocate the key arrays
			pCurve->m_rKeys = new FLOAT [ pCurve->m_KeyCount * pCurve->m_KeySize ];
			if (pCurve->m_rKeys == NULL)
				return fatalError(m_pLocator,
								  L"Memory allocation failed for <animate> key array.\n",
								  E_OUTOFMEMORY);

			// Fill in the key array
			UINT iKey = 0;
			UINT iValueCount = 0;
			strSemi = strchr(str, ';');	// keep track of end of key
			CHAR *strSeparators = "; \t\n";
			CHAR *tok = strtok(str, strSeparators);
			CHAR *pEnd;
			while (tok != NULL)
			{
				if (m_pBundler->ValidateType(tok, TT_FLOAT) == S_OK)	// TODO: move validation code
				{
					FLOAT fValue = (FLOAT)strtod(tok, &pEnd);
					if (*pEnd != '\0')
					{
						m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, tok);
						// leave as just a warning
					}
					if (iValueCount >= pCurve->m_KeySize)
					{
						const int buflen = 200;
						WCHAR buf[buflen];
						_snwprintf(buf, buflen,
								   L"<animate> key has too many values (%d > %d).\n",
								   iValueCount, pCurve->m_KeyCount);
						return fatalError(m_pLocator, buf, E_INVALIDARG);
					}
					pCurve->m_rKeys[iKey * pCurve->m_KeySize + iValueCount] = fValue;
					iValueCount++;
				}
				else
				{
					m_pBundler->ErrorMsg( "Unrecognized value \"%s\"\n", tok );
					return E_FAIL;
				}

				// If tok is beyond semicolon, it's time to look for a new key
				if (tok + strlen(tok) >= strSemi)
				{
					if (iValueCount != pCurve->m_KeySize)
						return fatalError(m_pLocator, L"<animate> key has too few values\n", E_INVALIDARG);
					iKey++;
					if (iKey > pCurve->m_KeyCount)
						return fatalError(m_pLocator, L"<animate> keys mismatched count\n", E_FAIL);
					strSemi = strchr(strSemi + 1, ';');
					iValueCount = 0;
				}
				
				// Get next token
				tok = strtok(NULL, strSeparators);
			}
		}
		else if (MATCH(keyTimes))
		{
			CHAR *str = CharString(pwchValue, cchValue);

			// Count the number of keys
			UINT KeyCount = 0;
			CHAR *strSemi = strchr(str, ';');
			while (strSemi && *strSemi == ';')
			{
				KeyCount++;
				strSemi = strchr(strSemi + 1, ';');
			}
			if (pCurve->m_KeyCount == 0)		// first of values, keyTimes, or keySplines, so set number of keys
				pCurve->m_KeyCount = KeyCount;
			else if (pCurve->m_KeyCount != KeyCount)
			{
				const int buflen = 200;
				WCHAR buf[buflen];
				_snwprintf(buf, buflen,
						   L"<animate> number of keyTimes values (%d) does not match other key counts (%d)\n",
						   KeyCount, pCurve->m_KeyCount);
				return fatalError(m_pLocator, buf, E_INVALIDARG);
			}

			// Allocate the key arrays
			pCurve->m_rKeyTimes = new FLOAT [ pCurve->m_KeyCount ];
			if (pCurve->m_rKeyTimes == NULL)
				return fatalError(m_pLocator,
								  L"Memory allocation failed for <animate> keyTimes array.\n",
								  E_OUTOFMEMORY);

			// Fill in the key array
			UINT iKey = 0;
			CHAR *strSeparators = "; \t\n";
			CHAR *tok = strtok(str, strSeparators);
			CHAR *pEnd;
			while (tok != NULL)
			{
				if (m_pBundler->ValidateType(tok, TT_FLOAT) == S_OK)	// TODO: move validation code
				{
					FLOAT fValue = (FLOAT)strtod(tok, &pEnd);
					if (*pEnd != '\0')
					{
						m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, tok);
						// leave as just a warning
					}
					pCurve->m_rKeyTimes[iKey] = fValue;
					iKey++;
				}
				else
				{
					m_pBundler->ErrorMsg( "Unrecognized constant value \"%s\"\n", tok );
					return E_FAIL;
				}

				// Get next token
				tok = strtok(NULL, strSeparators);
			}
			if (iKey != pCurve->m_KeyCount)
			{
				const int buflen = 200;
				WCHAR buf[buflen];
				_snwprintf(buf, buflen,
						   L"<animate> number of keyTimes (%d) does not match other key counts (%d)\n",
						   iKey, pCurve->m_KeyCount);
				return fatalError(m_pLocator, buf, E_INVALIDARG);
			}
		}
/*	// TODO: More SMIL attributes
		else if (MATCH(calcMode))
		{
		}
		else if (MATCH(keySplines))
		{
		}
		else if (MATCH(from))
		{
		}
		else if (MATCH(to))
		{
		}
*/		
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH_VALUE
#undef MATCH
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// animate validation
//
HRESULT XBContent::ValidateAnimation(AnimCurve *pCurve, BOOL bWrapAngle)
{
	if ( pCurve->m_rKeys == NULL 
		|| pCurve->m_KeyCount == 0 )
		return fatalError(m_pLocator, L"<animate> missing key values\n", E_FAIL);
	if (pCurve->m_rKeyTimes == NULL)
	{
		// make an evenly spaced key time array
		// TODO: space keys differently for calcMode=paced animation
		// TODO: consider leaving m_rKeyTimes array as NULL to
		// avoid passing around this data. 
		pCurve->m_rKeyTimes = new FLOAT [ pCurve->m_KeyCount ];
		if (pCurve->m_rKeyTimes == NULL)
			return fatalError(m_pLocator,
							  L"Memory allocation failed for <animate> keyTimes array.\n",
							  E_OUTOFMEMORY);
		pCurve->m_rKeyTimes[0] = 0.f;
		if (pCurve->m_KeyCount > 1)
		{
			FLOAT fScale = 1.f / (pCurve->m_KeyCount - 1);
			for (UINT iKey = 1; iKey < pCurve->m_KeyCount - 1; iKey++)
				pCurve->m_rKeyTimes[iKey] = (FLOAT)iKey * fScale;
			pCurve->m_rKeyTimes[pCurve->m_KeyCount - 1] = 1.f;
		}
	}
	if (pCurve->m_rKeyTimes[0] != 0.f
		|| (pCurve->m_KeyCount > 1 
		    && pCurve->m_rKeyTimes[pCurve->m_KeyCount-1] != 1.f))
	{
		ignorableWarning(m_pLocator, L"<animate> keyTimes do not start at 0.0 and end at 1.0\n", E_FAIL);
	}
	if (pCurve->m_KeyCount > 1 /* && bLooping */ )
	{
		FLOAT *pKey0 = &pCurve->m_rKeys[0];
		FLOAT *pKey1 = &pCurve->m_rKeys[(pCurve->m_KeyCount-1) * pCurve->m_KeySize];
		if (bWrapAngle)
		{
			if (pCurve->m_KeySize != 1)
				return fatalError(m_pLocator, L"<animate> expected single-valued keys for angle parameter\n", E_INVALIDARG);
			CONST FLOAT twopi = 2.f * D3DX_PI;
			CONST FLOAT feps = 1e-6f;
			FLOAT fAngle0 = fmodf(fmodf(*pKey0, twopi) + twopi, twopi);
			FLOAT fAngle1 = fmodf(fmodf(*pKey1, twopi) + twopi, twopi);
			if (fabsf(fAngle0 - fAngle1) > feps)
				ignorableWarning(m_pLocator, L"<animate> looping angle animation start and end key values do not match.\n", E_INVALIDARG);
		}
		else if (memcmp(pKey0, pKey1, sizeof(FLOAT) * pCurve->m_KeySize) != 0)
			ignorableWarning(m_pLocator, L"<animate> looping animation start and end key values do not match.\n", E_INVALIDARG);
	}
	return S_OK;
}
	
HRESULT XBContent::BeginMatrix_animate(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	if (m_rContextStack[m_iContext].m_Context != Matrix_Context) // sanity check
		return fatalError(m_pLocator, L"<animate> tag must appear within an enclosing <Matrix>\n", E_FAIL);
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PushContext(Matrix_animate_Context);
	if (pFrame->m_pAnim != NULL)
		return fatalError(m_pLocator, L"<animate> must appear before any other type of animation (<Scale>, <Rotate>, or <Translate>)\n", E_FAIL);

	// Overwrite or create new matrix animation
	AnimMatrix *pAnim;
	if ( pFrame->m_pAnimLocal != NULL )
	{
		pAnim = (AnimMatrix *)pFrame->m_pAnimLocal;
		delete pAnim->m_curve.m_rKeyTimes;
		delete pAnim->m_curve.m_rKeys;
		pFrame->m_pAnimLocal = NULL;
	}
	else
	{
		pAnim = new AnimMatrix;
		if (pAnim == NULL)
			return fatalError(m_pLocator, L"<animate> matrix allocation failed\n", E_OUTOFMEMORY);
	}
	pAnim->m_curve.m_KeyCount = 0;
	pAnim->m_curve.m_KeySize = 16;
	pAnim->m_curve.m_rKeys = NULL;
	pAnim->m_curve.m_rKeyTimes = NULL;
	pAnim->m_curve.m_fBegin = 0.f;
	pAnim->m_curve.m_fDurationInverse = 1.f;

	// Parse <animate> attributes
	hr = animate(&pAnim->m_curve, pAttributes, L"value");
	if (FAILED(hr))
		return hr;
	hr = ValidateAnimation(&pAnim->m_curve, false);
	if (FAILED(hr))
		return hr;

	// Add to frame animation expression
 	return pFrame->Premult(pAnim);
}


HRESULT XBContent::EndMatrix_animate()
{
	PopContext();
	return S_OK;
}

HRESULT XBContent::BeginTranslate_animate(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	if (m_rContextStack[m_iContext].m_Context != Translate_Context) // sanity check
		return fatalError(m_pLocator, L"<animate> tag must appear within an enclosing <Translate>\n", E_FAIL);
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PushContext(Translate_animate_Context);

	// Overwrite or create new translate animation
	AnimTranslate *pAnim;
	if ( pFrame->m_pAnimLocal != NULL )
	{
		pAnim = (AnimTranslate *)pFrame->m_pAnimLocal;
		delete pAnim->m_curve.m_rKeyTimes;
		delete pAnim->m_curve.m_rKeys;
		pFrame->m_pAnimLocal = NULL;
	}
	else
	{
		pAnim = new AnimTranslate;
		if (pAnim == NULL)
			return fatalError(m_pLocator, L"<animate> translate allocation failed\n", E_OUTOFMEMORY);
	}
	pAnim->m_curve.m_KeyCount = 0;
	pAnim->m_curve.m_KeySize = 3;
	pAnim->m_curve.m_rKeys = NULL;
	pAnim->m_curve.m_rKeyTimes = NULL;
	pAnim->m_curve.m_fBegin = 0.f;
	pAnim->m_curve.m_fDurationInverse = 1.f;

	// Parse <animate> attributes
	hr = animate(&pAnim->m_curve, pAttributes, L"value");
	if (FAILED(hr))
		return hr;
	hr = ValidateAnimation(&pAnim->m_curve, false);
	if (FAILED(hr))
		return hr;

	// Add to frame animation expression
 	return pFrame->Premult(pAnim);
}

HRESULT XBContent::EndTranslate_animate(void)
{
	PopContext();
	return S_OK;
}

HRESULT XBContent::BeginScale_animate(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	if (m_rContextStack[m_iContext].m_Context != Scale_Context) // sanity check
		return fatalError(m_pLocator, L"<animate> tag must appear within an enclosing <Scale>\n", E_FAIL);
	FrameExtra *pFrame = (FrameExtra *)m_rContextStack[m_iContext].m_pData;
	PushContext(Scale_animate_Context);
	
	// Overwrite or create new scale animation
	AnimScale *pAnim;
	if ( pFrame->m_pAnimLocal != NULL )
	{
		pAnim = (AnimScale *)pFrame->m_pAnimLocal;
		delete pAnim->m_curve.m_rKeyTimes;
		delete pAnim->m_curve.m_rKeys;
		pFrame->m_pAnimLocal = NULL;
	}
	else
	{
		pAnim = new AnimScale;
		if (pAnim == NULL)
			return fatalError(m_pLocator, L"<animate> scale allocation failed\n", E_OUTOFMEMORY);
	}
	pAnim->m_curve.m_KeyCount = 0;
	pAnim->m_curve.m_KeySize = 3;
	pAnim->m_curve.m_rKeys = NULL;
	pAnim->m_curve.m_rKeyTimes = NULL;
	pAnim->m_curve.m_fBegin = 0.f;
	pAnim->m_curve.m_fDurationInverse = 1.f;

	// Parse <animate> attributes
	hr = animate(&pAnim->m_curve, pAttributes, L"value");
	if (FAILED(hr))
		return hr;
	hr = ValidateAnimation(&pAnim->m_curve, false);
	if (FAILED(hr))
		return hr;
	
	// Add to frame animation expression
 	return pFrame->Premult(pAnim);
}

HRESULT XBContent::EndScale_animate(void)
{
	PopContext();
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Rotate animation handling
//
HRESULT XBContent::BeginRotate_animate(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	if (m_rContextStack[m_iContext].m_Context != Rotate_Context) // sanity check
		return fatalError(m_pLocator, L"<animate> tag must appear within an enclosing <Rotate>\n", E_FAIL);
	RotateContext *pRotateContext = (RotateContext *)m_rContextStack[m_iContext].m_pData;
	PushContext(Rotate_animate_Context);
	FrameExtra *pFrame = pRotateContext->m_pFrame;

	// Overwrite or create new rotate animation
	AnimRotate *pAnim;
	if ( pFrame->m_pAnimLocal != NULL )
	{
		pAnim = (AnimRotate *)pFrame->m_pAnimLocal;
		delete pAnim->m_curve.m_rKeyTimes;
		delete pAnim->m_curve.m_rKeys;
		pFrame->m_pAnimLocal = NULL;
	}
	else
	{
		pAnim = new AnimRotate;
		if (pAnim == NULL)
			return fatalError(m_pLocator, L"<animate> rotate allocation failed\n", E_OUTOFMEMORY);
	}
	pAnim->m_curve.m_KeyCount = 0;
	pAnim->m_curve.m_KeySize = 4;
	pAnim->m_curve.m_rKeys = NULL;
	pAnim->m_curve.m_rKeyTimes = NULL;
	pAnim->m_curve.m_fBegin = 0.f;
	pAnim->m_curve.m_fDurationInverse = 1.f;

	// Look for attribute tag to see if the user wants axis/angle animation or standard quaternion animation
	bool bAnimateAngle = false;
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
#define MATCH_VALUE(TOKEN) Match(L#TOKEN, pwchValue, cchValue)
		if (MATCH(attribute))
		{
			if (MATCH_VALUE(value))
			{
				break;	// standard quaternion animation
			}
			else if (MATCH_VALUE(angle))
			{
				bAnimateAngle = true;
				break;
			}
			else if (MATCH_VALUE(axis))
			{
				return fatalError(m_pLocator,
								  L"<animate> \"axis\" attribute not supported. Use quaternion \"value\" attribute instead.",
								  E_INVALIDARG);
			}
			else
			{
				const int buflen = 200;
				const int namelen = 150;
				WCHAR buf[buflen];
				_snwprintf(buf, buflen,
						   L"<animate> attribute \"%.*s\" not supported.",
						   cchValue < namelen ? cchValue : namelen, pwchValue);
				return fatalError(m_pLocator, buf, E_INVALIDARG);
			}
		}
#undef MATCH_VALUE
#undef MATCH
	}
	
	// Parse <animate> attributes
	if (bAnimateAngle)
	{
		if (pRotateContext->m_mode == RCM_QUATERNION)
		{
			// convert quaternion to angle axis
			D3DXQuaternionNormalize( &pRotateContext->m_quat, &pRotateContext->m_quat);
			D3DXQuaternionToAxisAngle( &pRotateContext->m_quat, &pRotateContext->m_vAxis, &pRotateContext->m_fAngle);
		}

		// Parse <animate attribute="angle"> values
		AnimCurve curveAngle;
		curveAngle.m_KeyCount = 0;
		curveAngle.m_KeySize = 1;
		curveAngle.m_rKeys = NULL;
		curveAngle.m_rKeyTimes = NULL;
		curveAngle.m_fBegin = 0.f;
		curveAngle.m_fDurationInverse = 1.f;
		hr = animate(&curveAngle, pAttributes, L"angle");
		if (FAILED(hr))
			return hr;
		hr = ValidateAnimation(&curveAngle, true);
		if (FAILED(hr))
			return hr;

		// Convert axis/angle keys to quaternion keys, with reasonable precision. 
		hr = MatchAxisAngleCurve(pAnim, &pRotateContext->m_vAxis, &curveAngle, 1e-6f);
		if (FAILED(hr))
			return hr;
	}
	else
	{
		// Standard quaternion animation keys
		hr = animate(&pAnim->m_curve, pAttributes, L"value");
		if (FAILED(hr))
			return hr;
		hr = ValidateAnimation(&pAnim->m_curve, false);
		if (FAILED(hr))
			return hr;
	}

	// Add to frame animation expression
 	return pFrame->Premult(pAnim);
}

HRESULT XBContent::EndRotate_animate(void)
{
	PopContext();
	return S_OK;
}





//////////////////////////////////////////////////////////////////////
// Write the skeleton as a resource with frame pointers as offsets
// from beginning of structure.
//
HRESULT XBContent::WriteSkeleton(FrameExtra *pFrameRoot)
{
	struct UserData {
		DWORD dwType;				// XBRC_SKELETON
		DWORD dwSize;				// total size (not including this header)
	};
	Skeleton skeletonSrc;
	skeletonSrc.m_pRoot = NULL;
	skeletonSrc.m_FrameCount = 0;
	skeletonSrc.m_rMatrix = NULL;
	HRESULT hr = skeletonSrc.SetRoot(pFrameRoot);
	if (FAILED(hr))
		return fatalError(m_pLocator, L"Frame hierarchy can not be created.\n", hr);
	skeletonSrc.UpdateTransformations();	// calculate cumulative transformations to be written to file
	
	// Make a resource identifier
	m_Count.m_Skeleton++;
	int cch = strlen(pFrameRoot->m_strName);
	if (cch == 0)
	{
		// Generate a name for the skeleton if the top frame's name is blank
		ZeroMemory(pFrameRoot->m_strName, FRAME_IDENTIFIER_SIZE);
		_snprintf(pFrameRoot->m_strName, FRAME_IDENTIFIER_SIZE, "Skeleton%d", m_Count.m_Skeleton);
		pFrameRoot->m_strName[FRAME_IDENTIFIER_SIZE - 1] = 0;
		cch = strlen(pFrameRoot->m_strName);
	}
	if (cch > BUNDLER_IDENTIFIER_MAX_LENGTH - 1)
		cch = BUNDLER_IDENTIFIER_MAX_LENGTH - 1;
	CHAR *strSkeletonID = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strSkeletonID, BUNDLER_IDENTIFIER_MAX_LENGTH);
	strncpy(strSkeletonID, pFrameRoot->m_strName, cch);
	strSkeletonID[cch] = 0;	// make sure the string is null terminated
	
	// Keep track of offset into header as a bundler resource
    DWORD cbSkeletonHeader = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].dwOffset = m_pBundler->m_cbHeader;
	cbSkeletonHeader += sizeof(UserData);	// skip user data
	m_pBundler->m_nResourceCount++;
		
	// Calculate size of variable-length arrays
	DWORD dwSize = sizeof(Skeleton) + skeletonSrc.m_FrameCount * (sizeof(D3DXMATRIX) + sizeof(Frame));
	DWORD dwAlign = 16; 	// matrices need 16-byte alignment
	DWORD cbFill = 0;
	if ((cbSkeletonHeader + sizeof(Skeleton)) % 16)
		cbFill = dwAlign - ( (cbSkeletonHeader + sizeof(Skeleton)) % dwAlign );
	dwSize += cbFill;

	// Copy skeleton frame count and matrix data
	BYTE *pData0 = new BYTE [ dwSize ];	// skeleton + matrix array + frame array
	if (pData0 == NULL)
		return fatalError(m_pLocator, L"Memory allocation failed for Skeleton.\n", E_OUTOFMEMORY);
	BYTE *pData = pData0;
	Skeleton *pSkeletonDst = (Skeleton *)pData;
	*pSkeletonDst = skeletonSrc;	// copy skeleton data, pointers will be overwritten below
	pData += sizeof(Skeleton);
	if (cbFill) // Write alignment filler
	{
		memset(pData, 0xAA, cbFill);
		pData += cbFill;
	}
	*(DWORD *)&pSkeletonDst->m_rMatrix = pData - pData0 + cbSkeletonHeader; // set file offset for matrices
	memcpy(pData, skeletonSrc.m_rMatrix, skeletonSrc.m_FrameCount * sizeof(FrameMatrix));
	pData += skeletonSrc.m_FrameCount * sizeof(FrameMatrix);

	// Flatten frame hierarchy and get file offsets
	struct FrameStackElement {
		Frame *pFrame;
		DWORD *pPreviousOffset;	// file offset to be filled in when node is processed
	} rFrameStack[FRAME_MAX_STACK];
	int iFrameStack = 1;	// depth of stack
	rFrameStack[0].pFrame = skeletonSrc.m_pRoot;	// put root on top of stack
	rFrameStack[0].pPreviousOffset = (DWORD *)&pSkeletonDst->m_pRoot;	// pRoot will be filled in below as first offset
	UINT iMatrix = 0;	// index to current entry in m_rMatrix
	while (iFrameStack)
	{
		// Pop the stack and process the top element
		iFrameStack--;
		Frame *pFrameSrc = rFrameStack[iFrameStack].pFrame;
		DWORD *pPreviousOffset = rFrameStack[iFrameStack].pPreviousOffset;
		((FrameExtra *)pFrameSrc)->m_Offset			// set offset in original FrameExtra struct for later use when writing Animation data
			= *pPreviousOffset						// set file offset of parent or sibling in destination
			= pData - pData0 + cbSkeletonHeader;
		Frame *pFrameDst = (Frame *)pData;
		*pFrameDst = *pFrameSrc;	// NULLS are copied as 0's
		pData += sizeof(Frame);	// go to next slot
		
		// Look through all the vertex shader parameter sets
		AnimVertexShaderParameter *pAnimVSP = m_pAnimVSPList;
		while (pAnimVSP)
		{
			// TODO: handle simple expressions, such as Inverse(foo) and foo * bar and world * view * projection
			if (strcmp(pAnimVSP->m_strExpression, pFrameSrc->m_strName) == 0)
			{
				if (!m_bErrorSuppress)
				{
					CONST INT buflen=1000;
					WCHAR buf[buflen];
					_snwprintf(buf, buflen, L"Found duplicate frame id=\"%S\"", pFrameSrc->m_strName);
					buf[buflen-1] = 0;	// make sure string is null-terminated
					ignorableWarning(m_pLocator, buf, E_FAIL);
					m_bErrorSuppress = true;
				}
				pAnimVSP->m_pSource = pSkeletonDst->m_rMatrix + iMatrix;	// file offset of current source matrix
			}
			pAnimVSP = pAnimVSP->m_pNext;
		}

		// Push sibling
		if (pFrameSrc->m_pNext != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrameSrc->m_pNext;
			rFrameStack[iFrameStack].pPreviousOffset = (DWORD *)&pFrameDst->m_pNext; // overwrite with local frame file offset
			iFrameStack++;
		}
		
		// Push child
		if (pFrameSrc->m_pChild != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrameSrc->m_pChild;	// source pointer will be overwritten...
			rFrameStack[iFrameStack].pPreviousOffset = (DWORD *)&pFrameDst->m_pChild; // with local frame file offset
			iFrameStack++;
		}

		// Increment location in matrix paletter
		iMatrix++;
	}
	ASSERT(pData - pData0 == (INT)dwSize);
	
	// Helper writing macro
#define WRITE(POINTER, SIZE)								\
	if (FAILED(m_pBundler->WriteHeader( POINTER, SIZE )))	\
		return E_FAIL;										\
	m_pBundler->m_cbHeader += SIZE;	// TODO: this should be done in WriteHeader
	
	// write to bundle
	UserData SkeletonUserData;
	SkeletonUserData.dwType = XBRC_SKELETON;
	SkeletonUserData.dwSize = dwSize;
	WRITE( &SkeletonUserData, sizeof(UserData) );
	WRITE( pData0, dwSize );
	
	// Cleanup, since we will no longer refer to data within the block, only offsets
	delete [] pData0;
	if (skeletonSrc.m_rMatrix)
		delete [] skeletonSrc.m_rMatrix;
	
    printf("Skeleton: wrote %s (%d bytes)\n", strSkeletonID, m_pBundler->m_cbHeader - cbSkeletonHeader + 8);
	
	return S_OK;
}




//////////////////////////////////////////////////////////////////////
// Write the current animation list as a resource with frame pointers
// as offsets from beginning of structure.
//
HRESULT XBContent::WriteAnimation(AnimLink *pAnimList)
{
	// TODO: the animation data should be in fast GPU memory, since
	// that's where the fixup is going to come from.
	struct UserData {
		DWORD dwType;				// XBRC_ANIMATION
		DWORD dwSize;				// total size (not including this header)
	};
	
	// Generate a name for the animation resource
	m_Count.m_Animation++;	
	CHAR *strAnimID = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strAnimID, BUNDLER_IDENTIFIER_MAX_LENGTH);
	_snprintf(strAnimID, BUNDLER_IDENTIFIER_MAX_LENGTH, "Animation%d", 	m_Count.m_Animation);
	strAnimID[BUNDLER_IDENTIFIER_MAX_LENGTH - 1] = 0;	// make sure the string is null terminated
	
	// Keep track of offset into header as a bundler resource
	DWORD cbAnimHeader = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].dwOffset = m_pBundler->m_cbHeader;
	cbAnimHeader += sizeof(UserData);	// skip UserData
	m_pBundler->m_nResourceCount++;

	// Add up sizes of vertex shader parameters and animation lists
	DWORD dwSize = 0;
	dwSize += sizeof(Animation);
	
	// Get size of vertex shader parameters
	DWORD VSPCount = 0;
	AnimVertexShaderParameter *pAnimVSP;
	for (pAnimVSP = m_pAnimVSPList; pAnimVSP != NULL; pAnimVSP = pAnimVSP->m_pNext)
	{
		// Write only those parameters that are active
		if (pAnimVSP->m_pSource != NULL)
		{
			dwSize += sizeof(AnimVSP);
			VSPCount++;
		}
	}
	
	// Get size and count of animation list
	DWORD AnimCount = 0;
	AnimLink *pAnimSrc;
	for (pAnimSrc = pAnimList; pAnimSrc; pAnimSrc = pAnimSrc->m_pNext)
	{
		AnimCount++;
		dwSize += sizeof(AnimLink);
	}

	// Get size of animation expressions
	for (pAnimSrc = pAnimList; pAnimSrc; pAnimSrc = pAnimSrc->m_pNext)
	{
		AnimFrame *pAnimFrame = pAnimSrc->m_pAnimFrame;
		dwSize += pAnimFrame->GetSize();
	}

	// Make a copy of the data, with pointers converted to file offsets
	BYTE *pAnimData0 = new BYTE [ dwSize ];
	BYTE *pAnimData = pAnimData0;
	
	// Make a copy of the VSP list
	Animation *pAnimation = (Animation *)pAnimData;
	pAnimData += sizeof(Animation);
	pAnimation->m_VSPCount = VSPCount;
	if (VSPCount == 0)
		pAnimation->m_rVSP = NULL;
	else
		*(DWORD *)&pAnimation->m_rVSP = pAnimData - pAnimData0 + cbAnimHeader;	// file offset
	pAnimation->m_AnimCount = AnimCount;
	*(DWORD *)&pAnimation->m_pAnimList = pAnimData + VSPCount * sizeof(AnimVSP) - pAnimData0 + cbAnimHeader;	// file offset
	for (pAnimVSP = m_pAnimVSPList; pAnimVSP != NULL; pAnimVSP = pAnimVSP->m_pNext)
	{
		if (pAnimVSP->m_pSource != NULL)
		{
			// Lookup vertex shader resource
			DWORD ResourceIndex;
			if (!m_pBundler->IsExistingIdentifier( pAnimVSP->m_strVertexShaderReference, &ResourceIndex))
			{
				m_pBundler->ErrorMsg("VertexShader \"%s\" not defined as a resource for parameter \"%s\".\n", 
					pAnimVSP->m_strVertexShaderReference, pAnimVSP->m_strExpression);
				return E_FAIL;
			}
			AnimVSP *pVSP = (AnimVSP *)pAnimData;
			pVSP->m_VertexShaderReference = ResourceIndex;
			pVSP->m_Index = pAnimVSP->m_Index;
			pVSP->m_Count = pAnimVSP->m_Count;
			pVSP->m_pSource = pAnimVSP->m_pSource;	// file offset set above
			pAnimVSP->m_pSource = NULL;	// clear source setting
			pAnimData += sizeof(AnimVSP);	// go to next record
		}
	}
	
	// Make a copy of the animation list, replacing pointers with file offsets
	AnimLink *pAnimDst = (AnimLink *)pAnimData;
	BYTE *pAnimFrameData = pAnimData + sizeof(AnimLink) * AnimCount;
	for (pAnimSrc = m_pAnimList; pAnimSrc; pAnimSrc = pAnimSrc->m_pNext, pAnimDst++)
	{
		// set file offsets in header
		if (pAnimSrc->m_pNext == NULL)
			pAnimDst->m_pNext = NULL;
		else
			*(DWORD *)&pAnimDst->m_pNext = (BYTE *)(pAnimDst + 1) - pAnimData0 + cbAnimHeader;
		*(DWORD *)&pAnimDst->m_pAnimFrame = pAnimFrameData - pAnimData0 + cbAnimHeader;
		*(DWORD *)&pAnimDst->m_pFrame = ((FrameExtra *)pAnimSrc->m_pFrame)->m_Offset;

		// fill in variably-sized animation-expression data
		AnimFrame *pAnimFrameSrc = pAnimSrc->m_pAnimFrame;
		pAnimFrameSrc->RelocateCopy(pAnimFrameData, (CONST BYTE *)((DWORD)pAnimData0 - cbAnimHeader));
		pAnimFrameData += pAnimFrameSrc->GetSize();
	}

	// Write to bundle
	UserData AnimUserData;
	AnimUserData.dwType = XBRC_ANIMATION;
	AnimUserData.dwSize = dwSize;
	WRITE( &AnimUserData, sizeof(UserData) );
	WRITE( pAnimData0, dwSize );
#undef WRITE
		
	printf("Animation: wrote %s (%d bytes)\n", strAnimID, m_pBundler->m_cbHeader - cbAnimHeader + 8);
		
	// Cleanup animation data
	delete [] pAnimData0;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\bundler.cpp ===
//-----------------------------------------------------------------------------
// File: Bundler.cpp
//
// Desc: Bundles up a list of resources into an Xbox Packed Resource (xpr)
//       file.
//
// Hist: 2001.02.06 - New for March XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Bundler.h"
#include "Texture.h"
#include "Cubemap.h"
#include "VolumeTexture.h"
#include "VB.h"
#include "UserData.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "stdafx.h"

#define INITIAL_HEADER_ALLOC 1024
#define INITIAL_DATA_ALLOC 65536

//-----------------------------------------------------------------------------
// Name: CBundler()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CBundler::CBundler()
{
    m_pd3d = NULL;
    m_pd3ddev = NULL;
    m_cbHeader = m_cbData   = 0;
    m_strRDF[0] = m_strXPR[0] = m_strHDR[0] = m_strERR[0] = 0;
    m_strPrefix[0] =  0;
    m_hfRDF    = m_hfXPR    = m_hfHDR    = m_hfERR    = INVALID_HANDLE_VALUE;
    m_bExplicitPrefix = FALSE;
    m_pbHeaderBuff = m_pbDataBuff   = NULL;
    m_nResourceCount = 0;
    m_bExplicitHDR = m_bExplicitXPR = m_bExplicitERR = FALSE;
    m_bSingleTexture = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CBundler()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CBundler::~CBundler()
{
    CloseFiles();
    if( m_pbHeaderBuff )
    {
        free( m_pbHeaderBuff );
        m_pbHeaderBuff = NULL;
    }
    
    if( m_pbDataBuff )
    {
        free( m_pbDataBuff );
        m_pbDataBuff = NULL;
    }
    
    if( m_pd3ddev != NULL )
    {
        m_pd3ddev->Release();
        m_pd3d->Release();
    }
}



//-----------------------------------------------------------------------------
// Name: ErrorMsg()
// Desc: Prints an error message to stderr, and writes to the error file
//-----------------------------------------------------------------------------
void CBundler::ErrorMsg( CHAR* strFmt, ... )
{
    DWORD cb;
    va_list arglist;
    const int TempSize = 2000;
    char strTemp[TempSize];

    if( INVALID_HANDLE_VALUE == m_hfERR )
    {   
        m_hfERR = CreateFile( m_strERR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    }

    va_start( arglist, strFmt );

    _vsnprintf( strTemp, TempSize - 1, strFmt, arglist );
    strTemp[TempSize-1] = 0;    // make sure string is null terminated for strlen call
    WriteFile( m_hfERR, strTemp, strlen( strTemp ), &cb, NULL );
    
    // Instead of sending the message to stderr, use the XBContent error handling
    //  vfprintf( stderr, strFmt, arglist );
    extern XBContent *g_pXBContent;
    if (g_pXBContent == NULL)
        fputs( strTemp, stderr );
    else
    {
        WCHAR wstrTemp[TempSize];
        size_t count = mbstowcs( wstrTemp, strTemp, TempSize );
        if (count == -1)
            fputs( strTemp, stderr );
        else
        {
            g_pXBContent->error(g_pXBContent->m_pLocator, wstrTemp, E_FAIL);
            g_pXBContent->m_bErrorSuppress = true;
        }
    }

    va_end( arglist );
}




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes D3D for texture gunk
//-----------------------------------------------------------------------------
HRESULT CBundler::InitD3D()
{
    HRESULT hr;
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;

    // If we've already init'ed D3D, then we're good to go
    if( m_pd3ddev != NULL )
        return S_FALSE;

    m_pd3d = Direct3DCreate8(D3D_SDK_VERSION);
    if (m_pd3d == NULL)
    {
        ErrorMsg("Couldn't create Direct3d - is it installed?\n");
        return E_FAIL;
    }

    m_pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = 8;
    presentParams.BackBufferHeight = 8;
    presentParams.BackBufferFormat = ( ( dispMode.Format == D3DFMT_R8G8B8 ) ? D3DFMT_R5G6B5 : dispMode.Format );

    hr = m_pd3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, GetDesktopWindow(),
        D3DCREATE_SOFTWARE_VERTEXPROCESSING, &presentParams, &m_pd3ddev);
    if (FAILED(hr))
    {
        ErrorMsg("Couldn't create reference device.  Error: %x\n", hr);
        m_pd3d->Release();
        m_pd3d = NULL;
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin
// Desc: Sets up writing 
//-----------------------------------------------------------------------------
HRESULT CBundler::Begin( CHAR *strBase )
{
/*  
    HRESULT hr;

    int n;
    int nBaseFileLen;
    char * pch;
    BOOL bHaveRDF = FALSE;

    for(n=1; n<argc; n++)
    {
        // step through each command line parameter
        if((argv[n][0] == '/') || (argv[n][0] == '-'))
        {
            if((n+1) == argc)
                return E_INVALIDARG;

            // found an option
            if(lstrcmpi("o", &(argv[n][1])) == 0)
            {
                // Output file
                lstrcpyA( m_strXPR, argv[n+1] );
                m_bExplicitXPR = TRUE;
            }
            else if(lstrcmpi("h", &(argv[n][1])) == 0)
            {
                // Header file
                lstrcpyA( m_strHDR, argv[n+1] );
                m_bExplicitHDR = TRUE;
            }
            else if(lstrcmpi("p", &(argv[n][1])) == 0)
            {
                // Prefix for header file constants
                lstrcpyA( m_strPrefix, argv[n+1] );
                m_bExplicitPrefix = TRUE;
            }
            else if(lstrcmpi("e", &(argv[n][1])) == 0)
            {
                // Error file
                lstrcpyA( m_strERR, argv[n+1] );
                m_bExplicitERR = TRUE;
            }
            else if(lstrcmpi("?", &(argv[n][1])) == 0)
                return E_INVALIDARG;    // causes usage to be displayed
            else
                return E_INVALIDARG;
            
            n++;    // skip two args
        }
        else
        {
            bHaveRDF = TRUE;
        }
    }

    if(!bHaveRDF)
        return E_INVALIDARG;
*/  
    // Grab the RDF filename
    lstrcpyA( m_strRDF, strBase );
    
    // Find where the filename ends and the extension begins
    CHAR *pch;
    pch = m_strRDF;
    while( pch && strchr( pch, '.' ) )
    {
        pch = strchr( pch, '.' ) + 1;
    }
    
    // If we never found a '.', use the whole filename
    if( pch == m_strRDF )
        pch = m_strRDF + lstrlen( m_strRDF ) + 1;
    
    // Must have something for a base filename
    INT nBaseFileLen = pch - m_strRDF - 1;
    if( nBaseFileLen <= 0 )
        return E_INVALIDARG;
    
    // Check to see if we are doing a quick single-texture conversion
    if((_stricmp(pch, "bmp") == 0) ||
       (_stricmp(pch, "jpg") == 0) ||
       (_stricmp(pch, "tga") == 0) ||
       (_stricmp(pch, "dds") == 0) ||
       (_stricmp(pch, "png") == 0))
    {
        m_bSingleTexture = TRUE;
    }
    
    // Copy the base filename + appropriate extension to each string
    strncpy( m_strXPR, m_strRDF, nBaseFileLen );
    m_strXPR[nBaseFileLen] = 0;
    strcat( m_strXPR, XPREXT );
    strncpy( m_strHDR, m_strRDF, nBaseFileLen );
    m_strHDR[nBaseFileLen] = 0;
    strcat( m_strHDR, HDREXT );
    strncpy( m_strERR, m_strRDF, nBaseFileLen );
    m_strERR[nBaseFileLen] = 0;
    strcat( m_strERR, ERREXT );
    
    strcpy( m_strPath, m_strXPR );
    if( strrchr( m_strPath, '\\' ) )
        strrchr( m_strPath, '\\' )[1] = 0;
    else
        m_strPath[0] = 0;

    // Creating a D3D device sets the floating point control
    // word to single precision.  Now that we only create the
    // D3D device on demand, we _could_ use double precision,
    // but set to single precision to maintain bit-for-bit
    // output compatibility.
    _controlfp( _PC_24, _MCW_PC );

    // Allocate buffers for storing data
    m_pbHeaderBuff = (BYTE *)malloc( INITIAL_HEADER_ALLOC );
    if( !m_pbHeaderBuff )
        return E_OUTOFMEMORY;
    m_cbHeaderAlloc = INITIAL_HEADER_ALLOC;

    m_pbDataBuff = (BYTE *)malloc( INITIAL_DATA_ALLOC );
    if( !m_pbDataBuff )
        return E_OUTOFMEMORY;
    m_cbDataAlloc = INITIAL_DATA_ALLOC;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OpenFiles()
// Desc: Opens file handles for all our output files
//-----------------------------------------------------------------------------
HRESULT CBundler::OpenFiles()
{
    m_hfXPR = CreateFile( m_strXPR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfXPR )
    {
        ErrorMsg( "Couldn't open file <%s>", m_strXPR );
        return E_FAIL;
    }

    m_hfHDR = CreateFile( m_strHDR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfHDR )
    {
        ErrorMsg( "Couldn't open header file <%s>", m_strHDR );
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CloseFiles()
// Desc: Closes file handles for all our input/output files
//-----------------------------------------------------------------------------
HRESULT CBundler::CloseFiles()
{
    if( INVALID_HANDLE_VALUE != m_hfRDF )
        CloseHandle( m_hfRDF );
    if( INVALID_HANDLE_VALUE != m_hfXPR )
        CloseHandle( m_hfXPR );
    if( INVALID_HANDLE_VALUE != m_hfHDR )
        CloseHandle( m_hfHDR );
    if( INVALID_HANDLE_VALUE != m_hfERR )
        CloseHandle( m_hfERR );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: End()
// Desc: Handles any necessary end-of-input processing, such as patching up
//       header information
//-----------------------------------------------------------------------------
HRESULT CBundler::End()
{
    if( FAILED( OpenFiles() ) )
        return E_FAIL;

    if( FAILED( WriteSymbolTable() ) )
        return E_FAIL;

    // write one last header entry to terminate the list
    DWORD tmp = 0xffffffff;
    WriteHeader( &tmp, sizeof( tmp ) );
    m_cbHeader += sizeof( tmp );

    if( FAILED( FlushDataFile() ) )
        return E_FAIL;

    if( FAILED( WriteHeaderFile() ) )
        return E_FAIL;
    
    return S_FALSE;
}


//-----------------------------------------------------------------------------
// Name: FilterFromString()
// Desc: Returns a D3DXFILTER from the given string
//-----------------------------------------------------------------------------
DWORD CBundler::FilterFromString( char* strFilter )
{
    DWORD filter  = D3DX_FILTER_TRIANGLE; // The default
    DWORD address = 0;
    DWORD dither  = 0;

    if( strFilter[0] )
    {
        // Scan string
        CHAR* strToken = strtok( strFilter, "|" );
        while( strToken != NULL )
        {
            if( !lstrcmpi( strToken, "NONE" ) )      filter  = D3DX_FILTER_NONE;
            if( !lstrcmpi( strToken, "POINT" ) )     filter  = D3DX_FILTER_POINT;
            if( !lstrcmpi( strToken, "LINEAR" ) )    filter  = D3DX_FILTER_LINEAR;
            if( !lstrcmpi( strToken, "TRIANGLE" ) )  filter  = D3DX_FILTER_TRIANGLE;
            if( !lstrcmpi( strToken, "BOX" ) )       filter  = D3DX_FILTER_BOX;
            if( !lstrcmpi( strToken, "WRAP" ) )      address = 0;
            if( !lstrcmpi( strToken, "CLAMP" ) )     address = D3DX_FILTER_MIRROR;
            if( !lstrcmpi( strToken, "DITHER" ) )    dither  = D3DX_FILTER_DITHER;

            strToken = strtok( NULL, "|" );
        }
    }

    return (filter|address|dither);
}

/*


//-----------------------------------------------------------------------------
// Name: HandleTextureToken()
// Desc: Takes over to handle a texture token. Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleTextureToken()
{
    HRESULT hr;
    BUNDLERTOKEN tok;
    char strBuff[MAX_PATH];
    CTexture2D tex(this);
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &tok );
    if( FAILED( hr ) )
        return hr;

    if( tok.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Texture name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( tok.eType & TOKEN_PROPERTY_TEXTURE )
        {
            hr = GetNextTokenString( strBuff, tok.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( tok.eType )
        {
            case TOKEN_PROPERTY_TEXTURE_SOURCE:
                strcpy( tex.m_strSource, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_ALPHASOURCE:
                strcpy( tex.m_strAlphaSource, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_WIDTH:
                tex.m_dwWidth = atoi( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_HEIGHT:
                tex.m_dwHeight = atoi( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuff );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a texture property.\n", tok.strKeyword );
        }
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Texture: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleCubemapToken()
// Desc: Takes over to handle a cubemap token. Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleCubemapToken()
{
    HRESULT      hr;
    BUNDLERTOKEN token;
    char         strBuffer[MAX_PATH];
    CCubemap     tex(this);
    BOOL         bDone = FALSE;
    DWORD        cbHeader;
    DWORD        cbData;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Cubemap name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & (TOKEN_PROPERTY_CUBEMAP|TOKEN_PROPERTY_TEXTURE) )
        {
            hr = GetNextTokenString( strBuffer, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_XP:
                strcpy( tex.m_strSourceXP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_XN:
                strcpy( tex.m_strSourceXN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_YP:
                strcat( tex.m_strSourceYP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_YN:
                strcpy( tex.m_strSourceYN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP:
                strcpy( tex.m_strSourceZP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN:
                strcpy( tex.m_strSourceZN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP:
                strcpy( tex.m_strAlphaSourceXP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN:
                strcpy( tex.m_strAlphaSourceXN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP:
                strcpy( tex.m_strAlphaSourceYP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN:
                strcpy( tex.m_strAlphaSourceYN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP:
                strcpy( tex.m_strAlphaSourceZP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN:
                strcpy( tex.m_strAlphaSourceZN, strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SIZE:
                tex.m_dwSize = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuffer );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a cubemap property.\n", token.strKeyword );
        }
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Cubemap: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     6 x %d x %d, %d levels\n\n", tex.m_dwSize, tex.m_dwSize, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleVolumeTextureToken()
// Desc: Takes over to handle a volume texture token. Reads all tokens up to
//       and including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleVolumeTextureToken()
{
    HRESULT        hr;
    BUNDLERTOKEN   token;
    char           strBuffer[MAX_PATH];
    CVolumeTexture tex(this);
    BOOL           bDone = FALSE;
    DWORD          cbHeader;
    DWORD          cbData;
    DWORD          srcnum = 0;
    DWORD          alphasrcnum = 0;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Cubemap name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & (TOKEN_PROPERTY_CUBEMAP|TOKEN_PROPERTY_TEXTURE) )
        {
            hr = GetNextTokenString( strBuffer, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_TEXTURE_SOURCE:
                if( tex.m_dwDepth )
                {
                    if( srcnum <tex.m_dwDepth )
                        strcpy( tex.m_astrSource[srcnum++], strBuffer );
                    else
                        srcnum++;
                }
                else
                    ErrorMsg("Must specify volume texture DEPTH before SOURCE.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_ALPHASOURCE:
                if( tex.m_dwDepth )
                {
                    if( alphasrcnum <tex.m_dwDepth )
                        strcpy( tex.m_astrAlphaSource[alphasrcnum++], strBuffer );
                    else
                        alphasrcnum++;
                }
                else
                    ErrorMsg("Must specify volume texture DEPTH before ALPHASOURCE.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_WIDTH:
                tex.m_dwWidth = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_HEIGHT:
                tex.m_dwHeight = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH:
                if( 0 == tex.m_dwDepth )
                {   
                    tex.m_dwDepth         = atoi( strBuffer );
                    tex.m_astrSource      = new FILENAME[tex.m_dwDepth];
                    tex.m_astrAlphaSource = new FILENAME[tex.m_dwDepth];
                    ZeroMemory( tex.m_astrSource,      sizeof(FILENAME) * tex.m_dwDepth );
                    ZeroMemory( tex.m_astrAlphaSource, sizeof(FILENAME) * tex.m_dwDepth );
                }
                else
                    ErrorMsg("VolumeTexture DEPTH already specified.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuffer );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a volume texture property.\n", token.strKeyword );
        }
    }

    // Check that we have a good number of sources
    if( ( srcnum != tex.m_dwDepth ) || ( alphasrcnum > 0  && alphasrcnum != tex.m_dwDepth ) )
    {   
        ErrorMsg("Volume texture must have same number of sources as the depth.\n" );
        return E_FAIL;
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Volume texture: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     %d x %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwDepth, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Match()
// Desc: Returns TRUE if it successfuly reads a token of the specified type.
//-----------------------------------------------------------------------------
BOOL CBundler::Match(INT TokType, BUNDLERTOKEN *pTok)
{
    HRESULT hr;
    hr = GetNextToken( pTok );
    if( FAILED( hr ) )
        return FALSE;

    if( pTok->eType != TokType )
        return FALSE;
    
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: HandleVertexBuffer()
// Desc: Takes over to handle a VertexBuffer token.  Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleVertexBufferToken()
{
    HRESULT hr;
    BUNDLERTOKEN tok;
    char strBuff[MAX_PATH], *pEnd;
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

    // This is the vertex buffer name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
    {
        ErrorMsg( "Vertexbuffer name should be followed by an open brace\n" );
        return E_FAIL;
    }

    CVertexBuffer *vb = new CVertexBuffer(this);
    
    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        switch( tok.eType )
        {
            case TOKEN_PROPERTY_VB_VERTEXDATA:
                if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
                {
                    ErrorMsg( "VertexData property must begin with an open brace.\n" );
                    return E_FAIL;
                }
                while(TRUE)
                {
                    if(FAILED(hr = GetNextTokenString( strBuff, TT_ANY ))) return hr;
                
                    if((strBuff[0] == '}') || (strBuff[0] == TOKEOF))
                        break;
                    else if(ValidateType(strBuff, TT_HEXNUMBER) == S_OK)
                        vb->AddVertexData((DOUBLE)strtoul(strBuff, &pEnd, 16));
                    else if(ValidateType(strBuff, TT_INTEGER) == S_OK)
                        vb->AddVertexData(atof(strBuff));
                    else if(ValidateType(strBuff, TT_FLOAT) == S_OK)
                        vb->AddVertexData(atof(strBuff));
                }
                break;
            case TOKEN_PROPERTY_VB_VERTEXFORMAT:
                if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
                {
                    ErrorMsg( "VertexFormat property must begin with an open brace.\n" );
                    return E_FAIL;
                }
                while(TRUE)
                {
                    if(FAILED(hr = GetNextTokenString( strBuff, TT_ANY ))) return hr;
                
                    if((strBuff[0] == '}') || (strBuff[0] == TOKEOF))
                        break;
                    else
                    {
                        if((strcmp(strBuff, "D3DVSDT_FLOAT1") == 0) ||
                           (strcmp(strBuff, "FLOAT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT1);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT2") == 0) ||
                                (strcmp(strBuff, "FLOAT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT2);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT3") == 0) ||
                                (strcmp(strBuff, "FLOAT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT3);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT4") == 0) ||
                                (strcmp(strBuff, "FLOAT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT4);
                        else if((strcmp(strBuff, "D3DVSDT_D3DCOLOR") == 0) ||
                                (strcmp(strBuff, "D3DCOLOR") == 0))
                            vb->AddVertexFormat(XD3DVSDT_D3DCOLOR);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT2") == 0) ||
                                (strcmp(strBuff, "SHORT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT2);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT4") == 0) ||
                                (strcmp(strBuff, "SHORT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT4);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT1") == 0) ||
                                (strcmp(strBuff, "NORMSHORT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT1);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT2") == 0) ||
                                (strcmp(strBuff, "NORMSHORT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT2);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT3") == 0) ||
                                (strcmp(strBuff, "NORMSHORT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT3);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT4") == 0) ||
                                (strcmp(strBuff, "NORMSHORT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT4);
                        else if((strcmp(strBuff, "D3DVSDT_NORMPACKED3") == 0) ||
                                (strcmp(strBuff, "NORMPACKED3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMPACKED3);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT1") == 0) ||
                                (strcmp(strBuff, "SHORT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT1);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT3") == 0) ||
                                (strcmp(strBuff, "SHORT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT3);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE1") == 0) ||
                                (strcmp(strBuff, "PBYTE1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE1);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE2") == 0) ||
                                (strcmp(strBuff, "PBYTE2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE2);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE3") == 0) ||
                                (strcmp(strBuff, "PBYTE3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE3);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE4") == 0) ||
                                (strcmp(strBuff, "PBYTE4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE4);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT2H") == 0) ||
                                (strcmp(strBuff, "FLOAT2H") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT2H);
                        else
                        {
                            ErrorMsg( "Unrecognized attribute format: %s\n", strBuff );
                            return E_FAIL;
                        }
                    }
                }
                break;

            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a vertexbuffer property.\n", tok.strKeyword );
        }
    }

    // Save the vertexbuffer to the bundle
    hr = vb->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("VB:  Wrote %s: %d bytes per vertex, %d vertices (%d bytes)\n\n", 
           m_aResources[m_nResourceCount].strIdentifier, vb->m_cBytesPerVertex,
           vb->m_cVertices, cbData );

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    delete vb;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleUserDataToken()
// Desc: Takes over to handle a UserData token.  Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleUserDataToken()
{
    BUNDLERTOKEN token;
    CUserData    ud(this);
    CHAR         strBuff[MAX_PATH];
    BOOL         bDone = FALSE;
    DWORD        cbHeader, cbData;
    HRESULT      hr;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Texture name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & TOKEN_PROPERTY_USERDATA )
        {
            hr = GetNextTokenString( strBuff, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_USERDATA_DATAFILE:
                strcpy( ud.m_strSource, strBuff );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a userdata property.\n", token.strKeyword );
        }
    }

    // Save the UserData to the bundle
    hr = ud.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf( "UserData: Wrote %ld bytes.\n", cbHeader );

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}

*/


//-----------------------------------------------------------------------------
// Name: FlushDataFile()
// Desc: Writes out all the buffered data to the data file, including
//       appropriate padding
//-----------------------------------------------------------------------------
HRESULT CBundler::FlushDataFile()
{
    BOOL bWriteOK;
    DWORD cb;
    XPR_HEADER xprh;
    BYTE * pbTemp;
    DWORD cbFill = 0;

    // Pad the data buffer out to be a multiple of the DVD sector size (2k).
    // This is needed in order to DMA the file off the DVD drive on the
    // Xbox.
    PadToAlignment( 2048 );

    xprh.dwMagic = XPR_MAGIC_VALUE;
    xprh.dwHeaderSize = m_cbHeader + sizeof( XPR_HEADER );

    // We may need to pad the file to a sector multiple for the 
    // start of the data block
    if( xprh.dwHeaderSize % 2048 )
    {
        cbFill = 2048 - ( xprh.dwHeaderSize % 2048 );
        xprh.dwHeaderSize += cbFill;
    }
    xprh.dwTotalSize = xprh.dwHeaderSize + m_cbData;

    // Write out header stuff
    if( !WriteFile( m_hfXPR, &xprh, sizeof( XPR_HEADER ), &cb, NULL ) )
        return E_FAIL;
    if( !WriteFile( m_hfXPR, m_pbHeaderBuff, m_cbHeader, &cb, NULL ) )
        return E_FAIL;

    if( cbFill )
    {
        // Allocate a buffer for fill data
        pbTemp = (BYTE *)malloc( cbFill );
        memset( pbTemp, 0xDEAD, cbFill );

        // Write it out
        bWriteOK = WriteFile( m_hfXPR, pbTemp, cbFill, &cb, NULL );
        free( pbTemp );
        if( !bWriteOK )
            return E_FAIL;
    }

    if( !WriteFile( m_hfXPR, m_pbDataBuff, m_cbData, &cb, NULL ) )
        return E_FAIL;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: RESOURCE_STRUCT_cmp
// Desc: Helper file for sorting list of resources
//-----------------------------------------------------------------------------
int __cdecl RESOURCE_STRUCT_cmp(const void *elem1, const void *elem2 )
{
    RESOURCE_STRUCT *p1 = (RESOURCE_STRUCT *)elem1;
    RESOURCE_STRUCT *p2 = (RESOURCE_STRUCT *)elem2;
    return strcmp(p1->strIdentifier, p2->strIdentifier);
}

//-----------------------------------------------------------------------------
// Name: WriteSymbolTable
// Desc: Write a symbol table resource
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteSymbolTable()
{
    // sort list of resources
    qsort(m_aResources, m_nResourceCount, sizeof(RESOURCE_STRUCT), RESOURCE_STRUCT_cmp);

    // Add symbol table resource at the end
    CHAR *strIdentifier = m_aResources[m_nResourceCount].strIdentifier;
    ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
    strcpy(strIdentifier, "SYMBOLTABLE");
    DWORD cbHeader0 = m_aResources[m_nResourceCount].dwOffset = m_cbHeader; // offset to UserData struct
    m_nResourceCount++;
    
    // get the size of all the resource strings
    DWORD StringSize = 0;
    for (DWORD i = 0; i < m_nResourceCount; i++)
        StringSize += strlen(m_aResources[i].strIdentifier) + 1;

    // get size of header
    DWORD HeaderSize = sizeof(DWORD)                // number of symbols
        + m_nResourceCount * 2 * sizeof(DWORD);     // (name, offset) pairs

    // Helper writing macro
#define WRITE(POINTER, SIZE)                    \
    if (FAILED(WriteHeader( POINTER, SIZE )))   \
        return E_FAIL;                          \
    m_cbHeader += SIZE; // TODO: this should be done in WriteHeader

    // write header to bundle
    struct UserData {
        DWORD dwType;               // XBRC_SYMBOLTABLE
        DWORD dwSize;               // total size (not including this header)
    } SymbolTableUserData;
    SymbolTableUserData.dwType = XBRC_SYMBOLTABLE;
    SymbolTableUserData.dwSize = HeaderSize + StringSize;
    WRITE( &SymbolTableUserData, sizeof(UserData) );

    // write count of symbols
    WRITE( &m_nResourceCount, sizeof(DWORD) );
        
    // write (name, offset) tags to header file
    DWORD cbStringOffset = cbHeader0 + sizeof(UserData) + HeaderSize;
    for (i = 0; i < m_nResourceCount; i++)
    {
        WRITE( &cbStringOffset, sizeof(DWORD) );    // offset to list of strings at end
        cbStringOffset += strlen(m_aResources[i].strIdentifier) + 1;
        WRITE( &m_aResources[i].dwOffset, sizeof(DWORD) );
    }

    // write the strings to the header file
    for (i = 0; i < m_nResourceCount; i++)
    {
        size_t length = strlen(m_aResources[i].strIdentifier) + 1;
        WRITE( m_aResources[i].strIdentifier, length ); // includes NULL
    }
    
#undef WRITE        
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: WriteHeaderFile()
// Desc: Writes out a .h file with useful definitions:
//       * NUM_RESOURCES
//       * XXX_OFFSET for each resource
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteHeaderFile()
{
    DWORD i;
    DWORD cb;
    char strBuff[256];

    sprintf( strBuff, "// Automatically generated by the xbrc tool from %s\n\n", m_strRDF );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;

    // strip root filename out of m_strRDF;
    CHAR strPrefix[MAX_PATH];

    if( m_strPrefix[0] )
    {
        strcpy( strPrefix, m_strPrefix );
    }
    else
    {
        // Use the resource name as a prefix, after removing prepending path
        // and file extension.
        CHAR drive[_MAX_DRIVE];
        CHAR dir[_MAX_DIR];
        CHAR name[_MAX_PATH];
        CHAR ext[_MAX_EXT];
        _splitpath( m_strRDF, drive, dir, name, ext );
        strcpy(strPrefix, name);
    }

    // Write out the number of resources
    sprintf( strBuff, "#define %s_NUM_RESOURCES %dUL\n\n", strPrefix, m_nResourceCount );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;

    // Make the output pretty
    CHAR *strSpaces = "                                                    ";
    UINT MaxLength = 0;
    
    // Write out the offset of each resource
    if( m_bSingleTexture )
    {
        sprintf( strBuff, "#define %s_OFFSET %dUL\n", strPrefix, 
                          m_aResources[0].dwOffset );
        if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
            return E_FAIL;
    }
    else
    {
        for( i = 0; i < m_nResourceCount; i++ )
        {
            UINT Length = strlen(m_aResources[i].strIdentifier);
            if (Length > MaxLength) MaxLength = Length;
        }
        for( i = 0; i < m_nResourceCount; i++ )
        {
            sprintf( strBuff, "#define %s_%s_OFFSET %.*s%dUL\n",
                     strPrefix, m_aResources[i].strIdentifier,
                     MaxLength - strlen(m_aResources[i].strIdentifier), strSpaces,
                     m_aResources[i].dwOffset );
            if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
                return E_FAIL;
        }
    }

    // Write out debug map of names to resources
    strcpy( strBuff, "\n#ifdef _DEBUG\n" );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;
    sprintf( strBuff, "XBRESOURCE %s_ResourceTags[%s_NUM_RESOURCES] = {\n", strPrefix, strPrefix );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;
    if( m_bSingleTexture )
    {
        sprintf( strBuff, "\t{ \"%s\",\t%s_OFFSET },\n", strPrefix, strPrefix );
        if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
            return E_FAIL;
    }
    else
    {
        // write list of resources
        for( i = 0; i < m_nResourceCount; i++ )
        {
            sprintf( strBuff, "\t{ \"%s_%s\", %.*s%s_%s_OFFSET },\n",
                     strPrefix, m_aResources[i].strIdentifier,
                     MaxLength - strlen(m_aResources[i].strIdentifier), strSpaces,
                     strPrefix, m_aResources[i].strIdentifier);
            if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
                return E_FAIL;
        }
    }
    strcpy( strBuff, "};\n#endif\n" );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;
    
    
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SetOutPackedResourceFile
// Desc: Takes over to handle the out_packedresource token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::SetOutPackedResourceFile(CHAR *strResourceFile)
{
    HRESULT hr = ValidateType( strResourceFile, TT_FILENAME );
    if (FAILED(hr))
        return hr;
    
    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitXPR )
    {
        if( strchr( strResourceFile, ':' ) )
            strcpy( m_strXPR, strResourceFile );
        else
        {
            strcpy( m_strXPR, m_strPath );
            strcat( m_strXPR, strResourceFile );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_packedresource overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetOutHeaderFile
// Desc: Takes over to handle the out_header token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::SetOutHeaderFile(CHAR *strHeaderFile)
{
    HRESULT hr = ValidateType( strHeaderFile, TT_FILENAME );
    if (FAILED(hr))
        return hr;

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitHDR )
    {
        if( strchr( strHeaderFile, ':' ) )
            strcpy( m_strHDR, strHeaderFile );
        else
        {
            strcpy( m_strHDR, m_strPath );
            strcat( m_strHDR, strHeaderFile );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_header overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetOutPrefix
// Desc: Set the output prefix
//-----------------------------------------------------------------------------
HRESULT CBundler::SetOutPrefix(CHAR *strPrefix)
{
    HRESULT hr = ValidateType( strPrefix, TT_ANY );
    if (FAILED(hr))
        return hr;

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output prefix must be specified before resources\n" );
    }
    else if( !m_bExplicitPrefix )
    {
        strcpy( m_strPrefix, strPrefix );
    }
    else
    {
        ErrorMsg( "Warning: out_prefix overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetOutErrorFile()
// Desc: Takes over to handle the out_error token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::SetOutErrorFile(CHAR *strErrorFile)
{
    HRESULT hr = ValidateType( strErrorFile, TT_FILENAME );
    if (FAILED(hr))
        return hr;

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitERR )
    {
        if( strchr( strErrorFile, ':' ) )
            strcpy( m_strERR, strErrorFile );
        else
        {
            strcpy( m_strERR, m_strPath );
            strcat( m_strERR, strErrorFile );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_error overriden by command line\n" );
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: WriteHeader()
// Desc: Copies resource header info to the header buffer.  Grows the header
//       buffer by multiples of 2.
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteHeader( void * pbBuff, DWORD cb )
{
    DWORD cbNew = m_cbHeaderAlloc;

    // Find the next power-of-2 size that is big enough to hold the data
    while( m_cbHeader + cb > cbNew )
        cbNew <<= 1;

    // Realloc if necessary
    if( cbNew > m_cbHeaderAlloc )
    {
        BYTE * pbTemp = (BYTE *)realloc( m_pbHeaderBuff, cbNew );
        if( !pbTemp )
            return E_OUTOFMEMORY;
        m_pbHeaderBuff = pbTemp;
        m_cbHeaderAlloc = cbNew;
    }

    // Copy over the data
    memcpy( m_pbHeaderBuff + m_cbHeader, pbBuff, cb );
    // m_pBundler->m_cbHeader += cb;    // Why don't we do this here?

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteData()
// Desc: Copies data to the data buffer.  Grows our data buffer by multiples
//       of 2
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteData( void * pbBuff, DWORD cb )
{
    DWORD cbNew = m_cbDataAlloc;

    //
    // Find the next power-of-2 size that is 
    // big enough to hold the data
    //
    while( m_cbData + cb > cbNew )
        cbNew <<= 1;
    
    // Realloc if necessary
    if( cbNew > m_cbDataAlloc )
    {
        BYTE * pbTemp = (BYTE *)realloc( m_pbDataBuff, cbNew );
        if( !pbTemp )
            return E_OUTOFMEMORY;
        m_pbDataBuff = pbTemp;
        m_cbDataAlloc = cbNew;
    }

    // Copy over the data
    memcpy( m_pbDataBuff + m_cbData, pbBuff, cb );
    m_cbData += cb;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PadToAlignment()
// Desc: Pads the data buffer to the specified alignment
//-----------------------------------------------------------------------------
HRESULT CBundler::PadToAlignment( DWORD dwAlign )
{
    HRESULT hr = S_OK;
    BYTE * pbTemp = NULL;
    DWORD cbFill = 0;

    if( m_cbData % dwAlign )
        cbFill = dwAlign - ( m_cbData % dwAlign );

    if( cbFill )
    {
        pbTemp = (BYTE *)malloc( cbFill );
        memset( pbTemp, 0xDEAD, cbFill );

        hr = WriteData( pbTemp, cbFill );
        
        free( pbTemp );
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: IsExistingIdentifier()
// Desc: Returns TRUE if we've already processed a resource with the given
//       identifier
//-----------------------------------------------------------------------------
BOOL CBundler::IsExistingIdentifier( char * strIdentifier, DWORD *pdwIndex )
{
    DWORD dwIndex;
    DWORD dwStrLen = strlen( strIdentifier );

    for( dwIndex = 0; dwIndex < m_nResourceCount; dwIndex++ )
    {
        if( strncmp( strIdentifier, m_aResources[ dwIndex ].strIdentifier, dwStrLen ) == 0
            && strlen( m_aResources[ dwIndex ].strIdentifier ) == dwStrLen)
        {
            if (pdwIndex)
                *pdwIndex = dwIndex + 1;    // use base-one indices to reserve 0 for NULL
            return TRUE;
        }
    }

    return FALSE;
}


/*

//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Processes the resource definition file and processes it to create our
//       Xbox Packed Resource (xpr) file and header file
//-----------------------------------------------------------------------------
HRESULT CBundler::Process()
{
    HRESULT hr;
    BUNDLERTOKEN tok;

    // Special case: single-texture conversion
    if( m_bSingleTexture )
    {
        CTexture2D tex(this);
        DWORD cbHeader, cbData;
        
        if( strrchr( m_strRDF, '\\' ) )
            strcpy( tex.m_strSource, strrchr( m_strRDF, '\\' )+1 );
        else
            strcpy( tex.m_strSource, m_strRDF );
        
        // Save the texture to the bundle
        hr = tex.SaveToBundle( &cbHeader, &cbData );
        if( FAILED( hr ) )
            return hr;
    
        printf( "Texture: Wrote %s out in format %s (%d bytes)\n", 
                 tex.m_strSource, tex.m_strFormat, cbData );
        printf( "     %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwLevels );
    
        m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
        m_cbHeader += cbHeader;

        HandleEOFToken();

        return S_OK;
    }
    
    // Open the file
    m_hfRDF = CreateFile( m_strRDF, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfRDF )
    {
        ErrorMsg( "Error: Can't open <%s>\n", m_strRDF );
        return E_FAIL;
    }

    // Iterate over top-level tokens (Texture, out_xxxx, EOF, etc)
    for( ; ; )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        hr = (this->*tok.pfnHandler)();
        if( FAILED( hr ) )
            return hr;
        else if( hr == S_FALSE  )
            break;

    }

    return S_OK;
}

*/

/*

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program
//-----------------------------------------------------------------------------
int _cdecl main( int argc, char * argv[] )
{
    HRESULT hr;
    CBundler bundler;

    hr = bundler.Initialize( argc, argv );
    if(hr == E_INVALIDARG)
    {
        bundler.PrintUsage();
        return 0;
    }
    else if(FAILED(hr))
    {
        bundler.ErrorMsg( "ERROR: D3D Initialization failed.\n" );
        return 0;
    }

    hr = bundler.Process();
    if( FAILED( hr ) )
        return 0;

    return 0;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\CD3DXBlt.h ===
//-----------------------------------------------------------------------------
// File: CD3DXBlt.h
//
// Desc: Contains general purpose blitting routines
//
// Hist: 2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef __CXD3DXBlt_H__
#define __CXD3DXBlt_H__

#include "CD3DXCodec.h"

///////////////////////////////////////////////////////////////////////////
// CXD3DXBlt ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXBlt
{
public:
    CXD3DXBlt();
   ~CXD3DXBlt();

    HRESULT Blt(D3DX_BLT* pDestBlt, D3DX_BLT* pSrcBlt, DWORD dwFilter);

protected:
    // Generic filters
    HRESULT BltSame();
    HRESULT BltCopy();
    HRESULT BltNone();
    HRESULT BltPoint();
    HRESULT BltBox2D();
    HRESULT BltBox3D();
    HRESULT BltLinear2D();
    HRESULT BltLinear3D();
    HRESULT BltTriangle2D();
    HRESULT BltTriangle3D();

    // Optimized filters
    HRESULT BltSame_DXTn();
    HRESULT BltBox2D_R8G8B8();  
    HRESULT BltBox2D_A8R8G8B8();
    HRESULT BltBox2D_X8R8G8B8();
    HRESULT BltBox2D_R5G6B5();  
    HRESULT BltBox2D_X1R5G5B5();
    HRESULT BltBox2D_A1R5G5B5();
    HRESULT BltBox2D_A4R4G4B4();
    HRESULT BltBox2D_R3G3B2();  
    HRESULT BltBox2D_A8();      
    HRESULT BltBox2D_A8R3G3B2();
    HRESULT BltBox2D_X4R4G4B4();
    HRESULT BltBox2D_A8P8();    
    HRESULT BltBox2D_P8();      
    HRESULT BltBox2D_A8L8();    
    HRESULT BltBox2D_A4L4();    

    // Codecs and Filter Type
    CXD3DXCodec *m_pSrc;
    CXD3DXCodec *m_pDest;

    DWORD m_dwFilter;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\bundler.h ===
//-----------------------------------------------------------------------------
// File: Bundler.h
//
// Desc: Header file for the bundler tool
//
// Hist: 2001.02.06 - New for March XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BUNDLER_H
#define BUNDLER_H

#include <assert.h>
#include <windows.h>
#include <d3dx8.h>

#include "xbrc.h"

// Default extensions for output files
#define XPREXT ".xbr"	/* use .xbr instead of .xpr for packed resource files that contain vertex shaders, etc. */
#define HDREXT ".h"
#define ERREXT ".err"

// $BUGBUG 11551
#define MAX_RESOURCES 10000

#define TOKEOF ((CHAR)0xff)

class CBundler;

/*
  typedef HRESULT (CBundler::* TOKENHANDLERFN)();


// Enums for all of our known tokens
typedef enum 
{ 
//    TOKEN_RESOURCE_OPENBRACE             = 0x00000001,
//    TOKEN_RESOURCE_CLOSEBRACE            = 0x00000002,
    TOKEN_RESOURCE_EOF                   = 0x00000003,
    TOKEN_RESOURCE_OUT_PACKEDRESOURCE    = 0x00000004,
    TOKEN_RESOURCE_OUT_HEADER            = 0x00000005, 
    TOKEN_RESOURCE_OUT_PREFIX            = 0x00000006, 
    TOKEN_RESOURCE_OUT_ERROR             = 0x00000007,
    TOKEN_RESOURCE_TEXTURE               = 0x00000010,
    TOKEN_RESOURCE_CUBEMAP               = 0x00000030,
    TOKEN_RESOURCE_VOLUMETEXTURE         = 0x00000050,
    TOKEN_RESOURCE_VERTEXBUFFER          = 0x00000100,
    TOKEN_RESOURCE_USERDATA              = 0x00000200,

    // Properties for a resource have the resource
    // value shifted over by 16 bits
    TOKEN_PROPERTY_TEXTURE                = 0x00100000,
    TOKEN_PROPERTY_TEXTURE_SOURCE         = 0x00100001,
    TOKEN_PROPERTY_TEXTURE_ALPHASOURCE    = 0x00100002,
    TOKEN_PROPERTY_TEXTURE_FILTER         = 0x00100003,
    TOKEN_PROPERTY_TEXTURE_FORMAT         = 0x00100004,
    TOKEN_PROPERTY_TEXTURE_WIDTH          = 0x00100005,
    TOKEN_PROPERTY_TEXTURE_HEIGHT         = 0x00100006,
    TOKEN_PROPERTY_TEXTURE_LEVELS         = 0x00100007,

    TOKEN_PROPERTY_CUBEMAP                = 0x00300000,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_XP      = 0x00300001,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_XN      = 0x00300002,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_YP      = 0x00300003,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_YN      = 0x00300004,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP      = 0x00300005,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN      = 0x00300006,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP = 0x00300011,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN = 0x00300012,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP = 0x00300013,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN = 0x00300014,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP = 0x00300015,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN = 0x00300016,
    TOKEN_PROPERTY_CUBEMAP_SIZE           = 0x00300022,

    TOKEN_PROPERTY_VOLUMETEXTURE             = 0x00500000,
//    TOKEN_PROPERTY_VOLUMETEXTURE_SOURCE      = 0x00500001,
//    TOKEN_PROPERTY_VOLUMETEXTURE_ALPHASOURCE = 0x00500002,
    TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH       = 0x00500003,

    TOKEN_PROPERTY_VB                     = 0x01000000,
    TOKEN_PROPERTY_VB_VERTEXDATA          = 0x01000001,
    TOKEN_PROPERTY_VB_VERTEXFORMAT        = 0x01000002,

    TOKEN_PROPERTY_USERDATA               = 0x02000000,
    TOKEN_PROPERTY_USERDATA_DATAFILE      = 0x02000001,

} TOKEN_ID;
*/

// Types of tokens for validation
typedef enum
{
    TT_ANY = 0,
    TT_IDENTIFIER,
    TT_HEXNUMBER,
    TT_INTEGER,
    TT_FLOAT,
    TT_FILENAME,
} TOKENTYPE;


/*
// Token struct that is passed around
typedef struct _BUNDLERTOKEN
{
    char *          strKeyword;
    TOKEN_ID        eType;
    TOKENTYPE       propType;
    TOKENHANDLERFN  pfnHandler;
} BUNDLERTOKEN;
*/


// Resource struct for tracking
#define BUNDLER_IDENTIFIER_MAX_LENGTH 128
typedef struct 
{
    char    strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH];
    DWORD   dwOffset;
} RESOURCE_STRUCT;




//-----------------------------------------------------------------------------
// Name: class CBundler
// Desc: Main application class for driving the bundler.  Handles data 
//       management, resource tracking, file management, and tokenizing
//-----------------------------------------------------------------------------
class CBundler
{
public:
    CBundler();
    ~CBundler();

    HRESULT Begin(CHAR *strBase);	// default base name of resource, header, and error files
	
    HRESULT SetOutPackedResourceFile(CHAR *strResourceFile);
	HRESULT SetOutHeaderFile(CHAR *strHeaderFile);
    HRESULT SetOutPrefix(CHAR *strPrefix);
    HRESULT SetOutErrorFile(CHAR *strErrorFile);
	
    HRESULT InitD3D();	// used only for image types not handled by LoadImage
    HRESULT WriteHeader( void * pbBuff, DWORD cb );
    HRESULT WriteData( void * pbBuff, DWORD cb );
    HRESULT PadToAlignment( DWORD dwAlign );	// data alignment

    HRESULT End();	// flush output, write files
	
    DWORD   FilterFromString( char* strFilter );

    // D3D stuff for manipulating textures
    LPDIRECT3D8 m_pd3d;
    LPDIRECT3DDEVICE8 m_pd3ddev;
	
    // Routine to call w/ error messages - prints to stderr and file
    void ErrorMsg( char * strFmt, ... );

    BOOL IsExistingIdentifier( char * strIdentifier, DWORD *pIndex = NULL );

    DWORD m_cbHeader;
    DWORD m_cbData;

public:

    HRESULT OpenFiles();            // Open output files
    HRESULT CloseFiles();           // Close all files
    HRESULT FlushDataFile();        // Flush from buffer to output file
    HRESULT WriteSymbolTable();     // Add a symbol table resource to the header
    HRESULT WriteHeaderFile();      // Create .h header file
	
    HRESULT ValidateType( CHAR* strToken, TOKENTYPE tt );

    // Filenames
	CHAR   m_strPath[MAX_PATH];
    CHAR   m_strRDF[MAX_PATH];
    CHAR   m_strXPR[MAX_PATH];
    CHAR   m_strHDR[MAX_PATH];
    CHAR   m_strERR[MAX_PATH];

	// Prefix for header file constants
    CHAR   m_strPrefix[MAX_PATH];

    // File handles
    HANDLE m_hfRDF;
    HANDLE m_hfXPR;
    HANDLE m_hfHDR;
    HANDLE m_hfERR;

    // Data buffer management
    BYTE*  m_pbHeaderBuff;
    DWORD  m_cbHeaderAlloc;
    BYTE*  m_pbDataBuff;
    DWORD  m_cbDataAlloc;

    // Resource tracking
    RESOURCE_STRUCT  m_aResources[MAX_RESOURCES];
    DWORD  m_nResourceCount;

    // For specifying output files and prefix on cmd line vs. in RDF
    BOOL   m_bExplicitXPR;
    BOOL   m_bExplicitHDR;
    BOOL   m_bExplicitERR;
	BOOL   m_bExplicitPrefix;

    // Indicates a single-texture conversion
    BOOL   m_bSingleTexture;
};


#endif // BUNDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\CD3DXCodec.cpp ===
//-----------------------------------------------------------------------------
// File: CD3DXCodec.cpp
//
// Desc: Contains general purpose blitting routines
//
// Hist: 2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "CD3DXCodec.h"
#include "basetexture.h"

extern BOOL D3DX__Premult;

static FLOAT g_fDitherOff[] =
{
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f
};

static FLOAT g_fDitherOn[] =
{
    0.96875f, 0.46875f, 0.84375f, 0.34375f, 0.96875f, 0.46875f, 0.84375f, 0.34375f,
    0.21875f, 0.71875f, 0.09375f, 0.59375f, 0.21875f, 0.71875f, 0.09375f, 0.59375f,
    0.78125f, 0.28125f, 0.90625f, 0.40625f, 0.78125f, 0.28125f, 0.90625f, 0.40625f,
    0.03125f, 0.53125f, 0.15625f, 0.65625f, 0.03125f, 0.53125f, 0.15625f, 0.65625f
};



///////////////////////////////////////////////////////////////////////////
// CXD3DXCodec /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CXD3DXCodec* CXD3DXCodec::Create(D3DX_BLT *pBlt)
{

#define CASE_FORMAT(format) \
    case D3DFMT_##format : \
        return new CXD3DXCodec_##format(pBlt)


    switch(pBlt->Format)
    {
//    CASE_FORMAT(R8G8B8);
#if 0
    CASE_FORMAT(R3G3B2);
    CASE_FORMAT(A8R3G3B2);
    CASE_FORMAT(X4R4G4B4);
    CASE_FORMAT(A8P8);
    CASE_FORMAT(A4L4);
    CASE_FORMAT(X8L8V8U8);
    CASE_FORMAT(W11V11U10);
    CASE_FORMAT(DXT3);
    CASE_FORMAT(DXT5);
#endif
    CASE_FORMAT(A8R8G8B8);
    CASE_FORMAT(X8R8G8B8);
    CASE_FORMAT(R5G6B5);
    CASE_FORMAT(X1R5G5B5);
    CASE_FORMAT(A1R5G5B5);
    CASE_FORMAT(A4R4G4B4);
    CASE_FORMAT(A8);
    CASE_FORMAT(P8);
    CASE_FORMAT(L8);
    CASE_FORMAT(A8L8);

    CASE_FORMAT(V8U8);
    CASE_FORMAT(L6V5U5);
    CASE_FORMAT(Q8W8V8U8);
    CASE_FORMAT(V16U16);

//    CASE_FORMAT(UYVY);
//    CASE_FORMAT(YUY2);
//    CASE_FORMAT(DXT1);
//    CASE_FORMAT(DXT2);
//    CASE_FORMAT(DXT4);
    }

    return NULL;
}

CXD3DXCodec::CXD3DXCodec(D3DX_BLT *pBlt, UINT uBPP, DWORD dwType)
{
    m_pbData = (BYTE *) pBlt->pData;
    m_Format = pBlt->Format;
    m_uPitch = pBlt->RowPitch;
    m_uSlice = pBlt->SlicePitch;
    m_Box = pBlt->SubRegion;
    m_ColorKey = pBlt->ColorKey;
    m_bColorKey = pBlt->ColorKey != 0;
    m_pfDither = pBlt->bDither ? g_fDitherOn : g_fDitherOff;
    m_uBytesPerPixel = uBPP >> 3;
    m_bLinear = uBPP != 0;
    m_dwType = dwType;

    if(CODEC_P == m_dwType)
    {
        m_dwType = CODEC_RGB;
        m_bPalettized = TRUE;

        if(pBlt->pPalette)
        {
            for(UINT i = 0; i < 256; i++)
            {
                m_pPalette[i].r = (FLOAT) pBlt->pPalette[i].peRed   * (1.0f / 255.0f);
                m_pPalette[i].g = (FLOAT) pBlt->pPalette[i].peGreen * (1.0f / 255.0f);
                m_pPalette[i].b = (FLOAT) pBlt->pPalette[i].peBlue  * (1.0f / 255.0f);
                m_pPalette[i].a = (FLOAT) pBlt->pPalette[i].peFlags * (1.0f / 255.0f);
            }
        }
        else
        {
            for(UINT i = 0; i < 256; i++)
            {
                m_pPalette[i].r = m_pPalette[i].g = m_pPalette[i].b = m_pPalette[i].a = 1.0f;
            }
        }
    }
    else
    {
        m_bPalettized = FALSE;
    }


    m_uWidth  = (UINT) (m_Box.Right - m_Box.Left);
    m_uHeight = (UINT) (m_Box.Bottom - m_Box.Top);
    m_uDepth  = (UINT) (m_Box.Back - m_Box.Front);
    m_uWidthBytes = m_uWidth * m_uBytesPerPixel;

    if(m_bLinear)
    {
        m_pbData += m_Box.Front * m_uSlice + m_Box.Top * m_uPitch + m_Box.Left * m_uBytesPerPixel;

        m_Box.Left   = 0;
        m_Box.Top    = 0;
        m_Box.Front  = 0;
        m_Box.Right  = m_uWidth;
        m_Box.Bottom = m_uHeight;
        m_Box.Back   = m_uDepth;
    }
}

CXD3DXCodec::~CXD3DXCodec()
{
    // Do nothing
}

void CXD3DXCodec::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    // Do nothing
}

void CXD3DXCodec::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    // Do nothing
}

void CXD3DXCodec::ColorKey(D3DXCOLOR *pColors)
{
    D3DXCOLOR *pColor;
    D3DXCOLOR *pColorLim = pColors + m_uWidth;

    for(pColor = pColors; pColor < pColorLim; pColor++)
    {
        if(*pColor == m_ColorKey)
            pColor->r = pColor->g = pColor->b = pColor->a = 0.0f;
    }
}


///////////////////////////////////////////////////////////////////////////
// Specific codecs ////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define ENCODE(format) \
    void CXD3DXCodec_##format::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)


ENCODE(R8G8B8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        pub[0] = (UINT8) F2I(pColors[i].b * 255.0f + fDither);
        pub[1] = (UINT8) F2I(pColors[i].g * 255.0f + fDither);
        pub[2] = (UINT8) F2I(pColors[i].r * 255.0f + fDither);

        pub += 3;
    }

    F2IEnd();
}


ENCODE(A8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 255.0f + fDither) << 16) |
                         (F2I(pColors[i].g * 255.0f + fDither) <<  8) |
                         (F2I(pColors[i].b * 255.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 255.0f + fDither) << 24));

        pul++;
    }

    F2IEnd();
}


ENCODE(X8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 255.0f + fDither) << 16) |
                         (F2I(pColors[i].g * 255.0f + fDither) <<  8) |
                         (F2I(pColors[i].b * 255.0f + fDither) <<  0));

        pul++;
    }

    F2IEnd();
}


ENCODE(R5G6B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 11) |
                         (F2I(pColors[i].g * 63.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(X1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 10) |
                         (F2I(pColors[i].g * 31.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(A1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 10) |
                         (F2I(pColors[i].g * 31.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0) |
                         (F2I(pColors[i].a *  1.0f + fDither) << 15));

        pus++;
    }

    F2IEnd();
}


ENCODE(A4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 15.0f + fDither) <<  8) |
                         (F2I(pColors[i].g * 15.0f + fDither) <<  4) |
                         (F2I(pColors[i].b * 15.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 15.0f + fDither) << 12));

        pus++;
    }

    F2IEnd();
}


ENCODE(R3G3B2)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) ((F2I(pColors[i].r * 7.0f + fDither) <<  5) |
                        (F2I(pColors[i].g * 7.0f + fDither) <<  2) |
                        (F2I(pColors[i].b * 3.0f + fDither) <<  0));

        pub++;
    }

    F2IEnd();
}


ENCODE(A8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) F2I(pColors[i].a * 255.0f + fDither);

        pub++;
    }

    F2IEnd();
}


ENCODE(A8R3G3B2)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r *   7.0f + fDither) <<  5) |
                         (F2I(pColors[i].g *   7.0f + fDither) <<  2) |
                         (F2I(pColors[i].b *   3.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 255.0f + fDither) <<  8));

        pus++;
    }

    F2IEnd();
}


ENCODE(X4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 15.0f + fDither) <<  8) |
                         (F2I(pColors[i].g * 15.0f + fDither) <<  4) |
                         (F2I(pColors[i].b * 15.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(A8P8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        UINT uMin = 0;
        FLOAT fDistMin = FLT_MAX;

        for(UINT u = 0; u < 256; u++)
        {
            D3DXCOLOR color = *pColors - m_pPalette[u];
            FLOAT fDist = color.r * color.r + color.g * color.g + color.b * color.b;

            if(fDist < fDistMin)
                uMin = u;
        }

        *pus = (UINT16) (uMin | (F2I(pColors[i].a * 255.0f + fDither) << 8));

        pus++;
    }

    F2IEnd();
}


ENCODE(P8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);


    for(UINT i = 0; i < m_uWidth; i++)
    {
        UINT uMin = 0;
        FLOAT fDistMin = FLT_MAX;

        for(UINT u = 0; u < 256; u++)
        {
            D3DXCOLOR color = pColors[i] - m_pPalette[u];
            FLOAT fDist = color.r * color.r + color.g * color.g + color.b * color.b + color.a * color.a;

            if(fDist < fDistMin)
            {
                uMin = u;
                fDistMin = fDist;
            }
        }

        *pub = (UINT8) uMin;

        pub++;
    }
}


ENCODE(L8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) F2I((pColors[i].r * 0.2125f +
                            pColors[i].g * 0.7154f +
                            pColors[i].b * 0.0721f) * 255.0f + fDither);

        pub++;
    }

    F2IEnd();
}


ENCODE(A8L8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I((pColors[i].r * 0.2125f +
                               pColors[i].g * 0.7154f +
                               pColors[i].b * 0.0721f) * 255.0f + fDither) << 0) |

                         (F2I(pColors[i].a * 255.0f + fDither) << 8));

        pus++;
    }

    F2IEnd();
}


ENCODE(A4L4)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) ((F2I((pColors[i].r * 0.2125f +
                              pColors[i].g * 0.7154f +
                              pColors[i].b * 0.0721f) * 15.0f + fDither) << 0) |

                        (F2I(pColors[i].a * 15.0f + fDither) << 4));

        pub++;
    }

    F2IEnd();
}


ENCODE(V8U8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 128.0f + fDither) & 255) << 0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) << 8);
                      
        pus++;
    }

    F2IEnd();
}


ENCODE(L6V5U5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT32) ((F2I(pColors[i].r * 16.0f + fDither) & 31) <<  0) |
                        ((F2I(pColors[i].g * 16.0f + fDither) & 31) <<  5) |
                        ((F2I(pColors[i].a * 63.0f + fDither) & 63) << 10);

        pus++;
    }

    F2IEnd();
}


ENCODE(X8L8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 128.0f + fDither) & 255) <<  0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) <<  8) |
                        ((F2I(pColors[i].a * 255.0f + fDither) & 255) << 16);

        pul++;
    }

    F2IEnd();
}


ENCODE(Q8W8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 128.0f + fDither) & 255) <<  0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) <<  8) |
                        ((F2I(pColors[i].b * 128.0f + fDither) & 255) << 16) |
                        ((F2I(pColors[i].a * 128.0f + fDither) & 255) << 24);

        pul++;
    }

    F2IEnd();
}


ENCODE(V16U16)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 32768.0f + fDither) & 65535) <<  0) |
                        ((F2I(pColors[i].g * 32768.0f + fDither) & 65535) << 16);

        pul++;
    }

    F2IEnd();
}


ENCODE(W11V11U10)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r *  512.0f + fDither) & 1023) <<  0) |
                        ((F2I(pColors[i].g * 1024.0f + fDither) & 2047) << 10) |
                        ((F2I(pColors[i].b * 1024.0f + fDither) & 2046) << 21);

        pul++;
    }

    F2IEnd();
}




#define DECODE(format) \
    void CXD3DXCodec_##format::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)


DECODE(R8G8B8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidthBytes;

    while(pub < pubLim)
    {
        pColors->r = (FLOAT) pub[2] * (1.0f / 255.0f);
        pColors->g = (FLOAT) pub[1] * (1.0f / 255.0f);
        pColors->b = (FLOAT) pub[0] * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pub += 3;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
        pColors->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
        pColors->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = (FLOAT) ((*pul >> 24) & 255) * (1.0f / 255.0f);

        pul++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
        pColors->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
        pColors->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(R5G6B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 11) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 63) * (1.0f / 63.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 10) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 31) * (1.0f / 31.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 10) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 31) * (1.0f / 31.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = (FLOAT) ((*pus >> 15) &  1) * (1.0f /  1.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  8) & 15) * (1.0f / 15.0f);
        pColors->g = (FLOAT) ((*pus >>  4) & 15) * (1.0f / 15.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = (FLOAT) ((*pus >> 12) & 15) * (1.0f / 15.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(R3G3B2)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = (FLOAT) ((*pub >>  5) & 7) * (1.0f / 7.0f);
        pColors->g = (FLOAT) ((*pub >>  2) & 7) * (1.0f / 7.0f);
        pColors->b = (FLOAT) ((*pub >>  0) & 3) * (1.0f / 3.0f);
        pColors->a = 1.0f;

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = 1.0f;
        pColors->g = 1.0f;
        pColors->b = 1.0f;
        pColors->a = (FLOAT) *pub * (1.0f / 255.0f);

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8R3G3B2)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  5) &   7) * (1.0f /   7.0f);
        pColors->g = (FLOAT) ((*pus >>  2) &   7) * (1.0f /   7.0f);
        pColors->b = (FLOAT) ((*pus >>  0) &   3) * (1.0f /   3.0f);
        pColors->a = (FLOAT) ((*pus >>  8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  8) & 15) * (1.0f / 15.0f);
        pColors->g = (FLOAT) ((*pus >>  4) & 15) * (1.0f / 15.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8P8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        *pColors = m_pPalette[*pus & 255];
        pColors->a = (FLOAT) ((*pus >>  8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(P8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        *pColors = m_pPalette[*pub];

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(L8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) *pub * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8L8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) ((*pus >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = (FLOAT) ((*pus >> 8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A4L4)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) ((*pub >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = (FLOAT) ((*pub >> 4) & 15) * (1.0f / 15.0f);

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}

DECODE(V8U8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pus >> 0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pus >> 8) & 255) * (1.0f / 128.0f);
        pColors->b = 0.0f;
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }
}


DECODE(L6V5U5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        INT8 iU = (INT8) ((*pus >>  0) & 31);
        INT8 iV = (INT8) ((*pus >>  5) & 31);

        // Sign extension
        iU <<= 3; iU >>= 3;
        iV <<= 3; iV >>= 3; 

        pColors->r = (FLOAT) iU * (1.0f / 16.0f);
        pColors->g = (FLOAT) iV * (1.0f / 16.0f);
        pColors->b = 0.0f;
        pColors->a = (FLOAT) ((*pus >> 10) & 63) * (1.0f / 63.0f);

        pus++;
        pColors++;
    }
}


DECODE(X8L8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pul >>  0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pul >>  8) & 255) * (1.0f / 128.0f);
        pColors->b = 0.0f;
        pColors->a = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);

        pul++;
        pColors++;
    }
}


DECODE(Q8W8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pul >>  0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pul >>  8) & 255) * (1.0f / 128.0f);
        pColors->b = (FLOAT) (INT8) ((*pul >> 16) & 255) * (1.0f / 128.0f);
        pColors->a = (FLOAT) (INT8) ((*pul >> 24) & 255) * (1.0f / 128.0f);

        pul++;
        pColors++;
    }
}


DECODE(V16U16)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT16) ((*pul >>  0) & 65535) * (1.0f / 32768.0f);
        pColors->g = (FLOAT) (INT16) ((*pul >> 16) & 65535) * (1.0f / 32768.0f);
        pColors->b = 0.0f;
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }
}


DECODE(W11V11U10)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        INT16 iU = (INT16) ((*pul >>  0) & 1023);
        INT16 iV = (INT16) ((*pul >> 10) & 2047);
        INT16 iW = (INT16) ((*pul >> 21) & 2047);

        // Sign extension
        iU <<= 6; iU >>= 6;
        iV <<= 5; iV >>= 5;
        iW <<= 5; iW >>= 5;

        pColors->r = (FLOAT) iU * (1.0f /  512.0f);
        pColors->g = (FLOAT) iV * (1.0f / 1024.0f);
        pColors->b = (FLOAT) iW * (1.0f / 1024.0f);
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }
}





///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecYUV //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CXD3DXCodecYUV::CXD3DXCodecYUV(D3DX_BLT *pBlt)
    : CXD3DXCodec(pBlt, 0, CODEC_RGB)
{
    m_CacheBox.Left   = m_Box.Left & ~1;
    m_CacheBox.Top    = 0;
    m_CacheBox.Front  = 0;
    m_CacheBox.Right  = (m_Box.Right + 1) & ~1;
    m_CacheBox.Bottom = 0;
    m_CacheBox.Back   = 0;

    m_uCacheWidth = m_CacheBox.Right - m_CacheBox.Left;

    m_bCacheDirty     = FALSE;
    m_bCacheAllocated = TRUE;

    if(!(m_pCache = new D3DXCOLOR[m_uCacheWidth]))
        m_bCacheAllocated = FALSE;

    if(D3DFMT_UYVY == pBlt->Format)
    {
        m_uYShift  = 8;
        m_uUVShift = 0;
    }
    else
    {
        m_uYShift  = 0;
        m_uUVShift = 8;
    }
}


CXD3DXCodecYUV::~CXD3DXCodecYUV()
{
    Commit();

    if(m_pCache)
        delete [] m_pCache;
}


HRESULT CXD3DXCodecYUV::Commit()
{
    if(!m_bCacheDirty || !m_bCacheAllocated)
        return S_OK;


    // Write data
    UINT16 *pus = (UINT16 *) (m_pbData + m_CacheBox.Left * 2 + m_CacheBox.Top * m_uPitch + m_CacheBox.Front * m_uSlice);
    D3DXCOLOR *pCache = m_pCache;

    for(UINT uLeft = m_CacheBox.Left; uLeft < m_CacheBox.Right; uLeft += 2)
    {
        FLOAT fY0 =  65.481f * pCache[0].r + 128.553f * pCache[0].g +  24.966f * pCache[0].b;
        FLOAT fY1 =  65.481f * pCache[1].r + 128.553f * pCache[1].g +  24.966f * pCache[1].b;

        FLOAT fU  = -37.797f * pCache[0].r + -74.203f * pCache[0].g + 112.000f * pCache[0].b;
        FLOAT fV  = 112.000f * pCache[0].r + -93.786f * pCache[0].g + -18.214f * pCache[0].b;

        int nY0 = F2I(fY0 + 0.5f) + 16;
        int nY1 = F2I(fY1 + 0.5f) + 16;
        int nU  = F2I(fU + 0.5f) + 128;
        int nV  = F2I(fV + 0.5f) + 128;

        nY0 = (nY0 < 0) ? 0 : ((nY0 > 0xff) ? 0xff : nY0);
        nY1 = (nY1 < 0) ? 0 : ((nY1 > 0xff) ? 0xff : nY1);
        nU  = (nU  < 0) ? 0 : ((nU  > 0xff) ? 0xff : nU );
        nV  = (nV  < 0) ? 0 : ((nV  > 0xff) ? 0xff : nV );

        pus[0] = (UINT16) ((nY0 << m_uYShift) | (nU << m_uUVShift));
        pus[1] = (UINT16) ((nY1 << m_uYShift) | (nV << m_uUVShift));

        pCache += 2;
        pus += 2;
    }

    m_bCacheDirty = FALSE;
    return S_OK;
}


HRESULT CXD3DXCodecYUV::Fetch(UINT uRow, UINT uSlice, BOOL bRead)
{
    HRESULT hr;

    if(!m_bCacheAllocated)
        return E_OUTOFMEMORY;

    if(uRow   >= m_CacheBox.Top   && uRow   < m_CacheBox.Bottom &&
       uSlice >= m_CacheBox.Front && uSlice < m_CacheBox.Back)
    {
        return S_OK;
    }

    // Flush dirty data in cache, if any
    if(FAILED(hr = Commit()))
        return hr;

    // Update cache rect
    m_CacheBox.Top    = uRow;
    m_CacheBox.Bottom = uRow + 1;
    m_CacheBox.Front  = uSlice;
    m_CacheBox.Back   = uSlice + 1;

    if(!bRead)
        return S_OK;


    // Read data
    UINT16 *pus = (UINT16 *) (m_pbData + m_CacheBox.Left * 2 + m_CacheBox.Top * m_uPitch + m_CacheBox.Front * m_uSlice);
    D3DXCOLOR *pCache = m_pCache;

    for(UINT uLeft = m_CacheBox.Left; uLeft < m_CacheBox.Right; uLeft += 2)
    {
        FLOAT fY0 = (FLOAT) ((pus[0] >> m_uYShift)  & 0xff) -  16.0f;
        FLOAT fU  = (FLOAT) ((pus[0] >> m_uUVShift) & 0xff) - 128.0f;

        FLOAT fY1 = (FLOAT) ((pus[1] >> m_uYShift)  & 0xff) -  16.0f;
        FLOAT fV  = (FLOAT) ((pus[1] >> m_uUVShift) & 0xff) - 128.0f;

        pCache[0].r = 0.00456621f * fY0                    + 0.00625893f * fV;
        pCache[0].g = 0.00456621f * fY0 - 0.00153632f * fU - 0.00318811f * fV;
        pCache[0].b = 0.00456621f * fY0 + 0.00791071f * fU;
        pCache[0].a = 1.0f;

        pCache[0].r = (pCache[0].r < 0.0f) ? 0.0f : ((pCache[0].r > 1.0f) ? 1.0f : pCache[0].r);
        pCache[0].g = (pCache[0].g < 0.0f) ? 0.0f : ((pCache[0].g > 1.0f) ? 1.0f : pCache[0].g);
        pCache[0].b = (pCache[0].b < 0.0f) ? 0.0f : ((pCache[0].b > 1.0f) ? 1.0f : pCache[0].b);

        pCache[1].r = 0.00456621f * fY1                    + 0.00625893f * fV;
        pCache[1].g = 0.00456621f * fY1 - 0.00153632f * fU - 0.00318811f * fV;
        pCache[1].b = 0.00456621f * fY1 + 0.00791071f * fU;
        pCache[1].a = 1.0f;

        pCache[1].r = (pCache[1].r < 0.0f) ? 0.0f : ((pCache[1].r > 1.0f) ? 1.0f : pCache[1].r);
        pCache[1].g = (pCache[1].g < 0.0f) ? 0.0f : ((pCache[1].g > 1.0f) ? 1.0f : pCache[1].g);
        pCache[1].b = (pCache[1].b < 0.0f) ? 0.0f : ((pCache[1].b > 1.0f) ? 1.0f : pCache[1].b);

        pCache += 2;
        pus += 2;
    }

    return S_OK;
}


void CXD3DXCodecYUV::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, m_uCacheWidth != m_uWidth)))
        return;

    memcpy(m_pCache + m_Box.Left - m_CacheBox.Left, pColors, m_uWidth * sizeof(D3DXCOLOR));
    m_bCacheDirty = TRUE;
}


void CXD3DXCodecYUV::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, TRUE)))
        return;

    memcpy(pColors, m_pCache + m_Box.Left - m_CacheBox.Left, m_uWidth * sizeof(D3DXCOLOR));

    if(m_bColorKey)
        ColorKey(pColors);
}



#ifdef SUPPORT_DXT
///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecDXT //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CXD3DXCodecDXT::CXD3DXCodecDXT(D3DX_BLT *pBlt)
    : CXD3DXCodec(pBlt, 0, CODEC_RGB)
{
    m_bRepeat = FALSE;

    switch(pBlt->Region.Right)
    {
    case 1:
        m_uXRepeat = 0;
        m_bRepeat = TRUE;
        break;

    case 2:
        m_uXRepeat = 1;
        m_bRepeat = TRUE;
        break;

    default:
        m_uXRepeat = 3;
        break;
    }


    switch(pBlt->Region.Bottom)
    {
    case 1:
        m_uYRepeat = 0;
        m_bRepeat = TRUE;
        break;

    case 2:
        m_uYRepeat = 1;
        m_bRepeat = TRUE;
        break;

    default:
        m_uYRepeat = 3;
        break;
    }


    m_CacheBox.Left   = m_Box.Left & ~3;
    m_CacheBox.Top    = 0;
    m_CacheBox.Front  = 0;
    m_CacheBox.Right  = (m_Box.Right + 3) & ~3;
    m_CacheBox.Bottom = 0;
    m_CacheBox.Back   = 0;

    m_uTopMax     = 0;
    m_uCacheWidth = m_CacheBox.Right - m_CacheBox.Left;

    m_bCacheDirty     = FALSE;
    m_bCacheAllocated = TRUE;

    for(UINT i = 0; i < 4; i++)
    {
        if(!(m_ppCache[i] = new D3DXCOLOR[m_uCacheWidth]))
            m_bCacheAllocated = FALSE;
    }
}


CXD3DXCodecDXT::~CXD3DXCodecDXT()
{
    Commit();

    for(UINT i = 0; i < 4; i++)
    {
        if(m_ppCache[i])
            delete [] m_ppCache[i];
    }
}


HRESULT CXD3DXCodecDXT::Commit()
{
    if(!m_bCacheDirty || !m_bCacheAllocated)
        return S_OK;

    BOOL bPremult = D3DX__Premult;

    for(UINT uLeft = m_CacheBox.Left; uLeft < (UINT) m_CacheBox.Right; uLeft += 4)
    {
        UINT32 ulBlock[16];
        LPBYTE pCell;

        // Copy cache data into block
        F2IBegin();
        UINT32 *pul = &ulBlock[0];

        if(bPremult)
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

                for(UINT uX = 0; uX < 4; uX++)
                {
                    *pul = (UINT32) ((F2I(pColor->r * pColor->a * 255.0f + 0.5f) << 16) |
                                     (F2I(pColor->g * pColor->a * 255.0f + 0.5f) <<  8) |
                                     (F2I(pColor->b * pColor->a * 255.0f + 0.5f) <<  0) |
                                     (F2I(pColor->a             * 255.0f + 0.5f) << 24));

                    pColor++;
                    pul++;
                }
            }
        }
        else
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

                for(UINT uX = 0; uX < 4; uX++)
                {
                    *pul = (UINT32) ((F2I(pColor->r * 255.0f + 0.5f) << 16) |
                                     (F2I(pColor->g * 255.0f + 0.5f) <<  8) |
                                     (F2I(pColor->b * 255.0f + 0.5f) <<  0) |
                                     (F2I(pColor->a * 255.0f + 0.5f) << 24));


                    pColor++;
                    pul++;
                }
            }
        }

        F2IEnd();


        // Repeat data for degenerate case
        if(m_bRepeat)
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                for(UINT uX = 0; uX < 4; uX++)
                {
                    ulBlock[(uY << 2) + uX] = ulBlock[((uY & m_uYRepeat) << 2) + (uX & m_uXRepeat)];
                }
            }
        }


        // Encode DXT block
        switch (m_Format)
        {
        case D3DFMT_DXT1:
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockRGB);
            XXEncodeBlockRGB((S3TC_COLOR *) &ulBlock[0], (S3TCBlockRGB *) pCell);
            break;

        case D3DFMT_DXT2:
#if 0
        case D3DFMT_DXT3:
#endif
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha4);
            EncodeBlockAlpha4((S3TC_COLOR *) &ulBlock[0], (S3TCBlockAlpha4 *) pCell);
            break;

        case D3DFMT_DXT4:
#if 0
        case D3DFMT_DXT5:
#endif
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha3);
            EncodeBlockAlpha3((S3TC_COLOR *) &ulBlock[0], (S3TCBlockAlpha3 *) pCell);
            pCell = pCell;
            break;
        }
    }

    m_bCacheDirty = FALSE;
    return S_OK;
}


HRESULT CXD3DXCodecDXT::Fetch(UINT uRow, UINT uSlice, BOOL bRead)
{
    HRESULT hr;

    if(!m_bCacheAllocated)
        return E_OUTOFMEMORY;

    if(uRow   >= m_CacheBox.Top   && uRow   < m_CacheBox.Bottom &&
       uSlice >= m_CacheBox.Front && uSlice < m_CacheBox.Back)
    {
        return S_OK;
    }

    // Flush dirty data in cache, if any
    if(FAILED(hr = Commit()))
        return hr;



    // Update cache rect
    m_CacheBox.Top    = uRow & ~3;
    m_CacheBox.Bottom = m_CacheBox.Top + 4;
    m_CacheBox.Front  = uSlice;
    m_CacheBox.Back   = uSlice + 1;

    if(m_uTopMax <= m_CacheBox.Top)
    {
        m_uTopMax = m_CacheBox.Top;

        if(!bRead)
            return S_OK;
    }



    // Read data
    BOOL bPremult = D3DX__Premult;

    for(UINT uLeft = m_CacheBox.Left; uLeft < (UINT) m_CacheBox.Right; uLeft += 4)
    {
        UINT32 ulBlock[16];
        LPBYTE pCell;

        // Decode DXT block
        switch (m_Format)
        {
        case D3DFMT_DXT1:
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockRGB);
            XXDecodeBlockRGB((S3TCBlockRGB *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;

        case D3DFMT_DXT2:
#if 0
        case D3DFMT_DXT3:
#endif
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha4);
            DecodeBlockAlpha4((S3TCBlockAlpha4 *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;

        case D3DFMT_DXT4:
#if 0
        case D3DFMT_DXT5:
#endif
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha3);
            DecodeBlockAlpha3((S3TCBlockAlpha3 *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;
        }


        // Copy block data into cache
        UINT32 *pul = &ulBlock[0];

        for(UINT uY = 0; uY < 4; uY++)
        {
            D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

            for(UINT uX = 0; uX < 4; uX++)
            {
                pColor->a = (FLOAT) ((*pul >> 24) & 255) * (1.0f / 255.0f);
                pColor->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
                pColor->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
                pColor->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);

                if(bPremult)
                {
                    if(0.0f == pColor->a)
                    {
                        pColor->r = 0.0f;
                        pColor->g = 0.0f;
                        pColor->b = 0.0f;
                    }
                    else if(1.0f > pColor->a)
                    {
                        pColor->r = (pColor->r < pColor->a) ? (pColor->r / pColor->a) : 1.0f;
                        pColor->g = (pColor->g < pColor->a) ? (pColor->g / pColor->a) : 1.0f;
                        pColor->b = (pColor->b < pColor->a) ? (pColor->b / pColor->a) : 1.0f;
                    }
                }

                pColor++;
                pul++;
            }
        }
    }

    return S_OK;
}


void CXD3DXCodecDXT::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, m_uCacheWidth != m_uWidth)))
        return;

    memcpy(m_ppCache[uRow - m_CacheBox.Top] + m_Box.Left - m_CacheBox.Left, pColors, m_uWidth * sizeof(D3DXCOLOR));
    m_bCacheDirty = TRUE;
}


void CXD3DXCodecDXT::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, TRUE)))
        return;

    memcpy(pColors, m_ppCache[uRow - m_CacheBox.Top] + m_Box.Left - m_CacheBox.Left, m_uWidth * sizeof(D3DXCOLOR));

    if(m_bColorKey)
        ColorKey(pColors);
}
#endif // SUPPORT_DXT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\cd3dxblt.cpp ===
//-----------------------------------------------------------------------------
// File: CD3DXBlt.cpp
//
// Desc: Contains general purpose blitting routines
//
// Hist: 2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "CD3DXBlt.h"

#define DPF(x,y)
#define D3DXASSERT(x)

///////////////////////////////////////////////////////////////////////////
// CXD3DXBlt ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CXD3DXBlt::CXD3DXBlt()
{
    m_pDest = NULL;
    m_pSrc  = NULL;
}


CXD3DXBlt::~CXD3DXBlt()
{
    if(m_pDest)
        delete m_pDest;

    if(m_pSrc)
        delete m_pSrc;
}

HRESULT CXD3DXBlt::Blt(D3DX_BLT* pDestBlt, D3DX_BLT* pSrcBlt, DWORD dwFilter)
{
    HRESULT hr;

    m_pDest = NULL;
    m_pSrc  = NULL;
    m_dwFilter = dwFilter;


    // Validate filter
    switch(dwFilter & 0xffff)
    {
    case D3DX_FILTER_NONE:
    case D3DX_FILTER_POINT:
    case D3DX_FILTER_LINEAR:
    case D3DX_FILTER_TRIANGLE:
    case D3DX_FILTER_BOX:
        break;

    default:
        DPF(0, "Invalid image filter");
        return D3DERR_INVALIDCALL;
    }

    if(dwFilter & (0xffff0000 & ~(D3DX_FILTER_MIRROR | D3DX_FILTER_DITHER)))
    {
        DPF(0, "Invalid image filter");
        return D3DERR_INVALIDCALL;
    }

    pDestBlt->bDither = (dwFilter & D3DX_FILTER_DITHER);


    // Find codecs
    if(!(m_pDest = CXD3DXCodec::Create(pDestBlt)) ||
       !(m_pSrc  = CXD3DXCodec::Create(pSrcBlt)))
    {
        DPF(0, "Unsupported image format");
        hr = E_FAIL;
        goto LDone;
    }


    // Make sure compatible image types
    if(m_pDest->m_dwType != m_pSrc->m_dwType)
    {
        DPF(0, "No conversion exists between source and destination image formats");
        hr = E_FAIL;
        goto LDone;
    }


    // Find blitter
    if(FAILED(BltSame()) &&
       FAILED(BltCopy()) &&
       FAILED(BltNone()) &&
       FAILED(BltPoint()) &&
       FAILED(BltBox2D()) &&
       FAILED(BltBox3D()) &&
       FAILED(BltLinear2D()) &&
       FAILED(BltLinear3D()) &&
       FAILED(BltTriangle2D()) &&
       FAILED(BltTriangle3D()))
    {
        DPF(0, "No suitable image filter found");
        hr = E_FAIL;
        goto LDone;
    }

    hr = S_OK;
    goto LDone;

LDone:
    if(m_pDest)
    {
        delete m_pDest;
        m_pDest = NULL;
    }

    if(m_pSrc)
    {
        delete m_pSrc;
        m_pSrc = NULL;
    }

    return hr;
}



HRESULT CXD3DXBlt::BltSame()
{
    if(m_pDest->m_Format != m_pSrc->m_Format)
        return E_FAIL;

    if(m_pSrc->m_bColorKey)
        return E_FAIL;

    if(m_pDest->m_uWidth  != m_pSrc->m_uWidth || 
       m_pDest->m_uHeight != m_pSrc->m_uHeight ||
       m_pDest->m_uDepth  != m_pSrc->m_uDepth)
    {
        return E_FAIL;
    }

#ifdef SUPPORT_DXT
    if(!m_pDest->m_bLinear)
        return BltSame_DXTn();
#endif // SUPPORT_DXT

    if(m_pDest->m_bPalettized && m_pDest->m_pPalette != m_pSrc->m_pPalette && 
        memcmp(m_pDest->m_pPalette, m_pSrc->m_pPalette, 256 * sizeof(PALETTEENTRY)))
    {
        return E_FAIL;
    }



    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        BYTE *pbDest = m_pDest->m_pbData + uZ * m_pDest->m_uSlice;
        BYTE *pbSrc  = m_pSrc ->m_pbData + uZ * m_pSrc ->m_uSlice;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            memcpy(pbDest, pbSrc, m_pDest->m_uWidthBytes);

            pbDest += m_pDest->m_uPitch;
            pbSrc  += m_pSrc ->m_uPitch;
        }
    }

    return S_OK;
}


HRESULT CXD3DXBlt::BltCopy()
{
    D3DXCOLOR *pColor;

    if(m_pDest->m_uWidth  != m_pSrc->m_uWidth || 
       m_pDest->m_uHeight != m_pSrc->m_uHeight ||
       m_pDest->m_uDepth  != m_pSrc->m_uDepth)
    {
        return E_FAIL;
    }

    if(!(pColor = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_FAIL;

//  DPF(0, "blt copy %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            m_pSrc ->Decode(uY, uZ, pColor);
            m_pDest->Encode(uY, uZ, pColor);
        }
    }

    delete [] pColor;
    return S_OK;
}


HRESULT CXD3DXBlt::BltNone()
{
    UINT uWidthMax, uWidthMin, uHeightMin, uDepthMin, uY, uZ;

    D3DXCOLOR *pColor;
    D3DXCOLOR *pBlack;

    if((m_dwFilter & 0xff) != D3DX_FILTER_NONE)
        return E_FAIL;

//  DPF(0, "blt none %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    uWidthMax  = (m_pDest->m_uWidth  > m_pSrc->m_uWidth)  ? m_pDest->m_uWidth  : m_pSrc->m_uWidth;
    uWidthMin  = (m_pDest->m_uWidth  < m_pSrc->m_uWidth)  ? m_pDest->m_uWidth  : m_pSrc->m_uWidth;
    uHeightMin = (m_pDest->m_uHeight < m_pSrc->m_uHeight) ? m_pDest->m_uHeight : m_pSrc->m_uHeight;
    uDepthMin  = (m_pDest->m_uDepth  < m_pSrc->m_uDepth)  ? m_pDest->m_uDepth  : m_pSrc->m_uDepth;

    if(!(pColor = new D3DXCOLOR[uWidthMax]))
        return E_FAIL;

    if(!(pBlack = new D3DXCOLOR[m_pDest->m_uWidth]))
    {
        delete [] pColor;
        return E_FAIL;
    }

    memset(pColor, 0x00, uWidthMax * sizeof(D3DXCOLOR));
    memset(pBlack, 0x00, m_pDest->m_uWidth * sizeof(D3DXCOLOR));


    for(uZ = 0; uZ < uDepthMin; uZ++)
    {
        for(uY = 0; uY < uHeightMin; uY++)
        {
            m_pSrc ->Decode(uY, uZ, pColor);
            m_pDest->Encode(uY, uZ, pColor);
        }

        for(uY = uHeightMin; uY < m_pDest->m_uHeight; uY++)
            m_pDest->Encode(uY, uZ, pBlack);
    }

    for(uZ = uDepthMin; uZ < m_pDest->m_uDepth; uZ++)
    {
        for(uY = 0; uY < m_pDest->m_uHeight; uY++)
            m_pDest->Encode(uY, uZ, pBlack);
    }

    delete [] pColor;
    delete [] pBlack;
    return S_OK;
}


HRESULT CXD3DXBlt::BltPoint()
{
    D3DXCOLOR *pSrc;
    D3DXCOLOR *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_POINT)
        return E_FAIL;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        return E_OUTOFMEMORY;

    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
    {
        delete []pSrc;
        return E_OUTOFMEMORY;
    }


//  DPF(0, "blt point %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    UINT uSrcXInc = (m_pSrc->m_uWidth  << 16) / m_pDest->m_uWidth;
    UINT uSrcYInc = (m_pSrc->m_uHeight << 16) / m_pDest->m_uHeight;
    UINT uSrcZInc = (m_pSrc->m_uDepth  << 16) / m_pDest->m_uDepth;

    UINT uSrcZ  = 0;
    UINT uDestZ = 0;

    while(uDestZ < m_pDest->m_uDepth)
    {
        UINT uSrcY  = 0;
        UINT uDestY = 0;
        UINT uSrcYLast = (UINT) -1;

        while(uDestY < m_pDest->m_uHeight)
        {
            UINT uSrcX  = 0;
            UINT uDestX = 0;

            if((uSrcYLast ^ uSrcY) >> 16)
            {
                m_pSrc->Decode(uSrcY >> 16, uSrcZ >> 16, pSrc);
                uSrcYLast = uSrcY;
            }

            while(uDestX < m_pDest->m_uWidth)
            {
                pDest[uDestX] = pSrc[uSrcX >> 16];

                uSrcX += uSrcXInc;
                uDestX++;
            }

            m_pDest->Encode(uDestY, uDestZ, pDest);

            uSrcY += uSrcYInc;
            uDestY++;
        }

        uSrcZ += uSrcZInc;
        uDestZ++;
    }

    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}


HRESULT CXD3DXBlt::BltBox2D()
{
    HRESULT hr;

    D3DXCOLOR *pxyz, *pxYz, *pXyz, *pXYz;
    D3DXCOLOR *pSrc, *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_BOX)
        return E_FAIL;

    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(!(m_pDest->m_uWidth == (m_pSrc->m_uWidth >> 1)) && 
       !(1 == m_pDest->m_uWidth && 1 == m_pSrc->m_uWidth))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uHeight == (m_pSrc->m_uHeight >> 1)) && 
       !(1 == m_pDest->m_uHeight && 1 == m_pSrc->m_uHeight))
    {
        return E_FAIL;
    }

    if(!(1 == m_pDest->m_uDepth && 1 == m_pSrc->m_uDepth))
        return E_FAIL;

//  DPF(0, "blt box %d->%d", m_pSrc->m_Format, m_pDest->m_Format);



    // Optimized filters
    if(!(m_dwFilter & D3DX_FILTER_DITHER) && (m_pSrc->m_Format == m_pDest->m_Format) && 
        (m_pSrc->m_uWidth >= 2) && (m_pSrc->m_uHeight >= 2))
    {
        hr = E_NOTIMPL;

        switch(m_pSrc->m_Format)
        {
#if 0
        case D3DFMT_R8G8B8:   hr = BltBox2D_R8G8B8();   break;
        case D3DFMT_R3G3B2:   hr = BltBox2D_R3G3B2();   break;
        case D3DFMT_A8R3G3B2: hr = BltBox2D_A8R3G3B2(); break;
        case D3DFMT_X4R4G4B4: hr = BltBox2D_X4R4G4B4(); break;
        case D3DFMT_A8P8:     hr = BltBox2D_A8P8();     break;
        case D3DFMT_A4L4:     hr = BltBox2D_A4L4();     break;
#endif
        case D3DFMT_A8R8G8B8: hr = BltBox2D_A8R8G8B8(); break;
        case D3DFMT_X8R8G8B8: hr = BltBox2D_X8R8G8B8(); break;
        case D3DFMT_R5G6B5:   hr = BltBox2D_R5G6B5();   break;
        case D3DFMT_X1R5G5B5: hr = BltBox2D_X1R5G5B5(); break;
        case D3DFMT_A1R5G5B5: hr = BltBox2D_A1R5G5B5(); break;
        case D3DFMT_A4R4G4B4: hr = BltBox2D_A4R4G4B4(); break;
        case D3DFMT_A8:       hr = BltBox2D_A8();       break;
        case D3DFMT_P8:       hr = BltBox2D_P8();       break;
        case D3DFMT_L8:       hr = BltBox2D_A8();       break;
        case D3DFMT_A8L8:     hr = BltBox2D_A8L8();     break;
        }

        if(SUCCEEDED(hr))
            return S_OK;
    }


    // Generic filter
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_OUTOFMEMORY;

    if(1 == m_pSrc->m_uHeight)
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth];

        pxyz = pSrc;
        pxYz = pxyz;
    }
    else
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxYz = pSrc + m_pSrc->m_uWidth * 1;
    }

    if(!pSrc)
    {
        delete [] pDest;
        return E_OUTOFMEMORY;
    }

    if(1 == m_pSrc->m_uWidth)
    {
        pXyz = pxyz;
        pXYz = pxYz;
    }
    else
    {
        pXyz = pxyz + 1;
        pXYz = pxYz + 1;
    }


    for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
    {
        UINT uY2 = uY << 1;

        m_pSrc->Decode(uY2 + 0, 0, pxyz);

        if(pxYz != pxyz)
            m_pSrc->Decode(uY2 + 1, 0, pxYz);


        for(UINT uX = 0; uX < m_pDest->m_uWidth; uX++)
        {
            UINT uX2 = uX << 1;
            pDest[uX] = (pxyz[uX2] + pXyz[uX2] + pxYz[uX2] + pXYz[uX2]) * 0.25f;
        }

        m_pDest->Encode(uY, 0, pDest);
    }


    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}



HRESULT CXD3DXBlt::BltBox3D()
{
    D3DXCOLOR *pxyz, *pxyZ, *pxYz, *pxYZ, *pXyz, *pXyZ, *pXYz, *pXYZ;
    D3DXCOLOR *pSrc, *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_BOX)
        return E_FAIL;

    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(!(m_pDest->m_uWidth == (m_pSrc->m_uWidth >> 1)) && 
       !(1 == m_pDest->m_uWidth && 1 == m_pSrc->m_uWidth))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uHeight == (m_pSrc->m_uHeight >> 1)) && 
       !(1 == m_pDest->m_uHeight && 1 == m_pSrc->m_uHeight))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uDepth == (m_pSrc->m_uDepth >> 1)))
        return E_FAIL;

//  DPF(0, "blt box %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_OUTOFMEMORY;

    if(1 == m_pSrc->m_uHeight)
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxyZ = pSrc + m_pSrc->m_uWidth * 1;
        pxYz = pxyz;
        pxYZ = pxyZ;
    }
    else
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 4];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxyZ = pSrc + m_pSrc->m_uWidth * 1;
        pxYz = pSrc + m_pSrc->m_uWidth * 2;
        pxYZ = pSrc + m_pSrc->m_uWidth * 3;
    }

    if(!pSrc)
    {
        delete [] pDest;
        return E_OUTOFMEMORY;
    }

    if(1 == m_pSrc->m_uWidth)
    {
        pXyz = pxyz;
        pXyZ = pxyZ;
        pXYz = pxYz;
        pXYZ = pxYZ;
    }
    else
    {
        pXyz = pxyz + 1;
        pXyZ = pxyZ + 1;
        pXYz = pxYz + 1;
        pXYZ = pxYZ + 1;
    }



    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        UINT uZ2 = uZ << 1;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            UINT uY2 = uY << 1;

            m_pSrc->Decode(uY2 + 0, uZ2 + 0, pxyz);

            if(pxyZ != pxyz)
                m_pSrc->Decode(uY2 + 0, uZ2 + 1, pxyZ);

            if(pxYz != pxyz)
                m_pSrc->Decode(uY2 + 1, uZ2 + 0, pxYz);

            if(pxYZ != pxyZ && pxYZ != pxYz)
                m_pSrc->Decode(uY2 + 1, uZ2 + 1, pxYZ);


            for(UINT uX = 0; uX < m_pDest->m_uWidth; uX++)
            {
                UINT uX2 = uX << 1;

                pDest[uX] = (pxyz[uX2] + pXyz[uX2] + pxyZ[uX2] + pXyZ[uX2] +
                             pxYz[uX2] + pXYz[uX2] + pxYZ[uX2] + pXYZ[uX2]) * 0.125f;
            }

            m_pDest->Encode(uY, uZ, pDest);
        }
    }

    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}



// ---------------------------------------------------------------------------
//
// LF - Linear filter
//
// This section of the code defines a bunch of structures, macros, and
// functions which are used for the linear filter.
//
// ---------------------------------------------------------------------------

struct LF_From
{
    UINT uFrom;
    float fWeight;
};

struct LF_To
{
    LF_From pFrom[2];
};


static UINT8 *
LF_SetupLinear(UINT uSrcLim, UINT uDstLim, BOOL bRepeat)
{
    LF_To *pTo;
    UINT8 *pbFilter;
    
    if(!(pTo = new LF_To[uDstLim]))
        return NULL;

    pbFilter = (UINT8 *) pTo;
    float fScale = (float) uSrcLim / (float) uDstLim;

    F2IBegin();

    for(UINT u = 0; u < uDstLim; u++)
    {
        float fSrc = (float) u * fScale - 0.5f;
        float fSrcFloor = floorf(fSrc);

        int iSrcA = F2I(fSrcFloor);
        int iSrcB = iSrcA + 1;

        if(iSrcA < 0)
            iSrcA = bRepeat ? uSrcLim - 1 : 0;

        if((UINT) iSrcB >= uSrcLim)
            iSrcB = bRepeat ? 0 : uSrcLim - 1;

        pTo->pFrom[0].uFrom   = (UINT) iSrcA;
        pTo->pFrom[0].fWeight = 1.0f - (fSrc - fSrcFloor);

        pTo->pFrom[1].uFrom   = (UINT) iSrcB;
        pTo->pFrom[1].fWeight = 1.0f - pTo->pFrom[0].fWeight;

        pTo++;
    }

    F2IEnd();

    return pbFilter;
}


HRESULT CXD3DXBlt::BltLinear2D()
{
    HRESULT hr;

    BOOL bRepeatX;
    BOOL bRepeatY;

    BYTE *pbXFilter = NULL;
    BYTE *pbYFilter = NULL;

    LF_To *pToX;
    LF_To *pToY;

    D3DXCOLOR *pDest = NULL;
    D3DXCOLOR *pSrc  = NULL;
    D3DXCOLOR *pSrcT;
    D3DXCOLOR *pxyz, *pxYz;

    UINT uX;
    UINT uY;
    UINT uFrom0;
    UINT uFrom1;


    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if((m_dwFilter & 0xff) != D3DX_FILTER_LINEAR)
        return E_FAIL;

//  DPF(0, "blt linear %d->%d", m_pSrc->m_Format, m_pDest->m_Format);


    // Create linear filters
    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);

    pbXFilter = LF_SetupLinear(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX);
    pbYFilter = LF_SetupLinear(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY);

    if(!pbXFilter || !pbYFilter)
        goto LOutOfMemory;


    // Create temp color space
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        goto LOutOfMemory;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2]))
        goto LOutOfMemory;

    pxyz = pSrc + m_pSrc->m_uWidth * 0;
    pxYz = pSrc + m_pSrc->m_uWidth * 1;



    uY = 0;
    pToY = (LF_To *) pbYFilter;

    uFrom0 = (UINT) -1;
    uFrom1 = (UINT) -1;

    while(uY < m_pDest->m_uHeight)
    {
        uX = 0;
        pToX = (LF_To *) pbXFilter;

        if(pToY->pFrom[0].uFrom != uFrom0)
        {
            if(pToY->pFrom[0].uFrom != uFrom1)
            {
                uFrom0 = pToY->pFrom[0].uFrom;
                m_pSrc->Decode(uFrom0, 0, pxyz);
            }
            else
            {
                uFrom0 = uFrom1;
                uFrom1 = (UINT) -1;

                pSrcT = pxyz; pxyz = pxYz; pxYz = pSrcT;
            }
        }

        if(pToY->pFrom[1].uFrom != uFrom1)
        {
            uFrom1 = pToY->pFrom[1].uFrom;
            m_pSrc->Decode(uFrom1, 0, pxYz);
        }

        while(uX < m_pDest->m_uWidth)
        {
            pDest[uX] = ((pxyz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                          pxyz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                         (pxYz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                          pxYz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight);

            pToX++;
            uX++;
        }

        m_pDest->Encode(uY, 0, pDest);

        pToY++;
        uY++;
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    delete [] pbXFilter;
    delete [] pbYFilter;

    delete [] pDest;
    delete [] pSrc;

    return hr;
}




HRESULT CXD3DXBlt::BltLinear3D()
{
    HRESULT hr;

    BOOL bRepeatX;
    BOOL bRepeatY;
    BOOL bRepeatZ;

    BYTE *pbXFilter = NULL;
    BYTE *pbYFilter = NULL;
    BYTE *pbZFilter = NULL;

    LF_To *pToX;
    LF_To *pToY;
    LF_To *pToZ;

    D3DXCOLOR *pDest = NULL;
    D3DXCOLOR *pSrc  = NULL;
    D3DXCOLOR *pSrcT;
    D3DXCOLOR *pxyz, *pxYz, *pxyZ, *pxYZ;

    UINT uX;
    UINT uY;
    UINT uZ;
    UINT uFrom0;
    UINT uFrom1;


    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if((m_dwFilter & 0xff) != D3DX_FILTER_LINEAR)
        return E_FAIL;

//  DPF(0, "blt linear %d->%d", m_pSrc->m_Format, m_pDest->m_Format);


    // Create linear filters
    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);
    bRepeatZ = !(m_dwFilter & D3DX_FILTER_MIRROR_W);

    pbXFilter = LF_SetupLinear(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX);
    pbYFilter = LF_SetupLinear(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY);
    pbZFilter = LF_SetupLinear(m_pSrc->m_uDepth,  m_pDest->m_uDepth,  bRepeatZ);

    if(!pbXFilter || !pbYFilter || !pbZFilter)
        goto LOutOfMemory;


    // Create temp color space
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        goto LOutOfMemory;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 4]))
        goto LOutOfMemory;

    pxyz = pSrc + m_pSrc->m_uWidth * 0;
    pxYz = pSrc + m_pSrc->m_uWidth * 1;
    pxyZ = pSrc + m_pSrc->m_uWidth * 2;
    pxYZ = pSrc + m_pSrc->m_uWidth * 3;



    uZ = 0;
    pToZ = (LF_To *) pbZFilter;

    while(uZ < m_pDest->m_uDepth)
    {
        uY = 0;
        pToY = (LF_To *) pbYFilter;
        uFrom0 = (UINT) -1;
        uFrom1 = (UINT) -1;


        while(uY < m_pDest->m_uHeight)
        {
            uX = 0;
            pToX = (LF_To *) pbXFilter;

            if(pToY->pFrom[0].uFrom != uFrom0)
            {
                if(pToY->pFrom[0].uFrom != uFrom1)
                {
                    uFrom0 = pToY->pFrom[0].uFrom;

                    m_pSrc->Decode(uFrom0, pToZ->pFrom[0].uFrom, pxyz);
                    m_pSrc->Decode(uFrom0, pToZ->pFrom[1].uFrom, pxyZ);
                }
                else
                {
                    uFrom0 = uFrom1;
                    uFrom1 = (UINT) -1;

                    pSrcT = pxyz; pxyz = pxYz; pxYz = pSrcT;
                    pSrcT = pxyZ; pxyZ = pxYZ; pxYZ = pSrcT;
                }
            }

            if(pToY->pFrom[1].uFrom != uFrom1)
            {
                uFrom1 = pToY->pFrom[1].uFrom;

                m_pSrc->Decode(uFrom1, pToZ->pFrom[0].uFrom, pxYz);
                m_pSrc->Decode(uFrom1, pToZ->pFrom[1].uFrom, pxYZ);
            }


            while(uX < m_pDest->m_uWidth)
            {
                pDest[uX] = ((pxyz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxyz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                             (pxYz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxYz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight) * pToZ->pFrom[0].fWeight +

                            ((pxyZ[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxyZ[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                             (pxYZ[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxYZ[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight) * pToZ->pFrom[1].fWeight;

                pToX++;
                uX++;
            }

            m_pDest->Encode(uY, uZ, pDest);

            pToY++;
            uY++;
        }

        pToZ++;
        uZ++;
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    delete [] pbXFilter;
    delete [] pbYFilter;
    delete [] pbZFilter;

    delete [] pDest;
    delete [] pSrc;

    return hr;
}




// ---------------------------------------------------------------------------
//
// TF - Triangle filter
//
// This section of the code defines a bunch of structures, macros, and
// functions which are used for the triangle filter.
//
// ---------------------------------------------------------------------------

#define TF_EPSILON 0.00001f

struct TF_To
{
    UINT uTo;           // mapping
    FLOAT fWeight;      // mapping weight
};

struct TF_From
{
    UINT uSize;         // size, in bytes
    TF_To pTo[1];       // may continue past 1
};

struct TF_Filter
{
    UINT uSize;         // size, in bytes
    TF_From pFrom[1];   // may continue past 1
};

struct TF_Row
{
    D3DXCOLOR *pclr;    // row data
    FLOAT fWeight;
    TF_Row *pNext;

    ~TF_Row() {
        delete [] pclr;
        delete pNext;
    }
};


static const UINT TF_uFilterSize = sizeof(TF_Filter) - sizeof(TF_From);
static const UINT TF_uFromSize   = sizeof(TF_From) - sizeof(TF_To);
static const UINT TF_uToSize     = sizeof(TF_To);


//
// Setup a triangle filter.  Each source pixel contriubtes equally to the
// destination image.
//

static UINT8 *
TF_SetupTriangle(UINT uSrcLim, UINT uDstLim, BOOL bRepeat)
{
    if(!uSrcLim || !uDstLim)
        return NULL;


    // Compute scale
    FLOAT fScale = (FLOAT) uDstLim / (FLOAT) uSrcLim;
    FLOAT f2ScaleInv = 0.5f / fScale;



    // Allocate memory needed to describe the filter.
    UINT uSizeMax = TF_uFilterSize + TF_uFromSize + TF_uToSize;
    UINT uRepeat = bRepeat ? 1 : 0;

    for(UINT uSrc = 0; uSrc < uSrcLim; uSrc++)
    {
        FLOAT fSrc = (FLOAT) uSrc - 0.5f;
        FLOAT fDstMin = fSrc * fScale;
        FLOAT fDstLim = fDstMin + fScale;

        uSizeMax += TF_uFromSize + TF_uToSize +
            (UINT) (fDstLim - fDstMin + uRepeat + 1) * TF_uToSize * 2;
    }

    UINT8 *pbFilter = new UINT8[uSizeMax];

    if(!pbFilter)
        return NULL;


    // Initialize filter
    UINT uSize = TF_uFilterSize;

    // Initialize accumulators
    UINT uAccumDst = 0;
    FLOAT fAccumWeight = 0.0f;



    for(uSrc = 0; uSrc < uSrcLim; uSrc++)
    {
        // Initialize TF_From block
        UINT uSizeFrom = uSize;
        TF_From *pFrom = (TF_From *) (pbFilter + uSize);
        uSize += TF_uFromSize;
        D3DXASSERT(uSize <= uSizeMax);


        // For each source pixel, we perform two passes.  During the first
        // pass, we record the influences due to this source pixel as we
        // approach it.  During the second pass, we record the influences
        // as we move away from it.

        for(UINT uPass = 0; uPass < 2; uPass++)
        {
            FLOAT fSrc = ((FLOAT) uSrc + uPass) - 0.5f;

            // Start and end of source pixel, in destination coordinates
            FLOAT fDstMin = fSrc * fScale;
            FLOAT fDstLim = fDstMin + fScale;


            // Clamp source pixel to destination image.
            if(!bRepeat)
            {
                if(fDstMin < 0.0f)
                    fDstMin = 0.0f;
                if(fDstLim > (FLOAT) uDstLim)
                    fDstLim = (FLOAT) uDstLim;
            }

            // Start of first destination pixel
            INT nDst = (INT) floorf(fDstMin);



            while((FLOAT) nDst < fDstLim)
            {
                FLOAT fDst0 = (FLOAT) nDst;
                FLOAT fDst1 = fDst0 + 1.0f;

                UINT uDst;
                if(nDst < 0)
                    uDst = (UINT) nDst + uDstLim;
                else if(nDst >= (INT) uDstLim)
                    uDst = (UINT) nDst - uDstLim;
                else
                    uDst = (UINT) nDst;


                // Save the accumulated weight from uAccumDst if we have moved
                // on to accumulating for the next pixel.

                if(uDst != uAccumDst)
                {
                    if(fAccumWeight > TF_EPSILON)
                    {
                        TF_To *pTo  = (TF_To *) (pbFilter + uSize);
                        uSize += TF_uToSize;

                        D3DXASSERT(uSize <= uSizeMax);

                        pTo->uTo = uAccumDst;
                        pTo->fWeight = fAccumWeight;

                    }

                    fAccumWeight = 0.0f;
                    uAccumDst = uDst;
                }


                // Clip destination pixel to source pixel.
                if(fDst0 < fDstMin)
                    fDst0 = fDstMin;
                if(fDst1 > fDstLim)
                    fDst1 = fDstLim;


                // Calculate average weight over destination pixel.  Since the
                // weight varies linearly, when the average weight is
                // multiplied by the size of the destination pixel, the result
                // is equal to the integral of the weight over this portion of
                // the pixel.

                FLOAT fWeight;
                if(!bRepeat && fSrc < 0.0f)
                    fWeight = 1.0f;
                else if(!bRepeat && fSrc + 1.0f >= (FLOAT) uSrcLim)
                    fWeight = 0.0f;
                else
                    fWeight = (fDst0 + fDst1) * f2ScaleInv - fSrc;

                fAccumWeight += (fDst1 - fDst0) * (uPass ? 1.0f - fWeight : fWeight);
                nDst++;
            }
        }


        // If there is a valid value still in the accumulator, it needs to be
        // written out.

        if(fAccumWeight > TF_EPSILON)
        {
            TF_To *pTo = (TF_To *) (pbFilter + uSize);
            uSize += TF_uToSize;

            D3DXASSERT(uSize <= uSizeMax);

            pTo->uTo = uAccumDst;
            pTo->fWeight = fAccumWeight;
        }

        fAccumWeight = 0.0f;


        // Record TF_From's size
        pFrom->uSize = uSize - uSizeFrom;
    }


    // Record TF_Filter's size
    ((TF_Filter *) pbFilter)->uSize = uSize;

    return pbFilter;
}




HRESULT
CXD3DXBlt::BltTriangle2D()
{
    HRESULT hr;
    UINT8 *pbXFilter, *pbYFilter;
    TF_Filter *pXFilter, *pYFilter;
    TF_From *pXFrom, *pYFrom, *pXFromLim, *pYFromLim;
    TF_To *pXTo, *pYTo, *pXToLim, *pYToLim;
    TF_Row *pRow, **ppRowActive, *pRowFree;
    BOOL bRepeatX, bRepeatY;
    UINT uRowsActive;
    UINT uSrcRow;
    D3DXCOLOR *pclrSrc;
    D3DXCOLOR *pclrPal;


    pbXFilter   = NULL;
    pbYFilter   = NULL;
    ppRowActive = NULL;
    pRowFree    = NULL;
    pclrSrc     = NULL;
    pclrPal     = NULL;


//  DPF(0, "blt triangle %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    // Create filters for each axis
    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(m_pDest->m_uDepth != 1 || m_pSrc->m_uDepth != 1)
        return E_FAIL;

    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);

    if(!(pbXFilter = TF_SetupTriangle(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX)) ||
       !(pbYFilter = TF_SetupTriangle(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY)))
    {
        hr = E_FAIL;
        goto LDone;
    }



    pXFilter = (TF_Filter *) pbXFilter;
    pYFilter = (TF_Filter *) pbYFilter;

    pXFromLim = (TF_From *) ((UINT8 *) pXFilter + pXFilter->uSize);
    pYFromLim = (TF_From *) ((UINT8 *) pYFilter + pYFilter->uSize);


    // Initialize accumulation rows
    if(!(ppRowActive = new TF_Row* [m_pDest->m_uHeight]))
        goto LOutOfMemory;

    memset(ppRowActive, 0, m_pDest->m_uHeight * sizeof(TF_Row *));
    uRowsActive = 0;

    if(!(pclrSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        goto LOutOfMemory;



    // Filter image
    uSrcRow = 0;

    for(pYFrom = pYFilter->pFrom; pYFrom < pYFromLim; pYFrom = (TF_From *) pYToLim)
    {
        D3DXCOLOR *pclrSrcX;

        pYToLim = (TF_To *) ((UINT8 *) pYFrom + pYFrom->uSize);

        if(pYFrom->pTo < pYToLim)
        {

            // Create necessary accumulation rows
            for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
            {
                if(!(pRow = ppRowActive[pYTo->uTo]))
                {
                    if(pRowFree)
                    {
                        // Reuse a row
                        pRow = pRowFree;
                        pRowFree = pRow->pNext;
                    }
                    else
                    {
                        // Allocate a new row
                        if(!(pRow = new TF_Row))
                            goto LOutOfMemory;

                        if(!(pRow->pclr = new D3DXCOLOR[m_pDest->m_uWidth]))
                        {
                            delete pRow;
                            goto LOutOfMemory;
                        }
                    }

                    memset(pRow->pclr, 0, m_pDest->m_uWidth * sizeof(D3DXCOLOR));
                    pRow->fWeight = 0.0f;
                    pRow->pNext = NULL;

                    ppRowActive[pYTo->uTo] = pRow;
                    uRowsActive++;
                }
            }


            // Read source pixels
            m_pSrc->Decode(uSrcRow, 0, pclrSrc);


            // Process a row from the source image
            pclrSrcX = pclrSrc;
            for(pXFrom = pXFilter->pFrom; pXFrom < pXFromLim; pXFrom = (TF_From *) pXToLim)
            {
                pXToLim = (TF_To *) ((UINT8 *) pXFrom + pXFrom->uSize);

                for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
                {
                    pRow = ppRowActive[pYTo->uTo];

                    for(pXTo = pXFrom->pTo; pXTo < pXToLim; pXTo++)
                    {
                        FLOAT fWeight =  pYTo->fWeight * pXTo->fWeight;

                        pRow->pclr[pXTo->uTo].r += pclrSrcX->r * fWeight;
                        pRow->pclr[pXTo->uTo].g += pclrSrcX->g * fWeight;
                        pRow->pclr[pXTo->uTo].b += pclrSrcX->b * fWeight;
                        pRow->pclr[pXTo->uTo].a += pclrSrcX->a * fWeight;
                    }
                }

                pclrSrcX++;
            }


            // Write completed accumulation rows
            for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
            {
                pRow = ppRowActive[pYTo->uTo];
                pRow->fWeight += pYTo->fWeight;

                if(pRow->fWeight + TF_EPSILON >= 1.0f)
                {
                    // Write and free row
                    m_pDest->Encode(pYTo->uTo, 0, pRow->pclr);

                    ppRowActive[pYTo->uTo] = NULL;
                    pRow->pNext = pRowFree;
                    pRowFree = pRow;

                    uRowsActive--;
                }
            }
        }

        uSrcRow++;
    }


    // Make sure that all accumulation rows have been written out.  This should
    // only happen if the filter was not constructed correctly.
    if(uRowsActive)
    {
        for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
        {
            if(ppRowActive[uRow])
            {
                // Write and delete row
                m_pDest->Encode(uRow, 0, ppRowActive[uRow]->pclr);
                delete ppRowActive[uRow];

                if(--uRowsActive == 0)
                    break;
            }
        }
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    // Clean up
    delete[] ppRowActive;
    delete pRowFree;

    delete [] pbYFilter;
    delete [] pbXFilter;
    delete [] pclrSrc;
    delete [] pclrPal;

    return hr;
}



HRESULT
CXD3DXBlt::BltTriangle3D()
{
    HRESULT hr;
    UINT8 *pbXFilter, *pbYFilter, *pbZFilter;
    TF_Filter *pXFilter, *pYFilter, *pZFilter;
    TF_From *pXFrom, *pYFrom, *pZFrom, *pXFromLim, *pYFromLim, *pZFromLim;
    TF_To *pXTo, *pYTo, *pZTo, *pXToLim, *pYToLim, *pZToLim;
    TF_Row *pSlice, **ppSliceActive, *pSliceFree;
    BOOL bRepeatX, bRepeatY, bRepeatZ;
    UINT uSlicesActive;
    UINT uSrcRow, uSrcSlice;
    D3DXCOLOR *pclrSrc;
    D3DXCOLOR *pclrPal;


    pbXFilter     = NULL;
    pbYFilter     = NULL;
    pbZFilter     = NULL;
    ppSliceActive = NULL;
    pSliceFree    = NULL;
    pclrSrc       = NULL;
    pclrPal       = NULL;


//  DPF(0, "blt triangle %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    // Create filters for each axis
    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);
    bRepeatZ = !(m_dwFilter & D3DX_FILTER_MIRROR_W);

    if(!(pbXFilter = TF_SetupTriangle(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX)) ||
       !(pbYFilter = TF_SetupTriangle(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY)) ||
       !(pbZFilter = TF_SetupTriangle(m_pSrc->m_uDepth,  m_pDest->m_uDepth,  bRepeatZ)))
    {
        hr = E_FAIL;
        goto LDone;
    }



    pXFilter = (TF_Filter *) pbXFilter;
    pYFilter = (TF_Filter *) pbYFilter;
    pZFilter = (TF_Filter *) pbZFilter;

    pXFromLim = (TF_From *) ((UINT8 *) pXFilter + pXFilter->uSize);
    pYFromLim = (TF_From *) ((UINT8 *) pYFilter + pYFilter->uSize);
    pZFromLim = (TF_From *) ((UINT8 *) pZFilter + pZFilter->uSize);


    // Initialize accumulation slices
    if(!(ppSliceActive = new TF_Row* [m_pDest->m_uDepth]))
        goto LOutOfMemory;

    memset(ppSliceActive, 0, m_pDest->m_uDepth * sizeof(TF_Row *));
    uSlicesActive = 0;

    if(!(pclrSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        goto LOutOfMemory;



    // Filter image
    uSrcSlice = 0;
    for(pZFrom = pZFilter->pFrom; pZFrom < pZFromLim; pZFrom = (TF_From *) pZToLim)
    {
        pZToLim = (TF_To *) ((UINT8 *) pZFrom + pZFrom->uSize);

        // Create necessary accumulation slices
        for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
        {
            if(!(pSlice = ppSliceActive[pZTo->uTo]))
            {
                if(pSliceFree)
                {
                    // Reuse a row
                    pSlice = pSliceFree;
                    pSliceFree = pSlice->pNext;
                }
                else
                {
                    // Allocate a new row
                    if(!(pSlice = new TF_Row))
                        goto LOutOfMemory;

                    if(!(pSlice->pclr = new D3DXCOLOR[m_pDest->m_uWidth * m_pDest->m_uHeight]))
                    {
                        delete pSlice;
                        goto LOutOfMemory;
                    }
                }

                memset(pSlice->pclr, 0, m_pDest->m_uWidth * m_pDest->m_uHeight * sizeof(D3DXCOLOR));
                pSlice->fWeight = 0.0f;
                pSlice->pNext = NULL;

                ppSliceActive[pZTo->uTo] = pSlice;
                uSlicesActive++;
            }
        }

        uSrcRow = 0;
        for(pYFrom = pYFilter->pFrom; pYFrom < pYFromLim; pYFrom = (TF_From *) pYToLim)
        {

            pYToLim = (TF_To *) ((UINT8 *) pYFrom + pYFrom->uSize);

            // Read source pixels
            m_pSrc->Decode(uSrcRow, uSrcSlice, pclrSrc);


            // Process a row from the source image
            D3DXCOLOR *pclrSrcX, *pclrDest;
            pclrSrcX = pclrSrc;

            for(pXFrom = pXFilter->pFrom; pXFrom < pXFromLim; pXFrom = (TF_From *) pXToLim)
            {
                pXToLim = (TF_To *) ((UINT8 *) pXFrom + pXFrom->uSize);

                for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
                {
                    for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
                    {
                        pclrDest = ppSliceActive[pZTo->uTo]->pclr + pYTo->uTo * m_pDest->m_uWidth;

                        for(pXTo = pXFrom->pTo; pXTo < pXToLim; pXTo++)
                        {
                            FLOAT fWeight = pZTo->fWeight * pYTo->fWeight * pXTo->fWeight;

                            pclrDest[pXTo->uTo].r += pclrSrcX->r * fWeight;
                            pclrDest[pXTo->uTo].g += pclrSrcX->g * fWeight;
                            pclrDest[pXTo->uTo].b += pclrSrcX->b * fWeight;
                            pclrDest[pXTo->uTo].a += pclrSrcX->a * fWeight;
                        }
                    }
                }

                pclrSrcX++;
            }

            uSrcRow++;
        }


        // Write completed accumulation slices
        for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
        {
            pSlice = ppSliceActive[pZTo->uTo];
            pSlice->fWeight += pZTo->fWeight;

            if(pSlice->fWeight + TF_EPSILON >= 1.0f)
            {
                // Write and free slice                
                for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
                    m_pDest->Encode(uRow, pZTo->uTo, pSlice->pclr + uRow * m_pDest->m_uWidth);

                ppSliceActive[pZTo->uTo] = NULL;
                pSlice->pNext = pSliceFree;
                pSliceFree = pSlice;

                uSlicesActive--;
            }
        }

        uSrcSlice++;
    }


    // Make sure that all accumulation slices have been written out.  This should
    // only happen if the filter was not constructed correctly.
    if(uSlicesActive)
    {
        for(UINT uSlice = 0; uSlice < m_pDest->m_uDepth; uSlice++)
        {
            if(ppSliceActive[uSlice])
            {
                // Write and delete slice
                for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
                    m_pDest->Encode(uRow, uSlice, pSlice->pclr + uRow * m_pDest->m_uWidth);

                delete ppSliceActive[uSlice];

                if(--uSlicesActive == 0)
                    break;
            }
        }
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    // Clean up
    delete[] ppSliceActive;
    delete pSliceFree;

    delete [] pbZFilter;
    delete [] pbYFilter;
    delete [] pbXFilter;
    delete [] pclrSrc;
    delete [] pclrPal;

    return hr;
}




// ---------------------------------------------------------------------------
//
// Optimized filters
//
// ---------------------------------------------------------------------------

#ifdef SUPPORT_DXT
HRESULT CXD3DXBlt::BltSame_DXTn()
{
    if((m_pSrc->m_Box.Left  | m_pSrc->m_Box.Top  | m_pSrc->m_Box.Right  | m_pSrc->m_Box.Bottom)  & 3)
        return E_FAIL;

    if((m_pDest->m_Box.Left | m_pDest->m_Box.Top | m_pDest->m_Box.Right | m_pDest->m_Box.Bottom) & 3)
        return E_FAIL;


    // Calculate block size and width
    UINT cbBlock, cbWidth;

    switch(m_pDest->m_Format)
    {
    case D3DFMT_DXT1:
        cbBlock = sizeof(S3TCBlockRGB);
        break;

    case D3DFMT_DXT2:
#if 0
    case D3DFMT_DXT3:
#endif
        cbBlock = sizeof(S3TCBlockAlpha4);
        break;

    case D3DFMT_DXT4:
#if 0
    case D3DFMT_DXT5:
#endif
        cbBlock = sizeof(S3TCBlockAlpha3);
        break;

    default:
        return E_FAIL;
    }


    cbWidth = (m_pDest->m_uWidth >> 2) * cbBlock;


    // Copy DXTn blocks
    BYTE *pbSliceDest = m_pDest->m_pbData + (m_pDest->m_Box.Left >> 2) * cbBlock + 
        (m_pDest->m_Box.Top >> 2) * m_pDest->m_uPitch + m_pDest->m_Box.Front * m_pDest->m_uSlice;

    BYTE *pbSliceSrc = m_pSrc->m_pbData + (m_pSrc->m_Box.Left >> 2) * cbBlock + 
        (m_pSrc->m_Box.Top >> 2) * m_pSrc->m_uPitch + m_pSrc->m_Box.Front * m_pSrc->m_uSlice;


    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        BYTE *pbDest = pbSliceDest;
        BYTE *pbSrc  = pbSliceSrc;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY += 4)
        {
            memcpy(pbDest, pbSrc, cbWidth);

            pbDest += m_pDest->m_uPitch;
            pbSrc  += m_pSrc ->m_uPitch;
        }

        pbSliceDest += m_pDest->m_uSlice;
        pbSliceDest += m_pSrc ->m_uSlice;
    }

    return S_OK;
}
#endif // SUPPORT_DXT


HRESULT 
CXD3DXBlt::BltBox2D_R8G8B8()
{
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8R8G8B8()
{
    UINT32 *pulDest   = (UINT32 *) m_pDest->m_pbData;
    UINT32 *pulSrc    = (UINT32 *) m_pSrc->m_pbData;
    UINT32 *pulSrcLim = (UINT32 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pulSrc < pulSrcLim)
    {
        UINT32 *pul     = pulDest;
        UINT32 *pulA    = pulSrc;
        UINT32 *pulB    = (UINT32 *) ((BYTE *) pulA + m_pSrc->m_uPitch);
        UINT32 *pulALim = pulA + m_pSrc->m_uWidth;

        while(pulA < pulALim)
        {
            *pul++ = (((((pulA[0] & 0x00ff00ff) + (pulA[1] & 0x00ff00ff) + 
                         (pulB[0] & 0x00ff00ff) + (pulB[1] & 0x00ff00ff)) + 0x00020002) >> 2) & 0x00ff00ff) |

                     (((((pulA[0] & 0xff00ff00) >> 2) + ((pulA[1] & 0xff00ff00) >> 2) +
                        ((pulB[0] & 0xff00ff00) >> 2) + ((pulB[1] & 0xff00ff00) >> 2)) + (0x02000200 >> 2)) & 0xff00ff00);

            pulA += 2;
            pulB += 2;
        }

        pulDest = (UINT32 *) ((BYTE *) pulDest + m_pDest->m_uPitch);
        pulSrc  = (UINT32 *) ((BYTE *) pulSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_X8R8G8B8()
{
    UINT32 *pulDest   = (UINT32 *) m_pDest->m_pbData;
    UINT32 *pulSrc    = (UINT32 *) m_pSrc->m_pbData;
    UINT32 *pulSrcLim = (UINT32 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pulSrc < pulSrcLim)
    {
        UINT32 *pul     = pulDest;
        UINT32 *pulA    = pulSrc;
        UINT32 *pulB    = (UINT32 *) ((BYTE *) pulA + m_pSrc->m_uPitch);
        UINT32 *pulALim = pulA + m_pSrc->m_uWidth;

        while(pulA < pulALim)
        {
            *pul++ = ((((pulA[0] & 0x00ff00ff) + (pulA[1] & 0x00ff00ff) + 
                        (pulB[0] & 0x00ff00ff) + (pulB[1] & 0x00ff00ff) + 0x00020002) & (0x00ff00ff << 2)) |

                      (((pulA[0] & 0x0000ff00) + (pulA[1] & 0x0000ff00) +
                        (pulB[0] & 0x0000ff00) + (pulB[1] & 0x0000ff00) + 0x00000200) & (0x0000ff00 << 2))) >> 2;

            pulA += 2;
            pulB += 2;
        }

        pulDest = (UINT32 *) ((BYTE *) pulDest + m_pDest->m_uPitch);
        pulSrc  = (UINT32 *) ((BYTE *) pulSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_R5G6B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0xf81f) + ((UINT32) pusA[1] & 0xf81f) + 
                                  ((UINT32) pusB[0] & 0xf81f) + ((UINT32) pusB[1] & 0xf81f) + 0x1002) & (0xf81f << 2)) |

                                ((((UINT32) pusA[0] & 0x07e0) + ((UINT32) pusA[1] & 0x07e0) + 
                                  ((UINT32) pusB[0] & 0x07e0) + ((UINT32) pusB[1] & 0x07e0) + 0x0040) & (0x07e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_X1R5G5B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x7c1f) + ((UINT32) pusA[1] & 0x7c1f) + 
                                  ((UINT32) pusB[0] & 0x7c1f) + ((UINT32) pusB[1] & 0x7c1f) + 0x0802) & (0x7c1f << 2)) |

                                ((((UINT32) pusA[0] & 0x03e0) + ((UINT32) pusA[1] & 0x03e0) + 
                                  ((UINT32) pusB[0] & 0x03e0) + ((UINT32) pusB[1] & 0x03e0) + 0x0040) & (0x03e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A1R5G5B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x7c1f) + ((UINT32) pusA[1] & 0x7c1f) + 
                                  ((UINT32) pusB[0] & 0x7c1f) + ((UINT32) pusB[1] & 0x7c1f) + 0x0802) & (0x7c1f << 2)) |

                                ((((UINT32) pusA[0] & 0x83e0) + ((UINT32) pusA[1] & 0x83e0) + 
                                  ((UINT32) pusB[0] & 0x83e0) + ((UINT32) pusB[1] & 0x83e0) + 0x10040) & (0x83e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A4R4G4B4()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x0f0f) + ((UINT32) pusA[1] & 0x0f0f) + 
                                  ((UINT32) pusB[0] & 0x0f0f) + ((UINT32) pusB[1] & 0x0f0f) + 0x0202) & (0x0f0f << 2)) |

                                ((((UINT32) pusA[0] & 0xf0f0) + ((UINT32) pusA[1] & 0xf0f0) + 
                                  ((UINT32) pusB[0] & 0xf0f0) + ((UINT32) pusB[1] & 0xf0f0) + 0x2020) & (0xf0f0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_R3G3B2() 
{
#if 0
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) ((((((UINT32) pubA[0] & 0xe3) + ((UINT32) pubA[1] & 0xe3) + 
                                 ((UINT32) pubB[0] & 0xe3) + ((UINT32) pubB[1] & 0xe3) + 0x42) & (0xe3 << 2)) |

                               ((((UINT32) pubA[0] & 0x1c) + ((UINT32) pubA[1] & 0x1c) + 
                                 ((UINT32) pubB[0] & 0x1c) + ((UINT32) pubB[1] & 0x1c) + 0x08) & (0x1c << 2))) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8()
{
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) (((UINT32) pubA[0] + (UINT32) pubA[1] + 
                               (UINT32) pubB[0] + (UINT32) pubB[1] + 0x02) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8R3G3B2()
{
#if 0
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x00e3) + ((UINT32) pusA[1] & 0x00e3) + 
                                  ((UINT32) pusB[0] & 0x00e3) + ((UINT32) pusB[1] & 0x00e3) + 0x0042) & (0x00e3 << 2)) |

                                ((((UINT32) pusA[0] & 0xff1c) + ((UINT32) pusA[1] & 0xff1c) + 
                                  ((UINT32) pusB[0] & 0xff1c) + ((UINT32) pusB[1] & 0xff1c) + 0x0208) & (0xff1c << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_X4R4G4B4()
{
#if 0
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x0f0f) + ((UINT32) pusA[1] & 0x0f0f) + 
                                  ((UINT32) pusB[0] & 0x0f0f) + ((UINT32) pusB[1] & 0x0f0f) + 0x0202) & (0x0f0f << 2)) |

                                ((((UINT32) pusA[0] & 0x00f0) + ((UINT32) pusA[1] & 0x00f0) + 
                                  ((UINT32) pusB[0] & 0x00f0) + ((UINT32) pusB[1] & 0x00f0) + 0x0020) & (0x00f0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8P8()
{
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_P8()
{
    return E_NOTIMPL;
}


HRESULT 
CXD3DXBlt::BltBox2D_A8L8()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x00ff) + ((UINT32) pusA[1] & 0x00ff) + 
                                  ((UINT32) pusB[0] & 0x00ff) + ((UINT32) pusB[1] & 0x00ff) + 0x0002) & (0x00ff << 2)) |

                                ((((UINT32) pusA[0] & 0xff00) + ((UINT32) pusA[1] & 0xff00) + 
                                  ((UINT32) pusB[0] & 0xff00) + ((UINT32) pusB[1] & 0xff00) + 0x0200) & (0xff00 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CXD3DXBlt::BltBox2D_A4L4()
{
#if 0
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) ((((((UINT32) pubA[0] & 0x0f) + ((UINT32) pubA[1] & 0x0f) + 
                                 ((UINT32) pubB[0] & 0x0f) + ((UINT32) pubB[1] & 0x0f) + 0x02) & (0x0f << 2)) |

                               ((((UINT32) pubA[0] & 0xf0) + ((UINT32) pubA[1] & 0xf0) + 
                                 ((UINT32) pubB[0] & 0xf0) + ((UINT32) pubB[1] & 0xf0) + 0x20) & (0xf0 << 2))) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\cubemap.h ===
//-----------------------------------------------------------------------------
// File: Cubemap.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the cubemap-related functionality of the bundler tool
//
// Hist: 2001.04.11 - New for May XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CUBEMAP_H
#define CUBEMAP_H

#include "Texture.h"




//-----------------------------------------------------------------------------
// Name: class CCubemap
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CCubemap : public CBaseTexture
{
    CImage* m_pImageXP;
    CImage* m_pImageXN;
    CImage* m_pImageYP;
    CImage* m_pImageYN;
    CImage* m_pImageZP;
    CImage* m_pImageZN;

    HRESULT LoadCubemap();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

public:
    char  m_strSourceXP[MAX_PATH];
    char  m_strSourceXN[MAX_PATH];
    char  m_strSourceYP[MAX_PATH];
    char  m_strSourceYN[MAX_PATH];
    char  m_strSourceZP[MAX_PATH];
    char  m_strSourceZN[MAX_PATH];
    char  m_strAlphaSourceXP[MAX_PATH];
    char  m_strAlphaSourceXN[MAX_PATH];
    char  m_strAlphaSourceYP[MAX_PATH];
    char  m_strAlphaSourceYN[MAX_PATH];
    char  m_strAlphaSourceZP[MAX_PATH];
    char  m_strAlphaSourceZN[MAX_PATH];
    DWORD m_dwSize;

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CCubemap( CBundler* pBundler );
    ~CCubemap();
};


#endif // CUBEMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\CD3DXCodec.h ===
//-----------------------------------------------------------------------------
// File: CD3DXCodec.cpp
//
// Desc: Contains general purpose blitting routines
//
// Hist: 2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef __CXD3DXCodec_H__
#define __CXD3DXCodec_H__

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>

#define CODEC_RGB 0x01
#define CODEC_P   0x02
#define CODEC_UV  0x03
#define CODEC_ZS  0x04

typedef signed char  INT8;
typedef short INT16;

typedef unsigned char  UINT8;
typedef unsigned short UINT16;

//----------------------------------------------------------------------------
//
// F2IBegin, F2I, F2IEnd
//
// Fast FLOAT->INT conversion.  F2IBegin sets and F2IEnd restores the FPU
// rounding mode.  F2I converts a float to an int.  You need to be careful of
// what other floating point code resides between F2IBegin and F2IEnd:  If
// something messes with the rounding mode, you could get unpredicted results.
//
//----------------------------------------------------------------------------


static UINT32 g_ulFPU;

static VOID
F2IBegin() {
    UINT32 ulFPU, ul;

    __asm {
        fnstcw WORD PTR [ulFPU]        // Get FPU control word
        mov    eax, DWORD PTR [ulFPU]
        or     eax, 0x0C00             // Rounding mode = CLAMP
        mov    DWORD PTR [ul], eax
        fldcw  WORD PTR [ul]           // Set FPU control word
    }

    // Save old FPU control word in thread-local storage
    g_ulFPU = ulFPU;
}


static inline INT
F2I(FLOAT f)
{
    volatile INT n;

    __asm {
        fld   f   // Load fload
        fistp n   // Store integer (and pop)
    }

    return n;
}

static VOID
F2IEnd() {
    // Get old FPU control word from thread-local storage
    UINT32 ulFPU = g_ulFPU;

    __asm {
        fldcw WORD PTR [ulFPU]    // Set FPU control word
    }
}


struct D3DX_BLT
{
    VOID*               pData;
    D3DFORMAT           Format;

    UINT                RowPitch;
    UINT                SlicePitch;

    D3DBOX              Region;
    D3DBOX              SubRegion;

    BOOL                bDither;

    D3DCOLOR            ColorKey;
    CONST PALETTEENTRY* pPalette;
};


///////////////////////////////////////////////////////////////////////////
// CXD3DXCodec /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXCodec
{
public:
    D3DFORMAT  m_Format;
    DWORD      m_dwType;
    BOOL       m_bLinear;
    BOOL       m_bColorKey;
    BOOL       m_bPalettized;

    BYTE*      m_pbData;
    D3DXCOLOR  m_ColorKey;
    FLOAT*     m_pfDither;
    D3DXCOLOR  m_pPalette[256];
    D3DBOX     m_Box;

    UINT       m_uPitch;
    UINT       m_uSlice;
    UINT       m_uWidth;
    UINT       m_uHeight;
    UINT       m_uDepth;
    UINT       m_uWidthBytes;
    UINT       m_uBytesPerPixel;

public:
    static CXD3DXCodec* Create(D3DX_BLT *pBlt);

    virtual ~CXD3DXCodec();

    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    static D3DCOLOR s_pPalette[256];

    void ColorKey(D3DXCOLOR *pColors);

    CXD3DXCodec(D3DX_BLT *pBlt, UINT uBPP, DWORD dwType);
};


///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecYUV //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXCodecYUV : public CXD3DXCodec
{
public: 
    CXD3DXCodecYUV(D3DX_BLT *pBlt);
    virtual ~CXD3DXCodecYUV();

    HRESULT Commit();
    HRESULT Fetch(UINT uRow, UINT uSlice, BOOL bRead);

    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    D3DXCOLOR *m_pCache;
    D3DBOX     m_CacheBox;
    UINT       m_uCacheWidth;
    BOOL       m_bCacheDirty;
    BOOL       m_bCacheAllocated;
    UINT       m_uYShift;
    UINT       m_uUVShift;
};



///////////////////////////////////////////////////////////////////////////
// CXD3DXCodecDXT //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CXD3DXCodecDXT : public CXD3DXCodec
{
public: 
    CXD3DXCodecDXT(D3DX_BLT *pBlt);
    virtual ~CXD3DXCodecDXT();

    HRESULT Commit();
    HRESULT Fetch(UINT uRow, UINT uSlice, BOOL bRead);

    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    D3DXCOLOR *m_ppCache[4];
    D3DBOX     m_CacheBox;
    UINT       m_uCacheWidth;
    BOOL       m_bCacheDirty;
    BOOL       m_bCacheAllocated;

    BOOL       m_bRepeat;
    UINT       m_uXRepeat;
    UINT       m_uYRepeat;
    UINT       m_uTopMax;
};



///////////////////////////////////////////////////////////////////////////
// Specific CXD3DXCodecs ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define DECLARE_CODEC(name, bits, type) \
    class CXD3DXCodec_##name : public CXD3DXCodec \
    { \
    public: \
        CXD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CXD3DXCodec(pBlt, (bits), (type)) {} \
    \
        virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors); \
        virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors); \
    }


#define DECLARE_CODEC_YUV(name) \
    class CXD3DXCodec_##name : public CXD3DXCodecYUV \
    { \
    public: \
        CXD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CXD3DXCodecYUV(pBlt) {} \
    }


#define DECLARE_CODEC_DXT(name) \
    class CXD3DXCodec_##name : public CXD3DXCodecDXT \
    { \
    public: \
        CXD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CXD3DXCodecDXT(pBlt) {} \
    }


DECLARE_CODEC(R8G8B8,    24, CODEC_RGB);
DECLARE_CODEC(A8R8G8B8,  32, CODEC_RGB);
DECLARE_CODEC(X8R8G8B8,  32, CODEC_RGB);
DECLARE_CODEC(R5G6B5,    16, CODEC_RGB);
DECLARE_CODEC(X1R5G5B5,  16, CODEC_RGB);
DECLARE_CODEC(A1R5G5B5,  16, CODEC_RGB);
DECLARE_CODEC(A4R4G4B4,  16, CODEC_RGB);
DECLARE_CODEC(R3G3B2,     8, CODEC_RGB);
DECLARE_CODEC(A8,         8, CODEC_RGB);
DECLARE_CODEC(A8R3G3B2,  16, CODEC_RGB);
DECLARE_CODEC(X4R4G4B4,  16, CODEC_RGB);
DECLARE_CODEC(A8P8,      16, CODEC_P);
DECLARE_CODEC(P8,         8, CODEC_P);
DECLARE_CODEC(L8,         8, CODEC_RGB);
DECLARE_CODEC(A8L8,      16, CODEC_RGB);
DECLARE_CODEC(A4L4,       8, CODEC_RGB);

DECLARE_CODEC(V8U8,      16, CODEC_UV);
DECLARE_CODEC(L6V5U5,    16, CODEC_UV);
DECLARE_CODEC(X8L8V8U8,  32, CODEC_UV);
DECLARE_CODEC(Q8W8V8U8,  32, CODEC_UV);
DECLARE_CODEC(V16U16,    32, CODEC_UV);
DECLARE_CODEC(W11V11U10, 32, CODEC_UV);

DECLARE_CODEC_YUV(UYVY);
DECLARE_CODEC_YUV(YUY2);
DECLARE_CODEC_DXT(DXT1);
DECLARE_CODEC_DXT(DXT2);
DECLARE_CODEC_DXT(DXT3);
DECLARE_CODEC_DXT(DXT4);
DECLARE_CODEC_DXT(DXT5);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\cubemap.cpp ===
//-----------------------------------------------------------------------------
// File: Cubemap.cpp
//
// Desc: Contains the cubemap-specific logic for the bundler tool
//
// Hist: 2001.04.11 - New for May XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Cubemap.h"
#include "Bundler.h"
#include "LoadImage.h"




//-----------------------------------------------------------------------------
// Name: CCubemap()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CCubemap::CCubemap( CBundler* pBundler )
         :CBaseTexture( pBundler )
{
    m_pImageXP              = NULL;
    m_pImageXN              = NULL;
    m_pImageYP              = NULL;
    m_pImageYN              = NULL;
    m_pImageZP              = NULL;
    m_pImageZN              = NULL;

    m_strSourceXP[0]         = '\0';
    m_strSourceXN[0]         = '\0';
    m_strSourceYP[0]         = '\0';
    m_strSourceYN[0]         = '\0';
    m_strSourceZP[0]         = '\0';
    m_strSourceZN[0]         = '\0';
    m_strAlphaSourceXP[0]    = '\0';
    m_strAlphaSourceXN[0]    = '\0';
    m_strAlphaSourceYP[0]    = '\0';
    m_strAlphaSourceYN[0]    = '\0';
    m_strAlphaSourceZP[0]    = '\0';
    m_strAlphaSourceZN[0]    = '\0';
}




//-----------------------------------------------------------------------------
// Name: ~CCubemap()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CCubemap::~CCubemap()
{
    delete m_pImageXP;
    delete m_pImageXN;
    delete m_pImageYP;
    delete m_pImageYN;
    delete m_pImageZP;
    delete m_pImageZN;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CCubemap::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    hr = LoadCubemap();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save cubemap data
    (*pcbData) = 0;

    SaveImage( pcbData, m_dwLevels, m_pImageXP );
    SaveImage( pcbData, m_dwLevels, m_pImageXN );
    SaveImage( pcbData, m_dwLevels, m_pImageYP );
    SaveImage( pcbData, m_dwLevels, m_pImageYN );
    SaveImage( pcbData, m_dwLevels, m_pImageZP );
    SaveImage( pcbData, m_dwLevels, m_pImageZN );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadCubemap()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CCubemap::LoadCubemap()
{
    HRESULT hr;

    // Try to look up our format string
    m_nFormat = FormatFromString( m_strFormat );
    if( m_nFormat < -1 )
    {
        m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
        return E_FAIL;
    }
    lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );

    // Check for linear textures
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_pBundler->ErrorMsg( "Error: Cubemaps cannot have linear formats", m_strFormat );
        return E_FAIL;
    }

    // If an alpha source was specified, make sure the format supports alpha
    if( m_strAlphaSourceXP[0] || m_strAlphaSourceXN[0] || 
        m_strAlphaSourceYP[0] || m_strAlphaSourceYN[0] || 
        m_strAlphaSourceZP[0] || m_strAlphaSourceZN[0] ) 
    {
        if( g_TextureFormats[m_nFormat].dwNumAlphaBits == 0 )
        {
            m_pBundler->ErrorMsg( "Warning: an ALPHASOURCE was specified, yet the " \
                                  "requested texture format, %s,  does not have " \
                                  "any alpha.\n", m_strFormat );
        }
    }

    // Load the image surfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    if( FAILED( hr = LoadImage( m_strSourceXP, m_strAlphaSourceXP, &m_pImageXP ) ) )
    {
		if( m_strAlphaSourceXP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceXP, m_strAlphaSourceXP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceXP );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceXN, m_strAlphaSourceXN, &m_pImageXN ) ) )
    {
		if( m_strAlphaSourceXN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceXN, m_strAlphaSourceXN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceXN );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceYP, m_strAlphaSourceYP, &m_pImageYP ) ) )
    {
		if( m_strAlphaSourceYP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceYP, m_strAlphaSourceYP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceYP );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceYN, m_strAlphaSourceYN, &m_pImageYN ) ) )
    {
		if( m_strAlphaSourceYN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceYN, m_strAlphaSourceYN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceYN );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceZP, m_strAlphaSourceZP, &m_pImageZP ) ) )
    {
		if( m_strAlphaSourceZP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceZP, m_strAlphaSourceZP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceZP );
        return hr;
    }
    if( FAILED( hr = LoadImage( m_strSourceZN, m_strAlphaSourceZN, &m_pImageZN ) ) )
    {
		if( m_strAlphaSourceZN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceZN, m_strAlphaSourceZN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceZN );
        return hr;
    }

    // Determine final width and height
    if( m_dwSize==0 )
    {
        // Enforce power-of-two dimensions for cubemap faces
        for( m_dwSize=1;  m_dwSize  < m_pImageXP->m_Width;  m_dwSize<<=1 );
    }

    // Determine final number of miplevels
    DWORD dwLevels = 1; 
    while( (1UL<<(dwLevels-1)) < m_dwSize )
        dwLevels++;
        
    if( m_dwLevels < 1 || m_dwLevels > dwLevels )
        m_dwLevels = dwLevels;

    // Change the size of the surfaces
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageXP );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageXN );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageYP );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageYN );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageZP );
    hr = ResizeImage( m_dwSize, m_dwSize, &m_pImageZN );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CCubemap::SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader )
{
    XD3DTexture d3dtex;

    XGSetCubeTextureHeader( m_dwSize, m_dwLevels, 0,
                            (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                            D3DPOOL_DEFAULT, (IDirect3DCubeTexture8*)&d3dtex,
                            dwStart, 0 );

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    (*pcbHeader) = sizeof(d3dtex);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\CVertexShader.cpp ===
//-----------------------------------------------------------------------------
// File: CVertexShader.cpp
//
// Desc: Contains the VertexShader-specific logic for the bundler tool
//
// Hist: 2001.09.26 - New for November XDK release
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "CVertexShader.h"
#include "Bundler.h"
#include "effect.h"

//-----------------------------------------------------------------------------
// Name: CVertexShader()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CVertexShader::CVertexShader( CBundler* pBundler )
{
    m_pBundler = pBundler;
	ZeroMemory(m_Identifier, sizeof(m_Identifier));
	m_dwDeclarationCount = 0;
	m_rdwDeclaration[m_dwDeclarationCount] = 0xffffffff;	// terminator
	m_cbFunctionSize = 0;
	m_pFunction = NULL;
	ZeroMemory(m_rbConstant, sizeof(m_rbConstant));
	m_dwVertexShaderReference = 0;
	ZeroMemory(m_rStreamInput, sizeof(m_rStreamInput));
}




//-----------------------------------------------------------------------------
// Name: ~CVertexShader (destructor)
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CVertexShader::~CVertexShader()
{
	if (m_pFunction)
		delete [] m_pFunction;
}



//-----------------------------------------------------------------------------
// Name: SetStream
// Desc: Add a stream token
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetStream(UINT iStream)
{
	if (m_dwDeclarationCount >= VERTEXSHADER_MAX_DECLARATION_COUNT)
		return E_FAIL;
	m_rdwDeclaration[m_dwDeclarationCount++] = XD3DVSD_STREAM(iStream);
	m_rdwDeclaration[m_dwDeclarationCount] = 0xffffffff;	// terminator
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetVertexRegisterFormat
// Desc: Add a vertex register token to the declaration
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetVertexRegisterFormat(UINT iVertexRegister, DWORD VertexFormat)
{
	if (m_dwDeclarationCount >= VERTEXSHADER_MAX_DECLARATION_COUNT)
		return E_FAIL;
	m_rdwDeclaration[m_dwDeclarationCount++] = XD3DVSD_REG(iVertexRegister, VertexFormat);
	m_rdwDeclaration[m_dwDeclarationCount] = 0xffffffff;	// terminator
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SkipBytes
// Desc: Add a SkipBytes token to the declaration
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SkipBytes(UINT Count)
{
	if (m_dwDeclarationCount >= VERTEXSHADER_MAX_DECLARATION_COUNT)
		return E_FAIL;
	m_rdwDeclaration[m_dwDeclarationCount++] = XD3DVSD_SKIPBYTES(Count);
	m_rdwDeclaration[m_dwDeclarationCount] = 0xffffffff;	// terminator
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetDeclaration
// Desc: Parse declaration to set streams and constants
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount)
{
	CONST FLOAT *pfConstant = (CONST FLOAT *)pConstantData;
	for (UINT i = 0; i < ConstantCount; i++)
	{
		INT iRegister = Register + (INT)i + 96;	// map -96,96 range to 0,192
		if (iRegister < 0 || iRegister >= XD3DVS_CONSTREG_COUNT)
			return E_FAIL;
		m_rbConstant[iRegister] = TRUE;	// mark register as active
		memcpy(m_rfConstant[iRegister], pfConstant, sizeof(float) * 4);
		pfConstant += 4;
	}
	return S_OK;
}
	
//-----------------------------------------------------------------------------
// Name: AddConstantsToDeclaration
// Desc: Look through active constants in m_rbConstant and add to declaration
//-----------------------------------------------------------------------------
HRESULT CVertexShader::AddConstantsToDeclaration()
{
	for (INT iConstant = 0; iConstant < XD3DVS_CONSTREG_COUNT; iConstant++)
	{
		if (m_rbConstant[iConstant])
		{
			if (m_dwDeclarationCount + 5 >= VERTEXSHADER_MAX_DECLARATION_COUNT)
			{
				m_rdwDeclaration[m_dwDeclarationCount] = 0xffffffff;	// terminator
				m_pBundler->ErrorMsg("VertexShader: Too many constants to fit in declaration\n");
				return E_FAIL;
			}
			m_rdwDeclaration[m_dwDeclarationCount] = XD3DVSD_CONST( iConstant - 96, 1 );
			memcpy(m_rdwDeclaration + m_dwDeclarationCount + 1, m_rfConstant[iConstant], sizeof(float) * 4);
			m_dwDeclarationCount += 5;
		}
	}
	m_rdwDeclaration[m_dwDeclarationCount] = 0xffffffff;	// terminator
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetStridesFromDeclaration
// Desc: Look through declaration for vertex register definitions and set
//       the appropriate strides.
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetStridesFromDeclaration()
{
	HRESULT hr = S_OK;
	int cbDeclaration = (m_dwDeclarationCount + 1) * sizeof(DWORD);
	DWORD *pToken = m_rdwDeclaration;
	int iActiveStream = -1;
	UINT Stride = 0;
	while (*pToken != XD3DVSD_END() )
	{
		switch (*pToken & XD3DVSD_TOKENTYPEMASK)
		{
        case XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_STREAM):
		{
			if (iActiveStream != -1 && Stride != 0)
			{
				// Set Stride if currently 0, otherwise check against calculated stride.
				if (m_rStreamInput[iActiveStream].Stride == 0)
					m_rStreamInput[iActiveStream].Stride = Stride;
				else
				{
					if (Stride != m_rStreamInput[iActiveStream].Stride)
					{
						m_pBundler->ErrorMsg("SetStridesFromDeclaration: stream %d given stride (%d) does not match computed stride (%d).\n",
											 iActiveStream, m_rStreamInput[iActiveStream].Stride, Stride);
						// Leave as warning
					}
				}
			}
			
			// Get stream index
            UINT iStream = *pToken & 0xf;
			if (iStream >= VERTEXSHADER_MAX_STREAMS)
			{
				m_pBundler->ErrorMsg("SetStridesFromDeclaration: stream index out of range (%d >= %d).\n", iStream, VERTEXSHADER_MAX_STREAMS);
				hr = E_FAIL;
				goto e_Exit;
			}
			iActiveStream = iStream;
			Stride = 0;
			break;
		}
        case XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_STREAMDATA):
		{
            if (*pToken & 0x10000000) // skip bytes
            {
                // XD3DVSD_SKIP or XD3DVSD_SKIPBYTES macro
				UINT count = (*pToken & XD3DVSD_SKIPCOUNTMASK) >> XD3DVSD_SKIPCOUNTSHIFT;
                if (!(*pToken & 0x08000000))
                {
					// skip dwords
                    count <<= 2;
				}
				Stride += count;
			}
			else	// data
			{
                DWORD sizeAndType = (*pToken & XD3DVSD_DATATYPEMASK) >> XD3DVSD_DATATYPESHIFT;
                DWORD reg = (*pToken & XD3DVSD_VERTEXREGMASK) >> XD3DVSD_VERTEXREGSHIFT;
				switch (sizeAndType)
				{
				case XD3DVSDT_FLOAT1      :    // 1D float expanded to (value, 0., 0., 1.)
					Stride += 4;
					break;
					
				case XD3DVSDT_FLOAT2      :    // 2D float expanded to (value, value, 0., 1.)
					Stride += 8;
					break;
//#if XBOX
				case XD3DVSDT_FLOAT2H     :    // 2D homogeneous float expanded to (value, value,0., value.)
					Stride += 12;
					break;
//#endif
					
				case XD3DVSDT_FLOAT3      :    // 3D float expanded to (value, value, value, 1.)
					Stride += 12;
					break;
					
				case XD3DVSDT_FLOAT4      :    // 4D float
					Stride += 16;
					break;
					
				case XD3DVSDT_D3DCOLOR    :    // 4D packed unsigned bytes mapped to 0. to 1. range
					Stride += 4;
					break;
					
//#if XBOX
				// Signed shorts map to the range [-32768, 32767]
				case XD3DVSDT_SHORT1      :    // 1D signed short expanded to (value, 0., 0., 1.)
					Stride += 2;
					break;

				case XD3DVSDT_SHORT2      :    // 2D signed short expanded to (value, value, 0., 1.)
					Stride += 4;
					break;

				case XD3DVSDT_SHORT3      :    // 3D signed short expanded to (value, value, value, 1.)
					Stride += 6;
					break;

				case XD3DVSDT_SHORT4      :    // 4D signed short
					Stride += 8;
					break;

				// (signed, normalized short maps from -1.0 to 1.0)
				case XD3DVSDT_NORMSHORT1  :    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
					Stride += 2;
					break;
				
				case XD3DVSDT_NORMSHORT2  :    // 2D signed, normalized short expanded to (value, value, 0., 1.)
					Stride += 4;
					break;

				case XD3DVSDT_NORMSHORT3  :    // 3D signed, normalized short expanded to (value, value, value, 1.)  
					Stride += 6;
					break;

				case XD3DVSDT_NORMSHORT4  :    // 4D signed, normalized short expanded to (value, value, value, value)  
					Stride += 8;
					break;

				case XD3DVSDT_NORMPACKED3 :    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
					Stride += 4;
					break;
				
				// Packed bytes map to the range [0, 1]
				case XD3DVSDT_PBYTE1      :    // 1D packed byte expanded to (value, 0., 0., 1.) 
					Stride += 1;
					break;
				
				case XD3DVSDT_PBYTE2      :    // 2D packed byte expanded to (value, value, 0., 1.)
					Stride += 2;
					break;

				case XD3DVSDT_PBYTE3      :    // 3D packed byte expanded to (value, value, value, 1.)
					Stride += 3;
					break;

				case XD3DVSDT_PBYTE4      :    // 4D packed byte expanded to (value, value, value, value) 
					Stride += 4;
					break;

//				case XD3DVSDT_NONE        :    // No stream data
//					break;
//#endif

				default:
					m_pBundler->ErrorMsg("SetStridesFromDeclaration: Bad vertex stream data type encoding (no D3DVSDT_* corresponds to 0x%x).", sizeAndType);
					hr = E_FAIL;
					goto e_Exit;
				}
			}
			break;
		}
			
        case XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_TESSELLATOR):
			m_pBundler->ErrorMsg("SetStridesFromDeclaration: Tessellator stream parsing not implemented.\n");
			hr = E_NOTIMPL;
			goto e_Exit;
			
        case XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_CONSTMEM):
		{
			int addr = ((*pToken & XD3DVSD_CONSTADDRESSMASK) >> XD3DVSD_CONSTADDRESSSHIFT) - 96;
            UINT count = (*pToken & XD3DVSD_CONSTCOUNTMASK) >> XD3DVSD_CONSTCOUNTSHIFT;
			pToken += 4 * count;
			break;
		}
			
        case XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_NOP):
            break;
			
        case XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_END):
            hr = S_OK;
			goto e_Exit;

		default:
			m_pBundler->ErrorMsg("SetStridesFromDeclaration: unknown token (0x%x) in the vertex shader declaration.\n", *pToken );
			hr = E_NOTIMPL;
			goto e_Exit;
		}

		// Go to the next token in the stream
		pToken++;
		if ((BYTE *)pToken - (BYTE *)m_rdwDeclaration > cbDeclaration)
		{
			m_pBundler->ErrorMsg("XDXVertexShaderDeclaration: missing end token.\n");
			hr = E_FAIL;
			goto e_Exit;
		}
	}

	// Handle last stream
	if (iActiveStream != -1 && Stride != 0)
	{
		// Set Stride if currently 0, otherwise check against calculated stride.
		if (m_rStreamInput[iActiveStream].Stride == 0)
			m_rStreamInput[iActiveStream].Stride = Stride;
		else
		{
			if (Stride != m_rStreamInput[iActiveStream].Stride)
			{
				m_pBundler->ErrorMsg("SetStridesFromDeclaration: stream %d given stride (%d) does not match computed stride (%d).\n",
									 iActiveStream, m_rStreamInput[iActiveStream].Stride, Stride);
				// Leave as warning
			}
		}
	}
			
 e_Exit:
	return hr;
}

#if 0
//-----------------------------------------------------------------------------
// Name: SetDeclaration
// Desc: Parse declaration to set streams and constants
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetDeclaration(const DWORD *pDeclaration)
{
	// Look for end of declaration
	CONST DWORD *pDeclarationEnd = pDeclaration;
	while (*pDeclarationEnd != 0xffffffff)
	{
		pDeclarationEnd++;
		if (pDeclarationEnd - pDeclaration > VERTEXSHADER_MAX_DECLARATION_COUNT)
			return E_FAIL;
	}
	DWORD dwDeclarationCount = pDeclarationEnd - pDeclaration + 1;
	if (m_dwDeclarationCount < dwDeclarationCount)
	{
		m_dwDeclarationCount = dwDeclarationCount;
		if (m_rdwDeclaration)
			delete [] m_rdwDeclaration;
		m_rdwDeclaration = new DWORD [ m_dwDeclarationCount ];
	}
	memcpy(m_rdwDeclaration, pDeclaration, m_dwDeclarationCount);
	return S_OK;
}
#endif
	
//-----------------------------------------------------------------------------
// Name: SetFunction
// Desc: Set vertex shader microcode
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetFunction(CONST void *pFunction, UINT cbFunctionSize)
{
	if (m_pFunction)
		delete m_pFunction;
	m_cbFunctionSize = cbFunctionSize;
	m_pFunction = new BYTE [ m_cbFunctionSize ];
	if (m_pFunction == NULL)
		return E_OUTOFMEMORY;
	memcpy(m_pFunction, pFunction, cbFunctionSize);
	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SetVertexShaderReference
// Desc: Set vertex shader resource index
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetVertexShaderReference(DWORD dwVertexShaderResourceIndex)
{
	m_dwVertexShaderReference = dwVertexShaderResourceIndex;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetStreamVertexBufferRefrence
// Desc: Set vertex buffer resource index to associate with a given stream
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SetStreamVertexBufferReference(UINT iStream, DWORD dwVertexBufferResourceIndex, DWORD Stride, DWORD Offset)
{
	if (iStream >= XD3DVS_STREAMS_MAX)
		return E_FAIL;
	m_rStreamInput[iStream].VertexBufferReference = dwVertexBufferResourceIndex;
	m_rStreamInput[iStream].Stride = Stride;
	m_rStreamInput[iStream].Offset = Offset;
	return S_OK;
}
	
//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CVertexShader::SaveToBundle( DWORD * pcbHeader, DWORD * pcbData )
{
	HRESULT hr = AddConstantsToDeclaration();
	if (FAILED(hr))
		return hr;
	hr = SetStridesFromDeclaration();
	if (FAILED(hr))
		return hr;
	
    if (m_dwDeclarationCount == 0
		&& m_cbFunctionSize == 0
		&& m_dwVertexShaderReference == 0)
    {
        m_pBundler->ErrorMsg( "Error: No declaration, function, or reference vertex shader specified\n" );
        return E_FAIL;
    }

	// Compute size of declaration (including constants) + function
	DWORD cbDeclaration = (m_dwDeclarationCount + 1) * sizeof(DWORD);	// include terminator in size
	DWORD cbFunction = m_cbFunctionSize;
	struct UserData {
		DWORD dwType;
		DWORD dwSize;
	} VSUserData;
	VSUserData.dwType = XBRC_VERTEXSHADER;
	//  vertex shader reference + vertex buffer stream references + declaration + function
	VSUserData.dwSize = sizeof(VertexShader) + cbDeclaration + cbFunction;

	// Write header
	if (FAILED(m_pBundler->WriteHeader( &VSUserData, sizeof(UserData))))
		return E_FAIL;
	m_pBundler->m_cbHeader += sizeof(UserData);	// TODO: this should be done in WriteHeader

	// Write VertexShader structure
	VertexShader VSSave;
	VSSave.Handle = 0;
	VSSave.DeclarationByteCount = cbDeclaration;
	VSSave.Declaration = (DWORD *)sizeof(VertexShader);	// file offset
	VSSave.FunctionByteCount = cbFunction;
	VSSave.Function = (DWORD *)(sizeof(VertexShader) + cbDeclaration);	// file offset
	VSSave.VertexShaderReference = m_dwVertexShaderReference;
	memcpy(VSSave.rStreamInput, m_rStreamInput, sizeof(m_rStreamInput));
	if (FAILED( m_pBundler->WriteHeader( &VSSave, sizeof(VertexShader) ) ))
		return E_FAIL;
	m_pBundler->m_cbHeader += sizeof(VertexShader); // TODO: this should be done in WriteHeader

	// Write declaration
    if ( FAILED( m_pBundler->WriteHeader( m_rdwDeclaration, cbDeclaration ) ) )
        return E_FAIL;
	m_pBundler->m_cbHeader += cbDeclaration; // TODO: this should be done in WriteHeader

	// Write function 
	if ( FAILED( m_pBundler->WriteHeader( m_pFunction, cbFunction ) ) )
		return E_FAIL;
	m_pBundler->m_cbHeader += cbFunction; // TODO: this should be done in WriteHeader

	// Set return counts
    *pcbHeader = sizeof(UserData) + VSUserData.dwSize;
	*pcbData = 0;	// no video data
    return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\frame.h ===
//-----------------------------------------------------------------------------
//  
//  File: frame.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  A frame hierarchy for nested transformations.
//
//-----------------------------------------------------------------------------
#pragma once

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3dx8math.h>
typedef __declspec(align(16)) D3DXMATRIX XGMATRIX;
#define XGMatrixMultiply D3DXMatrixMultiply
#endif
typedef XGMATRIX FrameMatrix;

#define FRAME_IDENTIFIER_SIZE 64

// hierarchies can be no wider or deeper than FRAME_MAX_STACK
#define FRAME_MAX_STACK 200

struct Frame {
	FrameMatrix m_Matrix;							// local transformation
    CHAR       m_strName[FRAME_IDENTIFIER_SIZE];	// name of this frame
	Frame     *m_pChild;							// child frame
	Frame     *m_pNext;								// sibling frame
};

struct Skeleton {
	DWORD       m_FrameCount;	// total number of frames
	FrameMatrix *m_rMatrix;		// cumulative transformations computed by frame hierarchy depth-first traversal
	Frame *		m_pRoot;		// root of frame hierarchy
	
	//////////////////////////////////////////////////////////////////////
	// Set root of frame hierarchy and allocate matrix array
	// to hold one matrix per node in the hierarchy.
	//
	HRESULT SetRoot(Frame *pRoot);

	//////////////////////////////////////////////////////////////////////
	// Do depth-first traversal of frame hierarchy to compute the
	// matrix palette
	//
	HRESULT UpdateTransformations();
};

#if 1

//////////////////////////////////////////////////////////////////////
// Add extra information to frame to make parsing and
// file writing easier.
//
struct AnimFrame;	// forward reference
struct FrameExtra : public Frame {
	AnimFrame *m_pAnim;	                            // accumulated animation expression
	AnimFrame *m_pAnimLocal;						// current animation defined by <animate> block
	DWORD	m_Offset;								// file offset

	FrameExtra();
	~FrameExtra();
	HRESULT AddChild(FrameExtra *pFrame);
	HRESULT Premult(AnimFrame *pAnim);
	static HRESULT DeleteHierarchy(FrameExtra *pFrame);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\effect.h ===
//-----------------------------------------------------------------------------
//  
//  File: effect.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//  An effect is a collection of rendering passes.  Each pass needs
//  vertex shaders (programs and constants), pixel shaders (programs
//  and constants), render states (including texture states),
//  textures, vertex buffers, index buffers, and draw lists.
//  
//-----------------------------------------------------------------------------
#pragma once

#define VERTEXSHADER_MAX_STREAMS 16
struct VertexShader {
	DWORD Handle;
	DWORD DeclarationByteCount;		// size of Declaration
	DWORD *Declaration;				// the declaration maps streams to vertex registers, and defines constants
	DWORD FunctionByteCount;		// size of Function
	DWORD *Function;				// function microcode maps vertex registers to transformed vertices
	DWORD VertexShaderReference;
	struct StreamInput {
		DWORD VertexBufferReference;
		DWORD Stride;
		DWORD Offset;
	} rStreamInput[VERTEXSHADER_MAX_STREAMS];
};

// PixelShader structure is same as D3DPIXELSHADERDEF

struct RenderState {
	DWORD State;
	DWORD Value;
};

struct TextureState {
	DWORD State;
	DWORD Value;
};

struct TextureStage {
	DWORD TextureResource;
	DWORD TextureStateCount;
	TextureState *rTextureState;
};

struct Draw {
	DWORD IndexBufferResource;
	DWORD Primitive;
	DWORD Start;
	DWORD Count;
};

struct Pass {
	DWORD VertexShaderResource;
	DWORD PixelShaderResource;	// TODO: Consider inlining the pixel shader definition
	DWORD RenderStateCount;
	RenderState *rRenderState;
	DWORD TextureStageCount;
	TextureStage *rTextureStage;
	DWORD DrawCount;
	Draw *rDraw;
};

#define EFFECT_IDENTIFIER_SIZE 128
struct Effect {
	CHAR Identifier[EFFECT_IDENTIFIER_SIZE];
	DWORD RenderTargetResource;
	DWORD PassCount;
	Pass *rPass;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\effect.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: effect.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of the XBContent class that concerns effects:
//     Effect, Pass, RenderState, TextureState, and Draw tags
//-----------------------------------------------------------------------------
#include "stdafx.h"

#define PASS_COUNT_INCREMENT 100
#define MAX_RENDER_STATE D3DRS_MAX
#define MAX_TEXTURE_STATE D3DTSS_MAX
#define MAX_TEXTURE_STAGE 4
#define MAX_DRAW 40

HRESULT XBContent::BeginEffect(ISAXAttributes *pAttributes)
{
	Effect *pEffect = new Effect;
	if (pEffect == NULL)
		return E_OUTOFMEMORY;
	pEffect->RenderTargetResource = 0;
	pEffect->PassCount = 0;
	pEffect->rPass = new Pass [PASS_COUNT_INCREMENT];
	if (pEffect->rPass == NULL)
	{
		delete pEffect;
		return E_OUTOFMEMORY;
	}
	PushContext(Effect_Context);
	m_rContextStack[m_iContext].m_pData = pEffect;

	// Set default resource id
	m_Count.m_Effect++;
	CHAR *strIdentifier = pEffect->Identifier;
	ZeroMemory(strIdentifier, EFFECT_IDENTIFIER_SIZE);
	_snprintf(strIdentifier, EFFECT_IDENTIFIER_SIZE, "Effect%d", m_Count.m_Effect);
	strIdentifier[EFFECT_IDENTIFIER_SIZE - 1] = 0;

	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(id))
		{
			if (cchValue >= BUNDLER_IDENTIFIER_MAX_LENGTH)
				cchValue = BUNDLER_IDENTIFIER_MAX_LENGTH - 1;
			ZeroMemory(strIdentifier, EFFECT_IDENTIFIER_SIZE);
			strncpy(strIdentifier, CharString(pwchValue, cchValue), cchValue );
			strIdentifier[cchValue] = 0;	// make sure the string is NULL terminated
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}

	// Check if identifier is unique
	if ( m_pBundler->IsExistingIdentifier( strIdentifier ) )
	{
        m_pBundler->ErrorMsg( "Second use of identifier \"%s\"", strIdentifier );
		return E_FAIL;
	}
	
	// Defer the save of the effect to the bundler until we process all the passes.
	return S_OK;
}

HRESULT XBContent::EndEffect()
{
	Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
	PopContext();

	// We should be compiling to a PushBuffer, but we don't currently
	// have access to the pushbuffer compilation code on the Win32
	// side. So, we make our own token stream that is compiled to a
	// pushbuffer on the Xbox side.

	// Keep track of offset into header as a bundler resource
	CHAR *strIdentifier = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
	strncpy(strIdentifier, pEffect->Identifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
	strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH - 1] = 0;	// make sure the string is null terminated
    DWORD cbHeader0 = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].dwOffset = m_pBundler->m_cbHeader;
	m_pBundler->m_nResourceCount++;
	
	// Calculate size and offsets into variable-size arrays
	UINT iPass;
	const int MAX_OFFSET = 10000;
	int iOffset = 0;
	DWORD rOffset[MAX_OFFSET];
	int iOffsetTextureState = 0;
	DWORD rOffsetTextureState[MAX_OFFSET];
	DWORD dwSize = sizeof(Effect);
	for (iPass = 0; iPass < pEffect->PassCount; iPass++)
	{
		// Pass *pPass = &pEffect->rPass[iPass];
		dwSize += sizeof(Pass);
	}
	for (iPass = 0; iPass < pEffect->PassCount; iPass++)	// then the variable-length arrays
	{
		Pass *pPass = &pEffect->rPass[iPass];

		// render states
		if (iOffset >= MAX_OFFSET)
			return E_FAIL;
		rOffset[iOffset++] = dwSize;
		dwSize += sizeof(RenderState) * pPass->RenderStateCount;

		// texture stages
		if (iOffset >= MAX_OFFSET)
			return E_FAIL;
		rOffset[iOffset++] = dwSize;
		dwSize += sizeof(TextureStage) * pPass->TextureStageCount;
		for (UINT iTextureStage = 0; iTextureStage < pPass->TextureStageCount; iTextureStage++)
		{
			// texture state
			if (iOffsetTextureState >= MAX_OFFSET)
				return E_FAIL;
			rOffsetTextureState[iOffsetTextureState++] = dwSize;
			dwSize += sizeof(TextureState) * pPass->rTextureStage[iTextureStage].TextureStateCount;
		}
		
		// draw commands
		if (iOffset >= MAX_OFFSET)
			return E_FAIL;
		rOffset[iOffset++] = dwSize;
		dwSize += sizeof(Draw) * pPass->DrawCount;
	}

	// Helper writing macro
#define WRITE(POINTER, SIZE)								\
	if (FAILED(m_pBundler->WriteHeader( POINTER, SIZE )))	\
		return E_FAIL;										\
	m_pBundler->m_cbHeader += SIZE;	// TODO: this should be done in WriteHeader
	
	// write header to bundle
	struct UserData {
		DWORD dwType;				// XBRC_EFFECT						0x80000040
		DWORD dwSize;				// total size (not including this header)
	} EffectUserData;
	EffectUserData.dwType = XBRC_EFFECT;
	EffectUserData.dwSize = dwSize;
	WRITE( &EffectUserData, sizeof(UserData) );

	// Write body of effect
	Effect EffectSave = *pEffect;
	EffectSave.rPass = (Pass *)sizeof(Effect); // set file offset
	WRITE( &EffectSave, sizeof(Effect) );
	iOffset = 0;
	iOffsetTextureState = 0;
	for (iPass = 0; iPass < pEffect->PassCount; iPass++)
	{
		Pass PassSave = pEffect->rPass[iPass];
		// set file offsets
		PassSave.rRenderState = (RenderState *)rOffset[iOffset++];
		PassSave.rTextureStage = (TextureStage *)rOffset[iOffset++]; 
		PassSave.rDraw = (Draw *)rOffset[iOffset++];
		WRITE( &PassSave, sizeof(Pass) );
	}
	for (iPass = 0; iPass < pEffect->PassCount; iPass++)
	{
		Pass *pPass = &pEffect->rPass[iPass];
		WRITE(  pPass->rRenderState, sizeof(RenderState) * pPass->RenderStateCount);
		UINT iTextureStage;
		for (iTextureStage = 0; iTextureStage < pPass->TextureStageCount; iTextureStage++)
		{
			TextureStage TextureStageSave = pPass->rTextureStage[iTextureStage];
			TextureStageSave.rTextureState = (TextureState *)rOffsetTextureState[iOffsetTextureState++];	// set file offset
			WRITE( &TextureStageSave, sizeof(TextureStage) );
		}
		for (iTextureStage = 0; iTextureStage < pPass->TextureStageCount; iTextureStage++)
		{
			TextureStage *pTextureStage = &pPass->rTextureStage[iTextureStage];
			WRITE(  pTextureStage->rTextureState, sizeof(TextureState) * pTextureStage->TextureStateCount );
		}
		WRITE( pPass->rDraw, sizeof(Draw) * pPass->DrawCount );
	}
#undef WRITE
    printf("Effect: wrote %s (%d bytes)\n", strIdentifier, m_pBundler->m_cbHeader - cbHeader0);
	
	// free up memory
	for (iPass = 0; iPass < pEffect->PassCount; iPass++)
	{
		Pass *pPass = &pEffect->rPass[iPass];
		if (pPass->rRenderState)
			delete [] pPass->rRenderState;
		if (pPass->rTextureStage)
		{
			for (UINT iTextureStage = 0; iTextureStage < pPass->TextureStageCount; iTextureStage++)
			{
				TextureStage *pTextureStage = &pPass->rTextureStage[iTextureStage];
				if (pTextureStage->rTextureState)
					delete [] pTextureStage->rTextureState;
			}
			delete [] pPass->rTextureStage;
		}
		if (pPass->rDraw)
			delete [] pPass->rDraw;
	}
	delete pEffect;
	
	return S_OK;
}


HRESULT XBContent::BeginPass(ISAXAttributes *pAttributes)
{
	Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
	PushContext(Pass_Context);
	m_rContextStack[m_iContext].m_pData = pEffect;	// keep effect pointer
	UINT PassCountNew = pEffect->PassCount + 1;
	if (PassCountNew / PASS_COUNT_INCREMENT * PASS_COUNT_INCREMENT == PassCountNew)
	{
		Pass *rPassOld = pEffect->rPass;
		
		// Allocate new array
		pEffect->rPass = new Pass [ PassCountNew + PASS_COUNT_INCREMENT ];
		if (pEffect->rPass == NULL)
			return E_OUTOFMEMORY;

		// Copy passes, including pointers, to new pass array
		memcpy(pEffect->rPass, rPassOld, sizeof(Pass) * pEffect->PassCount); 
		delete [] rPassOld;	// No destructor, so arrays are kept in the new pEffect->rPass's
	}
	Pass *pPass = &pEffect->rPass[pEffect->PassCount];
	ZeroMemory(pPass, sizeof(Pass));
	
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ )
	{
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		// No attributes are defined for <Pass>
		return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	return S_OK;
}

HRESULT XBContent::EndPass()
{
	Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
	pEffect->PassCount++;
	PopContext();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: PrimitiveTypeFromString
// Desc: helper function to choose primitive type
//-----------------------------------------------------------------------------
D3DPRIMITIVETYPE PrimitiveTypeFromString( CONST CHAR *str )
{
	CHAR *prefix = "D3DPT_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
	if (_stricmp(str, "POINTLIST") == 0)
		return D3DPT_POINTLIST;
	else if (_stricmp(str, "LINELIST") == 0)
		return D3DPT_LINELIST;
	else if (_stricmp(str, "LINELOOP") == 0)
		return D3DPT_LINELOOP;
	else if (_stricmp(str, "LINESTRIP") == 0)
		return D3DPT_LINESTRIP;
	else if (_stricmp(str, "TRIANGLELIST") == 0
			 || _stricmp(str, "TRILIST") == 0)		// TODO: spec eval on this kind of looseness
		return D3DPT_TRIANGLELIST;
	else if (_stricmp(str, "TRIANGLESTRIP") == 0
			 || _stricmp(str, "TRISTRIP") == 0)		// TODO: spec eval on this kind of looseness
		return D3DPT_TRIANGLESTRIP;
	else if (_stricmp(str, "TRIANGLEFAN") == 0
			 || _stricmp(str, "TRIFAN") == 0)		// TODO: spec eval on this kind of looseness
		return D3DPT_TRIANGLEFAN;
	else if (_stricmp(str, "QUADLIST") == 0)
		return D3DPT_QUADLIST;
	else if (_stricmp(str, "QUADSTRIP") == 0)
		return D3DPT_QUADSTRIP;
	else if (_stricmp(str, "POLYGON") == 0)
		return D3DPT_POLYGON;
	else
		return (D3DPRIMITIVETYPE)-1;
}
	
	// make sure the leftover chars are whitespace
HRESULT JustWhiteSpaceLeft(const CHAR *end)
{
	while (end && *end)
	{
		if (!isspace(*end))
			return E_FAIL;
		end++;
	}
	return S_OK;
}

HRESULT DWORD_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *end;
	DWORD dwValue = strtoul( str, &end, 0 );
	*pdwValue = dwValue;
	return JustWhiteSpaceLeft(end);
}

HRESULT BYTE_FromString(const CHAR *str, DWORD *pdwValue)
{
	return DWORD_FromString(str, pdwValue);
}

HRESULT FLOAT_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *end;
	DOUBLE doubleValue = strtod( str, &end );
	FLOAT floatValue = (FLOAT)doubleValue;
	*pdwValue = *(DWORD *)&floatValue;
	return JustWhiteSpaceLeft(end);
}

HRESULT LONG_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *end;
	LONG lValue = strtol( str, &end, 0 );
	*pdwValue = *(DWORD *)&lValue;
	return JustWhiteSpaceLeft(end);
}

HRESULT TRUE_FromString(const CHAR *str, DWORD *pdwValue)
{
	if (_stricmp(str, "TRUE") == 0)
	{
		*pdwValue = TRUE;
		return S_OK;
	}
	else if (_stricmp(str, "FALSE") == 0)
	{
		*pdwValue = FALSE;
		return S_OK;
	}
	else
		return E_FAIL;
}

HRESULT D3DBLEND_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DBLEND_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
    if (_stricmp(str, "ZERO" ) == 0)
	{
		*pdwValue = D3DBLEND_ZERO;
		return S_OK;
	}
    if (_stricmp(str, "ONE" ) == 0)
	{
		*pdwValue = D3DBLEND_ONE;
		return S_OK;
	}
    if (_stricmp(str, "SRCCOLOR" ) == 0)
	{
		*pdwValue = D3DBLEND_SRCCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "INVSRCCOLOR" ) == 0)
	{
		*pdwValue = D3DBLEND_INVSRCCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "SRCALPHA" ) == 0)
	{
		*pdwValue = D3DBLEND_SRCALPHA;
		return S_OK;
	}
    if (_stricmp(str, "INVSRCALPHA" ) == 0)
	{
		*pdwValue = D3DBLEND_INVSRCALPHA;
		return S_OK;
	}
    if (_stricmp(str, "DESTALPHA" ) == 0)
	{
		*pdwValue = D3DBLEND_DESTALPHA;
		return S_OK;
	}
    if (_stricmp(str, "INVDESTALPHA" ) == 0)
	{
		*pdwValue = D3DBLEND_INVDESTALPHA;
		return S_OK;
	}
    if (_stricmp(str, "DESTCOLOR" ) == 0)
	{
		*pdwValue = D3DBLEND_DESTCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "INVDESTCOLOR" ) == 0)
	{
		*pdwValue = D3DBLEND_INVDESTCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "SRCALPHASAT" ) == 0)
	{
		*pdwValue = D3DBLEND_SRCALPHASAT;
		return S_OK;
	}
    if (_stricmp(str, "CONSTANTCOLOR" ) == 0)
	{
		*pdwValue = D3DBLEND_CONSTANTCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "INVCONSTANTCOLOR" ) == 0)
	{
		*pdwValue = D3DBLEND_INVCONSTANTCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "CONSTANTALPHA" ) == 0)
	{
		*pdwValue = D3DBLEND_CONSTANTALPHA;
		return S_OK;
	}
    if (_stricmp(str, "INVCONSTANTALPHA" ) == 0)
	{
		*pdwValue = D3DBLEND_INVCONSTANTALPHA;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DBLENDOP_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DBLENDOP_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "ADD" ) == 0)
	{
		*pdwValue = D3DBLENDOP_ADD;
		return S_OK;
	}
    if (_stricmp(str, "SUBTRACT" ) == 0)
	{
		*pdwValue = D3DBLENDOP_SUBTRACT;
		return S_OK;
	}
    if (_stricmp(str, "REVSUBTRACT" ) == 0)
	{
		*pdwValue = D3DBLENDOP_REVSUBTRACT;
		return S_OK;
	}
    if (_stricmp(str, "MIN" ) == 0)
	{
		*pdwValue = D3DBLENDOP_MIN;
		return S_OK;
	}
    if (_stricmp(str, "MAX" ) == 0)
	{
		*pdwValue = D3DBLENDOP_MAX;
		return S_OK;
	}
    if (_stricmp(str, "ADDSIGNED" ) == 0)
	{
		*pdwValue = D3DBLENDOP_ADDSIGNED;
		return S_OK;
	}
    if (_stricmp(str, "REVSUBTRACTSIGNED" ) == 0)
	{
		*pdwValue = D3DBLENDOP_REVSUBTRACTSIGNED;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DCMPFUNC_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DCMP_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "NEVER" ) == 0)
	{
		*pdwValue = D3DCMP_NEVER;
		return S_OK;
	}
    if (_stricmp(str, "LESS" ) == 0)
	{
		*pdwValue = D3DCMP_LESS;
		return S_OK;
	}
    if (_stricmp(str, "EQUAL" ) == 0)
	{
		*pdwValue = D3DCMP_EQUAL;
		return S_OK;
	}
    if (_stricmp(str, "LESSEQUAL" ) == 0)
	{
		*pdwValue = D3DCMP_LESSEQUAL;
		return S_OK;
	}
    if (_stricmp(str, "GREATER" ) == 0)
	{
		*pdwValue = D3DCMP_GREATER;
		return S_OK;
	}
    if (_stricmp(str, "NOTEQUAL" ) == 0)
	{
		*pdwValue = D3DCMP_NOTEQUAL;
		return S_OK;
	}
    if (_stricmp(str, "GREATEREQUAL" ) == 0)
	{
		*pdwValue = D3DCMP_GREATEREQUAL;
		return S_OK;
	}
    if (_stricmp(str, "ALWAYS" ) == 0)
	{
		*pdwValue = D3DCMP_ALWAYS;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DCOLORWRITEENABLE_FromString(const CHAR *str, DWORD *pdwValue)
{
	return E_NOTIMPL;
}

HRESULT D3DCOLOR_FromString(const CHAR *str, DWORD *pdwValue)
{
	return DWORD_FromString(str, pdwValue );
}

HRESULT D3DCULL_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DCULL_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

	if (_stricmp(str, "NONE" ) == 0)
	{
		*pdwValue = D3DCULL_NONE;
		return S_OK;
	}
    if (_stricmp(str, "CW" ) == 0)
	{
		*pdwValue = D3DCULL_CW;
		return S_OK;
	}
    if (_stricmp(str, "CCW" ) == 0)
	{
		*pdwValue = D3DCULL_CCW;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DFRONT_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DFRONT_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "CW" ) == 0)
	{
		*pdwValue = D3DFRONT_CW;
		return S_OK;
	}
    if (_stricmp(str, "CCW" ) == 0)
	{
		*pdwValue = D3DFRONT_CCW;
		return S_OK;
	}
#undef MATCH	
	return E_FAIL;
}

HRESULT D3DFILLMODE_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DFILL_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

	if (_stricmp(str, "POINT" ) == 0)
	{
		*pdwValue = D3DFILL_POINT;
		return S_OK;
	}
	if (_stricmp(str, "WIREFRAME" ) == 0)
	{
		*pdwValue = D3DFILL_WIREFRAME;
		return S_OK;
	}
    if (_stricmp(str, "SOLID" ) == 0)
	{
		*pdwValue = D3DFILL_SOLID;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DFOGMODE_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DFOG_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "NONE" ) == 0)
	{
		*pdwValue = D3DFOG_NONE;
		return S_OK;
	}
    if (_stricmp(str, "EXP" ) == 0)
	{
		*pdwValue = D3DFOG_EXP;
		return S_OK;
	}
    if (_stricmp(str, "EXP2" ) == 0)
	{
		*pdwValue = D3DFOG_EXP2;
		return S_OK;
	}
    if (_stricmp(str, "LINEAR" ) == 0)
	{
		*pdwValue = D3DFOG_LINEAR;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DLOGICOP_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DLOGICOP_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "NONE" ) == 0)
	{
		*pdwValue = D3DLOGICOP_NONE;
		return S_OK;
	}
    if (_stricmp(str, "CLEAR" ) == 0)
	{
		*pdwValue = D3DLOGICOP_CLEAR;
		return S_OK;
	}
    if (_stricmp(str, "AND" ) == 0)
	{
		*pdwValue = D3DLOGICOP_AND;
		return S_OK;
	}
    if (_stricmp(str, "AND_REVERSE" ) == 0)
	{
		*pdwValue = D3DLOGICOP_AND_REVERSE;
		return S_OK;
	}
    if (_stricmp(str, "COPY" ) == 0)
	{
		*pdwValue = D3DLOGICOP_COPY;
		return S_OK;
	}
    if (_stricmp(str, "AND_INVERTED" ) == 0)
	{
		*pdwValue = D3DLOGICOP_AND_INVERTED;
		return S_OK;
	}
    if (_stricmp(str, "NOOP" ) == 0)
	{
		*pdwValue = D3DLOGICOP_NOOP;
		return S_OK;
	}
    if (_stricmp(str, "XOR" ) == 0)
	{
		*pdwValue = D3DLOGICOP_XOR;
		return S_OK;
	}
    if (_stricmp(str, "OR" ) == 0)
	{
		*pdwValue = D3DLOGICOP_OR;
		return S_OK;
	}
    if (_stricmp(str, "NOR" ) == 0)
	{
		*pdwValue = D3DLOGICOP_NOR;
		return S_OK;
	}
    if (_stricmp(str, "EQUIV" ) == 0)
	{
		*pdwValue = D3DLOGICOP_EQUIV;
		return S_OK;
	}
    if (_stricmp(str, "INVERT" ) == 0)
	{
		*pdwValue = D3DLOGICOP_INVERT;
		return S_OK;
	}
    if (_stricmp(str, "OR_REVERSE" ) == 0)
	{
		*pdwValue = D3DLOGICOP_OR_REVERSE;
		return S_OK;
	}
    if (_stricmp(str, "COPY_INVERTED" ) == 0)
	{
		*pdwValue = D3DLOGICOP_COPY_INVERTED;
		return S_OK;
	}
    if (_stricmp(str, "OR_INVERTED" ) == 0)
	{
		*pdwValue = D3DLOGICOP_OR_INVERTED;
		return S_OK;
	}
    if (_stricmp(str, "NAND" ) == 0)
	{
		*pdwValue = D3DLOGICOP_NAND;
		return S_OK;
	}
    if (_stricmp(str, "SET" ) == 0)
	{
		*pdwValue = D3DLOGICOP_SET;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DMATERIALCOLORSOURCE_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DMCS_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "MATERIAL" ) == 0)
	{
		*pdwValue = D3DMCS_MATERIAL;
		return S_OK;
	}            // Color from material is used
    if (_stricmp(str, "COLOR1" ) == 0)
	{
		*pdwValue = D3DMCS_COLOR1;
		return S_OK;
	}            // Diffuse vertex color is used
    if (_stricmp(str, "COLOR2" ) == 0)
	{
		*pdwValue = D3DMCS_COLOR2;
		return S_OK;
	}            // Specular vertex color is used
	return E_FAIL;
}

/*
HRESULT D3DMULTISAMPLE_TYPE_FromString(const CHAR *str, DWORD *pdwValue)
{
	return DWORD_FromString(str, pdwValue );
}
*/

HRESULT D3DPATCHEDGESTYLE_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DPATCHEDGE_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

	if (_stricmp(str, "DISCRETE" ) == 0)
	{
		*pdwValue = D3DPATCHEDGE_DISCRETE;
		return S_OK;
	}
	if (_stricmp(str, "CONTINUOUS" ) == 0)
	{
		*pdwValue = D3DPATCHEDGE_CONTINUOUS;
		return S_OK;
	}
#undef MATCH
	return E_FAIL;
}

HRESULT D3DSHADEMODE_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DSHADE_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "FLAT" ) == 0)
	{
		*pdwValue = D3DSHADE_FLAT;
		return S_OK;
	}
    if (_stricmp(str, "GOURAUD" ) == 0)
	{
		*pdwValue = D3DSHADE_GOURAUD;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DSTENCILOP_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DSTENCILOP_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "KEEP" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_KEEP;
		return S_OK;
	}
    if (_stricmp(str, "ZERO" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_ZERO;
		return S_OK;
	}
    if (_stricmp(str, "REPLACE" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_REPLACE;
		return S_OK;
	}
    if (_stricmp(str, "INCRSAT" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_INCRSAT;
		return S_OK;
	}
    if (_stricmp(str, "DECRSAT" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_DECRSAT;
		return S_OK;
	}
    if (_stricmp(str, "INVERT" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_INVERT;
		return S_OK;
	}
    if (_stricmp(str, "INCR" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_INCR;
		return S_OK;
	}
    if (_stricmp(str, "DECR" ) == 0)
	{
		*pdwValue = D3DSTENCILOP_DECR;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DSWATHWIDTH_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DSWATH_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "8" ) == 0)
	{
		*pdwValue = D3DSWATH_8;
		return S_OK;
	}
    if (_stricmp(str, "16" ) == 0)
	{
		*pdwValue = D3DSWATH_16;
		return S_OK;
	}
    if (_stricmp(str, "32" ) == 0)
	{
		*pdwValue = D3DSWATH_32;
		return S_OK;
	}
    if (_stricmp(str, "64" ) == 0)
	{
		*pdwValue = D3DSWATH_64;
		return S_OK;
	}
    if (_stricmp(str, "128" ) == 0)
	{
		*pdwValue = D3DSWATH_128;
		return S_OK;
	}
    if (_stricmp(str, "OFF" ) == 0)
	{
		*pdwValue = D3DSWATH_OFF;
		return S_OK;
	}
#undef MATCH
	return E_FAIL;
}

HRESULT D3DVERTEXBLENDFLAGS_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DVBF_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

    if (_stricmp(str, "DISABLE" ) == 0)
	{
		*pdwValue = D3DVBF_DISABLE;
		return S_OK;
	}     // Disable vertex blending
    if (_stricmp(str, "1WEIGHTS" ) == 0)
	{
		*pdwValue = D3DVBF_1WEIGHTS;
		return S_OK;
	}     // 2 matrix blending
    if (_stricmp(str, "2WEIGHTS" ) == 0)
	{
		*pdwValue = D3DVBF_2WEIGHTS;
		return S_OK;
	}     // 3 matrix blending
    if (_stricmp(str, "3WEIGHTS" ) == 0)
	{
		*pdwValue = D3DVBF_3WEIGHTS;
		return S_OK;
	}     // 4 matrix blending
    if (_stricmp(str, "2WEIGHTS2MATRICES" ) == 0)
	{
		*pdwValue = D3DVBF_2WEIGHTS2MATRICES;
		return S_OK;
	}     // Xbox extension
    if (_stricmp(str, "3WEIGHTS3MATRICES" ) == 0)
	{
		*pdwValue = D3DVBF_3WEIGHTS3MATRICES;
		return S_OK;
	}     // Xbox extension
    if (_stricmp(str, "4WEIGHTS4MATRICES" ) == 0)
	{
		*pdwValue = D3DVBF_4WEIGHTS4MATRICES;
		return S_OK;
	}     // Xbox extension
	return E_FAIL;
}

HRESULT D3DWRAP_FromString(const CHAR *str, DWORD *pdwValue)
{
	return E_NOTIMPL;
}

HRESULT D3DZBUFFERTYPE_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DZB_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}

	if (_stricmp(str, "FALSE" ) == 0)
	{
		*pdwValue = D3DZB_FALSE;
		return S_OK;
	}
    if (_stricmp(str, "TRUE" ) == 0)
	{
		*pdwValue = D3DZB_TRUE;
		return S_OK;
	}
    if (_stricmp(str, "USEW" ) == 0)
	{
		*pdwValue = D3DZB_USEW;
		return S_OK;
	}
	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////
// Texture state helpers
//
HRESULT D3DTEXF_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DTEXF_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
    if (_stricmp(str, "NONE") == 0)
	{
		*pdwValue = D3DTEXF_NONE;
		return S_OK;
	}
    if (_stricmp(str, "POINT") == 0)
	{
		*pdwValue = D3DTEXF_POINT;
		return S_OK;
	}
    if (_stricmp(str, "LINEAR") == 0)
	{
		*pdwValue = D3DTEXF_LINEAR;
		return S_OK;
	}
    if (_stricmp(str, "ANISOTROPIC") == 0)
	{
		*pdwValue = D3DTEXF_ANISOTROPIC;
		return S_OK;
	}
    if (_stricmp(str, "QUINCUNX") == 0)
	{
		*pdwValue = D3DTEXF_QUINCUNX;
		return S_OK;
	}
    if (_stricmp(str, "GAUSSIANCUBIC") == 0)
	{
		*pdwValue = D3DTEXF_GAUSSIANCUBIC;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DTEXTUREADDRESS_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DTADDRESS_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
    if (_stricmp(str, "WRAP") == 0)
	{
		*pdwValue = D3DTADDRESS_WRAP;
		return S_OK;
	}
    if (_stricmp(str, "MIRROR") == 0)
	{
		*pdwValue = D3DTADDRESS_MIRROR;
		return S_OK;
	}
    if (_stricmp(str, "CLAMP") == 0)
	{
		*pdwValue = D3DTADDRESS_CLAMP;
		return S_OK;
	}
    if (_stricmp(str, "BORDER") == 0)
	{
		*pdwValue = D3DTADDRESS_BORDER;
		return S_OK;
	}
    if (_stricmp(str, "CLAMPTOEDGE") == 0)
	{
		*pdwValue = D3DTADDRESS_CLAMPTOEDGE;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DTEXTUREALPHAKILL_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DTALPHAKILL_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
	
    if (_stricmp(str, "DISABLE") == 0
		|| _stricmp(str, "FALSE") == 0)
	{
		*pdwValue = D3DTALPHAKILL_DISABLE;
		return S_OK;
	}
    if (_stricmp(str, "ENABLE") == 0
		|| _stricmp(str, "TRUE") == 0)		// why is alpha kill different from all the other TRUE/FALSE settings?
	{
		*pdwValue = D3DTALPHAKILL_ENABLE;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DTEXTUREARG_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DTA_";
	int len = strlen(prefix);

	// copy the input string to a temporary buffer so we can use strtok
	const int buflen = 1000;
	CHAR buf[buflen];
	strncpy(buf, str, buflen);
	buf[buflen - 1] = 0;
	CHAR *strSeparators = " \t\n|";		// '|' is a valid separator in addition to whitespace
	CHAR *strBuff = strtok(buf, strSeparators);

	// look for texture args
	bool bComplement = false;
	bool bAlphaReplicate = false;
	DWORD dwSelect = (DWORD)-1;
	while (strBuff != NULL)
	{
		// skip prefix
		if (_strnicmp(strBuff, prefix, len) == 0)
		{
			strBuff += len;
		}

		// look for matches
		if (dwSelect == -1)
		{
			if (_stricmp(strBuff, "DIFFUSE") == 0)
			{
				dwSelect =  D3DTA_DIFFUSE;
			}
			else if (_stricmp(strBuff, "CURRENT") == 0)
			{
				dwSelect =  D3DTA_CURRENT;
			}
			else if (_stricmp(strBuff, "TEXTURE") == 0)
			{
				dwSelect =  D3DTA_TEXTURE;
			}
			else if (_stricmp(strBuff, "TFACTOR") == 0)
			{
				dwSelect =  D3DTA_TFACTOR;
			}
			else if (_stricmp(strBuff, "SPECULAR") == 0)
			{
				dwSelect =  D3DTA_SPECULAR;
			}
			else if (_stricmp(strBuff, "TEMP") == 0)
			{
				dwSelect =  D3DTA_TEMP;
			}
			else if (_stricmp(strBuff, "COMPLEMENT") == 0)
			{
				bComplement = true;
			}
			else if (_stricmp(strBuff, "ALPHAREPLICATE") == 0)
			{
				bAlphaReplicate = true;
			}
			else
				return E_FAIL;
		}
		else // look just for complement and alpha replicate
		{
			if (_stricmp(strBuff, "COMPLEMENT") == 0)
			{
				bComplement = true;
			}
			else if (_stricmp(strBuff, "ALPHAREPLICATE") == 0)
			{
				bAlphaReplicate = true;
			}
			else
				return E_FAIL;
		}
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)
		
		// Get next token
		strBuff = strtok(NULL, strSeparators);
	}
	if (dwSelect == -1)
		return E_FAIL;	// TODO: better error message

	// set return value
	if (bComplement)
		dwSelect |= D3DTA_COMPLEMENT;
	if (bAlphaReplicate)
		dwSelect |= D3DTA_ALPHAREPLICATE;
	*pdwValue = dwSelect;
	return S_OK;
}

HRESULT D3DTEXTURECOLORKEYOP_FromString(const CHAR *str, DWORD *pdwValue)
{
	CHAR *prefix = "D3DTCOLORKEYOP_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
	
    if (_stricmp(str, "DISABLE") == 0)
	{
		*pdwValue = D3DTCOLORKEYOP_DISABLE;
		return S_OK;
	}
    if (_stricmp(str, "ALPHA") == 0)
	{
		*pdwValue = D3DTCOLORKEYOP_ALPHA;
		return S_OK;
	}
    if (_stricmp(str, "RGBA") == 0)
	{
		*pdwValue = D3DTCOLORKEYOP_RGBA;
		return S_OK;
	}
    if (_stricmp(str, "KILL") == 0)
	{
		*pdwValue = D3DTCOLORKEYOP_KILL;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DTEXTUREOP_FromString(const CHAR *str, DWORD *pdwValue)
{
	// These should be done with the pixel shader, not with the texture stage states. 
	CHAR *prefix = "D3DTOP_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
	
    if (_stricmp(str, "DISABLE") == 0)
	{
		*pdwValue = D3DTOP_DISABLE;
		return S_OK;
	}
    if (_stricmp(str, "SELECTARG1") == 0)
	{
		*pdwValue = D3DTOP_SELECTARG1;
		return S_OK;
	}
    if (_stricmp(str, "SELECTARG2") == 0)
	{
		*pdwValue = D3DTOP_SELECTARG2;
		return S_OK;
	}
    if (_stricmp(str, "MODULATE") == 0)
	{
		*pdwValue = D3DTOP_MODULATE;
		return S_OK;
	}
    if (_stricmp(str, "MODULATE2X") == 0)
	{
		*pdwValue = D3DTOP_MODULATE2X;
		return S_OK;
	}
    if (_stricmp(str, "MODULATE4X") == 0)
	{
		*pdwValue = D3DTOP_MODULATE4X;
		return S_OK;
	}
    if (_stricmp(str, "ADD") == 0)
	{
		*pdwValue = D3DTOP_ADD;
		return S_OK;
	}
    if (_stricmp(str, "ADDSIGNED") == 0)
	{
		*pdwValue = D3DTOP_ADDSIGNED;
		return S_OK;
	}
    if (_stricmp(str, "ADDSIGNED2X") == 0)
	{
		*pdwValue = D3DTOP_ADDSIGNED2X;
		return S_OK;
	}
    if (_stricmp(str, "SUBTRACT") == 0)
	{
		*pdwValue = D3DTOP_SUBTRACT;
		return S_OK;
	}
    if (_stricmp(str, "ADDSMOOTH") == 0)
	{
		*pdwValue = D3DTOP_ADDSMOOTH;
		return S_OK;
	}
    if (_stricmp(str, "BLENDDIFFUSEALPHA") == 0)
	{
		*pdwValue = D3DTOP_BLENDDIFFUSEALPHA;
		return S_OK;
	}
    if (_stricmp(str, "BLENDTEXTUREALPHA") == 0)
	{
		*pdwValue = D3DTOP_BLENDTEXTUREALPHA;
		return S_OK;
	}
    if (_stricmp(str, "BLENDFACTORALPHA") == 0)
	{
		*pdwValue = D3DTOP_BLENDFACTORALPHA;
		return S_OK;
	}
    if (_stricmp(str, "BLENDTEXTUREALPHAPM") == 0)
	{
		*pdwValue = D3DTOP_BLENDTEXTUREALPHAPM;
		return S_OK;
	}
    if (_stricmp(str, "BLENDCURRENTALPHA") == 0)
	{
		*pdwValue = D3DTOP_BLENDCURRENTALPHA;
		return S_OK;
	}
    if (_stricmp(str, "PREMODULATE") == 0)
	{
		*pdwValue = D3DTOP_PREMODULATE;
		return S_OK;
	}
    if (_stricmp(str, "MODULATEALPHA_ADDCOLOR") == 0)
	{
		*pdwValue = D3DTOP_MODULATEALPHA_ADDCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "MODULATECOLOR_ADDALPHA") == 0)
	{
		*pdwValue = D3DTOP_MODULATECOLOR_ADDALPHA;
		return S_OK;
	}
    if (_stricmp(str, "MODULATEINVALPHA_ADDCOLOR") == 0)
	{
		*pdwValue = D3DTOP_MODULATEINVALPHA_ADDCOLOR;
		return S_OK;
	}
    if (_stricmp(str, "MODULATEINVCOLOR_ADDALPHA") == 0)
	{
		*pdwValue = D3DTOP_MODULATEINVCOLOR_ADDALPHA;
		return S_OK;
	}
    if (_stricmp(str, "DOTPRODUCT3") == 0)
	{
		*pdwValue = D3DTOP_DOTPRODUCT3;
		return S_OK;
	}
    if (_stricmp(str, "MULTIPLYADD") == 0)
	{
		*pdwValue = D3DTOP_MULTIPLYADD;
		return S_OK;
	}
    if (_stricmp(str, "LERP") == 0)
	{
		*pdwValue = D3DTOP_LERP;
		return S_OK;
	}
    if (_stricmp(str, "BUMPENVMAP") == 0)
	{
		*pdwValue = D3DTOP_BUMPENVMAP;
		return S_OK;
	}
    if (_stricmp(str, "BUMPENVMAPLUMINANCE") == 0)
	{
		*pdwValue = D3DTOP_BUMPENVMAPLUMINANCE;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT D3DTEXTURETRANSFORMFLAGS_FromString(const CHAR *str, DWORD *pdwValue)
{
	// These should be done with the vertex shader, not here.
	return E_NOTIMPL;
/*	
	CHAR *prefix = "D3DTTFF_";
	int len = strlen(prefix);
	if (_strnicmp(str, prefix, len) == 0)
	{
		str += len;
	}
	
    if (_stricmp(str, "DISABLE") == 0)
	{
		*pdwValue = D3DTTFF_DISABLE;
		return S_OK;
	}
    if (_stricmp(str, "COUNT1") == 0)
	{
		*pdwValue = D3DTTFF_COUNT1;
		return S_OK;
	}
    if (_stricmp(str, "COUNT2") == 0)
	{
		*pdwValue = D3DTTFF_COUNT2;
		return S_OK;
	}
    if (_stricmp(str, "COUNT3") == 0)
	{
		*pdwValue = D3DTTFF_COUNT3;
		return S_OK;
	}
    if (_stricmp(str, "COUNT4") == 0)
	{
		*pdwValue = D3DTTFF_COUNT4;
		return S_OK;
	}
    if (_stricmp(str, "PROJECTED") == 0)
	{
		*pdwValue = D3DTTFF_PROJECTED;
		return S_OK;
	}
	return E_FAIL;
*/
}

HRESULT D3DTSIGN_FromString(const CHAR *str, DWORD *pdwValue)
{
	return E_NOTIMPL;
	/*
#define D3DTSIGN_ASIGNED           0x10000000
#define D3DTSIGN_AUNSIGNED         0
#define D3DTSIGN_RSIGNED           0x20000000
#define D3DTSIGN_RUNSIGNED         0
#define D3DTSIGN_GSIGNED           0x40000000
#define D3DTSIGN_GUNSIGNED         0
#define D3DTSIGN_BSIGNED           0x80000000
#define D3DTSIGN_BUNSIGNED         0
	*/
}



HRESULT XBContent::BeginDraw(ISAXAttributes *pAttributes)
{
	Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
	PushContext(Draw_Context);
	m_rContextStack[m_iContext].m_pData = pEffect;	// keep effect pointer
	Pass *pPass = &pEffect->rPass[pEffect->PassCount];
	if (pPass->rDraw == NULL)
	{
		pPass->rDraw = new Draw [ MAX_DRAW ];
		if (pPass->rDraw == NULL)
			return E_OUTOFMEMORY;
	}
	if (pPass->DrawCount >= MAX_DRAW)
		return E_NOTIMPL;
	Draw *pDraw = &pPass->rDraw[pPass->DrawCount];
	ZeroMemory(pDraw, sizeof(Draw));

	// TODO: check that draw has not already been set. If so, make
	// a new pass with the same state.

	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(idref))
		{
			CHAR *strID = CharString(pwchValue, cchValue);
			DWORD dwResourceIndex;
			if (!m_pBundler->IsExistingIdentifier(strID, &dwResourceIndex))
			{
				m_pBundler->ErrorMsg("Unknown index buffer resource \"%s\"\n", strID);
				return E_FAIL;
			}
			pDraw->IndexBufferResource = dwResourceIndex;
		}
		else if (MATCH(primitive))
		{
			CHAR *strPrimitive = CharString(pwchValue, cchValue);
			pDraw->Primitive = PrimitiveTypeFromString(strPrimitive);
			if (pDraw->Primitive == (D3DPRIMITIVETYPE)-1)
			{
				m_pBundler->ErrorMsg("Unknown primitive type \"%s\"\n", strPrimitive);
				return E_FAIL;
			}
		}
		else if (MATCH(start))
		{
			pDraw->Start = atoi(CharString(pwchValue, cchValue));
		}
		else if (MATCH(count))
		{
			pDraw->Count = atoi(CharString(pwchValue, cchValue));
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	
	// TODO: check that all required parameters have been set
	pPass->DrawCount++;
	return S_OK;
}

HRESULT XBContent::EndDraw()
{
	PopContext();
	return S_OK;
}
	
HRESULT XBContent::BeginRenderState(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
	PushContext(RenderState_Context);
	m_rContextStack[m_iContext].m_pData = pEffect;	// keep effect pointer
	Pass *pPass = &pEffect->rPass[pEffect->PassCount];
	if (pPass->rRenderState != NULL)
	{
		fatalError(m_pLocator, L"<RenderState> tag must appear just once within a pass block\n", E_FAIL);
		m_bErrorSuppress = true;
		return E_FAIL;
	}

	// Render state to be filled in by attributes
	RenderState rRenderState[ MAX_RENDER_STATE ];
	memset(rRenderState, -1, sizeof(rRenderState));
	
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
		CHAR *str = CharString(pwchValue, cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(D3DRS_))
		{
			// Strip off D3DRS_ prefix
			pwchLocalName += 6;
			cchLocalName -= 6;
		}
		DWORD State = (DWORD)-1;
		DWORD Value;
		if (MATCH(PS))
		{
			// strip off PS prefix
			pwchLocalName += 2;
			cchLocalName -= 2;
			
			// look for pixel shader render states
			if (MATCH(ALPHAINPUTS0))
			{
				State = D3DRS_PSALPHAINPUTS0;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAINPUTS1))
			{
				State = D3DRS_PSALPHAINPUTS1;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAINPUTS2))
			{
				State = D3DRS_PSALPHAINPUTS2;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAINPUTS3))
			{
				State = D3DRS_PSALPHAINPUTS3;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAINPUTS4))
			{
				State = D3DRS_PSALPHAINPUTS4;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAINPUTS5))
			{
				State = D3DRS_PSALPHAINPUTS5;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAINPUTS6))
			{
				State = D3DRS_PSALPHAINPUTS6;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAINPUTS7))
			{
				State = D3DRS_PSALPHAINPUTS7;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(FINALCOMBINERINPUTSABCD))
			{
				State = D3DRS_PSFINALCOMBINERINPUTSABCD;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(FINALCOMBINERINPUTSEFG))
			{
				State = D3DRS_PSFINALCOMBINERINPUTSEFG;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_0))
			{
				State = D3DRS_PSCONSTANT0_0;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_1))
			{
				State = D3DRS_PSCONSTANT0_1;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_2))
			{
				State = D3DRS_PSCONSTANT0_2;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_3))
			{
				State = D3DRS_PSCONSTANT0_3;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_4))
			{
				State = D3DRS_PSCONSTANT0_4;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_5))
			{
				State = D3DRS_PSCONSTANT0_5;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_6))
			{
				State = D3DRS_PSCONSTANT0_6;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT0_7))
			{
				State = D3DRS_PSCONSTANT0_7;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_0))
			{
				State = D3DRS_PSCONSTANT1_0;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_1))
			{
				State = D3DRS_PSCONSTANT1_1;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_2))
			{
				State = D3DRS_PSCONSTANT1_2;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_3))
			{
				State = D3DRS_PSCONSTANT1_3;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_4))
			{
				State = D3DRS_PSCONSTANT1_4;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_5))
			{
				State = D3DRS_PSCONSTANT1_5;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_6))
			{
				State = D3DRS_PSCONSTANT1_6;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(CONSTANT1_7))
			{
				State = D3DRS_PSCONSTANT1_7;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS0))
			{
				State = D3DRS_PSALPHAOUTPUTS0;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS1))
			{
				State = D3DRS_PSALPHAOUTPUTS1;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS2))
			{
				State = D3DRS_PSALPHAOUTPUTS2;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS3))
			{
				State = D3DRS_PSALPHAOUTPUTS3;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS4))
			{
				State = D3DRS_PSALPHAOUTPUTS4;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS5))
			{
				State = D3DRS_PSALPHAOUTPUTS5;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS6))
			{
				State = D3DRS_PSALPHAOUTPUTS6;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOUTPUTS7))
			{
				State = D3DRS_PSALPHAOUTPUTS7;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS0))
			{
				State = D3DRS_PSRGBINPUTS0;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS1))
			{
				State = D3DRS_PSRGBINPUTS1;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS2))
			{
				State = D3DRS_PSRGBINPUTS2;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS3))
			{
				State = D3DRS_PSRGBINPUTS3;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS4))
			{
				State = D3DRS_PSRGBINPUTS4;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS5))
			{
				State = D3DRS_PSRGBINPUTS5;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS6))
			{
				State = D3DRS_PSRGBINPUTS6;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBINPUTS7))
			{
				State = D3DRS_PSRGBINPUTS7;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(COMPAREMODE))
			{
				State = D3DRS_PSCOMPAREMODE;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(FINALCOMBINERCONSTANT0))
			{
				State = D3DRS_PSFINALCOMBINERCONSTANT0;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(FINALCOMBINERCONSTANT1))
			{
				State = D3DRS_PSFINALCOMBINERCONSTANT1;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS0))
			{
				State = D3DRS_PSRGBOUTPUTS0;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS1))
			{
				State = D3DRS_PSRGBOUTPUTS1;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS2))
			{
				State = D3DRS_PSRGBOUTPUTS2;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS3))
			{
				State = D3DRS_PSRGBOUTPUTS3;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS4))
			{
				State = D3DRS_PSRGBOUTPUTS4;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS5))
			{
				State = D3DRS_PSRGBOUTPUTS5;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS6))
			{
				State = D3DRS_PSRGBOUTPUTS6;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(RGBOUTPUTS7))
			{
				State = D3DRS_PSRGBOUTPUTS7;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(COMBINERCOUNT))
			{
				State = D3DRS_PSCOMBINERCOUNT;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(DOTMAPPING))
			{
				State = D3DRS_PSDOTMAPPING;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(INPUTTEXTURE))
			{
				State = D3DRS_PSINPUTTEXTURE;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(TEXTUREMODES))
			{
				State = D3DRS_PSTEXTUREMODES;
				hr = DWORD_FromString(str, &Value);
			}
			else
			{
				return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
			}
		}
		// Non Pixel Shader render states
		else if (MATCH(ZFUNC))
		{
			State = D3DRS_ZFUNC;
			hr = D3DCMPFUNC_FromString(str, &Value);
		}
		else if (MATCH(ALPHAFUNC))
		{
			State = D3DRS_ALPHAFUNC;
			hr = D3DCMPFUNC_FromString(str, &Value);
		}
		else if (MATCH(ALPHABLENDENABLE))
		{
			State = D3DRS_ALPHABLENDENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(ALPHATESTENABLE))
		{
			State = D3DRS_ALPHATESTENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(ALPHAREF))
		{
			State = D3DRS_ALPHAREF;
			hr = BYTE_FromString(str, &Value);
		}
		else if (MATCH(SRCBLEND))
		{
			State = D3DRS_SRCBLEND;
			hr = D3DBLEND_FromString(str, &Value);
		}
		else if (MATCH(DESTBLEND))
		{
			State = D3DRS_DESTBLEND;
			hr = D3DBLEND_FromString(str, &Value);
		}
		else if (MATCH(ZWRITEENABLE))
		{
			State = D3DRS_ZWRITEENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(DITHERENABLE))
		{
			State = D3DRS_DITHERENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(SHADEMODE))
		{
			State = D3DRS_SHADEMODE;
			hr = D3DSHADEMODE_FromString(str, &Value);
		}
		else if (MATCH(COLORWRITEENABLE))
		{
			State = D3DRS_COLORWRITEENABLE;
			hr = D3DCOLORWRITEENABLE_FromString(str, &Value);
		}
		else if (MATCH(STENCILZFAIL))
		{
			State = D3DRS_STENCILZFAIL;
			hr = D3DSTENCILOP_FromString(str, &Value);
		}
		else if (MATCH(STENCILPASS))
		{
			State = D3DRS_STENCILPASS;
			hr = D3DSTENCILOP_FromString(str, &Value);
		}
		else if (MATCH(STENCILFUNC))
		{
			State = D3DRS_STENCILFUNC;
			hr = D3DCMPFUNC_FromString(str, &Value);
		}
		else if (MATCH(STENCILREF))
		{
			State = D3DRS_STENCILREF;
			hr = BYTE_FromString(str, &Value);
		}
		else if (MATCH(STENCILMASK))
		{
			State = D3DRS_STENCILMASK;
			hr = BYTE_FromString(str, &Value);
		}
		else if (MATCH(STENCILWRITEMASK))
		{
			State = D3DRS_STENCILWRITEMASK;
			hr = BYTE_FromString(str, &Value);
		}
		else if (MATCH(BLENDOP))
		{
			State = D3DRS_BLENDOP;
			hr = D3DBLENDOP_FromString(str, &Value);
		}
		else if (MATCH(BLENDCOLOR))
		{
			State = D3DRS_BLENDCOLOR;
			hr = D3DCOLOR_FromString(str, &Value);
		}
		else if (MATCH(SWATHWIDTH))
		{
			State = D3DRS_SWATHWIDTH;
			hr = D3DSWATHWIDTH_FromString(str, &Value);
		}
		else if (MATCH(POLYGONOFFSETZSLOPESCALE))
		{
			State = D3DRS_POLYGONOFFSETZSLOPESCALE;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(POLYGONOFFSETZOFFSET))
		{
			State = D3DRS_POLYGONOFFSETZOFFSET;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(POINTOFFSETENABLE))
		{
			State = D3DRS_POINTOFFSETENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(WIREFRAMEOFFSETENABLE))
		{
			State = D3DRS_WIREFRAMEOFFSETENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(SOLIDOFFSETENABLE))
		{
			State = D3DRS_SOLIDOFFSETENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(FOGENABLE))
		{
			State = D3DRS_FOGENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(FOGTABLEMODE))
		{
			State = D3DRS_FOGTABLEMODE;
			hr = D3DFOGMODE_FromString(str, &Value);
		}
		else if (MATCH(FOGSTART))
		{
			State = D3DRS_FOGSTART;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(FOGEND))
		{
			State = D3DRS_FOGEND;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(FOGDENSITY))
		{
			State = D3DRS_FOGDENSITY;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(RANGEFOGENABLE))
		{
			State = D3DRS_RANGEFOGENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(WRAP0))
		{
			State = D3DRS_WRAP0;
			hr = D3DWRAP_FromString(str, &Value);
		}
		else if (MATCH(WRAP1))
		{
			State = D3DRS_WRAP1;
			hr = D3DWRAP_FromString(str, &Value);
		}
		else if (MATCH(WRAP2))
		{
			State = D3DRS_WRAP2;
			hr = D3DWRAP_FromString(str, &Value);
		}
		else if (MATCH(WRAP3))
		{
			State = D3DRS_WRAP3;
			hr = D3DWRAP_FromString(str, &Value);
		}
		else if (MATCH(LIGHTING))
		{
			State = D3DRS_LIGHTING;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(SPECULARENABLE))
		{
			State = D3DRS_SPECULARENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(LOCALVIEWER))
		{
			State = D3DRS_LOCALVIEWER;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(COLORVERTEX))
		{
			State = D3DRS_COLORVERTEX;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(BACKSPECULARMATERIALSOURCE))
		{
			State = D3DRS_BACKSPECULARMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(BACKDIFFUSEMATERIALSOURCE))
		{
			State = D3DRS_BACKDIFFUSEMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(BACKAMBIENTMATERIALSOURCE))
		{
			State = D3DRS_BACKAMBIENTMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(BACKEMISSIVEMATERIALSOURCE))
		{
			State = D3DRS_BACKEMISSIVEMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(SPECULARMATERIALSOURCE))
		{
			State = D3DRS_SPECULARMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(DIFFUSEMATERIALSOURCE))
		{
			State = D3DRS_DIFFUSEMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(AMBIENTMATERIALSOURCE))
		{
			State = D3DRS_AMBIENTMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(EMISSIVEMATERIALSOURCE))
		{
			State = D3DRS_EMISSIVEMATERIALSOURCE;
			hr = D3DMATERIALCOLORSOURCE_FromString(str, &Value);
		}
		else if (MATCH(BACKAMBIENT))
		{
			State = D3DRS_BACKAMBIENT;
			hr = D3DCOLOR_FromString(str, &Value);
		}
		else if (MATCH(AMBIENT))
		{
			State = D3DRS_AMBIENT;
			hr = D3DCOLOR_FromString(str, &Value);
		}
		else if (MATCH(POINTSIZE))
		{
			State = D3DRS_POINTSIZE;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(POINTSIZE_MIN))
		{
			State = D3DRS_POINTSIZE_MIN;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(POINTSPRITEENABLE))
		{
			State = D3DRS_POINTSPRITEENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(POINTSCALEENABLE))
		{
			State = D3DRS_POINTSCALEENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(POINTSCALE_A))
		{
			State = D3DRS_POINTSCALE_A;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(POINTSCALE_B))
		{
			State = D3DRS_POINTSCALE_B;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(POINTSCALE_C))
		{
			State = D3DRS_POINTSCALE_C;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(POINTSIZE_MAX))
		{
			State = D3DRS_POINTSIZE_MAX;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(PATCHEDGESTYLE))
		{
			State = D3DRS_PATCHEDGESTYLE;
			hr = D3DPATCHEDGESTYLE_FromString(str, &Value);
		}
		else if (MATCH(PATCHSEGMENTS))
		{
			State = D3DRS_PATCHSEGMENTS;
			hr = DWORD_FromString(str, &Value);
		}
		else if (MATCH(VERTEXBLEND))
		{
			State = D3DRS_VERTEXBLEND;
			hr = D3DVERTEXBLENDFLAGS_FromString(str, &Value);
		}
		else if (MATCH(FOGCOLOR))
		{
			State = D3DRS_FOGCOLOR;
			hr = D3DCOLOR_FromString(str, &Value);
		}
		else if (MATCH(FILLMODE))
		{
			State = D3DRS_FILLMODE;
			hr = D3DFILLMODE_FromString(str, &Value);
		}
		else if (MATCH(BACKFILLMODE))
		{
			State = D3DRS_BACKFILLMODE;
			hr = D3DFILLMODE_FromString(str, &Value);
		}
		else if (MATCH(TWOSIDEDLIGHTING))
		{
			State = D3DRS_TWOSIDEDLIGHTING;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(NORMALIZENORMALS))
		{
			State = D3DRS_NORMALIZENORMALS;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(ZENABLE))
		{
			State = D3DRS_ZENABLE;
			hr = D3DZBUFFERTYPE_FromString(str, &Value);
		}
		else if (MATCH(STENCILENABLE))
		{
			State = D3DRS_STENCILENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(STENCILFAIL))
		{
			State = D3DRS_STENCILFAIL;
			hr = D3DSTENCILOP_FromString(str, &Value);
		}
		else if (MATCH(FRONTFACE))
		{
			State = D3DRS_FRONTFACE;
			hr = D3DFRONT_FromString(str, &Value);
		}
		else if (MATCH(CULLMODE))
		{
			State = D3DRS_CULLMODE;
			hr = D3DCULL_FromString(str, &Value);
		}
		else if (MATCH(TEXTUREFACTOR))
		{
			State = D3DRS_TEXTUREFACTOR;
			hr = D3DCOLOR_FromString(str, &Value);
		}
		else if (MATCH(ZBIAS))
		{
			State = D3DRS_ZBIAS;
			hr = LONG_FromString(str, &Value);
		}
		else if (MATCH(LOGICOP))
		{
			State = D3DRS_LOGICOP;
			hr = D3DLOGICOP_FromString(str, &Value);
		}
		else if (MATCH(EDGEANTIALIAS))
		{
			State = D3DRS_EDGEANTIALIAS;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(MULTISAMPLEANTIALIAS))
		{
			State = D3DRS_MULTISAMPLEANTIALIAS;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(MULTISAMPLEMASK))
		{
			State = D3DRS_MULTISAMPLEMASK;
			hr = DWORD_FromString(str, &Value);
		}
/*		
		else if (MATCH(MULTISAMPLETYPE))
		{
			State = D3DRS_MULTISAMPLETYPE;
			hr = D3DMULTISAMPLE_TYPE_FromString(str, &Value);
		}
*/
		else if (MATCH(SHADOWFUNC))
		{
			State = D3DRS_SHADOWFUNC;
			hr = D3DCMPFUNC_FromString(str, &Value);
		}
		else if (MATCH(LINEWIDTH))
		{
			State = D3DRS_LINEWIDTH;
			hr = FLOAT_FromString(str, &Value);
		}
		else if (MATCH(DXT1NOISEENABLE))
		{
		    State = D3DRS_DXT1NOISEENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(YUVENABLE))
		{
			State = D3DRS_YUVENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(OCCLUSIONCULLENABLE))
		{
			State = D3DRS_OCCLUSIONCULLENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(STENCILCULLENABLE))
		{
			State = D3DRS_STENCILCULLENABLE;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(ROPZCMPALWAYSREAD))
		{
			State = D3DRS_ROPZCMPALWAYSREAD;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(ROPZREAD))
		{
			State = D3DRS_ROPZREAD;
			hr = TRUE_FromString(str, &Value);
		}
		else if (MATCH(DONOTCULLUNCOMPRESSED))
		{
			State = D3DRS_DONOTCULLUNCOMPRESSED;
			hr = TRUE_FromString(str, &Value);
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);

		// If the value-parsing failed, print an error and exit.
		if (FAILED(hr))
			return UnexpectedAttributeToken(pwchLocalName, cchLocalName, pwchValue, cchValue, E_FAIL);

		// Add the render state, value pair to the list.  The rRenderState
		// array is big enough to hold all the possible render state values,
		// and on the Xbox, the enumeration is sequential, so we use the 
		// state as an index.
		rRenderState[State].State = State;
		rRenderState[State].Value = Value;
#undef MATCH
	}

	// Count number of active render states
	UINT nRenderStateCount = 0;
	UINT i;
	for (i = 0; i < MAX_RENDER_STATE; i++)
	{
		if (rRenderState[i].State != -1)
			nRenderStateCount++;
	}
	
	// Copy render state values to variably-sized array
	pPass->RenderStateCount = nRenderStateCount;
	pPass->rRenderState = new RenderState [ nRenderStateCount ];
	if (pPass->rRenderState == NULL)
	{
		fatalError(m_pLocator, L"Memory allocation failed for render state array\n", E_FAIL);
		m_bErrorSuppress = true;
		return E_FAIL;
	}
	nRenderStateCount = 0;
	for (i = 0; i < MAX_RENDER_STATE; i++)
	{
		if (rRenderState[i].State != -1)
		{
			pPass->rRenderState[nRenderStateCount] = rRenderState[i];
			nRenderStateCount++;
		}
	}
	
	return S_OK;	// default return
}

HRESULT XBContent::EndRenderState()
{
	// Find maximum active texture stage
	Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
	Pass *pPass = &pEffect->rPass[pEffect->PassCount];
	for (UINT i = 0; i < MAX_TEXTURE_STAGE; i++)
	{
		TextureStage *pTextureStage = &pPass->rTextureStage[i];
		if (pTextureStage->TextureResource != 0
			|| pTextureStage->TextureStateCount != 0)
		{
			// set stage count to one beyond maximum active stage
			pPass->TextureStageCount = i + 1;
		}
	}
	PopContext();
	return S_OK;
}
	
HRESULT XBContent::BeginTextureState(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
	PushContext(TextureState_Context);
	m_rContextStack[m_iContext].m_pData = pEffect;	// keep effect pointer
	Pass *pPass = &pEffect->rPass[pEffect->PassCount];
	if (pPass->rTextureStage == NULL)
	{
		pPass->rTextureStage = new TextureStage [ MAX_TEXTURE_STAGE ];
		ZeroMemory(pPass->rTextureStage, sizeof(TextureStage) * MAX_TEXTURE_STAGE );
	}

	// Texture stage state to be filled in by attributes
	DWORD Stage = (DWORD)-1;
	TextureState rTextureState[ MAX_TEXTURE_STATE ];
	memset(rTextureState, -1, sizeof(rTextureState));
	DWORD dwTextureResourceIndex = 0;
	
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
		CHAR *str = CharString(pwchValue, cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(Stage))
		{
			// The Stage token is special and is processed separately from the rest of the attributes
			hr = DWORD_FromString(str, &Stage);
			if (FAILED(hr))
				return UnexpectedToken(pwchValue, cchValue, E_FAIL);
			const int buflen = 1000;
			WCHAR buf[buflen];
			if (Stage >= MAX_TEXTURE_STAGE)
			{
				_snwprintf(buf, buflen, L"Invalid texture stage %d >= %d\n", Stage, MAX_TEXTURE_STAGE);
				fatalError(m_pLocator, buf, E_FAIL);
				m_bErrorSuppress = true;
				return E_FAIL;
			}
			TextureStage *pTextureStage = &pPass->rTextureStage[Stage];
			if (pTextureStage->rTextureState != NULL)
			{
				_snwprintf(buf, buflen, L"<TextureState> with Stage=%d already defined\n", Stage);
				fatalError(m_pLocator, buf, E_FAIL);
				m_bErrorSuppress = true;
				return E_FAIL;
			}
		}
		else if (MATCH(idref))
		{
			if (strcmp(str, "NULL") == 0)	// NULL is special case
				dwTextureResourceIndex = 0;
			else
			{
				// The idref token is special, and selects the current texture.
				if (!m_pBundler->IsExistingIdentifier(str, &dwTextureResourceIndex))
				{
					m_pBundler->ErrorMsg("Unknown resource \"%s\"\n", str);
					return E_FAIL;
				}
				// TODO: make sure this is a texture resource
			}
		}
		else
		{
			if (MATCH(D3DTSS_))
			{
				// Strip off D3DTSS_ prefix
				pwchLocalName += 7;
				cchLocalName -= 7;
			}

			DWORD State = (DWORD)-1;
			DWORD Value;
			if (MATCH(COLOROP))
			{
				State = D3DTSS_COLOROP;
				hr = D3DTEXTUREOP_FromString(str, &Value);
			}
			else if (MATCH(COLORARG0))
			{
				State = D3DTSS_COLORARG0;
				hr = D3DTEXTUREARG_FromString(str, &Value);
			}
			else if (MATCH(COLORARG1))
			{
				State = D3DTSS_COLORARG1;
				hr = D3DTEXTUREARG_FromString(str, &Value);
			}
			else if (MATCH(COLORARG2))
			{
				State = D3DTSS_COLORARG2;
				hr = D3DTEXTUREARG_FromString(str, &Value);
			}
			else if (MATCH(ALPHAOP))
			{
				State = D3DTSS_ALPHAOP;
				hr = D3DTEXTUREOP_FromString(str, &Value);
			}
			else if (MATCH(ALPHAARG0))
			{
				State = D3DTSS_ALPHAARG0;
				hr = D3DTEXTUREARG_FromString(str, &Value);
			}
			else if (MATCH(ALPHAARG1))
			{
				State = D3DTSS_ALPHAARG1;
				hr = D3DTEXTUREARG_FromString(str, &Value);
			}
			else if (MATCH(ALPHAARG2))
			{
				State = D3DTSS_ALPHAARG2;
				hr = D3DTEXTUREARG_FromString(str, &Value);
			}
			else if (MATCH(RESULTARG))
			{
				State = D3DTSS_RESULTARG;
				hr = D3DTEXTUREARG_FromString(str, &Value);
			}
			else if (MATCH(TEXTURETRANSFORMFLAGS))
			{
				State = D3DTSS_TEXTURETRANSFORMFLAGS;
				hr = D3DTEXTURETRANSFORMFLAGS_FromString(str, &Value);
			}
			else if (MATCH(ADDRESSU))
			{
				State = D3DTSS_ADDRESSU;
				hr = D3DTEXTUREADDRESS_FromString(str, &Value);
			}
			else if (MATCH(ADDRESSV))
			{
				State = D3DTSS_ADDRESSV;
				hr = D3DTEXTUREADDRESS_FromString(str, &Value);
			}
			else if (MATCH(ADDRESSW))
			{
				State = D3DTSS_ADDRESSW;
				hr = D3DTEXTUREADDRESS_FromString(str, &Value);
			}
			else if (MATCH(MAGFILTER))
			{
				State = D3DTSS_MAGFILTER;
				hr = D3DTEXF_FromString(str, &Value);
				// TODO: validation of value
			}
			else if (MATCH(MINFILTER))
			{
				State = D3DTSS_MINFILTER;
				hr = D3DTEXF_FromString(str, &Value);
				// TODO: validation of value
			}
			else if (MATCH(MIPFILTER))
			{
				State = D3DTSS_MIPFILTER;
				hr = D3DTEXF_FromString(str, &Value);
				// TODO: validation of value
			}
			else if (MATCH(MIPMAPLODBIAS))
			{
				State = D3DTSS_MIPMAPLODBIAS;
				hr = FLOAT_FromString(str, &Value);
			}
			else if (MATCH(MAXMIPLEVELS))
			{
				State = D3DTSS_MAXMIPLEVEL;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(MAXANISOTROPY))
			{
				State = D3DTSS_MAXANISOTROPY;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH(COLORKEYOP))
			{
				State = D3DTSS_COLORKEYOP;
				hr = D3DTEXTURECOLORKEYOP_FromString(str, &Value);
			}
			else if (MATCH(COLORSIGN))
			{
				State = D3DTSS_COLORSIGN;
				hr = D3DTSIGN_FromString(str, &Value);
			}
			else if (MATCH( ALPHAKILL ))
			{
				State = D3DTSS_ALPHAKILL;
				hr = D3DTEXTUREALPHAKILL_FromString(str, &Value);
			}
			else if (MATCH( BUMPENVMAT00 ))
			{
				State = D3DTSS_BUMPENVMAT00;
				hr = FLOAT_FromString(str, &Value);
			}
			else if (MATCH( BUMPENVMAT01 ))
			{
				State = D3DTSS_BUMPENVMAT01;
				hr = FLOAT_FromString(str, &Value);
			}
			else if (MATCH( BUMPENVMAT11 ))
			{
				State = D3DTSS_BUMPENVMAT11;
				hr = FLOAT_FromString(str, &Value);
			}
			else if (MATCH( BUMPENVMAT10 ))
			{
				State = D3DTSS_BUMPENVMAT10;
				hr = FLOAT_FromString(str, &Value);
			}
			else if (MATCH( BUMPENVLSCALE ))
			{
				State = D3DTSS_BUMPENVLSCALE;
				hr = FLOAT_FromString(str, &Value);
			}
			else if (MATCH( BUMPENVLOFFSET ))
			{
				State = D3DTSS_BUMPENVLOFFSET;
				hr = FLOAT_FromString(str, &Value);
			}
			else if (MATCH( TEXCOORDINDEX ))
			{
				State = D3DTSS_TEXCOORDINDEX;
				hr = DWORD_FromString(str, &Value);
			}
			else if (MATCH( D3DTSS_BORDERCOLOR ))
			{
				State = D3DTSS_BORDERCOLOR;
				hr = D3DCOLOR_FromString(str, &Value);
			}
			else if (MATCH( COLORKEYCOLOR ))
			{
				State = D3DTSS_COLORKEYCOLOR;
				hr = D3DCOLOR_FromString(str, &Value);
			}
			else
				return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);

			// If the value-parsing failed, print an error and exit.
			if (FAILED(hr))
				return UnexpectedAttributeToken(pwchLocalName, cchLocalName, pwchValue, cchValue, E_FAIL);
			
			// Add the texture stage state, value pair to the list.  The rTextureState
			// array is big enough to hold all the possible texture stage state values,
			// and on the Xbox, the enumeration is sequential, so we use the 
			// state as an index.
			rTextureState[State].State = State;
			rTextureState[State].Value = Value;
		}
	}
	if (Stage == -1)
	{
		fatalError(m_pLocator, L"<TextureState> missing required \"Stage\" attribute\n", E_FAIL);
		m_bErrorSuppress = true;
		return E_FAIL;
	}
			
	// Count number of active texture states
	UINT nTextureStateCount = 0;
	UINT i;
	for (i = 0; i < MAX_TEXTURE_STATE; i++)
	{
		if (rTextureState[i].State != -1)
			nTextureStateCount++;
	}
	
	// Copy texture state values to variably-sized array
	TextureStage *pTextureStage = &pPass->rTextureStage[Stage];
	pTextureStage->TextureStateCount = nTextureStateCount;
	pTextureStage->rTextureState = new TextureState [ nTextureStateCount ];
	if (pTextureStage->rTextureState == NULL)
	{
		fatalError(m_pLocator, L"Memory allocation failed for texture state array\n", E_FAIL);
		m_bErrorSuppress = true;
		return E_FAIL;
	}
	nTextureStateCount = 0;
	for (i = 0; i < MAX_TEXTURE_STATE; i++)
	{
		if (rTextureState[i].State != -1)
		{
			pTextureStage->rTextureState[nTextureStateCount] = rTextureState[i];
			nTextureStateCount++;
		}
	}

	// Set texture resource index
	pTextureStage->TextureResource = dwTextureResourceIndex;

	return S_OK;
}

HRESULT XBContent::EndTextureState()
{
	PopContext();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\frame.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: frame.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
#include "frame.h"

//////////////////////////////////////////////////////////////////////
// Set root of frame hierarchy and allocate matrix array
//
HRESULT Skeleton::SetRoot(Frame *pRoot)
{
	m_pRoot = pRoot;
	m_FrameCount = 0;
	if (m_rMatrix != NULL)
	{
		delete [] m_rMatrix;
		m_rMatrix = NULL;
	}
		
	// Count the number of frames
	Frame *rpFrameStack[FRAME_MAX_STACK];
	int iFrameStack = 1;	// depth of stack
	rpFrameStack[0] = pRoot;	// put root on top of stack
	while (iFrameStack)
	{
		// Pop the stack
		iFrameStack--;
		Frame *pFrame = rpFrameStack[iFrameStack];
		m_FrameCount++;

		// Push sibling
		if (pFrame->m_pNext != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rpFrameStack[iFrameStack] = pFrame->m_pNext;
			iFrameStack++;
		}
		
		// Push child
		if (pFrame->m_pChild != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rpFrameStack[iFrameStack] = pFrame->m_pChild;
			iFrameStack++;
		}
	}

	// Allocate the matrix array
	m_rMatrix = new FrameMatrix [ m_FrameCount ];
	if (m_rMatrix == NULL)
		return E_OUTOFMEMORY;
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Do depth-first traversal of frame hierarchy to compute the
// matrix palette.
//
// TODO: Not all of these transformations are actually used
// in the final result.  Do dependency analysis and avoid
// computing matrices that are not used.
//
HRESULT Skeleton::UpdateTransformations()
{
	// Iterate through frame hierarchy
	struct FrameStackElement {
		Frame *pFrame;
		int iMatrixParent;	// index into m_rMatrix
	} rFrameStack[FRAME_MAX_STACK];
	rFrameStack[0].pFrame = m_pRoot;
	rFrameStack[0].iMatrixParent = -1;
	int iMatrix = 0;	// index to current entry in m_rMatrix
	int iFrameStack = 1;	// depth of stack
	while (iFrameStack)
	{
		// Pop the stack
		iFrameStack--;
		Frame *pFrame = rFrameStack[iFrameStack].pFrame;
		int iMatrixParent = rFrameStack[iFrameStack].iMatrixParent;

		// Compute cumulative transformation
		if (iMatrixParent == -1)
			m_rMatrix[iMatrix] = pFrame->m_Matrix;	// set initial transformation
		else
			XGMatrixMultiply(&m_rMatrix[iMatrix], &pFrame->m_Matrix, &m_rMatrix[iMatrixParent]); // compute transformation from parent

		// Push sibling
		if (pFrame->m_pNext != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrame->m_pNext;
			rFrameStack[iFrameStack].iMatrixParent = iMatrixParent;	// use same parent as before
			iFrameStack++;
		}
		
		// Push child
		if (pFrame->m_pChild != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrame->m_pChild;
			rFrameStack[iFrameStack].iMatrixParent = iMatrix;	// use our matrix as child's parent matrix
			iFrameStack++;
		}

		iMatrix++;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\indexbuffer.cpp ===
//-----------------------------------------------------------------------------
// File: IndexBuffer.cpp
//
// Desc: Contains the IndexBuffer-specific logic for the bundler tool
//
// Hist: 2001.11.30 - New for December XDK Release
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "IndexBuffer.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CIndexBuffer()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CIndexBuffer::CIndexBuffer( CBundler* pBundler )
{
    m_pBundler = pBundler;
	m_IndexCount = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CIndexBuffer (destructor)
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CIndexBuffer::~CIndexBuffer()
{
}




//-----------------------------------------------------------------------------
// Name: AddIndex()
// Desc: Adds a single index to the index data
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::AddIndex( WORD Index )
{
    if (m_IndexCount >= MAX_INDEXBUFFER_COUNT)
    {
        m_pBundler->ErrorMsg( "Error: Index Buffer Overflow\n" );
        return E_FAIL;
    }
    m_rIndex[m_IndexCount++] = Index;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadIndicesFromFile
// Desc: Loads entire vertex data stream from file
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::LoadIndicesFromFile( CHAR* strFilename )
{
    // Open the file
    HANDLE hFile = CreateFileA( strFilename, 
                                GENERIC_READ, 
                                FILE_SHARE_READ, 
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Make sure we can fit the whole thing in memory.
    // TODO: Dynamically allocate memory for index buffers
    DWORD dwSize = GetFileSize( hFile, NULL );
    if( dwSize > sizeof( m_rIndex ) )
    {
        m_pBundler->ErrorMsg( "Error: Index data file too large.\n" );
        return E_FAIL;
    }

    // Read the data
    DWORD dwRead;
    ReadFile( hFile, m_rIndex, dwSize, &dwRead, NULL );
    if( dwRead != dwSize )
        return E_FAIL;

    CloseHandle( hFile );

    m_IndexCount = dwRead / sizeof( WORD );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CIndexBuffer::SaveToBundle( DWORD * pcbHeader, DWORD * pcbData )
{
    if (m_IndexCount == 0)
    {
        m_pBundler->ErrorMsg( "Error: No indices specified\n" );
        return E_FAIL;
    }

	// Compute size of header + XD3DIndexBuffer + alignment fill + indices
	struct UserData {
		DWORD dwType;				// USER_DATA_FLAG | XD3DCOMMON_TYPE_INDEXBUFFER
		DWORD dwSize;				// size of indexbuffer + alignment fill + indices
	} IBUserData;
	DWORD cbHeaderNew = m_pBundler->m_cbHeader + sizeof(UserData) + sizeof(XD3DIndexBuffer);
	DWORD dwAlign = XD3DINDEXBUFFER_ALIGNMENT; 
	DWORD cbFill = 0;
	if (cbHeaderNew % dwAlign)
		cbFill = dwAlign - ( cbHeaderNew % dwAlign );
	
	IBUserData.dwType = USER_DATA_FLAG | XD3DCOMMON_TYPE_INDEXBUFFER;
	IBUserData.dwSize = sizeof(XD3DIndexBuffer) + cbFill + sizeof(WORD) * m_IndexCount;	// size not including the UserData

	// Write header
	if (FAILED(m_pBundler->WriteHeader( &IBUserData, sizeof(UserData))))
		return E_FAIL;
	m_pBundler->m_cbHeader += sizeof(UserData);	// TODO: this should be done in WriteHeader

	// Write XD3DIndexBuffer
    XD3DIndexBuffer xd3dIndexBuffer;
    xd3dIndexBuffer.Common =  XD3DCOMMON_TYPE_INDEXBUFFER |  // Type   
                    1;                               // Initial Refcount
	// Offset from start of XD3DIndexBuffer structure to index data. Needs to be patched when loaded.
    xd3dIndexBuffer.Data   = sizeof(XD3DIndexBuffer) + cbFill;
    xd3dIndexBuffer.Lock   = 0;                          // Must be zero
	
    // Write the resource header
    if( FAILED( m_pBundler->WriteHeader( &xd3dIndexBuffer, sizeof( xd3dIndexBuffer ) ) ) )
        return E_FAIL;
	m_pBundler->m_cbHeader += sizeof(xd3dIndexBuffer);	// TODO: this should be done in WriteHeader

	// Write alignment filler
	if (cbFill)
	{
		BYTE Fill = 0xAA;
		for (DWORD iFill = 0; iFill < cbFill; iFill++)
		{
			if (FAILED(m_pBundler->WriteHeader( &Fill, 1 )))
				return E_FAIL;
			m_pBundler->m_cbHeader += 1;	// TODO: this should be done in WriteHeader
		}
	}

	// Write indices
	if (FAILED( m_pBundler->WriteHeader( m_rIndex, sizeof(WORD) * m_IndexCount ) ) )
		return E_FAIL;
	m_pBundler->m_cbHeader += sizeof(WORD) * m_IndexCount;	// TODO: this should be done in WriteHeader

	// Set return counts
    *pcbHeader = sizeof(UserData) + IBUserData.dwSize;
	*pcbData = 0;	// no video data
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\CVertexShader.h ===
//-----------------------------------------------------------------------------
// File: CVertexShader.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the vertexshader-related functionality of the bundler tool
//
// Hist: 2001.09.26 - New for November XDK release
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CVERTEXSHADER_H
#define CVERTEXSHADER_H

#include "vb.h"

class CBundler;

#define VERTEXSHADER_MAX_DECLARATION_COUNT	1000

//-----------------------------------------------------------------------------
// Name: class CVertexShader
// Desc: Handles VertexShader-specific processing
//-----------------------------------------------------------------------------
class CVertexShader
{
public:
    CVertexShader( CBundler * pBundler );
    ~CVertexShader();

    HRESULT SaveToBundle( DWORD *pcbHeader, DWORD *pcbData );

	// Build up a declaration
	HRESULT SetStream(UINT iStream);
	HRESULT SetVertexRegisterFormat(UINT iVertexRegister, DWORD VertexFormat);
	HRESULT SkipBytes(UINT Count);
	HRESULT SetConstant(INT iConstantRegister, CONST void *pConstantData, DWORD ConstantCount);
	
	// parse declaration into streams and constants
//	HRESULT SetDeclaration(const DWORD *pDeclaration);

	// set vertex shader microcode output from XGAssembleShader
	HRESULT SetFunction(CONST void *pFunction, UINT cbFunctionSize);

	// set resource references
	HRESULT SetVertexShaderReference(DWORD dwVertexShaderResourceIndex);
	HRESULT SetStreamVertexBufferReference(UINT iStream, DWORD dwVertexBufferResourceIndex, DWORD Stride, DWORD Offset);
	
    CBundler * m_pBundler;
#define VERTEXSHADER_IDENTIFIER_MAX_LENGTH 128
	CHAR m_Identifier[VERTEXSHADER_IDENTIFIER_MAX_LENGTH];
	DWORD m_dwDeclarationCount;
	DWORD m_rdwDeclaration[VERTEXSHADER_MAX_DECLARATION_COUNT];	// Does not include vertex constants
	UINT m_cbFunctionSize;
	BYTE *m_pFunction;
	BOOL  m_rbConstant[XD3DVS_CONSTREG_COUNT];	// is this register active?
	FLOAT m_rfConstant[XD3DVS_CONSTREG_COUNT][4];
	DWORD m_dwVertexShaderReference;			// index of vertex shader resource for initial values
	struct StreamInput {	// like D3DSTREAM_INPUT, but with vertex buffer reference instead of a pointer
		DWORD VertexBufferReference;
		DWORD Stride;
		DWORD Offset;
	} m_rStreamInput[XD3DVS_STREAMS_MAX];	// mapping of vertex buffer resources to streams
	
private:
	HRESULT AddConstantsToDeclaration();	// look through active constants in m_rbConstant and add to declaration
	HRESULT SetStridesFromDeclaration();	// parse declaration to set rStreamInput strides
};


#endif // CVERTEXSHADER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\indexbuffer.h ===
//-----------------------------------------------------------------------------
// File: IndexBuffer.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the indexbuffer-related functionality of the bundler tool
//
// Hist: 2001.11.30 - New for December XDK release
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef INDEXBUFFER_H
#define INDEXBUFFER_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>
#include "xd3d.h"

class CBundler;

#define MAX_INDEXBUFFER_COUNT 65536

//-----------------------------------------------------------------------------
// Name: class CIndexBuffer
// Desc: Handles IndexBuffer-specific processing
//-----------------------------------------------------------------------------
class CIndexBuffer
{
public:
    CIndexBuffer( CBundler * pBundler );
    ~CIndexBuffer();

    HRESULT SaveToBundle( DWORD *pcbHeader, DWORD *pcbData ); // indices are saved after the header
    HRESULT AddIndex( WORD Index );
    HRESULT LoadIndicesFromFile( CHAR* strFilename );
	
    DWORD m_IndexCount;
	WORD m_rIndex[MAX_INDEXBUFFER_COUNT];

private:
    CBundler * m_pBundler;
};


#endif // INDEXBUFFER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CPPSaxSample.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\LoadImage.cpp ===
//-----------------------------------------------------------------------------
// File: LoadImage.cpp
//
// Desc: Loads image files.
//
// Hist: 2001.04.13 - New for May XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <d3dx8.h>
#include "LoadImage.h"
#include "cd3dxblt.h"



//-----------------------------------------------------------------------------
// Name: CImage()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CImage::CImage()
{
    m_Format         = D3DFMT_UNKNOWN;
    m_pData          = NULL;
    m_pPalette       = NULL;
    m_bDeleteData    = FALSE;
    m_bDeletePalette = FALSE;
}




//-----------------------------------------------------------------------------
// Name: CImage()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CImage::CImage( DWORD dwWidth, DWORD dwHeight, D3DFORMAT format )
{
    m_Format            = format;
    m_Width             = dwWidth;
    m_Height            = dwHeight;

    m_Rect.left         = 0;
    m_Rect.top          = 0;
    m_Rect.right        = dwWidth;
    m_Rect.bottom       = dwHeight;

    // TODO: This needs to get straightened out
    m_Pitch             = m_Width * sizeof( DWORD );
    m_pData             = new BYTE[ m_Pitch * m_Height ];
    m_bDeleteData       = TRUE;
    m_pPalette          = NULL;
    m_bDeletePalette    = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CImage()
// Desc: Frees resources held by the object
//-----------------------------------------------------------------------------
CImage::~CImage()
{
    if( m_pData && m_bDeleteData )
        delete[] m_pData;

    if( m_pPalette && m_bDeletePalette )
        delete[] m_pPalette;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Attempts to load the given data as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( const VOID* pData, DWORD cbData )
{
    HRESULT hr;

    // Try all known image loading subroutines
    for( int i = 0; i < 4; i++ )
    {
        switch(i)
        {
            case 0: hr = LoadBMP( pData, cbData ); break;
            case 1: hr = LoadPPM( pData, cbData ); break;
            case 2: hr = LoadTGA( pData, cbData ); break;
            case 3: hr = LoadDIB( pData, cbData ); break;
        }

        if( SUCCEEDED(hr) )
            break;

        if( m_pData && m_bDeleteData )
            delete[] m_pData;

        if( m_pPalette && m_bDeletePalette )
            delete[] m_pPalette;

        m_pData          = NULL;
        m_pPalette       = NULL;
        m_bDeleteData    = FALSE;
        m_bDeletePalette = FALSE;
    }

    if( 4 == i )
    {
        DPF(0, "Unsupported file format");
        return D3DXERR_INVALIDDATA;
    }

    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = m_Width;
    m_Rect.bottom = m_Height;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Depalettize()
// Desc: Depalettize palettized images
//-----------------------------------------------------------------------------
HRESULT CImage::Depalettize()
{
    if( NULL == m_pPalette )
        return S_OK;

    BYTE*  pSrcData = (BYTE*)m_pData;
    DWORD* pDstData = new DWORD[m_Width*m_Height];

    BYTE*  pOldData = (BYTE*)pSrcData;
    BYTE*  pNewData = (BYTE*)pDstData;

    // Loop through all texels and get 32-bit color from the 8-bit palette index
    for( DWORD y=0; y<m_Height; y++ )
    {
        for( DWORD x=0; x<m_Width; x++ )
        {
            BYTE  index = *pSrcData++;

            DWORD red   = m_pPalette[index].peRed;
            DWORD green = m_pPalette[index].peGreen;
            DWORD blue  = m_pPalette[index].peBlue;
            DWORD alpha = m_pPalette[index].peFlags;

            *pDstData++ = (alpha<<24) | (red<<16) | (green<<8) | (blue<<0);
        }
    }

    // Delete the old palette
    if( m_bDeletePalette )
        delete[] m_pPalette;
    m_pPalette       = NULL;
    m_bDeletePalette = FALSE;

    // Delete the old data, and assign the new data
    if( m_bDeleteData )
        delete[] m_pData;
    m_pData          = pNewData;
    m_bDeleteData    = TRUE;

    // The format is now A8R8G8B8
    m_Format = D3DFMT_A8R8G8B8;
    m_Pitch  = m_Width * sizeof(DWORD);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Reads the data from the file and tries to load it as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( CHAR* strFilename )
{
    HANDLE hFile = CreateFileA( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory
    DWORD dwFileSize = GetFileSize( hFile, NULL );
    VOID* pFileData  = malloc( dwFileSize );

    // Read it the file
    DWORD dwRead;
    ReadFile( hFile, (VOID*)pFileData, dwFileSize, &dwRead, NULL );

    HRESULT hr = Load( pFileData, dwFileSize );

    // Free stuff
    CloseHandle( hFile );
    free( pFileData );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: LoadBMP()
// Desc: Attempts to load the given data as a BMP
//-----------------------------------------------------------------------------
HRESULT CImage::LoadBMP( const VOID* pvData, DWORD cbData )
{
    // Examine header
    if(cbData < sizeof(BITMAPFILEHEADER))
        return E_FAIL;

    BITMAPFILEHEADER *pFH = (BITMAPFILEHEADER *) pvData;

    if(pFH->bfType != (('B') | ('M' << 8)) || pFH->bfSize > cbData)
        return E_FAIL;

    return LoadDIB((BYTE *) pvData + sizeof(BITMAPFILEHEADER), cbData - sizeof(BITMAPFILEHEADER));
}




//-----------------------------------------------------------------------------
// Name: LoadDIB()
// Desc: Attempts to load the given data as a DIB
//-----------------------------------------------------------------------------
HRESULT CImage::LoadDIB( const VOID* pvData, DWORD cbData )
{
    UNALIGNED BITMAPINFOHEADER *pIH;
    DWORD     dwWidth, dwHeight, dwOffset, dwClrUsed;

    if(cbData < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    pIH = (BITMAPINFOHEADER *) pvData;

    if(pIH->biSize < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    dwWidth   = (DWORD) (pIH->biWidth);
    dwHeight  = (DWORD) (pIH->biHeight > 0 ? pIH->biHeight : -pIH->biHeight);
    dwClrUsed = (DWORD) (pIH->biClrUsed);

    if((pIH->biBitCount <= 8) && (0 == dwClrUsed))
        dwClrUsed = (DWORD) (1 << pIH->biBitCount);

    dwOffset  = (DWORD) pIH->biSize + dwClrUsed * sizeof(DWORD);

    if(dwOffset > (DWORD) cbData)
        return E_FAIL;

    if(pIH->biPlanes != 1)
        return E_FAIL;


    // Only RGB and BITFIELD bitmaps can be inverted
    if(pIH->biHeight < 0 && pIH->biCompression != BI_RGB && pIH->biCompression != BI_BITFIELDS)
        return E_FAIL;


    // Compute format
    DWORD dwB, dwG, dwR, dwA;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pIH->biCompression)
    {
        case BI_RGB:
        case BI_RLE4:
        case BI_RLE8:

            switch(pIH->biBitCount)
            {
                case 1:
                case 4:
                case 8:
                    Format = D3DFMT_P8;
                    break;

                case 16:
                    Format = D3DFMT_X1R5G5B5;
                    break;

                case 24:
#if 0
                    Format = D3DFMT_R8G8B8;
                    break;
#endif
                case 32:
                    Format = D3DFMT_X8R8G8B8;
                    break;

                default:
                    return E_FAIL;
            }
            break;

        case BI_BITFIELDS:
            if(pIH->biSize < sizeof(BITMAPV4HEADER))
                return E_FAIL;

            dwB = ((BITMAPV4HEADER *) pIH)->bV4BlueMask;
            dwG = ((BITMAPV4HEADER *) pIH)->bV4GreenMask;
            dwR = ((BITMAPV4HEADER *) pIH)->bV4RedMask;
            dwA = ((BITMAPV4HEADER *) pIH)->bV4AlphaMask;

            switch(pIH->biBitCount)
            {
                case 16:
                    if(dwB == 0x00ff && dwG == 0x00ff && dwR == 0x00ff && dwA == 0xff00)
                        Format = D3DFMT_A8L8;

                    else if(dwB == 0x001f && dwG == 0x07e0 && dwR == 0xf800 && dwA == 0x0000)
                        Format = D3DFMT_R5G6B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x0000)
                        Format = D3DFMT_X1R5G5B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x8000)
                        Format = D3DFMT_A1R5G5B5;

                    else if(dwB == 0x000f && dwG == 0x00f0 && dwR == 0x0f00 && dwA == 0xf000)
                        Format = D3DFMT_A4R4G4B4;
        #if 0
                    else if(dwB == 0x0003 && dwG == 0x001c && dwR == 0x00e0 && dwA == 0xff00)
                        Format = D3DFMT_A8R3G3B2;
        #endif
                    break;

                case 24:
                    if(dwB == 0x0000ff && dwG == 0x00ff00 && dwR == 0xff0000 && dwA == 0x000000)
        #if 0                
                        Format = D3DFMT_R8G8B8;
        #else
                        Format = D3DFMT_X8R8G8B8;
        #endif
                    break;

                case 32:
                    if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0x00000000)
                        Format = D3DFMT_X8R8G8B8;

                    else if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0xff000000)
                        Format = D3DFMT_A8R8G8B8;

                    break;
            }

            break;

        default:
            DPF(0, "LoadBMP: JPEG compression not supported");
            return E_NOTIMPL;
    }


    if(D3DFMT_UNKNOWN == Format)
    {
        return E_FAIL;
    }


    if(D3DFMT_P8 == Format)
    {
        DWORD dwClrUsed = pIH->biClrUsed;

        if(!dwClrUsed)
            dwClrUsed = 1 << pIH->biBitCount;

        m_bDeletePalette = TRUE;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        DWORD dw;
        RGBQUAD* prgb = (RGBQUAD*) (((BYTE *) pIH) + pIH->biSize);

        for(dw = 0; dw < dwClrUsed; dw++, prgb++)
        {
            m_pPalette[dw].peRed   = prgb->rgbRed;
            m_pPalette[dw].peGreen = prgb->rgbGreen;
            m_pPalette[dw].peBlue  = prgb->rgbBlue;
            m_pPalette[dw].peFlags = 0xff;
        }

        for(dw = dwClrUsed; dw < 256; dw++)
        {
            m_pPalette[dw].peRed   = 0xff;
            m_pPalette[dw].peGreen = 0xff;
            m_pPalette[dw].peBlue  = 0xff;
            m_pPalette[dw].peFlags = 0xff;
        }
    }

    DWORD dwWidthBytes;
    DWORD dwSrcInc, dwDstInc;

    switch(pIH->biBitCount)
    {
        case 1:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 3) + 3) & ~3;
            break;

        case 4:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 1) + 3) & ~3;
            break;

        default:
            dwWidthBytes = (dwWidth * (pIH->biBitCount >> 3));
            dwSrcInc = (dwWidthBytes + 3) & ~3;
            break;
    }

    m_Format  = Format;
    m_Pitch   = (DWORD)((dwWidthBytes + 3) & ~3);
    m_Width   = (DWORD)dwWidth;
    m_Height  = (DWORD)dwHeight;
#if 1
    if (pIH->biBitCount == 24 && Format == D3DFMT_X8R8G8B8)
    {
        UNALIGNED BYTE* pbSrc;
        DWORD*          pdwDst;
        int             nStrideDst;
        UINT            i, j;

        dwWidthBytes = (dwWidth * (32 >> 3));
        m_Pitch      = (DWORD)((dwWidthBytes + 3) & ~3);

        m_pData = new BYTE[dwHeight * m_Pitch];
        if (!m_pData)
		{
			m_bDeleteData = FALSE;
            return E_OUTOFMEMORY;
		}
        m_bDeleteData = TRUE;

        pbSrc = ((BYTE*)pvData) + dwOffset;
        if (pIH->biHeight < 0)
        {
            pdwDst = (DWORD*)m_pData;
            nStrideDst = m_Pitch >> 2;
        }
        else
        {
            pdwDst = (DWORD*)((BYTE*)m_pData + m_Pitch * (dwHeight - 1));
            nStrideDst = -(int)(m_Pitch >> 2);
        }

        for (i = 0; i < dwHeight; i++)
        {
            for (j = 0; j < dwWidth; j++)
            {
                pdwDst[j] = pbSrc[2] << 16 | pbSrc[1] << 8 | *pbSrc;
                pbSrc += 3;
            }

            pdwDst += nStrideDst;
        }

        return S_OK;
    }
#endif
    if(pIH->biHeight < 0 && pIH->biBitCount >= 8)
    {
        // The data is in the correct format already in the file.
        m_pData  = new BYTE[dwHeight * m_Pitch];
		if (!m_pData)
		{
			m_bDeleteData = FALSE;
			return E_OUTOFMEMORY;
		}
        memcpy( m_pData, ((BYTE *)pvData) + dwOffset, dwHeight * m_Pitch );
        m_bDeleteData = TRUE;
        return S_OK;
    }

    // Data in file needs to be converted.. so lets allocate the destination
    // buffer which will contain the image..

    m_pData  = new BYTE[dwHeight * m_Pitch];
    if(!m_pData)
	{
		m_bDeleteData = FALSE;
        return E_OUTOFMEMORY;
	}
    m_bDeleteData = TRUE;

    UNALIGNED BYTE *pbSrc, *pbDest, *pbDestMin, *pbDestLim, *pbDestLine;

    pbSrc = ((BYTE *) pvData) + dwOffset;

    if(pIH->biHeight < 0)
    {
        dwDstInc = m_Pitch;
        pbDest = (BYTE *) m_pData;
    }
    else
    {
        dwDstInc = 0 - (DWORD)m_Pitch;
        pbDest = (BYTE *) m_pData + (dwHeight - 1) * m_Pitch;
    }

    pbDestLine = pbDest;
    pbDestMin = (BYTE *) m_pData;
    pbDestLim = (BYTE *) m_pData + dwHeight * m_Pitch;



    if(BI_RLE4 == pIH->biCompression)
    {
        // RLE4. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        for(int i = 0; i < pbSrc[1]; i++)
                            pbDest[i] = (i & 1) ?  (pbSrc[2 + (i >> 1)] & 0x0f) : (pbSrc[2 + (i >> 1)] >> 4);

                        pbDest += pbSrc[1];
                        pbSrc += ((pbSrc[1] >> 1) + 1) & ~1;
                        break;
                }
            }
            else
            {
                for(int i = 0; i < pbSrc[0]; i++)
                    pbDest[i] = (i & 1) ? (pbSrc[1] & 0x0f) : (pbSrc[1] >> 4);

                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }

    if(pIH->biCompression == BI_RLE8)
    {
        // RLE8. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        memcpy(pbDest, pbSrc + 2, pbSrc[1]);
                        pbDest += pbSrc[1];
                        pbSrc += (pbSrc[1] + 1) & ~1;
                        break;
                }
            }
            else
            {
                memset(pbDest, pbSrc[1], pbSrc[0]);
                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }


    if(1 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (pbSrc[i >> 3] >> (7 - (i & 7))) & 1;

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }

    if(4 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (i & 1) ? pbSrc[i >> 1] & 0x0f : (pbSrc[i >> 1] >> 4);

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }


    while(pbDest >= pbDestMin && pbDest < pbDestLim)
    {
        memcpy(pbDest, pbSrc, dwWidthBytes);

        pbDest += dwDstInc;
        pbSrc  += dwSrcInc;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: struct TGAHEADER
// Desc: Defines the header format for TGA files
//-----------------------------------------------------------------------------
#pragma pack(1)
struct TGAHEADER
{
    BYTE IDLength;
    BYTE ColormapType;
    BYTE ImageType;

    WORD wColorMapIndex;
    WORD wColorMapLength;
    BYTE bColorMapBits;

    WORD wXOrigin;
    WORD wYOrigin;
    WORD wWidth;
    WORD wHeight;
    BYTE PixelDepth;
    BYTE ImageDescriptor;
};
#pragma pack()




//-----------------------------------------------------------------------------
// Name: LoadTGA()
// Desc: Attempts to load the given data as a TGA file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadTGA( const VOID* pvData, DWORD cbData )
{
    // Validate header.  TGA files don't seem to have any sort of magic number
    // to identify them.  Therefore, we will proceed as if this is a real TGA
    // file, until we see something we don't understand.

    BYTE*      pbData = (BYTE*)pvData;
    TGAHEADER* pFH    = (TGAHEADER*)pbData;

    if( cbData < sizeof(TGAHEADER) )
        return E_FAIL;

    if( pFH->ColormapType & ~0x01 )
        return E_FAIL;

    if( pFH->ImageType & ~0x0b )
        return E_FAIL;

    if( !pFH->wWidth || !pFH->wHeight )
        return E_FAIL;



    // Colormap size and format
    UINT uColorMapBytes = ((UINT) pFH->bColorMapBits + 7) >> 3;
    D3DFORMAT ColorMapFormat = D3DFMT_UNKNOWN;

    if(pFH->ColormapType)
    {
        switch(pFH->bColorMapBits)
        {
            case 15: ColorMapFormat = D3DFMT_X1R5G5B5; break;
            case 16: ColorMapFormat = D3DFMT_A1R5G5B5; break;
            case 24: ColorMapFormat = D3DFMT_X8R8G8B8; break;
            case 32: ColorMapFormat = D3DFMT_A8R8G8B8; break;
            default: return E_FAIL;
        }
    }


    // Image size and format
    UINT uBytes = ((UINT) pFH->PixelDepth + 7) >> 3;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pFH->ImageType & 0x03)
    {
        case 1:
            if(!pFH->ColormapType)
                return E_FAIL;

            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_P8; break;
                default: return E_FAIL;
            }
            break;

        case 2:
            switch(pFH->PixelDepth)
            {
                case 15: Format = D3DFMT_X1R5G5B5; break;
                case 16: Format = D3DFMT_A1R5G5B5; break;
                case 24: Format = D3DFMT_X8R8G8B8;   break;
                case 32: Format = D3DFMT_A8R8G8B8; break;
                default: return E_FAIL;
            }
            break;

        case 3:
            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_L8; break;
                default: return E_FAIL;
            }
            break;

        default:
            return E_FAIL;
    }

    BOOL bRLE         = pFH->ImageType & 0x08;
    BOOL bTopToBottom = 0x20 == (pFH->ImageDescriptor & 0x20);
    BOOL bLeftToRight = 0x10 != (pFH->ImageDescriptor & 0x10);

    pbData += sizeof(TGAHEADER);
    cbData -= sizeof(TGAHEADER);


    // Skip ID
    if(cbData < pFH->IDLength)
        return E_FAIL;

    pbData += pFH->IDLength;
    cbData -= pFH->IDLength;


    // Color map
    UINT cbColorMap = (UINT) pFH->wColorMapLength * uColorMapBytes;

    if(cbData < cbColorMap)
        return E_FAIL;

    if(D3DFMT_P8 == Format)
    {
        if(pFH->wColorMapIndex + pFH->wColorMapLength > 256)
            return E_FAIL;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        m_bDeletePalette = TRUE;
        memset(m_pPalette, 0xff, 256 * sizeof(PALETTEENTRY));

        BYTE *pb = pbData;
        PALETTEENTRY *pColor = m_pPalette + pFH->wColorMapIndex;
        PALETTEENTRY *pColorLim = pColor + pFH->wColorMapLength;

        while(pColor < pColorLim)
        {
            UINT u, uA, uR, uG, uB;

            switch(ColorMapFormat)
            {
                case D3DFMT_X1R5G5B5:
                    u = *((WORD *) pb);

                    uA = 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

                case D3DFMT_A1R5G5B5:
                    u = *((WORD *) pb);

                    uA = (u >> 15) * 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

                case D3DFMT_X8R8G8B8:
                    uA = 0xff;
                    uR = pb[2];
                    uG = pb[1];
                    uB = pb[0];

                    pb += 3;
                    break;

                case D3DFMT_A8R8G8B8:
                    u = *((DWORD *) pb);

                    uA = (u >> 24) & 0xff;
                    uR = (u >> 16) & 0xff;
                    uG = (u >>  8) & 0xff;
                    uB = (u >>  0) & 0xff;

                    pb += 4;
                    break;
            }
            
            pColor->peRed   = (BYTE) uR;
            pColor->peGreen = (BYTE) uG;
            pColor->peBlue  = (BYTE) uB;
            pColor->peFlags = (BYTE) uA;
        
            pColor++;
        }
    }

    pbData += cbColorMap;
    cbData -= cbColorMap;


    // Image data
    UINT cbImage;
    if(Format == D3DFMT_X8R8G8B8)
        cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * (uBytes+1);
    else
        cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * uBytes;

    m_Format  = Format;
    m_pData   = pbData;
    m_Pitch   = (UINT) pFH->wWidth * uBytes;

    m_Width  = pFH->wWidth;
    m_Height = pFH->wHeight;


    if(!bRLE && bTopToBottom && bLeftToRight )
    {
        // Data is already in a format usable to D3D.. no conversion is necessary
        
        m_pData = new BYTE[cbImage];
		if (!m_pData)
		{
			m_bDeleteData = FALSE;
			return E_OUTOFMEMORY;
		}
        memcpy( m_pData, pbData, min(cbData, cbImage) );
        m_bDeleteData = TRUE;

        pbData += cbImage;
        cbData -= cbImage;
    }
    else
    {
        // Image data is compressed, or does not have origin at top-left
        m_pData = new BYTE[cbImage];
        if(!m_pData)
		{
			m_bDeleteData = FALSE;
            return E_OUTOFMEMORY;
		}
        m_bDeleteData = TRUE;


        BYTE *pbDestY = bTopToBottom ? (BYTE *) m_pData : ((BYTE *) m_pData + (pFH->wHeight - 1) * m_Pitch);

        for(UINT uY = 0; uY < pFH->wHeight; uY++)
        {
            BYTE *pbDestX = bLeftToRight ? pbDestY : (pbDestY + m_Pitch - uBytes);

            for(UINT uX = 0; uX < pFH->wWidth; )
            {
                BOOL bRunLength;
                UINT uCount;

                if(bRLE)
                {
                    if(cbData < 1)
                        return E_FAIL;

                    bRunLength = *pbData & 0x80;
                    uCount = (*pbData & 0x7f) + 1;

                    pbData++;
                    cbData--;
                }
                else
                {
                    bRunLength = FALSE;
                    uCount = pFH->wWidth;
                }

                uX += uCount;

                while(uCount--)
                {
                    if(cbData < uBytes)
                        return E_FAIL;

                    memcpy(pbDestX, pbData, uBytes);

                    if(!bRunLength)
                    {
                        pbData += uBytes;
                        cbData -= uBytes;
                    }

                    pbDestX = bLeftToRight ? (pbDestX + uBytes) : (pbDestX - uBytes);
                }

                if(bRunLength)
                {
                    pbData += uBytes;
                    cbData -= uBytes;
                }
            }

            pbDestY = bTopToBottom ? (pbDestY + m_Pitch) : (pbDestY - m_Pitch);
        }
    }

    if(Format == D3DFMT_X8R8G8B8)
    {
        //convert from 24-bit R8G8B8 to 32-bit X8R8G8B8
        // do the conversion in-place
        BYTE *pSrc, *pDst;
        pSrc = (BYTE *)m_pData + (m_Height)*(m_Width*uBytes) - uBytes;
        pDst = (BYTE *)m_pData + (m_Height)*(m_Width*(uBytes+1)) - (uBytes+1);
            
        while(pSrc >= m_pData)
        {
            *(pDst+3) = 0xff;       //A
            *(pDst+2) = *(pSrc+2);  //R
            *(pDst+1) = *(pSrc+1);  //G
            *(pDst+0) = *pSrc;      //B
            pSrc -= 3;
            pDst -= 4;
        }
        m_Pitch   = m_Width * (uBytes+1);
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Anonymous enum
// Desc: Enumerations used for loading PPM files
//-----------------------------------------------------------------------------
enum
{
    PPM_WIDTH, PPM_HEIGHT, PPM_MAX, PPM_DATA_R, PPM_DATA_G, PPM_DATA_B
};




//-----------------------------------------------------------------------------
// Name: LoadPPM()
// Desc: Attempts to load the given data as a PPM file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadPPM( const VOID* pvData, DWORD cbData )
{
    BYTE *pbData = (BYTE *)pvData;

    // Check header
    BOOL bAscii;

    if(cbData < 2)
        return E_FAIL;

    if('P' == pbData[0] && '3' == pbData[1])
        bAscii = TRUE;
    else if('P' == pbData[0] && '6' == pbData[1])
        bAscii = FALSE;
    else
        return E_FAIL;

    pbData += 2;
    cbData -= 2;

    // Image data
    UINT uMode   = PPM_WIDTH;
    UINT uWidth  = 0;
    UINT uHeight = 0;
    UINT uMax    = 255;

    DWORD *pdw, *pdwLim;

    while(cbData)
    {
        if(!bAscii && PPM_DATA_R == uMode)
        {
            // Binary image data
            if(uMax > 255)
                return E_FAIL;

            if(cbData > 1 && '\r' == *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;

            while(cbData && pdw < pdwLim)
            {
                *pdw++ = ((255 * pbData[0] / uMax) << 16) |
                         ((255 * pbData[1] / uMax) <<  8) |
                         ((255 * pbData[2] / uMax) <<  0) | 0xff000000;

                pbData += 3;
                cbData -= 3;
            }

            if(pdw != pdwLim)
                return E_FAIL;

            return S_OK;
        }
        if(isspace(*pbData))
        {
            // Whitespace
            pbData++;
            cbData--;
        }
        else if('#' == *pbData)
        {
            // Comment
            while(cbData && '\n' != *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;
        }
        else
        {
            // Number
            UINT u = 0;

            while(cbData && !isspace(*pbData))
            {
                if(!isdigit(*pbData))
                    return E_FAIL;

                u = u * 10 + (*pbData - '0');

                pbData++;
                cbData--;
            }

            switch(uMode)
            {
                case PPM_WIDTH:
                    uWidth = u;

                    if(0 == uWidth)
                        return E_FAIL;

                    break;

                case PPM_HEIGHT:
                    uHeight = u;

                    if(0 == uHeight)
                        return E_FAIL;

                    m_pData = new BYTE[uWidth * uHeight * sizeof(DWORD)];
                    if (!m_pData)
					{
						m_bDeleteData = FALSE;
                        return E_OUTOFMEMORY;
					}
                    m_bDeleteData = TRUE;

                    pdw = (DWORD *) m_pData;
                    pdwLim = pdw + uWidth * uHeight;

                    m_Format = D3DFMT_X8R8G8B8;
                    m_Pitch  = uWidth * sizeof(DWORD);

                    m_Width  = uWidth;
                    m_Height = uHeight;
                    break;

                case PPM_MAX:
                    uMax = u;

                    if(0 == uMax)
                        return E_FAIL;

                    break;

                case PPM_DATA_R:
                    if(pdw >= pdwLim)
                        return E_FAIL;

                    *pdw  = ((u * 255 / uMax) << 16) | 0xff000000;
                    break;

                case PPM_DATA_G:
                    *pdw |= ((u * 255 / uMax) <<  8);
                    break;

                case PPM_DATA_B:
                    *pdw |= ((u * 255 / uMax) <<  0);

                    if(++pdw == pdwLim)
                        return S_OK;

                    uMode = PPM_DATA_R - 1;
                    break;
            }

            uMode++;
        }
    }

    return E_FAIL;
}




BOOL IsUvl( D3DFORMAT format )
{
    switch( format )
    {
//    case D3DFMT_LIN_V16U16:
//    case D3DFMT_LIN_V8U8:
//    case D3DFMT_LIN_L6V5U5:
//    case D3DFMT_LIN_X8L8V8U8:
//    case D3DFMT_LIN_Q8W8V8U8:
    case D3DFMT_V16U16:
    case D3DFMT_V8U8:
    case D3DFMT_L6V5U5:
    case D3DFMT_X8L8V8U8:
    case D3DFMT_Q8W8V8U8:
        return TRUE;
    default:
        return FALSE;
    }
}


HRESULT LoadImageFromImage( CImage* pDestImage, CImage* pSrcImage, DWORD dwFilter, D3DCOLOR ColorKey )
{
    RECT        srcRect;
    RECT        destRect;
    DWORD       dwRealFilter = dwFilter;
    CXD3DXBlt   Blt;
    HRESULT     hr;

    srcRect.left    = 0;
    srcRect.top     = 0;
    srcRect.right   = pSrcImage->m_Width;
    srcRect.bottom  = pSrcImage->m_Height;

    destRect.left   = 0;
    destRect.top    = 0;
    destRect.right  = pDestImage->m_Width;
    destRect.bottom = pDestImage->m_Height;

    if(D3DX_DEFAULT == dwRealFilter)
    {
        if(IsUvl(pSrcImage->m_Format))
            dwRealFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwRealFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }
    
    // Blt using specified filter
    D3DX_BLT DestBlt, SrcBlt;

    DestBlt.pData            = pDestImage->m_pData;
    DestBlt.RowPitch         = pDestImage->m_Pitch;
    DestBlt.SlicePitch       = 0;
    DestBlt.Format           = pDestImage->m_Format;
    DestBlt.ColorKey         = 0;
    DestBlt.pPalette         = pDestImage->m_pPalette;

    DestBlt.Region.Left      = 0;
    DestBlt.Region.Right     = (UINT) pDestImage->m_Width;
    DestBlt.Region.Top       = 0;
    DestBlt.Region.Bottom    = (UINT) pDestImage->m_Height;
    DestBlt.Region.Front     = 0;
    DestBlt.Region.Back      = 1;

    DestBlt.SubRegion.Left   = (UINT) destRect.left;
    DestBlt.SubRegion.Top    = (UINT) destRect.top;
    DestBlt.SubRegion.Right  = (UINT) destRect.right;
    DestBlt.SubRegion.Bottom = (UINT) destRect.bottom;
    DestBlt.SubRegion.Front  = 0;
    DestBlt.SubRegion.Back   = 1;


    SrcBlt.pData             = pSrcImage->m_pData;
    SrcBlt.RowPitch          = pSrcImage->m_Pitch;
    SrcBlt.SlicePitch        = 0;
    SrcBlt.Format            = pSrcImage->m_Format;
    SrcBlt.ColorKey          = ColorKey;
    SrcBlt.pPalette          = pSrcImage->m_pPalette;

    SrcBlt.SubRegion.Left    = (UINT) srcRect.left;
    SrcBlt.SubRegion.Top     = (UINT) srcRect.top;
    SrcBlt.SubRegion.Right   = (UINT) srcRect.right;
    SrcBlt.SubRegion.Bottom  = (UINT) srcRect.bottom;
    SrcBlt.SubRegion.Front   = 0;
    SrcBlt.SubRegion.Back    = 1;

    if( FAILED( hr = Blt.Blt( &DestBlt, &SrcBlt, dwRealFilter ) ) )
        goto LDone;


    hr = S_OK;
    goto LDone;

LDone:
    return hr;
}

//-----------------------------------------------------------------------------
// Name: CVolume()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CVolume::CVolume()
{
    m_Format         = D3DFMT_UNKNOWN;
    m_pData          = NULL;
}




//-----------------------------------------------------------------------------
// Name: CVolume()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CVolume::CVolume( DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, D3DFORMAT format )
{
    m_Format            = format;
    m_Width             = dwWidth;
    m_Height            = dwHeight;
    m_Depth             = dwDepth;

    m_Box.Left         = 0;
    m_Box.Top          = 0;
    m_Box.Front        = 0;
    m_Box.Right        = dwWidth;
    m_Box.Bottom       = dwHeight;
    m_Box.Back         = dwDepth;

    // TODO: This needs to get straightened out
    m_RowPitch          = m_Width * sizeof( DWORD );
    m_SlicePitch        = m_Height * m_Width * sizeof( DWORD );
    m_pData             = new BYTE[ m_SlicePitch * m_Depth ];
}




//-----------------------------------------------------------------------------
// Name: ~CVolume()
// Desc: Frees resources held by the object
//-----------------------------------------------------------------------------
CVolume::~CVolume()
{
    delete[] m_pData;
}





HRESULT LoadVolumeFromVolume( CVolume* pDestVolume, CVolume* pSrcVolume, DWORD dwFilter, D3DCOLOR ColorKey )
{
    D3DBOX      srcBox;
    D3DBOX      destBox;
    DWORD       dwRealFilter = dwFilter;
    CXD3DXBlt   Blt;
    HRESULT     hr;

    srcBox.Left    = 0;
    srcBox.Top     = 0;
    srcBox.Front   = 0;
    srcBox.Right   = pSrcVolume->m_Width;
    srcBox.Bottom  = pSrcVolume->m_Height;
    srcBox.Back    = pSrcVolume->m_Depth;

    destBox.Left   = 0;
    destBox.Top    = 0;
    destBox.Front  = 0;
    destBox.Right  = pDestVolume->m_Width;
    destBox.Bottom = pDestVolume->m_Height;
    destBox.Back   = pDestVolume->m_Depth;

    if(D3DX_DEFAULT == dwRealFilter)
    {
        if(IsUvl(pSrcVolume->m_Format))
            dwRealFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwRealFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }
    
    // Blt using specified filter
    D3DX_BLT DestBlt, SrcBlt;

    DestBlt.pData            = pDestVolume->m_pData;
    DestBlt.RowPitch         = pDestVolume->m_RowPitch;
    DestBlt.SlicePitch       = pDestVolume->m_SlicePitch;
    DestBlt.Format           = pDestVolume->m_Format;
    DestBlt.ColorKey         = 0;
    DestBlt.pPalette         = NULL;

    DestBlt.Region.Left      = 0;
    DestBlt.Region.Top       = 0;
    DestBlt.Region.Front     = 0;
    DestBlt.Region.Right     = (UINT) pDestVolume->m_Width;
    DestBlt.Region.Bottom    = (UINT) pDestVolume->m_Height;
    DestBlt.Region.Back      = (UINT) pDestVolume->m_Depth;

    DestBlt.SubRegion.Left   = (UINT) destBox.Left;
    DestBlt.SubRegion.Top    = (UINT) destBox.Top;
    DestBlt.SubRegion.Front  = (UINT) destBox.Front;
    DestBlt.SubRegion.Right  = (UINT) destBox.Right;
    DestBlt.SubRegion.Bottom = (UINT) destBox.Bottom;
    DestBlt.SubRegion.Back   = (UINT) destBox.Back;


    SrcBlt.pData             = pSrcVolume->m_pData;
    SrcBlt.RowPitch          = pSrcVolume->m_RowPitch;
    SrcBlt.SlicePitch        = pSrcVolume->m_SlicePitch;
    SrcBlt.Format            = pSrcVolume->m_Format;
    SrcBlt.ColorKey          = ColorKey;
    SrcBlt.pPalette          = NULL;

    SrcBlt.SubRegion.Left    = (UINT) srcBox.Left;
    SrcBlt.SubRegion.Top     = (UINT) srcBox.Top;
    SrcBlt.SubRegion.Front   = (UINT) srcBox.Front;
    SrcBlt.SubRegion.Right   = (UINT) srcBox.Right;
    SrcBlt.SubRegion.Bottom  = (UINT) srcBox.Bottom;
    SrcBlt.SubRegion.Back    = (UINT) srcBox.Back;

    if( FAILED( hr = Blt.Blt( &DestBlt, &SrcBlt, dwRealFilter ) ) )
        goto LDone;

    hr = S_OK;
    goto LDone;

LDone:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\LoadImage.h ===
//-----------------------------------------------------------------------------
// File: LoadImage.h
//
// Desc: Loads image files
//
// Hist: 2001.04.13 - New for May XDK release
//       2002.01.29 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef LOADIMAGE_H
#define LOADIMAGE_H

#define DPF(x,y)
#define D3DXASSERT(x)
#define D3DXERR_INVALIDDATA -1




//-----------------------------------------------------------------------------
// Name: class CImage
// Desc: Class to load different image formats
//-----------------------------------------------------------------------------
class CImage
{
public:
    CImage();
    CImage( DWORD dwWidth, DWORD dwHeight, D3DFORMAT format );
    ~CImage();

    VOID*           m_pData;
    D3DFORMAT       m_Format;
    DWORD           m_Width;
    DWORD           m_Height;
    DWORD           m_Pitch;
    PALETTEENTRY*   m_pPalette;

    RECT            m_Rect;

    BOOL            m_bDeleteData;
    BOOL            m_bDeletePalette;

    HRESULT LoadBMP( const VOID* pData, DWORD dwSize );
    HRESULT LoadDIB( const VOID* pData, DWORD dwSize );
    HRESULT LoadTGA( const VOID* pData, DWORD dwSize );
    HRESULT LoadPPM( const VOID* pData, DWORD dwSize );

public:
    HRESULT Load( const VOID* pData, DWORD dwSize );
    HRESULT Load( CHAR* strFilename );

    HRESULT Depalettize();
};

class CVolume
{
public:
    CVolume();
    CVolume( DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, D3DFORMAT format );
    ~CVolume();

    VOID*           m_pData;
    D3DFORMAT       m_Format;
    DWORD           m_Width;
    DWORD           m_Height;
    DWORD           m_Depth;
    DWORD           m_RowPitch;
    DWORD           m_SlicePitch;

    D3DBOX          m_Box;
};


HRESULT LoadImageFromImage( CImage* pDestImage, CImage* pSrcImage, DWORD dwFilter, D3DCOLOR ColorKey );
HRESULT LoadVolumeFromVolume( CVolume* pDestVolume, CVolume* pSrcVolume, DWORD dwFilter, D3DCOLOR ColorKey );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\PixelShader.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: PixelShader.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of the XBContent PixelShaders
//-----------------------------------------------------------------------------
#include "stdafx.h"


// Uncomment this if you want to break into the debugger when an error occurs
// #define BREAK_ON_ERROR

#if defined(DBG) && defined(BREAK_ON_ERROR)
#define SETERROR(HR,CODE) \
    do { \
if(FAILED(HR = CODE)){ \
            DebugBreak(); \
        } \
    } while(0)
#else
#define SETERROR(HR,CODE) \
    HR = CODE
#endif

HRESULT CreateBufferFromFile(const char* path, LPXGBUFFER* ppBuffer){
    HRESULT hr = S_OK;
    if(!path || !ppBuffer){
        SETERROR(hr,E_FAIL);
    }
    HANDLE file = INVALID_HANDLE_VALUE;
    if(SUCCEEDED(hr)){
        file = CreateFile(path,GENERIC_READ,FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
            NULL);
        if(file == INVALID_HANDLE_VALUE){
            SETERROR(hr,E_FAIL);
        }
    }
    DWORD size = 0;
    if(SUCCEEDED(hr)){
        size = GetFileSize(file,NULL);
        if(size == ~0){
            SETERROR(hr,E_FAIL);
        }
    }
    LPXGBUFFER pBuffer = NULL;
    if(SUCCEEDED(hr)){
        hr = XGBufferCreate(size, &pBuffer);
    }
    if(SUCCEEDED(hr)){
        DWORD sizeRead;
        BOOL result = ReadFile(file, pBuffer->GetBufferPointer(), size, &sizeRead, NULL);
        if(! result || sizeRead != size){
            SETERROR(hr,E_FAIL);
        }
    }
    if(file != INVALID_HANDLE_VALUE){
        CloseHandle(file);
    }
    if(SUCCEEDED(hr)){
        *ppBuffer = pBuffer;
    }
    else {
        if(pBuffer) pBuffer->Release();
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// The resolver is responsible for opening #include'd files
//
HRESULT IncludeResolver(
	LPVOID pResolverUserData,
	BOOL isSystemInclude,
	LPCSTR sourceFilePath,
	LPCSTR includeFileName,
	LPSTR resolvedFilePath,
	DWORD resolvedFilePathSize,
	LPXGBUFFER* ppResolvedFile)
{
	// TODO: distinguish between system include and local, look in more places for the file
	// try opening the file from the current directory
	HRESULT hr = CreateBufferFromFile(includeFileName, ppResolvedFile);
	if (FAILED(hr))
		return hr;
	strncpy(resolvedFilePath, includeFileName, resolvedFilePathSize);
	return S_OK;
}



#define PIXELSHADER_IDENTIFIER_SIZE BUNDLER_IDENTIFIER_MAX_LENGTH

struct PixelShader {
	CHAR Identifier[PIXELSHADER_IDENTIFIER_SIZE];
	D3DPIXELSHADERDEF def;

	PixelShader()
	{
		ZeroMemory(Identifier, PIXELSHADER_IDENTIFIER_SIZE);
		ZeroMemory(&def, sizeof(def));
	}

	// Helper function to assign values inside the def structure.  Uses the d3d mappings.
	HRESULT SetConstant(UINT iConstantRegister, CONST void *pConstantData, DWORD ConstantCount)
	{
		float *pFloatData = (float *)pConstantData;
		for (UINT i=0; i<ConstantCount; i++, iConstantRegister++, pFloatData += 4) 
		{
			DWORD dwValue = D3DXCOLOR(pFloatData[0], pFloatData[1], pFloatData[2], pFloatData[3]);

			if (iConstantRegister >= D3DPS_CONSTREG_MAX_DX8)
				return E_FAIL;

			// The pixelshaderdef struct has three dwords that map D3D constants.
			// Scan the mapping to determine which registers to write with this D3D constant.
			for(UINT r=0; r<8; r++) // check c0 registers
				if(((def.PSC0Mapping >> (4*r)) & 0xf) == iConstantRegister)
					def.PSConstant0[r] = dwValue;

			for(r=0; r<8; r++) // check c1 registers
				if((def.PSC1Mapping >> (4*r) & 0xf) == iConstantRegister)
					def.PSConstant1[r] = dwValue;
    
			for(r=0; r<2; r++) // check final combiner registers
				if((def.PSFinalCombinerConstants >> (4*r) & 0xf) == iConstantRegister)
					(&def.PSFinalCombinerConstant0)[r] = dwValue;	// PSFinalCombinerConstant0 or  PSFinalCombinerConstant1
		}
		return S_OK;
	}
};

HRESULT XBContent::BeginPixelShader(ISAXAttributes *pAttributes)
{
	PushContext(PixelShader_Context);
    PixelShader *pPS = new PixelShader;
	if (!pPS) return E_OUTOFMEMORY;
	m_rContextStack[m_iContext].m_pData = pPS;
	ZeroMemory(pPS, sizeof(PixelShader));

	// Set default resource id
	m_Count.m_PixelShader++;
	CHAR *strIdentifier = pPS->Identifier;
	ZeroMemory(strIdentifier, PIXELSHADER_IDENTIFIER_SIZE);
	_snprintf(strIdentifier, PIXELSHADER_IDENTIFIER_SIZE, "PixelShader%d", m_Count.m_PixelShader);
	strIdentifier[PIXELSHADER_IDENTIFIER_SIZE - 1] = 0;

	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(id))
		{
			if (cchValue >= PIXELSHADER_IDENTIFIER_SIZE)
				cchValue = PIXELSHADER_IDENTIFIER_SIZE - 1;
			ZeroMemory(strIdentifier, PIXELSHADER_IDENTIFIER_SIZE);
			strncpy(strIdentifier, CharString(pwchValue, cchValue), cchValue );
			strIdentifier[cchValue] = 0;	// make sure the string is NULL terminated
		}
		else if (MATCH(idref))
		{
			CHAR *strID = CharString(pwchValue, cchValue);
			DWORD dwResourceIndex;
			if (!m_pBundler->IsExistingIdentifier(strID, &dwResourceIndex))
			{
				m_pBundler->ErrorMsg("Unknown resource \"%s\"\n", strID);
				return E_FAIL;
			}

			// Copy reference pixel shader description over current description
			DWORD Offset = m_pBundler->m_aResources[dwResourceIndex-1].dwOffset + 2 * sizeof(DWORD);	// skip user data header
			D3DPIXELSHADERDEF *pdef = (D3DPIXELSHADERDEF *)(m_pBundler->m_pbHeaderBuff + Offset);
			pPS->def = *pdef;
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}

	// Check if identifier is unique
	if ( m_pBundler->IsExistingIdentifier( strIdentifier ) )
	{
        m_pBundler->ErrorMsg( "Second use of identifier \"%s\"", strIdentifier );
		return E_FAIL;
	}
	
	// Defer the save of the pixel buffer to the bundler until we
	// process all the PixelShader elements.
	return S_OK;
}

HRESULT XBContent::EndPixelShader()
{
	PixelShader *pPS = (PixelShader *)m_rContextStack[m_iContext].m_pData;
	if (pPS == NULL) return E_INVALIDARG;

	// Keep track of offset into header as a bundler resource
	CHAR *strIdentifier = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
	strncpy(strIdentifier, pPS->Identifier, BUNDLER_IDENTIFIER_MAX_LENGTH - 1);
	strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH] = 0;	// make sure the string is null terminated
    DWORD cbHeader0 = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].dwOffset = m_pBundler->m_cbHeader;
	m_pBundler->m_nResourceCount++;
	
	// Helper writing macro
#define WRITE(POINTER, SIZE)								\
	if (FAILED(m_pBundler->WriteHeader( POINTER, SIZE )))	\
		return E_FAIL;										\
	m_pBundler->m_cbHeader += SIZE;	// TODO: this should be done in WriteHeader
	
	// write header to bundle
	struct _UserData {
		DWORD dwType;				// XBRC_PIXELSHADER
		DWORD dwSize;				// total size (not including this header)
	} UserData;
	UserData.dwType = XBRC_PIXELSHADER;
	UserData.dwSize = sizeof(D3DPIXELSHADERDEF);
	
	WRITE( &UserData, sizeof(UserData) );
	WRITE( &pPS->def, sizeof(D3DPIXELSHADERDEF) );
	
#undef WRITE
	
    printf("PixelShader:  wrote %s (%d bytes)\n", strIdentifier, m_pBundler->m_cbHeader - cbHeader0);

	// cleanup
    delete pPS;
	PopContext();

	// If we're inside a pass context, save reference to pixel shader
	if (m_rContextStack[m_iContext].m_Context == Pass_Context)
	{
		Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
		Pass *pPass = &pEffect->rPass[pEffect->PassCount];
		
		// one-based index (since the resource count was already incremented)
		if (pPass->PixelShaderResource != 0)
			m_pBundler->ErrorMsg("<PixelShader> tag must appear just once within a <Pass> block\n");
		pPass->PixelShaderResource = m_pBundler->m_nResourceCount;
	}
	return S_OK;
}

#define PIXELSHADER_ASM_BUFFER_SIZE 10000
struct PixelShader_asm {
	PixelShader *m_pPS;
	INT m_cchCount;	// number of chars added to buffer
	CHAR m_buf[PIXELSHADER_ASM_BUFFER_SIZE];

	PixelShader_asm(PixelShader *pPS)
	{
		m_pPS = pPS;
		m_cchCount = 0;
		m_buf[0] = 0;
	}
};

HRESULT XBContent::BeginPixelShader_asm(ISAXAttributes *pAttributes)
{
	// Sanity check:
	if (m_rContextStack[m_iContext].m_Context != PixelShader_Context)
	{
		m_pBundler->ErrorMsg("<asm> tag must appear within an enclosing <PixelShader>\n");
		return E_FAIL;
	}

	// Make a new asm struct and push the context
	PixelShader *pPS = (PixelShader *)m_rContextStack[m_iContext].m_pData;
	PixelShader_asm *pPS_asm = new PixelShader_asm(pPS);
	if (pPS_asm == NULL)
		return E_OUTOFMEMORY;
	PushContext(PixelShader_asm_Context);
	m_rContextStack[m_iContext].m_pData = pPS_asm;

	return S_OK;
}

HRESULT XBContent::PixelShader_asm_Chars(WCHAR *pwchChars, int cchChars)
{
	PixelShader_asm *pPS_asm = (PixelShader_asm *)m_rContextStack[m_iContext].m_pData;
	int cchOut;
	CHAR *strFull = CharString(pwchChars, cchChars, &cchOut);
	if (cchOut + pPS_asm->m_cchCount >= PIXELSHADER_ASM_BUFFER_SIZE)
		return E_FAIL;
	strcat(pPS_asm->m_buf, strFull);
	pPS_asm->m_cchCount += cchOut;
	return S_OK;
}

HRESULT XBContent::EndPixelShader_asm()
{
	PixelShader_asm *pPS_asm = (PixelShader_asm *)m_rContextStack[m_iContext].m_pData;
	
	// Assemble the shader
	LPXGBUFFER pCompiledShader = NULL;
	LPXGBUFFER pErrorLog = NULL;
	LPXGBUFFER pListing = NULL;
	DWORD ShaderType;
	LPCSTR pSourceFileName = "<asm>";
	DWORD dwFlags = 0;
	HRESULT hr = XGAssembleShader(pSourceFileName, pPS_asm->m_buf, pPS_asm->m_cchCount, dwFlags,
								  NULL, &pCompiledShader, &pErrorLog, &pListing, IncludeResolver, this, &ShaderType);
	if (FAILED(hr))
	{
		m_pBundler->ErrorMsg("Pixel shader assembling failed.\n%.*s\n", pErrorLog->GetBufferSize(), pErrorLog->GetBufferPointer());
		goto e_Exit;
	}
	if (SASMT_SHADERTYPE(ShaderType) != SASMT_PIXELSHADER)
	{
		m_pBundler->ErrorMsg("Non-pixel shader specified in pixel shader context.\n");
	}
	if (pCompiledShader)
	{
		// Copy function code to PixelShader
		D3DPIXELSHADERDEF *pdef = (D3DPIXELSHADERDEF *)(pCompiledShader->GetBufferPointer());
		ASSERT(pCompiledShader->GetBufferSize() == sizeof(D3DPIXELSHADERDEF));
		pPS_asm->m_pPS->def = *pdef;
	}

	// Cleanup
 e_Exit:	
	if (pCompiledShader)
		pCompiledShader->Release();
	if (pErrorLog)
		pErrorLog->Release();
	if (pListing)
		pListing->Release();
	delete pPS_asm;
	PopContext();
	return hr;
}


#define PIXELSHADER_CONSTANT_BUFFER_SIZE 2000
struct PixelShader_Constant {
	PixelShader *m_pPS;
	UINT m_iConstantRegister;
	UINT m_iConstantCount;
	INT m_cchCount;	// number of chars added to buffer
	CHAR m_buf[PIXELSHADER_CONSTANT_BUFFER_SIZE];
	
	PixelShader_Constant(PixelShader *pPS)
	{
		m_pPS = pPS;
		m_iConstantRegister = 0x7ffffff;
		m_iConstantCount = 1;
		m_cchCount = 0;
		m_buf[0] = 0;
	}
};

HRESULT XBContent::BeginPixelShader_Constant(ISAXAttributes *pAttributes)
{
	// Sanity check:
	if (m_rContextStack[m_iContext].m_Context != PixelShader_Context)
	{
		m_pBundler->ErrorMsg("<Constant> tag must appear within an enclosing <PixelShader>\n");
		return E_FAIL;
	}

	// Make a new Constant struct and push the context
	PixelShader *pPS = (PixelShader *)m_rContextStack[m_iContext].m_pData;
	PixelShader_Constant *pPS_Constant = new PixelShader_Constant(pPS);
	if (pPS_Constant == NULL)
		return E_OUTOFMEMORY;
	PushContext(PixelShader_Constant_Context);
	m_rContextStack[m_iContext].m_pData = pPS_Constant;

	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(index))
		{
			pPS_Constant->m_iConstantRegister = atoi(CharString(pwchValue, cchValue));
		}
		else if (MATCH(count))
		{
			pPS_Constant->m_iConstantCount = atoi(CharString(pwchValue, cchValue));
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	return S_OK;
}

HRESULT XBContent::PixelShader_Constant_Chars(WCHAR *pwchChars, int cchChars)
{
	PixelShader_Constant *pPS_Constant = (PixelShader_Constant *)m_rContextStack[m_iContext].m_pData;
	int cchOut;
	CHAR *strFull = CharString(pwchChars, cchChars, &cchOut);
	if (cchOut + pPS_Constant->m_cchCount >= PIXELSHADER_CONSTANT_BUFFER_SIZE)
		return E_FAIL;
	strcat(pPS_Constant->m_buf, strFull);
	pPS_Constant->m_cchCount += cchOut;
	return S_OK;
}

HRESULT XBContent::EndPixelShader_Constant()
{
	HRESULT hr = S_OK;
	PixelShader_Constant *pPS_Constant = (PixelShader_Constant *)m_rContextStack[m_iContext].m_pData;
	
	// Add constants to Pixel shader
	UINT iConstantRegister = pPS_Constant->m_iConstantRegister;
	UINT iConstantCount = 0;
	FLOAT rConstantValue[4];
	UINT iConstantValueIndex = 0;
	CHAR *strSeparators = " \t\n";
	CHAR *strBuff = strtok(pPS_Constant->m_buf, strSeparators);
	CHAR *pEnd;
	while (strBuff != NULL)
	{
		if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
		{
			FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
			if (*pEnd != '\0')
			{
				m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
				// leave as just a warning
			}
			rConstantValue[iConstantValueIndex++] = fValue;
			if (iConstantValueIndex == 4)
			{
				// Every 4 values we add a new constant
				iConstantValueIndex = 0;
				if (iConstantCount >= pPS_Constant->m_iConstantCount)
				{
					m_pBundler->ErrorMsg("Warning: too many constant values (%d > %d) between <Constant> ... </Constant>.\n",
										 iConstantCount + 1, pPS_Constant->m_iConstantCount);
					goto e_Exit;
				}
				hr = pPS_Constant->m_pPS->SetConstant(iConstantRegister + iConstantCount, rConstantValue, 1);
				if (FAILED(hr))
				{
					m_pBundler->ErrorMsg("Could not set constant register %d.\n", iConstantRegister + iConstantCount);
					goto e_Exit;
				}
				iConstantCount++;
			}
		}
		else
		{
			m_pBundler->ErrorMsg( "Unrecognized constant value \"%s\"\n", strBuff );
			hr = E_FAIL;
			goto e_Exit;
		}

		// Get next token
		strBuff = strtok(NULL, strSeparators);
	}
	if (iConstantValueIndex != 0)
	{
		m_pBundler->ErrorMsg("Warning: extra data skipped in <Constant>\n");
	}
	if (iConstantCount != pPS_Constant->m_iConstantCount)
	{
		m_pBundler->ErrorMsg("Warning: missing constant values (found %d out of %d) <Constant>\n",
							 iConstantCount, pPS_Constant->m_iConstantCount);
	}
 e_Exit:

	// Cleanup
	delete pPS_Constant;
	PopContext();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\pushbuffer.h ===
//-----------------------------------------------------------------------------
// File: pushbuffer.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the pushbuffer-related functionality of the bundler library
//
// Hist: 2001.09.26 - New for November XDK release
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef PUSHBUFFER_H
#define PUSHBUFFER_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>
#include "xd3d.h"

class CBundler;

//-----------------------------------------------------------------------------
// Name: class CPushBuffer
// Desc: Handles all pushbuffer-specific processing
//-----------------------------------------------------------------------------
class CPushBuffer
{
public:
    CPushBuffer( CBundler * pBundler );
    ~CPushBuffer();

    HRESULT SaveToBundle( DWORD *pcbHeader, DWORD *pcbData );
	HRESULT CompileDrawIndexedVertices(
		XD3DPRIMITIVETYPE PrimitiveType,
		UINT VertexCount,
		CONST WORD *pIndexData);	// multiple calls append data to same pushbuffer
	HRESULT Clear();	// clears current pushbuffer data
	
private:
    HRESULT SaveHeader( DWORD dwStart, DWORD * pcbHeader );
    HRESULT SaveData( DWORD * pcbData );
    CBundler * m_pBundler;
	BYTE *m_pBuffer;	// instruction buffer
	DWORD m_BufferSize;	// size of buffer in bytes
};


#endif // PUSHBUFFER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\pushbuffer.cpp ===
//-----------------------------------------------------------------------------
// File: PushBuffer.cpp
//
// Desc: PushBuffer-related functionality of the bundler library
//
// Hist: 2001.09.26 - New for November XDK release
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "PushBuffer.h"
#include "Bundler.h"

//-----------------------------------------------------------------------------
// Name: CPushBuffer()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CPushBuffer::CPushBuffer( CBundler* pBundler )
{
    m_pBundler = pBundler;
	m_pBuffer = NULL;	// instruction buffer
	m_BufferSize = 0;	// size of buffer in bytes
}




//-----------------------------------------------------------------------------
// Name: ~CPushBuffer (destructor)
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CPushBuffer::~CPushBuffer()
{
	Clear();
}




//-----------------------------------------------------------------------------
// Name: CompileDrawIndexedVertices
// Desc: Allocates buffer and calls XGCompileDrawIndexedVertices to
// fill with pushbuffer commands.
//-----------------------------------------------------------------------------
HRESULT CPushBuffer::CompileDrawIndexedVertices(
		XD3DPRIMITIVETYPE PrimitiveType,
		UINT VertexCount,
		CONST WORD *pIndexData)
{
	// Get the size of the needed buffer
	DWORD Size = 0;
	HRESULT hr = XGCompileDrawIndexedVertices(NULL, &Size, (D3DPRIMITIVETYPE)PrimitiveType, VertexCount, pIndexData);
	if (FAILED(hr) && hr != XD3DERR_BUFFERTOOSMALL)
		return hr;
	BYTE *pBuffer;
	if (m_pBuffer == NULL)
	{
		// Allocate new buffer
		m_pBuffer = new BYTE [Size];
		if (m_pBuffer == NULL)
			return E_OUTOFMEMORY;
		pBuffer = m_pBuffer;
	}
	else
	{
		// Allocate buffer big enough to hold old and new data
		BYTE *pBufferOld = m_pBuffer;
		m_pBuffer = new BYTE [m_BufferSize + Size];
		if (m_pBuffer == NULL)
		{
			m_pBuffer = pBufferOld;
			return E_OUTOFMEMORY;
		}

		// Copy old data
		memcpy(m_pBuffer, pBufferOld, m_BufferSize);
		pBuffer = m_pBuffer + m_BufferSize;		// set copy point to end of old data
		m_BufferSize += Size;
	}
	// Compile the buffer
	return XGCompileDrawIndexedVertices(pBuffer, &Size, (D3DPRIMITIVETYPE)PrimitiveType, VertexCount, pIndexData);
}


//-----------------------------------------------------------------------------
// Name: Clear
// Desc: Delete the buffers and clears current pushbuffer data
//-----------------------------------------------------------------------------
HRESULT CPushBuffer::Clear()
{
	if (m_pBuffer)
		delete m_pBuffer;
	m_pBuffer = NULL;
	m_BufferSize = 0;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CPushBuffer::SaveToBundle( DWORD * pcbHeader, DWORD * pcbData )
{
    HRESULT hr;

    if (m_pBuffer == NULL || m_BufferSize == 0)
    {
        m_pBundler->ErrorMsg( "Error: No push buffer data specified\n" );
        return E_FAIL;
    }
    
    // Pad data file to proper alignment for the start of the vertex buffer
    hr = m_pBundler->PadToAlignment( XD3DPUSHBUFFER_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeader( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save data
    hr = SaveData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeader()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CPushBuffer::SaveHeader( DWORD dwStart, DWORD * pcbHeader )
{
    XD3DPushBuffer PB;

    PB.Common =
		XD3DCOMMON_TYPE_PUSHBUFFER |    // Type
		1;                              // Initial Refcount
    PB.Data   = dwStart; 				// Offset of data in data file
    PB.Lock   = 0;                      // Must be zero
	PB.Size	  = m_BufferSize;
    PB.AllocationSize = m_BufferSize;
	
    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &PB, sizeof( PB ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( PB );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveData()
// Desc: Saves the raw PushBuffer data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CPushBuffer::SaveData( DWORD * pcbData )
{
	*pcbData = m_BufferSize;
	return m_pBundler->WriteData( m_pBuffer, m_BufferSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\param.h ===
//-----------------------------------------------------------------------------
//
//  File: param.h
//
//  Copyright (C) 2001 Microsoft Corporation.
//  All rights reserved.
//
//  Author: Jerome E. Lengyel
//  Description: Parameter setting from application to XDX resources.
//
//-----------------------------------------------------------------------------

// One parameter type for each kind of parameter that may be set
struct Parameter_VertexShaderConstant {
	DWORD m_VertexShaderResource;	// vertex shader resource to write constant for
	DWORD m_Index;					// index into constants
	DWORD m_Count;					// count of constants to write
	VOID *m_pSource;				// source data
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\texture.cpp ===
//-----------------------------------------------------------------------------
// File: Texture.cpp
//
// Desc: Contains the texture-specific logic for the bundler tool
//
// Hist: 2001.02.06 - New for March XDK release
//       2001.04.13 - Reorganized for May XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include "Texture.h"
#include "Bundler.h"




//-----------------------------------------------------------------------------
// Name: CTexture2D()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CTexture2D::CTexture2D( CBundler* pBundler )
           :CBaseTexture( pBundler )
{
    m_strSource[0]      = 0;
    m_strAlphaSource[0] = 0;
    m_pImage            = NULL;
    m_dwWidth           = 0;
    m_dwHeight          = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CTexture2D()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CTexture2D::~CTexture2D()
{
	if (m_pImage)
		delete m_pImage;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CTexture2D::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    // Load the texture from disk, and set default values from it
    hr = LoadTexture();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save texture data
    (*pcbData) = 0;
    SaveImage( pcbData, m_dwLevels, m_pImage );
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadTexture()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CTexture2D::LoadTexture()
{
    HRESULT hr;

    // Load the imagesurfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    hr = LoadImage( m_strSource, m_strAlphaSource, &m_pImage );
    if( FAILED( hr ) )
    {
        // If the conventional load methods failed, we can try using D3DX as a
        // last ditch effort. This will load DDS files, JPGs, etc., but has
        // limitations like only pow-2 dimensions.

        hr = LoadImageUsingD3DX( m_strSource, m_strAlphaSource, &m_pImage );
        if( FAILED( hr ) )
        {
            if( m_strAlphaSource[0] )
                m_pBundler->ErrorMsg( "Texture: Couldn't load source file <%s> or <%s>\n", m_strSource, m_strAlphaSource );
            else
                m_pBundler->ErrorMsg( "Texture: Couldn't load source file <%s>\n", m_strSource );
            return hr;
        }
    }

    // Try to look up our format string
    if( m_strFormat[0] )
    {
        m_nFormat = FormatFromString( m_strFormat );
        if( m_nFormat < -1 )
        {
            m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
            return E_FAIL;
        }
    }

    // If the format is still not determined, resort to A8R8G8B8
    if( m_nFormat < 0 )
    {
        lstrcpyA( m_strFormat, "D3DFMT_A8R8G8B8" );
        m_nFormat = FormatFromString( m_strFormat );
    }

    // Determine final width and height
    if( m_dwWidth==0 || m_dwHeight==0 )
    {
        if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
        {
            // Linear textures can have any size
            m_dwWidth  = m_pImage->m_Width;
            m_dwHeight = m_pImage->m_Height;
        }
        else
        {
            // Enforce power-of-two dimensions for swizzled and compressed textures
            for( m_dwWidth=1;  m_dwWidth  < m_pImage->m_Width;  m_dwWidth<<=1 );
            for( m_dwHeight=1; m_dwHeight < m_pImage->m_Height; m_dwHeight<<=1 );
        }
    }

    // Determine final number of miplevels
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_dwLevels = 1;
    }
    else
    {
        // Count levels
        DWORD dwLevels = 1; 
        while( ( (1UL<<(dwLevels-1)) < m_dwWidth ) && ( (1UL<<(dwLevels-1))<m_dwHeight ) )
            dwLevels++;
            
        if( m_dwLevels < 1 || m_dwLevels > dwLevels )
            m_dwLevels = dwLevels;
    }

    // Change the size of the surface
    hr = ResizeImage( m_dwWidth, m_dwHeight, &m_pImage );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CTexture2D::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
    XD3DTexture d3dtex;

    XGSetTextureHeader(m_dwWidth, m_dwHeight, m_dwLevels, 0,
                       (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                       D3DPOOL_DEFAULT, (IDirect3DTexture8*)&d3dtex,
                       dwStart, 0);

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( d3dtex );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Fill a texture texel-by-texel.
//-----------------------------------------------------------------------------
HRESULT CTexture2DFill::SetNextTexel(DWORD dwColor)
{
	HRESULT hr = S_OK;
	if (m_pImage == NULL)
	{
		// Allocate surface
		if (m_dwWidth == 0 || m_dwHeight == 0)
		{
			m_pBundler->ErrorMsg( "Width and height attributes required for inline textures.\n" );
			return E_FAIL;
		}
		m_pImage = new CImage( m_dwWidth, m_dwHeight, D3DFMT_A8R8G8B8 );
		if (m_pImage == NULL)
		{
			m_pBundler->ErrorMsg( "Unable to create image surface for inline texture.\n" );
			return E_OUTOFMEMORY;
		}
		m_iTexel = 0;
	}
	if (m_iTexel >= m_dwWidth * m_dwHeight)
	{
		m_pBundler->ErrorMsg( "Too many texels (%d) added to inline texture (width=%d height=%d).\n", m_iTexel, m_dwWidth, m_dwHeight );
		return E_FAIL;
	}
	assert(m_pImage->m_Format == D3DFMT_A8R8G8B8);	// Image must be ARGB format
	DWORD *pPixel = (DWORD *)(m_pImage->m_pData) + m_iTexel;
	*pPixel = dwColor;
	m_iTexel++;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\userdata.h ===
//-----------------------------------------------------------------------------
// File: UserData.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the userdata-related functionality of the bundler tool
//
// Hist: 2001.02.06 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef USERDATA_H
#define USERDATA_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;

#define USERDATA_ALIGNMENT     4

//-----------------------------------------------------------------------------
// Name: class CUserData
// Desc: Handles user data processing
//-----------------------------------------------------------------------------
class CUserData
{
    CBundler* m_pBundler;

    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );
    HRESULT SaveUserDataData( DWORD* pcbData );

public:
	HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CHAR  m_strSource[MAX_PATH];
    VOID* m_pData;
    DWORD m_dwDataSize;

    CUserData( CBundler* pBundler );
    ~CUserData();
};


#endif // USERDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B05A63F4_9900_4362_9E2A_2C8E360B3B70__INCLUDED_)
#define AFX_STDAFX_H__B05A63F4_9900_4362_9E2A_2C8E360B3B70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#import <msxml4.dll> raw_interfaces_only 
using namespace MSXML2;

#include <stdio.h>

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef CONST
#define CONST const
#endif

#include <d3d8-xbox.h>
#include <d3d8types-xbox.h>

#include "XBContent.h"

// Bundler class types
#include "texture.h"
#include "vb.h"
#include "indexbuffer.h"
#include "pushbuffer.h"
#include "CVertexShader.h"
#include "userdata.h"

#include "effect.h"
#include "frame.h"
#include "anim.h"
#include "xbrc.h"

#ifndef ASSERT
#define ASSERT(X) { if (!(X)) { __asm int 3 } }
#endif

//////////////////////////////////////////////////////////////////////
// Returns true if the name matches the token
//
inline bool Match(CONST WCHAR *pToken, CONST WCHAR *pName, INT cchName)
{
	return (pToken[0] == pName[0])
		&& _wcsnicmp(pToken, pName, cchName) == 0
		&& wcslen(pToken) == (UINT)cchName;
}


//////////////////////////////////////////////////////////////////////
// Set quaternion keys to match axis/angle rotation.
//
HRESULT MatchAxisAngleCurve(AnimRotate *pRotate, CONST D3DXVECTOR3 *pvAxis, CONST AnimCurve *pAngle, FLOAT feps);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B05A63F4_9900_4362_9E2A_2C8E360B3B70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\texture.h ===
//-----------------------------------------------------------------------------
// File: Texture.h
//
// Desc: Header file containing class definition for the 2d texture-related 
//       functionality of the bundler tool
//
// Hist: 2001.02.06 - New for March XDK release
//       2001.04.13 - Reorganized for May XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TEXTURE_H
#define TEXTURE_H

#include "BaseTexture.h"




//-----------------------------------------------------------------------------
// Name: class CTexture2D
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CTexture2D : public CBaseTexture
{
public:
    CTexture2D( CBundler* pBundler );
    ~CTexture2D();

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CHAR  m_strSource[MAX_PATH];
    CHAR  m_strAlphaSource[MAX_PATH];
    DWORD m_dwWidth;
    DWORD m_dwHeight;

protected:
    HRESULT LoadTexture();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );
	
    CImage* m_pImage;
};


//-----------------------------------------------------------------------------
// Name: class CTexture2DFill
// Desc: Adds the ability to fill a texture texel-by-texel.
//-----------------------------------------------------------------------------
class CTexture2DFill : public CTexture2D
{
public:
	CTexture2DFill(CBundler *pBundler) : CTexture2D(pBundler) {}
	LONG m_iTexel;	// current position within texture
	HRESULT SetNextTexel(DWORD dwColor);
};


#endif // TEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\vb.cpp ===
//-----------------------------------------------------------------------------
// File: VB.cpp
//
// Desc: Contains the vertexbuffer-specific logic for the bundler tool
//
// Hist: 2001.02.06 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "VB.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CVertexBuffer()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CVertexBuffer::CVertexBuffer( CBundler* pBundler )
{
    m_pBundler = pBundler;
    m_DataCount = m_FormatCount = 0;
    m_bRawVertices = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CVertexBuffer (destructor)
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CVertexBuffer::~CVertexBuffer()
{
}




//-----------------------------------------------------------------------------
// Name: AddVertexData()
// Desc: Adds a single value to the vertex data stream
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::AddVertexData( DOUBLE val )
{
    if(m_DataCount >= MAX_VB_DATA)
    {
        m_pBundler->ErrorMsg( "Error: Vertex Data Buffer Overflow\n" );
        return E_FAIL;
    }
    m_Data[m_DataCount++] = val;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadVertexDataFromFile
// Desc: Loads entire vertex data stream from file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::LoadVertexDataFromFile( CHAR* strFilename )
{
    // Open the file
    HANDLE hFile = CreateFileA( strFilename, 
                                GENERIC_READ, 
                                FILE_SHARE_READ, 
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Make sure we can fit the whole thing in memory.
    // TODO: Dynamically allocate memory for vertex buffers
    DWORD dwSize = GetFileSize( hFile, NULL );
    if( dwSize > sizeof( m_Data ) )
    {
        m_pBundler->ErrorMsg( "Error: Vertex data file too large.\n" );
        return E_FAIL;
    }

    // Read the data
    DWORD dwRead;
    ReadFile( hFile, m_Data, dwSize, &dwRead, NULL );
    if( dwRead != dwSize )
        return E_FAIL;

    CloseHandle( hFile );

    m_bRawVertices = TRUE;
    m_DataCount = dwRead;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AddVertexFormat()
// Desc: Adds a single value to the vertex data format
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::AddVertexFormat( DWORD format )
{
    if(m_FormatCount >= MAX_VB_FORMATS)
    {
        m_pBundler->ErrorMsg( "Error: Vertex Format Buffer Overflow\n" );
        return E_FAIL;
    }
    m_Format[m_FormatCount++] = format;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveToBundle( DWORD * pcbHeader, DWORD * pcbData )
{
    HRESULT hr;

    if(m_FormatCount == 0)
    {
        m_pBundler->ErrorMsg( "Error: No attribute formats specified\n" );
        return E_FAIL;
    }
    
    if(m_DataCount == 0)
    {
        m_pBundler->ErrorMsg( "Error: No attribute data specified\n" );
        return E_FAIL;
    }
    
    // Pad data file to proper alignment for the start of the vertex buffer
    hr = m_pBundler->PadToAlignment( XD3DVERTEXBUFFER_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save vertexbuffer data
    hr = SaveVertexBufferData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
    XD3DVertexBuffer xd3dvb;

    xd3dvb.Common = XD3DCOMMON_TYPE_VERTEXBUFFER |    // Type
                    1;                                // Initial Refcount

    xd3dvb.Data   = dwStart;                    // Offset of data in data file
    xd3dvb.Lock   = 0;                          // Must be zero


    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &xd3dvb, sizeof( xd3dvb ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( xd3dvb );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SaveVertexBufferData()
// Desc: Saves the raw VertexBuffer data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveVertexBufferData( DWORD * pcbData )
{
    DWORD cData, cFormat, cVertex;
    FLOAT fOut[4];
    DWORD dwOut[4];
    SHORT sOut[4];
    BYTE  bOut[4];

    // calculate how many bytes per vertex
    m_cBytesPerVertex = 0;
    m_cInputValuesPerVertex = 0;
    for(cFormat=0; cFormat < m_FormatCount; cFormat++)
    {
		DWORD inputs;
		DWORD bytesout;
		switch (m_Format[cFormat])
		{
			case XD3DVSDT_FLOAT1     : 	inputs = 1; bytesout = sizeof(FLOAT);   break;
			case XD3DVSDT_FLOAT2     : 	inputs = 2; bytesout = 2*sizeof(FLOAT); break;
			case XD3DVSDT_FLOAT3     : 	inputs = 3; bytesout = 3*sizeof(FLOAT); break;
			case XD3DVSDT_FLOAT4     : 	inputs = 4; bytesout = 4*sizeof(FLOAT); break;
    		case XD3DVSDT_D3DCOLOR   : 	inputs = 4; bytesout = 4*sizeof(BYTE);  break;
    		case XD3DVSDT_SHORT2     : 	inputs = 2; bytesout = 2*sizeof(SHORT); break;
    		case XD3DVSDT_SHORT4     : 	inputs = 4; bytesout = 4*sizeof(SHORT); break;
    		case XD3DVSDT_NORMSHORT1 : 	inputs = 1; bytesout = sizeof(SHORT);   break;
    		case XD3DVSDT_NORMSHORT2 : 	inputs = 2; bytesout = 2*sizeof(SHORT); break;
    		case XD3DVSDT_NORMSHORT3 : 	inputs = 3; bytesout = 3*sizeof(SHORT); break;
    		case XD3DVSDT_NORMSHORT4 : 	inputs = 4; bytesout = 4*sizeof(SHORT); break;
    		case XD3DVSDT_NORMPACKED3: 	inputs = 3; bytesout = sizeof(DWORD);   break;
    		case XD3DVSDT_SHORT1     : 	inputs = 1; bytesout = sizeof(SHORT);   break;
    		case XD3DVSDT_SHORT3     : 	inputs = 3; bytesout = 3*sizeof(SHORT); break;
    		case XD3DVSDT_PBYTE1     : 	inputs = 1; bytesout = sizeof(BYTE);    break;
    		case XD3DVSDT_PBYTE2     : 	inputs = 2; bytesout = 2*sizeof(BYTE);  break;
    		case XD3DVSDT_PBYTE3     : 	inputs = 3; bytesout = 3*sizeof(BYTE);  break;
    		case XD3DVSDT_PBYTE4     : 	inputs = 4; bytesout = 4*sizeof(BYTE);  break;
    		case XD3DVSDT_FLOAT2H    : 	inputs = 3; bytesout = 3*sizeof(FLOAT); break;
			default:
				m_pBundler->ErrorMsg("Error: Bad vertex buffer format token\n");
				return E_FAIL;
		}
        m_cBytesPerVertex += bytesout;
        m_cInputValuesPerVertex += inputs;
    }
	
    // If we read raw vertex info from a file, just spew it out
	if (m_bRawVertices)
	{
        m_cVertices = m_DataCount / m_cBytesPerVertex;
        m_cTotalBytesinVB = m_DataCount;
        *pcbData = m_DataCount;

        if( FAILED( m_pBundler->WriteData( m_Data, m_DataCount ) ) )
            return E_FAIL;
        else
            return S_OK;
	}
	else
	{
		m_cVertices = m_DataCount/m_cInputValuesPerVertex;
		m_cTotalBytesinVB = m_cVertices*m_cBytesPerVertex;
		*pcbData = 0;
	}

    if((m_cVertices * m_cInputValuesPerVertex) != m_DataCount)
    {
        m_pBundler->ErrorMsg( "Warning: Extra Vertex Buffer Data:\n");
        m_pBundler->ErrorMsg( "         Format specifies %d values per vertex\n", m_cInputValuesPerVertex);
        m_pBundler->ErrorMsg( "         %d values supplied\n", m_DataCount);
        m_pBundler->ErrorMsg( "         Enough for %d vertices with %d values left over\n", m_cVertices, 
                             m_DataCount - m_cVertices * m_cInputValuesPerVertex);
    }

    for(cData = 0, cVertex = 0; cVertex < m_cVertices; cVertex++ )
    {
        for(cFormat=0; cFormat < m_FormatCount; cFormat++)
        {
            switch(m_Format[cFormat])
            {
				case XD3DVSDT_FLOAT1:
					*pcbData += sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT2:
					*pcbData += 2*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 2*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT2H:
				case XD3DVSDT_FLOAT3:
					*pcbData += 3*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					fOut[2] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 3*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT4:
					*pcbData += 4*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					fOut[2] = (FLOAT)m_Data[cData++];
					fOut[3] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 4*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_D3DCOLOR:
					*pcbData += 4*sizeof(BYTE);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);	// r
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);	// g
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);	// b
					bOut[3] = (BYTE)(m_Data[cData++] * 255.0);	// a
					if( FAILED( m_pBundler->WriteData( bOut, 4*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT1:
					*pcbData += sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT2:
					*pcbData += 2*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 2*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT3:
					*pcbData += 3*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					sOut[2] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 3*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT4:
					*pcbData += 4*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					sOut[2] = (SHORT)m_Data[cData++];
					sOut[3] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 4*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT1:
					*pcbData += sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT2:
					*pcbData += 2*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 2*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT3:
					*pcbData += 3*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[2] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 3*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT4:
					*pcbData += 4*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[2] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[3] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 4*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMPACKED3:
					*pcbData += sizeof(DWORD);
					dwOut[0] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[1] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[2] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[3] = (dwOut[0] & 0xffe00000) |
							   ((dwOut[1] >> 11) & 0x001ffc00) |
							   ((dwOut[2] >> 22) & 0x000003ff);
					if( FAILED( m_pBundler->WriteData( &(dwOut[3]), sizeof(DWORD) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE1:
					*pcbData += sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE2:
					*pcbData += 2*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 2*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE3:
					*pcbData += 3*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 3*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE4:
					*pcbData += 4*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[3] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 4*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
            }
        }
    }
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: VertexFormatFromString
// Desc: helper function to match a format string to the format constant
//-----------------------------------------------------------------------------
DWORD CVertexBuffer::VertexFormatFromString( CONST CHAR *strBuff )
{
	if((strcmp(strBuff, "D3DVSDT_FLOAT1") == 0) ||
	   (strcmp(strBuff, "FLOAT1") == 0))
		return XD3DVSDT_FLOAT1;
	else if((strcmp(strBuff, "D3DVSDT_FLOAT2") == 0) ||
			(strcmp(strBuff, "FLOAT2") == 0))
		return XD3DVSDT_FLOAT2;
	else if((strcmp(strBuff, "D3DVSDT_FLOAT3") == 0) ||
			(strcmp(strBuff, "FLOAT3") == 0))
		return XD3DVSDT_FLOAT3;
	else if((strcmp(strBuff, "D3DVSDT_FLOAT4") == 0) ||
			(strcmp(strBuff, "FLOAT4") == 0))
		return XD3DVSDT_FLOAT4;
	else if((strcmp(strBuff, "D3DVSDT_D3DCOLOR") == 0) ||
			(strcmp(strBuff, "D3DCOLOR") == 0))
		return XD3DVSDT_D3DCOLOR;
	else if((strcmp(strBuff, "D3DVSDT_SHORT2") == 0) ||
			(strcmp(strBuff, "SHORT2") == 0))
		return XD3DVSDT_SHORT2;
	else if((strcmp(strBuff, "D3DVSDT_SHORT4") == 0) ||
			(strcmp(strBuff, "SHORT4") == 0))
		return XD3DVSDT_SHORT4;
	else if((strcmp(strBuff, "D3DVSDT_NORMSHORT1") == 0) ||
			(strcmp(strBuff, "NORMSHORT1") == 0))
		return XD3DVSDT_NORMSHORT1;
	else if((strcmp(strBuff, "D3DVSDT_NORMSHORT2") == 0) ||
			(strcmp(strBuff, "NORMSHORT2") == 0))
		return XD3DVSDT_NORMSHORT2;
	else if((strcmp(strBuff, "D3DVSDT_NORMSHORT3") == 0) ||
			(strcmp(strBuff, "NORMSHORT3") == 0))
		return XD3DVSDT_NORMSHORT3;
	else if((strcmp(strBuff, "D3DVSDT_NORMSHORT4") == 0) ||
			(strcmp(strBuff, "NORMSHORT4") == 0))
		return XD3DVSDT_NORMSHORT4;
	else if((strcmp(strBuff, "D3DVSDT_NORMPACKED3") == 0) ||
			(strcmp(strBuff, "NORMPACKED3") == 0))
		return XD3DVSDT_NORMPACKED3;
	else if((strcmp(strBuff, "D3DVSDT_SHORT1") == 0) ||
			(strcmp(strBuff, "SHORT1") == 0))
		return XD3DVSDT_SHORT1;
	else if((strcmp(strBuff, "D3DVSDT_SHORT3") == 0) ||
			(strcmp(strBuff, "SHORT3") == 0))
		return XD3DVSDT_SHORT3;
	else if((strcmp(strBuff, "D3DVSDT_PBYTE1") == 0) ||
			(strcmp(strBuff, "PBYTE1") == 0))
		return XD3DVSDT_PBYTE1;
	else if((strcmp(strBuff, "D3DVSDT_PBYTE2") == 0) ||
			(strcmp(strBuff, "PBYTE2") == 0))
		return XD3DVSDT_PBYTE2;
	else if((strcmp(strBuff, "D3DVSDT_PBYTE3") == 0) ||
			(strcmp(strBuff, "PBYTE3") == 0))
		return XD3DVSDT_PBYTE3;
	else if((strcmp(strBuff, "D3DVSDT_PBYTE4") == 0) ||
			(strcmp(strBuff, "PBYTE4") == 0))
		return XD3DVSDT_PBYTE4;
	else if((strcmp(strBuff, "D3DVSDT_FLOAT2H") == 0) ||
			(strcmp(strBuff, "FLOAT2H") == 0))
		return XD3DVSDT_FLOAT2H;
	else
		return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\unknown.hpp ===
#ifndef _UNKNOWN_HPP
#define _UNKNOWN_HPP

//===========================================================================
// This template implements the IUnknown portion of a given COM interface.

template <class I> class _unknown : public I
{
private:    long _refcount;

public:        
        _unknown() 
        { 
            _refcount = 1;
        }

        virtual ~_unknown()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == __uuidof(I))
            {
                *ppvObject = static_cast<I*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    


template <class I, class J> class _unknown2 : public I, public J
{
private:    long _refcount;

public:        
        _unknown2() 
        { 
            _refcount = 1;
        }

        virtual ~_unknown2()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(static_cast<I*>(this));
            }
            else if (riid == __uuidof(I))
            {
                *ppvObject = static_cast<I*>(this);
            }
	        else if (riid == __uuidof(J))
            {
                *ppvObject = static_cast<J*>(this);
            }
             else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};

template <class I, class J, class K> class _unknown3 : public I, public J, public K
{
private:    long _refcount;

public:        
        _unknown3() 
        { 
            _refcount = 1;
        }

        virtual ~_unknown3()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(static_cast<I*>(this));
            }
            else if (riid == __uuidof(I))
            {
                *ppvObject = static_cast<I*>(this);
            }
	        else if (riid == __uuidof(J))
            {
                *ppvObject = static_cast<J*>(this);
            }
	        else if (riid == __uuidof(K))
            {
                *ppvObject = static_cast<K*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};


template <class I, class J, class K, class L> class _unknown4 : public I, public J, public K, public L
{
private:    long _refcount;

public:        
        _unknown4() 
        { 
            _refcount = 1;
        }

        virtual ~_unknown4()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(static_cast<I*>(this));
            }
            else if (riid == __uuidof(I))
            {
                *ppvObject = static_cast<I*>(this);
            }
	        else if (riid == __uuidof(J))
            {
                *ppvObject = static_cast<J*>(this);
            }
	        else if (riid == __uuidof(K))
            {
                *ppvObject = static_cast<K*>(this);
            }
 	        else if (riid == __uuidof(L))
            {
                *ppvObject = static_cast<L*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};

#endif _UNKNOWN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\userdata.cpp ===
//-----------------------------------------------------------------------------
// File: UserData.cpp
//
// Desc: Contains the userdata-specific logic for the bundler tool
//
// Hist: 2001.02.06 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "UserData.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CUserData()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CUserData::CUserData( CBundler* pBundler )
{
    m_pBundler     = pBundler;
    m_strSource[0] = '\0';
    m_pData        = NULL;
    m_dwDataSize   = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CUserData()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CUserData::~CUserData()
{
    if( m_pData )
        delete[] m_pData;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    if( 0 == m_strSource[0] )
    {
        m_pBundler->ErrorMsg( "Error: No source specified\n" );
        return E_FAIL;
    }

    // Add the path (if necessary) to the source filename
    CHAR strUserDataFilePath[MAX_PATH];
    if( strchr( m_strSource, ':' ) )
        strcpy( strUserDataFilePath, m_strSource );
    else
    {
        strcpy( strUserDataFilePath, m_pBundler->m_strPath );
        strcat( strUserDataFilePath, m_strSource );
    }

    HANDLE hFile = CreateFileA( strUserDataFilePath, GENERIC_READ, FILE_SHARE_READ,
                                NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        m_pBundler->ErrorMsg( "Error: Could not find userdata source: %s\n", m_strSource );
        return E_FAIL;
    }

    // Allocate memory
    m_dwDataSize = GetFileSize( hFile, NULL );
    m_pData      = new BYTE[8+m_dwDataSize];

    ((DWORD*)m_pData)[0] = 0x80000000;
    ((DWORD*)m_pData)[1] = m_dwDataSize;

    // Read the file
    DWORD dwRead;
    ReadFile( hFile, (BYTE*)m_pData+8, m_dwDataSize, &dwRead, NULL );
    CloseHandle( hFile );

    // Pad data file to proper alignment for the start of the userdata
    hr = m_pBundler->PadToAlignment( USERDATA_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save userdata data
    hr = SaveUserDataData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
/*
    DWORD dwUserDataID = 0x8000000;

    // Write the userdata tag to the resource header
    if( FAILED( m_pBundler->WriteHeader( &dwUserDataID, sizeof(DWORD) ) ) )
        return E_FAIL;

    // Write the userdata size to the resource header
    if( FAILED( m_pBundler->WriteHeader( &m_dwDataSize, sizeof(DWORD) ) ) )
        return E_FAIL;

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( m_pData, m_dwDataSize ) ) )
        return E_FAIL;
*/
    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( m_pData, m_dwDataSize+8 ) ) )
        return E_FAIL;

    (*pcbHeader) = m_dwDataSize+8;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveUserDataData()
// Desc: Saves the raw UserData data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveUserDataData( DWORD* pcbData )
{
    // There shouldn't be any video memory data to write
    (*pcbData) = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\token.cpp ===
//-----------------------------------------------------------------------------
// File: Token.cpp
//
// Desc: Contains the logic for extracting tokens from the resource
//       description file
//
// Hist: 2001.02.06 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Bundler.h"
#include <stdio.h>

/*

// Token defintions
const BUNDLERTOKEN g_Tokens[] =
{
    // Token string         token enumeration                   type            handler function
    { "",                   TOKEN_RESOURCE_EOF,                 TT_ANY,         CBundler::HandleEOFToken        },
//    { "{",                  TOKEN_RESOURCE_OPENBRACE,           TT_ANY,         NULL                            },
//    { "}",                  TOKEN_RESOURCE_CLOSEBRACE,          TT_ANY,         NULL                            },
    { "out_packedresource", TOKEN_RESOURCE_OUT_PACKEDRESOURCE,  TT_ANY,         CBundler::HandleOutPackedResourceToken      },
    { "out_header",         TOKEN_RESOURCE_OUT_HEADER,          TT_ANY,         CBundler::HandleOutHeaderToken  },
    { "out_prefix",         TOKEN_RESOURCE_OUT_PREFIX,          TT_ANY,         CBundler::HandleOutPrefixToken  },
    { "out_error",          TOKEN_RESOURCE_OUT_ERROR,           TT_ANY,         CBundler::HandleOutErrorToken   },

    { "Texture",            TOKEN_RESOURCE_TEXTURE,             TT_ANY,         CBundler::HandleTextureToken    },
    { "Source",             TOKEN_PROPERTY_TEXTURE_SOURCE,      TT_FILENAME,    NULL                            },
    { "AlphaSource",        TOKEN_PROPERTY_TEXTURE_ALPHASOURCE, TT_FILENAME,    NULL                            },
    { "Filter",             TOKEN_PROPERTY_TEXTURE_FILTER,      TT_ANY,         NULL                            },
    { "Format",             TOKEN_PROPERTY_TEXTURE_FORMAT,      TT_IDENTIFIER,  NULL                            },
    { "Width",              TOKEN_PROPERTY_TEXTURE_WIDTH,       TT_INTEGER,     NULL                            },
    { "Height",             TOKEN_PROPERTY_TEXTURE_HEIGHT,      TT_INTEGER,     NULL                            },
    { "Levels",             TOKEN_PROPERTY_TEXTURE_LEVELS,      TT_INTEGER,     NULL                            },
    
    { "Cubemap",            TOKEN_RESOURCE_CUBEMAP,                TT_ANY,         CBundler::HandleCubemapToken    },
    { "SourceXP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_XP,      TT_FILENAME,    NULL                            },
    { "SourceXN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_XN,      TT_FILENAME,    NULL                            },
    { "SourceYP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_YP,      TT_FILENAME,    NULL                            },
    { "SourceYN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_YN,      TT_FILENAME,    NULL                            },
    { "SourceZP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP,      TT_FILENAME,    NULL                            },
    { "SourceZN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN,      TT_FILENAME,    NULL                            },
    { "AlphaSourceXP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP, TT_FILENAME,    NULL                            },
    { "AlphaSourceXN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN, TT_FILENAME,    NULL                            },
    { "AlphaSourceYP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP, TT_FILENAME,    NULL                            },
    { "AlphaSourceYN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN, TT_FILENAME,    NULL                            },
    { "AlphaSourceZP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP, TT_FILENAME,    NULL                            },
    { "AlphaSourceZN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN, TT_FILENAME,    NULL                            },
    { "Size",               TOKEN_PROPERTY_CUBEMAP_SIZE,           TT_INTEGER,     NULL                            },

    { "VolumeTexture",      TOKEN_RESOURCE_VOLUMETEXTURE,             TT_ANY,         CBundler::HandleVolumeTextureToken    },
//    { "Source",             TOKEN_PROPERTY_VOLUMETEXTURE_SOURCE,      TT_FILENAME,    NULL                            },
//    { "AlphaSource",        TOKEN_PROPERTY_VOLUMETEXTURE_ALPHASOURCE, TT_FILENAME,    NULL                            },
    { "Depth",              TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH,       TT_INTEGER,     NULL                            },

    { "VertexBuffer",       TOKEN_RESOURCE_VERTEXBUFFER,        TT_ANY,         CBundler::HandleVertexBufferToken},
    { "VertexData",         TOKEN_PROPERTY_VB_VERTEXDATA,       TT_ANY,         NULL                            },
    { "VertexFormat",       TOKEN_PROPERTY_VB_VERTEXFORMAT,     TT_ANY,         NULL                            },

    { "UserData",           TOKEN_RESOURCE_USERDATA,            TT_ANY,         CBundler::HandleUserDataToken},
    { "DataFile",           TOKEN_PROPERTY_USERDATA_DATAFILE,   TT_ANY,         NULL },
};

*/


//-----------------------------------------------------------------------------
// Name: IsAlphaChar()
// Desc: TRUE for [a-zA-Z]
//-----------------------------------------------------------------------------
BOOL IsAlphaChar( char ch )
{
    return( ( ( ch >= 'a' ) && ( ch <= 'z' ) )  ||
            ( ( ch >= 'A' ) && ( ch <= 'Z' ) ) );
}




//-----------------------------------------------------------------------------
// Name: IsNumberChar()
// Desc: TRUE for [0-9]
//-----------------------------------------------------------------------------
BOOL IsNumberChar( char ch )
{
    return( ( ch >= '0' ) && ( ch <= '9' ) );
}




//-----------------------------------------------------------------------------
// Name: IsIdentifierChar()
// Desc: TRUE for [a-zA-Z0-9_]
//-----------------------------------------------------------------------------
BOOL IsIdentifierChar( char ch )
{
    return( IsAlphaChar( ch )  ||
            IsNumberChar( ch ) ||
            ch == '_' );
}




//-----------------------------------------------------------------------------
// Name: IsHexChar()
// Desc: TRUE for [a-fA-F0-9]
//-----------------------------------------------------------------------------
BOOL IsHexChar( char ch )
{
    return( ( ( ch >= 'a' ) && ( ch <= 'f' ) )  ||
            ( ( ch >= 'A' ) && ( ch <= 'F' ) )  ||
            IsNumberChar( ch ) );
}
            



//-----------------------------------------------------------------------------
// Name: IsWhiteSpaceChar()
// Desc: TRUE for [ \t\r\n]
//-----------------------------------------------------------------------------
BOOL IsWhiteSpaceChar( char ch )
{
    return( ( ch == ' '  ) ||
            ( ch == '\t' ) ||
            ( ch == '\r' ) ||
            ( ch == '\n' ) ||
            ( ch == ','  ) );   // commas are whitespace for this parser
}




//-----------------------------------------------------------------------------
// Name: TerminatesToken()
// Desc: True if next char starts new token or breaks between token
//-----------------------------------------------------------------------------
BOOL TerminatesToken( char ch )
{
    if(IsWhiteSpaceChar( ch )) return TRUE;
    if((ch == '{') ||
       (ch == '}') ||
       (ch == TOKEOF)) return TRUE;

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: IsFilenameChar()
// Desc: TRUE for [^\[\]\:\\/<>\=;,\t\r\n ]
//-----------------------------------------------------------------------------
BOOL IsFilenameChar( char ch )
{
    return( ch != '[' &&
            ch != ']' &&
            ch != ':' &&
            ch != '\\' &&
            ch != '/' &&
            ch != '<' &&
            ch != '>' &&
            ch != '=' &&
            ch != ';' &&
            ch != ',' &&
            ch != '\t' &&
            ch != '\r' &&
            ch != '\n' );
}



/*
//-----------------------------------------------------------------------------
// Name: GetChar()
// Desc: Gets the next character from the input file, removed comments
//-----------------------------------------------------------------------------
CHAR CBundler::GetChar()
{
    DWORD cb;
    CHAR tmp = m_cNext0;
    m_cNext0 = m_cNext1;
    m_cNext1 = m_cNext2;
    m_cNext2 = m_cNext3;
    ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
    if(cb == 0)
        m_cNext3 = TOKEOF;

    if((m_cNext0 == (CHAR)0xff) && (m_cNext1 == (CHAR)0xfe))
    {
        ErrorMsg( "Error: Unicode files are not supported\n");
        return TOKEOF;
    }
    
    while(TRUE)
    {
        // check for // comment
        if((m_cNext2 == '/') && (m_cNext3 == '/'))
        {
            // skip until \n for eof
            while((m_cNext2 != '\n') && (m_cNext2 != TOKEOF))
            {
                m_cNext2 = m_cNext3;
                ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
                if(cb == 0)
                    m_cNext3 = TOKEOF;
            }
        }
        // check for / * comment
        if((m_cNext2 == '/') && (m_cNext3 == '*'))
        {
            // skip until * / or eof
            while(!(((m_cNext2 == '*') && (m_cNext3 == '/')) || (m_cNext2 == TOKEOF)))
            {
                m_cNext2 = m_cNext3;
                ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
                if(cb == 0)
                    m_cNext3 = TOKEOF;
            }
            ReadFile( m_hfRDF, &m_cNext2, 1, &cb, NULL );
            if(cb == 0)
                m_cNext2 = TOKEOF;
            ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
            if(cb == 0)
                m_cNext3 = TOKEOF;
        }
        return tmp;
    }
}




//-----------------------------------------------------------------------------
// Name: PeekChar()
// Desc: Gets the next character from the input file without advancing the read
//       pointer.
//-----------------------------------------------------------------------------
CHAR CBundler::PeekChar()
{
    return m_cNext0;
}




//-----------------------------------------------------------------------------
// Name: GetNextTokenString()
// Desc: Gets the next token from the resource definition file.  
//-----------------------------------------------------------------------------
HRESULT CBundler::GetNextTokenString( char *strTokenString, TOKENTYPE tt )
{
    CHAR *cPtr = strTokenString;
    CHAR c;

    // skip whitespace
    while(IsWhiteSpaceChar(c=GetChar()));
    
    if(c == TOKEOF)
        return S_OK;        // eof

    *cPtr++ = c;

    if((c == '{') ||
       (c == '}'))
        return S_OK;        // single character tokens
    
    while(!TerminatesToken(PeekChar()))
        *cPtr++ = GetChar();

    *cPtr++ = '\0';     // terminate the string

    // Check that it's an appropriate type
    if( FAILED( ValidateType( strTokenString, tt ) ) )
        return E_FAIL;

    return S_OK;
}
*/



//-----------------------------------------------------------------------------
// Name: ValidateIdentifier()
// Desc: Verifies that the token is in the proper form for an identifier:
// ([A-za-z]+[A-Za-z0-9_]*)
//-----------------------------------------------------------------------------
static BOOL ValidateIdentifier( char* strToken )
{
    int i;

    if( !IsAlphaChar( strToken[0] ) )
        return FALSE;

    for( i = 1; strToken[i] != 0; i++ )
    {
        if( !IsIdentifierChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateHexNumber()
// Desc: Verifies that the token is in the proper form for a hex number:
// (0[x|X][0-9A-Fa-f]+)
//-----------------------------------------------------------------------------
static BOOL ValidateHexNumber( char* strToken )
{
    int i;

    if( strToken[0] != '0' )
        return FALSE;
    if( strToken[1] != 'x' &&
        strToken[1] != 'X' )
        return FALSE;
    
    for( i = 2; strToken[i] != 0; i++ )
    {
        if( !IsHexChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateInteger()
// Desc: Verifies that the token is in the proper form for a integer:
// ([-|][0-9]+)
//-----------------------------------------------------------------------------
static BOOL ValidateInteger( char* strToken )
{
    int i = 0;

    if( strToken[0] == '-' )
        i++;

    for( ; strToken[i] != 0; i++ )
    {
        if( !IsNumberChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateFloat()
// Desc: Verifies that the token is in the proper form for a float:
// [-|](([0-9]+(\.[0-9]+|)|\.[0-9]+)([Ee](\+|-|)[0-9]+|))
//-----------------------------------------------------------------------------
static BOOL ValidateFloat( char* strToken )
{
    int i = 0;
    BOOL bDecimal = FALSE;
    BOOL bExponent = FALSE;
    
    if( strToken[0] == '-' )
        i++;

    for( ; strToken[i] != 0; i++ )
    {
        if( strToken[i] == '.' )
        {
            if( bDecimal )
                return FALSE;
            bDecimal = TRUE;
        }
        else if( strToken[i] == 'e' ||
                 strToken[i] == 'E' )
        {
            if( bExponent )
                return FALSE;

            bDecimal = bExponent = TRUE;
            if( strToken[i + 1] == '+' ||
                strToken[i + 1] == '-' )
                i++;
        }
        else if( !IsNumberChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateFilename()
// Desc: Verifies that the token is in the proper form for a filename:
// (([A-Za-z]:|)(\\|/)(\:f(\\|/))*\:f)  where :f is a sequence of filename chars
//-----------------------------------------------------------------------------
static BOOL ValidateFilename( char* strToken )
{
    int i = 0;
    BOOL bLastWasSlash = FALSE;

    if( IsAlphaChar( strToken[0] ) &&
        strToken[1] == ':' )
    {
        i = 2;
    }

    for( ; strToken[i] != 0; i++ )
    {
        if( strToken[i] == '\\' ||
            strToken[i] == '/' )
        {
            bLastWasSlash = TRUE;
            continue;
        }

        if( !IsFilenameChar( strToken[i] ) )
            return FALSE;

        bLastWasSlash = FALSE;
    }

    return !bLastWasSlash;
}




//-----------------------------------------------------------------------------
// Name: ValidateType()
// Desc: Checks to see if the token is of the appropriate type.  If not, 
//       outputs an error message
//-----------------------------------------------------------------------------
HRESULT CBundler::ValidateType( char* strToken, TOKENTYPE tt )
{
    BOOL bValid;

    switch( tt )
    {
		case TT_ANY:
			bValid = TRUE;
			break;
		case TT_IDENTIFIER:
			bValid = ValidateIdentifier( strToken );
			break;
		case TT_HEXNUMBER:
			bValid = ValidateHexNumber( strToken );
			break;
		case TT_INTEGER:
			bValid = ValidateInteger( strToken );
			break;
		case TT_FLOAT:
			bValid = ValidateFloat( strToken );
			break;
		case TT_FILENAME:
			bValid = ValidateFilename( strToken );
			break;
    }

    if( !bValid )
        return E_FAIL;

    return S_OK;
}



/*

//-----------------------------------------------------------------------------
// Name: GetTokenFromString()
// Desc: Finds the token matching the given string
//-----------------------------------------------------------------------------
HRESULT CBundler::GetTokenFromString( char * strTokenString, BUNDLERTOKEN * pTok )
{
    // This lookup could be made faster via binary search or hashing
    for( int i = 0; i < sizeof( g_Tokens ) / sizeof( g_Tokens[0] ); i++ )
    {
        // Do we have a match?
        if( !lstrcmpi( strTokenString, g_Tokens[i].strKeyword ) )
        {
            *pTok = g_Tokens[i];
            return S_OK;
        }
    }

    ErrorMsg( "Unknown token <%s>\n", strTokenString );
    return E_FAIL;
}


//-----------------------------------------------------------------------------
// Name: GetNextToken()
// Desc: Gets the next token from the resource definition file
//-----------------------------------------------------------------------------
HRESULT CBundler::GetNextToken( BUNDLERTOKEN* pTok )
{
    HRESULT hr;
    char strTemp[MAX_PATH];

    ZeroMemory(strTemp, MAX_PATH);   // clear out old token string
    hr = GetNextTokenString( strTemp, TT_ANY );
    if( FAILED( hr ) )
        return hr;

    hr = GetTokenFromString( strTemp, pTok );
    if( FAILED( hr ) )
        return hr;

    return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\VolumeTexture.h ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the volume texture-related functionality of the bundler tool
//
// Hist: 2001.05.25 - New for July XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VOLUMETEXTURE_H
#define VOLUMETEXTURE_H

#include "Texture.h"


typedef CHAR FILENAME[80];

//-----------------------------------------------------------------------------
// Name: class CVolumeTexture
// Desc: Handles all VolumeTexture-specific processing, such as loading slices,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CVolumeTexture : public CBaseTexture
{
    CVolume* m_pVolume;
    CImage** m_apImages;

    HRESULT LoadVolumeTexture();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

public:
    FILENAME* m_astrSource;
    FILENAME* m_astrAlphaSource;
    DWORD     m_dwWidth;
    DWORD     m_dwHeight;
    DWORD     m_dwDepth;

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CVolumeTexture( CBundler* pBundler );
    ~CVolumeTexture();
};


#endif // VOLUMETEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\VolumeTexture.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.cpp
//
// Desc: Contains the VolumeTexture-specific logic for the bundler tool
//
// Hist: 2001.05.25 - New for July XDK release
//       2002.01.31 - Updated to avoid using D3D
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "VolumeTexture.h"
#include "Bundler.h"




//-----------------------------------------------------------------------------
// Name: CVolumeTexture()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CVolumeTexture::CVolumeTexture( CBundler* pBundler )
               :CBaseTexture( pBundler )
{
    m_apImages        = NULL;
    m_pVolume         = NULL;
    m_astrSource      = NULL;
    m_astrAlphaSource = NULL;
    m_dwWidth         = 0L;
    m_dwHeight        = 0L;
    m_dwDepth         = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CVolumeTexture()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CVolumeTexture::~CVolumeTexture()
{
    if( m_apImages )
    {
        for( DWORD i = 0; i < m_dwDepth; i++ )
        {
                delete m_apImages[i];
        }
        delete[] m_apImages;
    }

    delete m_pVolume;

    if( m_astrSource )
        delete[] m_astrSource;
    if( m_astrAlphaSource )
        delete[] m_astrAlphaSource;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    hr = LoadVolumeTexture();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save voleume texture data
    (*pcbData) = 0;

    SaveVolumeTexture( pcbData, m_dwLevels, m_pVolume );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadVolumeTexture()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::LoadVolumeTexture()
{
    HRESULT hr;

    // Try to look up our format string
    m_nFormat = FormatFromString( m_strFormat );
    if( m_nFormat < -1 )
    {
        m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
        return E_FAIL;
    }
    lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );

    // Make sure depth is a power of two for non-linear textures
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_pBundler->ErrorMsg( "Error: Volume textures must be swizzled or compressed.\n" );
        return E_FAIL;
    }

    // Make sure depth is a power of two
    DWORD dwDepth;
    for( dwDepth=1; dwDepth < m_dwDepth; dwDepth<<=1 );
    if( dwDepth != m_dwDepth )
    {
        m_pBundler->ErrorMsg( "Error: Volume texture dimensions must be a power-of-two" );
        return E_FAIL;
    }

    // If an alpha source was specified, make sure the format supports alpha
    for( DWORD i=0; i<m_dwDepth; i++ )
    {
        if( m_astrAlphaSource[i][0] ) 
        {
            if( g_TextureFormats[m_nFormat].dwNumAlphaBits == 0 )
            {
                m_pBundler->ErrorMsg( "Warning: an ALPHASOURCE was specified, yet the " \
                                      "requested texture format, %s,  does not have " \
                                      "any alpha.\n", m_strFormat );
            }
        }
    }

    // Load the image surfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    m_apImages = new CImage*[m_dwDepth];
    for( i = 0; i < m_dwDepth; i++ )
    {
        if( FAILED( hr = LoadImage( m_astrSource[i], m_astrAlphaSource[i], &m_apImages[i] ) ) )
        {
			if( m_astrAlphaSource[i] )
				m_pBundler->ErrorMsg( "Volume texture: Couldn't load source file <%s> or <%s>", m_astrSource[i], m_astrAlphaSource[i] );
			else
				m_pBundler->ErrorMsg( "Volume texture: Couldn't load source file <%s>", m_astrSource[i] );
            return hr;
        }
    }

    // If width or height wasn't specified, use dimensions from first source texture
    if( m_dwWidth==0 || m_dwHeight==0 )
    {
        DWORD dwWidth = m_apImages[0]->m_Width;
        DWORD dwHeight = m_apImages[0]->m_Height;

        // Enforce power-of-two dimensions
        for( m_dwWidth=1;   m_dwWidth  < dwWidth;   m_dwWidth<<=1 );
        for( m_dwHeight=1;  m_dwHeight < dwHeight;  m_dwHeight<<=1 );
    }

    // Keep dimensions in check
    if( m_dwWidth>512 || m_dwHeight>512 || m_dwDepth>512 )
    {
        m_pBundler->ErrorMsg( "Error: The max for volume texture dimensions is 512.\n" );
        return hr;
    }

    // Determine final number of miplevels
    DWORD dwLevels = 1; 
    while( (1UL<<(dwLevels-1)) < min( m_dwWidth, min( m_dwHeight, m_dwDepth ) ) )
        dwLevels++;
    
    if( m_dwLevels < 1 || m_dwLevels > dwLevels )
        m_dwLevels = dwLevels;

    // Change the size of the surfaces
    for( i=0; i<m_dwDepth; i++ )
    {
        hr = ResizeImage( m_dwWidth, m_dwHeight, &m_apImages[i] );
    }

    m_pVolume = new CVolume( m_dwWidth, m_dwHeight, m_dwDepth, D3DFMT_A8R8G8B8 );

    BYTE* pDest = (BYTE *)m_pVolume->m_pData;

    for( i = 0; i < m_dwDepth; i++ )
    {
        memcpy( pDest, m_apImages[i]->m_pData, m_dwWidth * m_dwHeight * sizeof( DWORD ) );
        pDest += m_dwWidth * m_dwHeight * sizeof( DWORD );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader )
{
    XD3DTexture d3dtex;

    XGSetVolumeTextureHeader( m_dwWidth, m_dwHeight, m_dwDepth, m_dwLevels, 0,
                              (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                              D3DPOOL_DEFAULT, (IDirect3DVolumeTexture8*)&d3dtex,
                              dwStart, 0 );

    // Overwrite the error in XGSetVolumeTextureHeader
    {
        for( DWORD LogWidth=0;  (1UL<<LogWidth)  <= m_dwWidth;  LogWidth++ )
        for( DWORD LogHeight=0; (1UL<<LogHeight) <= m_dwHeight; LogHeight++ )
        for( DWORD LogDepth=0;  (1UL<<LogDepth)  <= m_dwDepth;  LogDepth++ )
        d3dtex.Format =  3 << D3DFORMAT_DIMENSION_SHIFT /* UNDONE: verify */
                         | g_TextureFormats[m_nFormat].dwXboxFormat << D3DFORMAT_FORMAT_SHIFT
                         | m_dwLevels << D3DFORMAT_MIPMAP_SHIFT
                         | LogWidth   << D3DFORMAT_USIZE_SHIFT
                         | LogHeight  << D3DFORMAT_VSIZE_SHIFT
                         | LogDepth   << D3DFORMAT_PSIZE_SHIFT
                         | D3DFORMAT_DMACHANNEL_B
                         | D3DFORMAT_BORDERSOURCE_COLOR;
    }

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    (*pcbHeader) = sizeof(d3dtex);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\XBContent.h ===
// XBContent.h: interface for the XBContent class.
//
//////////////////////////////////////////////////////////////////////
#pragma once
#include "unknown.hpp"
#include "bundler.h"
#include "anim.h"

class XBContent : public _unknown2<ISAXContentHandler, ISAXErrorHandler>
{
public:
    XBContent();
    virtual ~XBContent();
	
protected:
	DWORD m_IncludeCount;	// include recursion count
	friend class CBundler;	// expose locator and error routines to bundler
	CBundler *m_pBundler;	// the bundler class writes the compiled .xbr file
	ISAXLocator *m_pLocator;	// current file name and location for error reporting
	bool m_bErrorSuppress;		// used to write error reports just once
	CHAR *m_strTemp;		// temporary string storage returned by CharString
	INT m_cchTemp;			// size of current tempory string buffer
	AnimLink *m_pAnimList;	// list of animations in the current animation block
	AnimVertexShaderParameter *m_pAnimVSPList;	// list of targets for animation
	
	//////////////////////////////////////////////////////////////////////
	// Counts for  resource name generation
	//
	struct {
		DWORD m_Texture;
		DWORD m_Surface;
		DWORD m_CubeTexture;
		DWORD m_VolumeTexture;
		DWORD m_VertexBuffer;
		DWORD m_IndexBuffer;
		DWORD m_VertexShader;
		DWORD m_PixelShader;
		DWORD m_Skeleton;
		DWORD m_Animation;
		DWORD m_Effect;
	} m_Count;
	
	//////////////////////////////////////////////////////////////////////
	// The context determines how the incoming tokens are routed.
	//
	enum Context {
		Root_Context,
		XDX_Context,
		include_Context,
		Texture_Context,
//		Palette_Context,
		Surface_Context,
		CubeTexture_Context,
		VolumeTexture_Context,
		VertexBuffer_Context,
		Vertex_Context,
		IndexBuffer_Context,
		VertexShader_Context,
		VertexShader_decl_Context,
		VertexShader_decl_stream_Context,
		VertexShader_decl_stream_vreg_Context,
		VertexShader_asm_Context,
		VertexShader_Constant_Context,
		PixelShader_Context,
		PixelShader_asm_Context,
		PixelShader_Constant_Context,
		Frame_Context,
		Matrix_Context,
		Matrix_animate_Context,
		Rotate_Context,
		Rotate_animate_Context,
		Scale_Context,
		Scale_animate_Context,
		Translate_Context,
		Translate_animate_Context,
		Effect_Context,
		Pass_Context,
		RenderState_Context,
		TextureState_Context,
		Draw_Context,
	};
#define MAX_CONTEXT 100
	int m_iContext;
	struct StackElement {
		Context m_Context;
		void *m_pData;
	} m_rContextStack[MAX_CONTEXT];

	HRESULT PushContext(Context NewContext)
	{
		if (m_iContext >= MAX_CONTEXT - 1)
			return E_FAIL;
		m_iContext++;
		m_rContextStack[m_iContext].m_Context = NewContext;
		m_rContextStack[m_iContext].m_pData = NULL;
		return S_OK;
	}
	
	HRESULT PopContext()
	{
		if (m_iContext <= 0)
			return E_FAIL;
		// TODO: free m_pData if non-NULL
		m_iContext--;
		return S_OK;
	}

	//////////////////////////////////////////////////////////////////////
	// Parsing helpers
	//
	HRESULT UnexpectedToken(WCHAR *pwchChars, int cchChars, HRESULT errCode);
	HRESULT UnexpectedAttributeToken(WCHAR *pwchLocalName, int cchLocalName,
									 WCHAR *pwchValue, int cchValue,
									 HRESULT errCode);
	HRESULT MustBeWhitespace(WCHAR *pwchChars, int cchChars);
	CHAR *CharString(WCHAR *pwch, int cch, int *pcchOut = NULL);	// converts a string of wide characters to a static string

	
	//////////////////////////////////////////////////////////////////////
	// Animate helpers
	//
	HRESULT animate(AnimCurve *pCurve, ISAXAttributes *pAttributes,
					CONST WCHAR *wstrAttribute);	// if non-NULL, this must match the attribute="name" 
	HRESULT ValidateAnimation(AnimCurve *pCurve,
							  BOOL bWrapAngle);		// do comparisons mod 2 * pi
	
	//////////////////////////////////////////////////////////////////////
	// Handlers
	//
	HRESULT Begin_include(ISAXAttributes *pAttributes);
	HRESULT End_include();
	
	HRESULT BeginCubeTexture(ISAXAttributes *pAttributes);
	HRESULT EndCubeTexture();
	
	HRESULT BeginIndexBuffer(ISAXAttributes *pAttributes);
	HRESULT IndexBufferChars(WCHAR *pwchChars, int cchChars);
	HRESULT EndIndexBuffer();

	HRESULT BeginMatrix(ISAXAttributes *pAttributes);
	HRESULT EndMatrix();
	HRESULT BeginMatrix_animate(ISAXAttributes *pAttributes);
	HRESULT EndMatrix_animate();
	
	HRESULT BeginRotate(ISAXAttributes *pAttributes);
	HRESULT EndRotate();
	HRESULT BeginRotate_animate(ISAXAttributes *pAttributes);
	HRESULT EndRotate_animate();
	
	HRESULT BeginScale(ISAXAttributes *pAttributes);
	HRESULT EndScale();
	HRESULT BeginScale_animate(ISAXAttributes *pAttributes);
	HRESULT EndScale_animate();
	
	HRESULT BeginTranslate(ISAXAttributes *pAttributes);
	HRESULT EndTranslate();
	HRESULT BeginTranslate_animate(ISAXAttributes *pAttributes);
	HRESULT EndTranslate_animate();
	
	HRESULT BeginSurface(ISAXAttributes *pAttributes);
	HRESULT EndSurface();
	
	HRESULT BeginTexture(ISAXAttributes *pAttributes);
	HRESULT TextureChars(WCHAR *pwchChars, int cchChars);
	HRESULT EndTexture();
	
//	HRESULT BeginPalette(ISAXAttributes *pAttributes);
//	HRESULT EndPalette();
	
	HRESULT BeginVertex(ISAXAttributes *pAttributes);
	HRESULT VertexChars(WCHAR *pwchChars, int cchChars);
	HRESULT EndVertex();
	
	HRESULT BeginVertexBuffer(ISAXAttributes *pAttributes);
	HRESULT EndVertexBuffer();
	
	HRESULT BeginVertexShader(ISAXAttributes *pAttributes);
	HRESULT EndVertexShader();

	HRESULT BeginVertexShader_decl(ISAXAttributes *pAttributes);
	HRESULT EndVertexShader_decl();

	HRESULT BeginVertexShader_decl_stream(ISAXAttributes *pAttributes);
	HRESULT EndVertexShader_decl_stream();

	HRESULT BeginVertexShader_decl_stream_vreg(ISAXAttributes *pAttributes);
	HRESULT EndVertexShader_decl_stream_vreg();

	HRESULT BeginVertexShader_asm(ISAXAttributes *pAttributes);
	HRESULT VertexShader_asm_Chars(WCHAR *pwchChars, int cchChars);
	HRESULT EndVertexShader_asm();

	HRESULT BeginVertexShader_Constant(ISAXAttributes *pAttributes);
	HRESULT VertexShader_Constant_Chars(WCHAR *pwchChars, int cchChars);
	HRESULT EndVertexShader_Constant();

	HRESULT BeginPixelShader(ISAXAttributes *pAttributes);
	HRESULT EndPixelShader();

	HRESULT BeginPixelShader_asm(ISAXAttributes *pAttributes);
	HRESULT PixelShader_asm_Chars(WCHAR *pwchChars, int cchChars);
	HRESULT EndPixelShader_asm();

	HRESULT BeginPixelShader_Constant(ISAXAttributes *pAttributes);
	HRESULT PixelShader_Constant_Chars(WCHAR *pwchChars, int cchChars);
	HRESULT EndPixelShader_Constant();

	HRESULT BeginFrame(ISAXAttributes *pAttributes);
	HRESULT EndFrame();
	
	HRESULT BeginEffect(ISAXAttributes *pAttributes);
	HRESULT EndEffect();
	
	HRESULT BeginPass(ISAXAttributes *pAttributes);
	HRESULT EndPass();
	
	HRESULT BeginRenderState(ISAXAttributes *pAttributes);
	HRESULT EndRenderState();
	
	HRESULT BeginTextureState(ISAXAttributes *pAttributes);
	HRESULT EndTextureState();
	
	HRESULT BeginDraw(ISAXAttributes *pAttributes);
	HRESULT EndDraw();
	
	HRESULT BeginXDX(ISAXAttributes *pAttributes);
	HRESULT EndXDX();

	//////////////////////////////////////////////////////////////////////
	// Resource writing
	//
	HRESULT WriteSkeleton(FrameExtra *pFrame);
	HRESULT WriteAnimation(AnimLink *pAnimList);

public:
 
	//////////////////////////////////////////////////////////////////////
	// ISAXContentHandler interface
	//
	virtual HRESULT STDMETHODCALLTYPE putDocumentLocator( 
        /* [in] */ ISAXLocator __RPC_FAR *pLocator);
    
    virtual HRESULT STDMETHODCALLTYPE startDocument( void);
    
    virtual HRESULT STDMETHODCALLTYPE endDocument( void);
    
    virtual HRESULT STDMETHODCALLTYPE startPrefixMapping( 
        /* [in] */ wchar_t __RPC_FAR *pwchPrefix,
        /* [in] */ int cchPrefix,
        /* [in] */ wchar_t __RPC_FAR *pwchUri,
        /* [in] */ int cchUri);
    
    virtual HRESULT STDMETHODCALLTYPE endPrefixMapping( 
        /* [in] */ wchar_t __RPC_FAR *pwchPrefix,
        /* [in] */ int cchPrefix);
    
    virtual HRESULT STDMETHODCALLTYPE startElement( 
        /* [in] */ wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName,
        /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
    
    virtual HRESULT STDMETHODCALLTYPE endElement( 
        /* [in] */ wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName);
    
    virtual HRESULT STDMETHODCALLTYPE characters( 
        /* [in] */ wchar_t __RPC_FAR *pwchChars,
        /* [in] */ int cchChars);
    
    virtual HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
        /* [in] */ wchar_t __RPC_FAR *pwchChars,
        /* [in] */ int cchChars);
    
    virtual HRESULT STDMETHODCALLTYPE processingInstruction( 
        /* [in] */ wchar_t __RPC_FAR *pwchTarget,
        /* [in] */ int cchTarget,
        /* [in] */ wchar_t __RPC_FAR *pwchData,
        /* [in] */ int cchData);
    
    virtual HRESULT STDMETHODCALLTYPE skippedEntity( 
        /* [in] */ wchar_t __RPC_FAR *pwchName,
        /* [in] */ int cchName);

	//////////////////////////////////////////////////////////////////////
	// ISAXErrorHandler interface
	//
	virtual HRESULT STDMETHODCALLTYPE error( 
		/* [in] */ ISAXLocator __RPC_FAR *pLocator,
		/* [in] */ unsigned short * pwchErrorMessage,
		/* [in] */ HRESULT errCode);
	
	virtual HRESULT STDMETHODCALLTYPE fatalError( 
		/* [in] */ ISAXLocator __RPC_FAR *pLocator,
		/* [in] */ unsigned short * pwchErrorMessage,
		/* [in] */ HRESULT errCode);
	
	virtual HRESULT STDMETHODCALLTYPE ignorableWarning( 
		/* [in] */ ISAXLocator __RPC_FAR *pLocator,
		/* [in] */ unsigned short * pwchErrorMessage,
		/* [in] */ HRESULT errCode);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\vb.h ===
//-----------------------------------------------------------------------------
// File: vb.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the vertexbuffer-related functionality of the bundler tool
//
// Hist: 2001.02.06 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VB_H
#define VB_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>
#include "xd3d.h"

class CBundler;

#define MAX_VB_DATA 655360
#define MAX_VB_FORMATS 32


//-----------------------------------------------------------------------------
// Name: class CVertexBuffer
// Desc: Handles all vb-specific processing
//-----------------------------------------------------------------------------
class CVertexBuffer
{
public:
    CVertexBuffer( CBundler * pBundler );
    ~CVertexBuffer();

    HRESULT SaveToBundle( DWORD *pcbHeader, DWORD *pcbData );
    HRESULT AddVertexData( DOUBLE val);
    HRESULT AddVertexFormat( DWORD format);
    HRESULT LoadVertexDataFromFile( CHAR* strFilename );
    static DWORD VertexFormatFromString( CONST CHAR *str );
    DWORD   m_cBytesPerVertex;
    DWORD   m_cInputValuesPerVertex;
    DWORD   m_cVertices;
    DWORD   m_cTotalBytesinVB;

private:
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader );
    HRESULT SaveVertexBufferData( DWORD * pcbData );

    CBundler * m_pBundler;
    DOUBLE m_Data[MAX_VB_DATA];
    DWORD  m_Format[MAX_VB_FORMATS];
// TODO: Have two different format keys to allow data to be input one way and written another
//    DWORD  m_InputFormat[MAX_VB_FORMATS];
//    DWORD  m_OutputFormat[MAX_VB_FORMATS];
    DWORD  m_DataCount;
    DWORD  m_FormatCount;
    BOOL   m_bRawVertices;  // true if data was loaded from file in packed format
};


#endif // VB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\xbrc.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: xbrc.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Defines the entry point for the console application.
//  
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "XBContent.h"

// Global content handler for handling error messages from the bundler library.
XBContent *g_pXBContent = NULL;

int _cdecl main(int argc, char* argv[])
{
    if (argc<2) {
        fprintf(stderr, 
            "Xbox Resource Compiler v0.4\n"
            "\txbrc file.xdx\n"
            "Compiles a file in the XML DirectX format (.xdx)\n"
            "to an Xbox resource file (.xbr) which can be loaded\n"
            "directly into an application or previewed using the\n"
            "xbview tool.\n"
            );
        return -1;
    }

    // Create an instance of the XML parser
    CoInitialize(NULL); 
    ISAXXMLReader* pRdr = NULL;
    HRESULT hr = CoCreateInstance( __uuidof(SAXXMLReader40), NULL, CLSCTX_ALL, __uuidof(ISAXXMLReader), (void **)&pRdr);
    if(FAILED(hr)) 
    {
		if (hr == REGDB_E_CLASSNOTREG)
		{
			fprintf(stderr, "xbrc: Failed to create SAXXMLReader40 instance. Please install msxml4.\nTrying previous version.\n");
			hr = CoCreateInstance( __uuidof(SAXXMLReader), NULL, CLSCTX_ALL, __uuidof(ISAXXMLReader), (void **)&pRdr);
		}
		if (FAILED(hr))
		{
			fprintf(stderr, "xbrc: Failed to create XML reader (error %08X).\n", hr);
			CoUninitialize();
			return hr;
		}
    }

    // Set the XML parser to use our callback routines on the tokens
    g_pXBContent = new XBContent;
    if (g_pXBContent == NULL)
        hr = E_OUTOFMEMORY;
    if (FAILED(hr))
    {
        fprintf(stderr, "xbrc: Failed to create Xbox content parser (error %08X).\n", hr);
        CoUninitialize();
        return hr;
    }
    pRdr->putContentHandler(g_pXBContent);  // the XBContent class supports both the content and error handling
    pRdr->putErrorHandler(g_pXBContent);

    // Parse the input files, including wildcards
    for (int i = 1; i < argc; i++)
    {
        WIN32_FIND_DATA FindFileData;
        HANDLE hFind;
        hFind = FindFirstFile(argv[i], &FindFileData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            fprintf(stderr, "xbrc: Can not find matching files for \"%s\".\n", argv[i]);
            hr = E_FAIL;
            break;
        }
        do {
            const int len = 10000;
            wchar_t URL[len];
            mbstowcs( URL, FindFileData.cFileName, len - 1);
            hr = pRdr->parseURL(URL);
            if (FAILED(hr))
            {
                if (hr == E_ACCESSDENIED)
                    fwprintf(stderr, L"xbrc: Access denied to \"%s\".\n");
                else if (hr == INET_E_OBJECT_NOT_FOUND)
                    fwprintf(stderr, L"xbrc: Object \"%s\" not found.\n", URL);
                else if (hr == INET_E_DOWNLOAD_FAILURE)
                    fwprintf(stderr, L"xbrc: Download failure for \"%s\".\n", URL);
                else
                    fwprintf(stderr, L"xbrc: Parsing document \"%s\" failed with error %08x.\n", URL, hr);
            }
        } while (FindNextFile(hFind, &FindFileData));
        FindClose(hFind);
    }

    // Cleanup
    pRdr->Release();
    CoUninitialize();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\XBContent.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: XBContent.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//  Implementation of the XBContent class.
//  
//-----------------------------------------------------------------------------
#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//

XBContent::XBContent()
{
    m_pBundler = NULL;
    m_iContext = 0;
    m_rContextStack[0].m_Context = Root_Context;
    m_rContextStack[0].m_pData = NULL;
    m_pLocator = NULL;
    m_bErrorSuppress = false;
    m_strTemp = NULL;
    m_cchTemp = 0;
    m_pAnimList = NULL;
    m_pAnimVSPList = NULL;
    m_IncludeCount = 0;
    ZeroMemory(&m_Count, sizeof(m_Count));
}

XBContent::~XBContent()
{
    if (m_pBundler)
        delete m_pBundler;
    if (m_pLocator)
        m_pLocator->Release();
    if (m_strTemp != NULL)
        delete m_strTemp;
}

//////////////////////////////////////////////////////////////////////
// Helper for printing out an error message for an unexpected token 
//
HRESULT XBContent::UnexpectedToken(WCHAR *pwchChars, int cchChars, HRESULT errCode)
{
    const int buflen = 1000;
    WCHAR buf[buflen];
    const int tokenlen = 900;
    WCHAR token[tokenlen];
    if (cchChars >= tokenlen) cchChars = tokenlen-1;
    wcsncpy(token, pwchChars, cchChars);
    token[cchChars] = 0;
    _snwprintf(buf, buflen, L"Unexpected token \"%s\"\n", token);
    fatalError(m_pLocator, buf, errCode);
    m_bErrorSuppress = true;
    return errCode;
}

//////////////////////////////////////////////////////////////////////
// Helper for printing out an error message for an unexpected attribute token 
//
HRESULT XBContent::UnexpectedAttributeToken(WCHAR *pwchLocalName, int cchLocalName,
                                            WCHAR *pwchValue, int cchValue,
                                            HRESULT errCode)
{
    const int buflen = 1000;
    WCHAR buf[buflen];
    const int namelen = 400;
    WCHAR name[namelen];
    const int valuelen = 400;
    WCHAR value[valuelen];
    if (cchLocalName >= namelen) cchLocalName = namelen-1;
    wcsncpy(name, pwchLocalName, cchLocalName);
    name[cchLocalName] = 0;
    if (cchValue >= valuelen) cchValue = valuelen-1;
    wcsncpy(value, pwchValue, cchValue);
    value[cchValue] = 0;
    _snwprintf(buf, buflen, L"Attribute \"%s\" got unexpected token \"%s\"\n", name, value);
    fatalError(m_pLocator, buf, errCode);
    m_bErrorSuppress = true;
    return errCode;
}

//////////////////////////////////////////////////////////////////////
// Helper for making sure that a range of characters are whitespace.
//
HRESULT XBContent::MustBeWhitespace(WCHAR *pwchChars, int cchChars)
{
    for (int i = 0; i < cchChars; i++)
    {
        if (!iswspace(pwchChars[i]))
        {
            // update string pointer and length
            pwchChars += i;
            cchChars -= i;
            const int buflen = 200;
            WCHAR buf[buflen];
            const int tokenlen = 10;
            WCHAR token[tokenlen];
            if (cchChars >= tokenlen) cchChars = tokenlen - 1;
            wcsncpy(token, pwchChars, cchChars);
            token[cchChars] = 0;
            _snwprintf(buf, buflen, L"Non-whitespace character string \"%s\" found in unexpected location.\n", token);
            fatalError(m_pLocator, buf, E_FAIL);
            m_bErrorSuppress = true;
            return E_FAIL;
        }
    }
    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Convert a wide-character string of characters to a null-terminated
// CHAR string. Returns a pointer to a static area.
//
CHAR *XBContent::CharString(WCHAR *pwch, int cch, int *pcchOut)
{
    int cchOut = wcstombs(NULL, pwch, cch);
    if (cchOut >= m_cchTemp)
    {
        if (m_strTemp)
            delete m_strTemp;
        m_cchTemp = cchOut + 1;
        m_strTemp = new CHAR [ m_cchTemp ];
    }
    cchOut = wcstombs(m_strTemp, pwch, cch);
    m_strTemp[cchOut] = 0;  // make sure it's NULL-terminated
    if (pcchOut) *pcchOut = cchOut;
    return m_strTemp;
}

//////////////////////////////////////////////////////////////////////
// include Handler
//
HRESULT XBContent::Begin_include(ISAXAttributes *pAttributes)
{
    m_IncludeCount++;   // include recursion count
#define MAX_INCLUDE_COUNT 100   
    if (m_IncludeCount > MAX_INCLUDE_COUNT) // Catch include loops
        return fatalError(m_pLocator, L"Too many included files.\n", E_FAIL);
    
    const int len = 10000;
    WCHAR URL[len];
    bool bFoundHREF = false;
    
    // Loop through attributes
    int iAttributeCount;
    pAttributes->getLength(&iAttributeCount);
    for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
        WCHAR *pwchLocalName;
        int cchLocalName;
        pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
        WCHAR *pwchValue;
        int cchValue;
        pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
        if (MATCH(href))
        {
            if (cchValue >= len)
                cchValue = len - 1;
            wcsncpy( URL, pwchValue, cchValue );
            URL[cchValue] = 0;  // make sure string is null-terminated
            bFoundHREF = true;
        }
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
    }
    
    if (!bFoundHREF)
        return fatalError(m_pLocator, L"<include> requires \"href\" attribute.\n", E_FAIL);

    // Keep URL for processing 
    WCHAR *strURL = new WCHAR [ wcslen(URL) + 1 ];
    if (strURL == NULL)
        return E_OUTOFMEMORY;
    wcscpy(strURL, URL);
    PushContext(include_Context);
    m_rContextStack[m_iContext].m_pData = strURL;

    return S_OK;
}

HRESULT XBContent::End_include()
{
    HRESULT hr;
    WCHAR *strURL = (WCHAR *)m_rContextStack[m_iContext].m_pData;
    PopContext();
    
    // Start the recursive parsing
    ISAXXMLReader* pRdr = NULL;
    hr = CoCreateInstance( __uuidof(SAXXMLReader), NULL, CLSCTX_ALL, __uuidof(ISAXXMLReader), (void **)&pRdr);
    if(FAILED(hr))
        return fatalError(m_pLocator, L"<include> unable to allocate new reader\n", hr);

    // Set the XML parser to use our callback routines on the tokens
    hr = pRdr->putContentHandler(this); // the XBContent class supports both the content and error handling
    hr = pRdr->putErrorHandler(this);

    // Save the current locator
    ISAXLocator *pLocatorSave = m_pLocator;
    if (pLocatorSave != NULL)
        pLocatorSave->AddRef();

    // Parse the input URL
    hr = pRdr->parseURL(strURL);
	
    // Cleanup
    pRdr->Release();

    // Restore locator
    this->putDocumentLocator(pLocatorSave);
    if (pLocatorSave)
        pLocatorSave->Release();

	// Print message on error
    if (FAILED(hr))
    {
		const int urlmaxlen = 200;
		const int errlen = urlmaxlen + 50;
		wchar_t err[errlen];
		
        if (hr == E_ACCESSDENIED)
            _snwprintf(err, errlen, L"<include> access denied to \"%.*s\".\n", urlmaxlen, strURL);
        else if (hr == INET_E_OBJECT_NOT_FOUND)
            _snwprintf(err, errlen, L"<include> object \"%.*s\" not found.\n", urlmaxlen, strURL);
        else if (hr == INET_E_DOWNLOAD_FAILURE)
            _snwprintf(err, errlen, L"<include> download failure for \"%.*s\".\n", urlmaxlen, strURL);
        else
            _snwprintf(err, errlen, L"<include> parsing document \"%.*s\" failed with error %08x\n", urlmaxlen, strURL, hr);
		
        m_bErrorSuppress = false;    // make sure include error is printed, too.
        return fatalError(m_pLocator, err, hr);
    }
    
    m_IncludeCount--;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CubeTexture Handler
//
HRESULT XBContent::BeginCubeTexture(ISAXAttributes *pAttributes)
{
    PushContext(CubeTexture_Context);
    return S_OK;
}

HRESULT XBContent::EndCubeTexture()
{
    PopContext();
    return S_OK;
}

    

    
//////////////////////////////////////////////////////////////////////
// IndexBuffer Handler
//
HRESULT XBContent::BeginIndexBuffer(ISAXAttributes *pAttributes)
{
    PushContext(IndexBuffer_Context);
    CIndexBuffer *pIB = new CIndexBuffer(m_pBundler);
    if (!pIB) return E_OUTOFMEMORY;
    m_rContextStack[m_iContext].m_pData = pIB;

    // Set default resource id
    m_Count.m_IndexBuffer++;
    CHAR *strIdentifier = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
    _snprintf(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH, "IndexBuffer%d", m_Count.m_IndexBuffer);
    strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH - 1] = 0;

    // Loop through attributes
    int iAttributeCount;
    pAttributes->getLength(&iAttributeCount);
    for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
        WCHAR *pwchLocalName;
        int cchLocalName;
        pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
        WCHAR *pwchValue;
        int cchValue;
        pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
        if (MATCH(id))
        {
            if (cchValue >= BUNDLER_IDENTIFIER_MAX_LENGTH)
                cchValue = BUNDLER_IDENTIFIER_MAX_LENGTH - 1;
		 	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
            strncpy(strIdentifier, CharString(pwchValue, cchValue), cchValue );
            strIdentifier[cchValue] = 0;    // make sure the string is NULL terminated
        }
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
    }

    // Check if identifier is unique
    if ( m_pBundler->IsExistingIdentifier( strIdentifier ) )
    {
        m_pBundler->ErrorMsg( "Second use of identifier \"%s\"", strIdentifier );
        return E_FAIL;
    }
    
    // Defer the save of the index buffer to the bundler until we
    // process all the indices.
    return S_OK;
}

HRESULT XBContent::IndexBufferChars(WCHAR *pwchChars, int cchChars)
{
    CIndexBuffer *pIB = (CIndexBuffer *)m_rContextStack[m_iContext].m_pData;
    if (pIB == NULL) return E_INVALIDARG;
    CHAR *strFull = CharString(pwchChars, cchChars);
    CHAR *strSeparators = " \t\n";
    CHAR *strBuff = strtok(strFull, strSeparators);
    CHAR *pEnd;
    while (strBuff != NULL)
    {
        if (m_pBundler->ValidateType(strBuff, TT_HEXNUMBER) == S_OK
            || m_pBundler->ValidateType(strBuff, TT_INTEGER) == S_OK)
        {
            pIB->AddIndex((WORD)strtoul(strBuff, &pEnd, 0));
            if (*pEnd != '\0')
            {
                m_pBundler->ErrorMsg( "Extra chars \"%s\" on token \"%s\"\n", pEnd, strBuff);
                return E_FAIL;
            }
        }
        else
        {
            m_pBundler->ErrorMsg( "Unrecognized index value \"%s\"\n", strBuff );
            return E_FAIL;
        }

        // Get next token
        strBuff = strtok(NULL, strSeparators);
    }
    return S_OK;
}

HRESULT XBContent::EndIndexBuffer()
{
    CIndexBuffer *pIB = (CIndexBuffer *)m_rContextStack[m_iContext].m_pData;
    if (pIB == NULL) return E_INVALIDARG;
    
    // TODO: save compiled push buffer instead
    
    // Get current offset
    m_pBundler->m_aResources[m_pBundler->m_nResourceCount].dwOffset = m_pBundler->m_cbHeader;

    // Save the IndexBuffer to the bundle
    DWORD cbHeader = 0, cbData = 0;
    HRESULT hr = pIB->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    // Success, so increment the resource count
    printf("IB:  Wrote %s: %d indices (%d bytes, including header)\n",
           m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier, pIB->m_IndexCount, cbHeader);
    m_pBundler->m_nResourceCount++;

    // cleanup
    delete pIB;
    PopContext();
    return S_OK;
}

    
//////////////////////////////////////////////////////////////////////
// Surface Handler
//
HRESULT XBContent::BeginSurface(ISAXAttributes *pAttributes)
{
    PushContext(Surface_Context);
    return E_NOTIMPL;
}

HRESULT XBContent::EndSurface()
{
    PopContext();
    return E_NOTIMPL;
}

    
//////////////////////////////////////////////////////////////////////
// Texture Handler
//
HRESULT XBContent::BeginTexture(ISAXAttributes *pAttributes)
{
    PushContext(Texture_Context);
    CTexture2DFill *ptex = new CTexture2DFill(m_pBundler);
    if (!ptex) return E_OUTOFMEMORY;
    m_rContextStack[m_iContext].m_pData = ptex;
        
    // Set default resource id
    m_Count.m_Texture++;
    CHAR *strIdentifier = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
    _snprintf(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH, "Texture%d", m_Count.m_Texture);
    strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH - 1] = 0;   // make sure the string is NULL terminated
    
    int iAttributeCount;
    pAttributes->getLength(&iAttributeCount);
    for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
        WCHAR *pwchLocalName;
        int cchLocalName;
        pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
        WCHAR *pwchValue;
        int cchValue;
        pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
        if (MATCH(id))
        {
            if (cchValue >= BUNDLER_IDENTIFIER_MAX_LENGTH)
                cchValue = BUNDLER_IDENTIFIER_MAX_LENGTH - 1;
			ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
            strncpy(strIdentifier, CharString(pwchValue, cchValue), cchValue );
            strIdentifier[cchValue] = 0;    // make sure the string is NULL terminated
        }
        else if (MATCH(source))
        {
            strcpy( ptex->m_strSource, CharString(pwchValue, cchValue));
        }
        else if (MATCH(alphasource))
        {
            strcpy( ptex->m_strAlphaSource, CharString(pwchValue, cchValue));
        }
        else if (MATCH(filter))
        {
            ptex->m_dwFilter = m_pBundler->FilterFromString(CharString(pwchValue, cchValue));
        }
        else if (MATCH(format))
        {
            strcpy( ptex->m_strFormat, CharString(pwchValue, cchValue));
        }
        else if (MATCH(width))
        {
            ptex->m_dwWidth = atoi(CharString(pwchValue, cchValue));
        }
        else if (MATCH(height))
        {
            ptex->m_dwHeight = atoi(CharString(pwchValue, cchValue));
        }
        else if (MATCH(levels))
        {
            ptex->m_dwLevels = atoi(CharString(pwchValue, cchValue));
        }
        else if (MATCH(colorkey))
        {
            CHAR *pString = CharString(pwchValue, cchValue);
            CHAR *pEnd;
            ptex->m_ColorKey = strtoul(pString, &pEnd, 0);
        }
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
    }
    
    if ( m_pBundler->IsExistingIdentifier( strIdentifier ) )
    {
        m_pBundler->ErrorMsg( "Second use of identifier \"%s\"", strIdentifier );
        return E_FAIL;
    }
    
    // Defer the save of the texture to the bundler until we
    // process all the Surface elements.  This allows individual
    // mipmap levels to be specified.
    return S_OK;
}

HRESULT XBContent::TextureChars(WCHAR *pwchChars, int cchChars)
{
    CTexture2DFill *pTexture = (CTexture2DFill *)m_rContextStack[m_iContext].m_pData;
    if (pTexture == NULL) return E_INVALIDARG;

    // TODO: Make sure texture does not have a source or alphasource set

    CHAR *strFull = CharString(pwchChars, cchChars);
    CHAR *strSeparators = " \t\n";
    CHAR *strBuff = strtok(strFull, strSeparators);
    CHAR *pEnd;
    while (strBuff != NULL)
    {
        if (m_pBundler->ValidateType(strBuff, TT_HEXNUMBER) == S_OK
            || m_pBundler->ValidateType(strBuff, TT_INTEGER) == S_OK)
        {
            HRESULT hr = pTexture->SetNextTexel((DWORD)strtoul(strBuff, &pEnd, 0));
            if (FAILED(hr))
                return E_FAIL;
            if (*pEnd != '\0')
            {
                m_pBundler->ErrorMsg( "Extra chars \"%s\" on token \"%s\"\n", pEnd, strBuff);
                return E_FAIL;
            }
        }
        else
        {
            m_pBundler->ErrorMsg( "Unrecognized index value \"%s\"\n", strBuff );
            return E_FAIL;
        }

        // Get next token
        strBuff = strtok(NULL, strSeparators);
    }
    return S_OK;
}

HRESULT XBContent::EndTexture()
{
    CTexture2DFill *ptex = (CTexture2DFill *)m_rContextStack[m_iContext].m_pData;
    if (ptex == NULL) return E_INVALIDARG;
    
    // Save the texture to the bundle
    DWORD cbHeader, cbData;
    HRESULT hr = ptex->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Texture: Wrote %s out in format %s (%d bytes)\n", 
           m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier, ptex->m_strFormat, cbData );
    printf("     %d x %d, %d levels\n", ptex->m_dwWidth, ptex->m_dwHeight, ptex->m_dwLevels);

    m_pBundler->m_aResources[m_pBundler->m_nResourceCount++].dwOffset = m_pBundler->m_cbHeader;
    m_pBundler->m_cbHeader += cbHeader;
    //m_pBundler->m_cbData += cbData;

    delete ptex; // Cleanup
    PopContext();
    return S_OK;
}

    
//////////////////////////////////////////////////////////////////////
// Vertex Handler
//
HRESULT XBContent::BeginVertex(ISAXAttributes *pAttributes)
{
    if (m_rContextStack[m_iContext].m_Context != VertexBuffer_Context)
    {
        m_pBundler->ErrorMsg("<v> tag must appear within an enclosing <VertexBuffer>\n");
        return E_FAIL;
    }
    PushContext(Vertex_Context);
    // use same pointer to vertex buffer as enclosing VertexBuffer
    m_rContextStack[m_iContext].m_pData = m_rContextStack[m_iContext-1].m_pData;

    // TODO: check for index attribute and verify that we're writing to the
    // correct index
    
    return S_OK;
}

HRESULT XBContent::VertexChars(WCHAR *pwchChars, int cchChars)
{
    CVertexBuffer *pVB = (CVertexBuffer *)m_rContextStack[m_iContext].m_pData;
    if (pVB == NULL) return E_INVALIDARG;
    CHAR *strFull = CharString(pwchChars, cchChars);
    CHAR *strSeparators = " \t\n";
    CHAR *strBuff = strtok(strFull, strSeparators);
    CHAR *pEnd;
    while (strBuff != NULL)
    {
        if (m_pBundler->ValidateType(strBuff, TT_HEXNUMBER) == S_OK)
        {
            // TODO: add in_format and out_format and make sure the in_format is correct here.
            // For now, we special case hex numbers as the way D3DCOLOR values are entered as packed
            DWORD value = strtoul(strBuff, &pEnd, 16);

            // TODO: check format string for proper type of input
            D3DXCOLOR color(value); // unpack the hex value
            pVB->AddVertexData((DOUBLE)color.r);
            pVB->AddVertexData((DOUBLE)color.g);
            pVB->AddVertexData((DOUBLE)color.b);
            pVB->AddVertexData((DOUBLE)color.a);

            // pVB->AddVertexData((DOUBLE)strtoul(strBuff, &pEnd, 16));
        }
        else if (m_pBundler->ValidateType(strBuff, TT_INTEGER) == S_OK)
        {
            FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
            if (*pEnd != '\0')
            {
                m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
                // leave as just a warning
            }
            pVB->AddVertexData(fValue);
        }
        else if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
        {
            FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
            if (*pEnd != '\0')
            {
                m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
                // leave as just a warning
            }
            pVB->AddVertexData(fValue);
        }
        else
        {
            m_pBundler->ErrorMsg( "Unrecognized vertex value \"%s\"\n", strBuff );
            return E_FAIL;
        }

        // Get next token
        strBuff = strtok(NULL, strSeparators);
    }
    return S_OK;
}

HRESULT XBContent::EndVertex()
{
    // TODO: make sure we have enough data for this vertex before
    // going on to the next one.  Pad if not?
    m_rContextStack[m_iContext].m_pData = NULL;
    PopContext();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// VertexBuffer Handler
//
HRESULT XBContent::BeginVertexBuffer(ISAXAttributes *pAttributes)
{
    PushContext(VertexBuffer_Context);
    CVertexBuffer *pVB = new CVertexBuffer(m_pBundler);
    if (!pVB) return E_OUTOFMEMORY;
    m_rContextStack[m_iContext].m_pData = pVB;

    // Set default resource id
    m_Count.m_VertexBuffer++;
    CHAR *strIdentifier = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
    _snprintf(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH, "VertexBuffer%d", m_Count.m_VertexBuffer);
    strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH - 1] = 0;

    // Loop through attributes
    int iAttributeCount;
    pAttributes->getLength(&iAttributeCount);
    for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
        WCHAR *pwchLocalName;
        int cchLocalName;
        pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
        WCHAR *pwchValue;
        int cchValue;
        pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
        if (MATCH(id))
        {
            if (cchValue >= BUNDLER_IDENTIFIER_MAX_LENGTH)
                cchValue = BUNDLER_IDENTIFIER_MAX_LENGTH - 1;
	     	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
			strncpy(strIdentifier, CharString(pwchValue, cchValue), cchValue );
            strIdentifier[cchValue] = 0;    // make sure the string is NULL terminated
        }
        // TODO: add format_in and format_out so that data can be read one way
        // and written another way.  To make this easier, move the format
        // string parsing somewhere else.
        else if (MATCH(format))
        {
            CHAR *strFull = CharString(pwchValue, cchValue);
            CHAR *strSeparators = " \t\n";
            CHAR *strBuff = strtok(strFull, strSeparators);
            while (strBuff != NULL)
            {
                DWORD VertexFormat = CVertexBuffer::VertexFormatFromString( strBuff );
                if (VertexFormat != -1)
                    pVB->AddVertexFormat(VertexFormat);
                else
                {
                    m_pBundler->ErrorMsg( "Unrecognized vertex format: %s\n", strBuff );
                    return E_FAIL;
                }

                // Get next token
                strBuff = strtok(NULL, strSeparators);
            }
        }
        else if (MATCH(names))
        {
            // TODO: names will be a way to map directly from VB's to VS's, without
            // all that stream(0) stream(1) nonsense.
        }
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
    }

    // Check if identifier is unique
    if ( m_pBundler->IsExistingIdentifier( strIdentifier ) )
    {
        m_pBundler->ErrorMsg( "Second use of identifier \"%s\"", strIdentifier );
        return E_FAIL;
    }
    
    // Defer the save of the vertex buffer to the bundler until we
    // process all the Vertex elements.
    return S_OK;
}

HRESULT XBContent::EndVertexBuffer()
{
    CVertexBuffer *pVB = (CVertexBuffer *)m_rContextStack[m_iContext].m_pData;
    if (pVB == NULL) return E_INVALIDARG;
    
    // Save the vertexbuffer to the bundle
    DWORD cbHeader = 0, cbData = 0;
    HRESULT hr = pVB->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;
    printf("VB:  Wrote %s: %d bytes per vertex, %d vertices (%d bytes)\n", 
           m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier, pVB->m_cBytesPerVertex,
           pVB->m_cVertices, cbData );
    m_pBundler->m_aResources[m_pBundler->m_nResourceCount++].dwOffset = m_pBundler->m_cbHeader;
    m_pBundler->m_cbHeader += cbHeader;
    //m_pBundler->m_cbData += cbData;

    // cleanup
    delete pVB;
    PopContext();
    return S_OK;
}

    
//////////////////////////////////////////////////////////////////////
// XDX Handler
//
HRESULT XBContent::BeginXDX(ISAXAttributes *pAttributes)
{
    HRESULT hr;
    hr = PushContext(XDX_Context);
    if (FAILED(hr))
        return hr;

    // Skip most attribute parsing on included files.
    // TODO: validate version attribute
    if (m_IncludeCount > 0)
        return S_OK;
    
    int iAttributeCount;
    pAttributes->getLength(&iAttributeCount);
    for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
        WCHAR *pwchLocalName;
        int cchLocalName;
        pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
        WCHAR *pwchValue;
        int cchValue;
        pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
        if (MATCH(version))
        {
            // TODO: version validation, reading of old version files, etc.
        }
        else if (MATCH(out_packedresource))
        {
            hr = m_pBundler->SetOutPackedResourceFile( CharString(pwchValue, cchValue) );
            if (FAILED(hr))
                return hr;
        }
        else if (MATCH(out_header))
        {
            hr = m_pBundler->SetOutHeaderFile( CharString(pwchValue, cchValue) );
            if (FAILED(hr))
                return hr;
        }
        else if (MATCH(out_error))
        {
            hr = m_pBundler->SetOutErrorFile( CharString(pwchValue, cchValue) );
            if (FAILED(hr))
                return hr;
        }
        else if (MATCH(out_prefix))
        {
            hr = m_pBundler->SetOutPrefix( CharString(pwchValue, cchValue) );
            if (FAILED(hr))
                return hr;
        }
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
    }
    return S_OK;
}

HRESULT XBContent::EndXDX()
{
    PopContext();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// ISAXContentHandler interface
//

HRESULT STDMETHODCALLTYPE XBContent::putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator
            )
{
    ISAXLocator *pLocatorOld = m_pLocator;
    m_pLocator = pLocator;
    if (m_pLocator)
        m_pLocator->AddRef();
    if (pLocatorOld)
        pLocatorOld->Release();
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE XBContent::startDocument()
{
    if (m_IncludeCount > 0)
        return S_OK;
    if (m_pBundler)
        delete m_pBundler;  // cleanup from last time
    m_pBundler = new CBundler;
    if (m_pBundler == NULL)
        return E_OUTOFMEMORY;

    // Get name from locator
    WCHAR *wstrName;
    HRESULT hr = m_pLocator->getPublicId(&wstrName);
    if (FAILED(hr))
        return hr;
    if (wstrName == NULL 
		|| *wstrName == 0)
    {
        hr = m_pLocator->getSystemId(&wstrName);
        if (FAILED(hr))
            return hr;
    }

    // TODO: make bundler use WCHAR paths
    // Convert wide chars to chars
    int cchOut = wcstombs(NULL, wstrName, _MAX_PATH);
    if (cchOut >= _MAX_PATH)
        return E_FAIL;
    CHAR file[_MAX_PATH];
    cchOut = wcstombs(file, wstrName, _MAX_PATH);
    file[cchOut] = 0;   // make sure it's NULL-terminated

    // Skip over prefix
    CHAR *strFileNoPrefix = file;
    CHAR *strPrefix = "file:///";
    int lenPrefix = strlen(strPrefix);
    if (strncmp(file, strPrefix, lenPrefix) == 0)
	{
        strFileNoPrefix += lenPrefix;

		// If it's a file, replace special URL chars, such as %20
		CHAR *pszSrc = strFileNoPrefix;
		CHAR *pszDst = strFileNoPrefix;
		while (*pszSrc)
		{
			// TODO: add other special chars
			if (*pszSrc == '%'
				&& *(pszSrc + 1) == '2'
				&& *(pszSrc + 2) == '0')
			{
				*pszDst = ' ';
				pszSrc += 3;	// skip %20
				pszDst++;
			}
			else
				*pszDst++ = *pszSrc++;
		}
		*pszDst = 0;
	}
    
    // Strip suffix from name
    CHAR path[_MAX_PATH];
    CHAR drive[_MAX_DRIVE];
    CHAR dir[_MAX_DIR];
    CHAR name[_MAX_PATH];
    CHAR ext[_MAX_EXT];
    _splitpath( strFileNoPrefix, drive, dir, name, ext );
    _makepath( path, drive, dir, name, ""); // .xbr, .h, and .err will be appended by bundler
    
    m_pBundler->Begin(path);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE XBContent::endDocument()
{
    if (m_IncludeCount > 0)
        return S_OK;
    HRESULT hr = m_pBundler->End();
    if (FAILED(hr))
        return hr;
    delete m_pBundler;
    m_pBundler = NULL;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE XBContent::startPrefixMapping( 
            /* [in] */ wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE XBContent::endPrefixMapping( 
            /* [in] */ wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix)
{
    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Route element event based on current context
// 
HRESULT STDMETHODCALLTYPE XBContent::startElement( 
            /* [in] */ wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
    switch (m_rContextStack[m_iContext].m_Context) {
    case Root_Context:
    {
        if (MATCH(XDX))
            return BeginXDX(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case XDX_Context:
    {
        if (MATCH(XDX))
        {
            // XDX context OK for included files only
            if (m_IncludeCount > 0)
                return BeginXDX(pAttributes);
            else
                return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
        }
        else if (MATCH(include))
            return Begin_include(pAttributes);
        else if (MATCH(Texture))
            return BeginTexture(pAttributes);
        else if (MATCH(CubeTexture)
                 || MATCH(CubeMap))
            return BeginCubeTexture(pAttributes);
        else if (MATCH(VertexBuffer))
            return BeginVertexBuffer(pAttributes);
        else if (MATCH(VertexShader))
            return BeginVertexShader(pAttributes);
        else if (MATCH(PixelShader))
            return BeginPixelShader(pAttributes);
        else if (MATCH(IndexBuffer))
            return BeginIndexBuffer(pAttributes);
        else if (MATCH(Surface))
            return BeginSurface(pAttributes);
        else if (MATCH(Frame))
            return BeginFrame(pAttributes);
        
    // TODO: use <Model> for <Effect>'s with bound geometry and
    // <Material> for <Effect>'s with unbound geometry
        else if (MATCH(Effect) || MATCH(Model) || MATCH(Material))
            return BeginEffect(pAttributes);
        
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case include_Context:
    {
        // Include element can have no child elements
        fatalError(m_pLocator, L"<include> must not have child elements.\n", E_FAIL);
        m_bErrorSuppress = true;
        return E_FAIL;
    }
    case Frame_Context:
    {
        if (MATCH(Texture))
            return BeginTexture(pAttributes);
        else if (MATCH(CubeTexture)
                 || MATCH(CubeMap))
            return BeginCubeTexture(pAttributes);
        else if (MATCH(VertexBuffer))
            return BeginVertexBuffer(pAttributes);
        else if (MATCH(VertexShader))
            return BeginVertexShader(pAttributes);
        else if (MATCH(PixelShader))
            return BeginPixelShader(pAttributes);
        else if (MATCH(IndexBuffer))
            return BeginIndexBuffer(pAttributes);
        else if (MATCH(Surface))
            return BeginSurface(pAttributes);
        else if (MATCH(Matrix))
            return BeginMatrix(pAttributes);
        else if (MATCH(Frame))
            return BeginFrame(pAttributes);

    // TODO: see note above
        else if (MATCH(Effect) || MATCH(Model) || MATCH(Material))
            return BeginEffect(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Texture_Context:
    {
        if (MATCH(Surface))
            return BeginSurface(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case CubeTexture_Context:
    {
        if (MATCH(Surface))
            return BeginSurface(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VolumeTexture_Context:
    {
        if (MATCH(Surface))
            return BeginSurface(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexBuffer_Context:
    {
        if (MATCH(v))
            return BeginVertex(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_Context:
    {
        if (MATCH(decl))
            return BeginVertexShader_decl(pAttributes);
        else if (MATCH(asm))
            return BeginVertexShader_asm(pAttributes);
        else if (MATCH(Constant))
            return BeginVertexShader_Constant(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_decl_Context:
    {
        if (MATCH(stream))
            return BeginVertexShader_decl_stream(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_decl_stream_Context:
    {
        if (MATCH(vreg))
            return BeginVertexShader_decl_stream_vreg(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case PixelShader_Context:
    {
        if (MATCH(asm))
            return BeginPixelShader_asm(pAttributes);
        else if (MATCH(Constant))
            return BeginPixelShader_Constant(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Effect_Context:
    {
        if (MATCH(Pass))
            return BeginPass(pAttributes);
        if (MATCH(RenderState))
            return BeginRenderState(pAttributes);
        // Should the following be forced to be outside of the <Effect> scope?
        else if (MATCH(Texture))
            return BeginTexture(pAttributes);
        else if (MATCH(VertexBuffer))
            return BeginVertexBuffer(pAttributes);
        else if (MATCH(IndexBuffer))
            return BeginIndexBuffer(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Pass_Context:
    {
        if (MATCH(RenderState))
            return BeginRenderState(pAttributes);
        else if (MATCH(VertexShader))
            return BeginVertexShader(pAttributes);
        else if (MATCH(PixelShader))
            return BeginPixelShader(pAttributes);
        else if (MATCH(Draw))
            return BeginDraw(pAttributes);
        // Should the following be forced to be outside of the <Pass> scope?
        else if (MATCH(Texture))
            return BeginTexture(pAttributes);
        else if (MATCH(VertexBuffer))
            return BeginVertexBuffer(pAttributes);
        else if (MATCH(IndexBuffer))
            return BeginIndexBuffer(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case RenderState_Context:
    {
        if (MATCH(TextureState))
            return BeginTextureState(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Matrix_Context:
    {
        if (MATCH(animate))
            return BeginMatrix_animate(pAttributes);
        else if (MATCH(Matrix))
            return BeginMatrix(pAttributes);    // general matrix multiply within matrix block
        else if (MATCH(Rotate))
            return BeginRotate(pAttributes);
        else if (MATCH(Scale))
            return BeginScale(pAttributes);
        else if (MATCH(Translate))
            return BeginTranslate(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Rotate_Context:
    {
        if (MATCH(animate))
            return BeginRotate_animate(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Scale_Context:
    {
        if (MATCH(animate))
            return BeginScale_animate(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Translate_Context:
    {
        if (MATCH(animate))
            return BeginTranslate_animate(pAttributes);
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    default:
        return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
#undef MATCH
}


HRESULT STDMETHODCALLTYPE XBContent::endElement( 
            /* [in] */ wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
    // Close current context.
    
    // Since the parser checks to make sure that the end matches the
    // begin, we don't have to check again here.  We do anyway just
    // for a sanity check.
    
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
    switch (m_rContextStack[m_iContext].m_Context)
    {
    case Root_Context:
        break; // unexpected
    case XDX_Context:
        if (MATCH(XDX))
            return EndXDX();
        break;
    case include_Context:
        if (MATCH(include))
        {
            if (m_IncludeCount > 0) // sanity check
                return End_include();
        }
        break;
    case CubeTexture_Context:
        if (MATCH(CubeTexture)
            || MATCH(CubeMap))
            return EndCubeTexture();
        break;
    case VertexBuffer_Context:
        if (MATCH(VertexBuffer))
            return EndVertexBuffer();
        break;
    case IndexBuffer_Context:
        if (MATCH(IndexBuffer))
            return EndIndexBuffer();
        break;
    case Surface_Context:
        if (MATCH(Surface))
            return EndSurface();
        break;
    case Texture_Context:
        if (MATCH(Texture))
            return EndTexture();
        break;
    case Vertex_Context:
        if (MATCH(v))
            return EndVertex();
        break;
    case VertexShader_Context:
    {
        if (MATCH(VertexShader))
            return EndVertexShader();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_decl_Context:
    {
        if (MATCH(decl))
            return EndVertexShader_decl();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_decl_stream_Context:
    {
        if (MATCH(stream))
            return EndVertexShader_decl_stream();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_decl_stream_vreg_Context:
    {
        if (MATCH(vreg))
            return EndVertexShader_decl_stream_vreg();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_asm_Context:
    {
        if (MATCH(asm))
            return EndVertexShader_asm();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case VertexShader_Constant_Context:
    {
        if (MATCH(Constant))
            return EndVertexShader_Constant();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case PixelShader_Context:
    {
        if (MATCH(PixelShader))
            return EndPixelShader();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case PixelShader_asm_Context:
    {
        if (MATCH(asm))
            return EndPixelShader_asm();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case PixelShader_Constant_Context:
    {
        if (MATCH(Constant))
            return EndPixelShader_Constant();
        else
            return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
    }
    case Frame_Context:
        if (MATCH(Frame))
            return EndFrame();
        break;
    case Matrix_Context:
        if (MATCH(Matrix))
            return EndMatrix();
        break;
    case Matrix_animate_Context:
        if (MATCH(animate))
            return EndMatrix_animate();
        break;
    case Rotate_Context:
        if (MATCH(Rotate))
            return EndRotate();
        break;
    case Rotate_animate_Context:
        if (MATCH(animate))
            return EndRotate_animate();
        break;
    case Scale_Context:
        if (MATCH(Scale))
            return EndScale();
        break;
    case Scale_animate_Context:
        if (MATCH(animate))
            return EndScale_animate();
        break;
    case Translate_Context:
        if (MATCH(Translate))
            return EndTranslate();
        break;
    case Translate_animate_Context:
        if (MATCH(animate))
            return EndTranslate_animate();
        break;
    case Effect_Context:
        // TODO: see <Effect> note above
        if (MATCH(Effect) || MATCH(Model) || MATCH(Material))
            return EndEffect();
        break;
    case Pass_Context:
        if (MATCH(Pass))
            return EndPass();
        break;
    case RenderState_Context:
        if (MATCH(RenderState))
            return EndRenderState();
        break;
    case TextureState_Context:
        if (MATCH(TextureState))
            return EndTextureState();
        break;
    case Draw_Context:
        if (MATCH(Draw))
            return EndDraw();
        break;
    }
    return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
}

HRESULT STDMETHODCALLTYPE XBContent::characters( 
            /* [in] */ wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    switch (m_rContextStack[m_iContext].m_Context)
    {
    case Vertex_Context:
        return VertexChars(pwchChars, cchChars);
    case IndexBuffer_Context:
        return IndexBufferChars(pwchChars, cchChars);
    case VertexShader_asm_Context:
        return VertexShader_asm_Chars(pwchChars, cchChars);
    case VertexShader_Constant_Context:
        return VertexShader_Constant_Chars(pwchChars, cchChars);
    case PixelShader_asm_Context:
        return PixelShader_asm_Chars(pwchChars, cchChars);
    case PixelShader_Constant_Context:
        return PixelShader_Constant_Chars(pwchChars, cchChars);
    case Texture_Context:
        return TextureChars(pwchChars, cchChars);
    default:
        return MustBeWhitespace(pwchChars, cchChars);
    }
    return S_OK;
}      
       
HRESULT STDMETHODCALLTYPE XBContent::ignorableWhitespace( 
            /* [in] */ wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    return S_OK;
}
        

HRESULT STDMETHODCALLTYPE XBContent::processingInstruction( 
            /* [in] */ wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE XBContent::skippedEntity( 
            /* [in] */ wchar_t __RPC_FAR *pwchVal,
            /* [in] */ int cchVal)
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// ISAXErrorHandler interface
//

static HRESULT PrintError(WCHAR *pwstrErrorType,
                          ISAXLocator __RPC_FAR *pLocator,
                          unsigned short * pwchErrorMessage,
                          HRESULT errCode)
{
    HRESULT hr;
    if (pLocator)
    {
        int iLine;
        hr = pLocator->getLineNumber(&iLine);
        if (FAILED(hr))
            return hr;
//      int iColumn;
//      hr = pLocator->getColumnNumber(&iColumn);
//      if (FAILED(hr))
//          return hr;
        WCHAR *pwstrID;
        hr = pLocator->getPublicId(&pwstrID);
        if (FAILED(hr))
            return hr;
        if (pwstrID == NULL)
        {
            hr = pLocator->getSystemId(&pwstrID);
            if (FAILED(hr))
                return hr;
        }

        // Strip file prefix so xbrc works better inside of msdev
        WCHAR *pwstrFilePrefix = L"file:///";
        INT FilePrefixLength = wcslen(pwstrFilePrefix);
        if (wcsncmp(pwstrID, pwstrFilePrefix, FilePrefixLength) == 0)
            pwstrID += FilePrefixLength;

//      fwprintf(stderr, L"\n%s(%d) : %s %08X: column %d: %s\n", 
//              pwstrID == NULL ? L"<unknown file>" : pwstrID, iLine, pwstrErrorType, errCode, iColumn, pwchErrorMessage);
        fwprintf(stderr, L"\n%s(%d) : %s %08X: %s\n", 
                 pwstrID == NULL ? L"<unknown file>" : pwstrID, iLine, pwstrErrorType, errCode, pwchErrorMessage);
    }
    else
    {
        // No locator available
        fwprintf(stderr, L"\n%s %08X: %s\n", 
                 pwstrErrorType, errCode, pwchErrorMessage);
    }
    return errCode;
}


HRESULT STDMETHODCALLTYPE XBContent::error( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ unsigned short * pwchErrorMessage,
            /* [in] */ HRESULT errCode)
{
    if (m_bErrorSuppress)
        return errCode;
    return PrintError(L"error", pLocator, pwchErrorMessage, errCode);
}

        
HRESULT STDMETHODCALLTYPE XBContent::fatalError( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ unsigned short * pwchErrorMessage,
            /* [in] */ HRESULT errCode)
{
    if (m_bErrorSuppress)
        return errCode;
    return PrintError(L"fatal error", pLocator, pwchErrorMessage, errCode);
}
        
HRESULT STDMETHODCALLTYPE XBContent::ignorableWarning( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ unsigned short * pwchErrorMessage,
            /* [in] */ HRESULT errCode)
{
    if (m_bErrorSuppress)
        return errCode;
    return PrintError(L"warning", pLocator, pwchErrorMessage, errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\VertexShader.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: VertexShader.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of the XBContent VertexShaders
//-----------------------------------------------------------------------------
#include "stdafx.h"

HRESULT XBContent::BeginVertexShader(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	PushContext(VertexShader_Context);
    CVertexShader *pVS = new CVertexShader(m_pBundler);
	if (!pVS) return E_OUTOFMEMORY;
	m_rContextStack[m_iContext].m_pData = pVS;

	// Set default resource id
	m_Count.m_VertexShader++;
	CHAR *strIdentifier = pVS->m_Identifier;
	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
	_snprintf(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH, "VertexShader%d", m_Count.m_VertexShader);
	strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH - 1] = 0;
	
	// Loop through attributes
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(id))
		{
			if (cchValue >= BUNDLER_IDENTIFIER_MAX_LENGTH)
				cchValue = BUNDLER_IDENTIFIER_MAX_LENGTH - 1;
			ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
			strncpy(strIdentifier, CharString(pwchValue, cchValue), cchValue );
			strIdentifier[cchValue] = 0;	// make sure the string is NULL terminated
		}
		else if (MATCH(idref))
		{
			CHAR *strID = CharString(pwchValue, cchValue);
			DWORD dwResourceIndex;
			if (!m_pBundler->IsExistingIdentifier(strID, &dwResourceIndex))
			{
				m_pBundler->ErrorMsg("Unknown resource \"%s\"\n", strID);
				return E_FAIL;
			}
			// TODO: make sure this is a vertex shader resource
			hr = pVS->SetVertexShaderReference(dwResourceIndex);
			if (FAILED(hr))
				return hr;
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}

	// Check if identifier is unique
	if ( m_pBundler->IsExistingIdentifier( strIdentifier ) )
	{
        m_pBundler->ErrorMsg( "Second use of identifier \"%s\"", strIdentifier );
		return E_FAIL;
	}
	
	// Defer the save of the vertex buffer to the bundler until we
	// process all the VertexShader elements.
	return S_OK;
}

HRESULT XBContent::EndVertexShader()
{
	CVertexShader *pVS = (CVertexShader *)m_rContextStack[m_iContext].m_pData;
	if (pVS == NULL) return E_INVALIDARG;

	// set resource name
	CHAR *strIdentifier = m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier;
	ZeroMemory(strIdentifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
	strncpy(strIdentifier, pVS->m_Identifier, BUNDLER_IDENTIFIER_MAX_LENGTH);
	strIdentifier[BUNDLER_IDENTIFIER_MAX_LENGTH - 1] = 0;	// make sure the string is null terminated
	
	// save current resource offset
    m_pBundler->m_aResources[m_pBundler->m_nResourceCount].dwOffset = m_pBundler->m_cbHeader;
	
    // Save the vertex shader to the bundle
    DWORD cbHeader = 0, cbData = 0;
	HRESULT hr = pVS->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
	{
		delete pVS;
        return hr;
	}
	
    printf("VertexShader:  wrote %s (%d bytes)\n", 
           m_pBundler->m_aResources[m_pBundler->m_nResourceCount].strIdentifier,
		   cbHeader);

	// increment resource count
	m_pBundler->m_nResourceCount++;
	
	// cleanup
    delete pVS;
	PopContext();

	// If we're inside a pass context, save reference to vertex shader
	if (m_rContextStack[m_iContext].m_Context == Pass_Context)
	{
		Effect *pEffect = (Effect *)m_rContextStack[m_iContext].m_pData;
		Pass *pPass = &pEffect->rPass[pEffect->PassCount];
		
		// one-based index (since the resource count was already incremented)
		if (pPass->VertexShaderResource != 0)
			m_pBundler->ErrorMsg("<VertexShader> tag must appear just once within a <Pass> block\n");
		pPass->VertexShaderResource = m_pBundler->m_nResourceCount;
	}
	return S_OK;
}

HRESULT XBContent::BeginVertexShader_decl(ISAXAttributes *pAttributes)
{
	// Sanity check:
	if (m_rContextStack[m_iContext].m_Context != VertexShader_Context)
	{
		m_pBundler->ErrorMsg("<decl> tag must appear within an enclosing <VertexShader>\n");
		return E_FAIL;
	}
	PushContext(VertexShader_decl_Context);
	// use same pointer to vertex shader as enclosing VertexShader
	m_rContextStack[m_iContext].m_pData = m_rContextStack[m_iContext-1].m_pData;
	
	return S_OK;
}

HRESULT XBContent::EndVertexShader_decl()
{
	m_rContextStack[m_iContext].m_pData = NULL;
	PopContext();
	return S_OK;
}

HRESULT XBContent::BeginVertexShader_decl_stream(ISAXAttributes *pAttributes)
{
	HRESULT hr;
	// Sanity check:
	if (m_rContextStack[m_iContext].m_Context != VertexShader_decl_Context)
	{
		m_pBundler->ErrorMsg("<stream> tag must appear within an enclosing <decl>\n");
		return E_FAIL;
	}
	// use same pointer to vertex shader as enclosing decl
	CVertexShader *pVS = (CVertexShader *)m_rContextStack[m_iContext].m_pData;
	PushContext(VertexShader_decl_stream_Context);
	m_rContextStack[m_iContext].m_pData = pVS;

	// Loop through attributes
	UINT StreamIndex = -1;
	INT Stride = 0;
	DWORD dwVertexBufferResourceIndex = -1;
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(index))
		{
			StreamIndex = atoi(CharString(pwchValue, cchValue)); 
		}
		else if (MATCH(idref))
		{
			CHAR *strID = CharString(pwchValue, cchValue);
			if (!m_pBundler->IsExistingIdentifier(strID, &dwVertexBufferResourceIndex))
			{
				m_pBundler->ErrorMsg("Unknown vertex buffer resource \"%s\"\n", strID);
				return E_FAIL;
			}
			// TODO: make sure that it's really a vertex buffer
		}
		else if (MATCH(stride))
		{
			Stride = atoi(CharString(pwchValue, cchValue));
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	if (StreamIndex == -1)
	{
		m_pBundler->ErrorMsg("<stream> tag requires an index attribute\n");
		return E_FAIL;
	}
	else
	{
		hr = pVS->SetStream(StreamIndex);
		if (FAILED(hr))
		{
			m_pBundler->ErrorMsg("Problem with <stream> attribute index=%d\n", StreamIndex);
			return hr;
		}
		if (dwVertexBufferResourceIndex != -1)
		{
			hr = pVS->SetStreamVertexBufferReference(StreamIndex, dwVertexBufferResourceIndex, Stride, 0);
			if (FAILED(hr))
			{
				m_pBundler->ErrorMsg("Problem with <stream> vertex buffer attribute idref=%d stride=%d\n", dwVertexBufferResourceIndex, Stride);
				return hr;
			}
		}
	}
	return S_OK;
}

HRESULT XBContent::EndVertexShader_decl_stream()
{
	m_rContextStack[m_iContext].m_pData = NULL;
	PopContext();
	return S_OK;
}

HRESULT XBContent::BeginVertexShader_decl_stream_vreg(ISAXAttributes *pAttributes)
{
	// Sanity check:
	if (m_rContextStack[m_iContext].m_Context != VertexShader_decl_stream_Context)
	{
		m_pBundler->ErrorMsg("<vreg> tag must appear within an enclosing <stream>\n");
		return E_FAIL;
	}
	// use same pointer to vertex shader as enclosing stream
	CVertexShader *pVS = (CVertexShader *)m_rContextStack[m_iContext].m_pData;
	PushContext(VertexShader_decl_stream_vreg_Context);
	m_rContextStack[m_iContext].m_pData = pVS;

	// Loop through attributes
	UINT iVertexRegister = -1;
	DWORD VertexFormat = -1;
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(index))
		{
			iVertexRegister = atoi(CharString(pwchValue, cchValue));
		}
		else if (MATCH(name))
		{
			// TODO: save name and validate when setting vertex buffer as source for this vertex shader
		}
		else if (MATCH(format))
		{
			CHAR *strFull = CharString(pwchValue, cchValue);
			CHAR *strSeparators = " \t\n";
			CHAR *strBuff = strtok(strFull, strSeparators);
			VertexFormat = CVertexBuffer::VertexFormatFromString( strBuff );
			if (VertexFormat == -1)
			{
				m_pBundler->ErrorMsg("Vertex format <vreg format=\"%s\"> is missing or invalid.\n", strBuff);
				return E_FAIL;
			}
			strBuff = strtok(NULL, strSeparators);
			if (strBuff != NULL)
			{
				m_pBundler->ErrorMsg( "Extra characters in format attribute \"%s\"\n", strBuff );
				return E_FAIL;
			}
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	if (iVertexRegister == -1)
	{
		m_pBundler->ErrorMsg("Vertex register index is missing or invalid.\n");
		return E_FAIL;
	}
	if (VertexFormat == -1)
	{
		m_pBundler->ErrorMsg("Vertex register format is missing or invalid.\n");
		return E_FAIL;
	}
	HRESULT hr = pVS->SetVertexRegisterFormat(iVertexRegister, VertexFormat);
	if (FAILED(hr))
	{
		m_pBundler->ErrorMsg("Unable to set vertex register format (index=%d format=0x%08x)\n",
			iVertexRegister, VertexFormat);
		return hr;
	}
	return S_OK;
}

HRESULT XBContent::EndVertexShader_decl_stream_vreg()
{
	m_rContextStack[m_iContext].m_pData = NULL;
	PopContext();
	return S_OK;
}

#define VERTEXSHADER_ASM_BUFFER_SIZE 10000
struct VertexShader_asm {
	CVertexShader *m_pVS;
	INT m_cchCount;	// number of chars added to buffer
	CHAR m_buf[VERTEXSHADER_ASM_BUFFER_SIZE];

	VertexShader_asm(CVertexShader *pVS)
	{
		m_pVS = pVS;
		m_cchCount = 0;
		m_buf[0] = 0;
	}
};

HRESULT XBContent::BeginVertexShader_asm(ISAXAttributes *pAttributes)
{
	// Sanity check:
	if (m_rContextStack[m_iContext].m_Context != VertexShader_Context)
	{
		m_pBundler->ErrorMsg("<asm> tag must appear within an enclosing <VertexShader>\n");
		return E_FAIL;
	}

	// Make a new asm struct and push the context
	CVertexShader *pVS = (CVertexShader *)m_rContextStack[m_iContext].m_pData;
	VertexShader_asm *pVS_asm = new VertexShader_asm(pVS);
	if (pVS_asm == NULL)
		return E_OUTOFMEMORY;
	PushContext(VertexShader_asm_Context);
	m_rContextStack[m_iContext].m_pData = pVS_asm;

	/*
	// Loop through attributes
	UINT iVertexRegister = -1;
	DWORD VertexFormat = -1;
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(source))
		{
			// TODO: read file in 
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}
	*/
	return S_OK;
}

HRESULT XBContent::VertexShader_asm_Chars(WCHAR *pwchChars, int cchChars)
{
	VertexShader_asm *pVS_asm = (VertexShader_asm *)m_rContextStack[m_iContext].m_pData;
	int cchOut;
	CHAR *strFull = CharString(pwchChars, cchChars, &cchOut);
	if (cchOut + pVS_asm->m_cchCount >= VERTEXSHADER_ASM_BUFFER_SIZE)
		return E_FAIL;
	strcat(pVS_asm->m_buf, strFull);
	pVS_asm->m_cchCount += cchOut;
	return S_OK;
}

extern HRESULT IncludeResolver(
	LPVOID pResolverUserData,
	BOOL isSystemInclude,
	LPCSTR sourceFilePath,
	LPCSTR includeFileName,
	LPSTR resolvedFilePath,
	DWORD resolvedFilePathSize,
	LPXGBUFFER* ppResolvedFile);

HRESULT XBContent::EndVertexShader_asm()
{
	VertexShader_asm *pVS_asm = (VertexShader_asm *)m_rContextStack[m_iContext].m_pData;
	
	// Assemble the shader
	LPXGBUFFER pConstants = NULL;
	LPXGBUFFER pCompiledShader = NULL;
	LPXGBUFFER pErrorLog = NULL;
	LPXGBUFFER pListing = NULL;
	DWORD ShaderType;
	LPCSTR pSourceFileName = "<asm>";
	DWORD dwFlags = 0;
	HRESULT hr = XGAssembleShader(pSourceFileName, pVS_asm->m_buf, pVS_asm->m_cchCount, dwFlags,
								  &pConstants, &pCompiledShader, &pErrorLog, &pListing, IncludeResolver, this, &ShaderType);
	if (FAILED(hr))
	{
		m_pBundler->ErrorMsg("Vertex shader assembling failed.\n%.*s\n", pErrorLog->GetBufferSize(), pErrorLog->GetBufferPointer());
		goto e_Exit;
	}
	if (SASMT_SHADERTYPE(ShaderType) == SASMT_PIXELSHADER)
	{
		m_pBundler->ErrorMsg("Pixel shader specified in vertex shader context.\n");
	}
	if (pCompiledShader)
	{
		// Add function code to VertexShader
		hr = pVS_asm->m_pVS->SetFunction(pCompiledShader->GetBufferPointer(), pCompiledShader->GetBufferSize());
		if (FAILED(hr))
			goto e_Exit;
	}
	if (pConstants)
	{
		// Add constants to vertex shader
		UINT iConstantCount = pConstants->GetBufferSize() / (5 * sizeof(DWORD));
		DWORD *pConstant = (DWORD *)pConstants->GetBufferPointer();
		for (UINT iConstant = 0; iConstant < iConstantCount; iConstant++)
		{
			UINT iConstantRegister = (*pConstant & XD3DVSD_CONSTADDRESSMASK) >> XD3DVSD_CONSTADDRESSSHIFT;
			UINT iCount = (*pConstant & XD3DVSD_CONSTCOUNTMASK) >> XD3DVSD_CONSTCOUNTSHIFT;
			if (iCount != 1)
			{
				m_pBundler->ErrorMsg("Shader constant count %d != 1 is not handled.\n", iCount);
				hr = E_FAIL;
				goto e_Exit;
			}
			pVS_asm->m_pVS->SetConstant(iConstantRegister - 96, pConstant + 1, iCount);
			pConstant += 5;
		}
	}

	// Cleanup
 e_Exit:	
	if (pConstants)
		pConstants->Release();
	if (pCompiledShader)
		pCompiledShader->Release();
	if (pErrorLog)
		pErrorLog->Release();
	if (pListing)
		pListing->Release();
	delete pVS_asm;
	PopContext();
	return hr;
}

#define VERTEXSHADER_CONSTANT_BUFFER_SIZE 2000
struct VertexShader_Constant {
	CVertexShader *m_pVS;
	INT m_iConstantRegister;
	UINT m_iConstantCount;
	INT m_cchCount;	// number of chars added to buffer
	CHAR m_buf[VERTEXSHADER_CONSTANT_BUFFER_SIZE];
	
	VertexShader_Constant(CVertexShader *pVS)
	{
		m_pVS = pVS;
		m_iConstantRegister = 0x7ffffff;
		m_iConstantCount = 1;
		m_cchCount = 0;
		m_buf[0] = 0;
	}
};

HRESULT XBContent::BeginVertexShader_Constant(ISAXAttributes *pAttributes)
{
	// Sanity check:
	if (m_rContextStack[m_iContext].m_Context != VertexShader_Context)
	{
		m_pBundler->ErrorMsg("<Constant> tag must appear within an enclosing <VertexShader>\n");
		return E_FAIL;
	}

	// Make a new Constant struct and push the context
	CVertexShader *pVS = (CVertexShader *)m_rContextStack[m_iContext].m_pData;
	VertexShader_Constant *pVS_Constant = new VertexShader_Constant(pVS);
	if (pVS_Constant == NULL)
		return E_OUTOFMEMORY;
	PushContext(VertexShader_Constant_Context);
	m_rContextStack[m_iContext].m_pData = pVS_Constant;

	// Loop through attributes
	CHAR *strParameter = NULL;
	int iAttributeCount;
	pAttributes->getLength(&iAttributeCount);
	for ( int iAttribute = 0; iAttribute < iAttributeCount; iAttribute++ ) {
		WCHAR *pwchLocalName;
		int cchLocalName;
		pAttributes->getLocalName(iAttribute, &pwchLocalName, &cchLocalName); 
		WCHAR *pwchValue;
		int cchValue;
		pAttributes->getValue(iAttribute, &pwchValue, &cchValue);
#define MATCH(TOKEN) Match(L#TOKEN, pwchLocalName, cchLocalName)
		if (MATCH(index))
		{
			pVS_Constant->m_iConstantRegister = atoi(CharString(pwchValue, cchValue));
		}
		else if (MATCH(name))
		{
			// TODO: use name instead of index to set vertex shader. This will
			// be handy when splicing and reorganizing
		}
		else if (MATCH(count))
		{
			pVS_Constant->m_iConstantCount = atoi(CharString(pwchValue, cchValue));
		}
		else if (MATCH(parameter))
		{
			// Save parameter string for process after the index and
			// count attributes are set.
			CHAR *str = CharString(pwchValue, cchValue);
			strParameter = new CHAR [ strlen(str) + 1 ];
			if (strParameter == NULL)
				return E_OUTOFMEMORY;
			strcpy(strParameter, str);
		}
		else
			return UnexpectedToken(pwchLocalName, cchLocalName, E_FAIL);
#undef MATCH
	}

	if (strParameter)
	{
		// Add this constant to the list of things that need to be updated
		// during the SetTime phase.
		AnimVertexShaderParameter *pAnimVSP = new AnimVertexShaderParameter;
		if (pAnimVSP == NULL)
			return E_OUTOFMEMORY;
		pAnimVSP->m_strVertexShaderReference = new CHAR [ strlen(pVS->m_Identifier) + 1 ];
		if (pAnimVSP->m_strVertexShaderReference == NULL)
			return E_OUTOFMEMORY;
		strcpy(pAnimVSP->m_strVertexShaderReference, pVS->m_Identifier);
		pAnimVSP->m_Index = pVS_Constant->m_iConstantRegister;
		pAnimVSP->m_Count = pVS_Constant->m_iConstantCount;
		pAnimVSP->m_strExpression = strParameter;	// allocated above
		strParameter = NULL;
		pAnimVSP->m_pSource = NULL;

		// Add to head of animated vertex shader parameter list
		pAnimVSP->m_pNext = m_pAnimVSPList;
		m_pAnimVSPList = pAnimVSP;

		// TODO: What about effects whose parameters change during
		// the skeleton traversal?  Perhaps the SetTime should be right
		// before rendering with this vertex shader. In other words,
		// the parameter evaluation happens at the same time as the
		// SetVertexShader.  This would be pretty easy to compile in
		// as push buffer fixups.
	}
	return S_OK;
}

HRESULT XBContent::VertexShader_Constant_Chars(WCHAR *pwchChars, int cchChars)
{
	VertexShader_Constant *pVS_Constant = (VertexShader_Constant *)m_rContextStack[m_iContext].m_pData;
	int cchOut;
	CHAR *strFull = CharString(pwchChars, cchChars, &cchOut);
	if (cchOut + pVS_Constant->m_cchCount >= VERTEXSHADER_CONSTANT_BUFFER_SIZE)
		return E_FAIL;
	strcat(pVS_Constant->m_buf, strFull);
	pVS_Constant->m_cchCount += cchOut;
	return S_OK;
}

HRESULT XBContent::EndVertexShader_Constant()
{
	HRESULT hr = S_OK;
	VertexShader_Constant *pVS_Constant = (VertexShader_Constant *)m_rContextStack[m_iContext].m_pData;
	
	// Add constants to vertex shader
	INT iConstantRegister = pVS_Constant->m_iConstantRegister;
	UINT iConstantCount = 0;
	FLOAT rConstantValue[4];
	UINT iConstantValueIndex = 0;
	CHAR *strSeparators = " \t\n";
	CHAR *strBuff = strtok(pVS_Constant->m_buf, strSeparators);
	CHAR *pEnd;
	while (strBuff != NULL)
	{
		if (m_pBundler->ValidateType(strBuff, TT_FLOAT) == S_OK)
		{
			FLOAT fValue = (FLOAT)strtod(strBuff, &pEnd);
			if (*pEnd != '\0')
			{
				m_pBundler->ErrorMsg( "Extra chars \"%s\" on value \"%s\".\n", pEnd, strBuff);
				// leave as just a warning
			}
			rConstantValue[iConstantValueIndex++] = fValue;
			if (iConstantValueIndex == 4)
			{
				// Every 4 values we add a new constant
				iConstantValueIndex = 0;
				if (iConstantCount >= pVS_Constant->m_iConstantCount)
				{
					m_pBundler->ErrorMsg("Warning: too many constant values (%d > %d) between <Constant> ... </Constant>.\n",
										 iConstantCount + 1, pVS_Constant->m_iConstantCount);
					goto e_Exit;
				}
				hr = pVS_Constant->m_pVS->SetConstant(iConstantRegister + iConstantCount, rConstantValue, 1);
				if (FAILED(hr))
				{
					m_pBundler->ErrorMsg("Could not set constant register %d.\n", iConstantRegister + iConstantCount);
					goto e_Exit;
				}
				iConstantCount++;
			}
		}
		else
		{
			m_pBundler->ErrorMsg( "Unrecognized constant value \"%s\"\n", strBuff );
			hr = E_FAIL;
			goto e_Exit;
		}

		// Get next token
		strBuff = strtok(NULL, strSeparators);
	}
	if (iConstantValueIndex != 0)
	{
		m_pBundler->ErrorMsg("Warning: extra data skipped in <Constant>\n");
	}
	if (iConstantCount != pVS_Constant->m_iConstantCount)
	{
		m_pBundler->ErrorMsg("Warning: missing constant values (found %d out of %d) <Constant>\n",
							 iConstantCount, pVS_Constant->m_iConstantCount);
	}
 e_Exit:

	// Cleanup
	delete pVS_Constant;
	PopContext();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\effect.h ===
//-----------------------------------------------------------------------------
//  
//  File: effect.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//  An effect is a collection of rendering passes.  Each pass needs
//  vertex shaders (programs and constants), pixel shaders (programs
//  and constants), render states (including texture states),
//  textures, vertex buffers, index buffers, and draw lists.
//  
//-----------------------------------------------------------------------------
#pragma once

#define VERTEXSHADER_MAX_STREAMS 16
struct VertexShader {
	DWORD Handle;
	DWORD DeclarationByteCount;		// size of Declaration
	DWORD *Declaration;				// the declaration maps streams to vertex registers, and defines constants
	DWORD FunctionByteCount;		// size of Function
	DWORD *Function;				// function microcode maps vertex registers to transformed vertices
	DWORD VertexShaderReference;
	struct StreamInput {
		DWORD VertexBufferReference;
		DWORD Stride;
		DWORD Offset;
	} rStreamInput[VERTEXSHADER_MAX_STREAMS];
};

// PixelShader structure is same as D3DPIXELSHADERDEF

struct RenderState {
	DWORD State;
	DWORD Value;
};

struct TextureState {
	DWORD State;
	DWORD Value;
};

struct TextureStage {
	DWORD TextureResource;
	DWORD TextureStateCount;
	TextureState *rTextureState;
};

struct Draw {
	DWORD IndexBufferResource;
	DWORD Primitive;
	DWORD Start;
	DWORD Count;
};

struct Pass {
	DWORD VertexShaderResource;
	DWORD PixelShaderResource;	// TODO: Consider inlining the pixel shader definition
	DWORD RenderStateCount;
	RenderState *rRenderState;
	DWORD TextureStageCount;
	TextureStage *rTextureStage;
	DWORD DrawCount;
	Draw *rDraw;
};

#define EFFECT_IDENTIFIER_SIZE 128
struct Effect {
	CHAR Identifier[EFFECT_IDENTIFIER_SIZE];
	DWORD RenderTargetResource;
	DWORD PassCount;
	Pass *rPass;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\xd3d.h ===
//-----------------------------------------------------------------------------
//  
//  File: xd3d.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h
//  
//-----------------------------------------------------------------------------
#pragma once
 
#define XD3DVERTEXBUFFER_ALIGNMENT     4
#define XD3DINDEXBUFFER_ALIGNMENT        4      
#define XD3DPUSHBUFFER_ALIGNMENT 4

#define XD3DPS_CONSTREG_MAX 8

#define XD3DVS_CONSTREG_COUNT		192
#define XD3DVS_STREAMS_MAX         	16
#define XD3DVS_INPUTREG_MAX         16

#define XD3DPUSHBUFFER_RUN_USING_CPU_COPY  0x80000000

#define XD3DCOMMON_TYPE_SHIFT         16
#define XD3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define XD3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define XD3DCOMMON_TYPE_PUSHBUFFER    0x00020000
#define XD3DCOMMON_TYPE_PALETTE       0x00030000
#define XD3DCOMMON_TYPE_TEXTURE       0x00040000
#define XD3DCOMMON_TYPE_SURFACE       0x00050000

#define XD3DERR_BUFFERTOOSMALL		MAKE_D3DHRESULT(2089) // Xbox extension

typedef enum _XD3DPRIMITIVETYPE {
    XD3DPT_POINTLIST             = 1,
    XD3DPT_LINELIST              = 2,
    XD3DPT_LINELOOP              = 3,  // Xbox extension
    XD3DPT_LINESTRIP             = 4,
    XD3DPT_TRIANGLELIST          = 5,
    XD3DPT_TRIANGLESTRIP         = 6,
    XD3DPT_TRIANGLEFAN           = 7,
    XD3DPT_QUADLIST              = 8,  // Xbox extension
    XD3DPT_QUADSTRIP             = 9,  // Xbox extension
    XD3DPT_POLYGON               = 10, // Xbox extension

    XD3DPT_MAX                   = 11,
    XD3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} XD3DPRIMITIVETYPE;

typedef enum _XD3DVSD_TOKENTYPE
{
    XD3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    XD3DVSD_TOKEN_STREAM,            // stream selector
    XD3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    XD3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    XD3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    XD3DVSD_TOKEN_EXT,               // extension
    XD3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    XD3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} XD3DVSD_TOKENTYPE;

#define XD3DVSD_TOKENTYPESHIFT   29
#define XD3DVSD_TOKENTYPEMASK    (7 << XD3DVSD_TOKENTYPESHIFT)

#define XD3DVSD_STREAMNUMBERSHIFT 0
#define XD3DVSD_STREAMNUMBERMASK (0xF << XD3DVSD_STREAMNUMBERSHIFT)

#define XD3DVSD_DATALOADTYPESHIFT 28
#define XD3DVSD_DATALOADTYPEMASK (0x1 << XD3DVSD_DATALOADTYPESHIFT)

#define XD3DVSD_DATATYPESHIFT 16
#define XD3DVSD_DATATYPEMASK (0xFF << XD3DVSD_DATATYPESHIFT)

#define XD3DVSD_SKIPCOUNTSHIFT 16
#define XD3DVSD_SKIPCOUNTMASK (0xF << XD3DVSD_SKIPCOUNTSHIFT)

#define XD3DVSD_VERTEXREGSHIFT 0
#define XD3DVSD_VERTEXREGMASK (0x1F << XD3DVSD_VERTEXREGSHIFT)

#define XD3DVSD_VERTEXREGINSHIFT 20
#define XD3DVSD_VERTEXREGINMASK (0xF << XD3DVSD_VERTEXREGINSHIFT)

#define XD3DVSD_CONSTCOUNTSHIFT 25
#define XD3DVSD_CONSTCOUNTMASK (0xF << XD3DVSD_CONSTCOUNTSHIFT)

#define XD3DVSD_CONSTADDRESSSHIFT 0
#define XD3DVSD_CONSTADDRESSMASK (0xFF << XD3DVSD_CONSTADDRESSSHIFT)

#define XD3DVSD_CONSTRSSHIFT 16
#define XD3DVSD_CONSTRSMASK (0x1FFF << XD3DVSD_CONSTRSSHIFT)

#define XD3DVSD_EXTCOUNTSHIFT 24
#define XD3DVSD_EXTCOUNTMASK (0x1F << XD3DVSD_EXTCOUNTSHIFT)

#define XD3DVSD_EXTINFOSHIFT 0
#define XD3DVSD_EXTINFOMASK (0xFFFFFF << XD3DVSD_EXTINFOSHIFT)

#define XD3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << XD3DVSD_TOKENTYPESHIFT) & XD3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define XD3DVSD_STREAM( _StreamNumber ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define XD3DVSD_STREAMTESSSHIFT 28
#define XD3DVSD_STREAMTESSMASK (1 << XD3DVSD_STREAMTESSSHIFT)
#define XD3DVSD_STREAM_TESS( ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_STREAM) | (XD3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..26] address of the vertex register
// _Type [XD3DVSDT_*] dimensionality and arithmetic data type

#define XD3DVSD_REG( _VertexRegister, _Type ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << XD3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define XD3DVSD_SKIP( _DWORDCount ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << XD3DVSD_SKIPCOUNTSHIFT))

// Skip _BYTECount BYTEs in vertex (Xbox extension)
//
#define XD3DVSD_SKIPBYTES( _BYTECount ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_STREAMDATA) | 0x18000000 | \
     ((_BYTECount) << XD3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [-96..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define XD3DVSD_CONST( _ConstantAddress, _Count ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << XD3DVSD_CONSTCOUNTSHIFT) | ((_ConstantAddress) + 96))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define XD3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << XD3DVSD_VERTEXREGINSHIFT) | \
     (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define XD3DVSD_TESSUV( _VertexRegister ) \
    (XD3DVSD_MAKETOKENTYPE(XD3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     (_VertexRegister))

// Generates END token
//
#define XD3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define XD3DVSD_NOP() 0x00000000

// Vertex attribute formats
#define XD3DVSDT_FLOAT1      0x12    // 1D float expanded to (value, 0., 0., 1.)
#define XD3DVSDT_FLOAT2      0x22    // 2D float expanded to (value, value, 0., 1.)
#define XD3DVSDT_FLOAT3      0x32    // 3D float expanded to (value, value, value, 1.)
#define XD3DVSDT_FLOAT4      0x42    // 4D float
#define XD3DVSDT_D3DCOLOR    0x40    // 4D packed unsigned bytes mapped to 0. to 1. range
#define XD3DVSDT_SHORT2      0x25    // 2D signed short expanded to (value, value, 0., 1.)
#define XD3DVSDT_SHORT4      0x45    // 4D signed short
#define XD3DVSDT_NORMSHORT1  0x11    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
#define XD3DVSDT_NORMSHORT2  0x21    // 2D signed, normalized short expanded to (value, value, 0., 1.)
#define XD3DVSDT_NORMSHORT3  0x31    // 3D signed, normalized short expanded to (value, value, value, 1.)  
#define XD3DVSDT_NORMSHORT4  0x41    // 4D signed, normalized short expanded to (value, value, value, value)  
#define XD3DVSDT_NORMPACKED3 0x16    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
#define XD3DVSDT_SHORT1      0x15    // 1D signed short expanded to (value, 0., 0., 1.)  
#define XD3DVSDT_SHORT3      0x35    // 3D signed short expanded to (value, value, value, 1.)
#define XD3DVSDT_PBYTE1      0x14    // 1D packed byte expanded to (value, 0., 0., 1.)  
#define XD3DVSDT_PBYTE2      0x24    // 2D packed byte expanded to (value, value, 0., 1.)
#define XD3DVSDT_PBYTE3      0x34    // 3D packed byte expanded to (value, value, value, 1.)
#define XD3DVSDT_PBYTE4      0x44    // 4D packed byte expanded to (value, value, value, value) 
#define XD3DVSDT_FLOAT2H     0x72    // 2D homogeneous float expanded to (value, value,0., value.)

// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h
#define X_D3DFMT_A8R8G8B8              0x00000006
#define X_D3DFMT_X8R8G8B8              0x00000007
#define X_D3DFMT_R5G6B5                0x00000005
#define X_D3DFMT_R6G5B5                0x00000027
#define X_D3DFMT_X1R5G5B5              0x00000003
#define X_D3DFMT_A1R5G5B5              0x00000002
#define X_D3DFMT_A4R4G4B4              0x00000004
#define X_D3DFMT_A8                    0x00000019
#define X_D3DFMT_A8B8G8R8              0x0000003A   
#define X_D3DFMT_B8G8R8A8              0x0000003B   
#define X_D3DFMT_R4G4B4A4              0x00000039   
#define X_D3DFMT_R5G5B5A1              0x00000038   
#define X_D3DFMT_R8G8B8A8              0x0000003C   
#define X_D3DFMT_R8B8                  0x00000029   
#define X_D3DFMT_G8B8                  0x00000028   
#define X_D3DFMT_P8                    0x0000000B
#define X_D3DFMT_L8                    0x00000000
#define X_D3DFMT_A8L8                  0x0000001A
#define X_D3DFMT_AL8                   0x00000001   
#define X_D3DFMT_L16                   0x00000032   
#define X_D3DFMT_V8U8                  0x00000028
#define X_D3DFMT_L6V5U5                0x00000027
#define X_D3DFMT_X8L8V8U8              0x00000007
#define X_D3DFMT_Q8W8V8U8              0x0000003A
#define X_D3DFMT_V16U16                0x00000033
#define X_D3DFMT_DXT1                  0x0000000C
#define X_D3DFMT_DXT2                  0x0000000E
#define X_D3DFMT_DXT3                0x0000000E // Not valid on Xbox
#define X_D3DFMT_DXT4                  0x0000000F
#define X_D3DFMT_DXT5                0x0000000F // Not valid on Xbox
#define X_D3DFMT_LIN_A1R5G5B5          0x00000010   
#define X_D3DFMT_LIN_A4R4G4B4          0x0000001D   
#define X_D3DFMT_LIN_A8                0x0000001F   
#define X_D3DFMT_LIN_A8B8G8R8          0x0000003F   
#define X_D3DFMT_LIN_A8R8G8B8          0x00000012   
#define X_D3DFMT_LIN_B8G8R8A8          0x00000040   
#define X_D3DFMT_LIN_G8B8              0x00000017   
#define X_D3DFMT_LIN_R4G4B4A4          0x0000003E   
#define X_D3DFMT_LIN_R5G5B5A1          0x0000003D   
#define X_D3DFMT_LIN_R5G6B5            0x00000011   
#define X_D3DFMT_LIN_R6G5B5            0x00000037   
#define X_D3DFMT_LIN_R8B8              0x00000016   
#define X_D3DFMT_LIN_R8G8B8A8          0x00000041   
#define X_D3DFMT_LIN_X1R5G5B5          0x0000001C   
#define X_D3DFMT_LIN_X8R8G8B8          0x0000001E   
#define X_D3DFMT_LIN_A8L8              0x00000020   
#define X_D3DFMT_LIN_AL8               0x0000001B   
#define X_D3DFMT_LIN_L16               0x00000035   
#define X_D3DFMT_LIN_L8                0x00000013   
#define X_D3DFMT_LIN_V16U16            0x00000036
#define X_D3DFMT_LIN_V8U8              0x00000017
#define X_D3DFMT_LIN_L6V5U5            0x00000037
#define X_D3DFMT_LIN_X8L8V8U8          0x0000001E
#define X_D3DFMT_LIN_Q8W8V8U8          0x00000012

#define D3DTEXTURE_ALIGNMENT            128

#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001
#define D3DFORMAT_DMACHANNEL_B          0x00000002

#define D3DFORMAT_CUBEMAP               0x00000004
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000
#define D3DFORMAT_PSIZE_SHIFT           28

#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
// #define D3DCOMMON_VIDEOMEMORY        0x00800000

#define D3DTEXTURE_PITCH_ALIGNMENT   64


// Texture Resource Format
struct XD3DTexture
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;
};

struct XD3DVertexBuffer
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
};

struct XD3DIndexBuffer {
    DWORD Common;                    
    DWORD Data;
    DWORD Lock;
};

struct XD3DPushBuffer
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Size; 			// Size, in bytes, of the push-buffer program.
    DWORD AllocationSize;   // Size, in bytes, of the allocation of the buffer pointed to by 'Data'.
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\anim.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: anim.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//  Key frame animation based on SkinnedMesh DirectX sample.
//-----------------------------------------------------------------------------
#include "anim.h"

//////////////////////////////////////////////////////////////////////
// Look up keys based on local time
//
HRESULT AnimCurve::FindKeys(float fLocalTime, UINT *piKey1, UINT *piKey2, FLOAT *pfLerpValue) CONST
{
    UINT iKey;
    UINT iKey1;
    UINT iKey2;
	iKey1 = iKey2 = 0;
	FLOAT fTime = (float)fmod(fLocalTime, m_rKeyTimes[m_KeyCount-1]);
	if (fTime < 0.f) fTime += m_rKeyTimes[m_KeyCount-1];
	for (iKey = 0 ;iKey < m_KeyCount ; iKey++)
	{
		if (m_rKeyTimes[iKey] > fTime)
		{
			iKey2 = iKey;
			
			if (iKey > 0)
			{
				iKey1= iKey - 1;
			}
			else  // when iKey == 0, then iKey1 == 0
			{
				iKey1 = iKey;
			}
			
			break;
		}
	}
	FLOAT fTime1 = (float)m_rKeyTimes[iKey1];
	FLOAT fTime2 = (float)m_rKeyTimes[iKey2];
	FLOAT fLerpValue;
	if ((fTime2 - fTime1) ==0)
		fLerpValue = 0;
	else
		fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);
	
	*piKey1 = iKey1;
	*piKey2 = iKey2;
	*pfLerpValue = fLerpValue;
	return S_OK;
}
	
//////////////////////////////////////////////////////////////////////
// Find the bracketing key times, then lerp the values
//
HRESULT AnimCurve::Sample(FLOAT fLocalTime, FLOAT *rfValue) CONST
{
	if (m_KeyCount == 0)
		return E_FAIL;
	if (m_KeyCount == 1)
	{
		for (UINT iValue = 0; iValue < m_KeySize; iValue++)
			rfValue[iValue] = m_rKeys[iValue];
		return S_OK;
	}
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	HRESULT hr = FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	if (FAILED(hr))
		return hr;
	FLOAT *rfKey1 = m_rKeys + iKey1 * m_KeySize;
	FLOAT *rfKey2 = m_rKeys + iKey2 * m_KeySize;
	for (UINT iValue = 0; iValue < m_KeySize; iValue++)
		rfValue[iValue] = rfKey1[iValue] + fLerpValue * (rfKey2[iValue] - rfKey1[iValue]);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Look up matrix key based on local time
//
HRESULT AnimMatrix::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
    if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		D3DXMatrixIdentity(pMatrix);
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		memcpy(&pMatrix->m[0][0], m_curve.m_rKeys, 16 * sizeof(FLOAT));
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey, iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	
	// Instead of lerping between the matrices, switch
	// to the next matrix when past the half-way mark.
	if (fLerpValue > 0.5)
	{
		iKey = iKey2;
	}
	else
	{
		iKey = iKey1;
	}
	memcpy(&pMatrix->m[0][0], m_curve.m_rKeys + 16 * iKey, 16 * sizeof(FLOAT));
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Interpolate between nearest rotate keys
//
HRESULT AnimRotate::SetTime(D3DXQUATERNION *pQuaternion, float fGlobalTime)
{
	if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		D3DXQuaternionIdentity(pQuaternion);
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		*pQuaternion = *(D3DXQUATERNION *)m_curve.m_rKeys;
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
//#define USE_SQUAD
#ifdef USE_SQUAD
	int i1 = (int)iKey1;
	int i2 = (int)iKey2;
	int i0 = i1 - 1;
	int i3 = i2 + 1;
	if(i0 < 0)
		i0 += m_curve.m_KeyCount;
	if(i3 >= (INT) m_curve.m_KeyCount)
		i3 -= m_curve.m_KeyCount;
	D3DXQUATERNION qA, qB, qC;
	D3DXQuaternionSquadSetup(&qA, &qB, &qC, 
							 (D3DXQUATERNION *)m_curve.m_rKeys + i0,
							 (D3DXQUATERNION *)m_curve.m_rKeys + i1,
							 (D3DXQUATERNION *)m_curve.m_rKeys + i2,
							 (D3DXQUATERNION *)m_curve.m_rKeys + i3);
	D3DXQuaternionSquad(pQuaternion, (D3DXQUATERNION *)m_curve.m_rKeys + i1, &qA, &qB, &qC, fLerpValue);
#else
	D3DXQuaternionSlerp(pQuaternion,
						(D3DXQUATERNION *)m_curve.m_rKeys + iKey1,
						(D3DXQUATERNION *)m_curve.m_rKeys + iKey2,
						fLerpValue);
#endif
	return S_OK;
}

HRESULT AnimRotate::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXQUATERNION quat;
	HRESULT hr = SetTime(&quat, fGlobalTime);
//	quat.w = -quat.w;
	D3DXMatrixRotationQuaternion(pMatrix, &quat);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between two rotate animations
//
HRESULT AnimRotateBlend::SetTime(D3DXQUATERNION *pRotate, float fGlobalTime)
{
	D3DXQUATERNION quatA;
	HRESULT hr = m_pAnimRotateA->SetTime(&quatA, fGlobalTime);
	if (FAILED(hr))
		return hr;
	
	D3DXQUATERNION quatB;
	hr = m_pAnimRotateB->SetTime(&quatB, fGlobalTime);
	if (FAILED(hr))
		return hr;

	D3DXQuaternionSlerp(pRotate, &quatA, &quatB, m_fBlend);
	return S_OK;
}

HRESULT AnimRotateBlend::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXQUATERNION quat;
	HRESULT hr = SetTime(&quat, fGlobalTime);
//	quat.w = -quat.w;
	D3DXMatrixRotationQuaternion(pMatrix, &quat);
	return hr;
}



//////////////////////////////////////////////////////////////////////
// Interpolate between nearest translation keys
//
HRESULT AnimTranslate::SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime)
{
	if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		pTranslate->x = pTranslate->y = pTranslate->z = 0.f;
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		*pTranslate = *(D3DXVECTOR3 *)m_curve.m_rKeys;
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	D3DXVec3Lerp(pTranslate,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey1,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey2,
				 fLerpValue);
	return S_OK;
}

HRESULT AnimTranslate::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vTranslate;
	HRESULT hr = SetTime(&vTranslate, fGlobalTime);
	D3DXMatrixTranslation(pMatrix, vTranslate.x, vTranslate.y, vTranslate.z);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between two translate animations
//
HRESULT AnimTranslateBlend::SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime)
{
	D3DXVECTOR3 vTranslateA;
	HRESULT hr = m_pAnimTranslateA->SetTime(&vTranslateA, fGlobalTime);
	if (FAILED(hr))
		return hr;
	
	D3DXVECTOR3 vTranslateB;
	hr = m_pAnimTranslateB->SetTime(&vTranslateB, fGlobalTime);
	if (FAILED(hr))
		return hr;

	D3DXVec3Lerp(pTranslate, &vTranslateA, &vTranslateB, m_fBlend);
	return S_OK;
}

HRESULT AnimTranslateBlend::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vTranslate;
	HRESULT hr = SetTime(&vTranslate, fGlobalTime);
	D3DXMatrixTranslation(pMatrix, vTranslate.x, vTranslate.y, vTranslate.z);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between nearest scale keys
//
HRESULT AnimScale::SetTime(D3DXVECTOR3 *pScale, float fGlobalTime)
{
	if (m_curve.m_rKeys == NULL
		|| m_curve.m_KeyCount == 0)
	{
		pScale->x = pScale->y = pScale->z = 1.f;
		return S_OK;
	}
	if (m_curve.m_KeyCount == 1)
	{
		*pScale = *(D3DXVECTOR3 *)m_curve.m_rKeys;
		return S_OK;
	}
	FLOAT fLocalTime = m_curve.LocalTime(fGlobalTime);
	UINT iKey1, iKey2;
	FLOAT fLerpValue;
	m_curve.FindKeys(fLocalTime, &iKey1, &iKey2, &fLerpValue);
	D3DXVec3Lerp(pScale,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey1,
				 (D3DXVECTOR3 *)m_curve.m_rKeys + iKey2,
				 fLerpValue);
	return S_OK;
}

HRESULT AnimScale::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vScale;
	HRESULT hr = SetTime(&vScale, fGlobalTime);
	D3DXMatrixScaling(pMatrix, vScale.x, vScale.y, vScale.z);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Interpolate between two scale animations
//
HRESULT AnimScaleBlend::SetTime(D3DXVECTOR3 *pScale, float fGlobalTime)
{
	D3DXVECTOR3 vScaleA;
	HRESULT hr = m_pAnimScaleA->SetTime(&vScaleA, fGlobalTime);
	if (FAILED(hr))
		return hr;
	
	D3DXVECTOR3 vScaleB;
	hr = m_pAnimScaleB->SetTime(&vScaleB, fGlobalTime);
	if (FAILED(hr))
		return hr;

	D3DXVec3Lerp(pScale, &vScaleA, &vScaleB, m_fBlend);
	return hr;
}

HRESULT AnimScaleBlend::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	D3DXVECTOR3 vScale;
	HRESULT hr = SetTime(&vScale, fGlobalTime);
	D3DXMatrixScaling(pMatrix, vScale.x, vScale.y, vScale.z);
	return hr;
}



#if ANIM_INTERPRETED

//////////////////////////////////////////////////////////////////////
// For writing to a file, we need to compute the size of the key data.
//
DWORD AnimCurve::GetSizeKeys() CONST
{
	return m_KeyCount * (1 /* keyTimes */ + m_KeySize) * sizeof(FLOAT);
}

//////////////////////////////////////////////////////////////////////
// Write the keys to the given memory location, then adjust
// pointer offsets to be relative to pBase, i.e. pDest - pBase.
// The number of bytes written must match the value returned by
// GetSizeKeys().
//
HRESULT AnimCurve::RelocateCopyKeys(BYTE *pDest, const BYTE *pBase) CONST
{
	UINT KeyTimesSize = sizeof(FLOAT) * m_KeyCount;
	memcpy(pDest, m_rKeyTimes, KeyTimesSize);
	*(DWORD *)&m_rKeyTimes = pDest - pBase;	// convert to file offset
	pDest += KeyTimesSize;
	memcpy(pDest, m_rKeys, sizeof(FLOAT) * m_KeyCount * m_KeySize);
	*(DWORD *)&m_rKeys = pDest - pBase;	        // convert to file offset
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Patch file offsets to memory offsets, i.e. convert file offsets
// to pointers relative to pBase
//
HRESULT AnimCurve::PatchKeys(const BYTE *pBase)
{
	*(DWORD *)&m_rKeyTimes += (DWORD)pBase;	// convert to pointer
	*(DWORD *)&m_rKeys += (DWORD)pBase;	    // convert to pointer
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Compute the transformation matrix based on the current animation keys.
HRESULT AnimFrame::SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
{
	switch (m_Type)
	{
	case ANIM_MATRIX: 			return ((AnimMatrix         *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_ROTATE: 			return ((AnimRotate         *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_TRANSLATE: 		return ((AnimTranslate      *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_SCALE: 			return ((AnimScale          *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_ROTATEBLEND:		return ((AnimRotateBlend    *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_TRANSLATEBLEND:	return ((AnimTranslateBlend *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_SCALEBLEND: 		return ((AnimScaleBlend     *)this)->SetTime(pMatrix, fGlobalTime);
	case ANIM_CONCAT: 			return ((AnimConcat         *)this)->SetTime(pMatrix, fGlobalTime);
	default:
		return E_NOTIMPL;
	}
}

//////////////////////////////////////////////////////////////////////
// For writing to a file, we need to compute the size of the
// structure data and the size of the key data.
//
DWORD AnimFrame::GetSize()
{
	DWORD Size;
	switch (m_Type)	{
	case ANIM_MATRIX:
	{
		AnimMatrix *pAnimMatrix = (AnimMatrix *)this;
		Size = sizeof(AnimMatrix);
		Size += pAnimMatrix->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_ROTATE:
	{
		AnimRotate *pAnimRotate = (AnimRotate *)this;
		Size = sizeof(AnimRotate);
		Size += pAnimRotate->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_TRANSLATE:
	{
		AnimTranslate *pAnimTranslate = (AnimTranslate *)this;
		Size = sizeof(AnimTranslate);
		Size += pAnimTranslate->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_SCALE:
	{
		AnimScale *pAnimScale = (AnimScale *)this;
		Size = sizeof(AnimScale);
		Size += pAnimScale->m_curve.GetSizeKeys();
		return Size;
	}
	case ANIM_ROTATEBLEND:
	{
		AnimRotateBlend *pAnimRotateBlend = (AnimRotateBlend *)this;
		Size = sizeof(AnimRotateBlend);
		Size += pAnimRotateBlend->m_pAnimRotateA->GetSize();
		Size += pAnimRotateBlend->m_pAnimRotateB->GetSize();
		return Size;
	}
	case ANIM_TRANSLATEBLEND:
	{
		AnimTranslateBlend *pAnimTranslateBlend = (AnimTranslateBlend *)this;
		Size = sizeof(AnimTranslateBlend);
		Size += pAnimTranslateBlend->m_pAnimTranslateA->GetSize();
		Size += pAnimTranslateBlend->m_pAnimTranslateB->GetSize();
		return Size;
	}
	case ANIM_SCALEBLEND:
	{
		AnimScaleBlend *pAnimScaleBlend = (AnimScaleBlend *)this;
		Size = sizeof(AnimScaleBlend);
		Size += pAnimScaleBlend->m_pAnimScaleA->GetSize();
		Size += pAnimScaleBlend->m_pAnimScaleB->GetSize();
		return Size;
	}
	case ANIM_CONCAT:
	{
		AnimConcat *pAnimConcat = (AnimConcat *)this;
		Size = sizeof(AnimConcat);
		Size += pAnimConcat->m_pAnimA->GetSize();
		Size += pAnimConcat->m_pAnimB->GetSize();
		return Size;
	}
	default:
		return 0;	// E_NOTIMPL
	}
}

//////////////////////////////////////////////////////////////////////
// Write the expression to the given memory location, adjusting
// pointer offsets to be relative to pBase, i.e. pDest - pBase.
// The number of bytes written must match the value returned by
// GetSize().
//
HRESULT AnimFrame::RelocateCopy(BYTE *pDest, const BYTE *pBase)
{
	HRESULT hr;
	switch (m_Type) {
	case ANIM_MATRIX:
	{
		AnimMatrix *pAnimMatrix = (AnimMatrix *)pDest;
		*pAnimMatrix = *(AnimMatrix *)this;
		pDest += sizeof(AnimMatrix);
		return pAnimMatrix->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_ROTATE:
	{
		AnimRotate *pAnimRotate = (AnimRotate *)pDest;
		*pAnimRotate = *(AnimRotate *)this;
		pDest += sizeof(AnimRotate);
		return pAnimRotate->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_TRANSLATE:
	{
		AnimTranslate *pAnimTranslate = (AnimTranslate *)pDest;
		*pAnimTranslate = *(AnimTranslate *)this;
		pDest += sizeof(AnimTranslate);
		return pAnimTranslate->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_SCALE:
	{
		AnimScale *pAnimScale = (AnimScale *)pDest;
		*pAnimScale = *(AnimScale *)this;
		pDest += sizeof(AnimScale);
		return pAnimScale->m_curve.RelocateCopyKeys(pDest, pBase);
	}
	case ANIM_ROTATEBLEND:
	{
		AnimRotateBlend *pAnimRotateBlend = (AnimRotateBlend *)pDest;
		*pAnimRotateBlend = *(AnimRotateBlend *)this;
		pDest += sizeof(AnimRotateBlend);
		hr = pAnimRotateBlend->m_pAnimRotateA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimRotateBlend->m_pAnimRotateA->GetSize();
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimRotateBlend->m_pAnimRotateB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	case ANIM_TRANSLATEBLEND:
	{
		AnimTranslateBlend *pAnimTranslateBlend = (AnimTranslateBlend *)pDest;
		*pAnimTranslateBlend = *(AnimTranslateBlend *)this;
		pDest += sizeof(AnimTranslateBlend);
		hr = pAnimTranslateBlend->m_pAnimTranslateA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimTranslateBlend->m_pAnimTranslateA->GetSize();
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimTranslateBlend->m_pAnimTranslateB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	case ANIM_SCALEBLEND:
	{
		AnimScaleBlend *pAnimScaleBlend = (AnimScaleBlend *)pDest;
		*pAnimScaleBlend = *(AnimScaleBlend *)this;
		pDest += sizeof(AnimScaleBlend);
		hr = pAnimScaleBlend->m_pAnimScaleA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimScaleBlend->m_pAnimScaleA->GetSize();
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimScaleBlend->m_pAnimScaleB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	case ANIM_CONCAT:
	{
		AnimConcat *pAnimConcat = (AnimConcat *)pDest;
		*pAnimConcat = *(AnimConcat *)this;
		pDest += sizeof(AnimConcat);
		hr = pAnimConcat->m_pAnimA->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		DWORD SizeA = pAnimConcat->m_pAnimA->GetSize();
		*(DWORD *)&pAnimConcat->m_pAnimA = pDest - pBase;	// convert to file offset
		pDest += SizeA;
		hr = pAnimConcat->m_pAnimB->RelocateCopy(pDest, pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimConcat->m_pAnimB = pDest - pBase;	// convert to file offset
		return S_OK;
	}
	default:
		return E_NOTIMPL;
	}
}

//////////////////////////////////////////////////////////////////////
// Patch file offsets to memory offsets, i.e. convert file offsets
// to pointers.
//
HRESULT AnimFrame::Patch(const BYTE *pBase)
{
	HRESULT hr;
	switch (m_Type) {
	case ANIM_MATRIX:
	{
		AnimMatrix *pAnimMatrix = (AnimMatrix *)this;
		return pAnimMatrix->m_curve.PatchKeys(pBase);
	}
	case ANIM_ROTATE:
	{
		AnimRotate *pAnimRotate = (AnimRotate *)this;
		return pAnimRotate->m_curve.PatchKeys(pBase);
	}
	case ANIM_TRANSLATE:
	{
		AnimTranslate *pAnimTranslate = (AnimTranslate *)this;
		return pAnimTranslate->m_curve.PatchKeys(pBase);
	}
	case ANIM_SCALE:
	{
		AnimScale *pAnimScale = (AnimScale *)this;
		return pAnimScale->m_curve.PatchKeys(pBase);
	}
	case ANIM_ROTATEBLEND:
	{
		AnimRotateBlend *pAnimRotateBlend = (AnimRotateBlend *)this;
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateA += (DWORD)pBase;	// convert to pointer
		hr = pAnimRotateBlend->m_pAnimRotateA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimRotateBlend->m_pAnimRotateB += (DWORD)pBase;	// convert to pointer
		hr = pAnimRotateBlend->m_pAnimRotateB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	case ANIM_TRANSLATEBLEND:
	{
		AnimTranslateBlend *pAnimTranslateBlend = (AnimTranslateBlend *)this;
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateA += (DWORD)pBase;	// convert to pointer
		hr = pAnimTranslateBlend->m_pAnimTranslateA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimTranslateBlend->m_pAnimTranslateB += (DWORD)pBase;	// convert to pointer
		hr = pAnimTranslateBlend->m_pAnimTranslateB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	case ANIM_SCALEBLEND:
	{
		AnimScaleBlend *pAnimScaleBlend = (AnimScaleBlend *)this;
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleA += (DWORD)pBase;	// convert to pointer
		hr = pAnimScaleBlend->m_pAnimScaleA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimScaleBlend->m_pAnimScaleB += (DWORD)pBase;	// convert to pointer
		hr = pAnimScaleBlend->m_pAnimScaleB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	case ANIM_CONCAT:
	{
		AnimConcat *pAnimConcat = (AnimConcat *)this;
		*(DWORD *)&pAnimConcat->m_pAnimA += (DWORD)pBase;	// convert to pointer
		hr = pAnimConcat->m_pAnimA->Patch(pBase);
		if (FAILED(hr))
			return hr;
		*(DWORD *)&pAnimConcat->m_pAnimB += (DWORD)pBase;	// convert to pointer
		hr = pAnimConcat->m_pAnimB->Patch(pBase);
		if (FAILED(hr))
			return hr;
		return S_OK;
	}
	default:
		return E_NOTIMPL;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\debugcmd.cpp ===
//-----------------------------------------------------------------------------
// File: DebugCmd.CPP
//
// Desc: 
//      Helps an application expose functionality through the debug channel
//  to a debug console running on a remote machine.
//      Commands are sent through the debug channel to the debug monitor on
//  the Xbox machine.  The Xbox machine routes it to the command processor,
//  which is linked into the application (this happens on a separate thread
//  from the application's).  When the application polls for commands to be
//  run (usually once per frame), it can then pick up the command to execute
//  and do the appropriate processing.
//
// Hist: 02.05.01 - Initial creation for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xbdm.h>
#include <stdio.h>

#include "DebugCmd.h"

// our critical section
bool g_fcsInited = false;
CRITICAL_SECTION g_cs;

// command prefix
static const char g_szCmd[] = "XCMD";

// processorproc buffer
static char g_szRemoteBuf[CCH_MAXCMDLEN];

//=========================================================================
// Name: RCmdHelp
// Desc: Builtin command - help
//          Iterates over the list of builtin and application-provided 
//          commands and displays a help string for each one
//=========================================================================
void RCmdHelp(int argc, char *argv[])
{
    for(UINT iCmd = 0; iCmd < g_nDCCmds; iCmd++)
    {
        DCPrintf("%s\t%s\n",
            g_rgDCCmds[iCmd].szCmd,
            g_rgDCCmds[iCmd].szCmdHelp);
    }
}

//=========================================================================
// Name: RCmdSet
// Desc: Builtin command - set
//          Can set or display values of any variables exposed by the 
//          application to the debug console
//=========================================================================
void RCmdSet(int argc, char *argv[])
{
    UINT nIndex;

    if(argc == 1)
    {
        // if we aren't passed any arguments, then just list all the variables and
        // what their current values are.
        for(nIndex = 0; nIndex < g_nDCVars; nIndex++)
        {
			CONST LPCSTR lpstr = g_rgDCVars[nIndex].lpstr;
			LPVOID lpvAddr = g_rgDCVars[nIndex].lpvAddr;
            switch(g_rgDCVars[nIndex].ddt)
            {
            case DC_bool:
                DCPrintf("%s\t= %d\n", lpstr, *(bool *)lpvAddr);
                break;
            case DC_I4:
                DCPrintf("%s\t= %d\n", lpstr, *(INT *)lpvAddr);
                break;
            case DC_I2:
                DCPrintf("%s\t= %d\n", lpstr, *(WORD *)lpvAddr);
                break;
            case DC_R4:
                DCPrintf("%s\t= %0.1f\n", lpstr, *(float *)lpvAddr);
                break;
            case DC_COLOR:
                DCPrintf("%s\t= 0x%.08x\n", lpstr, *(DWORD *)lpvAddr);
                break;
            case DC_FLOAT1:
			{
				FLOAT *pf = (float *)lpvAddr;
				DCPrintf("%s\t= %g\n", lpstr, pf[0]);
                break;
			}
            case DC_FLOAT2:
			{
				FLOAT *pf = (float *)lpvAddr;
                DCPrintf("%s\t= %g %g\n", lpstr, pf[0], pf[1]);
                break;
			}
            case DC_FLOAT3:
			{
				FLOAT *pf = (float *)lpvAddr;
                DCPrintf("%s\t= %g %g %g\n", lpstr, pf[0], pf[1], pf[2]);
                break;
			}
            case DC_FLOAT4:
			{
				FLOAT *pf = (float *)lpvAddr;
                DCPrintf("%s\t= %g %g %g %g\n", lpstr, pf[0], pf[1], pf[2], pf[3]);
                break;
			}
            case DC_MATRIX:
			{
				FLOAT *pf = (float *)lpvAddr;
                DCPrintf("%s\t= %g %g %g %g    %g %g %g %g    %g %g %g %g    %g %g %g %g\n", lpstr,
						 pf[0], pf[1], pf[2], pf[3],
						 pf[4], pf[5], pf[6], pf[7],
						 pf[8], pf[9], pf[10], pf[11],
						 pf[12], pf[13], pf[14], pf[15]);
                break;
			}
            }
        }
    }
    else
    {
        // if the user did a set "foo = 2", skip equals sign
		int iarg = 2;
        if(argv[iarg][0] == '=')
			iarg++;

        // Find the entry for this variable, if we can
        for(nIndex = 0; nIndex < g_nDCVars; nIndex++)
        {
			CONST LPCSTR lpstr = g_rgDCVars[nIndex].lpstr;
            if(!lstrcmpiA(argv[1], lpstr))
            {
                // Set the appropriate type of data
				CHAR *endptr;
				DWORD dwVal;
                LPVOID lpvAddr = g_rgDCVars[nIndex].lpvAddr;
                switch(g_rgDCVars[nIndex].ddt)
                {
                case DC_bool:
				{
					dwVal = (argv[iarg][0] == '0' && argv[iarg][1] == 'x') ?
						strtoul(argv[iarg], &endptr, 16) : atoi(argv[iarg]);
                    *(bool *)lpvAddr = !!dwVal;
                    DCPrintf("set %s = %d\n", lpstr, *(bool *)lpvAddr);
                    break;
				}
                case DC_I4:
				{
					dwVal = (argv[iarg][0] == '0' && argv[iarg][1] == 'x') ?
						strtoul(argv[iarg], &endptr, 16) : atoi(argv[iarg]);
                    *(INT *)lpvAddr = dwVal;
                    DCPrintf("set %s = %d\n", lpstr, *(INT *)lpvAddr);
                    break;
				}
                case DC_I2:
				{
					dwVal = (argv[iarg][0] == '0' && argv[iarg][1] == 'x') ?
						strtoul(argv[iarg], &endptr, 16) : atoi(argv[iarg]);
                    *(WORD *)lpvAddr = (WORD)dwVal;
                    DCPrintf("set %s = %d\n", lpstr, *(WORD *)lpvAddr);
                    break;
				}
                case DC_R4:
				{
                    *(float *)lpvAddr = (float)atof(argv[iarg]);
                    DCPrintf("set %s = %0.1f\n", lpstr, *(float *)lpvAddr);
                    break;
				}
				case DC_COLOR:
				{
					dwVal = (argv[iarg][0] == '0' && argv[iarg][1] == 'x') ?
						strtoul(argv[iarg], &endptr, 16) : atoi(argv[iarg]);
                    *(DWORD *)lpvAddr = dwVal;
					DCPrintf("set %s = 0x%.08x\n", lpstr,
						*(DWORD *)lpvAddr);
					break;
				}
				case DC_FLOAT1:
				{
					FLOAT *pf = (float *)lpvAddr;
					for (INT i = 0; iarg < argc && i < 1; iarg++, i++)
						pf[i] = (float)atof(argv[iarg]);
					DCPrintf("set %s = %g\n", lpstr, pf[0]);
					break;
				}
				case DC_FLOAT2:
				{
					FLOAT *pf = (float *)lpvAddr;
					for (INT i = 0; iarg < argc && i < 2; iarg++, i++)
						pf[i] = (float)atof(argv[iarg]);
					DCPrintf("set %s = %g %g\n", lpstr, pf[0], pf[1]);
					break;
				}
				case DC_FLOAT3:
				{
					FLOAT *pf = (float *)lpvAddr;
					for (INT i = 0; iarg < argc && i < 3; iarg++, i++)
						pf[i] = (float)atof(argv[iarg]);
					DCPrintf("set %s = %g %g %g\n", lpstr,
							 pf[0], pf[1], pf[2]);
					break;
				}
				case DC_FLOAT4:
				{
					FLOAT *pf = (float *)lpvAddr;
					for (INT i = 0; iarg < argc && i < 4; iarg++, i++)
						pf[i] = (float)atof(argv[iarg]);
					DCPrintf("set %s = %g %g %g %g\n", lpstr,
							 pf[0], pf[1], pf[2], pf[3]);
					break;
				}
				case DC_MATRIX:
				{
					FLOAT *pf = (float *)lpvAddr;
					for (INT i = 0; iarg < argc && i < 16; iarg++, i++)
						pf[i] = (float)atof(argv[iarg]);
					DCPrintf("set %s = %g %g %g %g    %g %g %g %g    %g %g %g %g    %g %g %g %g\n", lpstr,
							 pf[0], pf[1], pf[2], pf[3],
							 pf[4], pf[5], pf[6], pf[7],
							 pf[8], pf[9], pf[10], pf[11],
							 pf[12], pf[13], pf[14], pf[15]);
					break;
				}
                }

                // call the notif func if there was one
                if(g_rgDCVars[nIndex].pfnNotifFunc)
                    g_rgDCVars[nIndex].pfnNotifFunc(lpvAddr);

                return;
            }
        }

        DCPrintf("variable '%s' not found\n", argv[1]);
    }
}

//=========================================================================
// Name: CmdToArgv
// Dsec: Parse szCmd into argv and return # of args. (modifies szCmd)
//=========================================================================
int CmdToArgv(char *szCmd, char *szArg[], int maxargs)
{
    int argc = 0;
    int argcT = 0;
    char *szNil = szCmd + lstrlenA(szCmd);

    while(argcT < maxargs)
    {
        // eat whitespace
        while(*szCmd && (*szCmd == ' '))
            szCmd++;

        if(!*szCmd)
        {
            szArg[argcT++] = (char *)szNil;
        }
        else
        {
            // find the end of this arg
            char chEnd = (*szCmd == '"' || *szCmd == '\'') ? *szCmd++ : ' ';
            char *szArgEnd = szCmd;
            while(*szArgEnd && (*szArgEnd != chEnd))
                szArgEnd++;

            // record this bad boy
            szArg[argcT++] = szCmd;
            argc = argcT;

            // move szArg to the next argument (or not)
            szCmd = *szArgEnd ? szArgEnd + 1 : szArgEnd;
            *szArgEnd = 0;
        }
    }

    return argc;
}


//
// Temporary replacement for CRT string funcs, since
// we can't call CRT functions on the debug monitor
// thread right now.
//

//=========================================================================
// Name: dbgstrlen
// Desc: Returns length of sz
//=========================================================================
int dbgstrlen( LPCSTR sz )
{
    LPCSTR szEnd = sz;
    while( *szEnd )
        szEnd++;
    return szEnd - sz;
}

//=========================================================================
// Name: dbglc
// Desc: Returns lowercase of char
//=========================================================================
inline char dbglc( char ch )
{
    if( ch >= 'A' && ch <= 'Z' )
        return ch - ( 'A' - 'a' );
    else
        return ch;
}

//=========================================================================
// Name: dbgstrcmpn
// Desc: String compare.  Returns TRUE if strings are equal up to n 
//       chars or end of string
//=========================================================================
BOOL dbgstrcmpn( LPCSTR sz1, LPCSTR sz2, int n )
{
    while( ( dbglc( *sz1 ) == dbglc( *sz2 ) ) && *sz1 && n > 0 )
    {
        --n;
        ++sz1;
        ++sz2;
    }

    return( n == 0 || dbglc( *sz1 ) == dbglc( *sz2 ) );
}

//=========================================================================
// Name: dbgstrcpy
// Desc: Copies szSrc to szDest and terminates szDest
//=========================================================================
void dbgstrcpy( LPSTR szDest, LPCSTR szSrc )
{
    while( ( *szDest++ = *szSrc++ ) != 0 )
        ;
}
    
//=========================================================================
// Name: DCPRocessorProc
// Desc: Cmd notification proc
//
//  This is what is called by the Xbox debug monitor to have us process
//  a command.  What we'll actually attempt to do is tell it to make calls
//  to us on a separate thread, so that we can just block until we're 
//  able to process a command.
//=========================================================================
HRESULT __stdcall DCProcessorProc(LPCSTR szCommand, LPSTR szResp,
    DWORD cchResp, PDM_CMDCONT pdmcc)
{

    // skip over prefix
    LPCSTR szCmd = szCommand + lstrlenA(g_szCmd) + 1;
    BOOL   fKnownCommand = FALSE;

    // check if this is the initial connect signal
    if(dbgstrcmpn(szCmd, "__connect__", 11))
    {
        // if so, respond that we're connected
        lstrcpynA(szResp, "Connected.", cchResp);
        return XBDM_NOERR;
    }

    // check to see if the cmd exists
    for (UINT iCmd = 0; iCmd < g_nDCCmds; iCmd++)
    {
        if(dbgstrcmpn(g_rgDCCmds[iCmd].szCmd, szCmd, dbgstrlen(g_rgDCCmds[iCmd].szCmd)))
        {
            // If we find the string, copy it into the command buffer
            // to be examined by the polling function
            fKnownCommand = TRUE;
            break;
        }
    }

    if( fKnownCommand )
    {
        // g_szRemoteBuf needs to be protected by the critical section
        EnterCriticalSection(&g_cs);
        if( g_szRemoteBuf[0] )
        {
            // This means the application has probably stopped polling for debug commands
            dbgstrcpy( szResp, "Cannot execute - previous command still pending" );
        }
        else
        {
            dbgstrcpy( g_szRemoteBuf, szCmd );
        }
        LeaveCriticalSection(&g_cs);
    }
    else
    {
        dbgstrcpy( szResp, "unknown command" );
    }

    return XBDM_NOERR;
}

//=========================================================================
// Name: DCHandleCmds
// Desc: Poll routine called by Xbox app
//
//  The application should call this function periodically, usually every
//  frame.  This will check to see if there is a command waiting to be
//  executed, and if so, execute it.
//=========================================================================
BOOL DCHandleCmds()
{
    static BOOL fRegistered = false;
	const int maxargs = 30;
    char *      szArgv[maxargs];
    int         argc;
    char        szLocalBuf[CCH_MAXCMDLEN]; // local copy of command

    // Initialize ourselves when we're first called.
    if(!fRegistered)
    {
        // init our critical section
        if(!g_fcsInited)
        {
            InitializeCriticalSection(&g_cs);
            g_fcsInited = true;
        }

        // register our command handler with the debug monitor
        HRESULT hr = DmRegisterCommandProcessor(g_szCmd, DCProcessorProc);
        if(FAILED(hr))
            return false;

        fRegistered = true;
    }

    // If there's nothing waiting, return.
    if( !g_szRemoteBuf[0] )
    {
        return false;
    }

    // 
    // Grab a copy of the command to free up
    // the crtical section
    //
    EnterCriticalSection(&g_cs);

    lstrcpyA( szLocalBuf, g_szRemoteBuf );
    g_szRemoteBuf[0] = 0;

    LeaveCriticalSection(&g_cs);

    // Now process the command
    argc = CmdToArgv(szLocalBuf, szArgv, maxargs);

    // Find the entry in our command list
    for (UINT iCmd = 0; iCmd < g_nDCCmds; iCmd++)
    {
        if(!lstrcmpiA(g_rgDCCmds[iCmd].szCmd, szArgv[0]))
        {
            g_rgDCCmds[iCmd].pfnHandler(argc, szArgv);
            break;
        }
    }

    return true;
}

//=========================================================================
// Name: DCPrintf 
// Desc: Asynchronous printf routine that sends the string to the 
//          Remote Xbox Command Client
//=========================================================================

BOOL DCPrintf(LPCSTR szFmt, ...)
{
	extern bool g_bQuiet;
	if (g_bQuiet)
		return true;

    char szBuf[CCH_MAXCMDLEN];
    int cch;
    va_list arglist;

    // copy prefix into into buffer
    for(int ich = 0; ich < sizeof(g_szCmd); ich++)
        szBuf[ich] = g_szCmd[ich];
    szBuf[ich - 1] = '!';

    // format arguments
    va_start(arglist, szFmt);
    cch = _vsnprintf(&szBuf[ich], CCH_MAXCMDLEN - ich, szFmt, arglist);
    va_end(arglist);

    // send it out
    DmSendNotificationString(szBuf);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\debugcmd.h ===
//-----------------------------------------------------------------------------
// File: DebugCmd.H
//
// Desc: Remote Xbox command header
//
// This header file should be included into your application.  It provides 
// function and type definitions.  You will also need to modify the following
// variables:
//
// g_rgDCCmds - This is the list of commands your application provides.  Note
//  that "help" and "set" are provided automatically and can not be overriden.
//  This is currently defined in DebugCmd.cpp
// g_rgDCVars - This is a list of variables that your application exposes.
//  They can be examined and modified by the builtin "set" command.
//  This should be defined in your application source, after including DebugCmd.h
//
// Hist: 02.05.01 - Initial creation for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _DEBUGCMD_H
#define _DEBUGCMD_H

/////////////////////////////////////////////////////////////////////////////
// Commands
/////////////////////////////////////////////////////////////////////////////

#define CCH_MAXCMDLEN       256
typedef void (*RCMDSHANDLER)(int argc, char *argv[]);

// Command definition structure
typedef struct _DCCMDDEF
{
    LPSTR           szCmd;                      // Name of command
    RCMDSHANDLER    pfnHandler;                 // Handler function
    LPSTR           szCmdHelp;                  // Description of command
} DCCMDDEF;

extern const DCCMDDEF *g_rgDCCmds;				// List of app-defined commands
extern const UINT      g_nDCCmds;				// Number of app-defined commands

/////////////////////////////////////////////////////////////////////////////
// Useful commands for the application to put into the g_rgDCCmds array
/////////////////////////////////////////////////////////////////////////////
void RCmdHelp(int argc, char *argv[]);          // Help command
void RCmdSet(int argc, char *argv[]);           // Set command

/////////////////////////////////////////////////////////////////////////////
// Variables
/////////////////////////////////////////////////////////////////////////////

enum DCDATATYPES { DC_bool,
				   DC_I2,
				   DC_I4,
				   DC_R4,
				   DC_COLOR,
				   DC_FLOAT1,
				   DC_FLOAT2,
				   DC_FLOAT3,
				   DC_FLOAT4,
				   DC_MATRIX,
};
typedef void (*DCSETNOTIF)(LPVOID lpvAddr);

// Variable definition structure
typedef struct _DCVARDEF
{
    LPCSTR          lpstr;                      // Name of variable
    LPVOID          lpvAddr;                    // Address of variable
    DCDATATYPES  ddt;                        // Data type of variable
    DCSETNOTIF   pfnNotifFunc;               // Function to call upon change
} DCVARDEF;

// These should get defined in your application cpp file:
extern const DCVARDEF *g_rgDCVars;       // List of application variables
extern const UINT      g_nDCVars;        // Number of application vars


/////////////////////////////////////////////////////////////////////////////
// Misc
/////////////////////////////////////////////////////////////////////////////

//
// handle any remote commands that have been sent - this
// should be called periodically by the application
//
BOOL DCHandleCmds();

//
// asynchronous printf - this is used to send
// responses back to the debug console
//
BOOL DCPrintf(LPCSTR szFmt, ...);

#endif // _DEBUGCMD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbrc\xbrc.h ===
//-----------------------------------------------------------------------------
//  
//  File: xbrc.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Resource constants
//
//-----------------------------------------------------------------------------
 
#define USER_DATA_FLAG 0x80000000

// All of this should instead be compiled into pushbuffers, but
// that functionality is not yet exposed on the PC side.  

#define XBRC_INDEXBUFFER				(USER_DATA_FLAG|D3DCOMMON_TYPE_INDEXBUFFER)
#define XBRC_VERTEXSHADER 				0x80000010
#define XBRC_PIXELSHADER				0x80000020


/*
#define XBRC_BATCH						0x80000030

#define BATCH_SetRenderState 			1
#define BATCH_SetTextureStageState		2
#define BATCH_SetTexture				3
#define BATCH_SetPalette				4
#define BATCH_SetVertexShader			5
#define BATCH_SetVertexShaderInput		6
#define BATCH_SetVertexShaderConstant	7
#define BATCH_SetPixelShader			8
#define BATCH_SetRenderTarget			9
*/

#define XBRC_EFFECT						0x80000040
#define XBRC_SKELETON					0x80000050
#define XBRC_ANIMATION					0x80000060

// For preview and debugging the symbol table maps strings to offsets.
#define XBRC_SYMBOLTABLE				0x80000100
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\makefile.inc ===
!include "..\..\samples\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\anim.h ===
//-----------------------------------------------------------------------------
//  
//  File: anim.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Animation using key frames.
//
//-----------------------------------------------------------------------------
#pragma once

#include "frame.h"

//////////////////////////////////////////////////////////////////////
// When we go to the codegen model, all of this interpretation code
// can go away.  For now, we skip the compile/link step and write out
// a token stream that is interpreted in xbview.
//
#ifndef ANIM_INTERPRETED
#define ANIM_INTERPRETED 1
#endif

#if ANIM_INTERPRETED
enum AnimType {
	ANIM_MATRIX,
	ANIM_ROTATE,
	ANIM_TRANSLATE,
	ANIM_SCALE,
	ANIM_ROTATEBLEND,
	ANIM_TRANSLATEBLEND,
	ANIM_SCALEBLEND,
	ANIM_CONCAT,
};
#endif

////////////////////////////////////////////////////////////////////////////////
// Generic frame animation
//

struct AnimFrame
{
#if !ANIM_INTERPRETED
	
    //////////////////////////////////////////////////////////////////////
    // Compute the transformation matrix based on the current animation keys.
    virtual HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime) = 0;
	
#else	
	AnimType m_Type; // Instead of using virtual functions, we key off the type, which can be written to the preview file.

    //////////////////////////////////////////////////////////////////////
    // Compute the transformation matrix based on the current animation keys.
	//
	// This version does not use virtual functions, but instead
	// uses the m_Type field to choose which subclass to cast the
	// 'this' pointer to.
	HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);

    //////////////////////////////////////////////////////////////////////
	// For writing to a file, we need to compute the size of the
	// structure data and the size of the key data (which may need to be
	// aligned.)
	//
	DWORD GetSize();

    //////////////////////////////////////////////////////////////////////
	// Write the expression to the given memory location, adjusting
	// pointer offsets to be relative to pBase, i.e. pDest - pBase.
	// The number of bytes written must match the value returned by
	// GetSize().
	//
	HRESULT RelocateCopy(BYTE *pDest, const BYTE *pBase);

    //////////////////////////////////////////////////////////////////////
	// Patch file offsets to memory offsets, i.e. convert file offsets
	// to pointers relative to pBase
	//
	HRESULT Patch(const BYTE *pBase);
#endif
};

//////////////////////////////////////////////////////////////////////
// Basic key-framed animation, with variable size keys.  Based on
// the SMIL2.0 semantics for the <animate> tag.
//
struct AnimCurve {
    
    // animation information
    UINT m_KeyCount;    // number of keys in each array
    FLOAT *m_rKeyTimes; // m_KeyCount length
    UINT m_KeySize;     // number of floats in a key
    FLOAT *m_rKeys;     // m_KeySize * m_KeyCount length
    // FLOAT *m_rKeySplines;

    // Local time transformation, fLocal = (fGlobalTime - m_fBegin) * m_fDurationInverse;
    float m_fBegin;             // start of animation
    float m_fDurationInverse;   // inverse duration of animation
    // TODO: more SMIL stuff
    // enum { CalcMode_discrete, CalcMode_linear, CalcMode_paced, CalcMode_spline } CalcMode;
    // float m_fRepeatCount;
    // float m_fRepeatDur;

    //////////////////////////////////////////////////////////////////////
    // Compute local time
    FLOAT LocalTime(FLOAT fGlobalTime) CONST
    {
        // TODO: more SMIL stuff, repeats, fill mode, etc.
        return (fGlobalTime - m_fBegin) * m_fDurationInverse;
    }
    
    //////////////////////////////////////////////////////////////////////
    // Find the bracketing key times
    HRESULT FindKeys(FLOAT fLocalTime, UINT *piKey1, UINT *piKey2, FLOAT *pfLerpValue) CONST;

    //////////////////////////////////////////////////////////////////////
    // Find the bracketing key times, then lerp the values
    HRESULT Sample(FLOAT fLocalTime, FLOAT *rfValue) CONST;

#if ANIM_INTERPRETED
	AnimCurve()
	{
		m_KeyCount = 0;
		m_rKeyTimes = NULL;
		m_KeySize = 0;
		m_rKeys = NULL;
		m_fBegin = 0.f;
		m_fDurationInverse = 1.f;
	}
	
    //////////////////////////////////////////////////////////////////////
	// For writing to a file, we need to compute the size of the key data.
	//
	DWORD GetSizeKeys() CONST;

    //////////////////////////////////////////////////////////////////////
	// Write the keys to the given memory location, then adjust
	// pointer offsets to be relative to pBase, i.e. pDest - pBase.
	// The number of bytes written must match the value returned by
	// GetSizeKeys().
	//
	HRESULT RelocateCopyKeys(BYTE *pDest, const BYTE *pBase) CONST;

    //////////////////////////////////////////////////////////////////////
	// Patch file offsets to memory offsets, i.e. convert file offsets
	// to pointers relative to pBase
	//
	HRESULT PatchKeys(const BYTE *pBase);
#endif
};

////////////////////////////////////////////////////////////////////////////////
// Frame animation types
//
struct AnimMatrix : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimMatrix()
	{
		m_Type = ANIM_MATRIX;
		m_curve.m_KeySize = 16;
	}
	AnimMatrix(D3DXMATRIX *pMatrix)
	{
		// Create a static matrix
		m_Type = ANIM_MATRIX;
		m_curve.m_KeySize = 16;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 16 ];
		memcpy(m_curve.m_rKeys, &pMatrix->m[0][0], sizeof(FLOAT) * 16);
	}
#endif	
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
};

struct AnimRotate : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimRotate()
	{
		m_Type = ANIM_ROTATE;
		m_curve.m_KeySize = 4;
	}
	AnimRotate(D3DXQUATERNION *pQuaternion)
	{
		// Create a static rotation
		m_Type = ANIM_ROTATE;
		m_curve.m_KeySize = 4;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 4 ];
		memcpy(m_curve.m_rKeys, pQuaternion, sizeof(FLOAT) * 4);
	}
#endif
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXQUATERNION *pQuaternion, float fGlobalTime);
};

struct AnimTranslate : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimTranslate()
	{
		m_Type = ANIM_TRANSLATE;
		m_curve.m_KeySize = 3;
	}
	AnimTranslate(D3DXVECTOR3 *pTranslate)
	{
		// Create a static translate
		m_Type = ANIM_TRANSLATE;
		m_curve.m_KeySize = 3;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 3 ];
		memcpy(m_curve.m_rKeys, pTranslate, sizeof(FLOAT) * 3);
	}
#endif	
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime);
};

struct AnimScale : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimScale()
	{
		m_Type = ANIM_SCALE;
		m_curve.m_KeySize = 3;
	}
	AnimScale(D3DXVECTOR3 *pScale)
	{
		// Create a static scale
		m_Type = ANIM_SCALE;
		m_curve.m_KeySize = 3;
		m_curve.m_KeyCount = 1;
		m_curve.m_rKeyTimes = new FLOAT [ 1 ];
		m_curve.m_rKeyTimes[0] = 0.f;
		m_curve.m_rKeys = new FLOAT [ 1 * 3 ];
		memcpy(m_curve.m_rKeys, pScale, sizeof(FLOAT) * 3);
	}
#endif	
	AnimCurve m_curve;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pScale, float fGlobalTime);
};



////////////////////////////////////////////////////////////////////////////////
// Parameter blending.  Before creating the matrix, parameters are interpolated.
//
struct AnimRotateBlend : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimRotateBlend()
	{
		m_Type = ANIM_ROTATEBLEND;
	}
#endif	
	float m_fBlend;
	AnimRotate *m_pAnimRotateA;
	AnimRotate *m_pAnimRotateB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXQUATERNION *pQuaternion, float fGlobalTime);
};

struct AnimTranslateBlend : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimTranslateBlend()
	{
		m_Type = ANIM_TRANSLATEBLEND;
	}
#endif	
	float m_fBlend;
	AnimTranslate *m_pAnimTranslateA;
	AnimTranslate *m_pAnimTranslateB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pTranslate, float fGlobalTime);
};

struct AnimScaleBlend : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimScaleBlend()
	{
		m_Type = ANIM_SCALEBLEND;
	}
#endif	
	float m_fBlend;
	AnimScale *m_pAnimScaleA;
	AnimScale *m_pAnimScaleB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime);
    HRESULT SetTime(D3DXVECTOR3 *pScale, float fGlobalTime);
};



////////////////////////////////////////////////////////////////////////////////
// Matrix concatenation. Returns m_AnimA * m_AnimB
//
struct AnimConcat : public AnimFrame
{
#if ANIM_INTERPRETED
	AnimConcat()
	{
		m_Type = ANIM_CONCAT;
	}
#endif	
	AnimFrame *m_pAnimA;
	AnimFrame *m_pAnimB;
    HRESULT SetTime(D3DXMATRIX *pMatrix, float fGlobalTime)
	{
		HRESULT hr;
		D3DXMATRIX matA;
		hr = m_pAnimA->SetTime(&matA, fGlobalTime);
		if (FAILED(hr))
			return hr;
		D3DXMATRIX matB;
		hr = m_pAnimB->SetTime(&matB, fGlobalTime);
		if (FAILED(hr))
			return hr;
		D3DXMatrixMultiply(pMatrix, &matA, &matB);
		return S_OK;
	}
};




////////////////////////////////////////////////////////////////////////////////
// AnimLink attaches matrix animation to a frame.
//
struct AnimLink
{
    AnimLink      *m_pNext;         // next animation in list
    AnimFrame 	  *m_pAnimFrame;    // animation keys
    Frame         *m_pFrame;        // frame we're applying the animation to
};



////////////////////////////////////////////////////////////////////////////////
// Vertex shader parameter setting
//
// TODO: rework this whole class to cleanly separate animations from application of animations, 
// skeleton hierarchy from use of concatenated transformation

struct AnimVertexShaderParameter
{
    AnimVertexShaderParameter *m_pNext; // next animated vertex shader parameter in list
    CHAR *m_strVertexShaderReference;   // name of vertex shader
    UINT m_Index;                       // index into constants
    UINT m_Count;                       // count of constants to write
    CHAR *m_strExpression;              // expression to evaluate
    // TODO: fix this ugliness
    VOID *m_pSource; // this is the only kind of vertex shader animation we currently support
};

struct AnimVSP
{
    DWORD m_VertexShaderReference;  // vertex shader resource to write constant for
    DWORD m_Index;                  // index into constants
    DWORD m_Count;                  // count of constants to write
    VOID *m_pSource;                // pointer to source matrix
};

////////////////////////////////////////////////////////////////////////////////
// Animation resource that holds a list of vertex shader parameters to be set,
// and a list of animation expressions to evaluate.
//
struct Animation
{
    DWORD m_VSPCount;
    AnimVSP *m_rVSP;        // array of vertex shader parameter settings
    DWORD m_AnimCount;
    AnimLink *m_pAnimList;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\frame.h ===
//-----------------------------------------------------------------------------
//  
//  File: frame.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  A frame hierarchy for nested transformations.
//
//-----------------------------------------------------------------------------
#pragma once

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3dx8math.h>
typedef __declspec(align(16)) D3DXMATRIX XGMATRIX;
#define XGMatrixMultiply D3DXMatrixMultiply
#endif

#define FRAME_IDENTIFIER_SIZE 64

// hierarchies can be no wider or deeper than FRAME_MAX_STACK
#define FRAME_MAX_STACK 200

struct Frame {
	XGMATRIX   m_Matrix;							// local transformation
    CHAR       m_strName[FRAME_IDENTIFIER_SIZE];	// name of this frame
	Frame *    m_pChild;							// child frame
	Frame *    m_pNext;								// sibling frame
};

struct Skeleton {
	DWORD       m_FrameCount;	// total number of frames
	XGMATRIX *  m_rMatrix;		// cumulative transformations computed from frame hierarchy in depth-first traversal
	Frame *		m_pRoot;		// root of frame hierarchy
	
	//////////////////////////////////////////////////////////////////////
	// Set root of frame hierarchy and allocate matrix array
	// to hold one matrix per node in the hierarchy.
	//
	HRESULT SetRoot(Frame *pRoot);

	//////////////////////////////////////////////////////////////////////
	// Do depth-first traversal of frame hierarchy to compute the
	// matrix palette
	//
	HRESULT UpdateTransformations();
};

//////////////////////////////////////////////////////////////////////
// Debugging output
//
HRESULT PrintMatrix(XGMATRIX *pMat);
HRESULT PrintFrame(Frame *pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\print.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: print.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//  Printing to the debug display.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "Print.h"

#define MAX_OUT_LENGTH 10000
static WCHAR s_strOutBuf[MAX_OUT_LENGTH] = { 0 };	// start with null-terminated string
WCHAR *g_strOut = s_strOutBuf;	// debugging output string

//-----------------------------------------------------------------------------
// Name: Out
// Desc: Append a string to the debug display
//-----------------------------------------------------------------------------
HRESULT Out(CONST WCHAR *str)
{
	// append the current string
	wcsncat(g_strOut, str, MAX_OUT_LENGTH - 1);	// silently clip extra chars
	g_strOut[MAX_OUT_LENGTH - 1] = 0;	// make sure the string is terminated
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Printf
// Desc: Print a formatted string to the debug display
//-----------------------------------------------------------------------------
HRESULT Printf(CONST WCHAR *strFormat, ...)
{
	va_list val;
	va_start(val, strFormat);
	const buflen = 1000;
	WCHAR buf[buflen];
	_vsnwprintf(buf, buflen, strFormat, val);
	return Out(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\frame.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: frame.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
#include "frame.h"
#include "print.h"

//////////////////////////////////////////////////////////////////////
// Set root of frame hierarchy and allocate matrix array
//
HRESULT Skeleton::SetRoot(Frame *pRoot)
{
	m_pRoot = pRoot;
	m_FrameCount = 0;
	if (m_rMatrix != NULL)
	{
		delete [] m_rMatrix;
		m_rMatrix = NULL;
	}
		
	// Count the number of frames
	Frame *rpFrameStack[FRAME_MAX_STACK];
	int iFrameStack = 1;	// depth of stack
	rpFrameStack[0] = pRoot;	// put root on top of stack
	while (iFrameStack)
	{
		// Pop the stack
		iFrameStack--;
		Frame *pFrame = rpFrameStack[iFrameStack];
		m_FrameCount++;

		// Push sibling
		if (pFrame->m_pNext != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rpFrameStack[iFrameStack] = pFrame->m_pNext;
			iFrameStack++;
		}
		
		// Push child
		if (pFrame->m_pChild != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rpFrameStack[iFrameStack] = pFrame->m_pChild;
			iFrameStack++;
		}
	}

	// Allocate the matrix array
	m_rMatrix = new XGMATRIX [ m_FrameCount ];
	if (m_rMatrix == NULL)
		return E_OUTOFMEMORY;
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Do depth-first traversal of frame hierarchy to compute the
// matrix palette.
//
// TODO: Not all of these transformations are actually used
// in the final result.  Do dependency analysis and avoid
// computing matrices that are not used.
//
HRESULT Skeleton::UpdateTransformations()
{
	// Iterate through frame hierarchy
	struct FrameStackElement {
		Frame *pFrame;
		int iMatrixParent;	// index into m_rMatrix
	} rFrameStack[FRAME_MAX_STACK];
	rFrameStack[0].pFrame = m_pRoot;
	rFrameStack[0].iMatrixParent = -1;
	int iMatrix = 0;	// index to current entry in m_rMatrix
	int iFrameStack = 1;	// depth of stack
	while (iFrameStack)
	{
		// Pop the stack
		iFrameStack--;
		Frame *pFrame = rFrameStack[iFrameStack].pFrame;
		int iMatrixParent = rFrameStack[iFrameStack].iMatrixParent;

		// Compute cumulative transformation
		if (iMatrixParent == -1)
			m_rMatrix[iMatrix] = pFrame->m_Matrix;	// set initial transformation
		else
			XGMatrixMultiply(&m_rMatrix[iMatrix], &pFrame->m_Matrix, &m_rMatrix[iMatrixParent]); // compute transformation from parent

		// Push sibling
		if (pFrame->m_pNext != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrame->m_pNext;
			rFrameStack[iFrameStack].iMatrixParent = iMatrixParent;	// use same parent as before
			iFrameStack++;
		}
		
		// Push child
		if (pFrame->m_pChild != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrame->m_pChild;
			rFrameStack[iFrameStack].iMatrixParent = iMatrix;	// use our matrix as child's parent matrix
			iFrameStack++;
		}

		iMatrix++;
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: PrintMatrix
// Desc: Print a formatted version of a matrix
//-----------------------------------------------------------------------------
HRESULT PrintMatrix(XGMATRIX *pMatrix)
{
	for (UINT iRow = 0; iRow < 4; iRow++)
		Printf(L"  %f %f %f %f\n",
			   (*pMatrix)( iRow, 0 ),
			   (*pMatrix)( iRow, 1 ),
			   (*pMatrix)( iRow, 2 ),
			   (*pMatrix)( iRow, 3 ));
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: PrintFrame
// Desc: Print a formatted version of a frame
//-----------------------------------------------------------------------------
HRESULT PrintFrame(Frame *pFrame)
{
	WCHAR strName[FRAME_IDENTIFIER_SIZE];
	mbstowcs( strName, pFrame->m_strName, FRAME_IDENTIFIER_SIZE );
	strName[FRAME_IDENTIFIER_SIZE - 1] = 0;	// make sure string is null-terminated
	Out(strName); 
	Out(L"\n  local\n");
	PrintMatrix(&pFrame->m_Matrix);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\print.h ===
//-----------------------------------------------------------------------------
//  
//  File: print.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//  Printing to the debug display.
//-----------------------------------------------------------------------------
#pragma once

extern WCHAR *g_strOut;

HRESULT Out(CONST WCHAR *str);
HRESULT Printf(CONST WCHAR *strFormat, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\Resource.h ===
//-----------------------------------------------------------------------------
//  
//  File: Resource.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//	Wrapper around CXBPackedResource that does asynchronous reading 
//  of the resource file.
//  
//-----------------------------------------------------------------------------
#pragma once
#include <XBResource.h>

// $BUGBUG 11551
#define MAX_NUM_RESOURCES 10000

enum LOADINGSTATE { LOADING_NOTSTARTED, LOADING_HEADER, LOADING_DATA, LOADING_DONE, LOADING_FAILED };

class Resource : public CXBPackedResource
{
 public:
	Resource();
	~Resource();

	// Accessors
	DWORD Count() 					{ return m_dwNumResources; }
	DWORD GetTypeByIndex(DWORD ResourceIndex) 
		{ if (ResourceIndex >= m_dwNumResources) return 0; else return m_dwTypes[ResourceIndex]; }
	VOID *GetResourceByIndex(DWORD ResourceIndex)
		{ if (ResourceIndex >= m_dwNumResources) return NULL; else return m_ppResources[ResourceIndex]; }
	LOADINGSTATE CurrentLoadingState() { return m_LoadingState; }

    // Starts asynchronous loading of the resources out of the specified bundle
    HRESULT StartLoading( LPDIRECT3DDEVICE8 pDevice, LPSTR strFileBase );

	// Update status of loading state
	LOADINGSTATE PollLoadingState();

    // Called when Async I/O is complete to register the resources
    HRESULT OnIOComplete();

    // Unloads the resources.
    HRESULT Unload();	

	// Called by Unload to release handles, etc. to cleanup the resource before unloading.
	virtual HRESULT Cleanup(DWORD dwType,	// resource type
							BYTE *pHeader);	// pointer to resource header

	// Called by OnIOComplete to patch pointers.
	// Default Patch implementation calls register on standard resource types.
	virtual HRESULT Patch(DWORD dwType,		// resource type
						  BYTE *pHeader);	// pointer to resource header

 protected:
	LPDIRECT3DDEVICE8		m_pd3dDevice;				// for resource registration
    BYTE *				    m_ppResources[MAX_NUM_RESOURCES]; // Array of pointers to resources
    DWORD                   m_dwTypes[MAX_NUM_RESOURCES]; // Array of resource types
    HANDLE                  m_hfXPR;                // File handle for async i/o
    DWORD                   m_cbHeaders;            // Count of bytes of resource headers
    DWORD                   m_cbData;               // Count of bytes of data
    OVERLAPPED              m_overlapped;           // OVERLAPPED structure for async I/O
    LOADINGSTATE            m_LoadingState;             // current loading state
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\Resource.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: Resource.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Resource handling for effect, skeleton, and animation.
//  
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgmath.h>
#include <xgraphics.h>
#include "Resource.h"

//-----------------------------------------------------------------------------
// Name: SizeOfResource()
// Desc: Determines the size, in bytes, of the D3DResource pointed to by 
//       pRes.
//-----------------------------------------------------------------------------
static DWORD SizeOfResource( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:
            return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE:
            return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:
            return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:
            return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:
            return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:
            return sizeof(D3DPalette);
        default:
            return 0;
    }
}


//-----------------------------------------------------------------------------
// Name: Resource()
// Desc: Constructor
//-----------------------------------------------------------------------------
Resource::Resource()
{
	m_pd3dDevice    = NULL;
    m_cbHeaders     = 0;
	m_cbData        = 0;
	m_LoadingState = LOADING_NOTSTARTED;
}

//-----------------------------------------------------------------------------
// Name: ~Resource()
// Desc: Destructor
//-----------------------------------------------------------------------------
Resource::~Resource()
{
	Unload();
	if (m_pd3dDevice != NULL)
		m_pd3dDevice->Release();
}

//-----------------------------------------------------------------------------
// Name: PollLoadingState()
// Desc: Check for IO completion
//-----------------------------------------------------------------------------
LOADINGSTATE Resource::PollLoadingState()
{
    if ( m_LoadingState == LOADING_HEADER
		 || m_LoadingState == LOADING_DATA )
	{
		if ( HasOverlappedIoCompleted( &m_overlapped ) )
		{
			HRESULT hr = OnIOComplete();
			if (FAILED(hr))
				m_LoadingState = LOADING_FAILED;
		}
	}
	return m_LoadingState;
}


//-----------------------------------------------------------------------------
// Name: StartLoading()
// Desc: Loads all the resources from the given XBR. ppResources should 
//       be large enough to hold all the LPDIRECT3DRESOURCE8 pointers.  
//       The read is performed asynchronously, so the data isn't available
//       until OnIOComplete().
//-----------------------------------------------------------------------------
HRESULT Resource::StartLoading( LPDIRECT3DDEVICE8 pDevice, LPSTR strFileName )
{
    HRESULT     hr = S_OK;
    XPR_HEADER  xprh;
    HANDLE      hfHeader = INVALID_HANDLE_VALUE;
    DWORD       cb;

	// Make sure previous resources are unloaded
	Unload();

	// Set D3D device
	LPDIRECT3DDEVICE8 pDevicePrevious = m_pd3dDevice;
	m_pd3dDevice = pDevice;
	if (m_pd3dDevice)
		m_pd3dDevice->AddRef();
	if (pDevicePrevious != NULL)
		pDevicePrevious->Release();
	
    // Read out the headers first
    hfHeader = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                           OPEN_EXISTING, 0, NULL );
    if( hfHeader == INVALID_HANDLE_VALUE )
    {
        hr = E_FAIL;
        goto Done;
    }

    // Verify the XPR magic header
    if( !ReadFile( hfHeader, &xprh, sizeof( XPR_HEADER), &cb, NULL ) )
	{
		hr = E_FAIL; 
		goto Done;
	}
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        hr = E_INVALIDARG;
        goto Done;
    }

	// TODO: make header reading asynchronous, too, with LOADING_HEADER state
	
    // Allocate memory for the headers
    m_cbHeaders = xprh.dwHeaderSize - 3 * sizeof( DWORD );
    m_pSysMemData = new BYTE[m_cbHeaders];
    if( !m_pSysMemData )
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    // Read in the headers
    if( !ReadFile( hfHeader, m_pSysMemData, m_cbHeaders, &cb, NULL ) )
	{
		hr = E_FAIL; 
		goto Done;
	}
    CloseHandle( hfHeader );

    // Now read the data
    // File is opened with overlapped i/o and no buffering
    m_hfXPR = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL );
    if( m_hfXPR == INVALID_HANDLE_VALUE )
    {
        hr = E_FAIL;
        goto Done;
    }

    // Allocate contiguous memory for the texture data
    m_cbData = xprh.dwTotalSize - xprh.dwHeaderSize;
    m_pVidMemData = (BYTE *)D3D_AllocContiguousMemory( m_cbData, D3DTEXTURE_ALIGNMENT );
    if( !m_pVidMemData )
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    // Set up our overlapped i/o struct
    ZeroMemory( &m_overlapped, sizeof( OVERLAPPED ) );
    m_overlapped.Offset = xprh.dwHeaderSize;

    // Start the read of the texture data
    if( !ReadFile( m_hfXPR, m_pVidMemData, m_cbData, &cb, &m_overlapped ) )
    {
        if( GetLastError() == ERROR_IO_PENDING )
			m_LoadingState = LOADING_DATA;
        else
        {
            // Error we weren't expecting
            hr = E_FAIL;
            goto Done;
        }
    }

Done:
    // Lots of cleanup to do
    if( INVALID_HANDLE_VALUE != hfHeader )
        CloseHandle( hfHeader );

    // If we had an error condition, we need to 
    // free memory and close the XPR file
    if( FAILED( hr ) )
    {
        m_LoadingState = LOADING_FAILED;
        if( INVALID_HANDLE_VALUE != m_hfXPR )
            CloseHandle( m_hfXPR );

        delete[] m_pSysMemData;
        if( m_pVidMemData )
            D3D_FreeContiguousMemory( m_pVidMemData );
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: Unload()
// Desc: Cleans up resource state that is external to the bulk allocation.
//-----------------------------------------------------------------------------
HRESULT Resource::Unload()
{
	HRESULT hr = S_OK;

	if (m_LoadingState == LOADING_HEADER
		|| m_LoadingState == LOADING_DATA )
	{
		// Abort loading
		CloseHandle( m_hfXPR );
		m_hfXPR = INVALID_HANDLE_VALUE;
		m_LoadingState = LOADING_NOTSTARTED;
	}

    // Loop over resources, unloading as needed
    for( UINT i = 0; i < m_dwNumResources; i++ )
    {
		DWORD dwType = m_dwTypes[i];
		BYTE *pResource = m_ppResources[i];
		HRESULT hr2 = this->Cleanup(dwType, pResource);
		if (FAILED(hr2))
			hr = hr2;	// keep final result

	}
	Destroy();		// call CXBPackedResource cleanup routine
	return hr;
}

//-----------------------------------------------------------------------------
// Name: OnIOComplete()
// Desc: Called when async i/o is complete, so that we can copy the
//       texture data to video memory and register the resources.
//-----------------------------------------------------------------------------
HRESULT Resource::OnIOComplete()
{
	HRESULT hr = S_OK;
    BYTE      * pHeader;

    // Loop over resources, calling Register()
    pHeader = m_pSysMemData;
    for( int i = 0; i < MAX_NUM_RESOURCES; i++ )
    {
		DWORD dwType = *(DWORD*)pHeader;
		// Check for end token
		if ( dwType == 0xffffffff )
			break;
		// Check for userdata, which has size in header
		else if ( dwType & 0x80000000 )
		{
			DWORD dwSize = ((DWORD*)pHeader)[1];
			pHeader += 8;
			
			m_ppResources[i] = pHeader;	// pointer is to actual user data, not wrapper type and size
			m_dwTypes[i] = dwType;		// keep the type in a separate array
			
			// Special handling of user data, such as patching of file offsets to memory offsets, etc.
			hr = this->Patch(dwType, pHeader);
			if (FAILED(hr))
				break;
			pHeader += dwSize;
		}
		else
		{
			// Standard Resource
			m_dwTypes[i] = dwType & D3DCOMMON_TYPE_MASK;
			m_ppResources[i] = pHeader;
			hr = this->Patch(dwType, pHeader);
			if (FAILED(hr))
				break;
			pHeader += SizeOfResource( (LPDIRECT3DRESOURCE8)pHeader ); // standard resource types use standard sizes
		}
	}
    m_dwNumResources = i; // Number of loaded resources

    // Done with async XPR load
    CloseHandle( m_hfXPR );
    m_hfXPR = INVALID_HANDLE_VALUE;
	if (FAILED(hr))
	{
		m_LoadingState = LOADING_FAILED;
		return hr;
	}
	else
	{
		m_LoadingState = LOADING_DONE;
		return S_OK;
	}
}


//-----------------------------------------------------------------------------
// Name: OnIOComplete()
// Desc: Called when async i/o is complete, so that we can copy the
//       texture data to video memory and register the resources.
//-----------------------------------------------------------------------------
HRESULT Resource::Patch(DWORD dwType,	// resource type
						BYTE *pHeader)	// pointer to resource header
{
	if (!(dwType & 0x80000000))	// not user data
	{
		// Texture and VertexBuffer handling
		D3DResource *pResource = (D3DResource *)pHeader;
		pResource->Register( m_pVidMemData );
	}
	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Called by Unload to release handles, etc. to cleanup the resource before unloading.
//-----------------------------------------------------------------------------
HRESULT Resource::Cleanup(DWORD dwType, BYTE *pHeader)
{
	// default does nothing
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\texture.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: texture.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Texture resource drawing
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\texture.h ===
//-----------------------------------------------------------------------------
//  
//  File: texture.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Texture resource description and display.
//-----------------------------------------------------------------------------
 
#define FMT_SWIZZLED   0x1
#define FMT_LINEAR     0x2
#define FMT_COMPRESSED 0x4

const struct TEXTUREFORMAT
{
    WCHAR* name;
    DWORD  id;
    DWORD  type;
} g_TextureFormats[] = 
{
    { L"D3DFMT_A8R8G8B8",        D3DFMT_A8R8G8B8,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_A8R8G8B8",    D3DFMT_LIN_A8R8G8B8,  FMT_LINEAR      },
    { L"D3DFMT_X8R8G8B8",        D3DFMT_X8R8G8B8,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_X8R8G8B8",    D3DFMT_LIN_X8R8G8B8,  FMT_LINEAR      },
    { L"D3DFMT_R5G6B5",          D3DFMT_R5G6B5,        FMT_SWIZZLED    },
    { L"D3DFMT_LIN_R5G6B5",      D3DFMT_LIN_R5G6B5,    FMT_LINEAR      },
    { L"D3DFMT_A1R5G5B5",        D3DFMT_A1R5G5B5,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_A1R5G5B5",    D3DFMT_LIN_A1R5G5B5,  FMT_LINEAR      },
    { L"D3DFMT_A4R4G4B4",        D3DFMT_A4R4G4B4,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_A4R4G4B4",    D3DFMT_LIN_A4R4G4B4,  FMT_LINEAR      },
    { L"D3DFMT_DXT1",            D3DFMT_DXT1,          FMT_COMPRESSED  },
    { L"D3DFMT_DXT2",            D3DFMT_DXT2,          FMT_COMPRESSED  },
    { L"D3DFMT_DXT4",            D3DFMT_DXT4,          FMT_COMPRESSED  },
    { L"",                       0,                    0               },
};


// Define our vertex format
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p;          // Position
    D3DXVECTOR3 n;          // normal
    D3DCOLOR    diffuse;    // Diffuse color
    FLOAT       tu, tv;     // Texture coordinates
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1)


DWORD exptbl[] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,0,0,0,0,0,0};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\util.h ===
//-----------------------------------------------------------------------------
// File: util.h
// Desc: Handy utility functions
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>

void UnionSphere(D3DXVECTOR3 *pvCenter, float *pfRadius, const D3DXVECTOR3 &vCenter, const float &fRadius);
HRESULT ComputeBoundingSphere(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pvCenter, 
        FLOAT *pfRadius);

HRESULT DrawVertexVectors(DWORD nVertex,        // number of lines to draw
                          LPDIRECT3DVERTEXBUFFER8 pVBPosition, DWORD cbVertexSize, DWORD cbPositionOffset,  // origin of lines
                          LPDIRECT3DVERTEXBUFFER8 pVBVector, DWORD cbVectorSize, DWORD cbVectorOffset,      // offset of lines
                          float fVectorScale,   // scale
                          DWORD color0,         // color at base
                          DWORD color1);        // color at tip
HRESULT DrawNormals(DWORD nVertex, LPDIRECT3DVERTEXBUFFER8 pVB, DWORD dwFVF, float fNormalScale);

HRESULT BeginAxes();	// if you're drawing a lot of axes, call this first then call DrawAxes, then call EndAxes when done
HRESULT DrawAxes();
HRESULT EndAxes();

void PrepareDeviceForDrawSprite(IDirect3DDevice8* pDevice);
void DrawSpriteSimple(LPDIRECT3DDEVICE8 pDevice,
					  LPDIRECT3DTEXTURE8 pTexture, 
					  const D3DXVECTOR3 &ptDest,
					  float alpha,
					  float scale,
					  const RECT *pSourceRect);

WCHAR *GetString_D3DTEXTUREOP(DWORD d3dtop);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\XBR.h ===
//-----------------------------------------------------------------------------
//  
//  File: XBR.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  XML DirectX compiled resource drawing and previewing.
//
//-----------------------------------------------------------------------------
#pragma once
#include "Resource.h"
#include "xbrc.h"
#include "anim.h"
#include "effect.h"
#include "frame.h"
// #include "texture.h"

class XBR : public Resource
{
 public:
	
	// Called by OnIOComplete to patch pointers to all the effect types.
	virtual HRESULT Patch(DWORD dwType,		// resource type
						  BYTE *pHeader);	// pointer to resource header

    // Cleanup the resource before unloading.
	virtual HRESULT Cleanup(DWORD dwType,	// resource type
							BYTE *pHeader);	// pointer to resource header

	// Set a resource to be active
	HRESULT SetVertexShaderResource(DWORD VertexShaderResourceIndex);
	HRESULT SetPixelShaderResource(DWORD PixelShaderResourceIndex);
	HRESULT SetIndexBufferResource(DWORD IndexBufferResourceIndex);
	HRESULT SetTextureResource(DWORD iTextureStage, DWORD TextureResourceIndex);

	// Set the time for all of the animations in the resource list
	HRESULT SetTime(float fGlobalTime);
	
	// Draw the effect
	HRESULT DrawEffect(Effect *pEffect);

	// Debugging output
	HRESULT PrintVertexShaderDeclaration(DWORD VertexShaderResourceIndex);
	HRESULT PrintVertexShaderInputs(DWORD VertexShaderResourceIndex);

	// Constructor
	XBR()	{	m_dwSymbolCount = 0;	}

protected:
	// Symbol table was set if non-zero.  m_pResourceTags holds the (name, offset) tags
	DWORD m_dwSymbolCount;
public:
	DWORD SymbolCount()	{ return m_dwSymbolCount; }
	CONST CHAR *GetSymbolName(DWORD SymbolIndex);
	DWORD GetResourceIndexBySymbolIndex(DWORD SymbolIndex);
	DWORD GetSymbolIndex(CONST CHAR *strSymbol);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\util.cpp ===
//-----------------------------------------------------------------------------
// File: util.cpp
// Desc: Handy utility functions
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "util.h"
#include <tchar.h>

extern LPDIRECT3DDEVICE8 g_pd3dDevice;	// Defined by XbApp

//-----------------------------------------------------------------------------
// Macros for setting state and restoring on scope exit, which are
// used to set just the state needed for a debug routine.
//-----------------------------------------------------------------------------
#define SET_D3DTSS(STAGE, NAME, VALUE)\
	struct _D3DTSS_STAGE##STAGE##_##NAME {\
 		DWORD dw; \
		 _D3DTSS_STAGE##STAGE##_##NAME() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTextureStageState(STAGE, NAME, &dw);\
			g_pd3dDevice->SetTextureStageState(STAGE, NAME, VALUE);\
		}\
		 ~_D3DTSS_STAGE##STAGE##_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTextureStageState(STAGE, NAME, dw);\
		}\
	} __D3DTSS_STAGE##STAGE##_##NAME
#define SET_D3DTEXTURE(STAGE, TEXTURE)\
	struct _D3DTEXTURE_STAGE##STAGE {\
 		D3DBaseTexture *__pTexture; \
		 _D3DTEXTURE_STAGE##STAGE(D3DBaseTexture *pTexture) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTexture(STAGE, &__pTexture);\
			g_pd3dDevice->SetTexture(STAGE, pTexture);\
		}\
		 ~_D3DTEXTURE_STAGE##STAGE() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTexture(STAGE, __pTexture);\
			 if (__pTexture != NULL) __pTexture->Release();\
		}\
	} __D3DTEXTURE_STAGE##STAGE(TEXTURE)
#define SET_D3DTEXTURE_NULL(STAGE)\
	struct _D3DTEXTURE_STAGE##STAGE {\
 		D3DBaseTexture *__pTexture; \
		 _D3DTEXTURE_STAGE##STAGE() { /* constructor is called to save current value and set NULL value */ \
 			g_pd3dDevice->GetTexture(STAGE, &__pTexture);\
			g_pd3dDevice->SetTexture(STAGE, NULL);\
		}\
		 ~_D3DTEXTURE_STAGE##STAGE() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTexture(STAGE, __pTexture);\
			 if (__pTexture != NULL) __pTexture->Release();\
		}\
	} __D3DTEXTURE_NULL_STAGE##STAGE
#define SET_D3DRS(NAME, VALUE)\
	struct _D3DRS_##NAME {\
 		DWORD dw; \
		 _D3DRS_##NAME() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetRenderState(NAME, &dw);\
			g_pd3dDevice->SetRenderState(NAME, VALUE);\
		}\
		 ~_D3DRS_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetRenderState(NAME, dw);\
		}\
	} __D3DRS_##NAME
#define SET_D3DVS(VALUE)\
	struct _D3DVS {\
 		DWORD dw; \
		 _D3DVS() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetVertexShader(&dw);\
			g_pd3dDevice->SetVertexShader(VALUE);\
		}\
		 ~_D3DVS() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetVertexShader(dw);\
		}\
	} __D3DVS

//-----------------------------------------------------------------------------
// Macros used by the bounding sphere calculation routine
//-----------------------------------------------------------------------------
inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }

//-----------------------------------------------------------------------------
//  Take the union of two spheres
//-----------------------------------------------------------------------------
void UnionSphere(D3DXVECTOR3 *pvCenter, float *pfRadius, 
				 const D3DXVECTOR3 &vCenter, const float &fRadius)
{
	D3DXVECTOR3 v =  vCenter - *pvCenter;
	float vlen = D3DXVec3Length(&v);
	float a = MIN(-*pfRadius, vlen - fRadius);
	float b = MAX(*pfRadius, vlen + fRadius);
	*pfRadius = 0.5f * (b - a);
	*pvCenter += (0.5f * (b + a) / vlen) * v;
}

//-----------------------------------------------------------------------------
//  Find the bounding sphere for the vertices
//-----------------------------------------------------------------------------
HRESULT ComputeBoundingSphere(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pvCenter, 
        FLOAT *pfRadius)
{
	if (NumVertices == 0)
	{
		pvCenter->x = pvCenter->y = pvCenter->z = 0.f;
		*pfRadius = 0;
		return S_FALSE;
	}
	UINT cbVertexSize = D3DXGetFVFVertexSize(FVF);
	// use first vertex as starting point
	float feps = 1e-6f;  // use a small epsilon as zero radius
	*pvCenter = *(D3DXVECTOR3 *)pPointsFVF;
	*pfRadius = feps;
	// union in the rest of the points as zero-radius spheres
	for (UINT iVertex = 1; iVertex < NumVertices; iVertex++)
		UnionSphere(pvCenter, pfRadius, *(D3DXVECTOR3 *)((BYTE *)pPointsFVF + cbVertexSize * iVertex), feps);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Draw hedgehog vectors with origin at each vertex.
// Lines go from Position to Position + fVectorScale * Vector.
//-----------------------------------------------------------------------------
HRESULT DrawVertexVectors(DWORD nVertex,		// number of lines to draw
						  LPDIRECT3DVERTEXBUFFER8 pVBPosition, DWORD cbPositionSize, DWORD cbPositionOffset,	// origin of lines
						  LPDIRECT3DVERTEXBUFFER8 pVBVector, DWORD cbVectorSize, DWORD cbVectorOffset,		// offset of lines
						  float fVectorScale,	// scale
						  DWORD color0,		// color at base
						  DWORD color1)		// color at tip
{
	HRESULT hr = S_OK;
	const UINT nLineBuf = 1000;
	struct Vertex {
		float x, y, z;
		D3DCOLOR diffuse;
	} aVertex[nLineBuf*2];
	Vertex *pVertex = &aVertex[0];
	BYTE *pVertexPosition = NULL;
	BYTE *pVertexVector = NULL;
	UINT nLine = 0;
	SET_D3DRS( D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	SET_D3DRS( D3DRS_ZWRITEENABLE, TRUE);
	SET_D3DRS( D3DRS_ALPHATESTENABLE, FALSE);
	SET_D3DRS( D3DRS_NORMALIZENORMALS, FALSE);
	SET_D3DRS( D3DRS_ALPHABLENDENABLE, FALSE );
	SET_D3DRS( D3DRS_LIGHTING, FALSE);
	SET_D3DVS(D3DFVF_XYZ | D3DFVF_DIFFUSE);
	SET_D3DTEXTURE_NULL( 0 );
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE_NULL( 1 );
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE_NULL( 2 );
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE_NULL( 3 );
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	hr = pVBPosition->Lock(NULL, NULL, (BYTE **)&pVertexPosition, 0l );
	if (FAILED(hr))
		goto e_Exit;
	hr = pVBVector->Lock(NULL, NULL, (BYTE **)&pVertexVector, 0l );
	if (FAILED(hr))
		goto e_Exit;
	UINT iVertex;
	for (iVertex = 0; iVertex < nVertex; iVertex++)
	{
		float *pfPosition = (float *)(pVertexPosition + cbPositionSize * iVertex + cbPositionOffset);
		float *pfVector = (float *)(pVertexVector + cbVectorSize * iVertex + cbVectorOffset);
		pVertex[0].x = pfPosition[0];
		pVertex[0].y = pfPosition[1];
		pVertex[0].z = pfPosition[2];
		pVertex[0].diffuse = color0;
		pVertex[1].x = pVertex[0].x + pfVector[0] * fVectorScale;
		pVertex[1].y = pVertex[0].y + pfVector[1] * fVectorScale;
		pVertex[1].z = pVertex[0].z + pfVector[2] * fVectorScale;
		pVertex[1].diffuse = color1;
		pVertex += 2;
		nLine++;
		if (nLine == nLineBuf)
		{
			// buffer is full, so draw what we have
			hr = g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, nLine, aVertex, sizeof(Vertex));
			if (FAILED(hr))
				goto e_Exit;
			nLine = 0;
			pVertex = &aVertex[0];
		}
	}
	if (nLine != 0)
	{
		// draw any left over lines
		hr = g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, nLine, aVertex, sizeof(Vertex));
		if (FAILED(hr))
			goto e_Exit;
	}
e_Exit:
	if (pVertexPosition)
		pVBPosition->Unlock();
	if (pVertexVector)
		pVBVector->Unlock();
	return hr;
}

HRESULT DrawNormals(DWORD nVertex, LPDIRECT3DVERTEXBUFFER8 pVB, DWORD dwFVF, float fNormalScale)
{
	if (!((dwFVF & D3DFVF_XYZ) && (dwFVF & D3DFVF_NORMAL)))
		return S_FALSE; // no normals to draw
	UINT cbVertexSize = D3DXGetFVFVertexSize(dwFVF);
	return DrawVertexVectors(nVertex,
							 pVB, cbVertexSize, 0 /* position offset */,
							 pVB, cbVertexSize, 12 /* normal offset */,
							 fNormalScale,
							 D3DCOLOR_RGBA(0x00, 0xff, 0x00, 0xff),
							 D3DCOLOR_RGBA(0x00, 0xff, 0xff, 0xff));
}

//-----------------------------------------------------------------------------
//  Draw coordinate axes.
//-----------------------------------------------------------------------------

static struct CAxesState {
	SET_D3DRS(D3DRS_LIGHTING, FALSE);
	SET_D3DRS(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	SET_D3DVS(D3DFVF_XYZ|D3DFVF_DIFFUSE); // vertex shader
	SET_D3DTEXTURE_NULL( 0 );
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE_NULL( 1 );
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE_NULL( 2 );
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE_NULL( 3 );
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
} *s_pAxesState = NULL;

HRESULT BeginAxes()
{
	if (s_pAxesState != NULL)
		return E_FAIL;
	s_pAxesState = new CAxesState;
	if (s_pAxesState == NULL)
		return E_OUTOFMEMORY;
	return S_OK;
}

HRESULT EndAxes()
{
	if (s_pAxesState == NULL)
		return E_FAIL;
	delete s_pAxesState;
	s_pAxesState = NULL;
	return S_OK;
}

HRESULT DrawAxes()
{
	const float fAxisRodRadius = 0.05f;
	const float fAxisRodLength = 0.8f;
	const float fAxisConeRadius = fAxisRodRadius * 3.f;
	const float fAxisConeLength = 1.f;
	static struct AxisVertex {
		float x, y, z;
		D3DCOLOR color;
	} XAxis[] = {
		{ 0.f,             0.f,				 0.f }, 
		{ fAxisRodLength,  fAxisRodRadius,   0.f }, 
		{ fAxisRodLength,  fAxisConeRadius,  0.f }, 
		{ fAxisConeLength, 0.f,              0.f }, 
		{ fAxisRodLength,  0.f,              fAxisConeRadius }, 
		{ fAxisRodLength,  0.f,              fAxisRodRadius }, 
		{ 0.f,             0.f,              0.f },
		{ fAxisConeLength, 0.f,              0.f }, 
	};
	const int nVertex = sizeof(XAxis)/sizeof(AxisVertex);
	static AxisVertex YAxis[nVertex];
	static AxisVertex ZAxis[nVertex];
	static bool bInitialized = false;
	if (!bInitialized)
	{
		const D3DCOLOR XColor = 0xffff0000;
		const D3DCOLOR YColor = 0xff00ff00;
		const D3DCOLOR ZColor = 0xff0000ff;
		for (UINT i = 0; i < nVertex; i++)
		{
			XAxis[i].color = XColor;
			YAxis[i].x = XAxis[i].y; YAxis[i].y = XAxis[i].x; YAxis[i].z = XAxis[i].z; // swap x and y
			YAxis[i].color = YColor;
			ZAxis[i].x = XAxis[i].z; ZAxis[i].y = XAxis[i].y; ZAxis[i].z = XAxis[i].x; // swap x and z
			ZAxis[i].color = ZColor;
		}
		bInitialized = true;
	}

	if (s_pAxesState != NULL)
	{
		// BeginAxes was called, so assume state is set and just draw the axes
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, XAxis, sizeof(AxisVertex));
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, YAxis, sizeof(AxisVertex));
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, ZAxis, sizeof(AxisVertex));	
	}
	else
	{
		// set and save state
		CAxesState AxesState;

		// draw the axes
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, XAxis, sizeof(AxisVertex));
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, YAxis, sizeof(AxisVertex));
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, ZAxis, sizeof(AxisVertex));	
	}
	return S_OK;
}

//=========================================================================
// Prepare a device for a DrawSpriteSimple operation
//=========================================================================
void PrepareDeviceForDrawSprite(IDirect3DDevice8* pDevice)
{
    pDevice->SetPixelShader(0);

    pDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

    pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL);
    pDevice->SetRenderState(D3DRS_ALPHAREF, 0x00000001);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

    pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);
    pDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

    pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE);
    pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

    pDevice->SetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
    pDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_PASSTHRU);

    pDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_POINT);
}

//=========================================================================
// Draw a screen space texture sprite
//=========================================================================
void DrawSpriteSimple(LPDIRECT3DDEVICE8 pDevice,
    LPDIRECT3DTEXTURE8 pTexture, const D3DXVECTOR3 &ptDest,
    float alpha, float scale, const RECT *pSourceRect)
{
    SIZE size;
    RECT rcSrc;
    D3DSURFACE_DESC Desc;

    (void)pTexture->GetLevelDesc(0, &Desc);
    if(!pSourceRect)
    {
        rcSrc.left = 0;
        rcSrc.top = 0;
        rcSrc.right = Desc.Width;
        rcSrc.bottom = Desc.Height;

        pSourceRect = &rcSrc;
    }

    size.cx = pSourceRect->right - pSourceRect->left;
    size.cy = pSourceRect->bottom - pSourceRect->top;

    // Coordinates for Rendering Target in Screen space
    float left   = ptDest.x;
    float right  = ptDest.x + (float)size.cx*scale;
    float top    = ptDest.y;
    float bottom = ptDest.y + (float)size.cy*scale;

    // Setup texture coordinates to use
    float fTexLeft   = (float)pSourceRect->left   / (float)Desc.Width;
    float fTexTop    = (float)pSourceRect->top    / (float)Desc.Height;
    float fTexRight  = (float)pSourceRect->right  / (float)Desc.Width;
    float fTexBottom = (float)pSourceRect->bottom / (float)Desc.Height;

    // Setup alpha term to modulate in
    DWORD dwColor = ((DWORD)(alpha * 255.0f) << 24) | 0x00FFFFFF;

    struct MYD3DTLVERTEX
    {
        float   sx, sy, sz; // Screen coordinates
        float   rhw;        // Reciprocal of homogeneous w
        DWORD   color;      // Vertex color
        float   tu, tv;     // Texture coordinates
    } pvSprite[4] =
    {
        { left-0.5f,    top-0.5f, ptDest.z, 1.0f, dwColor, fTexLeft,  fTexTop},
        {right-0.5f,    top-0.5f, ptDest.z, 1.0f, dwColor, fTexRight, fTexTop},
        {right-0.5f, bottom-0.5f, ptDest.z, 1.0f, dwColor, fTexRight, fTexBottom},
        { left-0.5f, bottom-0.5f, ptDest.z, 1.0f, dwColor, fTexLeft,  fTexBottom},
    };

    pDevice->SetTexture(0, pTexture);
    pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1);

    // Display the sprite
    pDevice->DrawVerticesUP(D3DPT_QUADLIST, 4, pvSprite, sizeof(pvSprite[0]));
}

//-----------------------------------------------------------------------------
//  Return string corresponding to texture op
//-----------------------------------------------------------------------------
WCHAR *GetString_D3DTEXTUREOP(DWORD d3dtop)
{
	switch (d3dtop)
	{
	case 0:
		return L"<NONE>";
    case D3DTOP_DISABLE:
		 return L"D3DTOP_DISABLE";
    case D3DTOP_SELECTARG1:
		 return L"D3DTOP_SELECTARG1";
    case D3DTOP_SELECTARG2:
		 return L"D3DTOP_SELECTARG2";
    case D3DTOP_MODULATE:
		 return L"D3DTOP_MODULATE";
    case D3DTOP_MODULATE2X:
		 return L"D3DTOP_MODULATE2X";
    case D3DTOP_MODULATE4X:
		 return L"D3DTOP_MODULATE4X";
    case D3DTOP_ADD:
		 return L"D3DTOP_ADD";
    case D3DTOP_ADDSIGNED:
		 return L"D3DTOP_ADDSIGNED";
    case D3DTOP_ADDSIGNED2X:
		 return L"D3DTOP_ADDSIGNED2X";
    case D3DTOP_SUBTRACT:
		 return L"D3DTOP_SUBTRACT";
    case D3DTOP_ADDSMOOTH:
		 return L"D3DTOP_ADDSMOOTH";
    case D3DTOP_BLENDDIFFUSEALPHA:
		 return L"D3DTOP_BLENDDIFFUSEALPHA";
    case D3DTOP_BLENDTEXTUREALPHA:
		 return L"D3DTOP_BLENDTEXTUREALPHA";
    case D3DTOP_BLENDFACTORALPHA:
		 return L"D3DTOP_BLENDFACTORALPHA";
    case D3DTOP_BLENDTEXTUREALPHAPM:
		 return L"D3DTOP_BLENDTEXTUREALPHAPM";
    case D3DTOP_BLENDCURRENTALPHA:
		 return L"D3DTOP_BLENDCURRENTALPHA";
    case D3DTOP_PREMODULATE:
		 return L"D3DTOP_PREMODULATE";
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
		 return L"D3DTOP_MODULATEALPHA_ADDCOLOR";
    case D3DTOP_MODULATECOLOR_ADDALPHA:
		 return L"D3DTOP_MODULATECOLOR_ADDALPHA";
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
		 return L"D3DTOP_MODULATEINVALPHA_ADDCOLOR";
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
		 return L"D3DTOP_MODULATEINVCOLOR_ADDALPHA";
    case D3DTOP_BUMPENVMAP:
		 return L"D3DTOP_BUMPENVMAP";
    case D3DTOP_BUMPENVMAPLUMINANCE:
		 return L"D3DTOP_BUMPENVMAPLUMINANCE";
    case D3DTOP_DOTPRODUCT3:
		 return L"D3DTOP_DOTPRODUCT3";
    case D3DTOP_MULTIPLYADD:
		 return L"D3DTOP_MULTIPLYADD";
    case D3DTOP_LERP:
		 return L"D3DTOP_LERP";
	default:
		return L"<UNKNOWN>";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\xbrc.h ===
//-----------------------------------------------------------------------------
//  
//  File: xbrc.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Resource type constants
//-----------------------------------------------------------------------------
 
#define XBRC_USER_DATA_FLAG 0x80000000

// D3D resources
//#define XBRC_SURFACE       D3DRTYPE_SURFACE
//#define XBRC_VOLUME        D3DRTYPE_VOLUME
//#define XBRC_TEXTURE       	 D3DRTYPE_TEXTURE
//#define XBRC_VOLUMETEXTURE 	 D3DRTYPE_VOLUMETEXTURE
//#define XBRC_CUBETEXTURE   	 D3DRTYPE_CUBETEXTURE  
//#define XBRC_VERTEXBUFFER  	 D3DRTYPE_VERTEXBUFFER
//#define XBRC_PUSHBUFFER    D3DRTYPE_PUSHBUFFER
//#define XBRC_PALETTE       D3DRTYPE_PALETTE
//#define XBRC_FIXUP         D3DRTYPE_FIXUP

// Additional resources
// TODO: change index buffer to (XBRC_USER_DATA_FLAG|D3DRTYPE_INDEXBUFFER)
#define XBRC_INDEXBUFFER			(XBRC_USER_DATA_FLAG|D3DCOMMON_TYPE_INDEXBUFFER)
#define XBRC_VERTEXSHADER 			(XBRC_USER_DATA_FLAG|0x010)
#define XBRC_PIXELSHADER			(XBRC_USER_DATA_FLAG|0x020)
#define XBRC_EFFECT					(XBRC_USER_DATA_FLAG|0x040)
#define XBRC_SKELETON				(XBRC_USER_DATA_FLAG|0x050)
#define XBRC_ANIMATION				(XBRC_USER_DATA_FLAG|0x060)

// The symbol table maps strings to offsets.
#define XBRC_SYMBOLTABLE				(XBRC_USER_DATA_FLAG|0x100)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\crypt.cpp ===
/*
 *
 * crypt.cpp
 *
 * CCryptProvider and related interfaces
 *
 */

#include "precomp.h"

const BYTE CDevkitCrypt::rgbPrivateKey[1340] =
    {
           0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
           0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
           0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
           0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
           0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
           0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
           0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
           0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
           0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
           0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
           0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
           0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
           0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
           0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
           0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
           0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
           0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
           0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
           0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
           0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
           0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
           0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
           0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
           0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
           0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
           0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
           0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
           0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
           0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
           0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
           0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
           0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
           0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0xCD,0xE1,0xAD,0xFB,
           0x97,0x2B,0x02,0xF8,0xC9,0xB4,0xFF,0xF7,
           0x81,0x6C,0xC1,0x91,0x11,0xB8,0x44,0x5A,
           0xF9,0x18,0x6C,0x20,0xB5,0xBC,0xA9,0x17,
           0xD7,0x21,0x76,0x50,0x65,0xA0,0xB5,0x7B,
           0x70,0x57,0x19,0x3C,0xA0,0x03,0x59,0x27,
           0x5D,0xBA,0xE1,0x66,0xEE,0xAF,0xB1,0xFE,
           0x59,0xCE,0x9A,0x80,0x96,0xA8,0x8A,0x0A,
           0x96,0x05,0x92,0x1D,0x43,0xF9,0xB5,0x10,
           0x22,0xE8,0xB7,0xFC,0x93,0x40,0x85,0x63,
           0xF9,0x96,0xEC,0x24,0xE8,0xDE,0xAC,0x65,
           0x17,0xA7,0xD7,0x6C,0xFB,0x0A,0x6E,0x0C,
           0xFA,0xCC,0xF3,0xB1,0xC9,0x13,0x6A,0xB0,
           0x99,0x10,0x1B,0x69,0x7B,0xB0,0x1E,0x36,
           0x9E,0xDD,0x67,0xD4,0xD2,0xE3,0xB1,0x11,
           0xE7,0xEB,0x8C,0x14,0x6F,0xCC,0xCE,0x71,
           0xA5,0x29,0xA2,0xCE,0x00,0x00,0x00,0x00,
           0x07,0xB3,0xF5,0x5E,0x12,0x32,0x0D,0x07,
           0x28,0x09,0x10,0xCB,0x78,0xFD,0xDA,0x92,
           0xB3,0xCB,0x54,0xBF,0x66,0x5F,0x0E,0xCB,
           0x0B,0x66,0x94,0xDA,0x03,0xCB,0xBA,0x05,
           0xA5,0xE6,0x4B,0xBD,0x28,0xC8,0x12,0xB1,
           0x6C,0x6B,0x2A,0x9D,0x86,0xE1,0x57,0xAC,
           0xC1,0x8F,0x1B,0xF7,0x26,0x39,0x3E,0x44,
           0x9E,0x53,0x12,0x25,0x88,0x0A,0x3F,0xE0,
           0xF7,0xA5,0xB8,0xCD,0xF7,0xE3,0x63,0xA8,
           0xF3,0xBD,0x78,0xFE,0x5C,0xB2,0x73,0x84,
           0xE3,0x25,0x9A,0x28,0xE2,0x35,0x55,0xC3,
           0x4B,0xD4,0x17,0x96,0xBE,0xC8,0xC6,0x26,
           0x40,0x2C,0xEC,0x2E,0x54,0x28,0x0E,0xBC,
           0x6B,0xE0,0x0F,0x58,0xB7,0xAB,0x93,0x84,
           0x78,0x47,0x53,0x06,0xD1,0x84,0xBE,0x79,
           0x35,0x13,0xA6,0x75,0x76,0xCF,0x8E,0xC0,
           0x00,0x00,0x00,0x00,0x95,0xAE,0xEA,0x78,
           0x33,0xBB,0x54,0x92,0x45,0xE4,0xA6,0xD1,
           0xFA,0x5E,0xE0,0x94,0x1E,0xAC,0xFA,0x4D,
           0x06,0x48,0xEE,0x92,0x4F,0x19,0x2A,0xD3,
           0xE6,0x45,0x75,0x4E,0x24,0x6B,0xDB,0x18,
           0xF0,0xD0,0x42,0xEA,0x8E,0x2D,0x3F,0xC8,
           0x40,0xB1,0x30,0x59,0x0B,0x3C,0x94,0x6A,
           0x91,0xD8,0x3C,0xDC,0xC5,0xE7,0x84,0xB1,
           0x1D,0x01,0x38,0x62,0x38,0x0E,0x23,0x1E,
           0xCF,0x69,0x7C,0xAD,0xC5,0xA3,0xE2,0x97,
           0x57,0x72,0x65,0x66,0xD2,0x76,0x74,0x58,
           0x1C,0x58,0x6D,0x70,0x18,0x43,0x8D,0x83,
           0x45,0x29,0x23,0xC6,0xA0,0xB8,0x06,0x96,
           0x0E,0xCA,0x2B,0x16,0xF4,0x62,0x48,0x77,
           0x0B,0x1A,0x89,0xA8,0x41,0xB8,0xD6,0xFF,
           0x3A,0x76,0x4B,0xF4,0x2D,0x52,0x96,0xF8,
           0xC6,0x69,0xA9,0x31,0x00,0x00,0x00,0x00,
           0xB3,0xC9,0x4D,0xCE,0x69,0xEF,0x44,0x70,
           0x7E,0x77,0x52,0x14,0x0E,0x71,0x52,0xED,
           0x48,0x6D,0x2C,0xFA,0x77,0x6A,0xA0,0x78,
           0xC8,0x05,0x24,0xB7,0xD3,0x00,0x2E,0x44,
           0x36,0x73,0xE1,0x87,0x1A,0x75,0x4D,0x7F,
           0x62,0xA4,0x0D,0xB2,0x6C,0xB9,0x07,0x5E,
           0xF7,0x9E,0x21,0x42,0xDD,0xC9,0xA2,0x6A,
           0x62,0x96,0xD6,0x4B,0xF2,0x25,0x87,0x75,
           0x4B,0xE4,0x21,0x5F,0x59,0xCD,0x76,0x40,
           0x6D,0x35,0xC1,0xBD,0x6A,0x12,0xED,0x12,
           0x89,0xB5,0xA8,0x58,0xF4,0x15,0x95,0x47,
           0x84,0xFA,0xF1,0xD8,0xE2,0x85,0x9C,0x52,
           0x81,0xDD,0x0B,0x64,0x48,0xF0,0xFC,0x1F,
           0x9A,0x31,0x12,0xA1,0x08,0xD8,0x0C,0xF9,
           0x64,0xAE,0x36,0x04,0x2E,0x1D,0xCE,0xBD,
           0x3F,0xFC,0xEE,0x62,0xB2,0x8B,0x4E,0x4C,
           0x00,0x00,0x00,0x00,0xA3,0x67,0xDF,0xAE,
           0xF0,0x4B,0x5F,0xF5,0x46,0xB1,0x67,0x39,
           0x24,0x29,0xD6,0xE2,0xDF,0x78,0xB1,0x05,
           0x63,0x3F,0x03,0xB0,0xEF,0x01,0x14,0xD8,
           0x42,0x69,0x4D,0x1D,0x87,0xB2,0x4C,0x3B,
           0x21,0xD6,0xA2,0xA1,0xBD,0x5E,0xCB,0xB2,
           0x97,0xBB,0x23,0xD8,0xB6,0x0B,0x68,0x94,
           0x25,0x6F,0x2B,0xFD,0xAD,0x6F,0x33,0x58,
           0xB1,0x77,0x1E,0x77,0x0D,0xF3,0xFC,0xCE,
           0x32,0x58,0x9A,0x15,0xC7,0xCE,0x29,0x5A,
           0x8A,0x0F,0x94,0xF9,0xBD,0x3C,0xAC,0x45,
           0xC3,0x6E,0x3C,0x72,0x95,0x2D,0xDD,0x16,
           0x30,0x5F,0x9D,0xD7,0x1C,0x76,0xA2,0x6C,
           0xCE,0xF0,0x7B,0x35,0xDC,0xD4,0x7E,0xEF,
           0x8E,0x01,0x53,0xE8,0x43,0xF8,0x18,0xDF,
           0xBD,0x25,0x6C,0xBC,0x5E,0x42,0x5D,0xA1,
           0x75,0xC9,0x76,0x7E,0x00,0x00,0x00,0x00,
           0xA9,0x91,0x2B,0xBF,0x27,0x08,0x55,0xC3,
           0xDE,0xC9,0x11,0xF1,0x37,0xCC,0xAA,0xC9,
           0x81,0xC8,0x1D,0xD1,0x12,0xA4,0xB0,0xD6,
           0x65,0xAB,0xBB,0x92,0xD5,0x37,0x6F,0x70,
           0x8C,0xAC,0x30,0xF7,0xA7,0x79,0x10,0xEC,
           0x46,0xA3,0x08,0x2A,0xC4,0x9A,0xD0,0x49,
           0x3A,0x77,0x23,0xF2,0x86,0xEF,0x82,0xE5,
           0xE5,0x7B,0x50,0xED,0xD5,0x43,0xA7,0x33,
           0xED,0xD7,0xA4,0x7A,0xB6,0x35,0x60,0x9D,
           0xB9,0xAD,0x93,0xB4,0xD6,0x3C,0x3D,0xCE,
           0xDF,0x43,0x00,0xC2,0xFC,0xE1,0x5A,0x98,
           0x3A,0x07,0x7B,0xCE,0xA1,0x2F,0xEE,0x01,
           0x70,0x83,0x8B,0xC1,0x3F,0xB7,0x79,0x5E,
           0x3D,0x2F,0xBD,0x9F,0x7D,0xD9,0xBE,0x66,
           0xE2,0x32,0xD4,0x92,0x3D,0xD5,0xE1,0x9F,
           0xE7,0x2F,0x22,0x52,0xCA,0xD1,0xFB,0xBC,
           0x6F,0x80,0x82,0x34,0x1D,0x13,0x07,0x39,
           0x24,0xC7,0x83,0x7D,0x61,0x9A,0x73,0x84,
           0x6B,0x30,0x79,0x10,0xE6,0x1F,0xC7,0xC1,
           0x0F,0x22,0x09,0xAA,0x15,0xB7,0x00,0x1D,
           0x6E,0x1A,0x93,0x4D,0x34,0xC7,0x1B,0x75,
           0x56,0xAF,0x48,0x14,0x6D,0x66,0x9A,0xB6,
           0x8E,0x69,0xFA,0x67,0x95,0x78,0xEC,0xE6,
           0x9E,0xAF,0x43,0xA0,0x3D,0x43,0x6F,0xD1,
           0x49,0x4F,0x35,0x6A,0x9C,0x83,0xB3,0x03,
           0x50,0x40,0x2C,0x4A,0x63,0x2B,0x15,0x43,
           0x6C,0x1E,0xDD,0x9D,0x61,0xA3,0x04,0xBB,
           0x87,0xB6,0x35,0x1A,0x32,0x48,0x0F,0x87,
           0xF3,0xE9,0x32,0x38,0x8B,0x7A,0x5F,0x74,
           0x87,0x47,0x5A,0xEE,0x65,0x5C,0xBC,0x9F,
           0xAF,0xB5,0x88,0xA6,0x77,0x5B,0xA5,0x3A,
           0xB7,0xDB,0x54,0xB4,0xF5,0x78,0x32,0x1E,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

const BYTE CDevkitCrypt::rgbPublicKey[284] = 
    {
           0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
           0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
           0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
           0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
           0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
           0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
           0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
           0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
           0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
           0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
           0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
           0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
           0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
           0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
           0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
           0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
           0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
           0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
           0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
           0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
           0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
           0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
           0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
           0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
           0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
           0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
           0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
           0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
           0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
           0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
           0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
           0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
           0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

void CSimpleCrypt::Setup(void)
{
    m_pbSessionKey = NULL;
    m_cbSessionKey = 0;
}

void CSimpleCrypt::SetKeys(const BYTE *pbPublic, const BYTE *pbPrivate)
{
    m_pbPublicKey = pbPublic;
    m_pbPrivateKey = pbPrivate;
}

int CSimpleCrypt::CbGetDigestSize(void) const
{
    return XC_DIGEST_LEN;
}

int CSimpleCrypt::CbGetEncryptedDigestSize(void) const
{
    return XCCalcSigSize((PBYTE)m_pbPublicKey);
}

BOOL CSimpleCrypt::FComputeDigest(const BYTE *pb, DWORD cb, LPBYTE pbDigest) const
{
    XCCalcDigest((LPBYTE)pb, cb, pbDigest);
    return TRUE;
}

BOOL CSHACrypt::FComputeDigest(const BYTE *pb, DWORD cb, LPBYTE pbDigest) const
{
    A_SHA_CTX   SHAHash;

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PBYTE)pb, cb);
    A_SHAFinal(&SHAHash, pbDigest);

    return TRUE;
}

BOOL CSimpleCrypt::FComputeEncryptedDigest(const BYTE *pb, DWORD cb,
    LPBYTE pbDigest) const
{
    BYTE rgbDigest[XC_DIGEST_LEN];

    if(!m_pbPrivateKey)
        return FALSE;
    XCCalcDigest((LPBYTE)pb, cb, rgbDigest);
    XCSignDigest(rgbDigest, (PBYTE)m_pbPrivateKey, pbDigest);
    return TRUE;
}

BOOL CSimpleCrypt::FStartProgressiveHash(void)
{
    A_SHAInit(&m_sha);
    return TRUE;
}

BOOL CSimpleCrypt::FProgressiveHashData(const BYTE *pb, DWORD cb)
{
    A_SHAUpdate(&m_sha, (PBYTE)pb, cb);
    return TRUE;
}

BOOL CSimpleCrypt::FComputeProgressiveHash(LPBYTE pbDigest) const
{
    A_SHA_CTX sha = m_sha;
    A_SHAFinal(&sha, pbDigest);
    return TRUE;
}

BOOL CSimpleCrypt::FEncryptProgressiveHash(LPBYTE pbDigest) const
{
    BYTE rgbDigest[XC_DIGEST_LEN];
    A_SHA_CTX sha;

    if(!m_pbPrivateKey)
        return FALSE;
    sha = m_sha;
    A_SHAFinal(&sha, rgbDigest);
    XCSignDigest(rgbDigest, (PBYTE)m_pbPrivateKey, pbDigest);
    return TRUE;
}

BOOL CSimpleCrypt::FVerifyEncryptedDigest(const BYTE *pb, DWORD cb,
        const BYTE *pbSigned) const
{
    BYTE *rgbTemp;
    BYTE rgbDigest[XC_DIGEST_LEN];

    if(!m_pbPublicKey)
        return FALSE;
    if(!FComputeDigest(pb, cb, rgbDigest))
        return FALSE;
    rgbTemp = (PBYTE)_alloca(2 * XCCalcKeyLen((PBYTE)m_pbPublicKey));
    return XCVerifyDigest((PBYTE)pbSigned, (PBYTE)m_pbPublicKey, rgbTemp,
        (PBYTE)rgbDigest);
}

BOOL CSimpleCrypt::FVerifyEncryptedProgressiveHash(const BYTE *pbSigned) const
{
    BYTE *rgbTemp;
    BYTE rgbDigest[XC_DIGEST_LEN];
    A_SHA_CTX sha;

    if(!m_pbPublicKey)
        return FALSE;
    sha = m_sha;
    A_SHAFinal(&sha, rgbDigest);
    rgbTemp = (PBYTE)_alloca(2 * XCCalcKeyLen((PBYTE)m_pbPublicKey));
    return XCVerifyDigest((PBYTE)pbSigned, (PBYTE)m_pbPublicKey, rgbTemp,
        (PBYTE)rgbDigest);
}

BOOL CSimpleCrypt::FComputeSessionKeyFromData(const BYTE *pb, DWORD cb, DWORD cbit)
{
    PBYTE pbKey;

    DestroySessionKey();

    m_cbSessionKey = cbit ? (cbit + 7) / 8 : CbGetDigestSize();
    m_pbSessionKey = (PBYTE)malloc(m_cbSessionKey);
    if(cbit)
        /* Need to compute the key into a temp and then copy it */
        pbKey = (PBYTE)_alloca(CbGetDigestSize());
    else
        pbKey = m_pbSessionKey;
    if(!FComputeDigest(pb, cb, pbKey))
        DestroySessionKey();
    else if(cbit)
        memcpy(m_pbSessionKey, pbKey, m_cbSessionKey);
    return m_pbSessionKey != NULL;
}

void CSimpleCrypt::DestroySessionKey(void)
{
    if(m_pbSessionKey) {
        memset(m_pbSessionKey, 0, m_cbSessionKey);
        free(m_pbSessionKey);
        m_pbSessionKey = NULL;
    }
}

BOOL CSimpleCrypt::FSessionEncrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const
{
    if(!m_pbSessionKey)
        return FALSE;
    if(pbOut != pbIn)
        memcpy(pbOut, pbIn, cbIn);
    XCSymmetricEncDec(pbOut, cbIn, m_pbSessionKey, m_cbSessionKey);
    return TRUE;
}

BOOL CSimpleCrypt::FSessionDecrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const
{
    return FSessionEncrypt(pbIn, cbIn, pbOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\XBR.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: XBR.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  XML DirectX compiled resource drawing.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBR.h"
#include "Print.h"

// Called by OnIOComplete to patch pointers to all the effect types.
HRESULT XBR::Patch(DWORD dwType, BYTE *pHeader)
{
	HRESULT hr;
	if (dwType == XBRC_INDEXBUFFER)
	{
		// Patch index data offset
		D3DIndexBuffer *pIB = (D3DIndexBuffer *)pHeader;
		pIB->Data += (DWORD)pIB;	// convert structure offset to pointer
	}
	else if (dwType == XBRC_VERTEXSHADER)
	{
		// Currently, we keep references to resources as indices.
		// We could instead patch these to resource pointers.
		// The vertex shader refers to other vertex
		// shaders and to vertex buffers for stream data.
		VertexShader *pVertexShader = (VertexShader *)pHeader;
		pVertexShader->Declaration = (DWORD *)(pHeader + (DWORD)pVertexShader->Declaration);
		pVertexShader->Function = (DWORD *)(pHeader + (DWORD)pVertexShader->Function);
	}
	else if (dwType == XBRC_PIXELSHADER)
	{
		// Pixel shaders are defined inline and do not need patching.
	}
	else if (dwType == XBRC_EFFECT)
	{
		// Patch the file offsets to memory offsets
		Effect *pEffect = (Effect *)pHeader;
		pEffect->rPass = (Pass *)(pHeader + (DWORD)pEffect->rPass);	// overwrite rPass
		for (UINT iPass = 0; iPass < pEffect->PassCount; iPass++)
		{
			Pass *pPass = &pEffect->rPass[iPass];
			pPass->rRenderState = (RenderState *)(pHeader + (DWORD)pPass->rRenderState);
			pPass->rTextureStage = (TextureStage *)(pHeader + (DWORD)pPass->rTextureStage);
			for (UINT iTextureStage = 0; iTextureStage < pPass->TextureStageCount; iTextureStage++)
			{
				TextureStage *pTextureStage = &pPass->rTextureStage[iTextureStage];
				pTextureStage->rTextureState = (TextureState *)(pHeader + (DWORD)pTextureStage->rTextureState);
			}
			pPass->rDraw = (Draw *)(pHeader + (DWORD)pPass->rDraw);
		}
	}
	else if (dwType == XBRC_SKELETON)
	{
		// Patch the file offsets to memory offsets
		Skeleton *pSkeleton = (Skeleton *)pHeader;
		*(DWORD *)&pSkeleton->m_rMatrix += (DWORD)m_pSysMemData;
		*(DWORD *)&pSkeleton->m_pRoot += (DWORD)m_pSysMemData;
		Frame *pFrame = pSkeleton->m_pRoot;
		for (UINT iFrame = 0; iFrame < pSkeleton->m_FrameCount; iFrame++)
		{
			if (pFrame->m_pChild != NULL)
				*(DWORD *)&pFrame->m_pChild += (DWORD)m_pSysMemData;
			if (pFrame->m_pNext != NULL)
				*(DWORD *)&pFrame->m_pNext += (DWORD)m_pSysMemData;
			pFrame++;	// frames are laid out in an array
		}
	}
	else if (dwType == XBRC_ANIMATION)
	{
		// Patch the file offsets to memory offsets
		Animation *pAnimation = (Animation *)pHeader;
		if (pAnimation->m_rVSP != NULL)
		{
			*(DWORD *)&pAnimation->m_rVSP += (DWORD)m_pSysMemData;
			for (UINT iVSP = 0; iVSP < pAnimation->m_VSPCount; iVSP++)
			{
				AnimVSP *pVSP = &pAnimation->m_rVSP[iVSP];
				*(DWORD *)&pVSP->m_pSource += (DWORD)m_pSysMemData;	// source matrix
			}
		}
		if (pAnimation->m_pAnimList != NULL)
		{
			*(DWORD *)&pAnimation->m_pAnimList += (DWORD)m_pSysMemData;
			for (UINT iAnim = 0; iAnim < pAnimation->m_AnimCount; iAnim++)
			{
				AnimLink *pAnim = &pAnimation->m_pAnimList[iAnim];	// list is laid out in an array
				if (pAnim->m_pNext != NULL)
					*(DWORD *)&pAnim->m_pNext += (DWORD)m_pSysMemData;
				*(DWORD *)&pAnim->m_pAnimFrame += (DWORD)m_pSysMemData;
				hr = pAnim->m_pAnimFrame->Patch(m_pSysMemData);
				if (FAILED(hr))
					return hr;
				*(DWORD *)&pAnim->m_pFrame += (DWORD)m_pSysMemData;	// target frame
			}
		}
	}
	else if (dwType == XBRC_SYMBOLTABLE)
	{
		// Use symbol table only if user did not specify a resource tag array
		if (m_pResourceTags != NULL)
			return S_OK;

		// Get symbol count and resource tag pointer
		m_dwSymbolCount = *(DWORD *)pHeader;
		m_pResourceTags = (XBRESOURCE *)(pHeader + sizeof(DWORD));
		
		// Convert file offsets to string pointers
		for (UINT iSymbol = 0; iSymbol < m_dwSymbolCount; iSymbol++)
			*(DWORD *)&m_pResourceTags[iSymbol].strName += *(DWORD *)&m_pSysMemData;
	}
	else
		return Resource::Patch(dwType, pHeader);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Called by Unload to release handles, etc. to cleanup the resource before unloading.
//-----------------------------------------------------------------------------
HRESULT XBR::Cleanup(DWORD dwType, BYTE *pHeader)
{
	// Currently, VertexShaders are the only resource with "dangling" references
	if (dwType == XBRC_VERTEXSHADER)
	{
		VertexShader *pVertexShader = (VertexShader *)pHeader;
		if (pVertexShader->Handle)
			m_pd3dDevice->DeleteVertexShader(pVertexShader->Handle);
	}
	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SetVertexShaderConstant
// Desc: Look through VertexShader Declaration and set constant
//-----------------------------------------------------------------------------
static HRESULT SetVertexShaderConstant(VertexShader *pVertexShader, INT Register, CONST VOID *pConstantData, DWORD ConstantCount)
{
	if (pVertexShader->DeclarationByteCount == 0)
		return E_INVALIDARG;	// no declaration to parse
	DWORD *pToken = (DWORD *)pVertexShader->Declaration;
	while (*pToken != D3DVSD_END() )
	{
		switch (*pToken & D3DVSD_TOKENTYPEMASK)
		{
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM):
		{
			// parse the token
			INT addr = ((*pToken & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT) - 96;
			UINT count = (*pToken & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT;
			FLOAT *pValue = (float *)(pToken + 1);
			if (Register < (INT)(addr + count) && addr < (INT)(Register + ConstantCount))
			{
				// get the range to set
				INT addrStart = Register;
				if (addrStart < addr)
					addrStart = addr;
				INT addrEnd = Register + ConstantCount;
				if (addrEnd > (INT)(addr + count))
					addrEnd = addr + count;
				
				// set the constants
				FLOAT *pValueSrc = (FLOAT *)pConstantData + 4 * (addrStart - Register);
				FLOAT *pValueDst = pValue + 4 * (addrStart - addr);
				memcpy(pValueDst, pValueSrc, 4 * (addrEnd - addrStart) * sizeof(float));
			}
			pToken += 4 * count;
			break;
		}

		// ignore stream and nop tokens
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM):
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA):
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_NOP):
			break;
			
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_END):
			goto loop_break;
			
		default:
			Printf(L"Vertex shader declaration token (0x%x) not handled.\n", *pToken );
			return E_FAIL;
		}

		// Go to the next token in the stream
		pToken++;
		if ((BYTE *)pToken - (BYTE *)pVertexShader->Declaration > (INT)pVertexShader->DeclarationByteCount)
		{
			Out(L"Vertex shader declaration missing end token.\n");
			goto loop_break;
		}
	}
 loop_break:
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ApplyVertexShaderConstants
// Desc: Call m_pd3dDevice->SetVertexShaderConstants on all the constants
//       in the declaration.
//-----------------------------------------------------------------------------
static HRESULT ApplyVertexShaderConstants(LPDIRECT3DDEVICE8 pd3dDevice,
										  VertexShader *pVertexShader,
										  bool *pbStreamDeclaration)
{
	if (pbStreamDeclaration)
		*pbStreamDeclaration = false;
	if (pVertexShader->DeclarationByteCount == 0)
		return S_FALSE;	// no declaration to parse
	static bool bDumpConstants = false;	// debug
	DWORD *pToken = (DWORD *)pVertexShader->Declaration;
	while (*pToken != D3DVSD_END() )
	{
		switch (*pToken & D3DVSD_TOKENTYPEMASK)
		{
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM):
		{
			// parse the token
			int addr = ((*pToken & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT) - 96;
			UINT count = (*pToken & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT;
					
			// set the constants
			pd3dDevice->SetVertexShaderConstant(addr, pToken + 1, count);

			if (bDumpConstants)	// debug
			{
				// print out the constants for debugging
				float *pValue = (float *)(pToken + 1);
				for (UINT i = 0; i < count; i++)
				{
					Printf(L"c%d %g %g %g %g\n",
						   addr + i, 
						   *(float *)&pValue[i*4], 
						   *(float *)&pValue[i*4+1],
						   *(float *)&pValue[i*4+2], 
						   *(float *)&pValue[i*4+3]);
				}
			}
			
			pToken += 4 * count;
			break;
		}
		
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM):
			// Ignore stream tokens
			break;
					
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA):
			if (pbStreamDeclaration)
				*pbStreamDeclaration = true;
			break;
					
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_NOP):
			break;
			
		case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_END):
			goto loop_break;
			
		default:
			Printf(L"Vertex shader declaration token (0x%x) not handled.\n", *pToken );
			return E_FAIL;
		}

		// Go to the next token in the stream
		pToken++;
		if ((BYTE *)pToken - (BYTE *)pVertexShader->Declaration > (INT)pVertexShader->DeclarationByteCount)
		{
			Out(L"Vertex shader declaration missing end token.\n");
			goto loop_break;
		}
	}
 loop_break:
	bDumpConstants = false;		// debug
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetVertexShaderResource
// Desc: Create a vertex shader from a resource and set it to be current
//-----------------------------------------------------------------------------
HRESULT XBR::SetVertexShaderResource(DWORD VertexShaderResourceIndex)
{
	HRESULT hr;
	if (VertexShaderResourceIndex == 0)
		return S_FALSE;	// NULL
	if (this->GetTypeByIndex(VertexShaderResourceIndex - 1) != XBRC_VERTEXSHADER)
		return E_FAIL;	// bad type
	VertexShader *pVS = (VertexShader *)this->GetResourceByIndex(VertexShaderResourceIndex - 1);
	VertexShader *pVSRef = NULL;
	if (pVS->VertexShaderReference == 0)
	{
		// No vertex shader reference, so simply set the shader.
		if (pVS->Handle == 0)
		{
			// Create the vertex shader
			DWORD flags = 0;
			hr = m_pd3dDevice->CreateVertexShader( pVS->Declaration, pVS->Function, &pVS->Handle, flags );
			if (FAILED(hr))
				return hr;
		}
		// new version of d3d complains if SetVertexShaderInput is active when we
		// call SetVertexShader, so turn it off first
		hr = m_pd3dDevice->SetVertexShaderInput(0, 0, 0);
		if (FAILED(hr))
			return hr;
			
		hr = m_pd3dDevice->SetVertexShader(pVS->Handle);
		if (FAILED(hr))
			return hr;

		// Set any vertex shader constants that may be animated
		// TODO: Fix redundancy for non-animated vertex shader constants.
		bool bStreamDeclaration;
		hr = ApplyVertexShaderConstants(m_pd3dDevice, pVS, &bStreamDeclaration);
		if (FAILED(hr))
			return hr;
		
		// Map vertex buffers to streams
		D3DSTREAM_INPUT rStreamInput[VERTEXSHADER_MAX_STREAMS];
		UINT StreamCount = 0;
		for (UINT iStream = 0; iStream < VERTEXSHADER_MAX_STREAMS; iStream++)
		{
			DWORD iVB = pVS->rStreamInput[iStream].VertexBufferReference;
			if (iVB != 0)
			{
				if (iVB - 1 >= this->Count()
					|| this->GetTypeByIndex(iVB - 1) != D3DCOMMON_TYPE_VERTEXBUFFER)
					return E_FAIL;
				rStreamInput[iStream].VertexBuffer = (D3DVertexBuffer *)this->GetResourceByIndex(iVB - 1);
				rStreamInput[iStream].Stride = pVS->rStreamInput[iStream].Stride;
				rStreamInput[iStream].Offset = pVS->rStreamInput[iStream].Offset;
				StreamCount = iStream + 1;	// use maximum stream index to set count
			}
			else
			{
				rStreamInput[iStream].VertexBuffer = NULL;
				rStreamInput[iStream].Stride = 0;
				rStreamInput[iStream].Offset = 0;
			}
		}
		if (StreamCount)
		{
			hr = m_pd3dDevice->SetVertexShaderInput(pVS->Handle, StreamCount, rStreamInput);
			if (FAILED(hr))
				return hr;
		}
	}
	else
	{
		// Lookup vertex shader reference
		
		// TODO: Resolve all this stuff at compile time.

		// We should probably move away from using the vertex shader
		// reference business, and separate out the declaration from
		// the constants and stream mapping.

		// Right now, the only reference supported is a change in the
		// stream mapping and a change in the constants.
		hr = SetVertexShaderResource(pVS->VertexShaderReference);
		if (FAILED(hr))
			return hr;
		
		if (pVS->FunctionByteCount != 0)
			return E_FAIL;

		// Get the reference vertex shader description
		pVSRef = (VertexShader *)this->GetResourceByIndex(pVS->VertexShaderReference - 1);

		// Look through our own declaration for constants. For
		// shaders that reference other shaders, this is the
		// way that constants are over-ridden from the default.
		bool bStreamDeclaration = false;	// and check to see if the declaration has changed
		hr = ApplyVertexShaderConstants(m_pd3dDevice, pVS, &bStreamDeclaration);
		if (FAILED(hr))
			return hr;
		if (bStreamDeclaration)
		{
			// TODO: We redeclared the shader declaration, so we need to create a new version of the vertex shader
		}

		// Map vertex buffers to streams
		UINT StreamCount = 0;
		D3DSTREAM_INPUT rStreamInput[VERTEXSHADER_MAX_STREAMS];		// TODO: include stream count in VertexShader class
		for (UINT iStream = 0; iStream < VERTEXSHADER_MAX_STREAMS; iStream++)
		{
			// Override stream mapping using the new vertex shader
			DWORD iVB = pVS->rStreamInput[iStream].VertexBufferReference;
			if (iVB == 0)
				iVB = pVSRef->rStreamInput[iStream].VertexBufferReference;
			if (iVB != 0)
			{
				if (iVB - 1 >= this->Count()
					|| this->GetTypeByIndex(iVB - 1) != D3DCOMMON_TYPE_VERTEXBUFFER)
					return E_FAIL;
				rStreamInput[iStream].VertexBuffer = (D3DVertexBuffer *)this->GetResourceByIndex(iVB - 1);
				if (pVS->rStreamInput[iStream].Stride != 0)
				{
					// use the new stream
					rStreamInput[iStream].Stride = pVS->rStreamInput[iStream].Stride;
					rStreamInput[iStream].Offset = pVS->rStreamInput[iStream].Offset;
				}
				else
				{
					// use the reference stream
					rStreamInput[iStream].Stride = pVSRef->rStreamInput[iStream].Stride;
					rStreamInput[iStream].Offset = pVSRef->rStreamInput[iStream].Offset;
				}
				StreamCount = iStream + 1;	// use maximum stream touched as stream count
			}
			else
			{
				rStreamInput[iStream].VertexBuffer = NULL;
				rStreamInput[iStream].Stride = 0;
				rStreamInput[iStream].Offset = 0;
			}
		}
		if (StreamCount > 0)
		{
			hr = m_pd3dDevice->SetVertexShaderInput(pVSRef->Handle, StreamCount, rStreamInput);
			if (FAILED(hr))
				return hr;
		}
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetPixelShaderResource
// Desc: Create a pixel shader from a resource and set it to be current
//-----------------------------------------------------------------------------
HRESULT XBR::SetPixelShaderResource(DWORD PixelShaderResourceIndex)
{
	if (PixelShaderResourceIndex == 0)
		return S_FALSE;	// NULL
	D3DPIXELSHADERDEF *psd = (D3DPIXELSHADERDEF *)this->GetResourceByIndex(PixelShaderResourceIndex - 1);
	return m_pd3dDevice->SetPixelShaderProgram(psd);
}

//-----------------------------------------------------------------------------
// Name: SetIndexBufferResource
// Desc: Set the current index buffer from a resource index
//-----------------------------------------------------------------------------
HRESULT XBR::SetIndexBufferResource(DWORD IndexBufferResourceIndex)
{
	if (IndexBufferResourceIndex == 0)
		return S_FALSE;	// NULL
	if (IndexBufferResourceIndex - 1 >= this->Count()
		|| this->GetTypeByIndex(IndexBufferResourceIndex - 1) != XBRC_INDEXBUFFER)
		return E_FAIL;
	D3DIndexBuffer *pIB = (D3DIndexBuffer *)this->GetResourceByIndex(IndexBufferResourceIndex - 1);
	UINT BaseVertexIndex = 0;	// TODO: should we include this in the <Draw> tag
	return m_pd3dDevice->SetIndices(pIB, BaseVertexIndex);
}

//-----------------------------------------------------------------------------
// Name: SetTextureResource
// Desc: Set a texture resource to be current
//-----------------------------------------------------------------------------
HRESULT XBR::SetTextureResource(DWORD iTextureStage, DWORD TextureResourceIndex)
{
	if (TextureResourceIndex == 0)
		return S_FALSE;	// NULL
	if (TextureResourceIndex - 1 >= this->Count()
		|| this->GetTypeByIndex(TextureResourceIndex - 1) != D3DCOMMON_TYPE_TEXTURE)
		return E_FAIL;
	D3DBaseTexture *pBaseTexture = (D3DBaseTexture *)this->GetResourceByIndex(TextureResourceIndex - 1);
	return m_pd3dDevice->SetTexture( iTextureStage, pBaseTexture);
}


//-----------------------------------------------------------------------------
// Name: DrawEffect
// Desc: Execute the currently selected effect
//-----------------------------------------------------------------------------
HRESULT XBR::DrawEffect(Effect *pEffect)
{
	m_pd3dDevice->SetShaderConstantMode(D3DSCM_192CONSTANTS);
	
	// ignore RenderTargetResource for now
	for (UINT iPass = 0; iPass < pEffect->PassCount; iPass++)
	{
		Pass *pPass = &pEffect->rPass[iPass];
		if (pPass->VertexShaderResource != 0)
			SetVertexShaderResource(pPass->VertexShaderResource);
		if (pPass->PixelShaderResource != 0)
			SetPixelShaderResource(pPass->PixelShaderResource);
		for (UINT iRS = 0; iRS < pPass->RenderStateCount; iRS++)
		{
			RenderState *pRS = &pPass->rRenderState[iRS];
			m_pd3dDevice->SetRenderStateNotInline((D3DRENDERSTATETYPE)pRS->State, pRS->Value);
		}
		for (UINT iTS = 0; iTS < pPass->TextureStageCount; iTS++)
		{
			TextureStage *pTS = &pPass->rTextureStage[iTS];
			if (pTS->TextureResource != 0)
				SetTextureResource(iTS, pTS->TextureResource);
			for (UINT iTSS = 0; iTSS < pTS->TextureStateCount; iTSS++)
			{
				TextureState *pTSS = &pTS->rTextureState[iTSS];
				m_pd3dDevice->SetTextureStageStateNotInline(iTS, (D3DTEXTURESTAGESTATETYPE)pTSS->State, pTSS->Value);
			}
		}
		for (UINT iDraw = 0; iDraw < pPass->DrawCount; iDraw++)
		{
			Draw *pDraw = &pPass->rDraw[iDraw];
			if (pDraw->IndexBufferResource != 0)
			{
				SetIndexBufferResource(pDraw->IndexBufferResource);	// This sets D3D__IndexData
				// m_pd3dDevice->DrawIndexedPrimitive((D3DPRIMITIVETYPE)pDraw->Primitive, 0, 0, pDraw->Start, pDraw->Count);
				m_pd3dDevice->DrawIndexedVertices((D3DPRIMITIVETYPE)pDraw->Primitive, pDraw->Count, D3D__IndexData + pDraw->Start);
			}
			else
			{
				m_pd3dDevice->DrawVertices((D3DPRIMITIVETYPE)pDraw->Primitive, pDraw->Start, pDraw->Count);
			}
		}
	}

	m_pd3dDevice->SetShaderConstantMode(D3DSCM_96CONSTANTS);
	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SetTime
// Desc: Set the time for all of the animations in the resource set
//-----------------------------------------------------------------------------
HRESULT XBR::SetTime(float fGlobalTime)
{
	// TODO: this will not work if there are multiple animation
	// resources for the same skeleton, which is a very common
	// case. To fix this, add a selection which binds effect,
	// geometry, skeleton, and animation together for evaluation.
	
	// Walk the list of resources, looking for animations
	UINT iResource;
	for (iResource = 0; iResource < this->Count(); iResource++)
	{
		if (this->GetTypeByIndex(iResource) == XBRC_ANIMATION)
		{
			// Sample animation curves
			Animation *pAnimation = (Animation *)this->GetResourceByIndex(iResource);
			AnimLink *pAnimCurr = pAnimation->m_pAnimList;
			while (pAnimCurr != NULL)
			{
				pAnimCurr->m_pAnimFrame->SetTime(&pAnimCurr->m_pFrame->m_Matrix, fGlobalTime);
				pAnimCurr = pAnimCurr->m_pNext;
			}
		}
	}

	// Walk the list of resources, looking for skeletons
	for (iResource = 0; iResource < this->Count(); iResource++)
	{
		if (this->GetTypeByIndex(iResource) == XBRC_SKELETON)
		{
			// Update matrix hierarchy
			Skeleton *pSkeleton = (Skeleton *)this->GetResourceByIndex(iResource);
			pSkeleton->UpdateTransformations();
		}
	}

	// TODO: this will not work if there are multiple animation
	// resources for the same vertex shader, which is a very common case.

	// TODO: Move VSP's out of animation class and make a first-class object
	// that would be useful as a callback for generic parameter setting
	
	// Walk the list of resources, looking for animations
	for (UINT iResource = 0; iResource < this->Count(); iResource++)
	{
		if (this->GetTypeByIndex(iResource) == XBRC_ANIMATION)
		{
			// Set the vertex shader parameters that correspond to the VertexShaderResourceIndex
			Animation *pAnimation = (Animation *)this->GetResourceByIndex(iResource);
			for (UINT iVSP = 0; iVSP < pAnimation->m_VSPCount; iVSP++)
			{
				AnimVSP *pVSP = &pAnimation->m_rVSP[iVSP];
				VertexShader *pVertexShader = (VertexShader *)this->GetResourceByIndex(pVSP->m_VertexShaderReference - 1);
				
				// TODO: increase the kinds of supported animation
				XGMATRIX *pMatrix = (XGMATRIX *)pVSP->m_pSource;
				XGMATRIX mat;
				XGMatrixTranspose(&mat, pMatrix);

				// Set the constant in the declaration, so that when the vertex shader
				// is made active, we'll use the updated value.
				SetVertexShaderConstant(pVertexShader, pVSP->m_Index, (FLOAT *)mat, pVSP->m_Count);
			}
		}
	}
	
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: PrintVertexShaderDeclaration
// Desc: Print the vertex shader declaration to the debug display.
//-----------------------------------------------------------------------------
HRESULT XBR::PrintVertexShaderDeclaration(DWORD VertexShaderResourceIndex)
{
	VertexShader *pVertexShader = (VertexShader *)GetResourceByIndex(VertexShaderResourceIndex - 1);
	HRESULT hr = S_OK;
	DWORD *pToken = pVertexShader->Declaration;
	while (*pToken != D3DVSD_END() )
	{
		switch (*pToken & D3DVSD_TOKENTYPEMASK)
		{
			
        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM):
		{
			// Get stream index
            UINT iStream = *pToken & 0xf;
			Printf(L"D3DVSD_STREAM(%d),\n", iStream);
			break;
		}
		
        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA):
		{
            if (*pToken & 0x10000000) // skip
            {
                // D3DVSD_SKIP or D3DVSD_SKIPBYTES macro
				UINT count = (*pToken & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT;
                if (!(*pToken & 0x08000000))
  					Printf(L"\tD3DVSD_SKIP(%d),\t// skip %d bytes\n", count, count * 4);
  				else
					Printf(L"\tD3DVSD_SKIPBYTES(%d),\n", count);
			}
			else	// data
			{
                DWORD sizeAndType = (*pToken & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT;
                DWORD reg = (*pToken & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
				switch (sizeAndType)
				{
				case D3DVSDT_FLOAT1      :    // 1D float expanded to (value, 0., 0., 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_FLOAT1),\n", reg);
					break;
					
				case D3DVSDT_FLOAT2      :    // 2D float expanded to (value, value, 0., 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_FLOAT2),\n", reg);
					break;
					
				case D3DVSDT_FLOAT2H     :    // 2D homogeneous float expanded to (value, value,0., value.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_FLOAT2H),\n", reg);
					break;
					
				case D3DVSDT_FLOAT3      :    // 3D float expanded to (value, value, value, 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_FLOAT3),\n", reg);
					break;
					
				case D3DVSDT_FLOAT4      :    // 4D float
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_FLOAT4),\n", reg);
					break;
					
				case D3DVSDT_D3DCOLOR    :    // 4D packed unsigned bytes mapped to 0. to 1. range
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_D3DCOLOR),\n", reg);
					break;
					
				// Signed shorts map to the range [-32768, 32767]
				case D3DVSDT_SHORT1      :    // 1D signed short expanded to (value, 0., 0., 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_SHORT1),\n", reg);
					break;

				case D3DVSDT_SHORT2      :    // 2D signed short expanded to (value, value, 0., 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_SHORT2),\n", reg);
					break;

				case D3DVSDT_SHORT3      :    // 3D signed short expanded to (value, value, value, 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_SHORT3),\n", reg);
					break;

				case D3DVSDT_SHORT4      :    // 4D signed short
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_SHORT4),\n", reg);
					break;

				// (signed, normalized short maps from -1.0 to 1.0)
				case D3DVSDT_NORMSHORT1  :    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_NORMSHORT1),\n", reg);
					break;
				
				case D3DVSDT_NORMSHORT2  :    // 2D signed, normalized short expanded to (value, value, 0., 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_NORMSHORT2),\n", reg);
					break;

				case D3DVSDT_NORMSHORT3  :    // 3D signed, normalized short expanded to (value, value, value, 1.)  
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_NORMSHORT3),\n", reg);
					break;

				case D3DVSDT_NORMSHORT4  :    // 4D signed, normalized short expanded to (value, value, value, value)  
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_NORMSHORT4),\n", reg);
					break;

				case D3DVSDT_NORMPACKED3 :    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_NORMPACKED3),\n", reg);
					break;
				
				// Packed bytes map to the range [0, 1]
				case D3DVSDT_PBYTE1      :    // 1D packed byte expanded to (value, 0., 0., 1.) 
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_PBYTE1),\n", reg);
					break;
				
				case D3DVSDT_PBYTE2      :    // 2D packed byte expanded to (value, value, 0., 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_PBYTE2),\n", reg);
					break;

				case D3DVSDT_PBYTE3      :    // 3D packed byte expanded to (value, value, value, 1.)
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_PBYTE3),\n", reg);
					break;

				case D3DVSDT_PBYTE4      :    // 4D packed byte expanded to (value, value, value, value) 
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_PBYTE4),\n", reg);
					break;

				case D3DVSDT_NONE        :    // No stream data
					Printf(L"\tD3DVSD_REG(%d, D3DVSDT_NONE),\n", reg);
					break;

				default:
					Printf(L"Bad vertex stream data type encoding (no D3DVSDT_* corresponds to 0x%x).", sizeAndType);
					hr = E_FAIL;
					goto e_Exit;
				}
			}
			break;
		}
			
        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM):
		{
			int addr = ((*pToken & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT) - 96;
            UINT count = (*pToken & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT;
			// Printf(L"\tD3DVSD_CONST(%d, %d),\n", addr, count);
			for (UINT i = 0; i < count; i++)
			{
				FLOAT *pValue = (float *)&pToken[1];
				Printf(L"\tc%d %g %g %g %g\n",
					   addr + i, pValue[0], pValue[1], pValue[2], pValue[3]);
				pToken += 4;
			}
			break;
		}
			
        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_NOP):
			Out(L"\tD3DVSD_NOP(),\n");
            break;
			
        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR):
			Out(L"Tessellator stream parsing not implemented.\n");
			hr = E_NOTIMPL;
			goto e_Exit;
			
		// case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_END):
			// we should not hit this, since this is the main loop test
			
		default:
			Printf(L"unknown token (0x%x) in the vertex shader declaration.\n", *pToken );
			hr = E_NOTIMPL;
			goto e_Exit;
		}
		pToken++; // Go to the next token in the stream
	}
	Out(L"\tD3DVSD_END()\n");
 e_Exit:
	return hr;
}

//-----------------------------------------------------------------------------
// Name: PrintVertexShaderInputs
// Desc: Print the vertex shader inputs to the debug display.
//-----------------------------------------------------------------------------
HRESULT XBR::PrintVertexShaderInputs(DWORD VertexShaderResourceIndex)
{
	VertexShader *pVS = (VertexShader *)GetResourceByIndex(VertexShaderResourceIndex - 1);
	VertexShader *pVSRef = NULL;
	if (pVS->VertexShaderReference != 0)
	{
		// Lookup vertex shader reference
		if (pVS->VertexShaderReference - 1 >= this->Count()
			|| this->GetTypeByIndex(pVS->VertexShaderReference - 1) != XBRC_VERTEXSHADER)
			return E_FAIL;
		pVSRef = (VertexShader *)this->GetResourceByIndex(pVS->VertexShaderReference - 1);
	}
	// Dump vertex buffer mapping to stream
	for (UINT iStream = 0; iStream < VERTEXSHADER_MAX_STREAMS; iStream++)
	{
		DWORD iVB = pVS->rStreamInput[iStream].VertexBufferReference;
		if (iVB == 0 && pVSRef != NULL)
			iVB = pVSRef->rStreamInput[iStream].VertexBufferReference;
		if (iVB != 0)
		{
			bool bGoodVB = (iVB <= this->Count()) && this->GetTypeByIndex(iVB - 1) == D3DCOMMON_TYPE_VERTEXBUFFER;
			DWORD Stride = 0;
			DWORD Offset = 0;
			if (pVS->rStreamInput[iStream].Stride != 0)
			{
				// use the stride and offset 
				Stride = pVS->rStreamInput[iStream].Stride;
				Offset = pVS->rStreamInput[iStream].Offset;
			}
			else if (pVSRef != NULL)
			{
				// use the reference stride and offset
				Stride = pVSRef->rStreamInput[iStream].Stride;
				Offset = pVSRef->rStreamInput[iStream].Offset;
			}
			Printf(L"Stream%d : VertexBuffer=%d%s Stride=%d Offset=%d\n",
				iStream, iVB, bGoodVB ? L"" : L"<invalid resource>", Stride, Offset);
		}
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: GetSymbolName
// Desc: Return name of symbol at given index, or NULL if no symbol table
//-----------------------------------------------------------------------------
CONST CHAR *XBR::GetSymbolName(DWORD SymbolIndex)
{
	if (SymbolIndex >= m_dwSymbolCount)
		return NULL;
	else
		return m_pResourceTags[SymbolIndex].strName;
}


//-----------------------------------------------------------------------------
// Name: GetResourceIndexBySymbolIndex
// Desc: Return index of resource with given symbol index
//-----------------------------------------------------------------------------
DWORD XBR::GetResourceIndexBySymbolIndex(DWORD SymbolIndex)
{
	// TODO: reconsider symbol table sorting
	// Look through index table for matching offset
	for (DWORD ResourceIndex = 0; ResourceIndex < m_dwNumResources; ResourceIndex++)
	{
		DWORD dwType = m_dwTypes[ ResourceIndex ];
		DWORD dwOffset = m_ppResources[ ResourceIndex ] - m_pSysMemData;
		if (dwType & XBRC_USER_DATA_FLAG)
			dwOffset -= 8;	// move offset back to original type + size fields
		if (dwOffset == m_pResourceTags[SymbolIndex].dwOffset)
			return ResourceIndex;
	}
	return (DWORD)-1;
}

//-----------------------------------------------------------------------------
// Name: GetSymbolIndex
// Desc: Return symbol index with given symbol name. 
//-----------------------------------------------------------------------------
DWORD XBR::GetSymbolIndex(CONST CHAR *strSymbol)
{ 
	// Look through symbol table for matching symbol
	for (DWORD SymbolIndex = 0; SymbolIndex < m_dwSymbolCount; SymbolIndex++)
	{
		if (!strcmp(strSymbol, m_pResourceTags[SymbolIndex].strName))
			return SymbolIndex;
	}
	return (DWORD)-1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\tools\xbview\xbview.cpp ===
//-----------------------------------------------------------------------------
// File: xbview.cpp
//
// Desc: Demonstrates how to load resources from an XBR (Xbox Resource) file.
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include "XBR.h"
#include "texture.h"
#include "print.h"
#include "DebugCmd.h"
#include "util.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
	{ XBHELP_LEFTSTICK,	   XBHELP_PLACEMENT_2, L"Texture size" },
	{ XBHELP_A_BUTTON,	   XBHELP_PLACEMENT_1, L"Next" },
	{ XBHELP_B_BUTTON,	   XBHELP_PLACEMENT_1, L"Previous" },
	{ XBHELP_X_BUTTON,	   XBHELP_PLACEMENT_1, L"Toggle Alpha" },
	{ XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, L"Reload" },
	{ XBHELP_DPAD,		   XBHELP_PLACEMENT_1, L"Level" },
	{ XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Help" },
	{ XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
	{ XBHELP_LEFT_BUTTON,  XBHELP_PLACEMENT_1, L"Rewind" },
	{ XBHELP_RIGHT_BUTTON, XBHELP_PLACEMENT_1, L"Fast-Forward" },
};
#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(XBHELP_CALLOUT))

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//		 from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
	// Member variables
	CXBHelp					m_Help;					// Help data
	BOOL					m_bDrawHelp;			// Should we draw help info?
	CXBFont					m_Font;					// Font for rendering text

	XBR						m_XBR;					// Resource handler
	CHAR				   *m_strBundle;			// Name of the xpr bundle to load
	DWORD					m_nCurrent;				// Currently displayed resource
	DWORD					m_dwStateBlock;			// State block used to insulate effect drawing

	LPDIRECT3DVERTEXBUFFER8 m_pQuadVB;				// Quad for displaying textures
	FLOAT					m_fWidth;
	FLOAT					m_fHeight;
	
	DWORD					m_nLevel;				// which texture mipmap or skeleton level to display
	BOOL					m_bAlpha;				// draw just the alpha channel

	FLOAT					m_fTimeLocal;			// m_fAppTime * m_fTimeScale + m_fTimeOrigin
	FLOAT					m_fTimeOrigin;			// origin of time for animation shifting
	FLOAT					m_fTimeScale;			// scale of time

	D3DXMATRIX				m_matProjection;		// current projection matrix
	D3DXMATRIX				m_matView;				// current view  matrix
	D3DXMATRIX				m_matWorld;				// current world matrix

	FLOAT					m_fScrollX, m_fScrollY;		// position of debugging output string

	// Creates and sets up our vertex buffer
	HRESULT InitGeometry( FLOAT fWidth, FLOAT fHeight, FLOAT fMaxU, FLOAT fMaxV );

	// Texture quad drawing
	HRESULT DrawTexture();	// draw current texture

	// Effect drawing
	HRESULT DrawEffect(Effect *pEffect);
	
	// Skeleton drawing
	HRESULT DrawSkeleton(Skeleton *pSkeleton);

	// Time setting
	HRESULT SetLocalTime(FLOAT fTimeLocal)
	{
		m_fTimeLocal = fTimeLocal;
		m_fTimeOrigin = m_fTimeLocal - m_fAppTime * m_fTimeScale;	// adjust origin to match desired time
		return m_XBR.SetTime(m_fTimeLocal);
	}

	// Resource index setting
	HRESULT SetResource(DWORD ResourceIndex)
	{
		if (ResourceIndex >= m_XBR.Count())
			return E_INVALIDARG;
		m_nCurrent	= ResourceIndex;
		m_fWidth	= 1.0f;
		m_fHeight	= 1.0f;
		m_nLevel = (DWORD)-1;
		g_strOut[0] = 0;	// clear debug string
		m_fScrollX = m_fScrollY = 0.f;

		// Tell the custom debugger about the new resource
		DCPrintf("SetResource(%d)\n", ResourceIndex);
		return S_OK;
	}
	
public:
	CXBoxSample();
	HRESULT Initialize();
	HRESULT FrameMove();
	HRESULT Render();

	// Debug channel variable and command handlers
	static const DCVARDEF s_rgDCVars[];
	static const UINT s_nDCVars;
	static const DCCMDDEF s_rgDCCmds[];
	static const UINT s_nDCCmds;
	static void DC_set_time(LPVOID pvAddr);
	static void DC_resource(int argc, char *argv[]);
	static void DC_frame(int argc, char *argv[]);

} g_xbApp;



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
void __cdecl main()
{
	if( FAILED( g_xbApp.Create() ) )
		return;

	g_xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Initialize member varaibles
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
			:CXBApplication()
{
#ifdef _DEBUG
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;	// Allow unlimited frame rate
#endif
	m_bDrawHelp		= FALSE;
	m_pQuadVB		= NULL;
	m_fWidth		= 1.0f;
	m_fHeight		= 1.0f;
	m_nCurrent		= 0;
	m_dwStateBlock  = 0;
	m_nLevel	    = (DWORD)-1;
	m_bAlpha	    = false;
	m_strBundle = "D:\\Media\\xbrc_out.xbr";
	m_fScrollX = m_fScrollY = 0.f;
	m_fTimeOrigin = 0.f;
	m_fTimeScale = 1.f;
	m_bPaused = true;
}



//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitGeometry( FLOAT fWidth, FLOAT fHeight, FLOAT fMaxU, FLOAT fMaxV )
{
	// Create and lock our vertex buffer
	if( NULL == m_pQuadVB )
	{
		if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ), D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_MANAGED, &m_pQuadVB ) ) )
			return E_FAIL;
	}
	
	// Set up a quad in the vertex buffer
	CUSTOMVERTEX* pVertices;
	if( FAILED( m_pQuadVB->Lock( 0, 0, (BYTE **)&pVertices, 0L ) ) )
		return E_FAIL;

	pVertices[0].p	= D3DXVECTOR3( -fWidth/2, -fHeight/2, 1.0f );
	pVertices[0].n	= D3DXVECTOR3(	0.0f, 0.0f, -1.0f );
	pVertices[0].diffuse = 0xFFFFFFFF;
	pVertices[0].tu = 0.0f; 
	pVertices[0].tv = fMaxV;

	pVertices[1].p	= D3DXVECTOR3( -fWidth/2, fHeight/2, 1.0f );
	pVertices[1].n	= D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
	pVertices[1].diffuse = 0xFFFFFFFF;
	pVertices[1].tu = 0.0f; 
	pVertices[1].tv = 0.0f;

	pVertices[2].p	= D3DXVECTOR3( fWidth/2, -fHeight/2, 1.0f );
	pVertices[2].n	= D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
	pVertices[2].diffuse = 0xFFFFFFFF;
	pVertices[2].tu = fMaxU; 
	pVertices[2].tv = fMaxV;

	pVertices[3].p	= D3DXVECTOR3( fWidth/2, fHeight/2, 1.0f );
	pVertices[3].n	= D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
	pVertices[3].diffuse = 0xFFFFFFFF;
	pVertices[3].tu = fMaxU; 
	pVertices[3].tv = 0.0f;

	m_pQuadVB->Unlock();

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Performs whatever set-up is needed, for example, loading textures,
//		 creating vertex buffers, etc.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	// Create the font
	if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create the help
	if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Set up our vertex buffer
	if( FAILED( InitGeometry( m_fWidth, m_fHeight, 1.0f, 1.0f ) ) )
		return E_FAIL;

	// Set up our projection, view, and world matrices
	// For now, hard-code tiny's projection matrix
	D3DXMATRIX matProj( 1.86326f, 0.f, 0.f, 0.f,
						0.f, 2.41421f, 0.f, 0.f,
						0.f, 0.f, -1.00008f, -1.f, 
						0.f, 0.f, -5.91465f, 0.f );
	m_matProjection = matProj;
	D3DXMatrixIdentity( &m_matView );
	D3DXMatrixIdentity( &m_matWorld );
	m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );
	m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
	m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

	// Set up a light
	D3DLIGHT8 m_Light;
	ZeroMemory( &m_Light, sizeof( D3DLIGHT8 ) );
	m_Light.Type = D3DLIGHT_DIRECTIONAL;
	m_Light.Diffuse.r = 1.0f;
	m_Light.Diffuse.g = 1.0f;
	m_Light.Diffuse.b = 1.0f;
	m_Light.Diffuse.a = 1.0f;
	m_Light.Direction = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
	m_pd3dDevice->SetLight( 0, &m_Light );
	m_pd3dDevice->LightEnable( 0, TRUE );

	// Start loading our resources from the file
	m_XBR.StartLoading( m_pd3dDevice, m_strBundle );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Handles controller input each frame
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	bool bSetTime = !m_bPaused;

	// Toggle help
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
		m_bDrawHelp = !m_bDrawHelp;

	// reload the resources
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
	{
		if( FAILED( m_XBR.StartLoading( m_pd3dDevice, m_strBundle ) ) )
			return E_FAIL;
		SetResource(0);
		m_fTimeOrigin = -m_fAppTime * m_fTimeScale; // sets animation time to 0
	}

	if( m_XBR.PollLoadingState() != LOADING_DONE )
		return S_FALSE; // if loading or failed, do not do the rest of the updates

	// Rewind with left trigger and fast-forward with right trigger
	static float fRewindScale = 0.0001f;
	static float fFastForwardScale = 0.0001f;
	float fLeftTrigger = (float)m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER];
	fLeftTrigger *= fLeftTrigger;	// left trigger squared
	float fRightTrigger = (float)m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER];
	fRightTrigger *= fRightTrigger; // right trigger squared
	float fRewind = fRewindScale * fLeftTrigger;
	float fFastForward = fFastForwardScale * fRightTrigger;
	float fDelta = (fFastForward - fRewind);
	if (fDelta != 0.f)
	{
		m_fTimeOrigin += m_fElapsedTime * fDelta;
		bSetTime = true;	// update animations
	}

	// Cube thumbsticks for finer control
	static float fDeadZone = 0.005f;
	float fX1 = m_DefaultGamepad.fX1;
	fX1 = fX1 * fX1 * fX1;
	if (fabsf(fX1) < fDeadZone) fX1 = 0.f;
	float fY1 = m_DefaultGamepad.fY1;
	fY1 = fY1 * fY1 * fY1;
	if (fabsf(fY1) < fDeadZone) fY1 = 0.f;
	float fX2 = m_DefaultGamepad.fX2;
	fX2 = fX2 * fX2 * fX2;
	if (fabsf(fX2) < fDeadZone) fX2 = 0.f;
	float fY2 = m_DefaultGamepad.fY2;
	fY2 = fY2 * fY2 * fY2;
	if (fabsf(fY2) < fDeadZone) fY2 = 0.f;

	// Left thumbstick resizes texture quad
	m_fWidth  = max( 0.01f, min( 2.0f, m_fWidth	 *= (0.01f*fX1+1) ) );
	m_fHeight = max( 0.01f, min( 2.0f, m_fHeight *= (0.01f*fY1+1) ) );

	// Right thumbstick scrolls debug display
	static float fScrollXScale =  200.f;
	static float fScrollYScale = -400.f;
	m_fScrollX += fScrollXScale * fX2 * m_fElapsedTime;
	m_fScrollY += fScrollYScale * fY2 * m_fElapsedTime;

	// move forward through resources
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
	{
		SetResource(( m_nCurrent + 1 ) % m_XBR.Count());
	}


	// move backward through resources
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
	{
		SetResource( ( m_nCurrent + m_XBR.Count() - 1 ) % m_XBR.Count());
	}
	
	// toggle alpha
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
		m_bAlpha = !m_bAlpha;

	// move between mipmap levels or skeleton hierarchy
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN)
		m_nLevel++;
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP)
	{
		if( m_nLevel != -1 )
			m_nLevel--;
	}

	// set the current animation time
	if (bSetTime)
	{
		m_fTimeLocal = m_fAppTime * m_fTimeScale + m_fTimeOrigin;
		m_XBR.SetTime(m_fTimeLocal);
	}
	
    // Process any pending commands from the debug channel
    DCHandleCmds();
	
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawTexture
// Desc: draw current texture resource
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawTexture()
{
	if (m_XBR.GetTypeByIndex(m_nCurrent) != D3DCOMMON_TYPE_TEXTURE)
		return E_INVALIDARG;

	// Set up our view, projection, and world matrices
	D3DXMATRIX matProj;
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 1.0f, 1.0f, 10.0f );
	m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
	D3DXMATRIX matView;
	D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 1.0f );
	m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
	D3DXMATRIX matWorld;
	D3DXMatrixIdentity( &matWorld );
	m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

	// Get texture format
	DWORD *pRes	 = (DWORD *)m_XBR.GetResourceByIndex(m_nCurrent);
	DWORD dwFmt = (*(pRes+3) & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT;
	for(UINT x=0; g_TextureFormats[x].id != 0; x++)
		if(g_TextureFormats[x].id == dwFmt)
			break;
	if( g_TextureFormats[x].id != 0 )
	{
		// Set up quad to render
		if(g_TextureFormats[x].type == FMT_LINEAR)
		{
			DWORD dwU = (*(pRes+4) & D3DSIZE_WIDTH_MASK)+1;
			DWORD dwV = ((*(pRes+4) & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
			InitGeometry( m_fWidth, m_fHeight, (FLOAT)dwU, (FLOAT)dwV );
		}
		else
		{
			InitGeometry( m_fWidth, m_fHeight, 1.0f, 1.0f );
		}
	}

	// Set up our render and texture stage states
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,	TRUE );
	m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
	
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	if (m_bAlpha)
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE );
	else
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,	 D3DTADDRESS_CLAMP );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,	 D3DTADDRESS_CLAMP );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSW,	 D3DTADDRESS_CLAMP );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	if( m_nLevel == -1 )
	{
		// blend between miplevels for ordinary texture mapping
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAXMIPLEVEL, 0);	// use the most-detailed level as appropriate
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPMAPLODBIAS, 0);		
	}
	else
	{
		// draw just the desired miplevel
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAXMIPLEVEL, m_nLevel);	 // use just the desired miplevel
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPMAPLODBIAS, FtoDW(-100.f));	// bias choice to desired miplevel
	}
 
	// Select our texture and quad
	m_pd3dDevice->SetTexture( 0, (D3DBaseTexture *)m_XBR.GetResourceByIndex(m_nCurrent) );
	m_pd3dDevice->SetStreamSource( 0, m_pQuadVB, sizeof( CUSTOMVERTEX ) );

	// Draw the quad
	m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

	// Unselect the texture
	m_pd3dDevice->SetTexture( 0, NULL );
	
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawEffect
// Desc: save state, draw effect, restore state
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawEffect(Effect *pEffect)
{
	// Take state snapshot
	HRESULT hr = S_OK;
	if (m_dwStateBlock == 0)
	{
		hr = g_pd3dDevice->CreateStateBlock(D3DSBT_ALL, &m_dwStateBlock);
		if (FAILED(hr))
			return hr;
	}

	// Draw the effect
	hr = m_XBR.DrawEffect(pEffect);
					
	// Restore state
	g_pd3dDevice->SetVertexShaderInput(0, 0, 0);	// this is not handled by the state block
	g_pd3dDevice->ApplyStateBlock(m_dwStateBlock);
	return hr;
}

//-----------------------------------------------------------------------------
// Name: DrawSkeleton
// Desc: Draw the hierarchy of coordinate frames
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawSkeleton(Skeleton *pSkeleton)
{
	BeginAxes();
	
	// Iterate through frame hierarchy
	struct FrameStackElement {
		Frame *pFrame;
		UINT Indent;
	} rFrameStack[FRAME_MAX_STACK];
	rFrameStack[0].pFrame = pSkeleton->m_pRoot;
	rFrameStack[0].Indent = 0;
	UINT iMatrix = 0;	// index to current entry in m_rMatrix
	UINT iFrameStack = 1;	// depth of stack
	while (iFrameStack)
	{
		// Pop the stack
		iFrameStack--;
		Frame *pFrame = rFrameStack[iFrameStack].pFrame;
		UINT Indent = rFrameStack[iFrameStack].Indent;

		// Draw the current frame
		m_pd3dDevice->SetTransform(D3DTS_WORLD, &pSkeleton->m_rMatrix[iMatrix]);
		DrawAxes();

		// Print current frame
		if (iMatrix == m_nLevel)
		{
			PrintFrame(pFrame);
			Out(L"	cumulative\n");
			PrintMatrix(&pSkeleton->m_rMatrix[iMatrix]);
			Out(L"\n");
		}

		// Push sibling
		if (pFrame->m_pNext != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrame->m_pNext;
			rFrameStack[iFrameStack].Indent = Indent;
			iFrameStack++;
		}
		
		// Push child
		if (pFrame->m_pChild != NULL)
		{
			if (iFrameStack >= FRAME_MAX_STACK)
				return E_FAIL; // we hit our hard-coded stack-depth limit
			rFrameStack[iFrameStack].pFrame = pFrame->m_pChild;
			rFrameStack[iFrameStack].Indent = Indent + 1;
			iFrameStack++;
		}
		
		iMatrix++;
	}

	EndAxes();
	return S_OK;
}
	
//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Performs the graphics operations to render the texture on screen
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	const int DescriptionLength = 1000;
	WCHAR strDescription[DescriptionLength];

	// Begin the scene
	m_pd3dDevice->BeginScene();

	m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
						 0x00000000, 1.0f, 0L );

	RenderGradientBackground( 0x0000ffff, 0x00ffffff );

	wcscpy(strDescription, L"");
	LOADINGSTATE LoadingState = m_XBR.CurrentLoadingState();
	if( LoadingState != LOADING_DONE )
	{
		// If we're not done reading from disk, display a message
		if (LoadingState == LOADING_NOTSTARTED)
			wcscpy( strDescription, L"Loading not yet started." );
		else if (LoadingState == LOADING_HEADER)
			wcscpy( strDescription, L"Loading resource header.." );
		else if (LoadingState == LOADING_DATA)
			wcscpy( strDescription, L"Loading resource data..." );
		else if (LoadingState == LOADING_FAILED)
		{
			WCHAR strBundle[_MAX_PATH];
			mbstowcs( strBundle, m_strBundle, _MAX_PATH );
			strBundle[_MAX_PATH - 1] = 0;	// make sure string is null-terminated
			_snwprintf( strDescription, DescriptionLength, L"Resources failed to load from\n\"%s\"", strBundle);
		}
		strDescription[DescriptionLength-1] = 0;	// make sure string is null terminated
	}
	else if (LoadingState == LOADING_DONE)
	{
		// Get info about resource and prepare description string
		DWORD dwType = m_XBR.GetTypeByIndex(m_nCurrent);
		if (dwType == D3DCOMMON_TYPE_TEXTURE)
		{
			DWORD dwFmt, *pRes, dwDim, dwU, dwV, dwP, dwLevels, dwCube;
			WCHAR *pTexType, strRes[256], strLevels[256];
			pRes  = (DWORD *)m_XBR.GetResourceByIndex(m_nCurrent);
			dwFmt = (*(pRes+3) & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT;
			for(UINT x=0; g_TextureFormats[x].id != 0; x++)
			{
				if(g_TextureFormats[x].id == dwFmt)
					break;
			}
			if(g_TextureFormats[x].id != 0)
			{
				// get information about the texture
				dwDim	 = (*(pRes+3) & D3DFORMAT_DIMENSION_MASK) >> D3DFORMAT_DIMENSION_SHIFT;
				dwLevels = (*(pRes+3) & D3DFORMAT_MIPMAP_MASK) >> D3DFORMAT_MIPMAP_SHIFT;
				dwCube	 = (*(pRes+3) & D3DFORMAT_CUBEMAP);
				if(g_TextureFormats[x].type == FMT_LINEAR)
				{
					dwU = (*(pRes+4) & D3DSIZE_WIDTH_MASK)+1;
					dwV = ((*(pRes+4) & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
					dwP = 0;
				}
				else
				{
					dwU = exptbl[(*(pRes+3) & D3DFORMAT_USIZE_MASK) >> D3DFORMAT_USIZE_SHIFT];
					dwV = exptbl[(*(pRes+3) & D3DFORMAT_VSIZE_MASK) >> D3DFORMAT_VSIZE_SHIFT];
					dwP = exptbl[(*(pRes+3) & D3DFORMAT_PSIZE_MASK) >> D3DFORMAT_PSIZE_SHIFT];
				}
				
				if(dwDim == 2)
				{
					swprintf( strRes, L"%dx%d", dwU, dwV );
					pTexType = L"2D Texture";
				}
				else if(dwCube)
				{
					swprintf( strRes, L"%dx%d", dwU, dwV );
					pTexType = L"Cubemap";
				}
				else
				{
					pTexType = L"3D Texture";
					swprintf( strRes, L"%dx%dx%d", dwU, dwV, dwP );
				}
				
				if( dwLevels == 1 )
					swprintf( strLevels, L"1 level");
				else
				{
					if( m_nLevel == -1 )
						swprintf( strLevels, L"%d levels", dwLevels );
					else
					{
						if( m_nLevel >= dwLevels )
							m_nLevel = dwLevels - 1; // constrain choice of miplevel to appropriate range
						swprintf( strLevels, L"level %d of %d levels", m_nLevel, dwLevels );
					}
				}

				swprintf( strDescription, L"Resource %d of %d	 %s\n%s %s %s\n%s", 
						  m_nCurrent + 1, m_XBR.Count(), pTexType, strRes, 
						  g_TextureFormats[x].name, strLevels,
						  m_bAlpha ? L"alpha channel only" : L"");
			}
			else
			{
				swprintf( strDescription, L"Resource %d of %d	  Texture\n", 
						  m_nCurrent + 1, m_XBR.Count() );
			}
			DrawTexture();	// draw textured quad
		}
		else if (dwType == D3DCOMMON_TYPE_VERTEXBUFFER)
		{
			swprintf( strDescription, L"Resource %d of %d	  VertexBuffer\n", 
					  m_nCurrent + 1, m_XBR.Count());
		}
		else if ((dwType & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_INDEXBUFFER)
		{
			swprintf( strDescription, L"Resource %d of %d	  IndexBuffer\n", 
					  m_nCurrent + 1, m_XBR.Count());
		}
		else if (dwType == XBRC_VERTEXSHADER)
		{
			VertexShader *pVertexShader = (VertexShader *)m_XBR.GetResourceByIndex(m_nCurrent);
			swprintf( strDescription, L"Resource %d of %d	  VertexShader\nHandle=0x%08x\nVertexShaderReference=%d",
					  m_nCurrent + 1, m_XBR.Count(),
					  pVertexShader->Handle,
					  pVertexShader->VertexShaderReference );
			if (m_nLevel == -1)
			{
				g_strOut[0] = 0;	// clear debug string
				m_XBR.PrintVertexShaderInputs(m_nCurrent + 1);
				m_XBR.PrintVertexShaderDeclaration(m_nCurrent + 1);
				//m_nLevel = 0;
			}
		}
		else if (dwType == XBRC_PIXELSHADER)
		{
			swprintf( strDescription, L"Resource %d of %d	  PixelShader\n", 
					  m_nCurrent + 1, m_XBR.Count());
		}
		else if (dwType == XBRC_EFFECT)
		{
			Effect *pEffect = (Effect *)m_XBR.GetResourceByIndex(m_nCurrent);
			WCHAR strIdentifier[EFFECT_IDENTIFIER_SIZE];
			mbstowcs( strIdentifier, pEffect->Identifier, EFFECT_IDENTIFIER_SIZE );
			strIdentifier[EFFECT_IDENTIFIER_SIZE - 1] = 0;	// make sure string is null-terminated
			_snwprintf( strDescription, DescriptionLength, L"Resource %d of %d	   Effect\nID=\"%s\"\nRenderTarget=%d PassCount=%d",
						m_nCurrent + 1, m_XBR.Count(),
						strIdentifier, pEffect->RenderTargetResource, pEffect->PassCount );
			strDescription[DescriptionLength - 1] = 0;	// make sure string is terminated
			DrawEffect(pEffect);
		}
		else if (dwType == XBRC_SKELETON)
		{
			Skeleton *pSkeleton = (Skeleton *)m_XBR.GetResourceByIndex(m_nCurrent);
			WCHAR strIdentifier[FRAME_IDENTIFIER_SIZE];
			if (pSkeleton->m_FrameCount > 0)
			{
				int len = strlen(pSkeleton->m_pRoot->m_strName);
				mbstowcs( strIdentifier, pSkeleton->m_pRoot->m_strName, len );
			}
			strIdentifier[FRAME_IDENTIFIER_SIZE - 1] = 0;	// make sure string is null-terminated
			_snwprintf( strDescription, DescriptionLength, L"Resource %d of %d	   Skeleton\nID=\"%s\" FrameCount=%d",
						m_nCurrent + 1, m_XBR.Count(),
						strIdentifier, pSkeleton->m_FrameCount);
			strDescription[DescriptionLength - 1] = 0;	// make sure string is terminated

			// Set projection, view, and world matrices
			m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection);
			m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
			m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
					
			g_strOut[0] = 0;	// clear debug string
			DrawSkeleton((Skeleton *)m_XBR.GetResourceByIndex(m_nCurrent));
		}
		else if (dwType == XBRC_ANIMATION)
		{
			Animation *pAnimation = (Animation *)m_XBR.GetResourceByIndex(m_nCurrent);
			_snwprintf( strDescription, DescriptionLength, L"Resource %d of %d	   Animation\nTargetCount=%d AnimationCount=%d",
						m_nCurrent + 1, m_XBR.Count(),
						pAnimation->m_VSPCount, pAnimation->m_AnimCount);
			strDescription[DescriptionLength - 1] = 0;	// make sure string is terminated
		}
		else if (dwType & 0x80000000)
			swprintf( strDescription, L"Resource %d of %d	  UserData\ntype=0x%08x\n", 
					  m_nCurrent + 1, m_XBR.Count(), dwType);
		else
			swprintf( strDescription, L"Resource %d of %d	  Unknown\ntype=0x%08x\n", 
					  m_nCurrent + 1, m_XBR.Count(), dwType);
	}

	// Show title, frame rate, resource description, and help
	if( m_bDrawHelp )
		m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
	else
	{
		m_Font.Begin();
		m_Font.DrawText(  64,  50, 0xffffffff, L"xbview" );
		m_Font.DrawText( 450,  50, 0xffffff00, m_strFrameRate );
		WCHAR strAppTime[100];
		swprintf( strAppTime, L"%0.02f s", m_fAppTime * m_fTimeScale + m_fTimeOrigin );
		m_Font.DrawText( 450,  80, 0xffffff00, strAppTime );
		if (m_bPaused)
			m_Font.DrawText( 450,  110, 0xff888800, L"Paused");
		m_Font.DrawText(  64,  80, 0xff0000ff, strDescription );
		m_Font.DrawText(  64 + m_fScrollX, 150 + m_fScrollY, 0xff888888, g_strOut);
		m_Font.End();
	}

	m_pd3dDevice->EndScene();

	// Present the scene
	m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: TypeName
// Desc: Return a string for the given type
//-----------------------------------------------------------------------------
CHAR *TypeName(DWORD dwType)
{
	if (dwType == D3DCOMMON_TYPE_TEXTURE)
		return "Texture";
	else if (dwType == D3DCOMMON_TYPE_VERTEXBUFFER)
		return "VertexBuffer";
	else if ((dwType & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_INDEXBUFFER)
		return "IndexBuffer";
	else if (dwType == XBRC_VERTEXSHADER)
		return "VertexShader";
	else if (dwType == XBRC_PIXELSHADER)
		return "PixelShader";
	else if (dwType == XBRC_EFFECT)
		return "Effect";
	else if (dwType == XBRC_SKELETON)
		return "Skeleton";
	else if (dwType == XBRC_ANIMATION)
		return "Animation";
	else if (dwType & 0x80000000)
		return "UserData";
	else
		return "<Unknown>";
}

//-----------------------------------------------------------------------------
// Debug command handlers
//-----------------------------------------------------------------------------
bool g_bQuiet = false;

void CXBoxSample::DC_set_time(LPVOID pvAddr)
{
	FLOAT *pfTime = (FLOAT *)pvAddr;
	g_xbApp.SetLocalTime(*pfTime);
}

void CXBoxSample::DC_resource(int argc, char *argv[])
{
	XBR *pXBR = &g_xbApp.m_XBR;
	
	// Use argv[0] to limit the types of resources to look for.
	static struct MAPTYPE {
		CHAR *str;
		DWORD dwType;
		DWORD dwMask;
	} s_rMapType[] = {
	  {"effect",    XBRC_EFFECT,		~0ul },
	  {"skeleton",  XBRC_SKELETON,		~0ul },
	  {"anim",   	XBRC_ANIMATION,		~0ul },
	  {"vsh",    	XBRC_VERTEXSHADER,	~0ul },
	  {"psh",    	XBRC_PIXELSHADER,	~0ul },
	  {"ib",     	XBRC_INDEXBUFFER,	~0ul },
	  {"texture",   D3DCOMMON_TYPE_TEXTURE,			XBRC_USER_DATA_FLAG | D3DCOMMON_TYPE_MASK},
	  {"vb",     	D3DCOMMON_TYPE_VERTEXBUFFER,	XBRC_USER_DATA_FLAG | D3DCOMMON_TYPE_MASK},
	};
	static UINT s_MapTypeCount = sizeof(s_rMapType) / sizeof(MAPTYPE);
	DWORD dwTypeDesired = (DWORD)-1;
	DWORD dwMask = ~0ul;
	for (UINT iMapType = 0; iMapType < s_MapTypeCount; iMapType++)
	{
		if (!_stricmp(argv[0], s_rMapType[iMapType].str))
		{
			dwTypeDesired = s_rMapType[iMapType].dwType;
			dwMask = s_rMapType[iMapType].dwMask;
			break;
		}
	}
	
    if(argc == 1)
    {
        // if we aren't passed any arguments, then just list all the resources
        for (DWORD SymbolIndex = 0; SymbolIndex < pXBR->SymbolCount(); SymbolIndex++)
        {
			CONST CHAR *strName = pXBR->GetSymbolName(SymbolIndex);
			if (dwTypeDesired != -1)
			{
				// Only print out symbols matching the desired type
				DWORD ResourceIndex = pXBR->GetResourceIndexBySymbolIndex(SymbolIndex);
				if (ResourceIndex == (DWORD)-1)
					DCPrintf("resource '%s' not found with symbol index %d\n", argv[1], SymbolIndex);
				DWORD dwType = pXBR->GetTypeByIndex(ResourceIndex);
				if ((dwType & dwMask) != dwTypeDesired)
					continue;	// skip it, since it's not the right type
			}
			DCPrintf("%s\n", strName);
		}
    }
    else
    {
		// Look through symbol table for matching symbol
		for (DWORD SymbolIndex = 0; SymbolIndex < pXBR->SymbolCount(); SymbolIndex++)
		{
			CONST CHAR *strName = pXBR->GetSymbolName(SymbolIndex);
			if (!_stricmp(argv[1], strName))
			{
				DWORD ResourceIndex = pXBR->GetResourceIndexBySymbolIndex(SymbolIndex);
				if (ResourceIndex == (DWORD)-1)
				{
					DCPrintf("resource '%s' not found with symbol index %d\n", argv[1], SymbolIndex);
					return;
				}
				DWORD dwType = pXBR->GetTypeByIndex(ResourceIndex);
				if (dwTypeDesired != -1 
					&& (dwType & dwMask) != dwTypeDesired)
					continue;	// skip it, since it's not the right type
				g_xbApp.SetResource(ResourceIndex);
				DCPrintf("resource '%s' index=%d type=%s(0x%.08x)\n", argv[1], ResourceIndex, TypeName(dwType), dwType);
				return;
			}
		}
		DCPrintf("resource '%s' not found\n", argv[1]);
    }
}

void CXBoxSample::DC_frame(int argc, char *argv[])
{
	XBR *pXBR = &g_xbApp.m_XBR;
	if (argc == 1)
	{
		DWORD SkeletonResourceIndex = g_xbApp.m_nCurrent;
		DWORD dwType = pXBR->GetTypeByIndex(SkeletonResourceIndex);
		if (dwType != XBRC_SKELETON)
		{
			// Dump list of skeletons
			DCPrintf("use 'skeleton' to set current frame hierarchy\n");
			argv[0] = "skeleton";
			DC_resource(argc, argv);
			return;
		}

		// Dump frame hierarchy
		Skeleton *pSkeleton = (Skeleton *)pXBR->GetResourceByIndex(SkeletonResourceIndex);
		struct FrameStackElement {
			Frame *pFrame;
			bool bChildrenDone;
		} rFrameStack[FRAME_MAX_STACK];
		rFrameStack[0].pFrame = pSkeleton->m_pRoot;
		rFrameStack[0].bChildrenDone = false;
		int iFrameStack = 1;	// depth of stack
		while (iFrameStack)
		{
			// Get the top of the stack
			iFrameStack--;
			Frame *pFrame = rFrameStack[iFrameStack].pFrame;
			bool bChildrenDone = rFrameStack[iFrameStack].bChildrenDone;

			if (!bChildrenDone)
			{
				// Get full frame path
				const UINT lenName = FRAME_MAX_STACK * FRAME_IDENTIFIER_SIZE;
				CHAR strName[lenName];
				strName[0] = 0;
				for (int i = 0; i <= iFrameStack; i++)
				{
					strncat(strName, "/", lenName);
					strncat(strName, rFrameStack[i].pFrame->m_strName, lenName);
				}
				strName[lenName - 1] = 0;	// make sure string is terminated

				// Print current frame
				FLOAT *pf = (FLOAT *)pFrame->m_Matrix;
				DCPrintf("frame %s = %g %g %g %g    %g %g %g %g    %g %g %g %g    %g %g %g %g\n",
						 strName,
						 pf[0], pf[1], pf[2], pf[3],
						 pf[4], pf[5], pf[6], pf[7],
						 pf[8], pf[9], pf[10], pf[11],
						 pf[12], pf[13], pf[14], pf[15]);
		
				// Push child
				if (pFrame->m_pChild != NULL)
				{
					// keep current node on stack for path, but mark as done
					rFrameStack[iFrameStack].bChildrenDone = true;
					iFrameStack++;
					if (iFrameStack >= FRAME_MAX_STACK)
						return; // we hit our hard-coded stack-depth limit
					rFrameStack[iFrameStack].pFrame = pFrame->m_pChild;
					rFrameStack[iFrameStack].bChildrenDone = false;
					iFrameStack++;
				}
				else
					bChildrenDone = true;

			}

			if (bChildrenDone)
			{
				// Push sibling
				if (pFrame->m_pNext != NULL)
				{
					if (iFrameStack >= FRAME_MAX_STACK)
						return; // we hit our hard-coded stack-depth limit
					rFrameStack[iFrameStack].pFrame = pFrame->m_pNext;
					rFrameStack[iFrameStack].bChildrenDone = false;
					iFrameStack++;
				}
			}
		}
		return;
	}

	// Parse frame path to get skeleton
	CHAR *pStart = argv[1];
	if (*pStart == '/')		// skip initial separator
		pStart++;
	CHAR *pEnd = strchr(pStart, '/');
	if (pEnd) *pEnd = 0;
	DWORD SkeletonResourceIndex = (DWORD)-1;
	for (DWORD SymbolIndex = 0; SymbolIndex < pXBR->SymbolCount(); SymbolIndex++)
	{
		CONST CHAR *strName = pXBR->GetSymbolName(SymbolIndex);
		if (!_stricmp(pStart, strName))
		{
			DWORD ResourceIndex = pXBR->GetResourceIndexBySymbolIndex(SymbolIndex);
			if (ResourceIndex == (DWORD)-1)
			{
				DCPrintf("resource '%s' not found with symbol index %d\n", pStart, SymbolIndex);
				return;
			}
			DWORD dwType = pXBR->GetTypeByIndex(ResourceIndex);
			if (dwType == XBRC_SKELETON)
			{
				SkeletonResourceIndex = ResourceIndex;
				break;
			}
			// else skip it, since it's not a skeleton
		}
	}
	if (SkeletonResourceIndex == -1)
	{
		DCPrintf("skeleton '%s' not found\n", pStart);
		return;
	}
	Skeleton *pSkeleton = (Skeleton *)pXBR->GetResourceByIndex(SkeletonResourceIndex);
	if (pEnd) *pEnd = '/';	// restore slash
	
	// Parse frame path to get desired frame
	Frame *pFrame = pSkeleton->m_pRoot;
	while (pEnd)
	{
		pStart = pEnd + 1;
		if (*pStart == 0) break;
		pEnd = strchr(pStart, '/');
		if (pEnd) *pEnd = 0;

		// Look through children for matching name
		Frame *pFrameChild = pFrame->m_pChild;
		while (pFrameChild)
		{
			if (!strcmp(pStart, pFrameChild->m_strName))
			{
				pFrame = pFrameChild;
				break;
			}
			pFrameChild = pFrameChild->m_pNext;
		}
		if (pFrame != pFrameChild)
		{
			// Did not find a match
			if (pFrameChild == NULL)
				DCPrintf("frame '%s' not found\n", argv[1]);
			else
				DCPrintf("frame '%s' does not match\n", argv[1]);
			return;
		}
		if (pEnd) *pEnd = '/';	// restore slash
	}

	// Print or set frame
	FLOAT *pf = (FLOAT *)pFrame->m_Matrix;
	if (argc > 2)
	{
		INT iarg = 2;
        if (argv[iarg][0] == '=')
			iarg++;
		for (INT i = 0; iarg < argc && i < 16; iarg++, i++)
			pf[i] = (FLOAT)atof(argv[iarg]);
	}
	DCPrintf("frame %s = %g %g %g %g    %g %g %g %g    %g %g %g %g    %g %g %g %g\n",
			 argv[1],
			 pf[0], pf[1], pf[2], pf[3],
			 pf[4], pf[5], pf[6], pf[7],
			 pf[8], pf[9], pf[10], pf[11],
			 pf[12], pf[13], pf[14], pf[15]);
}

//-----------------------------------------------------------------------------
// Variable declaration block, exposed by the "set" command.
//-----------------------------------------------------------------------------
const DCVARDEF *g_rgDCVars = g_xbApp.s_rgDCVars;
const UINT      g_nDCVars  = g_xbApp.s_nDCVars;

const DCVARDEF CXBoxSample::s_rgDCVars[] = 
{
    { "time",       &g_xbApp.m_fTimeLocal,  DC_FLOAT1, DC_set_time },
    { "timeOrigin", &g_xbApp.m_fTimeOrigin, DC_FLOAT1, NULL },
    { "timeScale",  &g_xbApp.m_fTimeScale,  DC_FLOAT1, NULL },
    { "paused", 	&g_xbApp.m_bPaused,     DC_bool, NULL },
    { "proj", 		&g_xbApp.m_matProjection,     DC_MATRIX, NULL },
    { "view", 		&g_xbApp.m_matView,     DC_MATRIX, NULL },
    { "world", 		&g_xbApp.m_matWorld,    DC_MATRIX, NULL },
	{ "quiet",		&g_bQuiet,				DC_bool, NULL },
};
const UINT CXBoxSample::s_nDCVars = sizeof(CXBoxSample::s_rgDCVars) / sizeof(DCVARDEF);

//-----------------------------------------------------------------------------
// Command declaration block
//-----------------------------------------------------------------------------
const DCCMDDEF *g_rgDCCmds = g_xbApp.s_rgDCCmds;
const UINT      g_nDCCmds  = g_xbApp.s_nDCCmds;

const DCCMDDEF CXBoxSample::s_rgDCCmds[] =                   // List of app-defined commands
{
    {"help",      RCmdHelp,				" [CMD]: List commands / usage"},
    {"set",       RCmdSet,				" [VAR [= VAL]]: list variables or set a variable"},
    {"resource",  g_xbApp.DC_resource,  " [name]: current resource"},
    {"texture",   g_xbApp.DC_resource,  " [name]: current texture"},
    {"effect",    g_xbApp.DC_resource,  " [name]: current effect"},
    {"skeleton",  g_xbApp.DC_resource,  " [name]: current skeleton"},
    {"anim",   	  g_xbApp.DC_resource,  " [name]: current animation"},
    {"vsh",    	  g_xbApp.DC_resource,  " [name]: current vertex shader"},
    {"psh",    	  g_xbApp.DC_resource,  " [name]: current pixel shader"},
    {"ib",     	  g_xbApp.DC_resource,  " [name]: current index buffer"},
    {"vb",     	  g_xbApp.DC_resource,  " [name]: current vertex buffer"},
	{"frame",	  g_xbApp.DC_frame,     " [name]: current frame hierarchy"},
};
const UINT CXBoxSample::s_nDCCmds = sizeof(CXBoxSample::s_rgDCCmds) / sizeof(DCCMDDEF);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\dx2ml.cpp ===
/*
 *
 * dx2ml.cpp
 *
 * CDX2ML
 *
 */

#include "precomp.h"

#define SHOWERRS

#ifndef DVDEMU
__declspec(thread) BOOL fDidCoInit;
#endif

CDX2MLFile::CDX2MLFile(const CDX2MLFile &xml)
#ifndef DVDEMU
    : m_pxdoc(NULL)
#endif
{
    int i;
    DXI *pdxi;
    DXL *pdxl;
    XBI *pxbi;

    if(xml.m_pxml) {
        /* We'll memcpy the whole thing over and then replicate the fields
         * as appropriate */
        m_pxml = new DXML(*xml.m_pxml);
        pdxi = &m_pxml->rgdxi[0];
        for(i = 0; i < idxiMax; ++i, ++pdxi) {
            if(pdxi->szNameOnDisk)
                pdxi->szNameOnDisk = _strdup(pdxi->szNameOnDisk);
            if(pdxi->szNameOnTape)
                pdxi->szNameOnTape = _strdup(pdxi->szNameOnTape);
            if(pdxi->szRefName)
                pdxi->szRefName = _strdup(pdxi->szRefName);
        }
        pdxl = &m_pxml->rgdxl[0];
        for(i = 0; i < 2; ++i, ++pdxl) {
            if(pdxl->pxbi) {
                pxbi = pdxl->pxbi;
                pdxl->pxbi = new XBI[pdxl->ixbiMax];
                memcpy(pdxl->pxbi, pxbi, pdxl->ixbiMac * sizeof(XBI));
            }
        }
    }
}
CDX2MLFile::~CDX2MLFile()
{
    if(m_pxml) {
        for(int idxi = 0; idxi < idxiMax; ++idxi) {
            if(m_pxml->rgdxi[idxi].szNameOnDisk)
                delete m_pxml->rgdxi[idxi].szNameOnDisk;
            if(m_pxml->rgdxi[idxi].szNameOnTape)
                delete m_pxml->rgdxi[idxi].szNameOnTape;
            if(m_pxml->rgdxi[idxi].szRefName)
                delete m_pxml->rgdxi[idxi].szRefName;
        }
        if(m_pxml->szMasteringRef)
            delete m_pxml->szMasteringRef;
#ifndef DVDEMU
        delete m_pxml;
#endif
    }
}

static BOOL FCompareStrings(LPCSTR sz1, LPCSTR sz2)
{
    if(sz1) {
        if(sz2)
            return 0 == strcmp(sz1, sz2);
        else
            return FALSE;
    } else
        return NULL == sz2;
}

bool DXI::operator==(const DXI &dxi) const
{
    return
        FCompareStrings(szRefName, dxi.szRefName) &&
        FCompareStrings(szNameOnDisk, dxi.szNameOnDisk) &&
        FCompareStrings(szNameOnTape, dxi.szNameOnTape) &&
        dwImageSize == dxi.dwImageSize &&
        dwFlags == dxi.dwFlags;
}

bool DXL::operator==(const DXL &dxl) const
{
    return
        0 == memcmp(this, &dxl, (PBYTE)&dxl.pxbi - (PBYTE)&dxl) &&
        0 == memcmp(pxbi, dxl.pxbi, ixbiMac * sizeof(XBI));
}

bool DXML::operator==(const DXML &dxml) const
{
    int idxi;

    for(idxi = 0; idxi < idxiMax; ++idxi) {
        if(rgdxi[idxi] != dxml.rgdxi[idxi])
            return FALSE;
    }
    return
        rgdxl[0] == dxml.rgdxl[0] &&
        rgdxl[1] == dxml.rgdxl[1] &&
        FCompareStrings(szMasteringRef, dxml.szMasteringRef) &&
        fLayoutTape == dxml.fLayoutTape;
}

bool CDX2MLFile::operator==(const CDX2MLFile &xml) const
{
    int idxi;

    if(m_pxml) {
        if(xml.m_pxml)
            return *m_pxml == *xml.m_pxml;
        else
            return FALSE;
    } else
        return NULL == xml.m_pxml;
}

static int ilexXml;
static struct XI {
    XI *pxiPrev;
    LPCSTR szTagCur;
} *pxiTop;

static void PrintXml(CFileStmSeq *pstm, LPCSTR sz)
{
    for(int i = 0; i < ilexXml; ++i)
        pstm->CbWrite(2, (PBYTE)"  ");
    pstm->CbWrite(strlen(sz), (PBYTE)sz);
    pstm->CbWrite(2, (PBYTE)"\r\n");
}

static void StartElem(CFileStmSeq *pstm, LPCSTR szTag, LPCSTR szAttrs)
{
    char sz[1024];

    XI *pxi = new XI;
    pxi->pxiPrev = pxiTop;
    pxiTop = pxi;
    pxi->szTagCur = _strdup(szTag);
    if(szAttrs)
        sprintf(sz, "<%s %s>", szTag, szAttrs);
    else
        sprintf(sz, "<%s>", szTag);
    PrintXml(pstm, sz);
    ++ilexXml;
}

static void EndElem(CFileStmSeq *pstm)
{
    char sz[64];

    XI *pxi = pxiTop;
    pxiTop = pxiTop->pxiPrev;
    --ilexXml;
    sprintf(sz, "</%s>", pxi->szTagCur);
    PrintXml(pstm, sz);
    free((PVOID)pxi->szTagCur);
    delete pxi;
}

/* Here's the list of disc regions */
static struct {
    int ilyr;
    LPCSTR szType;
    int idxr;
} rgdsc[] = {
#ifndef DVDEMU
    { 0, "LEAD-IN", idxrLead },
    { 0, "DATA", idxrData },
    { 0, "MIDDLE", idxrMiddle },
    { 0, "X-LEAD-IN", idxrXLead },
#endif
    { 0, "X-DATA", idxrXData },
#ifndef DVDEMU
    { 0, "X-MIDDLE", idxrXMiddle },
    { 1, "X-MIDDLE", idxrXMiddle },
#endif
    { 1, "X-DATA", idxrXData },
#ifndef DVDEMU
    { 1, "X-LEAD-OUT", idxrXLead },
    { 1, "MIDDLE", idxrMiddle },
    { 1, "DATA", idxrData },
    { 1, "LEAD-OUT", idxrLead },
#endif
};

static LPCSTR rgszPlaceholders[] = {
    "DVD-X2-PLACEHOLDER",
    "DVD-X2-MIRROR-REGION",
    "DVD-X2-GROOVE-REGION",
    "DVD-X2-VELOCITY-REGION",
};

#ifndef DVDEMU

BOOL CDX2MLFile::FWriteFile(LPCSTR sz)
{
    BOOL fRet;
    CDiskFile *pstm;
    
    pstm = new CDiskFile(sz, GENERIC_WRITE);
    if(pstm->FIsOpen())
        fRet = FWriteFile(pstm);
    else
        fRet = FALSE;
    delete pstm;
    return fRet;
}

#endif // DVDEMU

static int rgidxiStreams[] = {
    idxiControl,
    idxiXControl,
    2, 3, 4, 5
};

BOOL CDX2MLFile::FWriteFile(CFileStmSeq *pstm)
{
    int ilyr;
    int idxi;
    int iidxi;
    int ipsn;
    int i;
    DXI *pdxi;
    char szT[1024];
    char szLenT[32];
    LPSTR szStreamType;
    BOOL fFakeName;

    if(!m_pxml)
        return FALSE;

    ilexXml = 0;
    PrintXml(pstm, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    StartElem(pstm, "dx2ml",
#ifdef DVDEMU
        NULL
#else
        "xmlns=\"x-schema:Dx2ml.xdr\""
#endif
        );

    /* Input streams */
    StartElem(pstm, "input", NULL);
    for(ilyr = 0; ilyr < 2; ++ilyr) {
        sprintf(szT, "id=\"Tape%d\"", ilyr + 1);
        StartElem(pstm, "media", szT);
        for(iidxi = 0; iidxi < idxiMax; ++iidxi) {
            idxi = rgidxiStreams[iidxi];
            pdxi = &m_pxml->rgdxi[idxi];
            /* Skip those files not on this layer */
            if(ilyr == 0 && !pdxi->fUsedLyr0)
                continue;
            if(ilyr == 1 && !pdxi->fUsedLyr1)
                continue;
            switch(idxi) {
            case idxiControl:
                szStreamType = "leadin-stream";
                fFakeName = ilyr == 1;
                break;
            case idxiXControl:
                szStreamType = "xbox-leadout-stream";
                fFakeName = ilyr == 0;
                break;
            default:
                szStreamType = "input-stream";
                fFakeName = FALSE;
                break;
            }
            if(m_pxml->fLayoutTape)
                fFakeName = FALSE;

            if(pdxi->dwImageSize)
                sprintf(szLenT, " length=\"%d\"", pdxi->dwImageSize);
            else
                szLenT[0] = 0;
            sprintf(szT, "<%s id=\"%s%s\" file-name=\"%s\"%s%s/>",
                szStreamType, pdxi->szRefName, fFakeName ? "_alt" : "",
                pdxi->szNameOnTape, szLenT, pdxi->f2054 ?
                " storage-mode=\"DATA2054\"" : "");
            PrintXml(pstm, szT);
        }
        EndElem(pstm);
        if(m_pxml->fLayoutTape)
            /* Only one medium */
            break;
    }
    EndElem(pstm);

    /* Disc data */
    StartElem(pstm, "disc", "type=\"DVD-X2\"");
    StartElem(pstm, "side", NULL);
    for(ilyr = 0; ilyr < 2; ++ilyr) {
        sprintf(szT, "id=\"Layer%d\"", ilyr);
        if(ilyr)
            strcat(szT, " direction=\"OUTER-TO-INNER\"");
        StartElem(pstm, "layer", szT);
        sprintf(szT, "start-address=\"%06X\"", m_pxml->rgdxl[ilyr].psnStart);
        StartElem(pstm, "main-band", szT);
        
        /* Loop over all of the disc regions and print out the appropriate
         * data for each */
        for(i = 0; i < (sizeof rgdsc / sizeof rgdsc[0]); ++i) {
            if(rgdsc[i].ilyr == ilyr) {
                DXR *pdxr = &m_pxml->rgdxl[ilyr].rgdxrAreas[rgdsc[i].idxr];
                sprintf(szT, "type=\"%s\"", rgdsc[i].szType);
                StartElem(pstm, "region", szT);
                idxi = pdxr->idxiImage;
                switch(rgdsc[i].idxr) {
                case idxrLead:
                    if(ilyr)
                        /* Layer 1 is leadout */
                        WriteXLeadOut(pstm);
                    else
                        WriteLeadIn(pstm);
                    break;
                case idxrXData:
                    /* We have to print out all of the placeholder and XBE
                     * image data we have accumulated */
                    if(idxi >= 0 && m_pxml->rgdxi[idxi].szRefName) {
                        WriteXData(pstm, ilyr);
                        break;
                    }
                    // else write an empty stream
                default:
                    if(idxi >= 0 && m_pxml->rgdxi[idxi].szRefName) {
                        sprintf(szT, "<input-stream-ref stream-id=\"%s\"/>",
                            m_pxml->rgdxi[idxi].szRefName);
                    } else
                        sprintf(szT, "<zero-stream length-used=\"%d\"/>",
                            m_pxml->rgdxl[ilyr].rgdxrAreas[rgdsc[i].idxr].cpsnSize);
                    PrintXml(pstm, szT);
                    break;
                }
                EndElem(pstm);
            }
        }
        /* Close the band */
        EndElem(pstm);
        
        /* Close the layer */
        EndElem(pstm);
    }
    EndElem(pstm);
    EndElem(pstm);

#ifndef DVDEMU
    /* Identify the layer */
    char szBufT[256];
    if(m_pxml->szMasteringRef)
        sprintf(szBufT, " master-id=\"%s\"", m_pxml->szMasteringRef);
    else
        szBufT[0] = 0;
    sprintf(szT, "<mastering-job media-ref=\"Tape%d\" layer-ref=\"Layer%d\"%s/>",
        m_pxml->iLayer+1, m_pxml->iLayer, szBufT);
    PrintXml(pstm, szT);
#endif
    EndElem(pstm);

    return TRUE;
}

void CDX2MLFile::WriteLeadIn(CFileStmSeq *pstm)
{
    char szT[1024];
    DXL *pdxl = &m_pxml->rgdxl[0];
    DXR *pdxr = &pdxl->rgdxrAreas[idxrLead];

    /* First write out padding up to the reference stream */
    if(pdxl->psnStart < pdxr->psnStart) {
        sprintf(szT, "<zero-stream length-used=\"%d\"/>", pdxr->psnStart -
            pdxl->psnStart);
        PrintXml(pstm, szT);
    }
    /* Then comes the reference stream */
    PrintXml(pstm, "<reference-code-stream/>");
    /* Now pad up to the control stream */
    if(pdxl->ipsnControlStart > 32) {
        sprintf(szT, "<zero-stream length-used=\"%d\"/>",
            pdxl->ipsnControlStart - 32);
        PrintXml(pstm, szT);
    }
    /* Here's the leadin stream */
    sprintf(szT, "<leadin-stream-ref stream-id=\"%s\"/>",
        m_pxml->rgdxi[idxiControl].szRefName);
    PrintXml(pstm, szT);
    /* Pad out this region */
    if((pdxl->ipsnControlStart + 16 * 192) < pdxr->cpsnSize) {
        sprintf(szT, "<zero-stream length-used=\"%d\"/>", pdxr->cpsnSize -
            (pdxl->ipsnControlStart + 16 * 192));
        PrintXml(pstm, szT);
    }
}

void CDX2MLFile::WriteXLeadOut(CFileStmSeq *pstm)
{
    char szT[1024];
    DXL *pdxl = &m_pxml->rgdxl[1];
    DXR *pdxr = &pdxl->rgdxrAreas[idxrLead];

    /* Write the appropriate amount of blank space */
    if(pdxl->ipsnControlStart) {
        sprintf(szT, "<zero-stream length-used=\"%d\"/>",
            pdxl->ipsnControlStart);
        PrintXml(pstm, szT);
    }
    /* Write out the leadout stream */
    sprintf(szT,  "<xbox-leadout-stream-ref stream-id=\"%s\"/>",
        m_pxml->rgdxi[idxiXControl].szRefName);
    PrintXml(pstm, szT);
    /* Write out the remaining blank space */
    if(pdxl->ipsnControlStart + 32 * 80 < pdxr->cpsnSize) {
        sprintf(szT, "<zero-stream length-used=\"%d\"/>", pdxr->cpsnSize -
            (pdxl->ipsnControlStart + 32 * 80));
        PrintXml(pstm, szT);
    }
}

void CDX2MLFile::WriteXData(CFileStmSeq *pstm, int ilyr)
{
    DXL *pdxl = &m_pxml->rgdxl[ilyr];
    DXR *pdxr = &pdxl->rgdxrAreas[idxrXData];
    DXI *pdxi = &m_pxml->rgdxi[pdxr->idxiImage];
    int i = 0;
    int ixbi = 0;
    DWORD psnCur = 0;
    DWORD psnMax = pdxr->cpsnSize;
    BOOL fXbiNext;
    LPCSTR szType;
    DWORD dwSize;
    DWORD dwStart;
    char szT[1024];

    while(i < pdxl->cxph || ixbi < pdxl->ixbiMac) {
        if(ixbi == pdxl->ixbiMac)
            fXbiNext = FALSE;
        else if(i == pdxl->cxph)
            fXbiNext = TRUE;
        else
            fXbiNext = pdxl->pxbi[ixbi].lsnStart < pdxl->rgxph[i].lsnStart;
        if(fXbiNext) {
            dwStart = pdxl->pxbi[ixbi].lsnStart;
            dwSize = pdxl->pxbi[ixbi++].cpsnSize;
            szType = "XBOX-EXECUTABLE";
        } else {
            dwStart = pdxl->rgxph[i].lsnStart;
            dwSize = 4096;
            szType = rgszPlaceholders[pdxl->rgxph[i++].ph];
        }
        /* If we've somehow gotten an overlap, we have to skip this */
        if(psnCur > dwStart)
            continue;
        /* Print out the null content to the next point */
        if(psnCur < dwStart) {
            sprintf(szT, "<input-stream-ref stream-id=\"%s\" "
                "length-used=\"%d\"/>", pdxi->szRefName, dwStart - psnCur);
            PrintXml(pstm, szT);
            psnCur = dwStart;
        }
        /* Print out the current content */
        sprintf(szT, "<input-stream-ref stream-id=\"%s\" "
            "length-used=\"%d\" content=\"%s\"/>", pdxi->szRefName,
            dwSize, szType);
        PrintXml(pstm, szT);
        psnCur += dwSize;
    }

    /* If we have room to go, then print out the tail */
    if(psnCur < psnMax) {
        sprintf(szT, "<input-stream-ref stream-id=\"%s\" length-used=\"%d\"/>", pdxi->szRefName,
            psnMax - psnCur);
        PrintXml(pstm, szT);
    }
}

#ifndef DVDEMU

LPSTR SzCopyWz(LPCWSTR wz)
{
    LPSTR sz;
    int cch;
    
    cch = WideCharToMultiByte(CP_ACP, 0, wz, -1, NULL, 0, NULL, NULL);
    if(cch > 0) {
        sz = new char[cch + 1];
        WideCharToMultiByte(CP_ACP, 0, wz, -1, sz, cch + 1, NULL, NULL);
        sz[cch] = 0;
    }
    return sz;
}

BOOL FEqualSzWz(LPCSTR sz, LPCWSTR wz, BOOL fIgnCase)
{
    for(; *sz; ++sz, ++wz) {
        if(fIgnCase) {
            if(isupper(*sz)) {
                if(*sz != (isupper(*wz) ? *wz : toupper(*wz)))
                    return FALSE;
                continue;
            } else if(islower(*sz)) { 
                if(*sz != (islower(*wz) ? *wz : tolower(*wz)))
                    return FALSE;
                continue;
            }
        }
        if(*sz != *wz)
            return FALSE;
    }
    return !*wz;
}

/* Define a COM ptr class helper that will release upon requery */
template <class T> class CMyComPtr : public CComPtr<T>
{
public:
    T** operator&()
    {
        if(p != NULL) {
            p->Release();
            p = NULL;
        }
        return &p;
    }
};

static BOOL FGetAttribute(IXMLDOMNode *pxn, LPCOLESTR wz, CComVariant *pvar)
{
    CMyComPtr<IXMLDOMNamedNodeMap> pxmap;
    CMyComPtr<IXMLDOMNode> pxnAttr;

    if(S_OK != pxn->get_attributes(&pxmap))
        return FALSE;
    if(S_OK != pxmap->getNamedItem(CComBSTR(wz), &pxnAttr))
        return FALSE;
    pvar->Clear();
    return S_OK == pxnAttr->get_nodeValue(pvar);
}

BOOL CDX2MLFile::FReadFile(LPCSTR sz, BOOL fRequireFull)
{
    LPOLESTR wz;
    int cwch;
    HRESULT hr;
    VARIANT_BOOL f;
    CMyComPtr<IXMLDOMNodeList> pxnlLyrList;
    CMyComPtr<IXMLDOMNode> pxn;
    CComVariant var;
    int ilyr;
    int idxr;

    /* Dump any document we might have */
    if(m_pxml) {
        delete m_pxml;
        m_pxml = NULL;
    }

    /* Make sure we've got COM going */
    if(!fDidCoInit) {
        if(FAILED(CoInitialize(NULL)))
            return FALSE;
        fDidCoInit = TRUE;
    }

    /* Make sure we've got a DOMDocument */
    if(!m_pxdoc) {
        CLSID clsid;

        if(FAILED(CLSIDFromProgID(L"Msxml.DOMDocument", &clsid)))
            return FALSE;
        if(FAILED(CoCreateInstance(clsid, NULL, CLSCTX_ALL,
                IID_IXMLDOMDocument, (void **)&m_pxdoc)))
            return FALSE;
    }

    /* Set document parameters */
    m_pxdoc->put_async(false);
    m_pxdoc->put_validateOnParse(!!fRequireFull);

    /* Load the file */
    cwch = 1 + strlen(sz);
    wz = (LPOLESTR)_alloca(cwch * sizeof(WCHAR));
    if(!MultiByteToWideChar(CP_ACP, 0, sz, -1, wz, cwch))
        return FALSE;
    hr = m_pxdoc->load(CComVariant(wz), &f);
    if(hr != S_OK || !f) {
#ifdef SHOWERRS
        CMyComPtr<IXMLDOMParseError> ppe;
        if(S_OK == m_pxdoc->get_parseError(&ppe)) {
            CComBSTR bst;
            if(S_OK == ppe->get_reason(&bst))
                fwprintf(stderr, L"XML parse error: %s\n", (LPOLESTR)bst);
        }
#endif
        return FALSE;
    }
    m_pxml = new DXML;
    memset(m_pxml, 0, sizeof *m_pxml);

    /* We've got a document, now pick apart the pieces.  First get the input
     * streams */
    if(S_OK == m_pxdoc->selectNodes(CComBSTR(L"/dx2ml/input/media"),
        &pxnlLyrList))
    {
        pxnlLyrList->reset();
        ilyr = 0;
        while(S_OK == pxnlLyrList->nextNode(&pxn) && ilyr < 2) {
            /* Figure out what layer we're looking at */
            if(!FGetAttribute(pxn, L"id", &var))
                continue;
            if(var.vt != VT_BSTR)
                continue;
            ReadInputStreams(ilyr, pxn);
            ++ilyr;
        }
    }

    /* Now read the disc regions */
    if(S_OK == m_pxdoc->selectNodes(CComBSTR(L"/dx2ml/disc/side/layer"),
        &pxnlLyrList))
    {
        pxnlLyrList->reset();
        while(S_OK == pxnlLyrList->nextNode(&pxn)) {
            /* Figure out what layer we're looking at */
            if(!FGetAttribute(pxn, L"id", &var))
                continue;
            if(var.vt != VT_BSTR)
                continue;
            if(0 == _wcsicmp(var.bstrVal, L"Layer0"))
                ilyr = 0;
            else if(0 == _wcsicmp(var.bstrVal, L"Layer1"))
                ilyr = 1;
            else
                continue;
            ReadDiscRegions(ilyr, pxn);
        }
    }

    /* Get the mastering job layer ID and mastering reference */
    m_pxml->iLayer = -1;
    if(S_OK == m_pxdoc->selectNodes(CComBSTR(L"/dx2ml/mastering-job"),
        &pxnlLyrList))
    {
        pxnlLyrList->reset();
        /* Only read the first one */
        if(S_OK == pxnlLyrList->nextNode(&pxn)) {
            if(FGetAttribute(pxn, L"layer-ref", &var) && var.vt == VT_BSTR) {
                if(0 == _wcsicmp(var.bstrVal, L"Layer0"))
                    m_pxml->iLayer = 0;
                else if(0 == _wcsicmp(var.bstrVal, L"Layer1"))
                    m_pxml->iLayer = 1;
            } else if(FGetAttribute(pxn, L"master-id", &var) && var.vt ==
                    VT_BSTR)
                m_pxml->szMasteringRef = SzCopyWz(var.bstrVal);
        }
    }

    return TRUE;
}

void CDX2MLFile::ReadInputStreams(int ilyr, IXMLDOMNode *pxnIn)
{
    CMyComPtr<IXMLDOMNodeList> pxnl;
    CMyComPtr<IXMLDOMNode> pxn;
    CComBSTR bstrType;
    CComVariant varId;
    CComVariant var;
    int idxi;
    DXI *pdxi;

    if(S_OK == pxnIn->selectNodes(CComBSTR(L"*"), &pxnl)) {
        pxnl->reset();
        while(S_OK == pxnl->nextNode(&pxn)) {
            bstrType.Empty();
            if(S_OK != pxn->get_nodeName(&bstrType))
                continue;
            if(FEqualSzWz("leadin-stream", bstrType, FALSE)) {
                idxi = idxiControl;
                m_pxml->rgdxi[idxi].fUsedLyr0 = TRUE;
                m_pxml->rgdxi[idxi].fUsedLyr1 = TRUE;
            } else if(FEqualSzWz("xbox-leadout-stream", bstrType, FALSE)) {
                /* We only want this from layer 1, but if we're reading a
                 * single-layer XML, then we need to take it from layer 0.
                 * We'll just parse whatever is here and discard any previously
                 * read value */
                idxi = idxiXControl;
                if(m_pxml->rgdxi[idxi].szRefName) {
                    free(m_pxml->rgdxi[idxi].szRefName);
                    m_pxml->rgdxi[idxi].szRefName = NULL;
                    if(m_pxml->rgdxi[idxi].szNameOnTape)
                        free(m_pxml->rgdxi[idxi].szNameOnTape);
                }
                m_pxml->rgdxi[idxi].fUsedLyr0 = TRUE;
                m_pxml->rgdxi[idxi].fUsedLyr1 = TRUE;
            } else if(FEqualSzWz("input-stream", bstrType, FALSE)) {
                for(idxi = 2; idxi < idxiMax && m_pxml->rgdxi[idxi].szRefName;
                    ++idxi);
                if(idxi == idxiMax)
                    /* Too much data, ignore */
                    continue;
            } else
                continue;
            if(!FGetAttribute(pxn, L"id", &varId) || varId.vt != VT_BSTR)
                continue;
            pdxi = &m_pxml->rgdxi[idxi];
            if(pdxi->szRefName)
                /* A duplicate somehow */
                continue;
            pdxi->szRefName = SzCopyWz(varId.bstrVal);
            if(FGetAttribute(pxn, L"file-name", &var) && var.vt == VT_BSTR)
                pdxi->szNameOnTape = SzCopyWz(var.bstrVal);
            if(FGetAttribute(pxn, L"length", &var) && var.vt == VT_BSTR)
                swscanf(var.bstrVal, L"%d", &pdxi->dwImageSize);
            if(FGetAttribute(pxn, L"storage-mode", &var) && var.vt == VT_BSTR &&
                    FEqualSzWz("DATA2054", var.bstrVal, FALSE))
                pdxi->f2054 = TRUE;
        }
    }
}

void CDX2MLFile::ReadDiscRegions(int ilyr, IXMLDOMNode *pxnIn)
{
    CMyComPtr<IXMLDOMNodeList> pxnlRgns, pxnlData;
    CMyComPtr<IXMLDOMNode> pxn, pxnData;
    CComVariant var;
    CComBSTR bstrName;
    int idxi;
    int i;
    int iMax = sizeof rgdsc / sizeof rgdsc[0];
    DXL *pdxl = &m_pxml->rgdxl[ilyr];
    DXR *pdxr;
    BOOL fGotStream;
    BOOL fWantSize;
    BOOL fGotSize;
    DWORD dwSize;
    DWORD psnCur;

    /* First mark all of the regions as absent */
    for(i = 0; i < idxrMax; ++i)
        pdxl->rgdxrAreas[i].idxiImage = -1;

    /* Find the start PSN for this side */
    if(S_OK != pxnIn->selectSingleNode(CComBSTR(L"main-band"), &pxn) ||
            !FGetAttribute(pxn, L"start-address", &var) ||
            !swscanf(var.bstrVal, L"%x", &pdxl->psnStart))
        pdxl->psnStart = 0;
    psnCur = pdxl->psnStart;

    /* Scan the region list */
    if(S_OK == pxnIn->selectNodes(CComBSTR(L"main-band/region"), &pxnlRgns)) {
        pxnlRgns->reset();
        while(S_OK == pxnlRgns->nextNode(&pxn)) {
            /* Get the region type */
            if(!FGetAttribute(pxn, L"type", &var) || var.vt != VT_BSTR)
                continue;

            /* See whether we can figure out which area we're talking about */
            for(i = 0; i < iMax; ++i) {
                if(rgdsc[i].ilyr == ilyr && FEqualSzWz(rgdsc[i].szType,
                        var.bstrVal, FALSE))
                    break;
            }
            if(i == iMax)
                continue;

            pdxr = &pdxl->rgdxrAreas[rgdsc[i].idxr];
            pdxr->psnStart = psnCur;
            pdxr->cpsnSize = 0;
            pdxr->idxiImage = -1;
            if(rgdsc[i].idxr == idxrLead)
                /* In case we don't see any good data, make it up */
                pdxl->ipsnControlStart = ilyr ? 0xFD0200 - psnCur : 512;

            /* Figure out what's in this section */
            if(S_OK == pxn->selectNodes(CComBSTR("*"), &pxnlData)) {
                pxnlData->reset();
                while(S_OK == pxnlData->nextNode(&pxnData)) {
                    bstrName.Empty();
                    if(S_OK != pxnData->get_nodeName(&bstrName))
                        continue;
                    fGotStream = FALSE;
                    fWantSize = FALSE;
                    dwSize = 0;
                    if(FEqualSzWz("zero-stream", bstrName, FALSE))
                        fWantSize = TRUE;
                    else if(FEqualSzWz("leadin-stream-ref", bstrName, FALSE) &&
                        ilyr == 0)
                    {
                        fGotStream = TRUE;
                        dwSize = 16 * 192;
                        /* Remember this starting block */
                        if(rgdsc[i].idxr == idxrLead && ilyr == 0) {
                            pdxl->ipsnControlStart = psnCur - pdxr->psnStart;
                        }
                    } else if(FEqualSzWz("xbox-leadout-stream-ref", bstrName,
                        FALSE) && ilyr == 1)
                    {
                        fGotStream = TRUE;
                        dwSize = 32 * 80;
                        if(rgdsc[i].idxr == idxrLead && ilyr == 1)
                            pdxl->ipsnControlStart = psnCur - pdxr->psnStart;
                    } else if(FEqualSzWz("reference-code-stream", bstrName,
                        FALSE) && ilyr == 0)
                    {
                        dwSize = 16 * 2;
                        /* This is the real start of the leadin area */
                        if(rgdsc[i].idxr == idxrLead && ilyr == 0) {
                            pdxr->psnStart = psnCur;
                            pdxr->cpsnSize = 0;
                        }
                    } else if(FEqualSzWz("input-stream-ref", bstrName, FALSE)) {
                        fGotStream = fWantSize = TRUE;
                    }
                    /* If we've got a size to find, get the data */
                    if(fWantSize && FGetAttribute(pxnData, L"length-used",
                            &var) && var.vt == VT_BSTR)
                        fGotSize = 1 == swscanf(var.bstrVal, L"%lu", &dwSize);
                    else
                        fGotSize = 0;
                    /* If we've got a stream name, find it so we can hook up
                     * to the appropriate input stream */
                    if(fGotStream && FGetAttribute(pxnData, L"stream-id",
                        &var) && var.vt == VT_BSTR)
                    {
                        /* We're only going to look up the image name if
                         * we haven't seen one already for this region.
                         * TODO: error out */
                        if(pdxr->idxiImage < 0) {
                            for(idxi = 0; idxi < idxiMax; ++idxi) {
                                if(m_pxml->rgdxi[idxi].szRefName &&
                                    FEqualSzWz(m_pxml->rgdxi[idxi].szRefName,
                                    var.bstrVal, FALSE))
                                {
                                    pdxr->idxiImage = idxi;
                                    if(ilyr == 0)
                                        m_pxml->rgdxi[idxi].fUsedLyr0 = TRUE;
                                    else
                                        m_pxml->rgdxi[idxi].fUsedLyr1 = TRUE;
                                    break;
                                }
                            }
                        }
                    }

                    /* If we didn't get a size, but we have an input stream,
                     * we'll take its size */
                    if(fWantSize && !fGotSize && pdxr->idxiImage >= 0)
                        dwSize = m_pxml->rgdxi[pdxr->idxiImage].dwImageSize;

                    /* If this is Xbox image data, we need to track this as a
                     * placeholder, XBE, etc. */
                    if(rgdsc[i].idxr == idxrXData && FGetAttribute(pxnData,
                        L"content", &var) && var.vt == VT_BSTR)
                    {
                        if(FEqualSzWz("XBOX-EXECUTABLE", var.bstrVal,
                            FALSE))
                        {
                            if(!pdxl->pxbi || pdxl->ixbiMax == pdxl->ixbiMac) {
                                XBI *pxbiNew = new XBI[pdxl->ixbiMax += 32];
                                if(pdxl->pxbi) {
                                    memcpy(pxbiNew, pdxl->pxbi,
                                        sizeof *pxbiNew * pdxl->ixbiMac);
                                    delete pdxl->pxbi;
                                }
                                pdxl->pxbi = pxbiNew;
                            }
                            pdxl->pxbi[pdxl->ixbiMac].lsnStart = pdxr->cpsnSize;
                            pdxl->pxbi[pdxl->ixbiMac++].cpsnSize = dwSize;
                        } else if(dwSize >= 4096 && pdxl->cxph < 8) {
                            /* Placeholders have to be at least 4096 blocks.
                             * If we find something smaller, ignore it; if we
                             * find something bigger, we roll the excess into
                             * the next block */
                            pdxl->rgxph[pdxl->cxph].lsnStart =
                                pdxr->cpsnSize;
                            for(int ph = 0; ph < XPH::phMax; ++ph) {
                                if(FEqualSzWz(rgszPlaceholders[ph],
                                        var.bstrVal, FALSE))
                                    break;
                            }
                            if(ph < XPH::phMax)
                                pdxl->rgxph[pdxl->cxph++].ph = ph;
                        }
                    }

                    /* Account for the size */
                    pdxr->cpsnSize += dwSize;
                    psnCur += dwSize;
                }
            }
        }
    }

    /* Now place all of the empty regions */
    i = ilyr ? idxrMax-1 : 0;
    pdxr = &pdxl->rgdxrAreas[i];
    psnCur = pdxl->psnStart;
    if(pdxr->cpsnSize == 0 && pdxr->psnStart != 0)
        psnCur = pdxr->psnStart;
    for(;;) {
        pdxr = &pdxl->rgdxrAreas[i];
        if(pdxr->cpsnSize == 0)
            pdxr->psnStart = psnCur;
        psnCur = pdxr->psnStart + pdxr->cpsnSize;
        if(ilyr) {
            if(--i < 0)
                break;
        } else {
            if(++i == idxrMax)
                break;
        }
    }
}

#endif // DVDEMU

BOOL CDX2MLFile::FValidateForm(void) const
{
    DWORD psnCur;
    int ilyr;
    int idxr;
    DXR *pdxr;
    DXL *pdxl;

    if(!m_pxml)
        return FALSE;

    /* Make sure that the layers line up and that those sections that were
     * specified show up in the right order */
    for(idxr = ilyr = 0; ilyr < 2; ++ilyr, --idxr) {
        pdxl = &m_pxml->rgdxl[ilyr];
        pdxr = &pdxl->rgdxrAreas[idxr];
        psnCur = pdxl->psnStart;
        /* On layer 0, the psn of the first area is allowed to be different
         * from the start psn of the layer, but only if it specifies lead
         * spacing */
        if(ilyr == 0) {
            if(pdxr->psnStart < psnCur)
                return FALSE;
            psnCur = pdxr->psnStart;
        }
        for(;;) {
            if(pdxr->psnStart != psnCur)
                return FALSE;
            if(pdxr->idxiImage >= 2 && pdxr->cpsnSize !=
                    m_pxml->rgdxi[pdxr->idxiImage].dwImageSize)
                return FALSE;
            psnCur += pdxr->cpsnSize;
            if(ilyr == 0) {
                ++pdxr;
                if(++idxr == idxrMax)
                    break;
            } else {
                --pdxr;
                if(--idxr < 0)
                    break;
            }
        }
        /* The last psn must equal the first psn of the opposite side */
        if(0x1000000 - psnCur != m_pxml->rgdxl[1 - ilyr].psnStart)
            return FALSE;
    }

    return TRUE;
}

BOOL CDX2MLFile::FValidateContent(void) const
{
    if(!FValidateForm())
        return FALSE;

    /* There are some things we don't validate here: that the image and ximage
     * data streams match up layer-to-layer and match the control data.  That's
     * done when we validate the control data */

    return
        /* Make sure the images occur in the right order */
        m_pxml->rgdxl[0].dxrLead.idxiImage == idxiControl &&
        m_pxml->rgdxl[0].dxrData.idxiImage == 2 &&
        m_pxml->rgdxl[0].dxrXData.idxiImage == 3 &&
        m_pxml->rgdxl[1].dxrXData.idxiImage == 4 &&
        m_pxml->rgdxl[1].dxrData.idxiImage == 5 &&
        m_pxml->rgdxl[1].dxrLead.idxiImage == idxiXControl &&

        /* Make sure the ECMA Control is in the right place */
        m_pxml->rgdxl[0].psnStart <= 0x020000 &&
        m_pxml->rgdxl[0].dxrLead.psnStart == 0x02F000 &&
        m_pxml->rgdxl[0].ipsnControlStart == 0x02F200 -
            m_pxml->rgdxl[0].dxrLead.psnStart &&

        /* Make sure the layer 0 middle area is big enough */
        m_pxml->rgdxl[0].dxrMiddle.psnStart <= 0x050E00 &&

        /* Make sure the layer 0 XLeadin is the right size */
        m_pxml->rgdxl[0].dxrXLead.psnStart == 0x05B200 &&
        m_pxml->rgdxl[0].dxrXLead.cpsnSize >= 0x5400 &&

        /* Make sure the layer 0 XMiddle is the right size */
        m_pxml->rgdxl[0].dxrXMiddle.psnStart <= 0x222F40 &&

        /* Make sure the layer 1 XMiddle is the right size */
        m_pxml->rgdxl[1].psnStart == 0xDC8860 &&

        /* Make sure the layer 1 XLeadout is the right size */
        m_pxml->rgdxl[1].dxrXLead.psnStart <= 0xF9FA00 &&

        /* Make sure the layer 1 middle area is the right size */
        m_pxml->rgdxl[1].dxrMiddle.psnStart == 0xFA4E00 &&
        m_pxml->rgdxl[1].dxrMiddle.cpsnSize >= 0xA400 &&

        /* Make sure the XControl is in the right place */
        m_pxml->rgdxl[1].dxrLead.psnStart <= 0xFD0000 &&
        m_pxml->rgdxl[1].ipsnControlStart == 0xFD0200 -
            m_pxml->rgdxl[1].dxrLead.psnStart;
}

BOOL CDX2MLFile::FValidatePlaceholderLocations(BOOL fFixup, BOOL fAPOnly,
    BOOL fPrintResults)
{
    int i;
    int iPrev;
    int ipsn;
    int ipsnMac;
    DWORD psn;
    DWORD dpsn;
    struct {
        DWORD psn;
        WORD ilyr;
        WORD ixph;
    } rgnxph[16];

    if(!m_pxml)
        return FALSE;

    /* Copy the layer 0 placeholders.  Make sure they are sufficiently
     * separated */
    ipsnMac = 0;
    for(i = 0; i < m_pxml->rgdxl[0].cxph; ++i) {
        /* All placeholders have to be on even boundaries, so check that
         * first */
        if(m_pxml->rgdxl[0].rgxph[i].lsnStart & 1) {
            if(fPrintResults) {
                fprintf(stderr, "error: layer 0 PH %d is not on an even sector\n",
                    i);
            }
            return FALSE;
        }
        if(fAPOnly && m_pxml->rgdxl[0].rgxph[i].ph == XPH::phNone)
            continue;
        rgnxph[ipsnMac].psn = m_pxml->rgdxl[0].rgxph[i].lsnStart +
            m_pxml->rgdxl[0].dxrXData.psnStart;
        rgnxph[ipsnMac].ilyr = 0;
        rgnxph[ipsnMac].ixph = (WORD)i;
        ++ipsnMac;
    }

    /* Copy the layer 1 placeholders.  We convert each placholder's layer 1 end
     * PSN into the matching layer 0 PSN and insert it into the sorted array */
    for(i = 0; i < m_pxml->rgdxl[1].cxph; ++i) {
        /* All placeholders have to be on even boundaries, so check that
         * first */
        if((m_pxml->rgdxl[0].dxrXData.cpsnSize +
            m_pxml->rgdxl[1].rgxph[i].lsnStart) & 1)
        {
            if(fPrintResults) {
                fprintf(stderr, "error: layer 1 PH %d is not on an even sector\n",
                    i);
            }
            return FALSE;
        }
        if(fAPOnly && m_pxml->rgdxl[1].rgxph[i].ph == XPH::phNone)
            continue;
        psn = (m_pxml->rgdxl[1].rgxph[i].lsnStart +
            m_pxml->rgdxl[1].dxrXData.psnStart + 0xFFF) ^ 0xFFFFFF;
        for(ipsn = 0; ipsn < ipsnMac; ++ipsn) {
            if(psn < rgnxph[ipsn].psn)
                break;
        }
        if(ipsn < ipsnMac) {
            memmove(&rgnxph[ipsn+1], &rgnxph[ipsn], (ipsnMac - ipsn) *
                sizeof(rgnxph[0]));
        }
        rgnxph[ipsn].psn = psn;
        rgnxph[ipsn].ilyr = 1;
        rgnxph[ipsn].ixph = (WORD)i;
        ++ipsnMac;
    }

    /* Make sure no placeholder is too close to the x-leadin */
    /* TODO: this should be 2mm, not a fixed number of sectors */
    for(i = 0; i < ipsnMac && rgnxph[i].psn < 0x6B000 || rgnxph[i].psn -
        m_pxml->rgdxl[0].dxrXData.psnStart < 0x15F00; ++i)
    {
        if(fPrintResults)
            fprintf(stderr, "%s: layer %d PH %d is too close to leadin\n",
                fFixup ? "warning" : "error", rgnxph[i].ilyr, rgnxph[i].ixph);
        if(!fFixup)
            return FALSE;
        m_pxml->rgdxl[rgnxph[i].ilyr].rgxph[rgnxph[i].ixph].fDisallow = TRUE;
    }
    i = ipsnMac;
    while(i-- && rgnxph[i].psn + 0x1000 > m_pxml->rgdxl[0].dxrXMiddle.psnStart -
        0x10000)
    {
        if(fPrintResults)
            fprintf(stderr, "%s: layer %d PH %d is too close to leadin\n",
                fFixup ? "warning" : "error", rgnxph[i].ilyr, rgnxph[i].ixph);
        if(!fFixup)
            return FALSE;
        m_pxml->rgdxl[rgnxph[i].ilyr].rgxph[rgnxph[i].ixph].fDisallow = TRUE;
    }
    iPrev = ipsnMac - 1;
    for(i = iPrev - 1; i >= 0; --i) {
        dpsn = rgnxph[i].ilyr == rgnxph[iPrev].ilyr ? 0x21000 : 0x11000;
        if(rgnxph[iPrev].psn - rgnxph[i].psn < dpsn) {
            if(fPrintResults) {
                fprintf(stderr, "%s: layer %d PH %d is too close to layer %d PH %d\n",
                    fFixup ? "warning" : "error", rgnxph[i].ilyr, rgnxph[i].ixph,
                    rgnxph[iPrev].ilyr, rgnxph[iPrev].ixph);
            }
            if(!fFixup)
                return FALSE;
            m_pxml->rgdxl[rgnxph[i].ilyr].rgxph[rgnxph[i].ixph].fDisallow = TRUE;
        } else
            iPrev = i;
    }

    return TRUE;
}

void CDX2MLFile::SetMasteringRef(LPCSTR sz)
{
    if(m_pxml) {
        if(m_pxml->szMasteringRef)
            delete m_pxml->szMasteringRef;
        if(sz)
            m_pxml->szMasteringRef = _strdup(sz);
        else
            m_pxml->szMasteringRef = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\dx2ml.h ===
/*
 *
 * dx2ml.h
 *
 * CDX2ML
 *
 */

#ifndef _DX2ML_H
#define _DX2ML_H

#include <filestm.h>

#define MAX_PLACEHOLDER_PER_LAYER 8

struct DXI
{
    LPSTR szRefName;
    LPSTR szNameOnDisk;
    LPSTR szNameOnTape;
    DWORD dwImageSize;
    union {
        struct {
            DWORD dwTapeId:1,
                fTapeFile:1,
                fUsedLyr0:1,
                fUsedLyr1:1,
                f2054:1,
                unused:27;
        };
        DWORD dwFlags;
    };

    bool operator==(const DXI &) const;
    bool operator!=(const DXI &dxi) const { return !(*this == dxi); }
};

struct DXR
{
    DWORD psnStart;
    DWORD cpsnSize;
    int idxiImage;
};

struct XBI
{
    DWORD lsnStart;
    DWORD cpsnSize;
	DWORD dwDummy;
};

// WARNING: the XBI and XPH have to be the same size

struct XPH
{
    DWORD lsnStart;
    enum {
        phNone,
        phMirror,
        phGroove,
        phVelocity,
        phMax
    };
    int ph;
    BOOL fDisallow;
};

struct DXL
{
    union {
        struct {
            DXR dxrLead;
            DXR dxrData;
            DXR dxrMiddle;
            DXR dxrXLead;
            DXR dxrXData;
            DXR dxrXMiddle;
        };
        DXR rgdxrAreas[6];
    };
    DWORD psnStart;
    DWORD ipsnControlStart;
    XPH rgxph[MAX_PLACEHOLDER_PER_LAYER];
    int cxph;
    int ixbiMac;
    int ixbiMax;
    XBI *pxbi;

    bool operator==(const DXL &) const;
    bool operator!=(const DXL &dxl) const { return !(*this == dxl); }
};

enum { idxrLead, idxrData, idxrMiddle, idxrXLead, idxrXData, idxrXMiddle,
    idxrMax };

enum { idxiXControl, idxiControl, idxiMax=6 };

struct DXML
{
    union {
        struct {
            DXI dxiXControl;
            DXI dxiControl;
        };
        DXI rgdxi[idxiMax];
    };
    DXL rgdxl[2];
    BOOL fLayoutTape;
    LPSTR szMasteringRef;
    DWORD iLayer;

    bool operator==(const DXML &) const;
    bool operator!=(const DXML &dxml) const { return !(*this == dxml); }
};

class CDX2MLFile
{
public:
#ifdef DVDEMU
    CDX2MLFile(void)
    {
        memset(&m_dxml, 0, sizeof m_dxml);
        m_pxml = &m_dxml;
    }
#else
    CDX2MLFile(void) : m_pxml(NULL), m_pxdoc(NULL) {}
#endif
    CDX2MLFile(const CDX2MLFile &xml);
    ~CDX2MLFile();

    BOOL FReadFile(LPCSTR sz, BOOL fRequireFull);
    BOOL FWriteFile(LPCSTR sz);
    BOOL FWriteFile(CFileStmSeq *pstm);

    BOOL FValidateForm(void) const;
    BOOL FValidateContent(void) const;
    BOOL FValidatePlaceholderLocations(BOOL fFixup, BOOL fAPOnly,
        BOOL fPrintResults);

    DXML *PdxmlGet(void) { return m_pxml; }
    void SetMasteringRef(LPCSTR sz);

    bool operator==(const CDX2MLFile &) const;
    bool operator!=(const CDX2MLFile &xml) const { return !(*this == xml); }

private:
    DXML *m_pxml;
#ifdef DVDEMU
    DXML m_dxml;
#else
    CComPtr<IXMLDOMDocument> m_pxdoc;
    void ReadInputStreams(int ilyr, IXMLDOMNode *pxnIn);
    void ReadDiscRegions(int ilyr, IXMLDOMNode *pxn);
#endif

    void WriteXData(CFileStmSeq *pstm, int ilyr);
    void WriteLeadIn(CFileStmSeq *pstm);
    void WriteXLeadOut(CFileStmSeq *pstm);
};

#endif // _DX2ML_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\filestm.h ===
/*
 *
 * filestm.h
 *
 * file access classes
 *
 */

#ifndef _FILESTM_H
#define _FILESTM_H

class CFileStmSeq
{
public:
    virtual BOOL FIsOpen(void) =0;
    virtual DWORD CbRead(DWORD cb, PBYTE pbBuf) =0;
    virtual DWORD CbWrite(DWORD cb, const BYTE *pbBuf) =0;
    virtual BOOL FCopyToStm(CFileStmSeq *pstm, CCheckSum *pxsum=NULL) =0;
    virtual ~CFileStmSeq() {}
protected:
    virtual BOOL FPreferredReceive(void) { return FALSE; }
    virtual BOOL FCopyFromStm(CFileStmSeq *pstm, CCheckSum *) { return FALSE; }
friend class CFileStmRandWithCopy;
};

class CFileStmRand : public CFileStmSeq
{
public:
    virtual BOOL FSeek(LARGE_INTEGER li) =0;
    virtual BOOL FSeek(LONG l) =0;
};

class CFileStmRandWithCopy : public CFileStmRand
{
public:
    virtual BOOL FCopyToStm(CFileStmSeq *pstm, CCheckSum *pxsum=NULL);
};

class CHandleFile : public CFileStmRandWithCopy
{
public:
    CHandleFile(HANDLE h)
    {
        m_hFile = h == INVALID_HANDLE_VALUE ? NULL : h;
    }
    virtual BOOL FIsOpen(void);
    virtual DWORD CbRead(DWORD cb, PBYTE pbBuf);
    virtual DWORD CbWrite(DWORD cb, const BYTE *pbBuf);
    virtual BOOL FSeek(LARGE_INTEGER li);
    virtual BOOL FSeek(LONG l);
    operator HANDLE() { return m_hFile; }
protected:
    HANDLE m_hFile;
};

class CDiskFileU : public CHandleFile
{
public:
    BOOL FReopen(DWORD dwFlags, DWORD dwSharing=0);
    void SetDeleteOnClose(BOOL f) { m_fDeleteOnClose = f; }
    virtual ~CDiskFileU();
protected:
    BOOL m_fDeleteOnClose;

    CDiskFileU(HANDLE hFile=NULL) : CHandleFile(hFile)
    {
        m_fDeleteOnClose = FALSE;
    }

    void DoOpen(DWORD dwFlags, DWORD dwSharing);
    void HandleDeleteOnClose(void);

    virtual const void *PvName(void) =0;
    virtual HANDLE DoCreateFile(const void *szName, DWORD dwAccess,
        DWORD dwSharing, LPSECURITY_ATTRIBUTES psa, DWORD dwDisp,
        DWORD dwFlags, HANDLE hT) =0;
    virtual void DoDeleteFile(const void *szName) =0;
};

class CDiskFile : public CDiskFileU
{
public:
    CDiskFile(LPCSTR szName, DWORD dwFlags=GENERIC_READ | GENERIC_WRITE,
        DWORD dwSharing=0);
    LPCSTR SzName(void) const { return m_szName; }
    virtual ~CDiskFile()
    {
        HandleDeleteOnClose();
    }

protected:
    char m_szName[MAX_PATH+1];

    CDiskFile(HANDLE hFile=NULL) : CDiskFileU(hFile)
    {
        m_szName[0] = 0;
    }

    virtual const void *PvName(void) { return (const void *)m_szName; };
    virtual HANDLE DoCreateFile(const void *szName, DWORD dwAccess,
        DWORD dwSharing, LPSECURITY_ATTRIBUTES psa, DWORD dwDisp,
        DWORD dwFlags, HANDLE hT)
    {
        return ::CreateFileA((LPCSTR)szName, dwAccess, dwSharing, psa, dwDisp,
            dwFlags, hT);
    }
    virtual void DoDeleteFile(const void *szName)
    {
        ::DeleteFileA((LPCSTR)szName);
    }
};

class CDiskFileW : public CDiskFileU
{
public:
    CDiskFileW(LPCWSTR wzName, DWORD dwFlags=GENERIC_READ | GENERIC_WRITE,
        DWORD dwSharing=0);
    LPCWSTR WzName(void) const { return m_wzName; }
    virtual ~CDiskFileW()
    {
        HandleDeleteOnClose();
    }

protected:
    WCHAR m_wzName[MAX_PATH+1];

    CDiskFileW(HANDLE hFile=NULL) : CDiskFileU(hFile)
    {
        m_wzName[0] = 0;
    }

    virtual const void *PvName(void) { return (const void *)m_wzName; };
    virtual HANDLE DoCreateFile(const void *wzName, DWORD dwAccess,
        DWORD dwSharing, LPSECURITY_ATTRIBUTES psa, DWORD dwDisp,
        DWORD dwFlags, HANDLE hT)
    {
        return ::CreateFileW((LPCWSTR)wzName, dwAccess, dwSharing, psa, dwDisp,
            dwFlags, hT);
    }
    virtual void DoDeleteFile(const void *wzName)
    {
        ::DeleteFileW((LPCWSTR)wzName);
    }
};

#endif // _FILESTM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\flcrypt.h ===
/*
 *
 * flcrypt.h
 *
 * CFloppyCrypt
 *
 */

#ifndef _FLCRYPT_H
#define _FLCRYPT_H

class CNCipherCrypt;

class CFloppyCrypt : public CSimpleCrypt
{
public:
    static CFloppyCrypt *PccImportKey(const CNCipherCrypt *);
    static CFloppyCrypt *PccCreate(BOOL fUnsecure=FALSE);
    BOOL FWrite(LPCSTR szID);
    BOOL FWritePub(void) const;
    BOOL FGetKeyId(LPBYTE pb) const;
    ~CFloppyCrypt() { Destroy(); }

private:
    struct XCKH {
        USHORT u1;
        USHORT u2;
        BYTE rgb[16];
        ULONG u3;
        ULONG cbPub;
        ULONG cbPri;
    };

    struct FLKH {
        USHORT sig;
        BYTE rgbLeadin[20];
        BYTE rgbDigest[20];
        BYTE rgbID[14];
    };

    struct OFLKH {
        USHORT sig;
        BYTE rgbLeadin[16];
        BYTE rgbID[14];
    };

    FLKH *m_pflkh;
    DWORD m_cb;

    BOOL FRead(BOOL fUnsecure);
    CFloppyCrypt(FLKH *pflkh, DWORD cb, PBYTE pbPubKey) :
        CSimpleCrypt(pbPubKey, NULL)
    {
        m_pflkh = pflkh;
        m_cb = cb;
    }

    void Destroy(void);

    static int CchGetPasswd(LPCSTR szPrompt, LPSTR sz, int cchMax);
    static const char szExtraPasswdBytes[];
};

#endif // _FLCRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\filestm.cpp ===
/*
 *
 * filestm.h
 *
 * file access classes
 *
 */

#include "precomp.h"

void CDiskFileU::DoOpen(DWORD dwFlags, DWORD dwSharing)
{
    DWORD dwDisp;
    DWORD dwAttr = (dwFlags & 0xFFFF) << 16;

    m_hFile = NULL;
    dwFlags &= GENERIC_READ | GENERIC_WRITE;
    if(dwFlags) {
        if(!(dwFlags & GENERIC_WRITE))
            dwSharing |= FILE_SHARE_READ;
        if(!(dwFlags & GENERIC_READ))
            dwDisp = CREATE_ALWAYS;
        else
            dwDisp = OPEN_EXISTING;
        m_hFile = DoCreateFile(PvName(), dwFlags, dwSharing, NULL, dwDisp,
            dwAttr, NULL);
        if(INVALID_HANDLE_VALUE == m_hFile)
            m_hFile = NULL;
    }
}

CDiskFile::CDiskFile(LPCSTR szName, DWORD dwFlags, DWORD dwSharing)
{
    strcpy(m_szName, szName);
    m_fDeleteOnClose = FALSE;
    DoOpen(dwFlags, dwSharing);
}

CDiskFileW::CDiskFileW(LPCWSTR wzName, DWORD dwFlags, DWORD dwSharing)
{
    wcscpy(m_wzName, wzName);
    m_fDeleteOnClose = FALSE;
    DoOpen(dwFlags, dwSharing);
}

BOOL CDiskFileU::FReopen(DWORD dwFlags, DWORD dwSharing)
{
    if(m_hFile)
        CloseHandle(m_hFile);
    DoOpen(dwFlags, dwSharing);
    return m_hFile != NULL;
}

BOOL CHandleFile::FIsOpen(void)
{
    return m_hFile != NULL;
}

DWORD CHandleFile::CbRead(DWORD cb, PBYTE pbBuf)
{
    DWORD cbRead;
    if(!m_hFile)
        return 0;
    return ReadFile(m_hFile, pbBuf, cb, &cbRead, NULL) ? cbRead : 0;
}

DWORD CHandleFile::CbWrite(DWORD cb, const BYTE *pbBuf)
{
    DWORD cbWritten;
    if(!m_hFile)
        return 0;
    return WriteFile(m_hFile, pbBuf, cb, &cbWritten, NULL) ? cbWritten : 0;
}

BOOL CHandleFile::FSeek(LARGE_INTEGER li)
{
    if(!m_hFile)
        return FALSE;
    return SetFilePointerEx(m_hFile, li, NULL, FILE_BEGIN);
}

BOOL CHandleFile::FSeek(LONG l)
{
    if(!m_hFile)
        return FALSE;
    return INVALID_SET_FILE_POINTER != SetFilePointer(m_hFile, l, NULL,
        FILE_BEGIN);
}

void CDiskFileU::HandleDeleteOnClose(void)
{
    if(m_fDeleteOnClose) {
        DoDeleteFile(PvName());
        m_fDeleteOnClose = FALSE;
    }
}

CDiskFileU::~CDiskFileU()
{
    if(m_hFile)
        CloseHandle(m_hFile);
    /* We can't delete from here; if the inherited class didn't clean up, this
     * will force a purecall reference */
    HandleDeleteOnClose();
}

BOOL CFileStmRandWithCopy::FCopyToStm(CFileStmSeq *pstm, CCheckSum *pxsum)
{
    BYTE rgb[8192];
    DWORD cb;

    if(pstm->FPreferredReceive())
        return pstm->FCopyFromStm(this, pxsum);

    if(!FIsOpen() || !pstm->FIsOpen())
        return FALSE;

    /* As long as we have data in our stream, write it out */
    for(;;) {
        cb = CbRead(sizeof rgb, rgb);
        if(cb == 0)
            return TRUE;
        if(pxsum)
            pxsum->SumBytes(rgb, cb);
        if(cb != pstm->CbWrite(cb, rgb))
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\flcrypt.cpp ===
/*
 *
 * flcrypt.cpp
 *
 * CFloppyCrypt
 *
 */

#include "precomp.h"

const char CFloppyCrypt::szExtraPasswdBytes[] =
    "EXTRAPASSWORDCHARACTERSATLEAST32";

int CFloppyCrypt::CchGetPasswd(LPCSTR szPrompt, LPSTR sz, int cchMax)
{
    int ich = 0;
    char ch;
    
    _cputs(szPrompt);
    for(;;) {
        ch = (char)_getch();
        switch(ch) {
        case 8:
        case 127:
            if(ich > 0)
                --ich;
            break;
        case 10:
        case 13:
            _putch('\r');
            _putch('\n');
            return ich;
        default:
            if(ich < cchMax)
                sz[ich++] = ch;
            else
                ++ich;
            break;
        }
    }
}

BOOL CFloppyCrypt::FRead(BOOL fUnsecure)
{
    HANDLE hFile;
    BYTE rgbBuf[8192];
    XCKH *pxckh;
    FLKH *pflkh;
    OFLKH *poflkh;
    PBYTE pbPub;
    PBYTE pbPri;
    PBYTE pbEncDigest;
    BOOL fRet = FALSE;
    char szPasswd[32];
    const char *pch;
    int ich;
    int cb;

    /* We're going to do unbuffered I/O, so we need an aligned buffer */
    pflkh = (FLKH *)(((ULONG)rgbBuf + 0xFFF) & ~0xFFF);

    /* Get the data */
    hFile = CreateFile(fUnsecure ? "A:\\KEYPAIR.XCK" : "A:\\KEYPAIR.FLK",
        GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_NO_BUFFERING, NULL);
    if(INVALID_HANDLE_VALUE == hFile)
        return FALSE;
    ReadFile(hFile, pflkh, 4096, &m_cb, NULL);
    CloseHandle(hFile);

    /* Decrypt the keys */
    if(fUnsecure)
        m_cb += sizeof *pflkh;
    m_pflkh = (FLKH *)malloc(m_cb);
    pxckh = (XCKH *)(m_pflkh + 1);
    if(fUnsecure) {
        memset(m_pflkh, 0, sizeof *m_pflkh);
        m_pflkh->sig = 0x4346;
        memcpy(m_pflkh->rgbID, "UNSECURE", 8);
        memcpy(m_pflkh + 1, pflkh, m_cb - sizeof *pflkh);
#if 0
    } else if(pflkh->sig == 0x4B46) {
        /* Handle old keys for conversion */
        memcpy(m_pflkh, pflkh, pflkh->rgbLeadin - (PBYTE)pflkh);
        ich = CchGetPasswd("Enter key password: ", szPasswd, sizeof szPasswd);
        pch = szExtraPasswdBytes;
        while(ich < sizeof szPasswd)
            szPasswd[ich++] = *pch++;
        if(!FComputeSessionKeyFromData((PBYTE)szPasswd, sizeof szPasswd))
            goto fatal;
        if(!FSessionDecrypt(pflkh->rgbLeadin, m_cb - (pflkh->rgbLeadin -
                (PBYTE)pflkh), m_pflkh->rgbLeadin))
            goto fatal;
        memset(m_pflkh->rgbLeadin, 0, sizeof m_pflkh->rgbLeadin);
#endif
    } else if(pflkh->sig == 0x4C46) {
        memset(m_pflkh, 0, sizeof *m_pflkh);
        m_pflkh->sig = 0x4346;
        poflkh = (OFLKH *)pflkh;
        ich = CchGetPasswd("Enter key password: ", szPasswd, sizeof szPasswd);
        pch = szExtraPasswdBytes;
        while(ich < sizeof szPasswd)
            szPasswd[ich++] = *pch++;
        if(!FComputeSessionKeyFromData((PBYTE)szPasswd, sizeof szPasswd))
            goto fatal;
        /* This gives us the key to decrypt the lead key */
        if(!FSessionEncrypt(poflkh->rgbLeadin, sizeof poflkh->rgbLeadin,
                poflkh->rgbLeadin))
            goto fatal;
        /* Now we can compute the message key */
        if(!FComputeSessionKeyFromData(poflkh->rgbLeadin,
                sizeof poflkh->rgbLeadin))
            goto fatal;
        if(!FSessionDecrypt(poflkh->rgbID, m_cb - (m_pflkh->rgbID -
                (PBYTE)m_pflkh), m_pflkh->rgbID))
            goto fatal;
    } else {
        if(pflkh->sig != 0x4346)
            goto fatal;
        memcpy(m_pflkh, pflkh, pflkh->rgbLeadin - (PBYTE)pflkh);
        ich = CchGetPasswd("Enter key password: ", szPasswd, sizeof szPasswd);
        pch = szExtraPasswdBytes;
        while(ich < sizeof szPasswd)
            szPasswd[ich++] = *pch++;
        if(!FComputeSessionKeyFromData((PBYTE)szPasswd, sizeof szPasswd))
            goto fatal;
        /* This gives us the key to decrypt the lead key */
        if(!FSessionEncrypt(pflkh->rgbLeadin, sizeof pflkh->rgbLeadin,
                m_pflkh->rgbLeadin))
            goto fatal;
        /* Now we can compute the message key */
        if(!FComputeSessionKeyFromData(m_pflkh->rgbLeadin,
                sizeof m_pflkh->rgbLeadin))
            goto fatal;
        if(!FSessionDecrypt(pflkh->rgbDigest, m_cb - (pflkh->rgbDigest -
                (PBYTE)pflkh), m_pflkh->rgbDigest))
            goto fatal;
        memset(m_pflkh->rgbLeadin, 0, sizeof m_pflkh->rgbLeadin);
        /* Verify the key digest */
        cb = sizeof *pxckh + pxckh->cbPub + pxckh->cbPri;
        if(cb + sizeof *m_pflkh > m_cb)
            goto fatal;
        if(!FComputeDigest((PBYTE)pxckh, cb, pflkh->rgbDigest))
            goto fatal;
        if(memcmp(pflkh->rgbDigest, m_pflkh->rgbDigest,
                sizeof m_pflkh->rgbDigest))
            goto fatal;
        memset(m_pflkh->rgbDigest, 0, sizeof m_pflkh->rgbDigest);
    }

    if(pxckh->u1 != 1)
        goto fatal;
    if(m_cb < sizeof *pxckh + sizeof *pflkh)
        goto fatal;
    if(m_cb < sizeof *pxckh + sizeof *pflkh + pxckh->cbPub + pxckh->cbPri)
        goto fatal;

    /* Select in the key */
    pbPub = (PBYTE)(pxckh + 1);
    pbPri = pxckh->cbPri > 32 ? pbPub + pxckh->cbPub : NULL;
    SetKeys(pbPub, pbPri);

    /* Validate the key pair */
    if(pbPri) {
        pbEncDigest = (PBYTE)_alloca(CbGetEncryptedDigestSize());
        if(!FComputeEncryptedDigest(rgbBuf, sizeof rgbBuf, pbEncDigest) ||
                !FVerifyEncryptedDigest(rgbBuf, sizeof rgbBuf, pbEncDigest))
            goto fatal;
    }

    /* At this point, we're good to go */
    fRet = TRUE;

fatal:
    memset(rgbBuf, 0, sizeof rgbBuf);
    memset(szPasswd, 0, sizeof szPasswd);
    DestroySessionKey();
    if(!fRet)
        Destroy();
    return fRet;
}

CFloppyCrypt *CFloppyCrypt::PccCreate(BOOL fUnsecure)
{
    CFloppyCrypt *pcc = new CFloppyCrypt(NULL, 0, NULL);
    if(pcc->FRead(fUnsecure))
        return pcc;
    delete pcc;
    return FALSE;
}

BOOL CFloppyCrypt::FWrite(LPCSTR szID)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BYTE rgbBuf[8192];
    XCKH *pxckh;
    FLKH *pflkh;
    BOOL fRet = FALSE;
    char szPasswd1[32];
    char szPasswd2[32];
    BYTE rgbTempID[14];
    const char *pch;
    int ich;
    DWORD cb;
    BOOL fT;
    CRandom rand;

    if(!m_pflkh)
        return FALSE;

    /* We're going to do unbuffered I/O, so we need an aligned buffer */
    pflkh = (FLKH *)(((ULONG)rgbBuf + 0xFFF) & ~0xFFF);
    memset(pflkh, 0, 4096);

    /* Prepare the header */
    pflkh->sig = 0x4346;

    /* Get the password */
    ich = CchGetPasswd("Enter new key password: ", szPasswd1, sizeof szPasswd1);
    if(ich < 8) {
        fprintf(stderr, "Passwords must be at least 8 chars\n");
        goto fatal;
    }
    if(ich != CchGetPasswd("Enter it again: ", szPasswd2, sizeof szPasswd2) ||
        memcmp(szPasswd1, szPasswd2, ich))
    {
        fprintf(stderr, "Passwords do not match\n");
        goto fatal;
    }

    /* Digest the key */
    pxckh = (XCKH *)(m_pflkh + 1);
    cb = sizeof *pxckh + pxckh->cbPub + pxckh->cbPri;
    if(cb + sizeof *m_pflkh > m_cb)
        goto fatal;
    if(!FComputeDigest((PBYTE)pxckh, cb, m_pflkh->rgbDigest))
        goto fatal;

    /* Set up the password key */
    pch = szExtraPasswdBytes;
    while(ich < sizeof szPasswd1)
        szPasswd1[ich++] = *pch++;
    if(!FComputeSessionKeyFromData((PBYTE)szPasswd1, sizeof szPasswd1))
        goto fatal;

    /* Set up the lead key */
    rand.RandBytes(pflkh->rgbLeadin, sizeof pflkh->rgbLeadin);
    if(!FSessionEncrypt(pflkh->rgbLeadin, sizeof pflkh->rgbLeadin,
            m_pflkh->rgbLeadin))
        goto fatal;

    /* Set up the message key */
    if(!FComputeSessionKeyFromData(m_pflkh->rgbLeadin, sizeof m_pflkh->rgbLeadin))
        goto fatal;

    /* Set the ID and encrypt the data */
    memcpy(rgbTempID, m_pflkh->rgbID, sizeof pflkh->rgbID);
    memset(m_pflkh->rgbID, 0, sizeof m_pflkh->rgbID);
    strncpy((LPSTR)m_pflkh->rgbID, szID, sizeof m_pflkh->rgbID);
    fT = FSessionEncrypt(m_pflkh->rgbDigest, m_cb - (m_pflkh->rgbDigest -
        (PBYTE)m_pflkh), pflkh->rgbDigest);
    
    /* Restore the old ID */
    memcpy(m_pflkh->rgbID, rgbTempID, sizeof pflkh->rgbID);
    memset(m_pflkh->rgbDigest, 0, sizeof m_pflkh->rgbDigest);

    if(!fT)
        goto fatal;

    /* Now write the file */
    hFile = CreateFile("A:\\KEYPAIR.FLK", GENERIC_WRITE, 0, NULL,
        CREATE_ALWAYS, FILE_FLAG_NO_BUFFERING, NULL);
    if(INVALID_HANDLE_VALUE == hFile)
        goto fatal;
    if(!WriteFile(hFile, pflkh, 4096, &cb, NULL))
        cb = 0;
    if(cb != 4096)
        goto fatal;
    /* We'll keep the extra data until I can figure out how to truncate it
     * without buffering */
#if 0
    if(INVALID_SET_FILE_POINTER == SetFilePointer(hFile, m_cb, NULL,
            FILE_BEGIN) || !SetEndOfFile(hFile))
        goto fatal;
#endif

    /* We've succeeded */
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;
    fRet = TRUE;

fatal:
    if(INVALID_HANDLE_VALUE != hFile) {
        CloseHandle(hFile);
        DeleteFile("A:\\KEYPAIR.FLK");
    }
    memset(szPasswd1, 0, sizeof szPasswd1);
    memset(szPasswd2, 0, sizeof szPasswd2);
    memset(rgbBuf, 0, sizeof rgbBuf);
    memset(m_pflkh->rgbLeadin, 0, sizeof m_pflkh->rgbLeadin);
    memset(m_pflkh->rgbDigest, 0, sizeof m_pflkh->rgbDigest);
    DestroySessionKey();
    return fRet;
}

BOOL CFloppyCrypt::FWritePub(void) const
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BYTE rgbBuf[8192];
    XCKH *pxckh;
    XCKH *pxckhOut;
    BOOL fRet = FALSE;
    const char *pch;
    int ich;
    DWORD cb;
    BOOL fT;

    if(!m_pflkh)
        return FALSE;

    /* We're going to do unbuffered I/O, so we need an aligned buffer */
    pxckhOut = (XCKH *)(((ULONG)rgbBuf + 0xFFF) & ~0xFFF);
    memset(pxckhOut, 0, 4096);

    /* Copy only as much data as is in the public key */
    pxckh = (XCKH *)(m_pflkh + 1);
    memcpy(pxckhOut, pxckh, sizeof *pxckh + pxckh->cbPub);

    /* Mark the private key as 16 bytes of zero */
    pxckhOut->cbPri = 16;

    /* Now write the file */
    hFile = CreateFile("A:\\PUBKEY.XCK", GENERIC_WRITE, 0, NULL,
        CREATE_ALWAYS, FILE_FLAG_NO_BUFFERING, NULL);
    if(INVALID_HANDLE_VALUE == hFile)
        goto fatal;
    if(!WriteFile(hFile, pxckhOut, 4096, &cb, NULL))
        cb = 0;
    if(cb != 4096)
        goto fatal;
    /* We'll keep the extra data until I can figure out how to truncate it
     * without buffering */

    /* We've succeeded */
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;
    fRet = TRUE;

fatal:
    if(INVALID_HANDLE_VALUE != hFile) {
        CloseHandle(hFile);
        DeleteFile("A:\\PUBKEY.XCK");
    }
    memset(rgbBuf, 0, sizeof rgbBuf);
    return fRet;
}

void CFloppyCrypt::Destroy(void)
{
    SetKeys(NULL, NULL);
    if(m_pflkh) {
        memset(m_pflkh, 0, m_cb);
        free(m_pflkh);
    }
    m_pflkh = NULL;
}

BOOL CFloppyCrypt::FGetKeyId(LPBYTE pb) const
{
    if(!m_pflkh)
        return FALSE;
    memcpy(pb, m_pflkh->rgbID, sizeof m_pflkh->rgbID);
    return TRUE;
}

CFloppyCrypt *CFloppyCrypt::PccImportKey(const CNCipherCrypt *pcc)
{
    XCKH *pxckh;
    FLKH *pflkh;
    int cb;
    BSAFE_PUB_KEY *pbpk;

    /* Get the public key */
    pbpk = (BSAFE_PUB_KEY *)pcc->PbGetPublicKey();
    if(!pbpk || pbpk->magic != RSA1)
        return NULL;

    /* Allocate some space for our version of the data */
    cb = sizeof *pbpk + pbpk->keylen;
    pflkh = (FLKH *)malloc(cb + sizeof *pflkh + sizeof *pxckh + 16);
    memset(pflkh, 0, sizeof *pflkh);
    pxckh = (XCKH *)(pflkh + 1);
    memset(pxckh, 0, sizeof *pxckh);

    /* Copy in the public key */
    pxckh->cbPub = cb;
    memcpy(pxckh + 1, pbpk, cb);

    /* Set the private key as 16 bytes of zero */
    pxckh->cbPri = 16;
    memset((PBYTE)(pxckh + 1) + cb, 0, 16);

    /* Set up the rest of the key headers */
    pxckh->u1 = 1;
    pxckh->u2 = (USHORT)pbpk->bitlen;

    /* And create our object */
    return new CFloppyCrypt(pflkh, cb + sizeof *pflkh + sizeof *pxckh + 16,
        (PBYTE)pbpk);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\gdfdir.cpp ===
/*
 *
 * gdfdir.cpp
 *
 * Manipulate GDF directories
 *
 */

#include "precomp.h"

GDIR::GDIR(CFileStmSeq *pstm, DWORD cb, LPCSTR szName)
{
    m_szName = szName ? _strdup(szName) : NULL;
    m_pbDirData = (PBYTE)malloc(m_cbSize = cb);
    if(!pstm || pstm->CbRead(cb, m_pbDirData) != cb) {
        free(m_pbDirData);
        m_pbDirData = NULL;
    }
    m_pgdeGet = NULL;
}

GDIR::GDIR(PBYTE pb, DWORD cb, LPCSTR szName)
{
    m_szName = szName ? _strdup(szName) : NULL;
    m_pbDirData = pb;
    m_cbSize = cb;
}

BOOL GDIR::FWriteToStm(CFileStmSeq *pstm) const
{
    DWORD cb = ((m_cbSize + 2047) & ~2047) - m_cbSize;
    BYTE rgb[2048];

    if(pstm->CbWrite(m_cbSize, m_pbDirData) != m_cbSize)
        return FALSE;
    if(cb) {
        memset(rgb, -1, cb);
        if(pstm->CbWrite(cb, rgb) != cb)
            return FALSE;
    }
    return TRUE;
}

void GDIR::ResetWalk(void)
{
    if(m_cbSize) {
        m_pgdeGet = (PGDF_DIRECTORY_ENTRY)m_pbDirData;
        if(m_pgdeGet && (WORD)m_pgdeGet->LeftEntryIndex == (WORD)-1)
            m_pgdeGet = NULL;
    } else
        m_pgdeGet = NULL;
}


PGDF_DIRECTORY_ENTRY GDIR::PgdeGetNextEntry(void)
{
    PGDF_DIRECTORY_ENTRY pgde = m_pgdeGet;
    DWORD cb;

    if(!pgde)
        return pgde;
    cb = pgde->FileNameLength + ((PBYTE)pgde->FileName - (PBYTE)pgde);
    cb = (cb + 3) & ~3;
    m_pgdeGet = (PGDF_DIRECTORY_ENTRY)((PBYTE)pgde + cb);
    cb = (PBYTE)m_pgdeGet - m_pbDirData;
    if(cb >= m_cbSize)
        m_pgdeGet = NULL;
    else if((WORD)m_pgdeGet->LeftEntryIndex == (WORD)-1) {
        cb = (cb + 2048) & ~2047;
        if(cb >= m_cbSize)
            m_pgdeGet = NULL;
        else
            m_pgdeGet = (PGDF_DIRECTORY_ENTRY)(m_pbDirData + cb);
    }

    return pgde;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\crypt.h ===
/*
 *
 * crypt.h
 *
 * CCryptProvider and related interfaces
 *
 */

#ifndef _CRYPT_H
#define _CRYPT_H

#include <sha.h>

class CCryptContainer
{
public:
    virtual BOOL FComputeDigest(const BYTE *pb, DWORD cb, LPBYTE pbDigest) const =0;
    virtual BOOL FComputeEncryptedDigest(const BYTE *pb, DWORD cb,
        LPBYTE pbDigest) const =0;
    virtual BOOL FStartProgressiveHash(void) =0;
    virtual BOOL FProgressiveHashData(const BYTE *pb, DWORD cb) =0;
    virtual BOOL FComputeProgressiveHash(LPBYTE pbDigest) const =0;
    virtual BOOL FEncryptProgressiveHash(LPBYTE pbDigest) const =0;
    virtual int CbGetDigestSize(void) const =0;
    virtual int CbGetEncryptedDigestSize(void) const =0;
    virtual BOOL FVerifyEncryptedDigest(const BYTE *pb, DWORD cb,
        const BYTE *pbSigned) const =0;
    virtual BOOL FVerifyEncryptedProgressiveHash(const BYTE *pbSigned) const =0;
    virtual const BYTE *PbGetPublicKey(void) const =0;
    virtual BOOL FComputeSessionKeyFromData(const BYTE *pb, DWORD cb, DWORD cbit=0) =0;
    virtual BOOL FSessionEncrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const =0;
    virtual BOOL FSessionDecrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const =0;
    virtual void DestroySessionKey(void) =0;
    virtual ~CCryptContainer() {}
};

class CSimpleCrypt : public CCryptContainer
{
public:
    CSimpleCrypt(void)
    {
        Setup();
        SetKeys(NULL, NULL);
    }
    virtual BOOL FComputeDigest(const BYTE *pb, DWORD cb, LPBYTE pbDigest) const;
    virtual BOOL FComputeEncryptedDigest(const BYTE *pb, DWORD cb,
        LPBYTE pbDigest) const;
    virtual BOOL FStartProgressiveHash(void);
    virtual BOOL FProgressiveHashData(const BYTE *pb, DWORD cb);
    virtual BOOL FComputeProgressiveHash(LPBYTE pbDigest) const;
    virtual BOOL FEncryptProgressiveHash(LPBYTE pbDigest) const;
    virtual int CbGetDigestSize(void) const;
    virtual int CbGetEncryptedDigestSize(void) const;
    virtual BOOL FVerifyEncryptedDigest(const BYTE *pb, DWORD cb,
        const BYTE *pbSigned) const;
    virtual BOOL FVerifyEncryptedProgressiveHash(const BYTE *pbSigned) const;
    virtual const BYTE *PbGetPublicKey(void) const { return m_pbPublicKey; }
    virtual BOOL FComputeSessionKeyFromData(const BYTE *pb, DWORD cb, DWORD cbit=0);
    virtual BOOL FSessionEncrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const;
    virtual BOOL FSessionDecrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const;
    virtual void DestroySessionKey(void);
    virtual ~CSimpleCrypt() { DestroySessionKey(); }
protected:
    CSimpleCrypt(const BYTE *pbPublic, const BYTE *pbPrivate)
    {
        Setup();
        SetKeys(pbPublic, pbPrivate);
    }
    void Setup(void);
    void SetKeys(const BYTE *pbPublic, const BYTE *pbPrivate);
private:
    const BYTE *m_pbPublicKey;
    const BYTE *m_pbPrivateKey;
    BYTE *m_pbSessionKey;
    int m_cbSessionKey;
    A_SHA_CTX m_sha;
};

class CDevkitCrypt : public CSimpleCrypt
{
public:
    CDevkitCrypt(void) : CSimpleCrypt(rgbPublicKey, rgbPrivateKey) {}
private:
    static const BYTE rgbPrivateKey[];
    static const BYTE rgbPublicKey[];
};

class CSHACrypt : public CSimpleCrypt
{
public:
    CSHACrypt(void) : CSimpleCrypt(NULL, NULL) {}
    virtual BOOL FComputeDigest(const BYTE *pb, DWORD cb, LPBYTE pbDigest) const;
};

class CRetailCrypt : public CSimpleCrypt
{
public:
    CRetailCrypt(void);
private:
    BYTE m_rgbPublicKey[284];
    static const BYTE rgbLeftHalf[];
    static const BYTE rgbRightHalf[];
};
#endif // _CRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\gdfdir.h ===
/*
 *
 * gdfdir.h
 *
 * Manipulate GDF directories
 *
 */

#ifndef _GDFDIR_H
#define _GDFDIR_H

#include <gdformat.h>

class GDIR {
public:
    GDIR(CFileStmSeq *pstm, DWORD cb, LPCSTR szName=NULL);
    GDIR(PBYTE pb, DWORD cb, LPCSTR szName=NULL);
    ~GDIR()
    {
        if(m_pbDirData)
            free(m_pbDirData);
        if(m_szName)
            free((PVOID)m_szName);
    }

    DWORD CbSize(void) const { return m_cbSize; }
    BOOL FGotData(void) const { return m_pbDirData != NULL; }
    BOOL FWriteToStm(CFileStmSeq *pstm) const;
    PGDF_DIRECTORY_ENTRY PgdeGetNextEntry(void);
    void ResetWalk(void);
    LPCSTR SzName(void) const { return m_szName ? m_szName : ""; }

private:
    PBYTE m_pbDirData;
    DWORD m_cbSize;
    LPCSTR m_szName;

    PGDF_DIRECTORY_ENTRY m_pgdeGet;
};

#endif // _GDFDIR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\lblprint.h ===
/*
 *
 * lblprint.h
 *
 * Label printing
 *
 */

#ifndef _LBLPRINT_H
#define _LBLPRINT_H

class CLabelPrinter
{
public:
    static CLabelPrinter *PprCreate(LPCSTR szName, int nOff=0);
    BOOL FStartLabel(void);
    void PrintLine(LPCSTR szFormat, ...);
    void EndLabel(void);
    ~CLabelPrinter();
private:
    CLabelPrinter(void) {}

    HDC m_hdc;
    HFONT m_hfont;
    LPSTR m_szName;
    DEVMODE *m_pdm;
    int m_iLine;
    POINT m_ptOff;
    int m_yPitch;
    int m_yOffBase;
};

#endif // _LBLPRINT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\lblprint.cpp ===
/*
 *
 * lblprint.h
 *
 * Label printing
 *
 */

#include "precomp.h"

CLabelPrinter *CLabelPrinter::PprCreate(LPCSTR szName, int nOff)
{
    CLabelPrinter *ppr;
    HANDLE hpr;
    DEVMODE *pdm;
    int cb;

    /* Get the document properties for this printer */
    if(!OpenPrinter((LPSTR)szName, &hpr, NULL))
        return NULL;
    cb = DocumentProperties(NULL, hpr, NULL, NULL, NULL, 0);
    if(cb <= 0)
        goto noprop0;
    pdm = (DEVMODE *)malloc(cb);
    if(DocumentProperties(NULL, hpr, NULL, pdm, NULL, DM_OUT_BUFFER) < 0)
        goto noprop1;
    ClosePrinter(hpr);

    /* Set up to run in landscape mode */
    pdm->dmFields = DM_ORIENTATION;
    pdm->dmOrientation = DMORIENT_LANDSCAPE;

    /* Remember what we've got */
    ppr = new CLabelPrinter;
    ppr->m_szName = _strdup(szName);
    ppr->m_pdm = pdm;
    ppr->m_yOffBase = nOff;
    return ppr;
noprop1:
    free(pdm);
noprop0:
    ClosePrinter(hpr);
    return NULL;
}

CLabelPrinter::~CLabelPrinter()
{
    if(m_hdc)
        EndLabel();
    if(m_hfont)
        DeleteObject(m_hfont);
    if(m_szName)
        free(m_szName);
    if(m_pdm)
        free(m_pdm);
}

BOOL CLabelPrinter::FStartLabel(void)
{
    DOCINFO di;
    int yPitch;

    m_hdc = CreateDC("WINSPOOL", m_szName, NULL, m_pdm);
    if(!m_hdc)
        return FALSE;

    m_iLine = 0;
    yPitch = GetDeviceCaps(m_hdc, LOGPIXELSY) / 6;
    /* See if we can figure out how big the page is */
    m_ptOff.x = GetDeviceCaps(m_hdc, PHYSICALWIDTH);
    m_ptOff.y = GetDeviceCaps(m_hdc, PHYSICALHEIGHT);
    DPtoLP(m_hdc, &m_ptOff, 1);
    m_ptOff.x = GetDeviceCaps(m_hdc, PHYSICALOFFSETX);
    m_ptOff.y = GetDeviceCaps(m_hdc, PHYSICALOFFSETY);
    DPtoLP(m_hdc, &m_ptOff, 1);

    /* If we have no cached font, or if the cached font is the wrong size,
     * we need to build a font that we'll be able to use */
    if(m_hfont && yPitch != m_yPitch) {
        DeleteObject(m_hfont);
        goto newfont;
    }
    if(!m_hfont) {
newfont:
        m_hfont = CreateFont(yPitch, 0, 0, 0, 0, FALSE, FALSE, FALSE,
            ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
            DEFAULT_QUALITY, DEFAULT_PITCH, "Helvetica");
    }
    if(!m_hfont) {
        DeleteDC(m_hdc);
        return FALSE;
    }
    m_yPitch = yPitch;
    SelectObject(m_hdc, m_hfont);

    memset(&di, 0, sizeof di);
    di.cbSize = sizeof di;
    di.lpszDocName = "LABEL";
    if(StartDoc(m_hdc, &di) <= 0) {
        DeleteDC(m_hdc);
        return FALSE;
    }
    if(StartPage(m_hdc) <= 0) {
        EndDoc(m_hdc);
        DeleteDC(m_hdc);
        return FALSE;
    }
    return TRUE;
}

void CLabelPrinter::PrintLine(LPCSTR szFormat, ...)
{
    char *pchStart, *pchEnd;
    char szStr[4096];
    va_list va;

    va_start(va, szFormat);
    _vsnprintf(szStr, sizeof szStr, szFormat, va);
    va_end(va);
    szStr[sizeof szStr - 1] = 0;
    for(pchStart = szStr; *pchStart; pchStart = pchEnd) {
        for(pchEnd = pchStart; *pchEnd && *pchEnd != '\n'; ++pchEnd);
        TextOut(m_hdc, m_ptOff.x, m_ptOff.y + m_yOffBase +
            (m_iLine + 1) * m_yPitch, pchStart, pchEnd - pchStart);
        while(*pchEnd == '\n') {
            ++m_iLine;
            ++pchEnd;
        }
    }
}

void CLabelPrinter::EndLabel(void)
{
    if(m_hdc) {
        EndPage(m_hdc);
        EndDoc(m_hdc);
        DeleteDC(m_hdc);
        m_hdc = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\ini.h ===
/*
 *
 * ini.h
 *
 * CIniFile
 *
 */

#ifndef _INI_H
#define _INI_H

#include <propbag.h>
#include <xsum.h>

class CIniBag : public CPropBag <CVarBag>
{
public:
    CIniBag() { m_pfnRemovePv = RemovePv; }
    CVarBag *PbagGetSection(LPCSTR);
protected:
    virtual PVOID PvAdd(PVOID pv) const
    {
        return pv;
    }
    static void RemovePv(PVOID pv)
    {
        delete (CVarBag *)pv;
    }
};

class CIniFile
{
public:
    CIniFile(void) : m_pbag(NULL) {}
    ~CIniFile() { Empty(); }

    void Empty(void)
    {
        if(m_pbag) {
            delete m_pbag;
            m_pbag = NULL;
        }
    }

    BOOL FReadFile(LPCSTR szFileName, BOOL fRequireXsum);
    BOOL FWriteFile(LPCSTR szFileName);
    CIniBag *PbagRoot(void)
    {
        if(!m_pbag)
            m_pbag = new CIniBag;
        return m_pbag;
    }
    DWORD DwXsum(void) const { return m_cxc.DwFinalSum(); }

private:
    CCheckSum m_cxc;
    CIniBag *m_pbag;

    void CalcXsum(void);
    static const LPCSTR szRootSection;
    static const LPCSTR szCRCKey;
};
  
#endif // _INI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\ini.cpp ===
/*
 *
 * ini.h
 *
 * CIniFile
 *
 */

#include "precomp.h"

const LPCSTR CIniFile::szRootSection = ".";
const LPCSTR CIniFile::szCRCKey = "FileCRC";

CVarBag *CIniBag::PbagGetSection(LPCSTR sz)
{
    CVarBag *pbag = FindProp(sz);
    if(!pbag) {
        pbag = new CVarBag;
        if(!FAddProp(sz, pbag)) {
            delete pbag;
            pbag = NULL;
        }
    }
    return pbag;
}

BOOL CIniFile::FReadFile(LPCSTR szName, BOOL fRequireXsum)
{
    FILE *pfl;
    char szLine[256];
    char *pchKey;
    char *pchValue;
    char *pch;
    CVarBag *pbvpCur;
    VPR vpT;
    PVOID espSav;

    Empty();
    pfl = fopen(szName, "r");
    if(!pfl)
        return FALSE;

    m_pbag = new CIniBag;
    _asm mov espSav, esp

    /* Create the root section */
    pbvpCur = new CVarBag;
    m_pbag->FAddProp(szRootSection, pbvpCur);

    /* Now read the file */
    while(fgets(szLine, sizeof szLine, pfl)) {
        for(pchKey = szLine; isspace(*pchKey); ++pchKey);
        if(*pchKey == '[') {
            /* New section */
            pch = strchr(++pchKey, ']');
            if(pch) {
                *pch = 0;
                /* We coalesce sections with the same name */
                pbvpCur = m_pbag->FindProp(pchKey);
                if(!pbvpCur) {
                    pbvpCur = new CVarBag;
                    m_pbag->FAddProp(pchKey, pbvpCur);
                }
            }
        } else {
            /* Value */
            pchValue = strchr(pchKey, '=');
            if(!pchValue || pchValue == pchKey)
                /* Bogus line */
                continue;
            *pchValue = ' ';
            while(isspace(*pchValue))
                --pchValue;
            *++pchValue = 0;
            while(isspace(*++pchValue));

            if(*pchValue == '"') {
                /* This is a string */
                _asm mov esp, espSav
                vpT.vpType = vpSz;
                vpT.sz = pch = (LPSTR)_alloca(strlen(pchValue + 1));
                /* Copy the string up to the final quote */
                while(*++pchValue && *pchValue != '"') {
                    if(*pchValue == '\\')
                        ++pchValue;
                    *pch++ = *pchValue;
                }
                *pch = 0;
            } else
                /* Assume a dword, unless the parse fails */
                vpT.vpType = 1 == sscanf(pchValue, "%i", &vpT.dw) ?
                    vpDw : vpNone;

            /* Now add this guy to the tree */
            pbvpCur->FAddProp(pchKey, &vpT);
            vpT.vpType = vpNone;
        }
    }

    fclose(pfl);

    /* If there was a checksum in the file, verify it */
    pbvpCur = m_pbag->FindProp(szRootSection);
    if(pbvpCur) {
        VPR *pvpCRC = pbvpCur->FindProp(szCRCKey);
        if(pvpCRC && pvpCRC->vpType == vpDw) {
            CalcXsum();
            if(m_cxc.DwFinalSum() == pvpCRC->dw)
                return TRUE;
        }
    }
    if(fRequireXsum) {
        /* We needed the checksum but we didn't find one we liked */
        Empty();
        return FALSE;
    }

    return TRUE;
}

void CIniFile::CalcXsum(void)
{
    LPCSTR *rgszSections;
    CVarBag **rgpbvp;
    int cbvp;
    int ibvpRoot;
    PVOID espSav;

    m_cxc.Reset();

    /* Get the section list and move the root section to the front, if
     * present */
    cbvp = m_pbag->Cprop();
    rgpbvp = (CVarBag **)_alloca(sizeof(PVOID) * cbvp);
    rgszSections = (LPCSTR *)_alloca(sizeof(PVOID) * cbvp);
    m_pbag->GetProps(rgszSections, rgpbvp);
    if(!m_pbag->FindProp(szRootSection, &ibvpRoot))
        ibvpRoot = -1;
    else if(ibvpRoot > 0) {
        CVarBag *pbvpRoot = rgpbvp[ibvpRoot];
        LPCSTR szRoot = rgszSections[ibvpRoot];

        memmove(rgpbvp + 1, rgpbvp, sizeof(PVOID) * ibvpRoot);
        memmove(rgszSections + 1, rgszSections, sizeof(PVOID) * ibvpRoot);
        rgpbvp[0] = pbvpRoot;
        rgszSections[0] = szRoot;
        ibvpRoot = 0;
    }

    _asm mov espSav, esp

    /* Now enumerate every section and print out its contents */
    for(int ibvp = 0; ibvp < cbvp; ++ibvp) {
        CVarBag *pbvp = rgpbvp[ibvp];
        int cvp = pbvp->Cprop();
        int ivpCRC;
        LPCSTR *rgszKeys;
        VPR **rgpvpValues;
        PVOID espT;
        int cchKey;
        int cchValue;
        char *pchT;
        LPSTR szValue;

        _asm mov esp, espSav
        rgszKeys = (LPCSTR *)_alloca(sizeof(LPCSTR) * cvp);
        rgpvpValues = (VPR **)_alloca(sizeof(LPCSTR) * cvp);
        _asm mov espT, esp

        pbvp->GetProps(rgszKeys, rgpvpValues);
        if(ibvp != ibvpRoot || !pbvp->FindProp(szCRCKey, &ivpCRC))
            ivpCRC = -1;

        /* If not the root section, CRC the section name */
        if(ibvp != ibvpRoot) {
            cchKey = strlen(rgszSections[ibvp]);
            _asm mov esp, espT
            pchT = (char *)_alloca(cchKey + 5);
            sprintf(pchT, "\n[%s]\n", rgszSections[ibvp]);
            m_cxc.SumBytes((LPBYTE)pchT, cchKey + 4);
        }

        /* Enumerate all the key/value pairs and checksum their contents */
        for(int ivp = 0; ivp < cvp; ++rgszKeys, ++rgpvpValues, ++ivp) {
            if(ivp != ivpCRC) {
                _asm mov esp, espT;
                cchKey = strlen(*rgszKeys);
                switch(rgpvpValues[0]->vpType) {
                case vpSz:
                    cchValue = 2 + strlen(rgpvpValues[0]->sz);
                    szValue = (LPSTR)_alloca(cchValue) + 1;
                    sprintf(szValue, "\"%s\"", rgpvpValues[0]->sz);
                    break;
                case vpDw:
                    cchValue = 10;
                    szValue = (LPSTR)_alloca(cchValue) + 1;
                    sprintf(szValue, "0x%08X", rgpvpValues[0]->dw);
                    break;
                default:
                    cchValue = 0;
                    break;
                }
                pchT = (char *)_alloca(cchKey + cchValue + 5);
                if(cchValue) {
                    sprintf(pchT, "%s = %s\n", *rgszKeys, szValue);
                    m_cxc.SumBytes((LPBYTE)pchT, cchKey + cchValue + 4);
                } else {
                    sprintf(pchT, "%s =\n", *rgszKeys);
                    m_cxc.SumBytes((LPBYTE)pchT, cchKey + 3);
                }
            }
        }
    }
}

BOOL CIniFile::FWriteFile(LPCSTR szName)
{
    FILE *pfl;
    LPCSTR *rgszSections;
    CVarBag **rgpbvp;
    int cbvp;
    int ibvpRoot;
    PVOID espSav;

    if(!m_pbag)
        /* Call this an empty bag */
        m_pbag = new CIniBag;

    pfl = fopen(szName, "w");
    if(!pfl)
        return FALSE;

    /* Get the section list.  If there is no root section make one; if there
     * is a root section, move it to the front */
    cbvp = m_pbag->Cprop();
    if(!m_pbag->FindProp(szRootSection, &ibvpRoot)) {
        ++cbvp;
        ibvpRoot = -1;
    }
    rgpbvp = (CVarBag **)_alloca(sizeof(PVOID) * cbvp);
    rgszSections = (LPCSTR *)_alloca(sizeof(PVOID) * cbvp);
    m_pbag->GetProps(rgszSections + (ibvpRoot < 0), rgpbvp + (ibvpRoot < 0));
    if(ibvpRoot < 0) {
        rgszSections[0] = szRootSection;
        rgpbvp[0] = new CVarBag;
        m_pbag->FAddProp(rgszSections[0], rgpbvp[0]);
    } else if(ibvpRoot > 0) {
        CVarBag *pbvpRoot = rgpbvp[ibvpRoot];
        LPCSTR szRoot = rgszSections[ibvpRoot];

        memmove(rgpbvp + 1, rgpbvp, sizeof(PVOID) * ibvpRoot);
        memmove(rgszSections + 1, rgszSections, sizeof(PVOID) * ibvpRoot);
        rgpbvp[0] = pbvpRoot;
        rgszSections[0] = szRoot;
    }

    /* Stash the checksum value in the bag */
    CalcXsum();
    VPR vpXsum(m_cxc.DwFinalSum());
    if(!rgpbvp[0]->FChangeProp(szCRCKey, &vpXsum))
        rgpbvp[0]->FAddProp(szCRCKey, &vpXsum);

    _asm mov espSav, esp

    /* Now enumerate every section and print out its contents */
    for(int ibvp = 0; ibvp < cbvp; ++ibvp) {
        CVarBag *pbvp = rgpbvp[ibvp];
        int cvp = pbvp->Cprop();
        LPCSTR *rgszKeys;
        VPR **rgpvpValues;

        _asm mov esp, espSav
        rgszKeys = (LPCSTR *)_alloca(sizeof(LPCSTR) * cvp);
        rgpvpValues = (VPR **)_alloca(sizeof(LPCSTR) * cvp);
        pbvp->GetProps(rgszKeys, rgpvpValues);
        if(ibvp == 0) {
            /* Make sure the CRC key is first in the list */
            int ivpCRC;
            if(pbvp->FindProp(szCRCKey, &ivpCRC) && ivpCRC > 0) {
                VPR *pvpCRC = rgpvpValues[ivpCRC];

                memmove(rgszKeys + 1, rgszKeys, sizeof(LPCSTR) * ivpCRC);
                memmove(rgpvpValues + 1, rgpvpValues, sizeof(LPCSTR) * ivpCRC);
                rgszKeys[0] = szCRCKey;
                rgpvpValues[0] = pvpCRC;
            }
        } else
            /* Need a section name */
            fprintf(pfl, "\n[%s]\n", rgszSections[ibvp]);

        /* Print all the key/value pairs */
        for(; cvp--; ++rgszKeys, ++rgpvpValues) {
            switch(rgpvpValues[0]->vpType) {
            case vpSz:
                fprintf(pfl, "%s = \"%s\"\n", *rgszKeys, rgpvpValues[0]->sz);
                break;
            case vpDw:
                fprintf(pfl, "%s = 0x%08X\n", *rgszKeys, rgpvpValues[0]->dw);
                break;
            default:
                fprintf(pfl, "%s =\n", *rgszKeys);
                break;
            }
        }
    }

    fclose(pfl);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\propbag.cpp ===
/*
 *
 * propbag.cpp
 *
 * CPropertyBag
 *
 */

#include "precomp.h"

const DWORD CPropertyBag::m_dcpropInc = 64;

CPropertyBag::~CPropertyBag()
{
    if(m_rgprop) {
        for(DWORD iprop = 0; iprop < m_ipropMax; ++iprop) {
            if(m_rgprop[iprop].szKey) {
                free((PVOID)m_rgprop[iprop].szKey);
                m_pfnRemovePv(m_rgprop[iprop].pvValue);
            }
        }
        delete m_rgprop;
    }
}

CPropertyBag::PROP *CPropertyBag::PpropFind(LPCSTR szKey, BOOL fMustExist) const
{
    if(m_rgprop) {
        CCheckSum cxc;
        char *szUpcaseKey;
        char *pch;

        szUpcaseKey = (char *)_alloca(strlen(szKey) + 1);
        strcpy(szUpcaseKey, szKey);
        for(pch = szUpcaseKey; *pch; ++pch)
            if(isalpha(*pch))
                *pch = (char)toupper(*pch);
        cxc.SumBytes((PBYTE)szUpcaseKey, strlen(szUpcaseKey));
        DWORD iprop = cxc.DwRunningSum() % m_ipropMax;
        while(m_rgprop[iprop].szKey) {
            if(0 == _stricmp(szKey, m_rgprop[iprop].szKey))
                return &m_rgprop[iprop];
            iprop = (iprop + 1) % m_ipropMax;
        }
        if(!fMustExist)
            return &m_rgprop[iprop];
    }
    return NULL;
}

PVOID CPropertyBag::FindProp(LPCSTR szKey) const
{
    PROP *pp = PpropFind(szKey, TRUE);
    return pp ? pp->pvValue : NULL;
}

PVOID CPropertyBag::FindProp(LPCSTR szKey, int *piOrd) const
{
    PROP *pp = PpropFind(szKey, TRUE);
    if(!pp)
        return NULL;
    *piOrd = pp->iOrdinal;
    return pp->pvValue;
}

BOOL CPropertyBag::FChangeProp(LPCSTR szKey, PVOID pvValue)
{
    PROP *pp = PpropFind(szKey, TRUE);
    if(pp) {
        m_pfnRemovePv(pp->pvValue);
        pp->pvValue = PvAdd(pvValue);
    }
    return pp != NULL;
}

BOOL CPropertyBag::FAddProp(LPCSTR szKey, PVOID pvValue)
{
    PROP *pp;

    /* Make sure we have a value */
    if(!pvValue)
        return NULL;

    /* Make sure this key doesn't exist already */
    if(PpropFind(szKey, TRUE))
        return FALSE;

    if(!m_rgprop) {
        m_rgprop = new PROP[m_ipropMax = m_dcpropInc];
        memset(m_rgprop, 0, sizeof(PROP) * m_ipropMax);
    }

    if(++m_cprop > m_ipropMax / 2) {
        /* Expand the hash table */
        PROP *rgpropT = m_rgprop;
        DWORD cpropT = m_ipropMax;

        m_rgprop = new PROP[m_ipropMax += m_dcpropInc];
        memset(m_rgprop, 0, sizeof(PROP) * m_ipropMax);
        for(DWORD iprop = 0; iprop < cpropT; ++iprop) {
            if(rgpropT[iprop].szKey) {
                pp = PpropFind(rgpropT[iprop].szKey, FALSE);
                *pp = rgpropT[iprop];
            }
        }
        delete rgpropT;
    }

    pp = PpropFind(szKey, FALSE);
    pp->szKey = _strdup(szKey);
    pp->pvValue = PvAdd(pvValue);
    pp->iOrdinal = m_cprop - 1;
    return TRUE;
}

void CPropertyBag::GetProps(LPCSTR *rgszKeys, PVOID *rgpvValues) const
{
    const PROP *pp = m_rgprop;
    DWORD iprop;

    for(iprop = 0; iprop < m_ipropMax; ++iprop, ++pp) {
        if(pp->szKey) {
            rgszKeys[pp->iOrdinal] = pp->szKey;
            rgpvValues[pp->iOrdinal] = pp->pvValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\ncipher.h ===
/*
 *
 * ncipher.h
 *
 * CNCipherCrypt
 *
 */

#ifndef _NCIPHER_H
#define _NCIPHER_H

#include <crypt.h>

class CNCipherCrypt : public CCryptContainer
{
public:
    ~CNCipherCrypt();
    static CNCipherCrypt *PccCreate(LPCSTR szProvider, LPCSTR szContainer);
    static CNCipherCrypt *PccCreate(HCRYPTPROV hprov);
    virtual BOOL FComputeDigest(const BYTE *pb, DWORD cb, LPBYTE pbDigest) const;
    virtual BOOL FComputeEncryptedDigest(const BYTE *pb, DWORD cb,
        LPBYTE pbDigest) const;
    virtual BOOL FStartProgressiveHash(void);
    virtual BOOL FProgressiveHashData(const BYTE *pb, DWORD cb);
    virtual BOOL FComputeProgressiveHash(LPBYTE pbDigest) const;
    virtual BOOL FEncryptProgressiveHash(LPBYTE pbDigest) const;
    virtual int CbGetDigestSize(void) const { return m_cbHash; };
    virtual int CbGetEncryptedDigestSize(void) const { return m_cbSigned; };
    virtual BOOL FVerifyEncryptedDigest(const BYTE *pb, DWORD cb,
        const BYTE *pbSigned) const;
    virtual BOOL FVerifyEncryptedProgressiveHash(const BYTE *pbSigned) const;
    virtual const BYTE *PbGetPublicKey(void) const { return m_pbPublicKey; }
    virtual BOOL FComputeSessionKeyFromData(const BYTE *pb, DWORD cb, DWORD cbit=0);
    virtual BOOL FSessionEncrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const;
    virtual BOOL FSessionDecrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const;
    virtual void DestroySessionKey(void);

    HCRYPTPROV HProvider(void) const { return m_hcprov; }
private:
    CNCipherCrypt(void);
    HCRYPTPROV m_hcprov;
    HCRYPTKEY m_hkeyPub;
    HCRYPTKEY m_hkeySession;
    HCRYPTHASH m_hhProgressive;
    DWORD m_cbHash;
    DWORD m_cbSigned;
    PBYTE m_pbPublicKey;
    BOOL m_fWeAcquiredContext;

    BOOL FCreateInternal(void);
    HCRYPTHASH HhComputeHash(const BYTE *pb, DWORD cb) const;
    BOOL FSignHash(HCRYPTHASH hh, LPBYTE pbDigest) const;
};

#endif // _NCIPHER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\ncipher.cpp ===
/*
 *
 * ncipher.h
 *
 * CNCipherCrypt
 *
 */

#include "precomp.h"

CNCipherCrypt::CNCipherCrypt(void)
{
    m_pbPublicKey = NULL;
    m_hkeyPub = NULL;
    m_hkeySession = NULL;
    m_hcprov = NULL;
    m_fWeAcquiredContext = FALSE;
}

CNCipherCrypt::~CNCipherCrypt()
{
    if(m_pbPublicKey)
        free(m_pbPublicKey);
    if(m_hkeyPub)
        CryptDestroyKey(m_hkeyPub);
    if(m_hkeySession)
        CryptDestroyKey(m_hkeySession);
    if(m_hcprov && m_fWeAcquiredContext)
        CryptReleaseContext(m_hcprov, 0);
}

CNCipherCrypt *CNCipherCrypt::PccCreate(LPCSTR szProvider, LPCSTR szContainer)
{
    CNCipherCrypt *pcc = new CNCipherCrypt;

    /* Get access to the crypt provider */
    if(!CryptAcquireContext(&pcc->m_hcprov, szContainer, szProvider,
            PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
        goto fatal;
    pcc->m_fWeAcquiredContext = TRUE;
    if(pcc->FCreateInternal())
        return pcc;
fatal:
    delete pcc;
    return NULL;
}

CNCipherCrypt *CNCipherCrypt::PccCreate(HCRYPTPROV hprov)
{
    CNCipherCrypt *pcc = new CNCipherCrypt;

    pcc->m_hcprov = hprov;
    if(pcc->FCreateInternal())
        return pcc;
    delete pcc;
    return NULL;
}

BOOL CNCipherCrypt::FCreateInternal(void)
{
    HCRYPTHASH hhash;
    DWORD cb;
    DWORD cbKey;
    PUBLICKEYSTRUC *pkey;
    RSAPUBKEY *prsa;
    BSAFE_PUB_KEY *pbpk;

    /* Fetch the public key and convert to xcrypt format */
    if(!CryptGetUserKey(m_hcprov, AT_SIGNATURE, &m_hkeyPub))
        return FALSE;
    if(!CryptExportKey(m_hkeyPub, NULL, PUBLICKEYBLOB, 0, NULL, &cb))
        return FALSE;
    pkey = (PUBLICKEYSTRUC *)_alloca(cb);
    if(!CryptExportKey(m_hkeyPub, NULL, PUBLICKEYBLOB, 0, (PBYTE)pkey, &cb))
        return FALSE;
    if(pkey->bType != PUBLICKEYBLOB || pkey->bVersion != 2 ||
        pkey->aiKeyAlg != CALG_RSA_SIGN)
    {
badpubkey:
        SetLastError(NTE_BAD_PUBLIC_KEY);
        return FALSE;
    }
    prsa = (RSAPUBKEY *)(pkey + 1);
    if(prsa->magic != RSA1)
        goto badpubkey;
    cb -= sizeof *prsa + sizeof *pkey;
    cbKey = ((prsa->bitlen + 7) / 8 + 7) & ~7;
    if(cb < cbKey)
        goto badpubkey;
    cbKey = ((prsa->bitlen + 7) / 8 + 8) & ~7;
    if(cbKey < cb)
        goto badpubkey;
    m_pbPublicKey = (PBYTE)malloc(cbKey + sizeof *pbpk);
    pbpk = (BSAFE_PUB_KEY *)m_pbPublicKey;
    pbpk->bitlen = prsa->bitlen;
    pbpk->keylen = ((pbpk->bitlen + 7) / 8 + 8) & ~7;
    pbpk->magic = prsa->magic;
    pbpk->pubexp = prsa->pubexp;
    pbpk->datalen = (pbpk->bitlen + 7) / 8 - 1;
    memcpy(pbpk + 1, prsa + 1, cb);
    if(cb > pbpk->keylen)
        memset((PBYTE)(pbpk + 1) + pbpk->keylen, 0, cb - pbpk->keylen);
    else if(cb < pbpk->keylen)
        memset((PBYTE)(pbpk + 1) + cb, 0, pbpk->keylen - cb);

    /* Get the hash size */
    if(!CryptCreateHash(m_hcprov, CALG_SHA1, NULL, 0, &hhash))
        return FALSE;
    cb = sizeof m_cbHash;
    if(!CryptGetHashParam(hhash, HP_HASHSIZE, (PBYTE)&m_cbHash, &cb, 0))
        m_cbHash = 0;
    CryptDestroyHash(hhash);
    if(!m_cbHash)
        return FALSE;
    m_hhProgressive = NULL;
    m_cbSigned = ((prsa->bitlen + 7) / 8 + 7) & ~7;

    return TRUE;
}

HCRYPTHASH CNCipherCrypt::HhComputeHash(const BYTE *pb, DWORD cb) const
{
    HCRYPTHASH hhash;

    if(!CryptCreateHash(m_hcprov, CALG_SHA1, NULL, 0, &hhash))
        return NULL;

    /* The XC digests all begin with the length dword first */
    if(!CryptHashData(hhash, (PBYTE)&cb, sizeof cb, 0))
        goto fatal;
    /* and then the actual data */
    if(!CryptHashData(hhash, pb, cb, 0))
        goto fatal;
    return hhash;
fatal:
    CryptDestroyHash(hhash);
    return NULL;
}

BOOL CNCipherCrypt::FComputeDigest(const BYTE *pb, DWORD cb, LPBYTE pbDigest) const
{
    HCRYPTHASH hhash;
    BOOL fRet;
    DWORD cbRet;

    hhash = HhComputeHash(pb, cb);
    if(!hhash)
        return NULL;
    /* We just assume that we have enough space to stick the data */
    cbRet = m_cbHash;
    fRet = CryptGetHashParam(hhash, HP_HASHVAL, pbDigest, &cbRet, 0);
    CryptDestroyHash(hhash);
    return fRet;
}

BOOL CNCipherCrypt::FStartProgressiveHash(void)
{
    if(m_hhProgressive)
        CryptDestroyHash(m_hhProgressive);
    if(!CryptCreateHash(m_hcprov, CALG_SHA1, NULL, 0, &m_hhProgressive)) {
        m_hhProgressive = NULL;
        return FALSE;
    }
    return TRUE;
}

BOOL CNCipherCrypt::FProgressiveHashData(const BYTE *pb, DWORD cb)
{
    if(!m_hhProgressive)
        return FALSE;
    if(!CryptHashData(m_hhProgressive, pb, cb, 0)) {
        CryptDestroyHash(m_hhProgressive);
        m_hhProgressive = NULL;
        return FALSE;
    }
    return TRUE;
}

BOOL CNCipherCrypt::FComputeProgressiveHash(LPBYTE pbDigest) const
{
    DWORD cbRet;

    if(!m_hhProgressive)
        return FALSE;
    /* We just assume that we have enough space to stick the data */
    cbRet = m_cbHash;
    return CryptGetHashParam(m_hhProgressive, HP_HASHVAL, pbDigest, &cbRet, 0);
}

BOOL CNCipherCrypt::FSignHash(HCRYPTHASH hh, LPBYTE pbDigest) const
{
    DWORD cbRet;
    BOOL fRet;

    /* We just assume that we have enough space to stick the data */
    cbRet = m_cbSigned;
    fRet = CryptSignHash(hh, AT_SIGNATURE, NULL, CRYPT_NOHASHOID, pbDigest,
        &cbRet);
    if(fRet && cbRet < m_cbSigned) {
        /* Fill the rest of the space with random data */
        g_rand.RandBytes(pbDigest + cbRet, m_cbSigned - cbRet);
    }

    return fRet;
}

BOOL CNCipherCrypt::FEncryptProgressiveHash(LPBYTE pbDigest) const
{
    DWORD cbRet;

    if(!m_hhProgressive)
        return FALSE;
    /* We just assume that we have enough space to stick the data */
    cbRet = m_cbSigned;
    return FSignHash(m_hhProgressive, pbDigest);
}

BOOL CNCipherCrypt::FComputeEncryptedDigest(const BYTE *pb, DWORD cb,
    LPBYTE pbDigest) const
{
    HCRYPTHASH hhash;
    BOOL fRet;
    DWORD cbRet;

    hhash = HhComputeHash(pb, cb);
    if(!hhash)
        return NULL;
    /* We just assume that we have enough space to stick the data */
    cbRet = m_cbSigned;
    fRet = FSignHash(hhash, pbDigest);
    CryptDestroyHash(hhash);

    return fRet;
}

BOOL CNCipherCrypt::FVerifyEncryptedDigest(const BYTE *pb, DWORD cb,
    const BYTE *pbSigned) const
{
    HCRYPTHASH hhash;
    BOOL fRet;

    hhash = HhComputeHash(pb, cb);
    if(!hhash)
        return NULL;

    fRet = CryptVerifySignature(hhash, pbSigned, m_cbSigned, m_hkeyPub,
        NULL, CRYPT_NOHASHOID);
    CryptDestroyHash(hhash);
    return fRet;
}

BOOL CNCipherCrypt::FVerifyEncryptedProgressiveHash(const BYTE *pbSigned) const
{
    if(!m_hhProgressive)
        return FALSE;
    return CryptVerifySignature(m_hhProgressive, pbSigned, m_cbSigned,
        m_hkeyPub, NULL, CRYPT_NOHASHOID);
}

BOOL CNCipherCrypt::FComputeSessionKeyFromData(const BYTE *pb, DWORD cb,
    DWORD cbit)
{
    HCRYPTHASH hhash;
    BOOL fRet = FALSE;

    DestroySessionKey();
    if(!CryptCreateHash(m_hcprov, CALG_SHA1, NULL, 0, &hhash))
        return NULL;
    if(!CryptHashData(hhash, pb, cb, 0))
        goto fatal;
    if(cbit == 0)
        cbit = 8 * m_cbHash;
    fRet = CryptDeriveKey(m_hcprov, CALG_RC4, hhash, cbit << 16,
        &m_hkeySession);

fatal:
    CryptDestroyHash(hhash);
    return NULL;
}

BOOL CNCipherCrypt::FSessionEncrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const
{
    if(!m_hkeySession)
        return FALSE;

    memcpy(pbOut, pbIn, cbIn);
    return CryptEncrypt(m_hkeySession, NULL, 0, TRUE, pbOut, &cbIn, cbIn);
}

BOOL CNCipherCrypt::FSessionDecrypt(const BYTE *pbIn, DWORD cbIn, LPBYTE pbOut) const
{
    if(!m_hkeySession)
        return FALSE;

    memcpy(pbOut, pbIn, cbIn);
    return CryptDecrypt(m_hkeySession, NULL, TRUE, 0, pbOut, &cbIn);
}

void CNCipherCrypt::DestroySessionKey(void)
{
    if(m_hkeySession) {
        CryptDestroyKey(m_hkeySession);
        m_hkeySession = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\randm.cpp ===
/*
 *
 * randm.cpp
 *
 * Random numbers
 *
 */

#include "precomp.h"

CRandom g_rand;

const ULONG CRandom::rgulMults[] = {
    0x52F690D5,
    0x534D7DDE,
    0x5B71A70F,
    0x66793320,
    0x9B7E5ED5,
    0xA465265E,
    0xA53F1D11,
    0xB154430F,
};

CRandom::CRandom(void)
{
    FILETIME ft;

    /* If this call fails, we still have random data in ft */
    GetSystemTimeAsFileTime(&ft);
    Seed(ft.dwHighDateTime ^ ft.dwLowDateTime);
}

void CRandom::Seed(ULONG ulSeed)
{
    m_ulMask = 0;
    m_ulMult = rgulMults[ulSeed & 7];
    m_ulCur = ulSeed;
    m_ulMask = Rand();
}

ULONG CRandom::Rand(void)
{
    ULARGE_INTEGER li;

    /* We're not a true 32-bit generator, since 2^32+1 isn't prime, so we use
     * 2^32-5 instead */
    li.QuadPart = m_ulCur;
    li.QuadPart += 1;
    li.QuadPart *= m_ulMult;
    li.QuadPart %= 0xFFFFFFFB;
    m_ulCur = li.LowPart;
    return m_ulCur ^ m_ulMask;
}

void CRandom::RandBytes(LPBYTE pb, DWORD cb)
{
    PUSHORT pus;

    if(cb == 0)
        return;
    if((ULONG)pb & 1) {
        *pb++ = (BYTE)(Rand() >> 14);
        --cb;
    }
    pus = (PUSHORT)pb;
    while(cb > 1) {
        *pus++ = (USHORT)(Rand() >> 8);
        cb -= 2;
    }
    if(cb)
        *pb = (BYTE)(Rand() >> 12);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\propbag.h ===
/*
 *
 * propbag.h
 *
 * CPropertyBag
 *
 */

#ifndef _PROPBAG_H
#define _PROPBAG_H

#include <stdlib.h>

enum { vpNone, vpDw, vpSz };

struct VPR {
    int vpType;
    union {
        DWORD dw;
        LPCSTR sz;
    };
    void Empty(void)
    {
        if(vpType == vpSz)
            free((void *)sz);
        vpType = vpNone;
    }
    VPR(void) { vpType = vpNone; }
    VPR(DWORD dwT) { Set(dwT); }
    VPR(LPCSTR szT) { Set(szT); }
    VPR(VPR &vpr) { Set(vpr); }
    VPR &operator=(DWORD dwT) { Empty(); Set(dwT); return *this; }
    VPR &operator=(LPCSTR szT) { Empty(); Set(szT); return *this; }
    VPR &operator=(const VPR &vpr) { Empty(); Set(vpr); return *this; }
    ~VPR() { Empty(); }
private:
    void Set(DWORD dwT) { vpType = vpDw; dw = dwT; }
    void Set(LPCSTR szT) { vpType = vpSz; sz = _strdup(szT); }
    void Set(const VPR &vpr)
    {
        vpType = vpr.vpType;
        if(vpType == vpDw)
            Set(vpr.dw);
        else
            Set(vpr.sz);
    }
};

class CPropertyBag {
public:
    CPropertyBag(void) : m_rgprop(NULL), m_ipropMax(0), m_cprop(0) {}
    ~CPropertyBag();

    DWORD Cprop(void) const { return m_cprop; }

private:
    struct PROP {
        LPCSTR szKey;
        PVOID pvValue;
        int iOrdinal;
    };
    
    PROP *m_rgprop;
    DWORD m_ipropMax;
    DWORD m_cprop;

    PROP *PpropFind(LPCSTR, BOOL) const;
    const static DWORD m_dcpropInc;
    void DestroyBag(void);

protected:
    virtual PVOID PvAdd(PVOID) const =0;
    void (*m_pfnRemovePv)(PVOID);

    BOOL FAddProp(LPCSTR, PVOID);
    PVOID FindProp(LPCSTR) const;
    PVOID FindProp(LPCSTR, int *) const;
    BOOL FChangeProp(LPCSTR, PVOID);
    void GetProps(LPCSTR *rgszKeys, PVOID *rgszValues) const;
};

template <class T> class CPropBag : public CPropertyBag {
public:
    BOOL FAddProp(LPCSTR szKey, T *p)
    {
        return CPropertyBag::FAddProp(szKey, (PVOID)p);
    }
    T *FindProp(LPCSTR szKey) const
    {
        return (T *)CPropertyBag::FindProp(szKey);
    }
    T *FindProp(LPCSTR szKey, int *piOrd) const
    {
        return (T *)CPropertyBag::FindProp(szKey, piOrd);
    }
    BOOL FChangeProp(LPCSTR szKey, T *p)
    {
        return CPropertyBag::FChangeProp(szKey, (PVOID)p);
    }
    void GetProps(LPCSTR *rgszKeys, T **rgp) const
    {
        CPropertyBag::GetProps(rgszKeys, (PVOID *)rgp);
    }
};

class CStringBag : public CPropBag<const char> {
public:
    CStringBag(void) { m_pfnRemovePv = RemovePv; }
private:
    virtual PVOID PvAdd(PVOID pv) const
    {
        return _strdup((const char *)pv);
    }
    static void RemovePv(PVOID pv)
    {
        free(pv);
    }
};

class CVarBag : public CPropBag<VPR> {
public:
    CVarBag(void) { m_pfnRemovePv = RemovePv; }
    LPCSTR FindSzProp(LPCSTR sz) const
    {
        VPR *pvp = FindProp(sz);
        return pvp && pvp->vpType == vpSz ? pvp->sz : NULL;
    }
    BOOL FFindDwProp(LPCSTR sz, PDWORD pdw) const
    {
        VPR *pvp = FindProp(sz);
        return pvp && pvp->vpType == vpDw ? (*pdw = pvp->dw, TRUE) :
            FALSE;
    }
    BOOL FAddProp(LPCSTR sz, VPR *pvp)
    {
        return CPropBag<VPR>::FAddProp(sz, pvp);
    }
    BOOL FAddProp(LPCSTR szKey, LPCSTR szVal)
    {
        VPR vprT;
        vprT.vpType = vpSz;
        vprT.sz = szVal;
        BOOL f = FAddProp(szKey, &vprT);
        vprT.vpType = vpNone;
        return f;
    }
    BOOL FAddProp(LPCSTR sz, DWORD dw)
    {
        return FAddProp(sz, &VPR(dw));
    }
private:
    virtual PVOID PvAdd(PVOID pv) const
    {
        return new VPR(*(VPR *)pv);
    }
    static void RemovePv(PVOID pv)
    {
        delete (VPR *)pv;
    }
};

#endif // _PROPBAG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\randm.h ===
/*
 *
 * randm.h
 *
 * Random numbers
 *
 */

#ifndef _RANDM_H
#define _RANDM_H

#include <time.h>

class CRandom
{
public:
    CRandom(void);

    ULONG Rand(void);
    void RandBytes(LPBYTE pb, DWORD cb);
private:
    static const ULONG rgulMults[];
    void Seed(ULONG ulSeed);
    ULONG m_ulMult;
    ULONG m_ulCur;
    ULONG m_ulMask;
};

extern CRandom g_rand;

#endif // _RANDM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\reg.h ===
/*
 *
 * reg.h
 *
 * Registry stuff
 *
 */

#ifndef _REG_H
#define _REG_H

#include <propbag.h>

CVarBag *PbagFromRegKey(HKEY hKey);

#endif // REG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\reg.cpp ===
/*
 *
 * reg.cpp
 *
 * Registry stuff
 *
 */

#include "precomp.h"

CVarBag *PbagFromRegKey(HKEY hkey)
{
    DWORD iValue;
    DWORD cValues;
    DWORD cchKeyMax;
    LPSTR szKey;
    char szValue[256];
    DWORD cchValue;
    DWORD cchKey;
    DWORD dwType;
    CVarBag *pbag;
    VPR vpr;

    if(ERROR_SUCCESS != RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL,
            NULL, &cValues, &cchKeyMax, NULL, NULL, NULL))
        return NULL;
    szKey = (LPSTR)_alloca(cchKeyMax + 1);
    pbag = new CVarBag;
    for(iValue = 0; iValue < cValues; ++iValue) {
        cchValue = sizeof szValue;
        cchKey = cchKeyMax + 1;
        if(ERROR_SUCCESS != RegEnumValue(hkey, iValue, szKey, &cchKey, NULL,
            &dwType, (LPBYTE)szValue, &cchValue))
        {
            delete pbag;
            return NULL;
        }
        if(dwType == REG_SZ) {
            vpr.vpType = vpSz;
            vpr.sz = szValue;
        } else if(dwType == REG_DWORD) {
            vpr.vpType = vpDw;
            vpr.dw = *(DWORD *)szValue;
        } else
            continue;
        pbag->FAddProp(szKey, &vpr);
        vpr.vpType = vpNone;
    }

    return pbag;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\rtlcrypt.cpp ===
/*
 *
 * rtlcrypt.cpp
 *
 * Retail key half
 *
 */

#include "precomp.h"

const BYTE CRetailCrypt::rgbLeftHalf[284] =
{
	0x9A, 0xD8, 0x2A, 0xA1, 0x05, 0x1A, 0x8F, 0x3A, 
	0x85, 0xA5, 0xE1, 0xF9, 0xF6, 0x26, 0x45, 0x4F, 
	0xF1, 0x69, 0xBE, 0x98, 0xC7, 0x53, 0x8D, 0x30, 
	0x1B, 0x23, 0x96, 0x3C, 0x78, 0xBC, 0x9A, 0x6C, 
	0x76, 0x1E, 0x6D, 0x91, 0x73, 0x9B, 0x9F, 0xFC, 
	0x15, 0x82, 0xAC, 0xA0, 0x14, 0xEC, 0xC3, 0x79, 
	0xF7, 0x0B, 0x49, 0x7D, 0xCD, 0x10, 0x9B, 0x16, 
	0x9A, 0x88, 0xB2, 0x90, 0x3F, 0xCB, 0xCF, 0x7C, 
	0x80, 0xC5, 0x4E, 0xDB, 0x0D, 0x85, 0x25, 0x82, 
	0xB2, 0xC4, 0xD3, 0xAF, 0x98, 0xFD, 0x06, 0xD7, 
	0x89, 0xF6, 0xD7, 0x38, 0xFE, 0x53, 0xE2, 0x7F, 
	0xAF, 0x54, 0x38, 0xDA, 0x66, 0x8A, 0x23, 0x4D, 
	0x28, 0x3C, 0x48, 0x1D, 0xF0, 0x7C, 0x27, 0x6D, 
	0x4E, 0xE0, 0x00, 0xBB, 0x7A, 0xED, 0xCE, 0x23, 
	0xD9, 0xE2, 0x44, 0xA0, 0x39, 0x43, 0xC8, 0xAC, 
	0x7C, 0x6B, 0x04, 0xBD, 0x3E, 0xDF, 0xCE, 0x5C, 
	0xBB, 0x69, 0xF8, 0x7F, 0xD4, 0x3E, 0x26, 0x46, 
	0xA5, 0x6E, 0xDD, 0xF0, 0x6B, 0xE7, 0x5A, 0x8B, 
	0x33, 0xEF, 0xE2, 0xCA, 0x77, 0x87, 0x55, 0xDC, 
	0x0D, 0xA1, 0x42, 0xE3, 0xEF, 0xBD, 0xDA, 0xC6, 
	0x7D, 0x4B, 0x09, 0x9A, 0x09, 0xFA, 0x41, 0xA8, 
	0x33, 0x61, 0x31, 0x64, 0xAA, 0xDB, 0x37, 0x54, 
	0xF2, 0x91, 0x76, 0xFC, 0xA5, 0xBA, 0xD6, 0x34, 
	0xDF, 0xDC, 0x02, 0xCD, 0x12, 0x71, 0x65, 0x44, 
	0xAD, 0x5C, 0x37, 0x51, 0x37, 0x5A, 0x17, 0x26, 
	0x0A, 0xE3, 0x7F, 0xE2, 0xA9, 0x57, 0xCD, 0x9F, 
	0x71, 0x3A, 0x66, 0xE1, 0x7E, 0x91, 0x04, 0x49, 
	0x0E, 0x51, 0xA1, 0x34, 0x30, 0x2A, 0xC8, 0x98, 
	0x0A, 0x9A, 0x98, 0xEE, 0x41, 0x21, 0x43, 0x80, 
	0x96, 0x4E, 0xFB, 0x8B, 0xC5, 0x5B, 0x07, 0xD2, 
	0x86, 0x48, 0xE3, 0x85, 0x28, 0x9C, 0x60, 0xE0, 
	0xF5, 0x8E, 0x52, 0x16, 0x3E, 0xE0, 0x35, 0x73, 
	0xFE, 0xFF, 0x89, 0x6C, 0x81, 0xB4, 0xA0, 0x45, 
	0x4E, 0x12, 0x41, 0x0E, 0xCB, 0xCE, 0x55, 0x64, 
	0x2F, 0xA9, 0x0A, 0x01, 0x3B, 0x74, 0x52, 0xB4, 
	0x11, 0xD3, 0x6D, 0xA7, 
};

CRetailCrypt::CRetailCrypt(void) : CSimpleCrypt(m_rgbPublicKey, NULL)
{
    int i;

    for(i = 0; i < sizeof m_rgbPublicKey; ++i)
        m_rgbPublicKey[i] = rgbLeftHalf[i] ^ rgbRightHalf[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\tape.h ===
/*
 *
 * tape.h
 *
 * CTapeDevice
 *
 */

#ifndef _TAPE_H
#define _TAPE_H

#include <filestm.h>

class CTapeDevice : public CFileStmSeq {
public:
    CTapeDevice(void) : m_hdev(NULL), m_pbBufCur(NULL), m_dwFlags(0),
        m_bWritePad(0) {}
    virtual ~CTapeDevice();

    BOOL FMount(LPCSTR, BOOL fWrite);
    BOOL FMount(HANDLE, BOOL fWrite);
    BOOL FMountAsTapeOrDisk(LPCSTR, BOOL fWrite);
    BOOL FUnmount(void);
    BOOL FMounted(void) { return m_hdev != NULL; }
    BOOL FRewind(void);
    BOOL FReadFile(LPSTR szName, LPDWORD lpdwDataBlkSize,
        LPDWORD lpdwDataPerPhy);
    BOOL FWriteFile(LPCSTR szName, DWORD dwDataBlkSize=2048,
        DWORD dwDataPerPhy=16);
    BOOL FCloseFile(void);
    BOOL FAtEnd(void) { return !m_fFatalError && m_fAtEOT; }
    void SetWritePadByte(BYTE b) { m_bWritePad = b; }

    virtual BOOL FIsOpen(void) { return m_pbBufCur != NULL; }
    virtual DWORD CbRead(DWORD cb, PBYTE pbBuf);
    virtual DWORD CbWrite(DWORD cb, const BYTE *pbBuf);
    virtual BOOL FCopyToStm(CFileStmSeq *pstm, CCheckSum *pxsum=NULL);

    DWORD DwCheckSum(void) { return m_xsum.DwFinalSum(); }

    BOOL FCopyEntire(CTapeDevice *ptap);

protected:
    virtual BOOL FPreferredReceive(void) { return TRUE; }
    virtual BOOL FCopyFromStm(CFileStmSeq *pstm, CCheckSum *pxsum);

    struct TOD // tape on disk
    {
        LARGE_INTEGER liCurWriteMark;
        LARGE_INTEGER cbToFilemark;
    };

    HANDLE m_hdev;
    TOD *m_ptod;

private:
    DWORD m_cbBlkCur;
    DWORD m_ibBlkCur;
    DWORD m_cbReadCur;
    DWORD m_cBlkCur;
    BYTE *m_pbBufCur;
    LPSTR m_szFilenameCur;
    DWORD m_cbRecCur;
    BYTE m_bWritePad;
    int iFile;
    union {
        struct {
            BOOL m_fAtEOF:1,
                m_fWriteOnly:1,
                m_fFatalError:1,
                m_fAtEOT:1,
                m_fVarBlks:1,
                unused:27;
        };
        DWORD m_dwFlags;
    };
    DWORD m_cbToNextFilemark; // disk streams only
    CCheckSum m_xsum;

    BOOL FSetupTapeDevice(void);
    BOOL FRewindNoHdrs(void);
    void ReadVolumeHeader(void);
    void WriteVolumeHeader(void);
    DWORD ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
    DWORD WriteFile(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
    BOOL FSeekToFilemark(int);
    BOOL FWriteFilemark(void);
    void SetAfterFilemark(void);
    BOOL FWriteFileHeaders(BOOL fEOF);
};

#endif // _TAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\tape.cpp ===
/*
 *
 * tape.cpp
 *
 * CTapeDevice
 *
 */

#include "precomp.h"

BOOL CTapeDevice::FMount(LPCSTR szName, BOOL fWrite)
{
    m_hdev = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, 0,
        OPEN_EXISTING, 0, NULL);
    if(m_hdev != INVALID_HANDLE_VALUE) {
        if(!FSetupTapeDevice()) {
            CloseHandle(m_hdev);
            m_hdev = NULL;
        }
    } else
        m_hdev = NULL;
    m_fWriteOnly = !!fWrite;
    m_ptod = NULL;
    return FRewind();
}

CTapeDevice::~CTapeDevice()
{
    FUnmount();
}

BOOL CTapeDevice::FSetupTapeDevice(void)
{
    DWORD err;
    DWORD cb;
    TAPE_GET_DRIVE_PARAMETERS dpGet;
    TAPE_SET_DRIVE_PARAMETERS dpSet;

    if(!m_hdev)
        return FALSE;
    err = PrepareTape(m_hdev, TAPE_LOAD, FALSE);
    if(err != NO_ERROR && err != ERROR_MEDIA_CHANGED)
        return FALSE;
    if(NO_ERROR != GetTapeStatus(m_hdev))
        return FALSE;
    cb = sizeof dpGet;
    if(NO_ERROR != GetTapeParameters(m_hdev, GET_TAPE_DRIVE_INFORMATION,
            &cb, &dpGet) || cb != sizeof dpGet)
        return FALSE;
    /* Keep parameters the same, except for Compression */
    dpSet.ECC = dpGet.ECC;
    dpSet.Compression = FALSE;
    dpSet.ReportSetmarks = dpGet.ReportSetmarks;
    dpSet.EOTWarningZoneSize = dpGet.EOTWarningZoneSize;
    return NO_ERROR == SetTapeParameters(m_hdev, SET_TAPE_DRIVE_INFORMATION,
        &dpSet);
}

BOOL CTapeDevice::FMount(HANDLE h, BOOL fWrite)
{
    m_hdev = h;
    m_ptod = new TOD;
    memset(m_ptod, 0, sizeof TOD);
    m_fWriteOnly = !!fWrite; 
    return FRewind();
}

BOOL CTapeDevice::FMountAsTapeOrDisk(LPCSTR sz, BOOL fWrite)
{
    if(0 == strncmp(sz, "\\\\.", 3))
        return FMount(sz, fWrite);
    if(fWrite)
        m_hdev = CreateFile(sz, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
    else
        m_hdev = CreateFile(sz, GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, 0, NULL);
    if(m_hdev != INVALID_HANDLE_VALUE) {
        if(FMount(m_hdev, fWrite))
            return TRUE;
        CloseHandle(m_hdev);
    }
    m_hdev = NULL;
    return FALSE;
}

BOOL CTapeDevice::FUnmount(void)
{
    BOOL fRet = TRUE;

    if(!m_hdev)
        return FALSE;

    /* Close any open file */
    if(m_pbBufCur)
        fRet = FCloseFile();
    /* If writing, write the final tapemark */
    if(m_fWriteOnly)
        fRet = FWriteFilemark() && fRet;
    /* Unmount the tape */
    if(!m_ptod)
        fRet = (NO_ERROR == PrepareTape(m_hdev, TAPE_UNLOAD, TRUE)) && fRet;
    if(m_hdev)
        CloseHandle(m_hdev);
    m_hdev = NULL;
    m_dwFlags = 0;
    return fRet;
}

DWORD CTapeDevice::ReadFile(HANDLE h, LPVOID pv, DWORD cb, LPDWORD pcb,
    LPOVERLAPPED p)
{
    DWORD dwRet;

    if(m_ptod) {
        /* If we're on a filemark, we'll return a filemark failure and
         * prep for the next bit of data */
        if(m_ptod->cbToFilemark.QuadPart == 0) {
            *pcb = 0;
            SetAfterFilemark();
            SetLastError(ERROR_FILEMARK_DETECTED);
            return 0;
        }
        if(m_ptod->cbToFilemark.HighPart == 0 &&
                m_ptod->cbToFilemark.LowPart < cb)
            /* We'll run out of data prior to the next filemark, so cut the
             * read short */
            cb = m_ptod->cbToFilemark.LowPart;
        dwRet = ::ReadFile(h, pv, cb, pcb, p);
        m_ptod->cbToFilemark.QuadPart -= *pcb;
    } else
        dwRet = ::ReadFile(h, pv, cb, pcb, p);

    return dwRet;
}

DWORD CTapeDevice::WriteFile(HANDLE h, LPCVOID pv, DWORD cb, LPDWORD pcb,
    LPOVERLAPPED p)
{
    return ::WriteFile(h, pv, cb, pcb, p);
}

BOOL CTapeDevice::FSeekToFilemark(int c)
{
    if(m_fFatalError || m_fWriteOnly)
        return FALSE;

    if(m_ptod) {
        if(c < 0)
            return FALSE;
        while(c--) {
            /* Skip as many bytes as remain in this file */
            if(!SetFilePointerEx(m_hdev, m_ptod->cbToFilemark, NULL,
                FILE_CURRENT))
            {
                m_fFatalError = TRUE;
                return FALSE;
            }
            SetAfterFilemark();
        }
        return TRUE;
    } else
        return NO_ERROR == SetTapePosition(m_hdev, TAPE_SPACE_FILEMARKS, 0,
            c, c < 0 ? -1 : 0, FALSE);
}

BOOL CTapeDevice::FWriteFilemark(void)
{
    LARGE_INTEGER li;
    DWORD cb;

    if(m_fFatalError || !m_fWriteOnly)
        return FALSE;

    if(m_ptod) {
        /* First get the current pointer */
        li.QuadPart = 0;
        if(!SetFilePointerEx(m_hdev, li, &li, FILE_CURRENT)) {
fatal:
            m_fFatalError = TRUE;
            return FALSE;
        }
        m_ptod->cbToFilemark.QuadPart = li.QuadPart -
            m_ptod->liCurWriteMark.QuadPart - sizeof li;
        if(!SetFilePointerEx(m_hdev, m_ptod->liCurWriteMark, NULL, FILE_BEGIN))
            goto fatal;
        if(!::WriteFile(m_hdev, &m_ptod->cbToFilemark,
                sizeof m_ptod->cbToFilemark, &cb, NULL) || cb !=
                sizeof m_ptod->cbToFilemark)
            goto fatal;
        if(!SetFilePointerEx(m_hdev, li, NULL, FILE_BEGIN))
            goto fatal;
        m_ptod->liCurWriteMark = li;
        li.QuadPart = 0;
        if(!::WriteFile(m_hdev, &li, sizeof li, &cb, NULL) || cb != sizeof li)
            goto fatal;
        return TRUE;
    } else
        return NO_ERROR == WriteTapemark(m_hdev, TAPE_FILEMARKS, 1, FALSE);
}

void CTapeDevice::SetAfterFilemark(void)
{
    DWORD cb;

    if(m_ptod && !m_fFatalError && !m_fWriteOnly) {
        /* We should be sitting on a filemark, so read it */
        if(!::ReadFile(m_hdev, &m_ptod->cbToFilemark,
                sizeof m_ptod->cbToFilemark, &cb, NULL) || cb !=
                sizeof m_ptod->cbToFilemark)
            m_fFatalError = TRUE;
    }
}

BOOL CTapeDevice::FRewindNoHdrs(void)
{
    BOOL fRet;

    m_xsum.Reset();
    if(!m_hdev)
        return FALSE;

    /* Close any open file */
    if(m_pbBufCur)
        FCloseFile();
    m_fFatalError = FALSE;
    m_fAtEOT = FALSE;

    if(m_ptod) {
        if(INVALID_SET_FILE_POINTER == SetFilePointer(m_hdev, 0, NULL,
                FILE_BEGIN))
            fRet = FALSE;
        else {
            SetAfterFilemark();
            fRet = TRUE;
        }
    } else
        fRet = SetTapePosition(m_hdev, TAPE_REWIND, 0, 0, 0, TRUE) == NO_ERROR;
    if(!fRet)
        m_fFatalError = TRUE;
    return fRet;
}

BOOL CTapeDevice::FRewind(void)
{
    if(FRewindNoHdrs()) {
        if(m_fWriteOnly)
            WriteVolumeHeader();
        else
            ReadVolumeHeader();
    } else
        m_fFatalError = TRUE;
    return !m_fFatalError;
}

void CTapeDevice::ReadVolumeHeader(void)
{
    TAPE_SET_MEDIA_PARAMETERS mp;
    BYTE rgbVOL1[80];
    DWORD cb;

    /* Configure for block reads */
    mp.BlockSize = 80;
    if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
        SET_TAPE_MEDIA_INFORMATION, &mp))
    {
fatal:
        m_fFatalError = TRUE;
        return;
    }

    /* Read the VOL1 block */
    if(!ReadFile(m_hdev, rgbVOL1, sizeof rgbVOL1, &cb, NULL) ||
            cb != sizeof rgbVOL1 ||  *(DWORD *)rgbVOL1 != '1LOV')
        goto fatal;

    /* Don't really care what the contents are */
}

void CTapeDevice::WriteVolumeHeader(void)
{
    TAPE_SET_MEDIA_PARAMETERS mp;
    BYTE rgbVOL1[80];
    LARGE_INTEGER li;
    DWORD cb;
    int ich;

    if(m_ptod) {
        /* We should be ready to write a filemark */
        li.QuadPart = m_ptod->liCurWriteMark.QuadPart = 0;
        if(!::WriteFile(m_hdev, &li, sizeof li, &cb, NULL) || cb != sizeof li)
            goto fatal;
    } else {
        /* Configure for block writes */
        mp.BlockSize = 80;
        if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
            SET_TAPE_MEDIA_INFORMATION, &mp))
        {
fatal:
            m_fFatalError = TRUE;
            return;
        }
    }

    /* Construct the VOL1 block */
    memset(rgbVOL1, ' ', sizeof rgbVOL1);
    *(DWORD *)rgbVOL1 = '1LOV';
    rgbVOL1[79] = '4';

    /* Write it out */
    if(!WriteFile(m_hdev, rgbVOL1, sizeof rgbVOL1, &cb, NULL) ||
            cb != sizeof rgbVOL1)
        goto fatal;
}

DWORD CTapeDevice::CbRead(DWORD cb, PBYTE pbBuf)
{
    DWORD cbReq = cb;
    DWORD cbRet;
    LPBYTE pbBufT;
    DWORD cblk;
    const BYTE *pbSum = pbBuf;

    if(!m_hdev || !m_pbBufCur || m_fWriteOnly || m_fAtEOF)
        return 0;

    /* First fetch data from the current block if there is any */
    if(m_ibBlkCur) {
curblk:
        if(m_ibBlkCur + cb <= m_cbReadCur)
            cbRet = cb;
        else
            cbRet = m_cbReadCur - m_ibBlkCur;
        memcpy(pbBuf, m_pbBufCur + m_ibBlkCur, cbRet);
        m_ibBlkCur += cbRet;
        pbBuf += cbRet;
        cb -= cbRet;
        if(m_ibBlkCur == m_cbReadCur)
            m_ibBlkCur = 0;
    }

    /* Read all of the data that we can */
    while(cb && !m_fAtEOF) {
        /* If we know we have at least a full block waiting, then we can read
         * straight into the user buffer.  Otherwise, we need to read into our
         * buffer in preparation for a partial block read */
        if(cb >= m_cbBlkCur) {
            pbBufT = pbBuf;
            cblk = cb / m_cbBlkCur;
        } else {
            pbBufT = m_pbBufCur;
            cblk = 1;
        }
        if(!ReadFile(m_hdev, pbBufT, m_cbBlkCur * cblk, &cbRet, NULL) &&
            cbRet == 0)
        {
            /* We hit a filemark, or a fatal error, so mark EOF */
            if(GetLastError() != ERROR_FILEMARK_DETECTED)
                m_fFatalError = TRUE;
            m_fAtEOF = TRUE;
            break;
        }
        if(cbRet == m_cbBlkCur)
            m_cBlkCur += cblk;
        else
            ++m_cBlkCur;
        if(pbBufT == pbBuf) {
            pbBuf += cbRet;
            cb -= cbRet;
        } else {
            /* We read a partial block, so we need to copy the appropriate
             * amount of data into the user buffer.  We have that code above,
             * so we just jump there.  And since we may not have fulfilled
             * the read request due to a partial read of a full-sized variable
             * length block, we can fall through into the read loop again */
            m_cbReadCur = cbRet;
            goto curblk;
       }
    }

    if(cbReq - cb > 0)
        m_xsum.SumBytes(pbSum, cbReq - cb);
    return cbReq - cb;
}

DWORD CTapeDevice::CbWrite(DWORD cb, const BYTE *pbBuf)
{
    DWORD cbReq = cb;
    DWORD cbRet;

    if(!m_hdev || !m_pbBufCur || !m_fWriteOnly || m_fFatalError)
        return 0;

    m_xsum.SumBytes(pbBuf, cb);

    /* First fill data from the current block if there is a pending partial
     * write */
    if(m_ibBlkCur) {
        if(m_ibBlkCur + cb <= m_cbBlkCur)
            cbRet = cb;
        else
            cbRet = m_cbBlkCur - m_ibBlkCur;
        memcpy(m_pbBufCur + m_ibBlkCur, pbBuf, cbRet);
        m_ibBlkCur += cbRet;
        pbBuf += cbRet;
        cb -= cbRet;
        if(m_ibBlkCur == m_cbBlkCur) {
            /* Need to flush this block */
            if(!WriteFile(m_hdev, m_pbBufCur, m_cbBlkCur, &cbRet, NULL) ||
                cbRet != m_cbBlkCur)
            {
                m_fFatalError = TRUE;
                return 0;
            }
            ++m_cBlkCur;
            m_ibBlkCur = 0;
        }
    }

    /* Write all of the full blocks that we can */
    if(cb >= m_cbBlkCur) {
        DWORD cblk = cb / m_cbBlkCur;
        if(!WriteFile(m_hdev, pbBuf, m_cbBlkCur * cblk, &cbRet, NULL) ||
                cbRet != m_cbBlkCur * cblk)
            m_fFatalError = TRUE;
        else
            m_cBlkCur += cblk;
        pbBuf += cbRet;
        cb -= cbRet;
    }

    /* If there is still data to go and we know there's still room to write
     * file data, copy the remainder into a buffer to flush later */
    if(cb && !m_fAtEOF) {
        m_ibBlkCur = cb;
        memcpy(m_pbBufCur, pbBuf, cb);
        cb = 0;
    }

    return cbReq - cb;
}

BOOL CTapeDevice::FCloseFile(void)
{
    BOOL fRet;
    DWORD cb;

    if(!m_hdev || !m_pbBufCur || m_fFatalError)
        return FALSE;

    if(m_fWriteOnly) {
        /* If we have a pending write, flush it now */
        if(m_ibBlkCur && !m_fAtEOF) {
            DWORD cbRet;

            if(m_fVarBlks)
                cb = m_ibBlkCur;
            else {
                memset(m_pbBufCur + m_ibBlkCur, m_bWritePad,
                    m_cbBlkCur - m_ibBlkCur);
                m_xsum.SumBytes(m_pbBufCur + m_ibBlkCur,
                    m_cbBlkCur - m_ibBlkCur);
                cb = m_cbBlkCur;
            }
            if(!WriteFile(m_hdev, m_pbBufCur, cb, &cbRet, NULL) ||
                    cbRet != cb)
                m_fFatalError = TRUE;
            else
                ++m_cBlkCur;
        }
        fRet = !m_fFatalError;
        if(fRet)
            /* Write a filemark prior to the next file */
            fRet = FWriteFilemark();
        if(fRet)
            /* Now we need to write the EOF records */
            fRet = FWriteFileHeaders(TRUE);
        free(m_szFilenameCur);
    } else {
        if(!m_fAtEOF)
            fRet = FSeekToFilemark(1);
        else
            fRet = TRUE;
        if(fRet)
            /* Skip over the EOF records */
            fRet = FSeekToFilemark(1);
    }

    /* Mark as no file open */
    delete m_pbBufCur;
    m_pbBufCur = NULL;
    if(!fRet)
        m_fFatalError = TRUE;
    return fRet;
}

BOOL CTapeDevice::FReadFile(LPSTR szName, LPDWORD lpdwDataBlkSize,
    LPDWORD lpdwDataPerPhy)
{
    BYTE rgbHDR1[80];
    BYTE rgbHDR2[80];
    TAPE_SET_MEDIA_PARAMETERS mp;
    TAPE_GET_DRIVE_PARAMETERS dp;
    DWORD cb;
    BYTE *pch;
    char szT[8];
    DWORD dwBlkSize;
    DWORD dwDataPerPhy;

    if(!m_hdev || m_fFatalError || m_fWriteOnly || m_fAtEOT)
        return FALSE;

    if(m_pbBufCur) {
        /* File is open, so close it */
        FCloseFile();
    }

    /* Configure for block reads */
    mp.BlockSize = 80;
    if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
        SET_TAPE_MEDIA_INFORMATION, &mp))
    {
fatal:
        m_fFatalError = TRUE;
        return FALSE;
    }

    /* Read the HDR1 block */
    if(!ReadFile(m_hdev, rgbHDR1, sizeof rgbHDR1, &cb, NULL) ||
        cb != sizeof rgbHDR1 ||  *(DWORD *)rgbHDR1 != '1RDH')
    {
        /* Assume end of tape */
        m_fAtEOT = TRUE;
        return FALSE;
    }

    /* Read the HDR2 blck */
    if(!ReadFile(m_hdev, rgbHDR2, sizeof rgbHDR2, &cb, NULL) ||
            cb != sizeof rgbHDR2 ||  *(DWORD *)rgbHDR2 != '2RDH')
        goto fatal;

    /* Seek to the next filemark */
    if(!FSeekToFilemark(1))
        goto fatal;

    /* We only support fixed-record files */
    if(rgbHDR2[4] != 'F')
        goto fatal;

    /* Fetch the filename */
    pch = &rgbHDR1[21];
    *pch = 0;
    while(*--pch == ' ')
        *pch = 0;
    strcpy(szName, (LPSTR)&rgbHDR1[4]);

    /* Report the record and block sizes */
    memcpy(szT, rgbHDR2 + 5, 5);
    szT[5] = 0;
    if(!sscanf(szT, "%d", &m_cbBlkCur))
        goto fatal;
    memcpy(szT, rgbHDR2 + 10, 5);
    szT[5] = 0;
    if(!lpdwDataBlkSize)
        lpdwDataBlkSize = &dwBlkSize;
    if(!sscanf(szT, "%d", lpdwDataBlkSize))
        goto fatal;
    if(!lpdwDataPerPhy)
        lpdwDataPerPhy = &dwDataPerPhy;
    *lpdwDataPerPhy = m_cbBlkCur / *lpdwDataBlkSize;
    /* We'll refuse to deal with files whose physical blocks aren't multiples
     * of data blocks */
    if(*lpdwDataPerPhy * *lpdwDataBlkSize != m_cbBlkCur)
        goto fatal;

    /* Configure the block size */
    mp.BlockSize = m_cbBlkCur;
    if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
        SET_TAPE_MEDIA_INFORMATION, &mp))
    {
        /* The block size in the file is not one that the device likes, so
         * we'll switch to variable block mode and set our buffer to the
         * maximum block size that the device can handle */
        cb = sizeof dp;
        if(NO_ERROR != GetTapeParameters(m_hdev, GET_TAPE_DRIVE_INFORMATION,
                &cb, &dp) || cb != sizeof dp)
            goto fatal;
        m_cbBlkCur = dp.MaximumBlockSize;
        mp.BlockSize = 0;
        if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
                SET_TAPE_MEDIA_INFORMATION, &mp))
            goto fatal;
    }

    /* Allocate the read buffer and we're done */
    m_pbBufCur = new BYTE[m_cbBlkCur];
    if(!m_pbBufCur)
        goto fatal;
    m_ibBlkCur = 0;
    m_cBlkCur = 0;
    m_fAtEOF = FALSE;

    return TRUE;
}

BOOL CTapeDevice::FWriteFileHeaders(BOOL fEOF)
{
    BYTE rgbHDR1[80];
    BYTE rgbHDR2[80];
    TAPE_SET_MEDIA_PARAMETERS mp;
    DWORD cb;
    char szT[8];
    int ich;
    LPSTR szHDR = fEOF ? "EOF" : "HDR";

    if(m_fFatalError)
        return FALSE;

    /* Configure for block writes */
    mp.BlockSize = 80;
    if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
        SET_TAPE_MEDIA_INFORMATION, &mp))
    {
fatal:
        m_fFatalError = TRUE;
        return FALSE;
    }

    /* Contsruct the HDR1 block */
    strcpy(szT, "000000");
    sprintf((LPSTR)rgbHDR1, "%s1%-17.17s      0001%04d000101%s000000 %06d",
        szHDR, m_szFilenameCur, iFile, szT, m_cBlkCur);
    memset(rgbHDR1 + 60, ' ', 20);

    /* Write it out */
    if(!WriteFile(m_hdev, rgbHDR1, sizeof rgbHDR1, &cb, NULL) ||
            cb != sizeof rgbHDR1)
        goto fatal;

    /* Construct the HDR2 block */
    sprintf((LPSTR)rgbHDR2, "%s2F%05d%05d", szHDR, m_cbBlkCur, m_cbRecCur);
    memset(rgbHDR2 + 15, ' ', 65);

    /* Write it out */
    if(!WriteFile(m_hdev, rgbHDR2, sizeof rgbHDR2, &cb, NULL) ||
            cb != sizeof rgbHDR2)
        goto fatal;

    /* Write a filemark */
    if(!FWriteFilemark())
        goto fatal;

    return TRUE;
}

BOOL CTapeDevice::FWriteFile(LPCSTR szName, DWORD dwDataBlkSize,
    DWORD dwDataPerPhy)
{
    BYTE rgbHDR1[80];
    BYTE rgbHDR2[80];
    TAPE_SET_MEDIA_PARAMETERS mp;
    DWORD cb;
    char *pch;
    char szT[8];
    int ich;

    if(!m_hdev || m_fFatalError || !m_fWriteOnly)
        return FALSE;

    if(m_pbBufCur) {
        /* File is open, so close it */
        if(!FCloseFile())
            return FALSE;
    }

    m_cBlkCur = 0;
    m_cbBlkCur = dwDataBlkSize * dwDataPerPhy;
    m_cbRecCur = dwDataBlkSize;
    m_szFilenameCur = _strdup(szName);
    m_fVarBlks = FALSE;
    
    /* Need to upcase the filename */
    for(pch = m_szFilenameCur; *pch; ++pch) {
        if(islower(*pch))
            *pch = (char)toupper(*pch);
    }

    